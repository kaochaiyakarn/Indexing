uml automatic test generation charles jim davies alan hartman thierry laurent oxford university computing laboratory wolfson building parks road oxford ox qd uk crc ale comlab ox ac uk ibm haifa research laboratory hartman il ibm com irisa inria rennes thierry irisa fr verimag centre equation laurent imag fr 
presents architecture model verification testing profile unified modeling language uml 
class object state diagrams define essential models descriptions characterise entire range possible behaviours terms actions events model 
object state diagrams introduce test directives 
models written profile may compiled tool language intermediate format 
descriptions written animated verified generate tests 
illustrating testing architecture adopted defines profile uml explains testing directives basis compilation test generation process reports reports problems encountered 
software systems extremely complex amount information contained system implementation hope comprehend 
true natural world surrounds cope exactly way creating suitable model system working 
suitability model depends intended application 
clearly include piece information relevant purpose try exclude piece information 
model information may difficult comprehend complex automated software engineering 
model entirely suitable purpose may suitable vital piece information may missing 
purposes mind may need different models system 
describe modelling architecture purposes modelbased verification testing 
explain resulting models translated automatically language state machines animated verified basis automatic test generation 
models test directives described unified modeling language uml architecture applied modeling language suitable state machine semantics 
description architecture 
section define uml profile models purposes 
sections explain models compiled intermediate format 
section 
explain principles models generation test suites 
discussion related 
architecture component architecture system model written uml collection class state object diagrams class diagram identifies entities system state diagrams class explain entities may evolve object diagram specifies initial configuration 
second component written uml test directive consists particular object state diagrams object diagrams express test constraints coverage criteria state diagrams specify test purposes 
system model test directives constructed standard toolsets rational rose 
control center 
system model uml class diagram object diagram state diagrams compile test directive uml object diagrams state diagrams state machine fig 

architecture automatic test generation generate model check test suite result api compiler takes model produces collection interacting state machines written intermediate format language 
form machine dictated state diagrams model interaction mimics action event mechanism uml 
representation animated verified model checked tools caesar aldebaran development package cadp 
case test directive describes test model property checked output confirmation property holds explanation 
alternatively representation provided input tgv test generation verification tool 
case state diagram component test directive guide exploration underlying transition system constructed fly necessary state machine description 
tgv provides output tree tabular combined notation standard format telecommunications industry output translated produce test cases language api applications programming interface java see section 
details 
modelling language carried part ec funded project 
reason refer subset uml chosen modelling language aml 
choosing uml primary consideration choosing language accessibility ease 
reach ordinary practitioner modeller tester software industry 
led graphical notation existing industry standard modelling language uml best candidate 
consideration domain appropriateness combination adequacy abstraction 
chosen subset uml rich describe properties wish test 
time include unnecessary constructs complication complexity simple possible 
closely related consideration compositionality 
possible combine models components produce model complete system 
existing semantics uml information achieve extended explanation message passing interaction 
uml uml 
set techniques specification visualisation documentation 
language primarily object oriented methodology concepts added harel language statecharts petri nets message sequence charts sdl 
important aspect uml presence variation points language semantics definition language intentionally incomplete interpretation required model written uml basis formal analysis automatic test generation 
required instantiation 
uml include language data types operations written target language specification normally imperative programming language 
wish compile models define target language 
target language target language 
operations actions data types written basic subset syntax accessible familiarity imperative programming languages 
obvious advantages choice diagrams target language language implementation java compiler focus translation state machines interpretation uml actions need translate primitives 
translation implementation language api java syntax easily automated 
aspect invites user intervention choice data representation 
primitive types defined include standard datatypes integers arrays records 
user intervention required may desirable 
attributes class diagrams profile attributes may observable values observable attributes may inspected point test 
default attributes observable indicate adding tag 
operations may observable occurrence operation return value recorded projected model 
furthermore may controllable indicating may called outside system test may tag indicate 
associations place data attributes class type 
class diagram association represented solid line classes 
associations may annotated roles attribute name reveals formal name object closer class context object class 
object diagrams object diagram shows state system certain point time collection objects particular state 
object diagrams describe initial configuration system model specify starting configuration test directive flag configurations inclusion exclusion test model 
object diagram notation similar class notation compartments rectangle 
state object may constrained assertion state name corresponding state diagram constraining values attributes 
presence link objects indicates communication possible call actions object produce call events send actions object produce signal events 
link may decorated information roles attribute name link reveals name context closer object object 
annotate object diagram representing initial state system stereotype initial 
state diagrams state diagram shows object react arrival event 
reaction may sequence actions possibly accompanied transition named state 
event represents receipt signal effect operation call 
action represents sending signal call operation 
diagram state represented rectangle rounded corners 
simplify presentation may factor transition information rectangles actions common incoming transition may included entry actions state actions common outgoing transition may included exit actions 
transition mention particular action self transitions may internal transitions proceed factorisation 
internal transition represented name event followed action expression 
optional guard boolean valued expression tells particular occurrence event trigger specified actions false fact event occurred simply forgotten 
general event occur guard evaluated value guard may depend values attributes event 
transition may annotated event guard action expression 
transition begins fires occurrence trigger event 
guard evaluated action list considered prove false change state take place sense transition cancelled 
guard guard true exit actions source state performed followed actions transition entry actions target state 
outgoing transitions enabled time labelled event requires event guards true may fire 
state diagrams cope easily phenomenon nondeterminism 
actions call action action stimulus call event created trigger action sequence object 
call actions synchronous caller waits event processed resuming execution 
send action creates stimulus time signal event 
send actions asynchronous caller proceeds waiting event processed 
class diagram may include tag name compartment indicate events observable controllable sent environment 
indicate classes signal events label class stereotype signal 
send call actions name target object scope state diagram 
declared attribute names role name far link association 
case object diagram role name needed identify callee object object left anonymous known different name inside state diagram current object 
role names needed class diagrams object performing particular role created test phase case named initial object diagram 
test directives introduce diagrams express test directives 
compilation directives described section inputs provided test generation tool aml compiler section 
test directives consist distinct parts test purposes test constraints coverage criteria 
test purposes describe behaviours wants test 
aml test purpose represented state diagram number special states 
steer test generator selection relevant execution sequences 
label state diagram forms part test directive stereotype test need stereotype state diagrams define system model corresponding class classifier 
test constraints describe additional restrictions test cases wants generate steering test generator selection relevant execution sequences 
test constraints described object diagrams 
propose kinds test constraints include express state sequences specification selected test generation satisfy constraint constraints specified object diagrams stereotyped include 
exclude express state sequences specification selected test generation satisfy constraint corresponding object diagrams stereotyped exclude 
start give global constraint start state expected test case defines preamble described object diagrams stereotyped start 
give global constraint termination state expected test case defines object diagrams stereotyped 
coverage criteria describe coverage requirements generating sets test cases 
precisely constraint expressed set expressions object variables 
reachable combination expression values test case generated state selected sequences satisfies constraint 
coverage criteria viewed possibly huge set include constraints 
compilation intermediate format language developed sit high level specification languages sdl promela 
internal representations 
representations passed tools translated languages example sdl specifications analysed spin model checker 
translating high level languages may allow extend fix open parts semantics example give precise timed semantics sdl 
choice intermediate format aml modelling language test generation tool motivated arguments allows re tools developed environment 
particular existing simulation engine able generate fly underlying labelled transition systems associated description front test generation tool 
offers relative flexibility defining aml semantics aml construct translation schemes foreseen independently simulation engine 
easy define aml semantics incremental way extend compiler accordingly 
potential loss efficiency caused intermediate representation performing simulation directly aml level largely compensated optimization tools available level 
fact previous experience sdl demonstrated static analysis techniques gave efficient simulator existing ones 
particular model test generation advantageously combined slicing techniques 
objects specification represented extended finite state machine process instance 
state process values local variables private processes evolve communicate sending receiving asynchronous signals specified instances 
process instances created statically system initialisation dynamically run time 
reliable lossy peer peer multicast fifo multiset timely delayed 
uml arrival signal may trigger transition states accompanied specified sequence actions 
sequence may involve sending signals processes changing values local variables 
process compilation revolves state diagrams model transformed process 
initial start object diagram model test defines initial configuration processes 
class diagram provides information data types operations 
translation defines effective semantics uml language state diagrams 
need define signal operation acknowledgment signal including return value parameter synchronous operation communications asynchronous process object model communication buffer object 
states state state diagram translated control state stability initiality attributes 
state marked unstable transaction state transition transition treated atomic system 
state marked initial treated initial state process 
start state state diagram init state finish state state transitions 
translate simple state append entry actions incoming transition prepend exit actions outgoing transition transform internal transition external self transition entry exit actions 
transitions having mapped object states construct transition transition state diagram input guard action output ack newstate output clause response synchronous operations modeled call actions 
events call event represents operation invocation caller notified completion provided return value 
translate call events signal inputs input operation name list buffer operation name operation current object list list variables received parameters stored buffer name buffer event read 
achieve synchronisation caller object add symmetrical action signal input representing call event sending appropriate completion return signal caller 
signal event represents reception uml signal model asynchronous communication 
translate signal events directly signal inputs input signal list buffer time matching action 
guards translated post guarded inputs received parameters tested guard evaluated input done false execution transition disabled restricting values process willing accept 
modeling language guards expressed expressions 
actions translate call action add additional stable state representation object 
state object issued call operation return 
state diagram transition state labelled call action obtain representation form state input event input ack guard state action send action output output signal parameters effect appending specified signal buffer associated target object 
test generation test generation tool principles existing tools tgv 

tools different principles summarised describe principles adapted combined test generation tool 
tgv tgv test generation tool developed verimag irisa 
sound testing theory 
theory test generation algorithms ensure conformant implementation rejected test case theoretically possible generate test case reject non conformant implementation 
models specifications input output labelled transition systems inputs outputs internal events distinguished 
behaviour implementation test unknown black box suppose modelled 
conformance relation ioco defines correct implementations respect specification allow detection incorrect quiescence timers test cases ioco defined terms traces suspension automata 
built addition loops labelled new output quiescent state livelock deadlock absence output 
ioco trace including outputs included main inputs tgv specification test purpose tp test selection 
tp complete automaton accept reject states 
accept states select behaviours wants test reject states may prune exploration labels tp regular expressions matching labels particular label meaning 
test generation process composed operations 
product tp common actions mark states accept reject states tp 
operation may unfold second operation computes suspension automaton tp propagating marking state sets 
result deterministic observable traces accept reject states mark behaviours accepted rejected tp 
selection operation builds possible objects complete test graph consisting traces leading accept pass verdict associated plus divergences traces outputs giving rise inconclusive verdict alternatively test case tc subgraph obtained additional constraint test cases conflicts choices output action 
cases state tc output observable fail implicit unspecified outputs 
mirror image tc applied inverts inputs outputs 
knowledge tgv test generation tool generate test cases loops restricted sequences trees 
tgv accepts optional files define test architecture 
rename file rename labels hide file specifies unobservable actions io file distinguishes inputs outputs observable actions 
files support regular expressions 
additional options may tune test generation process exploration depth computation priorities order exploration transitions synthesis timer operations start cancel timeout 
order avoid state explosion specification implicitly simulation api functions traversal 
case test generation operations applied sequence fly cases conflict resolution 
necessary parts ofs tp built 
consequently tgv different specification languages soon simulation api produced compiler language 
done sdl lotos caesar compiler inria grenoble uml umlaut tool compiler 
tgv accepts specifications form explicit graphs bcg aldebaran formats 
test cases produced bcg aldebaran format pseudo sdl specifications 
test generation tool developed ibm research laboratory haifa 
extension mur model checker 
main differences tgv specification model describes observable behaviour system internal behaviour 
model finite state machine edges labelled inputs states labelled control state values observable variables 
test generation process traversal finite state machine directed coverage criteria test constraints 
coverage criteria state space defined expressions subsets variables control states 
state graph conceptual built explicitly 
state coverage criterion boolean expression state transition coverage criterion pair boolean expressions source target states transition 
criteria transformed finite set coverage tasks instantiate conditions 
phase test generation determines specified coverage tasks reachable chooses random representative reachable task 
test generation engine covers tasks set paths specification 
test constraints may restrict test sequences limit reachable set states transitions finite state machine 
possible forbid traversal state satisfies condition forbid certain paths satisfy boolean conditions middle length 
traversal strategies including fly coverage directed traversal 
test cases computed sequences composed actions expected values observable variables 
non deterministic transi tions test case dealt inconclusive outcome pass fail outcomes test case 
principles test generation tool project developing test generation engine combines principles tgv test selection test purposes test constraints coverage criteria 
test cases allow combination observations outputs tgv values variables 
input test generation process model obtained translation uml model 
model contains specification system test directives test architecture 
additionally mapping uml objects generated allowing description test cases terms uml objects 
test architecture consists list controllable signals calls list observable signals calls variables corresponding io hide files tgv 
sequel focus different test directives test generation 
test directives test directives identify particular behaviours specification wants test 
tool uses kinds directives test purposes la tgv test constraints coverage criteria la 
test purposes test constraints combined test constraints coverage criteria 
notice case dynamic creation test directives paired set process instances considered 
test purposes similar goal observers 
described extended automata syntax accept reject states preamble markers 
transitions labelled asynchronous inputs outputs synchronous calls guards assignments referring specifications objects private variables 
test constraints composed operator boolean predicates specification variables control states 
kinds operators include bool expr means state selected sequence satisfy constraint exclude bool expr means state satisfy constraint start bool expr bool expr define test cases 
coverage criteria specified boolean expressions states transitions state graph defined expressions finite codomains control states variables 
reachable combination expressions covered sequence described 
test generation test generation engine tgv extended ways 
test directives refer specification variables control states boolean predicates guards compiled linked specification system simulation api 
simulation api test generation engine consists functions construction observation product specification test purposes constrained test constraints specification constrained coverage criteria 
product specification test purpose different tgv 
order avoid unnecessary intermediate states transition specification may consist atomic sequence actions possibly starting input followed outputs internal actions 
transition test purpose contains action observable transition matches transition specification contains event 
hiding test architecture treated differently hide actions transition necessarily actions 
tgv tp states just identifiers 
values variables may observable states tp carry vector values observable variables 
state set states carries set vectors values defines set correct observations observable variables 
set attached corresponding state test case selected 
observations lead fail verdict 
test selection process incorporates tgv mechanisms 
test purpose builds test case complete test graph satisfying test constraints 
case coverage criteria builds set test cases test graph covering reachable coverage tasks 
avoid redundancy computation test purposes coverage criteria processed 
breadth depth traversal strategies onthe fly possible 
discussion described progress 
architecture defined aml compiler written 
modelling aml currently done industrial partners 
project carried part eu funded project acronym formed phrase automated generation execution test suites distributed component software 
project involves industrial academic research centres 
coordinated ibm research haifa academic contributors university oxford irisa universit joseph fourier grenoble 
industrial partners france telecom ibm uk international luxembourg ag germany 
aim project develop methods tools automation software testing particular emphasis testing distributed component systems project started november expected run october 
academic contribution define modelling language describe suitable semantics address problems complexity design implement new test generation tool existing ones 
related prospect degree automation testing process clearly attractive 
computing pervasive critical lives time designs complex interactions components harder measure predict 
software testing difficult expensive 
considerable amount research carried application finite state machine fsm notations testing test generation particularly regard testing communicating systems 
research solves fundamental problems testing attempt address problems scale complexity encountered modern software engineering 
research theories testing statecharts 
methods behavioural model generation toolkits automated testing packages generating input sequences testing user interfaces taken pragmatic industrial approach 

presents architecture precursor adopted project 
exist tools generation test cases uml models 
umlaut tgv 
tool umlaut provides simulation api tgv test generation tool suffers limitations considered uml subset tgv limitations expression test directives 
main advantage test generation tool ability combine different test directives coverage criteria test purposes test constraints 
allows user tune selection test cases respect budget test campaign 
hierarchy test suites constructed property larger test suite greater coverage implementation 
hierarchy particularly useful regression testing 
combines coverage test purposes sdl coverage limited branch coverage 
reports success automated test case generation 
examples 
includes comment questions remained scalability approach state machine approach 
appropriate circumstances 
focus research exactly working scalable methods automated test generation object oriented principles building fundamental research world finite state machines 

cl fernandez 
static analysis improve automatic test generation 
graf schwartzbach editors proceedings tacas berlin germany lncs pages 
springer march 

graf roux vincent 
timed extensions sdl 
proceedings sdl forum lncs 
appear 

ed brinksma 
iso specification language lotos 
computer networks isdn systems 

rational software 
rational rose 
june www rational com 

ibrahim khalil ibrahim el far 
automated construction software behavior models 
master thesis american university 

hartman pinter 
model test generator test standard conformance 
ibm system journal special issue software testing 
appear 
currently available www haifa il ibm com projects verification publications html 

feather smith 
automatic generation test oracles pilot studies application 
automated software engineering january 

jean claude fernandez claude thierry cesar 
experiment automatic generation test suites protocols verification technology 
science computer programming 
citeseer nj nec com html 

fernandez 
cadp protocol validation verification toolbox 

gregor 
protocol testing review methods relevance software testing 

gronau hartman 
methodology architecture automated software testing 
www haifa il ibm com projects verification papers pdf 

object management group 
unified modeling language uml draft february 
www omg org cgi bin doc ad 

david harel eran 
executable object modeling statecharts 
proceedings th international conference software engineering pages 
ieee computer society press 
citeseer nj nec com article harel executable html 

gerard holzmann 
model checker spin 
ieee transactions software engineering may 

itu 
recommendation 
specification description language sdl 
technical report international telecommunication union standardization sector gen november 

ron 
quel le 
validation test generation object oriented distributed software 
ieee proc 
parallel distributed software engineering kyoto japan april 

ron morel 
test generation derived model checking 
nicolas halbwachs doron peled editors cav trento italy volume lncs pages 
springer verlag july 

project 
www de 

microsoft robinson intelligent search test group 
applying models testing process 
information software technology 


control centre 
june www com 

tretmans 
test generation inputs outputs repetitive quiescence 
software concepts tools 
