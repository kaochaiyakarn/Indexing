journal artificial intelligence research submitted published generalizing boolean satisfiability iii implementation dixon dixon ginsberg ginsberg comon time systems suite eugene usa david hofer hofer cs uoregon luks luks cs uoregon information science university usa andrew parkes parkes cirl uoregon edu cirl university oregon eugene usa third papers describing zap satisfiability engine existing tools retaining performance characteristics modern highperformance solvers 
fundamental idea underlying zap problems passed engines contain rich internal structure obscured boolean representation goal define representation structure apparent exploited improve computational performance 
surveyed existing knowingly exploited problem structure improve performance engines second showed structure understood terms groups permutations acting individual clauses particular 
conclude series discussing techniques needed implement ideas reporting performance variety problem instances 

third series papers describing zap satisfiability engine substantially generalizes existing tools retaining performance characteristics modern high performance solvers zchaff moskewicz madigan zhao zhang malik :10.1.1.24.7475
papers series arguments effect boolean satisfiability problems incorporate rich structure reflects properties domain problems arise improvements performance satisfiability engines understood terms ability exploit structure dixon ginsberg parkes refer zap 
structure understood terms groups algebraic sense permutations acting individual clauses dixon ginsberg luks parkes refer zap :10.1.1.71.4933
cfl ai access foundation 
rights reserved 
dixon ginsberg hofer luks parkes showed implementation ideas expected combine attractive computational properties variety ideas including efficient implementations unit propagation zhang stickel extensions boolean language include cardinality pseudo boolean constraints barth dixon ginsberg hooker parity problems tseitin limited form quantification known ginsberg parkes 
discuss implementation prover ideas describe performance pigeonhole parity clique coloring problems 
classes problems known exponentially difficult conventional boolean satisfiability engines formalization highlights group nature reasoning involved 
technical point view difficult zap papers need draw algorithms theoretical constructions zap results computational group theory gap group seress regarding implementation 
plan describing implementation follows 
section review material zap 
section presenting boolean satisfiability algorithms hope generalize basic algebraic ideas underlying zap 
section describes group theoretic computations required zap implementation 

section gives brief necessarily incomplete ideas computational group theory 

sections describe implementations computations discussed section 
basic construction describe algorithm give example computation action 
existing implementation public domain system gap provide pointer implementation concepts needed implement scratch additional detail provided 

section extends basic algorithms section deal unit propagation want compute single unit clause instance list unit consequences augmented clause 

section discusses implementation zhang stickel watched literal idea setting 

section describes technique select possible resolvents augmented clauses 
functionality analog conventional prover single ground reason truth falsity variable 
reasons augmented clauses may variety ways ground instances clauses combined 

describing algorithms experimental results regarding performance sections 
section reports performance zap individual algorithmic components section contrasts zap performance cnf predecessors focus algorithms 
description zap input language contained appendix zap implementation needed zap report performance relatively theoretical examples clearly involve group reasoning 
performance wider range problem classes reported 

concluding remarks appear section 
section proofs generally deferred appendix interests maintaining continuity exposition 
importance computational group theory ideas presenting strongly suggest reader proofs section 
long complex apologies 
zap attempt synthesize different fields complex right computational group theory implementations boolean satisfiability engines 
computational group theory addition inherent complexity foreign ai audience 
complete algorithms boolean satisfiability increasingly sophisticated past decade substantial modifications original dpll algorithm relevance bounded learning bayardo miranker bayardo schrag ginsberg watched literals zhang stickel 
bring fields see wide range techniques computational group theory relevant problems interest goal simply translate dpll new setting show boolean satisfiability moved 
case lemma need extend existing computational group theory results 
new satisfiability techniques possibilities arise synthesis proposing section describe 
intended self contained 
assume reader familiar material zap results repeated convenience accompanying text intended stand 
spite previous paragraphs intended complete 
goal practical minimum required implement effective group reasoning system 
results obtained theoretical described zap practical described excite 
just excited number issues explored 
primary goal foundation needed interested researchers explore ideas 

zap fundamentals basic structure overview zap involves summarizing distinct areas existing boolean satisfiability engines group theoretic elements underlying zap 
boolean satisfiability description architecture modern boolean satisfiability engines 
start unit propagation procedure describe follows dixon ginsberg hofer luks parkes definition boolean satisfiability problem described terms set clauses partial assignment assignment values true false subset variables appearing represent partial assignment sequence consistent literals appearance vi sequence means vi set true appearance vi means vi set false 
annotated partial assignment sequence li ci ci reason associated choice li 
ci true means variable set result branching decision ci clause entails li virtue choices previous lj annotated partial assignment called sound respect set constraints ci reason ci 
see zap additional details 
possibly annotated partial assignment denote literals satisfied set literals unvalued procedure unit propagation compute unit propagate set clauses annotated partial assignment 
ln cn li literal highest index return htrue resolve ci literal unassigned hp return hfalse result returned depends contradiction encountered propagation result returned true contradiction false 
case clause unvalued literals line li literal set ci reason li set way caused unsatisfiable 
resolve ci return result new nogood problem question 
eventually return partial assignment augmented include variables set propagation process 
unit propagation inference procedure procedure relevance bounded learning rbl sat problem set learned nogoods annotated partial assignment compute rbl zap implementation hx yi unit propagate true empty return failure remove successive elements unit learn return rbl solution return literal assigned value return rbl hp true expected procedure recursive 
point unit propagation produces contradiction currently unspecified learn procedure incorporate solver current state recurse 
empty means derived contradiction procedure fails 
backtracking step line backtrack just satisfiable enables unit propagation 
technique zchaff moskewicz 
leads increased flexibility choice variable assigned backtrack complete generally improves performance 
unit propagation indicate presence contradiction produce solution problem question pick unvalued literal set true recurse 
note don need set literal true false eventually need backtrack set false handled modification line 
need procedure incorporate new nogood clausal database order definition definition ili clause denote partial assignment 
say possible value poss li ambiguity possible write simply poss poss 
words poss number literals satisfied valued reduced clause requires true literal 
note poss expression number potentially satisfied literals possible value clause essentially measure authors called irrelevance bayardo miranker bayardo schrag ginsberg 
unsatisfied clause poss unit propagation say clause unit 
poss means change single variable lead unit propagation 
notion learning relevance bounded inference captured dixon ginsberg hofer luks parkes procedure set clauses annotated partial assignment compute learn result adding clause removing irrelevant clauses remove poss return hope familiar please refer zap papers cited fuller explanations 
zap continue procedures approximately current form replace idea clause disjunction literals augmented clause definition augmented clause variable boolean satisfiability problem pair boolean clause group wn 
clause instance augmented clause cg clause called base instance 
roughly speaking augmented clause consists conventional clause group permutations literals theory intent act clause element group get clause part original theory 
group required subgroup group permutations harrison wn sn permutation permute variables problem flip signs arbitrary subset 
showed zap suitably chosen groups correspond cardinality constraints parity constraints group flips signs number variables universal quantification finite domains 
lift previous procedures augmented setting 
unit propagation example checking see clause unit assignments check see augmented clause unit instance 
procedure essentially unchanged procedure procedure unit propagation compute unit propagate set clauses annotated partial assignment 
ln cn cg cg cg li literal cg highest index return htrue resolve cg ci literal cg unassigned hp cg return hfalse basic inference procedure virtually unchanged 
zap computational group theory community denote image clause group element cg possibly familiar 
explained zap reflects fact composition fg permutations acts second 
zap implementation procedure relevance bounded learning rbl sat problem set learned clauses annotated partial assignment compute rbl hx yi unit propagate true empty return failure remove successive elements unit learn return rbl solution return literal assigned value return rbl hp true line unit propagation returns augmented clause base instance reason backtrack virtue line procedure 
follows line procedure unchanged boolean version 
lift procedure setting need augmented version definition definition augmented clause partial assignment 
poss mean minimum possible value instance poss ming poss cg procedure unchanged augmented clause simple 
effect definition cause remove augmented clauses instance irrelevant 
presumably useful retain clause long relevant instance 
zap showed proof engine built procedures properties number generators group logarithmic group size achieve exponential improvements basic representational efficiency 
relevant nogoods retained search proceeds memory requirements remain polynomial size problem solved 
produce polynomially sized proofs pigeonhole clique coloring problems parity problem 
generalizes order inference provided quantifiers universal domains quantification finite 
stated proof show unit propagation procedure implemented way generalizes ginsberg parkes zhang stickel watched literal idea 
dixon ginsberg hofer luks parkes group theoretic elements examining procedures elements new relative boolean engines 
line unit propagation procedure need find unit instances augmented clause 

line procedure need compute resolvent augmented clauses 

line learning procedure need determine augmented clause relevant instances 
third needs different second 
resolution need definitions definition permutation set sp mean restriction set say lifting back original set acts 
definition set omega denote sym omega group permutations omega sym omega subgroup group omega say acts definition suppose acts set orbit denoted xg xg xg 
closure denoted set tg definition 
kn omega 
gn sym omega say permutation sym omega stable extension 
gn 
kn gi gi gi gi denote set stable extensions 

kn stab ki gi 
set stable extensions stab ki gi closed composition subgroup sym omega 
definition suppose augmented clauses 
result resolving denoted resolve augmented clause resolve stab ci gi wn 
follows definitions computing resolvent augmented clauses required procedure essentially matter computing set stable extensions groups question 
return problem section 
problems viewed instances 
convenience depart standard usage permit map points images outside zap implementation definition clause viewed set literals group permutations acting fix sets literals integer say problem finding cg cg reporting exists 
find unit instance set set satisfied literals set unvalued literals 
implies searching instance satisfied unvalued literal 
find relevant instance set set satisfied unvalued literals 
relevance bound corresponds search relevant instance 
remainder theoretical material focused problems computing stable extensions pair groups solving transporter problem 
discuss techniques solve problems brief overview computational group theory generally 

computational group theory group theory large computational group theory specifically study effective computational algorithms solve group theoretic problems far broad allow detailed presentations single journal 
generally refer theory groups general information seress permutation group algorithms computational group theory specifically excellent texts areas 
abbreviated group theory zap 
substitute goal provide general understanding computational group theory possible examples follows 
mind basic ideas hope convey 
stabilizer chains 
underlie fundamental technique large groups represented efficiently 
underlie subsequent computations done groups 

group decompositions 
group subgroup natural way partition partitions partitioned subgroup gradual refinement underpins search group algorithms developed 

lex leader search 
general possible establish lexicographic ordering elements permutation group searching element group having particular property transporter problem assume loss generality looking element minimal ordering 
allows search pruned portion search shown contain minimal element eliminated 
dixon ginsberg hofer luks parkes stabilizer chains fact group described terms exponentially smaller number generators attractive representational point view issues arise large set clauses represented way 
fundamental simple membership tell fixed clause instance augmented clause 
general instance transporter problem need cg image intersect complement 
simpler clearly related problem assumes fixed permutation cg 
representation terms simply generators obvious determined quickly 
course represented list elements sort elements lexicographically binary search determine included 
virtually problem interest solved time polynomial size groups involved better solving problems time polynomial total size generators generally polynomial logarithm size groups polylog size original clausal database 
call procedure polynomial polytime number generators size set literals acts 
polynomial procedures assured zap representational efficiencies mature computational gains membership problem determining representation terms generators need coherent way understanding structure group 
suppose subgroup group sym omega symmetries set omega enumerate elements omega omega 
ln 
subset fixes lh 
easy see closed composition elements fix composition 
follows subgroup fact definition group acting set omega subset omega point stabilizer subgroup gl lg set stabilizer subgroup lg having defined point stabilizer go define point stabilizer fact point stabilizer similarly define point stabilizer li construct chain stabilizers group necessarily trivial points omega stabilized point 
want describe terms generators assume describe terms generators furthermore generators superset generators 
subgroup 

development computationally efficient procedures solving permutation group problems appears begun sims pioneering stabilizer chains 
zap implementation definition strong generating set group sym 
ln set generators property hs 
usual denotes group generated gi 
easy see generating set strong just case property discussed generated incrementally generators fact elements 
example suppose symmetric group elements denote 
hard see generated cycle transposition strong generating set 
subgroup stabilizes isomorphic randomly permute remaining points hs want strong generating set need add similar permutation generating set hs slightly interesting example 
permutation possible write permutation composition transpositions 
possible construction maps supposed go ignores rest construction 
example order composition left right maps virtue transposition left unaffected 
representation permutation terms transpositions unique parity number transpositions permutation represented product odd number transpositions 
furthermore product transposition products lengths obviously represented product length follows product permutations definition alternating group order denoted subgroup permutations sn 
strong generating set 
fix points transposition obviously odd trivial group 
smaller get subset generators operating necessary transposition 
hard dixon ginsberg hofer luks parkes see cycle odd consider strong generating set 


sn strong generating set odd 





simplify expressions slightly get 


odd 



strong generating set easy compute size original group need known definition result definition groups define hg set hg say hg right coset proposition hg hg cosets hg hg cosets identical disjoint 
words subgroup group cosets partition leads definition groups index denoted number distinct cosets corollary finite group cosets partition original group natural think defining equivalence relation ss belong coset proposition ss xy proof 
xy coset hg coset 
conversely hg coset xy hh equivalence relations groups form 
ss right invariant equivalence relation elements group ss xz ss yz cosets define equivalence relation 
returning stabilizer chains recall denote lg orbit li set points maps 
zap implementation proposition group acting set 
ln associated stabilizer chain lg proof 
know inductively easy see distinct cosets correspond exactly points maps li lg result follows 
note expression easy compute strong generating set 
example strong generating set clear orbit size 
orbit size orbit size 
total size group 
hardly surprise 
strong generating set 
orbit clearly size orbit size 

general course exactly cosets alternating group odd permutations constructed multiplying permutations fixed transposition 
evaluate size strong generators realizing orbit size size orbit size 
orbit size transposition 

strong generating set test membership way 
suppose group described terms strong generating set stabilizer chain specific permutation 
possibilities 
orbit clearly 
orbit select construct fixes determine recursively 
process stabilized elements moved 
original procedure known sifting 
continuing example see cycle 
see produces conclude hardly surprise 
dixon ginsberg hofer luks parkes second know get 
obviously odd continue procedure 
fixed 
moved trivial group conclude correctly 
coset decomposition group problems considering transporter problem subsume described zap dixon ginsberg parkes 
known np hard follows transporter 
suggests group theoretic methods solving involve search way 
search involves potential examination instances augmented clause group theoretic terms potential examination member group computational group theory community approaches search problem gradually decomposing smaller smaller cosets 
call coset decomposition tree produced root tree entire group leaf nodes individual elements definition group stabilizer chain 
coset decomposition tree tree vertices ith level cosets parent particular coset contains 
particular level cosets correspond points sequence hl 
lii mapped points image li identifying children particular node level 
example suppose consider augmented clause sym corresponding collection ground clauses suppose working assignment true false trying determine instance unsatisfied 
assuming take coset decomposition tree associated zap implementation delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta aa aa aa aa aa aa aa aa aa aa aa aa iiii iiii iiii gamma gamma gamma gamma gamma gamma pppp pppp pppp theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta theta pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi ee ee ee ee ee ee ee ee ee ee ee ee bb bb bb bb bb bb bb bb bb bb bb bb sym sym ab ac ad sym bc bc bc bc bd bd bd bd cd cd cd cd cd cd cd cd cd cd cd cd explanation notation surely order 
nodes lefthand edge labeled associated groups example node level labeled sym point fixed allowed vary 
move row find representatives cosets considered 
moving second row entry ab means coset basic group sym obtained multiplying element ab right 
coset maps uniformly lower rows multiply coset representatives associated nodes leading root 
third node third row labeled bd corresponds coset sym bd elements coset bd cd bd 
point uniformly mapped fixed fixed mapped fourth point row corresponds coset sym ab ab cd ab point uniformly mapped uniformly mapped swapped 
fifth point coset sym bc ab sym abc abc abcd uniformly mapped uniformly mapped mapped fourth line basic group trivial single member coset obtained multiplying coset representatives path root 
ninth tenth nodes marked asterisks tree correspond permutations abc abcd respectively partition coset 

occasionally denote group multiplication operator explicitly improve clarity typesetting 
dixon ginsberg hofer luks parkes understanding structure search straightforward 
root original augmented clause may unsatisfiable instances 
move child know image instance clause question true assignment question follows clause satisfied 
similar way mapping produce satisfied clause 
search space reduced delta delta delta delta delta delta delta delta delta delta delta delta aa aa aa aa aa aa iiii iiii iiii gamma gamma gamma gamma gamma gamma pppp pppp pppp theta theta theta theta theta theta theta theta theta theta theta theta pi pi pi pi pi pi pi pi pi pi pi pi ee ee ee ee ee ee bb bb bb bb bb bb sym sym ab ac ad bc bc bd bd cd cd cd cd cd cd map point row corresponds mapping producing satisfiable clause 
map node mapped node mapped permutation ac labeling parent get satisfiable clause 
map eventually get unsatisfiable clause clear recognize expanding children 
case mapped similar final search tree delta delta delta delta delta delta delta delta delta delta delta delta aa aa aa aa aa aa iiii iiii iiii gamma gamma gamma gamma gamma gamma pppp pppp pppp pi pi pi pi pi pi ee ee ee bb bb bb sym sym ab ac ad bc bc bd bd cd cd zap implementation clauses need examined instances original leaf nodes need considered 
internal nodes pruned pruned generation values need considered necessarily unsatisfied literals theory 
level search space aa aa aa pppp pppp pppp pi pi pi pi pi pi ee ee ee bb bb bb sym ac ad bc bd cd cd lex leaders remaining search space example examines fewer leaf nodes original appears redundancy 
understand possible simplification recall searching group element cg unsatisfied current assignment 
group element suffices wish search group element smallest lexicographic ordering group definition sym omega group omega 
ordering elements omega write ordering defined definition total order immediately lemma sym omega ordered set omega unique minimal element 
minimal element typically called lexicographic leader lex leader example imagine solution group element corresponding unsatisfied instance right hand node depth 
necessarily analogous solution preceding node depth search spaces sense identical 
hypothetical group elements identical images swapped 
group elements left hand node precede right hand node lexicographic dixon ginsberg hofer luks parkes ordering follows lexicographically element re looking right hand node pruned 
search space aa aa aa pppp pppp pppp bb bb bb sym ac ad bd cd particular technique quite general searching group element particular property restrict search lex leaders set elements prune search space basis 
seress provides complete discussion context problems typically considered computational group theory example context transporter problem specifically section 
note remaining leaf nodes equivalent refer instance know images instance fixed choices relevant 
assuming variables problem ordered clause considered prune search depth get aa aa aa pppp pppp pppp sym ac ad bd single leaf node need considered 
return application ideas zap stress scratched surface computational group theory 
field broad zap implementation developing rapidly implementation zap ideas appear seress gap code 
name chosen reflect zap heritage outgrowth zchaff gap 
augmented resolution turn zap specific requirements 
definition augmented resolution involves computing group stable extensions groups appearing resolvents 
specifically augmented clauses need compute group stable extensions 
recalling definition group permutations property cg similarly 
viewing clauses ci sets closure ci gi recall definition 
example consider clauses ad bf bg closure cg 
need find permutation restricted element ofh ad bf restricted element bg second condition know moved permutation acceptable bg generate symmetric group sym 
second restriction impact image 
condition know swapped left unchanged permutation acceptable 
recall second condition permute conditions combine imply move move break condition 
swap group stable extensions ad construction return 
procedure augmented clauses compute stab ci gi 
authors zchaff moskewicz madigan zhao zhang malik selection include acronym surely unfair moskewicz madigan malik 
didn quite ring hope implicitly excluded authors accept apologies choice 
dixon ginsberg hofer luks parkes closure cg closure cg restrict closure restrict closure closure closure stab restrict stab restrict int stab stab gi generators int gi lifted stab gi lifted stab closure return hg restrict restrict proposition result returned procedure stab ci gi 
proof appendix example computation discuss computational issues surrounding procedure 
example began section modify ad bf xy earlier ad bf new points don affect set instances way affect resolution computation 

cg amounts computing closures ci gi described earlier closure closure 

gi restrict group act corresponding 
example restrict restrict ad bf irrelevant points removed 
note possible restrict group arbitrary set restrict permutation xy set need add 
case possible restrict gi set closed action group 

closure closure 
construction works considering separate sets intersection closures original clauses computation interesting various agree points closure closure 
analysis sets straightforward just need agree element set question 
step compute intersection region 
example 


find subgroup set stabilizes case subgroup set stabilizes pair 
restrict ad bf ad longer swap restrict bg get stab 
int stab stab simultaneously agree restricted restrict restrict restriction lie intersection 
example int zap implementation 
gi generators int 
element int lead element group stable extensions provided extend appropriately back full set cg cg step begins process building extensions 
suffices just generators int construct generators 
gi 

gi lifted 
goal build permutation closure closure restricted matches generator gi 
lifting gi separately closure closure 
lifting suffices take example ad case inclusion swap precluded required just 

closure 
simply compose get desired permutation closure closure part permutations acting intersection closure closure acted twice 
case get ad longer captures freedom exchange deal restricting away combining 
example restricting away produces trivial permutation 

return hg restrict restrict compute final answer sources combined working construct elements restrict fix point closure elements restrict fix point closure 
sets obviously consist stable extensions 
element restrict point stabilizes closure point stabilizes points closure restrict restricted closure words point stabilizes 
example restrict ad restrict ad final group returned ad ad group identical obvious ad dixon ginsberg hofer luks parkes swap pair pair see fit 
swap ad sanctioned resolvent ad bf mention relevant variable second bg 
second swap sanctioned cases 
computational issues conclude section discussing computational issues arise implement procedure including complexity various operations required 

efficient algorithms exist computing closure set group 
basic method flood fill approach adding marking result acting set single generator recurring new points added 

gi group restricted set stabilizes restricting generating permutations individually 

closure closure 
set intersection straightforward 


set stabilizer straightforward known polynomial total size generators group considered seress effective implementations coset decomposition described section computing set node pruned maps point inside vice versa 
gap implements see comments section 

int stab stab 
group intersection known polynomial total size generators coset decomposition 
coset decompositions constructed groups combined search spaces pruned appropriately 
gap implements 

gi generators int 
groups typically represented terms generators reconstructing list generators trivial 
generators known constructing strong generating set known polynomial number generators constructed 

gi lifted 
suppose group acting set subset permutation acting know restriction find construct stabilizer chain ordering puts elements 
basically looking sifting procedure section produces point points fixed 
find polynomial time inverting sifting procedure 

closure 
line restriction easy 

transporter problem mentioned section np hard set stabilizer group intersection see step np hard babai moran 
zap implementation 
return hg restrict restrict groups typically represented generators need simply take union generators arguments 
point stabilizers needed arguments straightforward compute stabilizer chains 

unit propagation ir relevance test remarked main computational requirement augmented satisfiability engine ability solve transporter problem augmented clause viewed set literals sets literals integer want find cg cg exists 
warmup somewhat simpler problem assuming simply looking cg 
need definitions definition groups 
transversal subset contains element coset denote transversal 
note cosets transversal contain unique element generally assume identity unique element 
definition suppose acts set omega omega cg denote elements fixed search proceeds gradually fix points clause question 
notation definition refer easily points fixed far 
procedure groups element sets find group element map cgt cth return failure ch return ff element ch hff map hff failure return rt return failure dixon ginsberg hofer luks parkes essentially codification example section 
terminate search clause fixed remaining group included analog lex leader pruning discussed section 
recursive call line retain original group subsequent versions procedure 
precise description procedure state explicitly acts sym omega omega believe conditions obvious context elected clutter procedural descriptions 
proposition map returns element cg element exists returns failure 
proof 
proof appendix shows slightly stronger result map returns element cgt element exists 
procedure terminates search elements stabilized include lex leader considerations search space examined example section replaced variables avoid confusion current represent clause question 
aa aa aa pppp pppp pppp sym important prune node lower right larger problem node may expanded significant search subtree 
discuss pruning section 
interests clarity go example explicitly 
recall clause sym permutes xi arbitrarily 
initial pass procedure ch suppose select stabilize 
line selects point mapped select mapped recursive call fail line 
suppose pick image 
ch need fix image point left original clause selecting image leads failure 
taken image map 
element fixed recursive call returns trivial permutation line 
combined line caller fix image 
original invocation combines produce final answer 
zap implementation transporter problem extending algorithm solve transporter problem straightforward addition requiring cth line need keep track number points mapped set sure won forced exceed limit understand suppose examining node coset decomposition tree labeled permutation node corresponds permutations gt various subgroup considered level 
want ensure cgt cgt assumed avoid set completely replace slightly stronger cgt turn equivalent cg set simply result operating set permutation 
variety ways bound approximated moment simply introduce auxiliary function overlap assume computes lower bound ch procedure procedure groups element sets integer find group element transport cgt cgt cth return failure overlap return failure ch return ff element ch hff transport hff failure return rt return failure convenience denote transport transport 
top level function corresponding original invocation procedure 
proposition provided ch overlap ch transport computed procedure returns element cg cg element exists returns failure 
dixon ginsberg hofer luks parkes second condition overlap overlap ch needed ensure procedure terminates line overlap limit reached succeeding line 
procedure simplified significantly fact need return single desired properties opposed examples arising ir relevance calculations single answer suffices 
want compute unit consequences literal need unit instances clause question 
considerations case defer discussion topic section 
initial version overlap procedure group sets compute overlap lower bound overlap ch return ch having defined overlap may replace test line procedure check see overlap st indicating ch st equivalently cht simple version overlap defined difference procedures 
overlap matures change lead additional pruning cases 
orbit pruning general ways nodes pruned transporter problem 
lexicographic pruning bit difficult defer section 
understand example 
consider clause group permutes variables arbitrarily 
cg 
clearly isn room image size way element set avoid element set element universe 
bit better cases 
suppose group swap 
find cg 
answer clearly 
orbit image avoid set general case appearing procedure consider initial call identity permutation 
group consider orbits points orbit prune search 
reason points remain acted element definition orbit requires 
points stay away manage cg 
general case necessarily 
fixed ff clause construct image acting ff interested zap implementation equivalently ffg st ffg necessarily orbit ff prune st similar reasons prune fact prune space fit image intersecting putting points better 
seen particular orbit number points eventually mapped cases expression negative number points mapped max prune node max sum orbits group 
somewhat convenient rewrite fact max incorporating type analysis procedure gives procedure group sets compute overlap lower bound overlap ch orbit max return proposition group sets acted ch overlap ch overlap computed procedure 
dixon ginsberg hofer luks parkes block pruning pruning described previous section improved 
see consider example arise solving instance pigeonhole problem 
cardinality constraints presumably saying pigeons hole hole rewriting individual cardinality constraints augmented clauses produces sym sym terms generators really capture full symmetry single axiom 
realizing obtain switching case want switch 
add generator group modify permutations generate sym permute appropriately 
single augmented clause obtain hard see capture 
suppose false variables unvalued 
unit instance 
regard pruning condition previous section group single orbit condition 
actual pigeonhole instance variables negated 
dropped negations convenience 
zap implementation fails 
possible conclude immediately unit instances 
unit instances variable clause set unvalued variables remain 
equivalently unit instance valued need valued instance unit 
similarly unit instance 
went wrong 
went wrong pruning heuristic thinks mapped clause instance case possible instance question unit 
heuristic doesn realize separate blocks action group question 
formalize definition definition suppose acts set say acts transitively orbit put somewhat differently acts transitively just case xg definition suppose group acts transitively set block system partitioning sets 
bn permutes bi 
words block bi bj image bi bi 
image bi disjoint bi blocks partition group acting transitively nontrivially set block systems definition group acting transitively set block system 
bn called trivial 
case single block consisting entire set obviously block system 
point block permutes points obviously permutes blocks 
lemma blocks block system identical size 
example considering block system action group set 
conceivable clause image unit set impossible fewer unvalued literals particular block 
looking expression individual blocks 
dixon ginsberg hofer luks parkes clause single block block system remain single block acted clause winds block bi condition replaced bi bi case bi bi prune unvalued literals block question 
unvalued literals clause instance considered unit 
course don know exactly block eventually contain image prune min bi case target block generate prune 
example considering bi block block system 
generalizing idea straightforward 
notational convenience introduce definition 
tk sets suppose ti 
tin elements smallest size 
denote tij sigma mini ti 
proposition group acting transitively set suppose 
bk block system bi blocks 
bk 
size individual block bi cg sigma mini bi nb proposition block system trivial sense equivalent cg proposition 
bk block system group acting transitively set weaker 
event shown strengthen procedure procedure group sets compute overlap lower bound overlap ch zap implementation orbit 
bk block system bi max sigma mini bi return block system line procedure 
general best answer question seen proposition block system better trivial ones 
practice best choice appears minimal block system blocks smallest size contained single block 
procedure procedure group sets compute overlap lower bound overlap ch orbit 
bk minimal block system bi max min bi return proposition group sets acted ch overlap ch overlap computed procedure 
note block system depends group original clause means implementation possible compute block systems changes sets satisfied unvalued literals respectively 
gap includes algorithms finding minimal block systems set elements called seed gap contained single block 
basic idea form initial block system points seed block point outside seed block 
algorithm repeatedly runs generators group seeing generator maps elements block xg yg different blocks 
happens blocks containing xg yg merged 
continues generator respects candidate block system point procedure complete lexicographic pruning block pruning help example section 
final space searched 
faster implementation procedure designed testing equivalence finite automata aho hopcroft ullman chapter takes sna time size generating set inverse ackerman function 
dixon ginsberg hofer luks parkes aa aa aa pppp pppp pppp sym ac ad bc bd remarked leaf node mapped essentially identical second mapped 
important expand complicated examples may involve substantial amount search nodes leaf nodes 
sort situation lexicographic pruning generally applied 
want identify leaf nodes equivalent way expand lexicographically member equivalence class 
particular node need computationally effective way determining lexicographically member equivalence class 
identifying conditions nodes equivalent 
understand recall interested image clause particular group element means don care particular literal mapped care image entire clause don care image literal isn formal point view extending set stabilizer notation somewhat definition permutation group sets 
sk acted sk mean subgroup simultaneously set stabilizes si equivalently sk ig si 
computing multiset stabilizer sk ig si need compute individual set stabilizers take intersection 
recall set stabilizers computed coset decomposition stabilized point moved set question node pruned set stabilizer computation 
straightforward modify set stabilizer algorithm stabilized point moved si node question pruned 
allows sk computed single traversal decomposition tree 
suppose permutation stabilizes set cg satisfies conditions transporter problem 
acting doesn affect set corresponding image clause jg identical image means permutations equivalent jg set stabilizer alternatively permutation equivalent element coset jg 
hand suppose permutation simultaneously stabilizes sets satisfied unvalued literals respectively 
possible show zap implementation operate operating successfully don impact question cg solution transporter problem 
upshot definition group double coset gk set elements form jgk proposition group permutations set acted suppose sets acted instance transporter problem element gg solution understand important imagine prune search tree permutations remaining ones minimal double cosets gk 
impact solubility instance transporter problem 

particular instance solutions pruning tree obviously introduce 
particular instance solution element gk solution specifically minimal element gk solution minimal element pruned assumptions 
see prune node show permutation underneath minimal double coset jgk 
state precise conditions lets prune node suppose coset decomposition group xj point fixed depth tree 
node depth tree know corresponds coset ht stabilizes xj denote image xj zj 
ht minimal double coset gk proposition node corresponding ht pruned 
lemma leon xl xj xk zk min kz zk ht element gk 
lemma reported seress length orbit xj xl ifz elements orbit gz zl ht jgk 
results give conditions node coset decomposition pruned searching solution instance transporter problem 
consider example 
lemma 
return example section sym 
sym sym ab cd consider node repeatedly remarked pruned depth fix image case take statement lemma xl xj xl jx xl 
prune zl min zk zl dixon ginsberg hofer luks parkes restricting gives min zk example zk holds assuming ordering 
node pruned get reduced search space aa aa aa pppp pppp pppp sym ac ad bd desired 
node pruned lemma 
conditions lemma require take length orbit 
image points orbit orbit prune node 
previous node maps pruned course 
particular example simple 
nodes examined depth significant overlap groups question 
node pruned lemma lemmas prune different nodes complex cases 
note groups computed root tree group independent sets cached augmented clause 
lemmas known results computational group theory community 
lemma suppose permutation labeling node ht coset decomposition tree depth zi gx xk residual group level 
set points moved gx xk zi min xi ht element gk 
example consider cardinality constraint xm corresponding augmented clause xm sym set xi 
zap implementation suppose fix images xi order considering node image fixed image fixed 
sym 
xm sym xm 
xm lemma gives jxk xm sym need fix xj 
xj xk xm smallest element set prune node 
see proof proposition example 
refer lemmas pruning lemmas 
adding lexicographic pruning transporter procedure gives procedure groups element sets integer find group element transport cgt cgt overlap st return failure overlap return failure ch return pruning lemma applied return failure ff element ch hff transport hff failure return rt return failure note test line requires access groups original group procedure called 
retain copy group recursive call line 
brought mathematical power bear transporter problem specifically disagree recall repeated zap 
high performance satisfiability engines running difficult problems spend excess cpu time unit propagation seen instance transporter problem 
effort spent improving efficiency procedure predecessors expected lead substantial performance improvements practical application 
see experimental results section 
note lexicographic pruning important expensive 
defer line procedure 
earlier lexicographic prune independent sets count pruning faster defer lexicographic check extent possible 
dixon ginsberg hofer luks parkes time spent total cpu time sec zchaff data fraction cpu time spent unit propagation 
unit propagation procedure designed need find single permutation satisfying conditions transporter problem technically suffices zap needs 
unit propagation useful collect unit consequences augmented clause opposed collecting repeated traversals coset decomposition tree 
consequences observation help example illustrates points going making 
consider augmented clause sym sym situation false unvalued 
group allows arbitrary permutations unit consequences instances augmented clause 
note simply collect group elements associated unit instance group elements may correspond clause instance cg unit literal cg example ab correspond identical clause clause lead current partial assignment 
goal compute set permutations associated set unit definition augmented clause partial assignment 
unit consequences set literals cg cg 
fixed literal unit consequences set literals cg cg cg 
zap implementation unit consequences involve additional requirement literal appear clause instance question 
useful discuss watched literals section 
example unit consequences unit consequences longer identity permutation needed base instance 
unit consequences 
partial assignment annotated need just unit consequences reasons definition set pairs hl gi literal pair 
hl 
hln denote 
ln 
augmented clause partial assignment called annotated set unit consequences 
cg cg hl gi 
set unit consequences returning example annotated consequence abc hf ef hf abc ef set abc hf ef annotated set unit consequences abc hf ef hf abc ef 
hf ef hf abc ef annotated set unit consequences appear consequence 
modify transporter procedure search entire tree accumulating annotated set unit consequences 
need careful pruning lemmas may prune node includes permutation minimal double coset gk 
problem minimal element gk may correspond distinct unit consequences 
running example may minimal elements gk supports accumulate minimal elements get full set unit consequences result 
successful minimal double coset reconstructing relevant orbits easy introducing definitions cater 
basic idea want minimal entail sense drawn permutations double coset gk 
example subgroup simultaneously stabilizes sym sym 
permutation allows conclude operate ef conclude 
formalize follows definition group say hl entails hl hl lg 
say set pairs entails set pairs writing pair entailed pair skeletal set unit consequences set unit consequences entails annotated set unit consequences running example ef paragraph allowing example entail hf ef see skeletal set unit consequences partial assignment 
dixon ginsberg hofer luks parkes lemma proof 
pair form hlg gi hl associated literal construct full set unit consequences skeletal set repeatedly find new unit possible procedure set pairs hl gi group compute complete complete complete hl gi lg select lh hl ghi return proposition complete complete apply pruning lemmas search proceeds eventually returning skeletal set unit consequences clause question 
addition unit instance fact unsatisfiable return failure marker sort 
handle returning values 
indicates contradiction second skeletal set unit consequences 
procedure groups element sets find transport skeletal set unit consequences overlap st return hfalse overlap return hfalse ch ct return htrue return hfalse ii pruning lemma applied return hfalse ff element ch hff hu transport hff true return htrue hl gt hl gi return hfalse zap implementation proposition assume ch overlap ch transport computed procedure 
cg cg transport htrue gi transport hfalse zi skeletal set unit consequences application pruning lemmas proposition augmented clause corresponding cardinality constraint 
sets procedure expand linear number nodes finding skeletal set unit consequences 
original formulation cardinality constraints zap determining particular constraint unit finding implied literals takes time linear length constraint involves simple walk constraint 
appropriate linear number nodes expanded case 

watched literals pruning technique considered possibility finding analog setting zhang stickel watched literal idea 
understand basic idea suppose checking see clause unit situation unvalued 
follows clause unit independent value assigned point watch literals long remain unvalued clause unit 
practice data structures representing include pointer clause question unit test needs performed clauses pointed literals changing value 
continue discuss ideas useful distinguish different types clauses satisfied current partial assignment unit definition clause possibly annotated partial assignment 
say settled satisfied unit unsettled 
definition clause possibly annotated partial assignment 
unsettled watching set set literals 
words contains unvalued literals unsettled current partial assignment 
satisfied unit 
watching set case 
sense doesn matter 
assuming notice clause changes unsettled unit unit propagate detect potential contradiction dixon ginsberg hofer luks parkes settled clauses uninteresting perspective generate second unit propagation 
watch settled clause see fit 
sense matter 
properties watching sets remain valid backtrack 
means settled clause unsettled backtrack watched unvalued variables backtrack 
order discuss backtracking formal way introduce definition partial assignment set possibly augmented clauses 
say closed clause unit consequence closure minimal sound closed extension denoted pt simply clear context 
definition closure sense intersection closed partial assignments closed 
compute closure simply add unit consequences time available 
note ambiguity unit consequence added point add unit consequences order 
definition hl 
partial assignment 
initial subsequence hl 
say backtrack point 
denote largest backtrack point 
clause say retraction denoted largest backtrack point unsettled 
note require backtrack point unsettled opposed simply unsatisfied 
closed difference definition permit backtrack point unit 
unit retract reverting point unit 
simply unit propagation computes backtrack point immediately lemma unsettled example suppose annotated partial assignment literal reason true true true clause retraction ha ci 
removing sufficient unsettled ha di closed legal backtrack point 
theory retraction fact hai ha ci backtrack point unit drawn 
generalize definition include settled clauses zap implementation definition clause annotated partial assignment 
watching set set literals 
words contain unvalued literals replace retraction discussed earlier point backtrack longer satisfied unit 
continuing earlier example watching set watching set watching set recall definition forces backtrack way hai 
lemma watching set superset order watching sets useful course maintain search proceeds 
ideally maintenance involve modifying watching sets infrequently possible adjust required variables take new values backtracking 
recall example section unvalued constitute watching set clause satisfied need clause satisfied watching set 
note example satisfied remove watching set need replace backtrack point unvalued 
leaving watching set required satisfy definition needed ensure sets need adjusted backtrack 
hand example unsatisfied need check clause see unit 
clause unit set true unit propagation maintenance required 
clause unsettled unvalued replace set literals watching clause 
clause satisfied unvalued retraction clause watching set need modified 
general proposition suppose watching set literal 

watching set backtrack point 
settled hp li watching set hp li 

settled hp li watching set hp li 

watching set hp li 
proposition tells modify watching sets search proceeds 
modification required backtrack claim 
modification required clause satisfied unit claim remove newly valued literal watching set unvalued variables claim 
modification required add negation watched literal claim 
sum modification watching sets required add negation watched literal partial assignment watched clause settled case dixon ginsberg hofer luks parkes add remaining unvalued literals watching set 
addition remove literals watching set unvalued literals 
possibility zchaff ground systems example 
suppose usual watching point true 
leave watching set virtue condition extend watching set include extending watching set admissible virtue lemma remove watching set 
change unneeded ground prover useful augmented version proposition 
lift ideas augmented setting modifying definition obvious way get definition augmented clause annotated partial assignment 
watching set set literals watching set instance cg leads augmented analog proposition 
clauses proposition proposition clause correspondence results 
proposition suppose watching set literal 

watching set backtrack point 
cg watching set hp li 

cg hp li cg unsettled hp li watching set hp li 

cg hp li watching set hp li 
example suppose return augmented clause considered previous section sym sym 
suppose initially watching false imagine false 
need augment cg unsettled instance cg contains instances need add watching set add points 
case clause unit instance example remove watching set 
reason backtrack past point danger watching unsatisfied clause 
suppose unvalued false 
add watching set free remove sanctioned proposition settled instances cg conditions claims equivalent 
zap implementation false unvalued true 
add watching set remove new watching set 
instance watched literal 
cases remove literal just false watching set 
surely clause instance unvalued literals watching set 
correspond requirement cg hp li instance 
stronger condition claim proposition allows slightly better cases satisfied literal clause satisfied sufficiently know backtrack 
fourth proposition essential effective functioning prover replace watched literal false new unvalued literal important watching original watched literal claim proposition allows practical cases 
fourth watching sets get larger search proceeded 
eventually literal clause watched computational power idea lost 
watching sets reduce number clauses examined line unit propagation procedure 
augmented clause needs associated watching set initialized updated sanctioned proposition 
initialization straightforward clause length need define associated watching set property cg fact take simply cg union instances cg rely subsequent unit tests gradually reduce size 
fourth clause proposition 
challenge modify procedure way facilitates maintenance watching sets 
doing understand bit detail watching sets searching unit instances particular augmented clause 
consider augmented clause corresponding quantified clause xy set instances set instances augmented clause sym sym elements respectively 
suppose true unvalued clause unit instances 
suppose search unit instances stabilizing image stabilized group sym sym 
possible bindings denote search space looks dixon ginsberg hofer luks parkes delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta aa aa aa aa aa aa aa aa aa aa aa aa iiii iiii iiii gamma gamma gamma gamma gamma gamma pppp pppp pppp sym sym sym interests conserving space written qi similarly rj 
leaf nodes fails relevant instance unvalued construct new watching set entire clause watches 
note causes lose significant amounts information regarding portions search space need reexamined 
example responsible literals leaf node follows delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta aa aa aa aa aa aa aa aa aa aa aa aa iiii iiii iiii gamma gamma gamma gamma gamma gamma pppp pppp pppp simply accumulate literals root search tree conclude reason failure watching set 
watched literals changes value potentially reexamine entire search tree 
address changing order variable stabilization replacing search space depicted delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta delta pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi pi ee ee ee ee ee ee ee ee ee aa aa aa aa aa aa aa aa aa iiii iiii iiii pppp sym sym sym zap implementation center node needs value changes node appears 
search space simply delta delta delta delta delta delta pi pi pi pi pi pi ee ee ee aa aa aa sym sym expect changes value 
upshot collect new watching set original augmented clause corresponding need modify unit propagation procedure stabilize points mapped specific watched literal unsatisfied 
see keep watching set updated consider proposition 
searching unit instances augmented clause need compute set cg unsettled instance cg contains fixed literal 
solution lies procedure describes search unit instances 
remaining clause instances particular search node determined test line simply recognizing instance node need able identify set unvalued literals meets unsettled instance cg twice 
modify overlap procedure procedure group sets acted bound compute overlap collection elements sufficient guarantee ch collection exists orbit 
bk minimal block system bi delta min bi delta delta return return dixon ginsberg hofer luks parkes proposition procedure returns nonempty set procedure returns value excess case ch position replace procedure version uses watched literals procedure groups element sets optionally watched element find transport skeletal set unit consequences supplied wt ch return hfalse overlap st return hfalse overlap return hfalse ti ch ct return htrue return hfalse pruning lemma applied return hfalse ff element ch supplied cth choose ff wt ffh hff hu xi transport hff true return htrue hl gt hl gi return hfalse application pruning lemmas line need restricted group prune group element cg basis group element jgk jgk pruned line 
proposition suppose overlap computed procedure satisfies proposition 
cg cg cg transport computed procedure returns htrue procedure returns hfalse skeletal set unit consequences ch ch ch unsettled zap implementation note pruning lemmas applied relatively late procedure line successful application prunes space increasing size watching set 
pruning lemmas applied earlier 
appears case 
discussed section pruning lemmas relatively complex check moving test earlier precede line presumably slows unit propagation procedure factor approximately primarily due need compute set stabilizer cases simple counting argument suffices 
addition absolute impact watching sets expected quite small 
understand suppose executing procedure instance eventually fail 
node pruned counting argument new contribution wn set watched literals lexicographic argument node node eventually fail contribute watching set wn eventually returned value 
possible wn wn different elements selected overlap function line example expect vast majority cases wn wn non lexicographic prune impact eventual watching set computed 
proposition implies watching set returned procedure update watching set third claim proposition 
fourth claim hope remove new watching set need check see cg hp li new watching set 
determined single call transport cg hp li remove cases save call transport exploiting fact shown proof proposition satisfied hp li unit consequence 
position describe watched literals augmented setting 
start definition watched augmented clause pair augmented clause watching set 
procedure unit propagation compute unit propagate set watched augmented clauses annotated partial assignment set pairs hl ri literals reasons dixon ginsberg hofer luks parkes hl ri element hl ri hp hl rii hr transport true li literal ch highest index return htrue resolve ch ci complete literal ch unassigned hz hz chi transport failure return hfalse line invoke version transport function accepts additional argument literal required included clause instance sought 
modification similar literal transport procedure 
proposition annotated partial assignment set watched augmented clauses watching set set unit consequences clauses unit propagate true ci augmented clause nogood modified watching sets watching sets value returned hfalse watching sets replaced watching sets procedure modified incorporated fairly obvious way procedure literal added partial assignment added passed unit propagation procedure 

resolution revisited additional theoretical point need discuss turning attention experimental matters 
goal augmented resolution produce resolvents sanctioned instances augmented clauses resolved 
showed zap possible produce resolvents 
example phenomenon 
zap implementation suppose resolving clauses ab ab result ab consider example 
instances surely better resolvent ab 
general want conclude possible conclude ae set inclusion proper 
resolvent properly stronger additional consideration 
suppose resolving augmented clauses choose instances resolving clauses resolvent literals possible resolvents distinct ab select 
know general answer reasonable heuristic choice order literals added current partial assignment 
assuming resolvent nogood presumably false current partial assignment select resolvent allows larger case resolvent involving literal added 
considerations direct analog conventional boolean satisfiability engine 
particular literal resolvent reasons just flexibility possible definition ff fi augmented clauses resolving literal ff fi 
resolvent ff fi clause obtained resolving ffg ffg 
note group resolvent clause resolve ffg independent resolvent selected focus attention strictly syntactic properties resolvent 
formalize fact partial assignment induces natural lexicographic ordering set nogoods theory definition partial assignment ground clause 
literal negation maximal index say falsification depth position literal falsification depth zero literal event falsification depth denoted nogoods say falsified earlier writing lc lc 
result obtained direct computation applying resolution stability property discussed zap groups identical 

weak analog zchaff replace nogood leads greater 
functionality part zchaff code appear documented 
dixon ginsberg hofer luks parkes example suppose ha ei 
falsification depth third variable assigned falsification depth 
learn allows similarly common element eliminated backtrack general goal resolving augmented clauses select resolvent minimal note lemma ae nogoods 
procedure suppose augmented clauses ff fi unit partial assignment hl 
ff fi 
find minimal resolvent ff fi lambda literals avoid fff ff fif fi ff fi transport ff lp 
ln transport fi lp 
ln failure failure lp fff ffg fif fff fif return resolve fff fif basic idea gradually force clause instances away partial assignment back keep track literals unavoidable associated call transport failed 
unavoidable literals accumulated set continue call transporter function objection clause instances includes elements point attention deepest variable known avoidable unavoidable reach root partial assignment return instances 
example 
suppose ha ei ff instances second clause fi single instance resolve minimal instances augmented clauses resolve get better resolve get literals appear case re better suppose follow example procedure initially set say ff fff set fi fif set instance fi 
initial value literal ff fi zap implementation try find way avoid having appear final resolvent 
looking instance ff includes literal re resolving avoids subsequent literal aren 
instance ff 
instance fi avoids call line fails 
add leave clauses fff fif unchanged 
decrement longer fff fif pass loop looking clause instances avoid 
know ll forced include final result don worry 
hope point exclude successful finding instances 
existing instance fi suffices instance ff 
new fff gets reduced fff fif 
pass loop tries avoid continuing avoid know avoid current fff fif 
turns impossible added decremented 
avoiding impossible decremented zero procedure correctly returns proposition suppose augmented clauses ff fi ff fi unit partial assignment ff fi 
value returned procedure minimal resolvent ff fi 
procedure implemented somewhat efficiently described fff example satisfies condition implicit line need transport function important relatively improvement fact resolution involves repeated calls transport function 
general boolean satisfiability engines need worry time resolution function unit propagation dominates running time 
naive implementation procedure involves calls transport unit propagation procedure resolution comes dominate zap runtime 
correct remember point procedure 
procedure needed correctness needed find improved resolution instances 
amount time spent looking instances computational savings achieved having 
put slightly differently requirement produce resolvent absolutely minimal ordering 
resolvent nearly minimal suffice especially producing truly minimal instance involves large computational cost 
achieve goal working modified transport function lines procedure 
expanding coset decomposition tree completely limited number nodes examined 
zap current implementation prunes transporter search nodes examined solving pigeonhole problem example turns sufficient ensure resulting proof length strictly minimal resolvents 
modify pruning computation pruning gs difficult compute 
gs stabilizing element set surely stabilizes set approximation saves time reduces amount possible pruning 
appropriate dixon ginsberg hofer luks parkes secs pigeons cpu time cpu time resolution pigeonhole problem artificially reduced size search tree need produce answer quickly 

experimental results components position describe experimental performance algorithms 
remarked describing performance zap algorithmic components resolution unit propagation algorithms 
performance results complete inference tool build ideas section 
experiments performed ghz pentium gb main memory 
resolution implemented resolution procedure described section results pigeonhole problem shown 
particular example involves resolving basic axioms pigeonhole problem containing pigeons holes axiom says pigeon hole second pigeons hole 
group corresponds global symmetry group pigeons holes interchanged freely 
zap implementation resolvent axioms fact computed computation result zap group stable extensions superset group algorithm section computing augmented resolvents include check see groups identical implementation include check 
test disabled produce data 
plot observed time seconds resolution function number pigeons involved time plotted log scale 
memory usage typically approximately mb cpu usage dominated need compute stabilizer chains groups question 
algorithms doing take time size domain group operating furst hopcroft luks knuth 
case symmetries pigeons holes stabilized independently expect stabilizer chain computation take time number pigeons 
fit data curve axb best fit occurring ss 
consistent stabilizer chain computation dominating runtime 
reinsert check see groups running times reduced uniformly approximately 
testing group equality involves checking see generator member vice versa involves computing stabilizer chains groups question 
need compute stabilizer chains dominates computation 
unit propagation give data showing average time needed unit test pigeonhole problem 
naturally occurring unit tests arise run prover problem question 
memory program remained far gb available example maximum usage approximately mb pigeons unit test np complete customary give mean median running times means mean running times appear growing polynomially compare lines best fit medians appear modestly smaller means 
shown appears ratio mean median running times growing linearly problem size 
earlier shows average cpu time failed tests clause question unit instances successful tests unit instances exist seen failed unit tests generally complete far quickly successful counterparts similar size various pruning heuristics come play 
cases scaling continues appear polynomial problem size 

accurately measuring peak memory usage difficult group operations regularly allocate free relatively large blocks memory 
measured usage simply starting system monitor observing practical problem instances took extended amounts time complete 
reason report memory usage approximately problem instance 
dixon ginsberg hofer luks parkes secs pigeons fit exponential fit cpu time unit test pigeonhole problem 
experimental results zap conclude discussion zap experimental performance results problem instances entirety opposed performance individual algorithmic components 
presenting results describe domains considered expectations regard performance zap existing systems areas 
examining performance domains 
pigeonhole problem goal show put pigeons holes pigeon get hole 

parity problem goal show pi xi pi xi odd sets equal tseitin 

clique coloring problem goal show map containing clique colored colors reasons chosen particular problem classes follows 
easy 
obvious put pigeons holes pi xi pi xi xi appears exactly twice 
obvious color graph containing clique user fewer colors 
case especially note solving easy problem 
case trying color specific graph containing clique goal zap implementation mean median ratio pigeons ratio mean vs median cpu time unit test pigeonhole problem show graph containing clique colored 
different graph coloring generally 
put somewhat differently problems examining suitable representations easy 

problems known exponentially difficult resolution methods 
shown pigeonhole problems haken parity problems tseitin 
clique coloring problems known exponentially difficult resolution linear programming methods 
fact know implemented system scales polynomially class problem 

problems involve structure captured group setting 
data compares zap performance zchaff section discusses performance boolean tools problem classes discussing 
chose zchaff comparison partly discussed series papers partly appears best performance problem classes considering 
see section additional details 
zap expectations proceeding point theoretical basis known short group proofs exist problems 
showed zap dixon ginsberg hofer luks parkes secs pigeons cpu time pigeonhole instances zap zchaff group pigeonhole proofs expected short parity problems short group proofs mimic gaussian elimination 
showed short group proofs existed clique coloring proof fairly intricate 
goal determine implementation ideas discover short proofs practice control group inference require additional theoretical ideas understand 
please understand goal point test zap standard np complete search problems boolean form graph coloring quasigroup completion problems gomes selman 
doing involves significant effort ensuring zap constant factors data structures comparable systems preliminary indications possible modest impact performance approximately factor complete reported 
pigeonhole results shows running times zap zchaff pigeonhole instances 
repeats zap data including best exponential polynomial fits time spent 
running time appears polynomial varying approximately number pigeons 
rough terms factor needed stabilizer chain constructions 
branch positive literals know see zap resolutions needed solve problem resolution lead unit propagations 
total time expected approximately zap implementation secs pigeons fit polynomial fit zap scaling pigeonhole instances assuming unit propagation involves stabilizer chain computations actual search 
observed performance close theoretical value 
practice zap branches positive literals negative ones 
reason negative literals appear far clauses positive ones clauses negative literal opposed single clause positive literal usual branching heuristic boolean satisfiability community initially assigns variable value satisfies clauses possible 
number nodes expanded zap solving particular instance pigeonhole problem shown presents similar data zchaff 
number nodes expanded zap fact exactly curiously depth zchaff search smaller instance pigeons 
know small size pigeonhole proofs zap result effectiveness optimal resolvents fundamental argument zap proofs pigeonhole problem short 
moving parity problems allow comment importance various algorithmic techniques described 
recognize algorithms quite involved important demonstrate associated algorithmic complexity leads legitimate computational gains 
shows time needed solve pigeonhole instances abandon pruning lemmas avoid search optimal resolvents 
clear data techniques essential obtaining performance exhibited system 
dixon ginsberg hofer luks parkes nodes pigeons nodes expanded pigeonhole problem abandon search optimal resolvents proof lengths increase significantly appear remain polynomial length increase learned axioms leads increased running times unit propagation appears primary reason performance degradation 
running times scale exponentially 
abandoning pruning lemmas leads exponential running times 
expected level exponentially learned ground axioms prune search unit instances exponential behavior expected 
ways reduced zap algorithmic complexity 
example removed watched literals computational machinery needed maintain 
turns change virtually impact zap pigeonhole performance prover behavior typically backtrack free dixon 
general watched literals expected play important role zap dpll style prover 
focus series papers show group augmentations implemented sacrificing ability techniques boolean satisfiability engines effective practice watched literals certainly numbered techniques 
evaluate possibility learning augmented clauses learning ground versions 
avoid need implement procedure avoid computational gains zap theoretically access 
learning augmented clauses theoretical reductions proof zap implementation secs pigeons pruning resolution instances improvement due pruning lemmas optimal resolution instances 
circles mark zap performance 
indicate performance pruning lemmas disabled unit propagation boxes give performance resolutions original base instances clauses resolved opposed searching resolving optimal instances 
size obtained proof necessarily unchanged dpll style approach 
tseitin results problem class experimental data due tseitin shown urquhart require resolution proofs exponential length 
problem graph associate boolean variable edge vertex associated charge equal sum mod variables adjacent charge entire graph sum mod charges vertices 
require connected graph charge set constraints associated vertices unsatisfiable tseitin 
graph problem size associated constraints dixon ginsberg hofer luks parkes gamma gamma gamma gamma gamma gamma gamma gamma language zap see appendix axiom set unsatisfiable adding axioms gives problems known exponentially difficult resolution methods urquhart 
times solution zap zchaff shown 
zchaff clearly scaling exponentially best fit zap times log problem size 
shows number nodes expanded systems 
number search nodes expanded zap appears growing polynomially size problem give take keeping result zap showing zap proofs polynomial length exist parity problems 
pigeonhole instances see short proofs exist theory apparently practice 
polynomial number nodes expanded super polynomial amount time consumed unit propagation procedure culprit super polynomial amount time unit propagation 
shown fact case 
unit test easy groups simply flip number variables question 
want know augmented clause unit instance find unvalued variables contains 
clause unit 
exactly clause unit variable valued parity sum take desired value 
reason unit tests scaling nlog 
zap implementation secs size cpu time tseitin instances zap zchaff 
zchaff scaling exponentially zap scaling log 
nlog scaling appears consequence multiset stabilizer computation underlies transporter pruning 
scaling polynomial show polytime methods exist set stabilizer groups question general methods implemented gap zap exploit abelian nature parity groups scaling shown 
obvious extension existing implementation include efficient set stabilizer algorithms groups 
clique coloring final problem class experimental data clique coloring 
class problems related pigeonhole problem far difficult 
mentioned previously domain graph coloring nodes connected edge assigned different colors 
graph clique size obvious graph colored colors 
equivalent instance pigeonhole problem 
clique coloring problem told 
argument fact groups abelian fact group orbits size set stabilizer problem converted linear algebra 
dixon ginsberg hofer luks parkes nodes size nodes expanded tseitin problems 
zchaff scaling exponentially zap scaling polynomially 
graph clique size contains clique size fact know exact location clique widens search considerably 
know automated proof system scales polynomially problems class resolution linear programming methods inevitably scale exponentially 
showed zap zap produce polynomial length proofs theory suggestions proofs easy find practice 
details zap performance problem class reiterate observation clique coloring problems thought unsatisfiable instances graph coloring problems generally 
particular instance problem class describe specific graph needs colored says graph contains clique needs colored colors 
axiomatization problem follows 
eij describe graph cij describe coloring graph qij describe embedding clique graph 
graph nodes clique size colors available 
ci cin 
qi qim 
eij cil cjl 
qij 
zap implementation secs size average log cpu time unit test tseitin problems 
zap scaling approximately nlog 
eij eij means edge graph nodes cij means graph node colored jth color qij means ith element clique mapped graph node axiom says graph node color 
says element clique appears graph 
says nodes graph color colors available connected edge 
says elements clique map node graph 
says clique clique clique elements map disconnected nodes graph encoding passed zap group follows sort color sort node sort clique predicate edge node node predicate color node color predicate clique clique node group color color color dixon ginsberg hofer luks parkes color color color color color color group clique clique clique clique clique clique clique clique clique clique clique clique clique clique clique clique clique group nodes edge edge edge edge color color color color clique clique clique clique clique clique color color color color color color edge edge edge edge edge edge clique clique clique clique clique clique clique clique clique color color group nodes clique clique clique group clique edge color color group nodes color clique clique group nodes clique clique clique edge group nodes clique version clique graph size trying just colors 
group symmetry colors second elements clique third symmetry nodes 
axiomatization identical earlier 
note common symmetry problem axiomatization obscures sense included relevant symmetry symmetries particular axiom 
times solution zap zchaff shown 
expected zchaff scaling exponentially zap appears scaling 
order allow data single axis problem instances selected clique size smaller graph size 
shows number nodes expanded systems 
number nodes expanded zchaff growing exponentially problem size number expanded zap growing polynomially 
pigeonhole problem zap implementation secs graph size clique size cpu time clique instances zap zchaff see short proofs existence guaranteed theory practice 
figures display zap performance somewhat wider range problem instances clique graph sizes allowed vary independently 
number nodes expanded general size clique size graph 
handful outliers notably instance expanded larger number nodes 
exceptions expanded fewer nodes 
regard total cpu time time appears scaling cg 
outlier polynomial performance observed generally 
best knowledge zap system exhibit polynomial performance problem class remarked approaches proven scale exponentially 
related compare experimental results obtained systems attempt exploit problem structure improve performance satisfiability solvers 
section provides high level summary experimental results number dixon ginsberg hofer luks parkes nodes graph size clique size nodes expanded clique problems efforts compares results zap benchmark problems described previous sections 
recall benchmark problems highly structured different type structure 
theoretically problems allow polynomial time solutions provably hard conventional solvers 
solver solves problems efficiently ability exploit range different types problem structure automates strong proof system 
course interesting solver practical general purpose solver 
example tseitin problems solved polynomial time form gaussian elimination schaefer pigeonhole problems solved polynomial time linear programming method simplex method 
solutions constitutes practical general purpose solver 
ran number solvers benchmark problems obtaining results pigeonhole tseitin clique coloring zap nlog zchaff march eq resolution 
planes integer programming zap implementation nodes zap clique size graph size nodes expanded clique problems presenting numerous graphs summarize results simply reporting scaling solver problem class 
polynomial time scaling indicated exponential time scaling scaling shown problem classes discussed separate encodings considered tseitin problems 
encoding encoding section second involves new variables reduce clause length described 
performance improved new scaling 
final rows give known proof complexity results resolution cutting planes proof systems provide lower bounds corresponding rows 
reducing performance results exponential polynomial scaling omits valuable information 
clearly difference scaling care polynomial 
details specific scaling factors included discussion follows goal table merely summarize strength solver underlying proof system 
details solvers appearing table follows pseudo boolean version dpll algorithm 
represents problems pseudo boolean form automates cutting planes proof system 
proof system allows polynomial length proofs pigeonhole problem able solve problems efficiently 
scaling pigeonhole instances number pigeons 
improvement dixon ginsberg hofer luks parkes secs zap xy clique size graph size cpu time expended clique problems scaling seen zap 
performance tseitin clique coloring problems exponential cutting planes inference able capture exploit structure problems 
li march eq van dpll solvers modified incorporate equivalence reasoning enable solve parity problems efficiently 
expected march eq exhibited exponential scaling pigeonhole clique coloring problems solvers designed recognize structure problems 
surprising exponential scaling observed march eq initial encoding tseitin problems 
scales exponentially recognize structure encoding parity problems performance improved modifying cnf encoding reduce size structure apparent solver 
doing involves significant number new auxiliary variables experimental results new encoding discussed 
march eq recognize structure original encoding solves preprocessing phase 
exponential scaling due simply fact size boolean encoding growing exponentially function graph size see section 

li personal communication 
zap implementation parity constraint rewritten set parity constraints length li 
parity constraint form 
xn equivalent set parity constraints 
xn xn summing set parity constraints gives xn equivalent 
tseitin encoding section translated parity constraints way converted cnf exponential blowup size existing cnf encoding avoided 
clear resolution produce polynomially sized proof unsatisfiability resulting theory 
march eq zap exhibit improved performance new encoding results shown tseitin column table 
march eq solves encoding tseitin problems virtually instantaneously 
substantially outperforms zchaff reported li 
running times remain exponential system unable solve instance size seconds 
performance zap improved scaling unchanged 
new variables accepted practice reducing size cnf encodings potential reduce length proofs constructed solvers 
classes problems known hard extended resolution version resolution new variables permitted 
general introducing new variables order reduce proof length considered cheating proof complexity perspective new variables introduced proof systems essentially equivalent 
addition general method introducing variables known know implemented system 
advantage zap group annotations avoid need syntactic sort 
approach solving highly symmetric problems seen solver li purdom jr 
solver dpll algorithm accepts input problem cnf set matrices describing global symmetry variables 
global symmetry partition set variable assignments equivalence classes 
addition normal pruning techniques dpll search pruned eliminating partial assignment minimal equivalence corresponding global symmetry 
scales polynomially pigeonhole problems class input symmetry groups allowed currently dixon ginsberg hofer luks parkes limited applied tseitin clique coloring problems 
clear limitation overcome matures included table 
solvers tested zap solver provide efficient solutions test problems solver scales polynomially clique coloring 
better scaling pigeonhole problems march eq better scaling tseitin problems solvers exploit narrowly defined type problem structure perform poorly domains 
performance zap improve basic group primitives underlying zap procedures optimized 

zap represents appears new synthesis distant fields computational group theory boolean satisfiability 
algorithmic point view fields fairly mature complex synthesis inherits significant algorithmic complexity result 
goal initial versions algorithms group theorem prover need describe performance prototype implementation ideas 
seen zap easily outperforms conventional counterparts difficult problem instances group structure concealed boolean axiomatization 
said important realize results scratch surface zap underlying representational shift allows 
tseitin problems example incorporation sophisticated set stabilizer algorithms allow improve zap performance fact polynomially nodes expanded solving problems eventual performance system 
improvements possible 
pigeonhole clique coloring problems computational performance dominated stabilizer chain computations groups question groups products full symmetry groups 
known full symmetry groups extremely difficult usual stabilizer chain algorithms cases possible produce stabilizer chains directly time stabilizer chain data structure modified jerrum 
modifications expected improve zap performance significantly domain 
simply 
extensions obviously need experiment zap wide range problem instances 
general points regarding area 
left problem discovering group structure existing clausal databases 
practical impact substantial reasons 
possible apply zap directly problems encoded boolean axioms possible discover emergent group structure appears search begun 
example symmetry exists particular problem hidden existing axiomatization inferences symmetry may apparent needs noticed 
second important zap provides broad stage 
progress computational group theory expected lead performance improvements inference dually applying zap wide range reasoning problems zap implementation provide new set examples computational group theorists test ideas 
lifting heuristics area ai group setting may analogs heuristics available practical domains 
new reasonable hope zap allow ideas boolean satisfiability computational group theory search ai combined leading new insights levels performance areas 
acknowledgments members cirl technical staff time systems assistance ideas series papers 
implementers maintainers gap elements zap implementation directly implementations appear gap descriptions seress book 
especially anonymous reviewers zap papers care effort put reviewing series papers span journal pages entirety 
papers substantially improved efforts 
sponsored part air force office scientific research afosr number air force research laboratory afrl number small business technology transfer research advanced technology institute ati number office naval research onr number defense advanced research projects agency darpa air force research laboratory rome ny agreements numbered darpa agreement number hr 
views expressed authors 
appendix proofs procedure augmented clauses compute stab ci gi closure cg closure cg restrict closure restrict closure closure closure stab restrict stab restrict int stab stab gi generators int gi lifted stab gi lifted stab closure return hg restrict restrict proposition result returned procedure stab ci gi 
proof 
show element group returned stable extension showing generators line stable extensions recall set stable extensions subgroup 
show stable extension returned showing constructed procedure 
dixon ginsberg hofer luks parkes claim argued main text elements stable show elements 
element note cg gi similarly agrees withl gi outside 
stable second claim suppose stable extension consider restriction cg cg intersection cg cg agree elements call elements agrees 
restricting away intersection get see element group generated matches cg cg consider 
identity cg cg restricting cg cg get element point stabilizes cg cg elements included directly line resolution procedure 
follows element hg restrict restrict hg restrict restrict procedure groups element sets find group element map cgt cth return failure ch return ff element ch hff map hff failure return rt return failure proposition map returns element cg element exists returns failure 
proof 
remarked main text prove slightly stronger result map returns element cgt element exists 
proposition stated special case 
proof proceeds induction number elements moved ct procedure return failure line ct return line 
inductive step assume moves point lines don affect correctness procedure point allow early termination fixed point moved inside interesting case form transversal line 
element represented gt hff transversal 
gt returned solution know inductive hypothesis recursive call line 
procedure groups element sets integer find group element transport cgt cgt zap implementation cth return failure overlap return failure ch return ff element ch hff transport hff failure return rt return failure proposition provided ch overlap ch transport computed procedure returns element cg cg element exists returns failure 
proof 
remarked main text ct 
ct required empty ct ct 
proof proceeds essentially unchanged proposition 
conditions overlap function necessary 
need know ch overlap order avoid terminating search early line 
need overlap ch ensure fixed element line identify failure ct don return successfully line case 
procedure group sets compute overlap lower bound overlap ch orbit max return proposition group sets acted ch overlap ch overlap computed procedure 
proof 
subtlety involves contribution fixed points clause sum 
fixed point orbit fixed points contribute sum depending proposition group acting transitively set suppose 
bk block system bi blocks 
bk 
size individual block bi cg sigma mini bi nb proof 
set blocks collectively contain image cg 
usual counting argument 
blocks contain dixon ginsberg hofer luks parkes points set contain sigma mini bi points 
nb points available result follows 
proposition block system trivial sense equivalent cg proof 
suppose single block 
set take minimum cg hand block system trivial point block sigma mini bi smallest number points set size sigma mini bi cg proposition 
bk block system group acting transitively set weaker 
proof 
comparing see trying show sigma mini bi nb sigma mini bi nb blocks block system equivalent sigma mini bi nb sigma mini bi bq bq nb sigma mini bi sigma mini bi lefthand side total amount space blocks included sigma mini bi righthand side amount space blocks 
follows result proved 
zap implementation lemma group permutations set acted suppose sets acted permutation cg cg proof 
immediate cj lemma group permutations set acted suppose sets acted permutation cg cgk cg cgk proof 
clearly suffices show result equivalent 
cgk cg sk cg sk set stabilizer set stabilizer group 
proposition group permutations set acted suppose sets acted instance transporter problem element gg solution proof 
combine lemmas 
lemma sym omega omega ordered set 
xn suppose sym omega satisfies zl suppose fixed set xi xk 
suppose zi min xi gx element proof 
existence zx xi zi consider gt gx xk 
stabilizes set xi 
xk 
stabilizes point set fixes xi xji zi dixon ginsberg hofer luks parkes hand fix xl precedes gt gt minimal 
lemma suppose permutation labeling node ht coset decomposition tree depth zi gx xk residual group level 
set points moved gx xk zi min xi ht element gk 
proof 
direct consequence lemma 
ae permutation jm xi 
ae fixes point moved gx xk ae fixes 
xi follows ae permute remaining points xi 
xk 
jm xi zx xi set stabilizer statement lemma element jg 
gk result follows 
procedure set pairs hl gi group compute complete complete complete hl gi lg select lh hl ghi return proposition complete complete proof 
complete entry added clearly entailed complete entire image eventually added 
procedure groups element sets find transport skeletal set unit consequences zap implementation overlap st return hfalse overlap return hfalse ch ct return htrue return hfalse ii pruning lemma applied return hfalse ff element ch hff hu transport hff true return htrue hl gt hl gi return hfalse proposition assume ch overlap ch transport computed procedure 
cg cg transport htrue gi transport hfalse zi skeletal set unit consequences proof 
procedure identical procedure value returned 
cg cg htrue gi returned line cause htrue gt returned recursive call line 
cg cg argument proceeds usual induction number points moved know correct answer returned line usual reasons remains consider recursive case line 
know cg unit accumulate result minimal jgk usual 
need show set hl gi collected skeletal set unit consequences 
see suppose hl gi annotated unit consequence 
minimal jgk accumulated set pairs accumulated line associated literal set stabilizes clause cj cgk produces unit consequence element proposed skeleton returned procedure skeletal set unit consequences 
proposition augmented clause corresponding cardinality constraint 
sets procedure expand linear number nodes finding skeletal set unit consequences 
dixon ginsberg hofer luks parkes proof 
original cardinality constraint xm sym set xi xm show leon pruning lemma suffices reduce search quadratic size 
basic idea part proof follows 
suppose expanding particular node corresponding selection image point xi image xi selected prune immediately 
image selected image smallest available point set question lexicographic reasons 
addition original symmetry literals require literals satisfied unvalued selected order expansion 
argument formally note sym sym sym sym sym 
assume loss generality points fixed coset decomposition tree xi order continue denote fixed image xi particular search node zi 
denote gamma sequence zi depth node question gamma fixed part image clause set total number points valued unsatisfied 
prune node 
gamma 
nodes pruned image meets set satisfied literals 

gamma 
nodes pruned image includes unsatisfied literals 

gamma hy yj ui yi minimal leon lemma requires zj min yj 
yi outside ky yj sym yj assumed node pruned 

gamma hy 
yji 
yj elements order yj element argument identical previous paragraph ky yj includes full symmetry group remaining elements follows unpruned nodes search gamma hy 
min gamma hy 
yj yj 
min minimal element yi smallest elements order 
need possible values zap implementation depth tree clause completely instantiated 
linear number nodes type quadratic number nodes second 
reduce total number nodes searched linear repeat argument discussion example lemma 
considered node image 
consider slightly general case gamma hz 
zk zi sequence zk zk 
lemma gx xk full symmetry group remaining xi xk 
xm 
sym 
xm sym xm 
xm 
statement lemma gives jm xi jm xk sym xk xk result zk xk xk tk zk node pruned 
fixes position list point sequence yi reduces number search nodes linear 
proposition suppose watching set literal 

watching set backtrack point 
settled hp li watching set hp li 

settled hp li watching set hp li 

watching set hp li 
proof 
hard 
note backtrack point watching set watching set 
second claim settled hp li possibilities 
unsettled addition caused settled li proper 
unsettled hp li watching set 

settled hp li watching set 
third claim follows second assumed watching set fourth claim suppose hp li remains watching set 
satisfied settled added continues watching set virtue second claim 
dixon ginsberg hofer luks parkes remaining case potentially smaller removed adjoined impact intersection watching set 
watching set proves final claim 
proposition suppose watching set literal 

watching set backtrack point 
cg watching set hp li 

cg hp li cg unsettled hp li watching set hp li 

cg hp li watching set hp li 
proof 
know watching set instance proposition show claims follows 
proposition states directly watching set instance backtrack point second cg cg 
second claim follows fourth claim proposition 
remaining claims interesting 
third suppose cg instance 
cg settled hp li know watching set hp li 
watching set cg hp li 
cg unsettled hp li condition claim says cg hp li watching set cg hp li 
completes proof third claim 
fourth final claim cases 

cg unsettled hp li note cg cg hp li cg hp li watching set cg hp li 
hp li cg hp li cg hp li watching set 

cg unit hp li consider cg know fourth claim proposition watching set cg hp li 
follows cg 

zap implementation cg cg form cg xk new unit consequence xi 
note hp li 
cg hp li violation premise claim 

cg satisfied hp li know watching set cg hp li trick show remove safely 
cg obviously 
cg need show third claim proposition applied need show cg cg assumption cg hp li note hp li intersection equivalent cg hp li follows follow show cg hp li cg hp li cg proper hp li 
cg inclusion holds cg cg satisfied hp li cg satisfied 
involves backtrack backtrack point cg cg 
second inclusion holds literals satisfied necessarily unvalued 
combining gives result proved 
procedure group sets acted bound compute overlap collection elements sufficient guarantee ch collection exists dixon ginsberg hofer luks parkes orbit 
bk minimal block system bi delta min bi delta delta return return proposition procedure returns nonempty set procedure returns value excess case ch proof 
claim examine procedures 
clear procedure returns soon procedure concludes minimum overlap greater need simply argue nonempty 
increment line nonempty delta zero line 
second part imagine replacing procedure set returned 
computation unchanged step follows 
procedure groups element sets optionally watched element find transport skeletal set unit consequences zap implementation supplied wt ch return hfalse overlap st return hfalse overlap return hfalse ti ch ct return htrue return hfalse pruning lemma applied return hfalse ff element ch supplied cth choose ff wt ffh hff hu xi transport hff true return htrue hl gt hl gi return hfalse proposition suppose overlap computed procedure satisfies proposition 
cg cg cg transport computed procedure returns htrue procedure returns hfalse skeletal set unit consequences ch ch ch unsettled proof 
restriction permutations cg enforced lines procedure note contradiction line points fixed cg certain 
note prune basis affecting correctness procedure pruning lemmas restricted group leaves watched literal intact 
difference procedure procedure involves computation set watched literals 
set produced line know proposition set sufficient guarantee cht cht current residual search tree 
show satisfying conditions proposition covered 
see consider point node pruned procedure show points covered exclusions statement proposition 
prune line occur cht dixon ginsberg hofer luks parkes 
prune line occur cht cht settled 
pruning lemma applied eventual solution shown minimal usual double coset gg 
case watching set operated statement proposition 
procedure unit propagation compute unit propagate set watched augmented clauses annotated partial assignment set pairs hl ri literals reasons hl ri element hl ri hp hl rii hr transport true li literal ch highest index return htrue resolve ch ci complete literal ch unassigned hz hz chi transport failure return hfalse proposition annotated partial assignment set watched augmented clauses watching set set unit consequences clauses unit propagate true ci augmented clause nogood modified watching sets watching sets value returned hfalse watching sets replaced watching sets proof 
really just matter assembling pieces 
procedure essentially loop literals original procedure 
literal find unit clauses contain appropriate call transport clause watched 
transport call reveals presence contradiction return resolvent reasons usual 
contradiction adjust partial assignment procedure add new unit consequences zap implementation list remains analyzed update watching set accordance propositions 
remaining issue removal watching set line procedure 
precisely fourth claim proposition applied 
note call transport hp li added line 
require instance cg intersection cg obviously unaffected removal lemma ae nogoods 
proof 
immediate 
soon literal happen eventually literals removed definition falsification depth exceed 
procedure suppose augmented clauses ff fi unit partial assignment hl 
ff fi 
find minimal resolvent ff fi lambda literals avoid fff ff fif fi ff fi transport ff lp 
ln transport fi lp 
ln failure failure lp fff ffg fif fff fif return resolve fff fif proposition suppose augmented clauses ff fi ff fi unit partial assignment ff fi 
value returned procedure minimal resolvent ff fi 
proof 
need show procedure terminates returns resolvent result minimal 
show procedure terminates show reduced iteration main loop 
iteration know lp fff fif iteration line selected fff fif unchanged lp added means longer satisfied satisfied li reduced line 
hand lines selected know definition lines literal lp 
ln fff fif 
words lp 
ln fff fif reduced procedure terminates 
returns resolvent clear 
dixon ginsberg hofer luks parkes see value returned minimal suppose gm hm fff fif show fff fif permutations returned line 
set fff fif point included images produced procedure images provided hypothetical counterexample 
fff fif sets agree literals index greater lz fff fif initial value set line procedure terminates final value consider point procedure changes value change lp added transport calls failed impossible say image ff avoid lp 
ln know fff avoids lp 
ln avoids lp 
ln assuming lp transport gl ff lp 
ln succeeded 
follows change lines 
impossible fact successfully managed avoid lz contradicts assumption fff fif lz fff fif appendix zap problem format historically boolean satisfiability problems typically format variables correspond positive integers literals nonzero integers negative integers negated literals clauses terminated zeroes 
dimacs format precedes actual clauses problem single line cnf indicating variables appearing clauses problem 
numerical format impossible exploit existing understanding user problem question may problem conventional boolean tool problem structure obscured boolean encoding event felt inappropriate building augmented solver 
felt important user able 
specify numerical constraints appear cardinality parity constraints 
quantify axioms finite domains 
provide group augmentations explicitly mechanisms insufficient 
discussing specific provisions zap areas zap input file begins list domain specifications giving names sizes domain theory 
followed predicate specifications giving arity predicate domain type argument 
predicates domains defined possible refer predicate instances directly indicating pigeon third hole nonground fashion 
zap implementation group definition group specified directly assigned symbolic designator augmented clause 
group syntax conventional group described terms generators permutation 
permutation list cycles cycle space separated list literals 
augmented clause uses previously defined group form clause group group ground clause essentially sequence literals designator group 
group augmented clause group collectively generated example group encoding pigeonhole instance involving pigeons holes domain specs sort pigeon sort hole predicate specs predicate pigeon hole group specs group permute pigeons permute holes group encoding group group types domain variables pigeons holes 
single predicate indicating pigeon particular hole 
single group corresponds symmetries holes pigeons 
generate group generators 
correspond symmetry pigeons generator swapping pigeons second generator rotating pigeons 
recall permutations generate symmetry group pigeons 
second pair generators generate symmetry holes similarly generator swapping holes second generator swapping holes 
generate 
turning axioms says hole contain pigeons hole contain distinct pigeons virtue group action 
second axiom says pigeon hole pigeon 
dixon ginsberg hofer luks parkes cardinality parity constraints group specified directly general form zap axiom quantifiers clause result quantifiers described 
result includes information desired right hand side axiom simple terminator indicating clause boolean comparison operator followed integer indicating clause cardinality constraint mod operator followed integer indicating sum values literals required congruent mod 
quantification quantifiers form 
xk 
xk xi variables appear predicate instances 
addition classical quantifiers introduce 
xk quantifier means variables take values cause quantified predicate instances identical 
example axiom saying pigeon hole contrast conventional specific pigeon hole instance 
equivalent inappropriate inclusion pigeonhole formulation 
new quantifier understood light discussion section zap argued cases quantification fact natural provided 
quantification far easier represent augmented clauses avoids cases need introduce reason equality 
event zap supports forms universal quantification quantifier encoding pigeonhole problem zap implementation sort pigeon sort hole predicate pigeon hole quantification encoding forall exists pigeon instance 
axioms say directly hole contain distinct pigeons note pigeon hole encoding presumably intuitive previous 
aho hopcroft ullman 

design analysis computer algorithms 
addison wesley 
babai moran 

arthur merlin games randomized proof system hierarchy complexity classes 
comput 
system sci 
barth 

davis putnam enumeration algorithm linear optimization 
tech 
rep mpi max planck institut ur informatik saarbr germany 
bayardo miranker 

complexity analysis space bounded learning algorithms constraint satisfaction problem 
proceedings thirteenth national conference artificial intelligence pp 

bayardo schrag 

csp look back techniques solve real world sat instances 
proceedings fourteenth national conference artificial intelligence pp 

dixon ginsberg 

combining satisfiability techniques ai 
knowledge engrg 
rev 
dixon ginsberg luks parkes 

generalizing boolean satisfiability ii theory 
journal artificial intelligence research 
dixon ginsberg parkes 

generalizing boolean satisfiability background survey existing 
journal artificial intelligence research 
furst hopcroft luks 

polynomial time permutation groups 
proceedings st annual ieee symp 
foundations computer science focs pp 

ieee 
gap group 
gap groups algorithms programming version 
www gap system org 
ginsberg 

dynamic backtracking 
journal artificial intelligence research 
ginsberg parkes 

search 
proceedings seventh international conference principles knowledge representation reasoning breckenridge colorado 
dixon ginsberg hofer luks parkes gomes selman 

problem structure presence perturbations 
proceedings fourteenth national conference artificial intelligence pp 
providence ri 
haken 

intractability resolution 
theoretical computer science 
harrison 

switching automata theory 
mcgraw hill 
van 

aligning cnf equivalence reasoning 
seventh international conference theory applications satisfiability testing pp 

available www satisfiability org sat programme pdf 
hooker 

generalized resolution cutting planes 
annals operations research 
jerrum 

compact representation permutation groups 
algorithms 
knuth 

notes efficient representation permutation groups 
combinatorica 
leon 

permutation group algorithms partitions theory algorithms 
symbolic comput 
li 

integrating reasoning davis putnam procedure 
proceedings seventeenth national conference artificial intelligence pp 

li 

equivalent literal propagation davis putnam procedure 
discrete app 
math 
li purdom jr 

integrating symmetry breaking dll procedure 
fifth international symposium theory applications satisfiability testing sat pp 

moskewicz madigan zhao zhang malik 

chaff engineering efficient sat solver 
th design automation conference 


lower bounds resolution cutting planes proofs monotone computations 
symbolic logic 


theory groups 
springer 
schaefer 

complexity satisfiability problems 
proceedings tenth annual acm symposium theory computing pp 

seress 

permutation group algorithms vol 
cambridge tracts mathematics 
cambridge university press cambridge uk 
sims 

computational methods study permutation groups 
leech 
ed computational problems algebra proc 
conf 
oxford 
pergamon press 
tseitin 

complexity derivation propositional calculus 

ed studies constructive mathematics mathematical logic part pp 

consultants bureau 
zap implementation urquhart 

hard examples resolution 
jacm 
zhang stickel 

implementing davis putnam method 
journal automated reasoning 

