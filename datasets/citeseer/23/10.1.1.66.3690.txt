type system founded recursion derek dreyer robert harper karl crary july cmu cs school computer science carnegie mellon university pittsburgh pa interest designing recursive module extension ml simple general possible propose novel type system general recursion effectful expressions 
presence effects necessitate backpatching semantics recursion scheme type system ensures statically recursion founded body recursive expression evaluate attempting access undefined recursive variable avoids unnecessary run time costs associated backpatching 
ensure founded recursion presence multiple recursive variables separate compilation track usage individual recursive variables represented statically names 
type system may eventually integrated smoothly ml reasoning involving names required inside code uses recursive construct need infect existing ml code 
material supported part nsf ccr ccr 
opinions findings recommendations publication author reflect views agency 
keywords type theory recursive modules computational effects founded recursion 
distinguishing feature programming languages ml family standard ml objective caml strong support modular programming 
module systems languages strictly hierarchical prohibiting cyclic dependencies program modules 
restriction unfortunate means mutually recursive functions types defined module regardless belong conceptually module 
consequence recursive modules commonly requested extensions ml languages 
years recursive module extensions variety functional languages 
main stumbling blocks designing extension impure language ml interaction module level recursion core level computational effects 
core language ml permits recursive definitions abstractions functions recursive linking arguably restricted modules contain fun bindings 
computational effects quite severe restriction recursive module programming 
recursive module proposals attempt ameliorate restriction splitting modules recursively linkable section initialization section subjecting syntactic restrictions 
construct certainly flexible forbids effects entirely imposes structure recursive modules arbitrary 
suggested abandoning ml style modules altogether favor mixin modules units recursive linking norm hierarchical linking special case 
purpose extending ml constitute drastic revision language support feature may needed occasion 
recursion effects interest designing recursive module extension ml simple general possible suppose introduce new form structure declaration structure rec structure may refer recursively priori limitations recursion interact computational effects may occur evaluation 
standard interpretation recursion fixed point operator new recursive structure declaration tantamount structure fix fix evaluates unrolling fix 
fixed point semantics property computational effects re enacted recursive inherently wrong behavior undesirable intended uses recursive modules 
example consider declaration mutually recursive structures 
debug trace externally accessible debugging flags respectively 
fixed point semantics recursive prompts re evaluation entire module including creation brand new ref cells debug trace 
words recursive call operates entirely different mutable state setting debug true externally alter fact debug false recursive calls alternative semantics recursion exhibits appropriate behavior respect computational effects backpatching semantics scheme structure rec evaluate follows bound fresh location containing undefined value evaluated module value evaluation attempts dereference run time error reported 
fixed point semantics backpatching ensures effects happen 
argue backpatching semantics really achieves ability write excessively recursive definitions 
example effectful definitions debug trace really participate recursion 
imagine semantics structure rec models recursion fixed point effects outside fixed point occur 
hoisting effects may result behavior backpatching semantics denote capture avoiding substitution structure rec struct structure struct val debug ref false fun structure struct val trace ref false fun example recursive module effects functor sig functor sig structure rec struct structure structure separate compilation recursive modules effect question state known true continuations matters continuation captured inside outside recursive definition 
hoisting effects impossible context separate compilation 
particular consider shows structures may developed apart abstracting recursive variable structure rec linking may compiled separately case access implementations way hoist effects 
backpatching semantics simpler cleaner general approach 
founded recursion russo employs backpatching semantics described recursive module extension moscow ml 
russo extension advantage relatively simple largely type system attempt statically ensure structure rec founded evaluation dereference possible compile time error detection preferable 
addition statically ensuring allow recursive modules implemented efficiently 
absence static detection known implementation choices recursive variable implemented pointer value option type initially case dereference perform tag check see implemented pointer thunk initially fn raise error case dereference perform function call 
way mutually recursive functions defined module boundaries noticeably slower ordinary ml functions 
recursion statically known founded value pointed needed access require single pointer dereference 
propose type theoretic approach ensuring founded recursive definitions backpatching semantics recursion 
basic idea model recursive variables statically names names track set recursive variables piece code may attempt dereference evaluated 
names inspired core language metaprogramming symbolic computation closer detail concurrent names model control effects 
names important tracking uses multiple recursive variables presence nested recursion equally important feature approach require changes recompilation existing ml code 
number difficult issues surrounding static type components recursive modules restrict attention dynamic code components recursive modules 
correspondingly develop type system level recursive core level expressions 
intend extension core language ml basis extension module language 
overview remainder organized follows section introduce notion ensures program safe evaluate contains free undefined recursive variables 
series examples illustrate simple approach tracking suffers number theoretical practical problems 
section core type system solving problems context pure simply typed calculus 
effects necessitate backpatching semantics recursion subtleties involving names fact explored absence effects 
give static dynamic semantics core language meta theoretic properties including type safety 
section show encode unrestricted form recursion extending language memoized computations 
unrestricted construct ensure founded recursion useful fallback circumstances type system weak observe recursive term founded 
section compare approach related section conclude suggest 
consider general recursive construct form rec 
representing expression type may refer ultimate value recursively required ensure rec 
wellfounded 
crary require valuable pure terminating context 
generalize notion permitting effects call term may judged evaluable evaluation access undefined recursive variable 
ensure rec 
founded expression evaluable context uses variable non evaluable 
expression non evaluable formed evaluable expressions safe evaluate presence undefined recursive variables 
formally incorporate type system dividing typing judgment classifying evaluable terms classifying non evaluable terms 
implicit inclusion 
addition need extend language notion undefined variables call names 
write names capital letters opposed variables appear lowercase 
distinction seen typing rules extensions give typing rule recursive expressions judgment rec 
true clearly undecidable property certain kinds expressions expect type system recognize evaluable 
instance recall example recursively defines pair submodules pair ref expression abstraction 
general values tuples evaluable expressions considered evaluable 
addition ref evaluable long constituent expressions 
independent computational purity 
correspondence non computational impurity sense hidden abstractions unleashed function applications 
ml assume purpose value restriction function applications potentially impure 
current setting similarly assume simplicity function applications potentially non evaluable 
unfortunately assumption major drawback implies evaluate function application inside recursive expression 
furthermore usually unnecessary functions defined inside recursive expression may hiding name functions defined existing ml code 
example defining local state ref expression suppose wish define mutable array submodule call array creation function structure struct val array array fun array update fun 
call array array perfectly evaluable call function inside module 
lumping assuming worst judgment far conservative 
partial solution distinguish types total partial functions 
purposes total arrow type classifies function body evaluable partial arrow type classifies function body potentially non evaluable correspondingly applications total evaluable functions evaluable arguments deemed evaluable applications partial functions assumed non evaluable total partial distinction addresses concerns discussed previous section extent 
existing ml functions classified total arrow type ml proper synonymous total arrow 
may evaluate calls existing ml functions presence undefined names inside recursive expression function applications known evaluable 
serious problems 
recursive functions consider happens general recursion define recursive function factorial rec int int 
fn 
note forced give recursive expression partial arrow type body factorial function uses recursive name exporting factorial partial function bad means application factorial evaluated inside recursive expression 
problem observe factorial function partial evaluation general recursive expression defining total soon definition 
way incorporate observation type system revise typing rule recursive terms rec 
ignore partial total discrepancies matching declared type actual type example factorial definition allow name declared total arrow int int body definition equivalent type modulo partial total mismatch 
unfortunately revised typing rule sound prohibit nested recursive expressions 
may erroneously turn truly partial function total code illustrates rec 
val rec unit 
fn problem evaluation recursive expression defining results backpatching unsound expression type fn total 
calculus section employ similar idea way sense presence multiple names 
higher order functions problem total partial distinction arises higherorder functions 
suppose wish standard basis map function lists type val map list list type map pure ml type arrows total means apply map partial function rec sig 
val val list list map 
type map reasonable know map implemented way knowing evaluating map try apply resulting potential dereference able replace map eta expansion fn xs map xs clearly evaluable value 
eta expansion ill typed type match argument type map 
really type system say map ill typed merely non evaluable 
observation fall naturally name semantics section 
separate compilation russo points problem separate compilation recursive modules moscow ml applies equally system sketched far way refer recursive variable dereferencing 
instance recall separate compilation scenario 
code ill typed current setup call value semantics functor applications evaluating recursive variable undefined 
really intended functor applications dereference name pass resulting module value argument pass name argument 
way account intended semantics treat recursive variable potentially divergent expression value new location type dereferenced explicitly 
idea fleshed name core calculus 
variables variables names names supports names types terms box unbox rec 
values typing contexts core language syntax name core calculus order address problems enumerated previous section core calculus generalizes judgment tracks uses individual names 
new judgment form interpretation context term type evaluable modulo names set 
words evaluate dereferencing names possibly call finite set names support 
previous judgment correspond modulo empty support correspond modulo non empty support 
major difference calculus language sketched section distinction names recursive variables 
particular recursive variable split static component name dynamic component variable 
result recursive expressions form rec 
static dynamic component recursive variable 
name static representative recursive variable supports variable stands actual location store recursive value 
limited role static representative name longer term construct assigned type context 
consequently previously wrote rec 
written rec 
replaces occurrences expression explicit dereference written unbox 
distinguishing static dynamic aspects recursive variable affords simple solution separate compilation problem discuss section 
syntax syntax core language 
assume existence countably infinite sets names names variables variables range supports 
write name shorthand singleton support 
type structure language follows 
unit pair types require explanation 
arrow type bears support arrow indicates set names associated recursive variables defined function type may applied 
write shorthand arrow type empty support 
language provides ability expression name 
type classifies name abstractions suspend evaluation bodies treated values 
application notation inspired confused harper lillibridge notation labels variables module calculus 
labels distinguish external names module components internal variable names 
recursive construct bound inside name abstraction allows name parameter instantiated support just single name 
reasons allowing names instantiated supports discussed section 
lastly location type classifies memory location contain value type recursive variables associated names defined 
locations commonly introduced recursive expressions dynamic component recursive variable location may introduced box evaluates boxes resulting value stores new location 
boxing may potentially create new location box value values location type variables 
elimination form location types unbox dereferences location resulting evaluation write box shorthand box 
notational conventions term variable bound term type name bound term rec 
name variable bound usual identify terms types equivalent modulo conversion bound variables 
notational convenience enforce implicit requirements formedness contexts judgments 
context formed bind variable name twice prefix form free names bound judgment form formed formed free names appearing right turnstile bound 
assume maintain implicit invariant contexts judgments formed 
static semantics main typing judgment form 
support represents set names associated recursive variables may assume defined time evaluated 
put way recursive variables may dereference associated names static semantics carefully designed validate assumption 
rules type system designed admissible principle support weakening says instance variable require support rule allows assigned support dom just empty support 
remainder rules may summarized follows 
unit needs support rule pairs projections require support constituent expressions rules 
function type support long body typed addition support rule 
evaluate function application support contain supports support arrow type rule 
name abstraction suspends evaluation body typechecked support abstraction rule 
words view kind arrow type bears empty support compare rule 
note assumptions formedness judgments ensures support contain dom dom 
restricting name abstractions motivated fact intended uses name abstractions body abstraction value empty support 
instantiating name abstraction type support type resulting substituting rule 
substitution defined replacing support appearing turn defined follows def boxing expression evaluates box support rule 
furthermore box may location type arbitrary resulting location contains defined value may unboxed immediately 
unboxing expression type permitted recursive variables associated names defined contained support rule 
rules interesting rules type system type equivalence judgment defined 
judgment means equivalent term formedness type equivalence dom box unbox rec 
core language static semantics types modulo names support identical types ignore occurrences names example types equivalent modulo support containing intuition type equivalence judgment recursive variable associated name completely ignored typechecking purposes care tracking uses undefined recursive variables 
support time evaluated recursive variables associated names defined 
context typing support types equivalent differ respect names irrelevant 
note checking equivalence arrow types modulo compare argument types result types extended modulus 
sense function types may applied support 
rule box justified similarly 
notion equivalence modulo support critical typing recursive terms 
recall factorial example section adapted core calculus rec int int 
fn unbox 
issue declared type match actual type body int int 
types match modulo correspondingly typing rule recursive terms rec 
works follows 
context extended name recursive variable type 
location type binds name variable says support expression attempts dereference unbox rule checks type extended context support include undefined evaluating 
checks equivalent modulo easiest understand step generalization earlier idea ignoring discrepancies partial total arrows comparing 
difference ignore discrepancies respect particular name names rule behaves properly presence multiple names nested recursion 
contrast rule appears straightforward allowing term type support assigned type equivalent modulo names fact rule solves higher order function problem described section 
recall wanted apply existing higher order ml function map partial function arrow type bears non empty support rec sig 
val 
val list list fn xs map xs 
problem type match argument type map 
intuitively code ought typecheck willing add support arrow type applied ignored typing body rule encapsulates reasoning 
specified type list list assume support typechecking body map xs 
support rule allows assign type equivalent type modulo body typed support name abstractions non strictness far illustrated inclusion supports typing equivalence judgments addresses problems recursive higher order functions described section 
system addresses problem separate compilation making dereferencing recursive variable explicit operation providing ability expression name 
recall separate compilation scenario 
recursive variables core language longer dereferenced implicitly attempt rewrite linking module structure rec sig structure structure recursive variable value location type sig passing argument dereference 
assuming non strict dereference argument applied recursion founded 
types give reflect property non strict 
suppose return type sig give type sig sig argument sig 
sig 
structure rec sig structure structure revised separate compilation scenario type matches type absence arrow indicates applied empty support 
type sense defined name scope outside recursive module 
name abstractions come 
show non strict irrelevant particular support required unbox argument name abstraction allow name support substituted shows resulting typed separate compilation scenario type sig sig recursive construct quite flexible separate compilation purposes 
particular suppose wanted parameterize just 
way system extract value type sig unboxing 
easy remedy problem generalizing recursive construct ary rec 
recursive variables xi boxed separately type 
name abstractions express non strictness core level ml functions turn allows founded recursive definitions typecheck 
instance suppose access code map function 
wrapping definition map name abstraction assign function type 
list list type indicates map turn value arrow type value arrow type apply argument process 
type map write recursive module example involving map way wanted write originally section rec sig 
val 
val list list map 
results better code eta expanding map requires having access implementation map 
furthermore requires modify type map infecting existing ml infrastructure names 
important absence solution type system strong rule typecheck eta expansion map requiring changes existing ml code 
example illustrates useful able instantiate name abstraction support single name 
particular suppose type non singleton support definition map possible ability instantiate map support 
small step semantics dynamic semantics continuations continuation frames box unbox rec 
value vi box box dom box unbox unbox unbox dom rec 
rec 
rec 
core language dynamic semantics formalize dynamic semantics core language terms virtual machine 
machine states consist store continuation expression currently evaluated 
stand machine state 
continuation consists stack continuation frames shown 
store partial mapping variables location type storable things 
storable thing term nonsense 
denote storable thing stored valid possibly nonsense stored denote result creating new name storing 
denote result updating store store dom 
denote empty store 
dynamic semantics language shown 
takes form stepping relation rules fairly straightforward 
rule says order evaluate rec 
create new location store bound nonsense push recursive frame rec 
continuation stack evaluate 
ensure location store conversion 
evaluated value rule performs backpatching step stores location store returns location dereferenced unboxed rule simply looks value bound store 
type safety observe machine stuck attempt unbox location bound nonsense 
point type safety theorem ensure happen formed programs 
defining notion formedness stores dependent notion runtime context 
runtime context context binds variables types variables canonical forms far means location types 
addition distinguish locations connect associated names introducing new context binding form behaves semantically bindings distinguished syntactically 
definition runtime contexts context runtime bindings take form 
definition store formedness store formed denoted 
runtime dom 



essentially judgment says assigns types locations domain locations map appropriately typed values ones associated names support define formedness continuations continuation frames judgments cont defined 
judgment says continuation expects value type fill judgment says expects value type fill produces value type return 
rule slightly unusual rule recursive frames rec 

frame binder rule requires context 
safe assumption rec 
gets pushed stack binding added store 
define notion formedness machine state requires type expression component matches type hole continuation component definition machine state formedness machine state formed denoted 


cont state preservation progress theorems leading type safety continuation formedness cont cont cont cont cont cont continuation frame formedness theorem preservation 
box unbox box rec 
formedness core continuations definition terminal states machine state terminal form 
definition stuck states machine state stuck non terminal state theorem progress stuck 
note unbox formedness implies box type 
formedness ensures value progress rule 
corollary type safety suppose 
machine state stuck 
types ref cont terms ref get set callcc throw ref ref ref get cont cont ref ref ref set cont callcc cont throw static semantics extensions effects full meta theory language proofs appendix effectiveness important language admit practical typechecking algorithm 
implicitly typed form language obvious algorithm exists terms unique types 
example type easy eliminate non determinism making language explicitly typed 
particular abstractions annotated boxed expressions annotated revised typing rules easy synthesize unique types explicitly typed terms equivalence modulo support 
see appendix details 
remains important question type support information explicitly typed terms inferred 
adding computational effects modeled semantics backpatching quite operationally terms mutable store easy incorporate actual computational effects framework 
extensions completely straightforward essentially oblivious presence supports typing judgments 
extends syntax semantics language mutable state continuations 
primitives ref get set primitives callcc throw standard typing rules 
ref cells continuations allocated store values types ref cont variables representing locations store 
think continuation kind function return type may surprising typing rules continuations oblivious names 
arrow type specifies support required call function type continuation type cont specify support support required order throw continuation 
view cont specifying empty support 
see support unnecessary consider machine state looks evaluate callcc form callcc 
assuming formed know cont callcc 
current continuation callcc bind evaluating type 
explicit continuations part continuation frames ref get set set throw throw ref ref dom ref get get get set set set set set dom callcc throw throw throw throw cx throw cx dynamic semantics extensions effects ref ref set ref throw cont get ref ref set cont throw formedness continuations effects language think function argument type applied may dereference recursive variables associated names appropriate arrow type return type 
support arrow type equivalent bearing empty support cont 
gives extensions dynamic semantics mutable state continuations 
extend stores contain mappings locations continuations rules mutable state completely straightforward 
rules continuations fairly straightforward machine state current continuation explicit 
proving type safety extensions requires simple orthogonal extension proof framework section 
judgment formedness types comp terms delay force comp comp delay comp comp force static semantics memoized computations continuations extended obvious way shown 
definition runtime contexts extended include variables type ref cont definition store formedness extended follows definition runtime contexts context runtime bindings take form ref cont 
definition store formedness store formed denoted definition 
ref 

cont 
cont encoding unrestricted recursion despite efforts type system recursive terms rec 
statically determine evaluated dereferencing cases important fallback approach allow programmer write rec 
understanding recursion may ill founded dereferences corresponding run time cost 
option add second unrestricted recursive term construct typing rule 
note introduce name restrictions dereferenced 
dereferencing may diverge mere pointer dereference assign thunk type box dereferencing achieved applying adding explicit construct redundancy recursive mechanisms language 
preferable level theory find way encode unrestricted recursion terms existing recursive construct 
achieve extending language primitives memoized computations 
syntax static semantics extension 
introduce type comps locations storing memoized computations 
value type essentially thunk type result memoized application 
machine states error continuation frames force memo dom delay force force force memo memo 
force error dynamic semantics memoization force comp comp memo formedness memoization continuations primitive delay creates memoized location store bound unevaluated expression forced force expression stored evaluated value written back evaluation location bound nonsense forced stage machine raises error 
force check see bound expression nonsense 
despite difference operational behavior typing rules memoized computations appear just comps delay force shorthand respectively 
comp shorthand comp 
encode recursive memoized computation 
def force rec comp 
delay force unbox easiest understand encoding stepping 
new recursive location created bound nonsense 
delay creates new memoized location bound expression 

rec value returns forced resulting evaluation 
value recursive variable encoded force unbox dereferenced applied evaluation 
result forcing raising run time error 
essentially view rec encoding merely tying recursive knot memoized computation memoization resulting force performs backpatching 
observe give comp non semantics consider synonymous encoding precisely fixed point semantics recursion 
memoization ensures effects happen force recursive computation 
dynamic semantics extension 
evaluate delay create new memoized location store bind rule 
evaluate force evaluate rule 
evaluates location look store 
bound expression proceed evaluate push continuation stack memoization frame remind result evaluating memoized rules 
bound nonsense middle evaluating force step error state halts program rule 
extending type safety proof handle memoized computations straightforward 
continuation frame formedness extended rules 
update definition runtime contexts include memoized location bindings formed terminal states include error store formedness account memoized locations definition runtime contexts context runtime bindings take form ref cont comp 
definition machine state formedness machine state formed error formed definition 
definition terminal states machine state terminal error terminal definition 
definition store formedness store formed denoted definition comp 
related founded recursion boudol proposes type system founded recursion employs backpatching semantics 
boudol system tracks degrees expressions depend free variables degree depends appears guarded position abstraction 
call support expression corresponds boudol system set variables expression depends degree 
distinction recursive ordinary variables boudol system equivalent rec 
ensures evaluation dereference requiring depend degree 
system arrow type indicates recursive variables may dereferenced function type applied 
arrow type boudol system indicates degree body function depends argument 
classify functions strict non strict arguments respectively 
discussed section ability identify non strict functions especially important purposes separate compilation 
example order typecheck separate compilation scenario necessary know separately compiled functors non strict 
contrast system requires code rewritten shown boudol system typecheck code essentially reason function applications form argument variable treated special case semantics expression depends variable degree merely passes dereferencing 
implies ordinary bound variables may instantiated run time recursive variables 
system boxes recursive variables implementation boudol system forced box variables 
simplicity boudol system achieved expense conservative 
particular function application considered depend free variables degree 
suppose curried function dereferences recursive variable type system allow argument instantiated type empty support 
boudol system application depend degree appear unguarded recursive term defining address limitations boudol system hirschowitz leroy propose generalization target language compiling mixin module calculus 
specifically extend boudol notion degrees arbitrary integers degree depends roughly number abstractions appears continuing example function depend degree instantiating argument decrement degree 
purpose compiling mixin modules primary feature required hirschowitz leroy target language ability link mutually recursive abstractions compiled separately 
illustrated section calculus provides feature 
addition simple examples name system easily accounts strictness analysis hirschowitz leroy 
instance variable thunk type expressions considered strict identity function apply function considered strict functions 
result applying function thunk considered strict identity function clearly apply thunk 
contrast type system observes identity total applied empty support 
weak polymorphism effect systems analogy approaches discussed tracking founded recursion combining polymorphism effects early days ml 
boudol distinction reminiscent tofte distinction imperative applicative type variables 
hirschowitz leroy generalization boudol similar idea weak polymorphism implemented macqueen earlier versions sml nj compiler type variable carries numeric strength representing roughly number function applications required ref cell created storing value type 
system ties effect systems style talpin jouvelot arrow type indicates set effects may occur function type applied 
effect question dereferencing undefined recursive variable represented statically name 
common criticism leveled effect systems weak polymorphism functional imperative implementations polymorphic function different types impossible know type expect designing specification module separate implementation 
system avoids problem names infect types recursive modules separately compiled parts may completely ignore names designing external interface recursive module 
possible notion type equivalence modulo support appears novel specific founded recursion problem 
names idea names core calculus inspired modal logic names model metaprogramming language symbolic computation 
names turn inspired pitts gabbay freshml 
uses names represent undefined symbols appearing inside expressions modal type 
expressions viewed pieces syntax free names defined compiled 
names conceptually closer concurrent names model control effects notion handling 
mentioned earlier think dereferencing recursive variable effect sense handled backpatching variable 
formally system quite different employ judgment type equivalence modulo support plays critical role system 
monadic recursion considerable adding effectful recursion haskell 
effects haskell isolated monadic computations adding form recursion effectful expressions requires understanding recursion interacts monads 
erk launchbury propose monadic fixed point construct mfix defining recursive computations monads satisfy certain set axioms 
show mfix define recursive form haskell construct 
friedman sabry argue backpatching semantics recursion fundamentally stateful defining recursive computation monad requires monad combined state monad 
approach allows recursion monads obey erk launchbury axioms continuation monad 
primary goal type system statically ensure founded recursion impure call byvalue setting recursive monadic computations haskell avoids static analysis largely orthogonal 
dynamic semantics language borrows moggi sabry give operational semantics monadic metalanguage extended friedman sabry mfix 
recursive modules recursive module proposals restrict form recursive module construct recursion defined effectful expressions 
exception russo extension moscow ml employs unrestricted form recursion similar construct section 
leroy experimental extension caml permits arbitrary effects recursive modules restricts backpatching modules pointed type modules export functions lazy computations 
restriction enables efficient implementation pointed types appropriate bottom value initialize recursive variable 
apply optimization 
case pointed 
system permits examples leroy extension 
crary harper puri give foundational account recursive modules models recursion fixed point module level 
fixed point semantics sense require body fixed point module valuable pure terminating context recursive variable non valuable 
judgment section seen generalization 
similarly flatt felleisen proposal units divides recursive module construct recursive section restricted contain valuable expressions unrestricted initialization section evaluated recursive knot tied 
duggan study mixin module extension ml allows function datatype definitions span module boundaries 
flatt felleisen confine extensible function definitions mixin section mixin module separate effectful initialization section 
proposals ancona zucca calculus cms purely functional call name mixin modules 
direction ancona extends cms computational effects encapsulated monads 
handle recursive monadic computations recursive construct erk launchbury 
direction hirschowitz leroy transfer cms call value setting 
type system perform static analysis mixin modules ensure founded recursive definitions requires strictness dependencies module components written explicitly interfaces modules 
clear interfaces containing dependency graphs incorporated practical programming language 
proposed novel type system general recursion effectful expressions serve foundation recursive module extension ml 
presence effects necessitate backpatching semantics recursion scheme type system ensures statically recursion founded avoids unnecessary run time costs associated backpatching 
ensure founded recursion presence multiple recursive variables separate compilation track usage individual recursive variables represented statically names 
core system easily extended account computational effects mutable state continuations 
addition extend language form memoized computation allows write arbitrary recursive definitions expense additional run time cost 
explicitly typed version type system admits straightforward typechecking algorithm serve target language compiling recursive extension ml 
important direction determine extent names available ml programmer 
depend heavily degree types involving names inferred typechecking recursive modules 
key direction scale approach module level 
addition issues involving recursion level types question names recursion interact module level features type generativity 
currently investigating question combining language previous type system higher order modules 
davide ancona sonia eugenio moggi elena zucca 
mixin modules computational effects 
international colloquium languages automata programming eindhoven netherlands 
davide ancona elena zucca 
primitive calculus module systems 
international conference principles practice declarative programming volume lecture notes computer science pages 
springer verlag 
gerard boudol 
recursive record semantics objects revisited 
research report inria 
appear journal functional programming 
karl crary robert harper puri 
recursive module 
conference programming language design implementation pldi pages atlanta ga derek dreyer karl crary robert harper 
type system higher order modules 
acm symposium principles programming languages pages 
derek dreyer robert harper karl crary 
practical type theory recursive modules 
technical report cmu cs school computer science carnegie mellon university march 
dominic duggan 
mixin modules 
acm sigplan international conference functional programming pages philadelphia pennsylvania june 
dominic duggan 
parameterized modules recursive modules mixin modules 
acm sigplan workshop ml pages baltimore maryland september 
erk john launchbury 
recursive monadic bindings 
international conference functional programming pages paris france 
erk john launchbury 
recursive haskell 
haskell workshop october 
matthew flatt matthias felleisen 
units cool modules hot languages 
acm sig plan conference programming language design implementation pages montreal canada june 
daniel friedman amr sabry 
recursion computational effect 
technical report tr indiana university december 
john greiner 
weak polymorphism sound 
journal functional programming 
robert harper mark lillibridge 
type theoretic approach higher order modules sharing 
acm symposium principles programming languages pages portland january 
tom hirschowitz xavier leroy 
mixin modules call value setting 
european symposium programming volume lecture notes computer science pages 
richard kelsey william clinger jonathan rees eds 
revised report algorithmic language scheme 
higher order symbolic computation september 
xavier leroy 
proposal recursive modules objective caml may 
available author web site 
robin milner mads tofte robert harper david macqueen 
definition standard ml revised 
mit press 
eugenio moggi amr sabry 
monadic semantics value recursion 
workshop fixed points computer science april 

meta programming names necessity 
international conference functional programming pages pittsburgh pa 
significant revision available technical report cmu cs carnegie mellon university 

modal calculus effect handling 
technical report cmu cs carnegie mellon university june 
objective caml 
www ocaml org 
andrew pitts murdoch gabbay 
metalanguage programming bound names modulo renaming 
roland backhouse jos nuno oliveira editors mathematics program construction volume lecture notes computer science pages 
springer 
claudio russo 
recursive structures standard ml 
international conference functional programming pages florence italy september 
jean pierre talpin pierre jouvelot 
type effect discipline 
information computation 
mads tofte 
operational semantics polymorphic type inference 
phd thesis university edinburgh 
andrew wright 
simple imperative polymorphism 
lisp symbolic computation 
meta theory proof type safety definition context inclusion context included context denoted contains bindings possibly 
proposition type equivalence equivalence relation type equivalence modulo equivalence relation formed types 
proof straightforward 
proposition exchange formed permutation proof straightforward 
proposition weakening suppose 




cont cont 


proof straightforward induction derivations 
lemma substitution 





dom 

dom 
proof straightforward induction derivation premise 
invariant parts maintained inductively supports premises typing rule supersets support 
lemma inversion 












box 

unbox box 


rec 


ref ref 

get ref 

set ref 

callcc cont 

throw cont 

delay comp 

force comp 
proof language construct bottom typing derivation consists instance typing rule construct followed sequence applications type equivalence rule 
sequence reduced application rule transitivity equivalence 
derivation know exists derivation inference rule applied typing rule corresponding outermost construct rest completely straightforward parts part substitution 
theorem preservation 
proof cases second premise 
case rule 
value 
formedness cont 

inversion 

rule cont 
case rule 

formedness cont 

rule cont 
case rule 

formedness cont 

rule 
case rule 

formedness cont 

inversion 
rule cont 
case rule 
vi 
formedness cont 

inversion vi 
case rule 

formedness cont 

inversion 

rule cont 
case rule 

formedness cont 

rule cont 
case rule 

formedness cont 

inversion 

substitution 
case rule 

formedness cont 

inversion 

rule cont 
case rule 

formedness cont 

inversion 
substitution 
case rule 
box box 
formedness cont box 

inversion 

rule box cont 
case rule 
dom box 
formedness cont 

weakening cont 

rule 
case rule 
unbox unbox 
formedness cont unbox 

inversion box 

rule unbox box cont 
case rule 
unbox 
formedness cont box 

inversion bound case 

store formedness 
case rule 
dom rec 
rec 

formedness cont rec 


inversion 

weakening cont 

rule rec 
cont 

weakening 
case rule 
rec 

formedness cont 

weakening rule cont 

weakening 
case rule 
ref ref 
formedness cont ref 

inversion ref 

rule ref cont 
case rule 
dom ref 
formedness ref cont 

weakening ref 

rule ref ref 
case rule 
get get 
formedness cont get 

inversion ref 

rule get ref cont 
case rule 
get 
formedness cont ref 

inversion ref 

store formedness 
case rule 
set set 
formedness cont set 

inversion ref 

rule set ref cont 
case rule 
set set 
formedness cont ref 

rule set cont 
case rule 
set 
formedness cont ref 

inversion ref 



rule 
case rule 
dom callcc 
formedness cont callcc 

inversion cont 

weakening cont cont cont 
case rule 
throw throw 
formedness cont throw 

inversion cont 

rule throw cont cont 
case rule 
throw throw 
formedness cont cont 

rule throw cont 
case rule 
cx throw cx 
formedness cont 

inversion cont 

cx cont 
case rule 
dom delay 
formedness cont delay 

inversion comp 

weakening 

rule 
case rule 
force force 
formedness cont force 

inversion comp 

rule force comp cont 
case rule 
force memo 
formedness cont comp 

rule memo cont 

inversion comp 

store formedness 
case rule 
memo 
formedness cont comp 

inversion comp 


case rule 
trivial error formed 
lemma canonical forms suppose runtime 

form 
form 
form 
form 
variable 
force error proof straightforward 
theorem progress terminal exists proof terminal done 
assume terminal 
form cont 
value progress rules 
suppose value 
non terminal form form box rec 
ref set throw memo progress rules respectively 
remaining cases straightforward canonical forms form progress rule 
form progress rule 
form progress rule 
unbox box variable progress rule 
get ref variable progress rule 
set ref variable progress rule 
throw cont variable progress rule 
force comp variable progress rule 
typechecking explicitly typed calculus give typechecking algorithm explicitly typed version language implicitly typed version save modifications rules 
cont throw cont callcc delay comp typechecking algorithm takes input context explicitly typed term support synthesizes unique type support 
check particular type synthesize unique type check equivalent modulo synthesis algorithm shown 
usual implicit assumptions formedness judgments defined free names right turnstile bound context 
decidability explicitly typed system follows fact synthesis algorithm sound complete 
prove soundness synthesis algorithm need technical lemma 
alternatively modify second premise typing rule recursive terms rule order match second premise corresponding synthesis rule 
lemma just shows modified version typing rule admissible 
lemma division support exists type 
proof induction derivations 
interesting cases carry support form 
case define 
need show si ti si 
show proof completely symmetric 


subtracting sides 
expanding definition 
right hand side equal 

expanding clear 
define si 
clearly 
induction exists define 
rule si 
type checking type synthesis dom 
ref ref unbox rec 
cont callcc ref get delay comp theorem soundness algorithm 
ref set cont throw comp force typechecking algorithm proof straightforward induction algorithm 
interesting case synthesis rule recursive terms 
case know induction 
lemma know exists 
rule desired result follows rule 
theorem completeness algorithm 
proof straightforward induction derivations 
interesting case typing rule recursive terms 
induction 
second premise typing rule tells weakening 
definition synthesis rec 

critical second premise synthesis rule recursive terms modulus just 

