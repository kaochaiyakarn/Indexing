structured types separation logic harvey tuch sydney research lab national ict australia australia school computer science engineering unsw sydney australia harvey tuch com au structured types arrays structs additional challenges pointer program verification 
conventional proof abstractions multiple independent typed heaps separation logic previous built low level memory model shown sound directly applicable verifications 
due non monotonic nature pointer lvalue validity presence unary operator 
example type safe updates pointers fields struct break independence updates typed heaps conjuncts 
generalisation earlier formal memory model captured low level features pointers memory formed basis expressive implementation separation logic new features providing explicit support structured types 
implement framework theorem prover isabelle hol proofs machine checked 
keywords separation logic interactive theorem proving programs featuring pointers difficult verify programs indirection largely result aliasing problem 
example consider program pointer variables float int triple true unable ascertain value pointed may refer location type safe languages form aliasing call inter type aliasing ignored proofs abstraction multiple typed heaps semantic model heap function variable language type float heap float ptr float int heap int ptr int 
unfortunately luxury language features pointer arithmetic casting break illusion type safety forced adopt programmer model heap function addr byte particular wish verify systems code exploiting compiler architecture dependent language features 
national ict australia funded australian government backing australia ability initiative part australian research council 
electronically published electronic notes theoretical computer science url www elsevier nl locate entcs tuch key observation permits code violates memory type safety code remain type safe fragment earlier reconciled multiple typed heaps proof abstraction low level view memory providing rewriting approach lifting proof states byte granularity maps typed heaps 
avoided inter type aliasing considerations possible gave unified framework proofs needed consider code violated type safety 
framework included parsing tool emitted mixed deep shallow embedding schirmer hoare logic verification environment 
remains problem intra type aliasing pointers type may alias 
possible provide explicit conditions states stating presence absence aliasing cumbersome inductively defined data structures :10.1.1.11.5322
particular frame problem limits scalability verifications 
potential solution separation logic hearn reynolds providing language specifications inference rules concisely allows expression aliasing conditions assertions ensures modularity specifications :10.1.1.11.5322
previous provided shallow embedding separation logic isabelle hol building multiple typed heaps development resulting framework capable accommodating different proof techniques address aliasing 
extend framework support structured types provide details deep embedding structure type information capable handling size alignment padding restrictions semantics heap dereferencing structured types 
earlier rewrites proof rules multiple typed heaps separation logic generalised way benefit mechanisation usable verifications little new overhead 
aspects structured types previously handled semantics shallow translation trusted ml code able promoted hol level 
structs hol type encoding type unique type theorem prover 
types belonged axiomatic type class type isabelle introduced constants connected low level byte representation hol values bytes type byte list bytes byte list type typ tag type typ tag typ info type typ info functions bytes bytes converted isabelle values lists bytes suitable writing reading raw heap state 
function typ tag associated unique type tag type providing means treating language types class values hol 
typ info allowed size alignment information type calculated 
distinct isabelle pointer type isabelle type model pointer types defined datatype ptr ptr addr tuch fig 

heap update dependencies 
int char float phantom left hand side associate pointer type information pointer values isabelle type system 
primitive types char long defined library architecture compiler expected way 
struct types modelled hol level isabelle record types 
trusted ml code parser provided structured type program corresponding record declaration definitions functions appearing type requiring full structure information appear hol level 
lvalue calculations requiring full structure information inside ml parser offset size alignment calculations 
example running example consider struct declarations struct struct float int char struct triple demonstrates significant limitation earlier memory model problem update dereference type safe need consider aliasing proof rules developed far considered type unsafe region memory single type share common address despite having different related types 
similar problem effect updates struct enclosed field pointer values 
fig 
demonstrates problem manifests multiple typed heaps abstraction 
longer case updates heaps treated independently updating field type heap may affect typed heaps enclosing structs 
updating struct affects typed heaps field types fields fields 
update effects longer simple function update involve potentially multiple field updates accesses 
solution propose treat structured type information class value hol develop generalised definitions rewrites rules tuch making 
treat structured types class types provide benefits abstraction typing proofs semantic level considered terms members 
arrays heap decay corresponding pointer arithmetic inside structured values modelled definitions 
unions treated differently decaying casts byte lists value representations 
notation meta language isabelle hol conforms largely everyday mathematical notation 
section introduces non standard notation particular basic data types primitive operations 
space total functions denoted 
type variables written notation means hol term hol type 
option type datatype option new element type 
option model partial functions writing option 
constructor underspecified inverse called satisfying function update written stands 
domain restriction 
finite integers represented type word determines word length 
succinctness abbreviations word word 
functions nat convert natural numbers unsigned 
hoare triples written assertions program 
assertions syntax refer program variable current state means state 
program states bound assertions 

isabelle supports axiomatic type classes similar restrictive haskell notation ring restricts type variable types support axioms class ring 
type classes reasoned abstractly recourse just defining axioms 
type shown belong type class proof class axioms hold 
consequences class axioms follow 
isabelle hol type derive type consisting single element denoted type 
provides convenient way restrict type term working polymorphic definitions 
memory model type descriptions solution proposed requires type meta data available hol level 
needs include information type structure size alignment 
addition fine grained description value representation encoding tuch decoding functions possible extract functions specific fields structure desirable 
hol level structure objects represented potentially nested isabelle hol records 
field access update functions defined record package struct represented hol record type struct functions struct int update int int struct struct supplied write update possible helpful record functions reasoning field accesses updates detailed lower level view fields subsequence byte level value representation 
facilitate functions derived record functions included type meta data 
definition capture record access update functions fields field descriptions record field desc field access byte list byte list field update byte list functions provide connection structure value typed hol object value field structure byte list 
field access takes additional byte list parameter utilised semantics provide existing state byte sequence representing field described 
allows padding fields ability pass previous state update field description field struct field access bytes field update bs bs size type int bytes bs definition type meta data captured type description mutually inductive definitions datatype typ desc typ struct typ name typ struct nat nat typ desc field name list type description tree structures internal nodes branches labeled field names leaves corresponding fields primitive types 
leaves size alignment provided 
type description struct fig 

correspondence fields structure struct fields definition intended explicitly represent padding inserted compiler ensure alignment restrictions met 
type descriptions specialised ways typ info field desc typ desc typ byte list byte list typ desc type information provides information required describe encoding decoding representation 
type information exported function export remove dependency export leaf field descriptions collapsed byte list normalisation functions field desc leaf size replaced bs 
field access field update bs arbitrary replicate 
conservative standard compliant approach non determinism oracle 
tuch field desc int pad desc pad field desc float field desc char fig 

type description struct pad normalisation motivated observation padding fields ignored reading structured values byte representation 
may exist byte representation value primitive types 
provides means quantify compare types 
type information type type write type export type 
definition field name access update structure fields operators viewed field name list separated fields leading sub structure refer qualified field name 
qualified field name may lead field primitive structure type structure 
arrays members named index array 
table provides number functions defined type descriptions 
summarise provide examples functions backed primitive recursive definitions isabelle hol 
performs lookup path root returning sub tree offset exists 
related concept td set sub trees returned 
type struct type struct type struct td set type struct type struct type float type char pad export size td align td summing maximum leaf node sizes alignments respectively 
justified standard requirement fields aligned structures aligned 
field access ti field update ti compose respective primitive leaf functions sequentially provide expected encoding decoding functions aggregate type 
field access ti type struct bs 
bytes take size type int bs bytes take size type struct drop size type int bs definition address corresponding lvalue designated structure field access update ptr ptr val nat snd type lvalues appear semantics proof obligations statements 
definition connection hol typed value type information size alignment underlying byte representation tuch typ desc qualified field name typ desc nat sub tree offset base structure valid qualified field name leads 
td set typ desc typ desc nat set set sub trees offset base structure 
size td typ desc nat type size size td type struct 
align td typ desc nat type alignment exponent align td type struct 
field access ti typ info byte list byte list derived field access entire structure represented type information 
field update ti typ info byte list derived field update entire structure represented type information 
export typ info typ export type information 
function definitions table type description functions 
bytes field access ti type bytes bs field update ti type bs arbitrary size type size td type align type align td type type constraints section describe fundamental properties need hold isabelle hol type model type 
ensure functions defn 
rest behave expected standard proofs update rules 
available user framework 
definition mem type axiomatic type class requires size alignment related properties hold type instantiation align type dvd size type size type addr align type dvd addr conditions follow requirements standard exception final alignment constraint add pointer arithmetic better behaved holds implementations aware 
constant addr represents size address space result entire structure update independent original value bs size type field update ti type bs field update ti type bs formedness conditions type information ensure sensible values field names node sizes field descriptions wf desc type wf size desc type wf field desc type conditions detailed defn 
defn 
defn 

definition write wf desc type description node branches labelled field name 
definition write wf size desc node type description non zero size 
definition type information consistent properties hold tuch bs bs bs bs field update ti bs field update ti bs field update ti bs bs 
bs field update ti field access ti bs bs 
bs bs bs field access ti field update ti bs bs field access ti field update ti bs bs bs 
bs field access ti bs size td properties similar provided isabelle record package hol level established automatically 
definition type information formed field descriptions leaf fields consistent pair distinct leaf fields properties hold bs bs field update ti bs field update ti bs field update ti bs field update ti bs bs bs bs size td bs size td field access ti field update ti bs bs field access ti bs standard commutativity non interference properties hol level wish preserve field descriptions 
theorem mem type axioms imply properties bs size type bytes bytes bs type combinators bs size type bytes bs size type size type constraints previous section require construction suitable type information corresponding mem type instantiation proof type appearing programs wish verify 
done entirely ml level synthesising intended hol term type information directly proof unfolded definition fragile scale 
improved approach type information construction combinators allow structure built field wise generic proof rules 
approach combinators corresponding proof rules derived elide brevity 
semantics translation shallow hol embedding target expressions 
tuch provide details side effects aspects semantics translated provide simply definitions terms model heap accesses updates 
definition heap dereferences expressions semantics lifting raw heap state polymorphic lift function lift current state 
heap list addr byte nat addr byte list heap list heap list suc heap list lift addr byte type ptr lift bytes heap list size type ptr val heap update providing semantics update dereferences tuch heap mem 
int size oftype int heap update list heap list bytes 
fig 

int heap representation 
bytes addr fig 

previous heap type description valid struct pointer heap update list addr byte list addr byte addr byte heap update list heap update list xs heap update list xs heap update heap update list ptr val bytes heap list size type ptr val example translates state transformer heap update lift fig 
illustrates functions value transformations 
heap type description inside type safe fragment majority code remains implicit mapping memory locations types heap dereferences respect mapping 
earlier introduced mapping additional state component referred heap type description heap typ desc addr typ tag option heap type description history variable influence semantics programs 
mapping extracted source code program verifier adds proof annotations update heap type description 
wrote mean pointer valid heap type description guard guard restricts validity assertion language pointer dereferencing rules 
depicted fig 

problem notion heap type description single pointer may valid location 
structured types base address pointer structure type field type valid 
general valid qualified field names desire validity monotonicity property ptr 
achieve introduce new definition heap type description typ slice nat typ bool heap typ desc addr bool typ slice tuch location maps tuple component bool indicating value located address second component typ slice providing indexed map typ may reside particular address 
index calculated depth tree offset 
bool value indicates location base part value footprint example new heap type description provided fig 

point typ bool pair colour determined component shape second 
struct footprint extends horizontal axis footprints members 
vertical axis indicates position typ slice address 
second half struct higher tree deeper due struct changing depth past offset 
observation intuition pointer validity taken independent presence absence type information enclosing structured types history variable 
nat addr fig 

new heap type description valid struct pointer 
char definition pointer validity defined heap type description valid footprint size td list map typ slice snd nat fst nat ptr valid footprint ptr val type list map list nat converts list expected map typ slice takes vertical slice intended heap footprint exported type information offset typ slice type struct type float true type struct true type struct false map subset operator provides monotonicity 
function ptr updates heap type description pointer valid 
definitions properties rules function omitted brevity 
typed heaps lifting stage lifting process provides heap view proofs 
approach taken preference partial function aid partitioning state 
reason previous approach heap type description allowing consideration potential overlap values type eliminated valid pointers 
tuch 
fig 

example heap state 
addr heap typ desc heap mem struct nat state struct float lift typ heap fig 

stage lifting 
int char definition stage lift state results intermediate heap state addr datatype heap index nat datatype heap value byte styp typ bool addr addr heap index heap state addr heap value example state provided fig 
struct footprint 
explanation model provided 
function lift state filters locations false heap type description depending index removing values affect final lifted typed heaps 
equality lifted heaps modulo heap type description locations interest valid pointers 
lift state 
case fst option case styp snd lifted validity heap list expressed heap states heap list respectively obvious way 
definition second lifting stage results typed lifted heaps 
lift typ heap function restricts heap domain locations affecting resultant ptr heap valid pointer values 
equality modulo pointer validity 
lift typ heap bytes heap list size type ptr val tuch stages shown fig 
combined lift lift lift typ heap lift state lift lift polymorphic returns typed heap 
program embedding continues functions lift heap update pre post conditions invariants stronger lift precise statements 
update dependency order definition partial order defined type descriptions expresses update dependency heaps formalising relation described 
td set lifted predicate type type export type export type example running example type struct type struct type int type struct 
update struct affect lifted int heap update struct affect struct heap 
rewrites section develop rewrites allow effects updates lifted typed heaps evaluated 
auxiliary definitions key theorems thm 
thm 

theorems form conditional rewrites require additional support efficiently applicable followed detail 
definition list names fields matching exported type information obtained field names typ info typ qualified field name list 
field names type struct type float 
definition td set predicate may derived checks pointer ptr field structured type base ptr field type ptr val ptr val td set type functions may derived provide second components result valid qualified field name field typ type fst type field offset type snd type theorem lifted heap update valid ptr sub type type type lift heap update super field update lift super field update field case update value field names type type ptr val ptr val tuch locations enclose valid pointers unaffected 
update update value update value update value fs field offset type field update ti field typ type bytes update value fs traverses relevant fields enclosing structured type looking field offset matches difference enclosing pointer base match update value performs update field 
write bytes field access ti supplied byte list zero 
thm 
gives conditional rewrite allows update lifted typed heap level making updated typed heap involve unfolding complex definition general 
additional rewrites behaved updates 
theorem valid qualified field name super field update pointer reduced field update obtained type information type type export lift super field update ptr lift lift field update ti bytes side condition resolved having unfold type information rewrites installed construction combinators ml level 
field update ti rewritten record field 
lift super field update ptr lift lift rewrite remaining cases type type type type 
theorem lifted heap update valid ptr strict sub type type type lift heap update sub field update field names type type lift sub field update ptr sub field update fs sub field update fs ptr bytes field access ti field typ type dom non interference theorem rewrites update lifted typed heap valid pointer type disjoint type lift heap update lift type type lift heap update lift describes multiple independent heaps distinct field names 
updates pointer dereference specific field affect heap 
directly presence operator address arithmetic 
shown tuch theorem base pointers type field names prefix updates pointer derived field affect value lifted heap ga type type size td size type size td size type lift heap update ptr ptr lift ptr separation logic section describe shallow embedding separation logic tuch extended structured types :10.1.1.11.5322
focus singleton heap assertion definitions properties standard 
domain model separation assertions predicates heap states applied assertions verification environment result lifting stage 
example loop invariant separation assertion heap memory type description state variables respectively written lift state abbreviate sep 
rationale choice domain allows expressive separation assertions possible simpler models 
earlier intermediate state addr typ tag option byte unstructured types naive extension addr typ list byte 
unfortunately allow assertions separated refer distinct type levels address necessary provide flexible rules unfolding ignoring padding expect ptr ptr typ outline typ outline contains outer level type information enclosing structure 
adding type level index domain heap state provides facility 
shallow embedding definition footprint type ptr addr set gives set addresses inside pointer heap state footprint footprint ptr val nat size td type typ slice type definition asserts heap contains exactly mapping matching guard location pointer value lift typ heap dom footprint wf heap val wf heap val asserts type styp value heap state matches type index respectively 
definition standard definitions connectives empty heap predicate separation conjunction implication empty dom dom tuch case :10.1.1.11.5322
shallow embedding standard hol connectives quantifiers freely mixed separation connectives standard commutative associative distributive properties apply connectives formalised pure intuitionistic domain strictly exact assertions properties :10.1.1.11.5322
frame rule applies development 
lifting proof obligations verification condition generator applies weakest precondition rules transform hoare triples hol goals solved applying theorem prover tactics 
rewrites lift raw heap component proof obligations section provide rules allow low level applications lift heap update expressed terms separation assertions 
desirable reasoning derived rules assertions separation logic level 
theorem rule connects lift separation mapping assertions lift state lift heap update dereferences produce proof goals form lift state lift state heap update heap update heap update heap update pn vn theorem reduce heap updates pre state lift state type export type field update ti bytes lift state heap update ptr thm 
applied goals similar situations thm 

theorem earlier heap update rules apply lift state lift state heap update unfolding lift state lift state heap update additional rules allow dive inside singleton heap assertion structured type value 
may needed extracting points information aid discharging guard proof obligations side conditions rules thm 
useful allowing granularity assertion changed 
theorem points mapping assertion valid qualified field name derived singleton heap assertion type export type guard mono ptr bytes field access ti tuch struct node struct node reverse struct node ptr int item struct node struct node null ptr struct node temp ptr ptr ptr ptr temp return fig 

place list reversal source code 
developed rewrite approach unfolds fields structured values zoom structured values 
example place list reversal fig 
provides example type safe program performs place list reversal singly linked list struct type represent nodes 
standard example separation logic pointer program verification literature pre post specification loop invariant provided thm 

definition specification invariant list abstraction predicate lifts pointer linked data structure heap corresponding algebraic data type node list isabelle hol list null list xs null item list xs theorem reverse function implements specification zs 
list zs ptr sep reverse ret proc reverse ptr list rev zs reverse ret sep proof 
running verification condition generation left resulting proof obligations arising hoare logic rule invariant xs ys 
list xs ptr list ys sep rev zs rev xs ys pre inv inv post conditions trivial 
loop invariant preservation proof requires show 
zs ptr ys list ptr null rev zs rev list item ys ptr list list list ys lift state ptr list ys list list lift ptr ptr lift state heap update ptr ptr follows thm 

side condition may discharged thm 
thm 
eliminating lift 
side conditions dis tuch charged rewrites installed translation evaluating 
interesting point proof show 
zs ptr ys list ptr null rev zs rev list item ys ptr list list list ys lift state field update ti type node ptr bytes applying reverse definition bytes mem type axioms lifts rhs hol record level simplify goal 
compared earlier place list reversal example proof script structure size lines 
experience lifts heap updates reduced type safe freeing user level detail 
completeness result possible shallow treatment 
related idea separate heaps separate pointer types structure fields hoare logic goes back burstall 
level multiple typed heaps formalisation closely related mehta nipkow isabelle exploit isabelle type inference different way 
ground efficient reasoning detailed semantics directly applicable concrete programs extend support structured types 
moy developed memory model structured types type hierarchy 
differs physical sub typing focus translating behaved unions casts sub typing instances 
tool supports hoare logic verification programs including type safe part pointer arithmetic level 
increase applicability program verification drastically supporting unsafe part 
separation logic mechanised theorem proving systems previously :10.1.1.11.5322
provide soundness program verification grounding idealised models concrete semantics 
able support separation logic notation unsafe low level pointer manipulations time 
semantics front presents thorough detailed memory model formalisation similarities exploratory 
model unifies low level semantics proof abstractions previous paragraph 
continued earlier pointer program verification higherorder logic programs providing extensions generalisations resulting framework capable fully exploiting structured types 
development deeply embeds type structure information theorem prover generic rules describe type safe updates common interactive proof abstractions multiple typed heaps separation logic 
tuch extended earlier notion heap independence take account partial ordering heap update dependency development heap state allows expressive assertions 
type unsafe operations continue supported albeit proof cost 
includes providing support union types behaved tagged unions struct pointer casting case physical subtyping development isabelle tactics separation logic proofs integration automated tools decision procedures 
acknowledgments klein discussions reading drafts 
proving pointer programs hoare logic backhouse oliveira editors mathematics program construction mpc lncs pp 

burstall techniques proving correctness programs alter data structures meltzer michie editors machine intelligence edinburgh university press pp 

tre 
march multi prover verification programs formal methods software engineering th international conference formal engineering methods seattle usa lncs pp 

stephens applying source code verification microkernel project technical report tud fi rz tu dresden 
hearn bi assertion language mutable data structures popl proceedings th acm sigplan sigact symposium principles programming languages pp 

marti yonezawa verification heap manager operating system separation logic third workshop semantics program analysis computing environments memory management space pp 

mehta nipkow proving pointer programs higher order logic information computation appear 
moy union cast deductive verification verification workshop oxford uk 
formalised hol ph thesis computer laboratory university cambridge 
reynolds separation logic logic shared mutable data structures proc :10.1.1.11.5322
th ieee symposium logic computer science pp 

schirmer verification sequential imperative programs isabelle hol ph thesis technische universit nchen 
chandra ball reps coping type casts esec fse proceedings th european software engineering conference held jointly th acm sigsoft international symposium foundations software engineering pp 

tuch klein unified memory model pointers sutcliffe voronkov editors th international conference logic programming artificial intelligence reasoning lpar lncs pp 

tuch klein types bytes separation logic hofmann felleisen editors proceedings th acm sigplan sigact symposium principles programming languages nice france 
weber mechanized program verification separation logic tarlecki editors computer science logic th international workshop csl lecture notes computer science pp 

wenzel type classes overloading higher order logic gunter felty editors theorem proving higher order logics lncs pp 


