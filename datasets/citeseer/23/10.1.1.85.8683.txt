konrad zuse zentrum berlin url www zib de projects integer optimization mip zib report june tobias scip framework integrate constraint mixed integer programming berlin germany scip framework integrate constraint mixed integer programming tobias january constraint programs mixed integer programs closely related optimization problems originating different scientific areas 
today state art algorithms fields strategies common particular branch bound process recursively divide problem smaller subproblems 
hand main techniques process subproblem different observed complementary strengths 
programming framework scip integrates techniques fields order exploit strengths constraint programming mixed integer programming 
contrast proposals years combine fields scip focus easy implementation rapid prototyping tailored expert users need full depth control high performance 
keywords mixed integer programming mip constraint programming cp branch bound years shown combining techniques constraint programming integer programming help solve problems intractable methods 
example applied hybrid approach solve chemistry industry planning problems include lot sizing assignment sequencing subproblems 
chip library cp part dash xpress mp library ip part 
examples successful integration include assembly line balancing problem parallel machine scheduling problem 
different approaches integrate constraint integer programming single framework 
kasper developed konrad zuse zentrum berlin zib de framework coupe unifies cp ip observing techniques rely branching inference 
setting cutting planes domain propagation just specific types inference 
propose system introduces symbolic constraints top mixed integer programming solvers 
aron developed simpl system integrated modelling solution 
view cp ip special case infer relax restrict cycle cp ip techniques closely interact stage 
introduces constraint integer programming framework scip oriented needs constraint mathematical programming experts want total control solution process access detailed information guts solver 
includes features framework branching cutting pricing propagation 
highly flexible possible user plugins constraint handlers implement arbitrary constraints variable dynamically create problem variables domain propagators apply constraint independent domain propagations cut separators apply cutting planes lp relaxation provide relaxations dual bounds addition lp relaxation primal heuristics search feasible solutions specific support probing diving node selectors guide search branching rules split problem subproblems simplify solved problem file readers parse different input file formats event handlers informed specific events node solved specific variable changed bounds new primal solution display handlers create additional columns solver output 
dialog handlers extend included command shell 
existing unit implemented plugin leading interface flexible meet needs additional user extensions 
dynamic cut pool management included 
user may mix preprocessed active problem variables expressions automatically transformed corresponding active problem variables 
arbitrarily children node created different children arbitrarily defined 
open lp solver support currently supporting cplex clp lp relaxation need solved single node turned completely pure constraint solver 
additional relaxations semidefinite relaxations lagrangian relaxations included working parallel interleaved 
conflict analysis applied learn infeasible subproblems 
dynamic memory management reduces number operation system calls automatic memory leakage detection debug mode 
remaining part organized follows 
section compares constraint programming mixed integer programming problems different techniques solve 
intermediate problem class called constraint integer program defined 
section introduces basic concepts cip framework scip describes different types external plugins included extend scip functionality 
section illustrates algorithmic design scip describes framework external plugins interact solve cip instance 
section gives computational results mip instances compares scip academic state art commercial mip solver 
comparison cp mip section introduce definitions constraint programs mixed integer programs derive problem class call constraint integer program 
briefly compare basic solution strategies fields highlight key ideas approaches efficient praxis 
constraint programming optimization version constraint program cp defined follows definition constraint program constraint program triple cp consists solving cp min 
dn representing domains finitely variables xj dj 

cm finite set constraints ci 
objective function 
define 
ci 
note restrictions constraint predicates ci objective function existing constraint logic programming solvers prolog iii clp cal chip ilog solver usually restricted finite domain constraint programming cp fd 
setting domains 
dm finite 
solve cp fd problem recursively split smaller subproblems usually splitting single variable domain creating branching tree implicitly enumerating potential solutions 
subproblem node tree domain propagation performed exclude values variables domains 
domain reductions inferred single constraints primal reductions objective function feasible solution dual reductions 
variable domain reduced single value new primal solution 
variables domains gets empty subproblem discarded different leaf branching tree selected continue search 
key element solving constraint programs praxis efficient implementation domain propagation algorithms exploit structure involved constraints 
cp solver usually includes library constraint types specifically tailored propagators 
important feature provided infrastructure managing local domains representing subproblems tree 
currently different techniques existing software trailing copying see comparison 
node tree trailing stores differences node parent respect variables domains current set active constraints 
reduces memory consumption cost additional effort switching subproblems 
hand copying physically duplicates data parent node define child nodes applies necessary modifications child nodes 
result large memory overhead allows fast switching subproblems 
mixed integer programming mixed integer program mip defined definition mixed integer program matrix vectors subset 
mixed integer program mip solve mip min ax 
common restrictions mip integer programs ips binary programs bps 
note contrast cp restricted linear constraints linear objective function integral real valued domains 
despite restricted modelling capabilities mip practical applications prove mip ip bp successfully applied real word problems 
usually requires expert knowledge generate models solved current general purpose mip solvers 
cases necessary adapt solving process specific problem structure hand 
done help mip framework 
just cp solvers modern mip solvers recursively split problem smaller subproblems generating branching tree 
processing nodes different 
node tree lp relaxation solved constructed mip removing integrality conditions 
relaxation strengthened cutting planes lp information integrality restrictions derive valid inequalities cutting optimal lp solution removing integral solutions 
lp provides lower bound subtree bound exceeds value currently best primal solution node subtree discarded 
lp relaxation usually gives stronger bound simple dual propagation cp solvers provide 
important ingredients mip solver implementation fast numerically stable lp solver cutting plane separators primal heuristics algorithms see 
additionally applied branching rule major importance see 
necessary infrastructure includes management subproblem modifications lp information cut pool 
modern mip solvers cbc cplex sip symphony xpress offer variety different general purpose separators activated solving problem instance hand see 
possible add problem specific cuts callback mechanisms providing flexibility full mip framework offers 
mechanisms cases sufficient solve problem instance 
help modelling tools ampl gams possible formulate model mathematical fashion automatically transform model data solver input solve instance reasonable time 
setting user need know internals mip solver black box tool 
unfortunately rapid mathematical prototyping chain see yield results acceptable solving time problem class small instances 
problem classes user develop special purpose code problem specific algorithms 
provide necessary infrastructure branching tree lp management support standard general purpose algorithms lp cutting plane separators primal heuristics mip framework abacus tools provided coin project 
constraint integer programming described previous sections current solvers constraint programming mixed integer programming share idea dividing problem smaller subproblems implicitly enumerating potential solutions 
differ way processing subproblems 
mip specific restriction cp mip solvers apply sophisticated problem specific algorithms operate subproblem particular simplex algorithm solve lp relaxations cutting plane separators cut separator 
contrast due unrestricted definition cps cp solvers take global perspective 
rely constraint propagators exploiting structure single constraint class 
usually communication individual constraints takes place variables domains 
advantage cp possibility model problem directly expressive constraints contain lot structure 
transforming constraints linear inequalities conceal structure mip solver lessen solver ability draw valuable instance right decisions search 
hope combining cp mip techniques take advantage strengths compensate different weaknesses 
propose slight restriction cp definition constraint integer constraint integer program cip consists solving cip min finite set 
cm constraints ci 
subset 
variable index set objective function vector fulfill restriction xi axi xn axi xn xn xi xn 
restriction ensures remaining subproblem fixing integral variables linear program 
means problem completely solved enumerating values integral variables solving corresponding lps 
linearity restriction objective function easily compensated introducing auxiliary objective variable linked actual non linear objective function non linear constraint 
just demand linear objective function order simplify derivation lp relaxation 
holds true omitting general variable domains exist definition constraint program 
represented additional constraints 
cp meets condition represented constraint integer program 
remaining part describe scip framework solve 
basic concepts scip scip framework constraint integer programming provides necessary infrastructure implement algorithms solving 
manages branching tree subproblem data automatically updates lp relaxations handles transformations due preprocessing problem modifications 
additionally cut pool pricing store management sat conflict analysis mechanism see available 
scip provides efficient memory allocation shell includes simple leak detection compiled debug mode 
lot statistical output generated support user diagnosis algorithms particular branching tree visualized help vbc tool 
despite infrastructure mentioned main algorithms part external plugins 
user defined callback objects interact framework detailed interface 
current distribution scip contains necessary plugins solve mips see section computational results mip instances 
describe different plugin types role solving cip 
note forbid quadratic involved expressions 
remaining part fixing eliminating integral variables linear continuous variables 
constraint handlers cip consists constraints central objects scip constraint handlers 
constraint handler represents semantics single class constraints provides algorithms handle constraints corresponding type 
primary task constraint handler check solution feasibility respect constraints type existing problem instance 
feasibility test suffices produce correct algorithm solving constraints supported type 
algorithm resemble complete enumeration potential solutions additional primal information available 
help pruning search tree constraint handlers may provide additional information constraints framework methods simplify problem representation propagation methods tighten variables domains linear relaxation generated advance fly improve dual bound lp branching decisions split problem smaller subproblems structural knowledge constraints order generate balanced branching tree 
example knapsack constraint handler knapsack constraint specialization linear constraint positive integral right hand side positive integral coefficients aj binary variables xj 
feasibility test knapsack constraint handler simple adds coefficients aj variables xj set solution compares result right hand side algorithms knapsack constraints include modifying coefficients right hand side order tighten lp relaxation fixing variables aj see 
propagation method fixes additional variables fit knapsack variables fixed current subproblem 
linear relaxation knapsack constraint initially consists knapsack inequality 
additional cutting planes lifted cover cuts cover cuts dynamically generated enrich knapsack relaxation cut current lp solution 
addition constraint primal mechanisms provided individual constraint handlers additional algorithms applied help 
usually perform dual operations objective function account 
example value variable xj decreased rendering constraint infeasible information constraint handlers provide objective value cj variable non negative dual fixing fixes variable lower bound 
setting mip condition satisfied iff cj 
cut separators scip distinct different types cutting planes 
type constraint cutting planes valid inequalities facets polyhedron described single constraint subset constraints 
may strengthened lifting procedures take information full problem account 
cutting planes generated constraint handlers corresponding constraint types 
prominent examples different types knapsack cuts generated knapsack constraint handler cuts tsp tours subtour elimination comb inequalities separated tour constraint handler 
second type cutting planes general purpose cuts current lp relaxation integrality conditions generate valid inequalities 
generating cuts task cut separators 
examples fractional cuts complemented mixed integer rounding cuts strong chv tal cuts 
domain propagators constraint primal domain propagation algorithms part corresponding constraint handlers 
example alldifferent constraint handler excludes certain values variables domains help bipartite matching algorithm 
contrast domain propagators provide dual propagations propagations applied due objective function currently best known primal solution 
example simple objective function propagator variables domains respect objective bound objective value currently best primal solution 
th column coefficient matrix alldifferent 
xk requires integer variables 
xk take pairwise dif ferent values 
branching rules scip integrality conditions enforced external plugin integrality constraint handler 
slightly differ constraints way data stored variables take integral values integrality restriction attached directly variables globally available algorithms 
integrality constraint handler sure solution accepted contains integral variables fractional values 
current lp solution fractional integrality restriction enforced branching 
branching performed calling branching rules 
branching rule usually creates subproblems splitting single variable domain 
applied fractional lp solution commonly integral variable xj fractional value xj selected branches xj xj xj xj created 
known infeasible reliability strong branching rules examples type see 
possible implement general branching schemes example creating subproblems adding additional constraints subproblems tightening variable domain 
variable optimization problems modeled huge number variables path graph subset set corresponding single variable 
case full set variables generated advance 
variables added dynamically problem may improve current solution 
mixed integer programming technique called column generation 
scip supports dynamic variable creation variable 
called subproblem processing generate additional variables reduce lower bound subproblem 
operate lp relaxation usually calculate reduced costs existing variables problem specific algorithm add variables negative reduced costs 
note variable part model problem class specific 
scip contain default variable 
primal heuristics feasible solutions different ways traversal branching tree 
hand solution node relaxation may feasible 
hand feasible solutions discovered primal heuristics 
called periodically search 
scip provides specific infrastructure diving probing heuristics 
diving heuristics iteratively resolve lp making changes current subproblem usually aiming driving fractional values integral variables integrality 
probing heuristics call domain propagation algorithms constraint handlers applying changes variables domains 
heuristics special support scip include local search heuristics tabu search rounding heuristics try round current fractional lp solution feasible integral solution 
node selectors node selectors decide leaves branching tree selected subproblem processed 
choice huge impact solver performance influences finding feasible solutions 
constraint programming originally developed constraint satisfaction problems csps 
cps objective function 
setting solver find feasible solution 
available cp solvers employ depth search 
addition objective function depth search usually inferior strategy 
tends evaluate nodes tree discarded optimal solution known earlier 
mixed integer programming node selection strategies known try discover feasible solutions early search process 
examples strategies best best estimate search 
scip provides specific support lp relaxations constraint handlers possess virtual methods generating lp additional cut separators may included tightening lp relaxation exist lot interface methods access lp information current subproblem 
addition possible include relaxations lagrange relaxations semidefinite relaxations 
possible objects 
manages necessary data structures calls relaxation solver generate dual bounds primal solution candidates 
data define single relaxation extracted user defined problem data lp information integrality conditions provided constraint handlers 
case constraint handlers extended support specific relaxation 
lp relaxations support managing information available speed resolves subproblems 
subproblem user may call number including lp relaxation 
particular possible refrain solving relaxation case solver behaves cp solver 
event handlers scip contains sophisticated event system external plugins objects informed certain events 
example constraint handler may want informed domain changes variables involved constraints 
avoid unnecessary preprocessing propagation constraint processed domain involved variables changed preprocessing propagation call 
events update certain internal values total weight variables currently fixed knapsack constraint order avoid frequent recalculation 
potential applications event system include dynamic graphical display currently best solution online visualization branching tree 
supported events triggered new primal solution node processed 
event handler special plugin called process events selected types 
handler usually passes information objects constraint handler 
common scip constraint handler closely interacts event handler order improve run time performance 
conflict handlers current state art sat solvers employ analysis infeasible subproblems generate called conflict clauses see 
induced constraints may help prune branching tree nodes 
cp community generalization clauses known goods 
scip adopts mechanism extends analysis infeasible lps 
conflict internal analysis algorithms included conflict handlers called create conflict constraint set conflicting variables 
conflict handlers usually closely cooperate constraint handlers calling constraint creation method constraint handler adding constraint model 
file readers file readers called parse input file generate cip model 
creates constraints variables activates variable necessary 
file reader hooked single file name extension 
automatically called user wants read problem file corresponding name 
examples file formats mps format lp format linear mixed integer programs cnf format sat instances conjunctive normal form tsp format traveling salesman tour instances 
dialog handlers scip comes textual shell allows user read problem instances modify solver parameters initiate optimization display certain statistics solution information 
shell extended dialog handlers 
linked shell calling tree executed user enters respective command 
default shell generated dialog handlers completely adjustable needs software developer 
display columns solving constraint integer program scip displays status information column fashion 
example current number processed branching tree nodes solving time relative gap primal dual bound display columns 
exist wide variety display columns activated deactivated demand 
additionally user implement display columns order track problem algorithm specific values 
algorithmic design section focuses algorithmic design scip 
execution scip different operational stages distinguished see 
stages described specified callback methods different plugins executed operations user may perform different stages 
explained problem represented scip data structures transformations applied course algorithm 
init stage init stage basic data structures allocated initialized 
user include required plugins calls 
included plugin may allocate private data 
call solver leaves init stage enters problem modification stage executing file reader create problem instance 
init problem modification transforming free transform transformed solved free solve init solve solving 
operational stages scip 
arrows represent possible transitions stages 
problem modification stage problem modification stage user define modify original problem instance wants solve 
create constraints variables activate included variable 
file reader called init stage switches problem modification stage call subsequently creates necessary problem data 
transforming stage actual solving process begins scip creates working copy original problem instance 
working copy called transformed problem protects original problem instance modifications applied solving 
original problem modified problem modification stage 
transforming stage data variables constraints copied separate memory area 
scip know constraints represented call constraint handlers create copies constraints 
transformed stage copying process transforming stage completed transformed stage reached 
state intermediate state user may initiate stage free solving process data switching free transform stage 
stage stage permanent problem modifications transformed problem applied methods constraint handlers 
plugins called iteratively reductions specified limit reached 
main tasks detect aggregations variables 
variables deleted problem replacing occurences constraints corresponding counterpart 
aggregations stored variable aggregation graph framework automatically convert operations variables equivalent ones active problem variables 
example consider linear constraints integer variables 
constraint fixes 
linear constraint handler replaces occurence fixed value resulting 
aggregated 
constraint inserts aggregation aggregation graph 
shows complete aggregation graph example 
left hand side original problem variables created problem modification stage shown 
linked transformed problem counterpart 
additional links transformed variables introduced aggregations 
assume constraint handler cut separator adds inequality lp relaxation 
inequality constructed mixture original fixed aggregated active problem variables automatically transformed active problem variables 
results inequality stored lp relaxation 
inequality derive bound change automatically produces corresponding bound changes 
constraint handlers may upgrade constraints specific constraint type 
example linear constraint handler provides upgrading mechanism constraints constraint handlers hooked mechanism called converting linear constraints constraints type 
example original original original original fixed aggregated aggregated 
variable aggregation graph example 
active knapsack constraint handler see example checks linear constraint consists binary variables integral weights finite side check succeeds linear constraint converted knapsack constraint possibly negating binary variables inverting inequality 
stage transformed stage stage intermediate stage reached completed 
thereon actual solving process may launched 
solved problem instance detecting infeasibility fixing variables scip automatically switches init solve stage solved stage 
init solve stage init solve stage necessary data structures solving process set 
example root node branching tree created lp solver initialized 
additionally plugins informed solving process create initialize private data 
solving stage problem solved stage branch bound process implicitly enumerate potential solutions performed solving stage 
stage contains main solving loop scip node selection domain propagation constraint enforcement primal heuristics 
main solving loop solving stage 
relaxation solving consists different steps called successively problem solved solving process interrupted see 
node selection step iteration main solving loop selection subproblem 
node selector highest priority active node selector called select leaves branching tree processed 
decide current node children siblings best remaining leaves stored tree 
ordering relation tree leaves defined active node selector 
successively choosing child sibling current node called 
selecting best leave tree ends current sequence starts 
set subproblems processed computationally expensive children siblings closely related current node 
switching best leave tree expensive advantage search brought regions search space promising contain feasible solution 
efficient node selectors mip employ mixture best search 
scip different operation modes standard mode memory saving mode 
memory limit parameter user nearly reached scip switches memory saving mode priorities node selectors apply 
usually depth search node selector highest priority memory saving mode produce unprocessed nodes strategies best search tends reduce number open leaves releasing allocated memory 
memory consumption decreased sufficiently scip switches back standard mode 
domain propagation node selected processed corresponding subproblem set domain propagators domain propagation methods constraint handlers called tighten variables local domains 
propagation applied iteratively reductions propagation limit set user reached 
domain propagation need applied node 
constraint handler domain propagator decide wants spend effort trying tighten variables domains 
relaxation solving step solving loop solve subproblem relaxations particular lp relaxation 
domain propagation solving relaxations skipped applied needed 
active variable lp relaxation solved order generate new variables obtain feasible dual bound 
scip notational distinctions cip subproblem lp relaxation 
cip consists variables constraints 
variables marked integer continuous domains may contain holes 
constraints stored constraint handler specific data structures 
semantics unknown framework implicitly actions performed constraint handlers callback methods 
lp relaxation consists columns rows 
column lower upper bounds known 
column belongs exactly cip variable cip variable needs represented column lp 
rows defined linear combinations columns left right hand sides additional data 
single constraint give rise multiple rows lp rows live created general purpose separator 
lp solving inner loop seen 
executed long changes lp applied separation reduced cost strengthening steps 
note resolving lp adding cuts modifying columns bounds efficiently done dual simplex algorithm 
calling lp solver 
step call lp solver solve initial lp relaxation subproblem 
root node defined node selection domain propagation constraint enforcement primal heuristics 
lp solving loop 
lp solving calling lp solver variable pricing cut separation reduced cost strengthening domain propagation relaxations constraints marked initial constraint handlers asked enrich lp rows correspond initial constraints lp solved 
initial lp relaxation subsequent node equals parent relaxation modified additional bound changes node 
note branching constraints change lp relaxation child nodes directly 
modifies cip subproblem corresponding constraint handlers may modify lp cut separation constraint enforcement methods see section 
lp solved primal dual simplex algorithm depending feasibility status current basis 
possible interior point method barrier algorithm solve lp relaxations provided included lp solver 
resulting lp solution checked stability 
numerically unstable situation different lp solver parameter settings tried order achieve stable solution 
fails lp relaxation current subproblem discarded solving process continues lp solved current node 
note feature solving numerically difficult problems 
due fact scip need solve lp node easily leap numerical troubles lp solver having abandon solving process 
variable pricing 
initial lp solved variable called create new variables add additional columns lp 
variable complete incomplete 
complete generates new variable current lp solution optimal relaxation full variable space 
incomplete objective value optimal lp solution necessarily dual bound subproblem apply bounding may exist variables reduce lp value potentially leading improved primal solution 
pricing performed rounds 
round new variables created round lp solver called resolve relaxation 
note primal simplex algorithm quickly resolve lp new columns added 
cut separation 
pricing performed lp resolved cut separators separation methods constraint handlers called tighten lp relaxation additional cutting planes 
iteration lp solving loop cutting planes collected separation store added lp 
selection cuts added lp crucial decision affects performance stability lp solver subsequent calls 
scip cuts selected respect different criteria see efficacy cuts distance corresponding hyperplanes current lp solution orthogonality cuts respect 
tried select nearly orthogonal subset cutting planes cutting deep possible current lp polyhedron 
user possibility change employed distance norm 
default settings euclidean norm measure efficacy cuts 
reduced cost strengthening 
simplex lp solver provides reduced cost values column denoting change objective value change column solution value 
information columns currently bounds tighten opposite bound see 
reduced cost strengthening viewed special kind general purpose cutting plane separator dual problem information 
versions scip moved core framework implemented external cut separator plugin 
domain propagation 
bound columns changed cut separation reduced cost strengthening steps domain propagation applied tighten variables domains see section 
constraint enforcement domain propagation applied relaxations solved constraint handlers asked process relaxations primal solutions 
mip usually solution lp relaxation 
contrast constraint handlers feasibility tests check primal solution generated primal heuristic feasibility enforcement methods try resolve infeasibility 
constraint handler different options dealing infeasibility see reducing variable domain exclude infeasible solution local set domains adding additional valid constraint deal appropriately infeasible solution adding cutting plane lp relaxation cuts infeasible solution creating branching infeasible solution longer feasible relaxations child nodes concluding current subproblem infeasible cut branching tree just stating solution infeasible resolving infeasibility 
remaining answer constraint enforcement method current solution feasible constraints constraint handler 
constraint handlers enforcement methods called order specified constraint handlers enforcement priorities 
depending result code constraint enforcement method scip proceeds differently 
constraint handler tightened variable domain added constraint enforcement cycle aborted algorithm jumps back domain propagation 
adding cutting plane lp solving 
branching cutting current node finish processing node primal heuristics called 
constraint handler detects solution infeasible resolving solution feasible constraints constraint handler constraint handler asked process current solution 
constraint enforcement cycle different outcomes 
constraint handler resolved infeasibility node processing continued appropriately 

constraint handlers declared solution feasible means new feasible solution 
node selection domain propagation lp solving constraint enforcement primal heuristics result 

constraint enforcement results 
reduced domain added constraint added cut branched cutoff infeasible feasible 
constraint handler detected infeasibility resolved 
case branching rules called create branching 
note integrality constraint handler enforces constraint calling branching rules integer variables fractional value 
integrality constraint handler enforcement priority constraint handlers may decide want called integral solutions case negative priority called fractional solutions positive priority 
called integral solutions useful efficient feasibility test constraint handler applied integral solutions solution selects edges graph feasibility test graph algorithm 
called fractional solutions useful wants apply constraint specific branching rule set partitioning constraint handler may want branch subset set partitioning constraint variable set 
primal heuristics processing subproblem concludes calling primal heuristics 
plugin scip primal heuristics need process single node 
usually called certain frequency specific depth levels branching tree 
primal heuristics generate primal solutions passed constraint handlers checking feasibility 
feasible solution leaves branching tree exceeding new primal bound discarded 
computational results scip version includes necessary plugins solve mixed integer programs 
particular supports cutting planes fractional cuts marchand version complemented mixed integer rounding cuts strong chv tal cuts lifted knapsack cover cuts 
cutting planes clique cuts depend set packing relaxation missing added versions 
scip includes various preprocessing algorithms provide probing techniques 
different variants diving heuristics including modification feasibility pump 
additionally quick simple involved rounding heuristic lp solution starting point generating primal solutions 
various branching rules available including simple inefficient infeasible infeasible branching rules sophisticated reliability branching variants costly strong branching rule see review 
node selection rule configured resemble mixture depth best search 
lp solver interfaces exist cplex clp 
computational results mip instances comparing scip cplex sip 
note cplex embedded lp solver scip 
calculations performed ghz pentium ee workstation gb ram 
test set consists instances instances collected 
selected instances cplex needed branching nodes hour cpu time solving 
runs time limit seconds memory limit gb 
table shows results test set 
obviously scip strictly competitive cplex factor geometric mean total running time 
take numbers cplex run default settings absolute set relative corresponding values scip 
test set assembled months ago cplex available 
scip sip cplex name nodes time nodes time nodes time cap mas mas misc pk pp qiu rout ran ran ran ran mas prod bc mkc seymour total geom 
mean table 
computational results scip cplex 
results marked solved optimality time memory limits 
indication scip performance far away stateof art mip solver 
comparison scip sip shows sip slightly superior 
surprising scip successor sip algorithms reimplemented scip tuned exhaustive ones sip 
parameter settings carefully adjusted 
additionally sip exclusively implemented solve completely specified mips overhead incorporated scip support general constraints variable pricing subproblem relaxations 
koch martin 
mixed integer programming library 
zib de 
koch martin 
branching rules revisited 
operations research letters 
sakai sato hawley hasegawa 
constraint logic programming language cal fgcs proceedings international conference fifth generation computer systems pages tokyo 
elf nger kasper mehlhorn 
scip symbolic constraints integer linear programming 
technical report tr mpi saarbr cken may 
fischetti 
embedding cuts branch cut framework computational study cuts 
preliminary draft october 
aron hooker 
simpl system integrating optimization techniques 

michel editors integration ai techniques constraint programming combinatorial optimization problems international conference pages nice france april 
rk 
integer programming software systems 
annals operations research 
forthcoming www gatech edu faculty martin publications final pdf 
balas 
facets knapsack polytope 
mathematical programming 
balas zemel 
facets knapsack polytope minimal covers 
siam journal applied mathematics 
bixby gu rothberg 
mip theory practice closing gap 
powell scholtes editors systems modelling optimization methods theory applications pages 
kluwer 
kasper 
branch infer unifying framework integer finite domain constraint programming 
informs journal computing 

solving assembly line balancing problems combining ip cp 
sixth annual workshop ercim working group constraints june 
raman rosenthal 
gams user guide december 
www gams com 
coin 
computational infrastructure operations research 
www coin org 
colmerauer 
prolog iii 
communications acm volume pages july 
dantzig 
maximization linear function variables subject linear inequalities 
koopmans editor activity analysis production allocation pages 
john wiley sons new york 
dash optimization 
xpress mp 
www com 
dincbas van hentenryck simonis graf berthier 
constraint logic programming language chip 
fgcs proceedings international conference fifth generation computer systems pages tokyo 
fischetti glover 
feasibility pump 
technical report universit di bologna operations research 
forrest 
coin branch cut 
www coin org 
forrest de la 
clp user guide august 
www coin org clp 
gay kernighan 
ampl modelling language mathematical programming 
duxbury press brooks cole publishing nd edition november 

algorithm integer solutions linear programming 
graves wolfe editors advances mathematical programming pages new york 
mcgraw hill 
gr tschel padberg 
symmetric traveling salesman problem inequalities 
mathematical programming 
gr tschel padberg 
symmetric traveling salesman problem ii lifting theorems facets 
mathematical programming 
ibm 
mathematical programming system extended program manual 
sh th ed 
ilog cplex 
manual 
www ilog com products cplex 
jaffar 
lassez 
constraint logic programming 
proceedings th acm symposium principles programming languages pages munich 
jain grossmann 
algorithms hybrid milp cp models class optimization problems 
informs journal computing 
koch 
user guide 
technical report konrad zuse zentrum berlin 
berlin 
www zib de koch 
koch 
rapid mathematical prototyping 
phd thesis tu berlin 

tree interface version user manual 
technical report institut informatik universit zu ln 
www informatik uni de ls research 

strengthening chv tal cuts fractional cuts 
operations research letters 

api users manual 
www com 
marchand wolsey 
aggregation mixed integer rounding solve mips 
operations research 
martin 
integer programs block structure 
technische universit berlin 
martin 
intersection knapsack polyhedra extensions 
bixby boyd os editors integer programming combinatorial optimization proceedings th ipco conference pages 

decision tree optimization software benchmarks optimization software 
plato asu edu bench html 
nemhauser 

coral lehigh edu 
nemhauser 
mixed integer optimizer 
operations research letters 
nemhauser wolsey 
integer combinatorial optimization 
john wiley sons 

puget 
implementation clp 
technical report ilog france 

symphony version user manual 
technical report lehigh university industrial systems engineering 
org symphony 
reinelt 
tsplib 
institut angewandte mathematik universit heidelberg www uni heidelberg de groups software tsplib 

preprocessing probing techniques mixed integer programming problems 
orsa journal computing 
schulte 
comparing trailing copying constraint programming 
de schreye editor proceedings international conference logic programming pages las cruces nm usa november 
mit press 
marques silva sakallah 
grasp search algorithm propositional satisfiability 
ieee transactions computers 

abacus branch cut system 
phd thesis institut informatik universit zu ln 

solving planning scheduling problems combined integer constraint programming 
spectrum november 
wolsey 
valid inequalities knapsacks mips generalized upper bound constraints 
discrete applied mathematics 

und simplex 
phd thesis konrad zuse zentrum berlin 

