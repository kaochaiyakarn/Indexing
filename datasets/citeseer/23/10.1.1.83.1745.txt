case high level programming models reconfigurable computers david andrews ron sass erik anderson jason wesley peck jim stevens fabrice ed information telecommunication technology center university kansas irving hill road lawrence ks ku edu outline discuss issues currently accepted computational models hybrid cpu fpga systems 
discuss need researchers develop new high level programming models just focus extensions programming languages enabling accessibility portability standard high level applications cpu fpga boundary 
unifying programming model specifying application threads running hybrid cpu fpga system 
threads specified single pthreads posix threads multithreaded application program compiled run cpu synthesized run fpga 
system general unique reconfigurable computing community abstracts cpu fpga components unified custom threaded multiprocessor architecture platform 
hardware thread interface hwti component developed provides platform independent compilation target 
hwti enables standard thread communication synchronization operations software hardware boundary 
reconfigurable computing rc discipline existence decade 
time significant strides fabrication providing hybrid cpu fpga components millions free logic gates diffused ip form high speed multipliers sram blocks 
unfortunately researchers far struggled develop tools programming environments allow programmers system designers just hardware designers tap full potential new reconfigurable chips 
deficiency part due widespread acceptance fpga simple processor accelerator subsequent absence modern parallel programming model supports accessibility portability parallel computations cpu fpga boundary 
concerning reconfigurable computing community lessons learned past parallel processing efforts clearly indicate need provide portable parallel programming models composed unaltered high level languages middleware libraries 
outline discuss issues currently accepted computational models hybrid cpu fpga systems 
discuss need researchers develop new highlevel programming models just focusing extension programming languages include pragmas 
outline multithreaded programming model run time system achieving seamless interaction threads running cpu fpga boundary 
far commonly accepted computational model rc community treats fpga instruction level hardware accelerator cpu 
outlines basic computational model 
traditional software development single threaded application code profiled find portion application provide performance benefit custom hardware acceleration 
identified target code section replaced custom hardware core 
platform specific interfaces created allow application software communicate control hardware core 
typically software ap cpu time main block max block block return cpu active block idle block block fpga traditional fpga processor model plication interfaces hardware core low level component structures fifo queues feeding input data hardware core second streaming output data back software application 
execution application software executes normal reaches critical portion kernel code invokes hardware core 
accomplished cpu transferring data hardware core idling hardware core finishes execution 
hardware core signals completion cpu reads output data back hardware core resumes normal execution 
small scales hardware acceleration model effective exploiting instruction level parallelism ilp exposed loop unrolling 
larger scales hardware acceleration model replace ultra critical sections code applications 
method regardless scale certainly merits 
example consider mathematically intensive realm molecular dynamics applications 
authors successfully able port molecular dynamics application called src platform consisting intel microprocessors fpga technologies hardware acceleration model achieve speedup 
historical perspective hardware acceleration model similar model assumed cisc processor architectures 
cisc architectures cpu executes series instructions cisc instruction instruction set architecture isa 
hardware acceleration model cisc instructions implemented parallelized circuits fpga microcode 
methods strive achieve maximum performance low level instruction customization 
traditional cisc architectures limited microcode isa associated fixed structure available alus datapaths hardware acceleration reconfigurable architectures limited number free gates fpga 
approaches similar instruction issue semantics require cpu fetching instructions multi cycle instruction implemented microcode fpga executed 
support fpga processor model researchers investigating augmentations existing languages hardware compilation techniques allow programmers system designers specify custom accelerators high level programming languages :10.1.1.22.3767
acceptance hardware acceleration model seen reinforcement design tools offered leading fpga fabrication houses 
altera adopted model ii processor hardware compiler 
objective isolate section code programmer determined candidate automatically create hardware core execute place 
compiler strong advantage user required prior knowledge hardware description language hdl order take advantage able implement critical portions code hardware 
additionally compiler able support large portion full ansi standard recursion floating point arithmetic exception 
considering challenge producing parallel circuits purely sequential language efforts quite impressive 
task translating hdl way increases program performance non trivial 
language provides thin abstraction von neumann architecture reinforces sequential instruction execution architecture associated cpu memory bottleneck 
furthermore certain programming constructs techniques pointers recursion commonly software systems difficult replicate hardware 
tools show results great effort far put forth providing software programmers access reconfigurable fabric modern fpga devices 
addition language translation issues standard communication methods interfacing software hardware portions application defined 
need capabilities outlined 
wolf outline technical challenges propose approaches automating creation hardware software interfaces embedded systems multiprocessor systems chip soc 
interestingly data transfer times hardware software boundary significant occasionally greater original software execution time 
additional consistency problems introduced modern memory hierarchies utilizing multiple levels cache 
efforts explored optimization techniques balancing number loops unrolled parallel circuits match bandwidth capabilities system bus 
garp attempted circumvent memory bottleneck proposing new cpu architecture integrated reconfigurable fabric 
unfortunately showed applications limited spatial parallelism loop bodies coupled size limitations embedded reconfigurable fabric result performance degradations compared compiler optimized software implementations 
models seek exploit low level parallelism limited sized code fragment single execution stream ignore available user specified concurrency exposed modern coarse grained multithreaded multitasking models 
moore law continues improve size density fpgas new models required translate coarse levels parallelism parallel concurrent circuits fpga 
programming models conceptually approaches providing access hardware acceleration computational model development path similar occurred simd systolic arrays parallel signal processing domains 
approaches higher level languages augmented specific pragmas exploiting fine grained arithmetic instruction level parallelism form matches underlying machine computational model 
approaches bring advancements accessibility cost portability promoting detailed knowledge underlying architec ture directly source language 
concerning reconfigurable computing lessons learned parallel processing domain clearly show importance decoupling machine specific attributes high level language achieve portability importance exploiting coarser grained thread level parallelism 
current practices evidenced software developed high performance cluster computing encapsulate machine specific code middle ware libraries linked unaltered source code form programming model 
informally programming models provide framework system software components interactions platform independent portable 
portability achieved separating policy mechanisms framework 
policy specified common high level language set system service apis 
modern programming models achieve portability adopting unmodified high level languages middleware service routines 
multithreaded programming model gained popularity embedded systems domain ability represent time event triggered reactive processes typical domain 
multithreaded programming model familiar realm general purpose computing providing convenient framework processing concurrent client requests common server 
support multithreaded programming model provided pthreads posix threads library released linux unix windows 
additional lowlevel hardware support multithreading standard modern cpus evidenced intel technology 
multithreaded programming model high level design flow multithreaded programming model hybrid cpu fpga architectures shown 
design flow programmers express system computations familiar pthreads semantics set application requirements 
functional flow threaded high level program written verified standard workstation running linux pthreads prior synthesis hardware design 
apis pthreads apis wrappers going pthreads pthreads available 
initial debugging standard workstation multithreaded application profiled workstation run board testing allowing developer identify threads mapped reconfigurable fabric 
example ease supports seamless creation threads execution hardware software consider code seen 
example shows application level code parent thread creating child threads software hardware 
example child thread implements complete discrete wavelet transform dwt 
parent thread create multiple child threads run parallel hardware synchronize threads traditional software threads 
show execution times configurations dwt child threads 
timings single child thread representing classic single instruction stream fpga accelerator model 
surprisingly hardware implementation shows speedup compared software version 
timings highlight benefits parallelism 
software threads running single cpu thread time multiplexed total execution time summation independent execution times thread plus operating system overhead 
threads mapped hardware parallelism achieved 
hardware threads running parallel show speedup compared software threads time multiplexing cpu 
simple example illustrates benefit enabling coarse grained multiple instruction streams multiple data mimd parallelism fpga 
conceptually simple extending reconfigurable system faced key challenges 
design flow modified support synthesis application program code linking apis state machine versions syscall run time services 
effect api provide consistent policies threads running cpu fpga 
includes ability support standard programming function invocations creating passing data types pointers accordance semantics pthread api 
shows high level description integrated compilation synthesis tool flow 
shown augmented standard gcc tool chain produce output new hardware intermediate form hif generate vhdl 
hif similar standard single assignment intermediate forms slightly modified controlled format better serve target vhdl generation 
second challenge create new hardware ver sions system service libraries support api operations hardware threads 
support shared memory thread model created services support creation control scheduling child threads executing hardware 
additionally created services allowed independent hardware threads synchronize threads standard semaphore operations independently access global local data 
services invoked hardware threads original user specified apis source program 
api eliminate need create unique interfaces threads interact cpu fpga hardware software boundary 
allows high level code portable software hardware different platforms verified high level design flow 
hwti interface created hardware thread interface hwti encapsulate system service mechanisms hardware threads 
block diagram hardware thread interface component shown 
shown hwti entity linked automatically generated vhdl architecture version user code similar fashion traditional system call software routines 
hwti component contains interfaces hwti system interface interacting hthread service components hwti user interface supporting system service calls user thread 
hwti target automatically linked hll synthesizer directly included developers wishing hand write threads vhdl 
shows analogous nature common run time system services available hardware software threads 
shown center column standard policy invoking run time services steps 
arguments passed application program run time services second run time service routine invoked 
traditional software methods policy achieved pushing arguments stack executing specific trap instruction run time service 
achieve analogous policy threads running hardware hardware interface provides registers replace stack command register replaces trap 
shown mechanism provide passing arguments simply drive inputs hwti registers 
specific syscall functionality specified unique opcode shown table 
example hthread hw hw sw sw hthread attr attr attr attr attr struct array arg arg arg arg retval log log setup uart printing initialize system hthread init initialize attributes threads hthread attr init attr hthread attr init attr hthread attr init attr hthread attr init attr setup attributes hardware thread hthread attr attr hwti zero hthread attr attr hwti set thread argument data value arg length length arg length length arg length length arg length length length arg data length arg data length arg data length arg data length hthread design flow uniform api length printf arg data log create log log time log hthread create sw attr arg hthread create sw attr arg hthread create hw attr null arg hthread create hw attr null arg wait hardware thread exit hthread join hw void retval hthread join hw void retval hthread join sw void retval hthread join sw void retval log time log clean attribute structure hthread attr destroy attr hthread attr destroy attr hthread attr destroy attr hthread attr destroy attr log close ascii log length printf arg data printf qed return main return application level code creating hybrid threads number type total time threads threads ms speedup graphic software hardware software software hardware hardware software hardware 
software hardware dwt example run time performance push stack library code execution cpu hthread syscall syscall xx arg arg pass api arguments user system call system routine xx drive inputs hwti regs user space supervisor space system service policy mechanisms execute trap xx 
op code xx hwti hwti state machine fpga compilation synthesis tool flow user thread completed executes hthread exit api opcode hthread exit placed opcode line latched user opcode register 
seen vhdl example 
accordance standard pthread exit system call user thread may pass parameter back parent thread hwti user argument register 
argument registers access global memory combination load store opcodes 
hwti implemented slices 
number includes logic standard vendor supplied bus interface minimal user logic thread immediately exits run command 
system system bus thread id command argument status result hwti system interface hwti user interface user status user result user opcode hardware thread user logic user argument hwti block diagram entity simple thread port clk std logic status std logic vector result std logic vector opcode std logic vector argument std logic vector argument std logic vector entity simple thread architecture beh simple thread constant variable declaration 
update process wait rising edge clk status user status reset reset variables 
status user status run status user status ack case current status user status run current current additional state machine logic final call exit opcode opcode hthread exit current final final wait exit ack status user status ack opcode opcode noop current final current final final idle reset event current final case process beh user argument vhdl generated code simple thread table hwti system calls syscall description noop operation requested hthread exit user thread finished executing returns results register load user thread requesting read memory store user thread requesting write memory hthread self returns thread id hthread yield meaning hardware thread resumes execution immediately mutex lock user thread requesting lock mutex hthread mutex unlock user thread requesting unlock mutex slices represent slices xilinx virtex ii pro fpga xc vp 
timing results hwti operation listed table 
exception load store results recorded cycle accurate simulation entire system 
load store recorded timings onchip execution hardware thread instantiated bus dram plb bus 
hw sw run time kernel glance mirroring traditional run time software thread system services hardware components appears daunting provided motivation redesign complete set efficient globally accessible shared services hardware software threads 
shows run time system components implemented hardware 
migrates thread manager scheduler mutex manager new cpu bypass interrupt scheduler hardware 
migrating services hardware brings significant performance benefits software threads efficient invocation processing mechanisms 
invocation mechanisms accessing system services longer inefficient traversal hierarchical software protocol stacks achieved lightweight atomic load store operations 
second speculative variable execution performed key system services scheduler eliminated 
example shows comparative timings executing typical scheduler services system active software threads running 
overhead making scheduling decision constant negligible jitter 
actual overhead selecting thread run hardware scheduler clock cycles constant delay independent number threads ready run queue 
small amount jitter seen software thread system bus mutexes cpu software interface software thread conditional variables software thread thread manager thread scheduler hardware interface hardware thread hthread system block diagram hardware interface hardware thread shared memory solely due cache misses swapping thread contexts cpu 
scheduler scheduling decisions priori parallel application programs running cpu 
cpu interrupted thread entering ready run queue higher priority thread running cpu threads ready run queue 
contrast existing software schedulers invoked interrupt cpu just consider event may may trigger true scheduling decision release mutex 
complete example mutex unlock operation illustrated shows processing steps hthread system performs release mutex scheduling decision resume execution thread 
traditional operating system steps performed completely software cpu 
steps require context switch application thread system services performed scheduler considers new scheduling decision required queuing blocked thread 
steps performed hardware allowing cpu continue executing application thread 
systems hardware software threads migrating processing cpu critical significant overhead jitter introduced cpu perform pre scheduler speculative processing hardware threads unblocked 
multithreaded capability reported supports cre table timing results hwti operations command clock cycles comment write id register time receiving thread id time system status changes write run register time receiving run command status register changes run write reset register time receiving reset command status register changed unused load time user thread issues load opcode time hwti status run including bus transaction store time user thread issues store opcode time hwti returns user status run including bus transaction time hthread yield time user thread issuing opcode time hwti status run hthread self time user thread issuing opcode time hwti status run hthread mutex lock time user thread issuing opcode time hwti status run including bus transaction time mutex manager time hthread mutex unlock time user thread issuing opcode time hwti status run including bus transaction time mutex manager time hthread exit time user thread issuing opcode time hwti ends bus transaction thread manager system status changes exit running software threads running software threads min mean max min mean max scheduling decision mutex lock interrupt handler determination id cpu software interface id id software thread mutexes software thread conditional variables software thread queue system bus thread manager hthread performance summary hwti id hardware thread hwti id hardware thread scheduler shared ready memory software thread unlocks mutex calling hthread mutex unlock sends signal mutex manager 
mutex manager inspects queue decides id mutex 
mutex manager sends add thread thread manager 
thread manager gives id scheduler add ready run queue 
scheduler knows id hardware thread add id queue 
scheduler sends run command id hwti 
hardware thread resumes execution owner mutex 
hthread mutex unlock sequence ation control hardware software threads linux 
approach taken allow hardware threads access data linux existing virtual memory address space 
convenient approach requires additional complexity hardware thread maintain virtual address translation tables invokes memory manager running cpu page swapping external interrupts introducing jitter overhead 
discussed existing computational models hybrid cpu fpga systems need creation standard parallel programming models 
unifying multithreaded programming model controlling hardware software threads running cpu fpga boundary 
provides system service libraries encapsulate platform specific operations pthreads compatible apis 
allows threads specified single pthreads multithreaded application program compiled run cpu synthesized run fpga 
support abstraction cpu fpga component boundary created hardware thread interface hwti component frees designer having specify embed platform specific instructions form customized hardware software interactions 
hardware thread interface supports generalized pthreads api semantics 
approach follows accepted practices high performance computing community bring accessibility portability reconfigurable computing domain 
ability allow multiple execution threads exist fpga provides new mechanism exploit full potential fpga 
acknowledgment article partially sponsored national science foundation ehs contract ccr 
andrews peck 
fpga implementation priority scheduler module 
proceedings th ieee international real time systems symposium works progress session rtss wip 
andrews peck preston sass 
hardware software designed multithreaded rtos kernel 
proceedings th ieee international conference emerging technologies factory automation september 
athanas silverman 
processor reconfiguration instruction set metamorphosis 
ieee computer volume pages 

programming posix threads 
addison wesley longman publishing boston ma usa 
callahan 
automatic compilation hybrid reconfigurable architectures 
ph dissertation university california berkeley 
david lau 
automated generation hardware accelerators direct memory access 
proceedings th annual conference field custom computing machines 
gokhale 
fpga computing data parallel proceedings ieee workshop fpgas custom computing machines pages 
rousseau 
automatic generation component wrappers composition hardware library elements starting communication service specification 
gupta dutt gupta nicolau 
spark high level synthesis framework applying parallelizing compiler transformations 
international conference vlsi design january 
hauser wawrzynek 
garp mips processor reconfigurable coprocessor 
proceedings ieee workshop fpgas custom computing machines 
wolf 
hardware software interface design embedded systems february 
pointer 
automated generation hardware accelerators direct memory access 
proceedings th annual conference field custom computing machines 

study speedups competitiveness fpga soft processor cores dynamic hardware software partitioning 
design automation test europe date volume pages munich germany 
bohm draper beveridge chawathe ross 
high level language abstraction reconfigurable computing 
ieee computer pages august 
park 
performance area modeling complete fpga designs presence loop transformations 
ieee transactions computers november 
peck andrews 
hardware software design operating systems thread management scheduling 
proceedings th ieee international real time systems symposium works progress session rtss wip 
hall 
compiler approach design space exploration fpga 
proceedings acm conference programming language design implementation june 
possi 
virtual memory window application reconfigurable coprocessors 
proceeding st annual conference design automation acm press pages 
pozzi 
seamless hardware software integration reconfigurable computing systems 
ieee design test computers pages 
agarwal lee smith lam athanas silverman ghosh 
prism ii compiler architecture 
proceedings ieee workshop fpgas custom computing machines pages 
www com 

www com 

www intel com technology 
intel hyper threading technology 
www systemc org 
systemc 
xilinx 
programmable logic devices 
www xilinx com 
accessed may 

yen wolf 
communication synthesis distributed embedded systems 
