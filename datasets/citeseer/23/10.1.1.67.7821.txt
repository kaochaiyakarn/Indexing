detecting debugging insecure information flows wes andy podgurski david leon electrical engineering computer science department case western reserve university euclid avenue cleveland oh usa hotmail com andy eecs edu edu new approach dynamic information flow analysis detect debug insecure flows programs 
applied offline validate debug program information flow policy fast response critical applied online prevent illegal flows deployed programs 
dynamic analysis inherently unable detect implicit information flows approach incorporates static preprocessing phase permits detection implicit flows runtime addition explicit ones 
support interactive debugging insecure flows incorporates new forward computing algorithm dynamic slicing precise previous forward computing algorithms restricted programs structured control flow 
prototype tool implementing proposed approach developed java byte code programs 
case studies tool applied subject programs described 

insecure information flows classical type security violation 
flows permit leakage confidential information corruption data high integrity requirements data untrustworthy source 
information flows critical occurrence ordinary software failures involving interactions program components 
information flow occurs object source object target sink information stored propagated directly indirectly object 
information flows explicit implicit 
explicit flows result data control dependences program statements 
example explicit flow variable assignment statement variable defined statement 
explicit flow variable branch predicate conditional statement variable defined conditional statement scope 
conditional statement may cause implicit flow 
example consider statements 
clause executed information flow occurs final value depends value flow explicit clause executed implicit 
information flow analysis computer security closely related program dependence analysis applications software engineering code optimization parallelization 
podgurski clarke shown statement program affect execution behavior static chain data control dependences statements 
information flow analysis program dependence analysis closely related program slicing debugging technique seeks identify set program statements called slice responsible erroneous program state occurred particular location program 
static dynamic variants program slicing 
dynamic information flow analysis seeks identify information flows objects runtime closely related dynamic slicing extracts slice execution trace 
dynamic information flow analysis dynamic slicing potentially precise static counterparts outcomes conditional branches known runtime 
dynamic slicing intended general debugging useful determining cause unsafe note characterization implicit explicit flows somewhat different 
information flows discovered dynamic information flow analysis 
importance information flows attacks software failures capability detecting illegal erroneous information flows potentially great utility intrusion detection software testing 
surprisingly dynamic information flow analysis applications received little attention research literature 
practical precise forward computing algorithm intra inter procedural structured unstructured programs 
forward computing algorithms dynamic slicing operate tandem program execution advantage require previously stored execution trace 
dynamic analysis inherently unable detect implicit information flows approach incorporates optional static preprocessing phase permits detection implicit flows runtime addition explicit ones 
approach apparently address detection implicit flows dynamic setting 
implemented algorithm tool monitoring information flow java byte code programs information flow monitoring tool detect unsafe information flows offline synthetic test cases captured operational inputs online deployment provided software monitored time performance critical 
capability possible forward computing algorithm 
recognizing security requirements change deployment tool designed support configurable information flow policies feature static systems lack 
dynamic nature tool easily handles language features generally hard handle static context pointers arrays dynamic binding 
checking illegal information flows objects tool considers dynamic types objects 
handles intra procedural inter procedural flows currently address flows resulting exceptions exit statements handles data flows threads multi threaded programs 
support debugging unsafe information flows kinds debugging variant dynamic information flow analysis algorithm dynamic slicing 
forward computing algorithm applicable structured unstructured programs 
forward computing algorithms dynamic slicing advantageous interactive debugging require note constructs java language break continue return statements lead programs strictly speaking unstructured 
previously stored execution trace 
slicing algorithm precise reasonably efficient necessary define variant standard control dependence called direct dynamic control dependence devise algorithm compute efficiently see section 
slicing algorithm optionally compute relevant slices handle multiple procedures unstructured constructs control statements involving object array general relevant slice algorithm 
section surveys related information flow analysis dynamic slicing 
section presents definitions equations needed describe algorithms 
section presents algorithms 
section describes approach detecting implicit flows 
section briefly discusses implementation java byte code programs 
section describes results evaluating tool empirically 
section 

related lampson motivated research information flow analysis describing problem listing number possible information leaks 
fenton proposed machine called data mark machine support dynamic checking information flows 
machine variable including program counter pc tagged security level 
write variable inhibited level lower pc level 
note instruction set machine contains instruction reset pc level 
jones lipton proposed similar mechanism output program checked illegal flows 
perl scripting language provides special execution mode called taint mode user supplied input treated suspicious programmer explicitly approves 
taint mode effective preventing flows user supplied input data potentially dangerous system calls unable detect prevent type flows including ones resulting control dependence 
static analysis techniques validating information flows usually safer precise dynamic mechanisms treat control flow paths executable 
denning denning proposed technique control flow data flow analysis verifying program compliance information flow policy 
number language type checking systems proposed 
systems program expression assigned security type addition ordinary type 
type checking program compiler ensures program exhibit illegal information flows run time 
tip provides survey static dynamic vf vi cfg unstructured method program slicing techniques 
dynamic program slicing introduced korel laski approach computes executable slices structured programs 
korel proposed algorithm computes executable slices possibly unstructured programs 
agrawal horgan dynamic dependence graphs ddg size unbounded reduced version compute dynamic slices 
aforementioned algorithms backward analysis forward computing algorithms dynamic slicing information flow analysis focus 
korel propose forward computing algorithm dynamic slicing algorithm applicable structured programs 
forward computing slicing algorithm proposed handling possibly unstructured programs 
algorithm employs imprecise rules capturing control dependences involving goto break continue statements 
example goto statement executed slices target statement statements execute contain goto statements dependent 
algorithm precision reduced fact determines variables statement statically 
presents example contrasts slices computed algorithm slices computed algorithm 
zhang analyzed characteristics dynamic slices overlapping identified properties enable space efficient representation forward computing algorithms 
show reduced order binary decision diagrams represent set dynamic slices space time requirements maintaining dynamic slices greatly reduced 
korel laski defined relation called potential influence relates control statement statements affect evaluated differently 
agrawal horgan potential influence relation define call relevant slices dynamic program slices reflect potential influences 
backward computing algorithm computing relevant slices extending ddg 
proposed coverage relevant slices involving certain limited code changes basis test suite reduction regression testing 
earlier version algorithm computes relevant slices extending program dependence graphs pdgs 
forward computing algorithm strictly intra procedural handles scalar variables structured code 
wang backward computing algorithm computing relevant slices augmenting pdg discussed relevant slices detection call omission errors java byte code programs 
clear parallel potential influence relation implicit flow relation described earlier surprisingly 
approach detecting implicit flows section related aforementioned relevant slices 
approach uses program transformations uses forward computing algorithm additionally handle interprocedural flows unstructured constructs control statements involving object array 

definitions section conjunction appendix presents number definitions equations form basis algorithms 
dynamic control dependence data dependence defined 
relations program statements define direct indirect influence relations 
relations define information flows dynamic slices 

dynamic control dependence program dependence analysis concept control dependence model dependence program statements branch predicates potentially control execution 
achieve precision dynamic information flow analysis dynamic slicing algorithms require new definition dynamic control dependence classical definition static control dependence 
classical control dependence defined appendix conservative static approximation runtime dependences occur program statements branch predicates control execution 
control dependence characterized precisely runtime outcomes conditional table sample trace cfg corresponding ddyncd relationships 
column shows steps taken algorithm 
column shows state top stack displayed right 
ddyncd algorithm actions tagged line number ddyncd ddyncd pushes ddyncd pops ddyncd pushes ddyncd pushes ddyncd pops ddyncd pops pushes pops ddyncd pushes ddyncd pops pushes ddyncd ddyncd pushes pops ddyncd pops pushes ddyncd pops pushes pops ddyncd ddyncd branches known 
defining dynamic control dependence useful speak terms execution traces 
formally execution trace sequence elements called actions 
action represents execution statement basic block 
kth action trace denoted corresponding statement basic block 
statement occurring trace denotes action involving execution predicate action action branch predicate 
subtrace denoted subsequence actions starting 
obvious correspondence execution traces programs initial walks see appendix programs control flow graphs equate traces initial walks actions vertex occurrences 
static control dependence relation due ferrante 
appendix define rename direct control dependence dcd 
provide formal definition dynamic control dependence dcd relation definition 
actions execution trace predicate action 
directly dynamically control dependent denoted ddyncd iff subtrace demonstrates dcd unique predicate action directly dynamically control dependent denoted ddyncd 
intuitively ddyncd predicate action occur prior action dcd key precisely capturing dynamic control dependences information flows slices may dynamic scope predicate actions simultaneously due loops nested control constructs unstructured flow control 
note ddyncd relation applicable structured unstructured programs 
ddyncd relationships control flow graph execution trace vi vf shown second column table 
defined ddyncd models intraprocedural control dependences 
inter procedural control dependences may occur execution trace spans different functions 

dynamic data dependence modeling dynamic data dependences actions requires associating sets variables objects action set variables objects defined assigned value set variables objects referenced 
note different objects may defined different actions involving statement 
apply notation traces sets actions obvious way 
definition 
actions execution trace directly dynamically data dependent denoted iff set actions directly dynamically data dependent denoted 
informally iff uses variable object defined relation models intra procedural inter procedural data dependences 
occur execution trace spans different functions data defined function 

direct influence influence addition ddyncd relations identify kinds dynamic dependences actions inter procedural defined formally value returned return statement value passed formal parameter control dependence calling method invoke instruction similar static entry dependence effect described combination aforementioned types dependences comprises call direct influence 
actions directly influences denoted iff exhibits types dependences 
note reversal order set actions directly influenced denoted 
influence relation represents different ways direct indirect statement influence execution 
formally simply transitive closure relation 
definition 
execution trace actions influences denoted influence iff sequence actions ai ai 
set actions influence denoted influence 
follows influence influence 
dynamic information flow analysis dynamic slicing dynamic information flow analysis closely related dynamic slicing examine execution trace identify dynamic control data dependence relationships 
dynamic information flow analysis concerned identifying set variables objects influence variable object action dynamic slicing concerned identifying set statements influence influence variable object definition 
execution trace actions variables defined respectively 
information flows iff influence set variables objects information flows set influence set variables objects influence set variables objects actions influence dynamic information flow analysis algorithm inductive characterization set note compute variables objects information flows variable object action uses define suffices compute definition dynamic slice action set statements executed actions influence plus 
definition 
execution trace action dynamic slice set statements influence dynamic slicing algorithm inductive characterization ii useful consider dynamic slice variable just action executed 
dynamic slice variable object just execution action simply slice action defined 
algorithms section describe algorithm computing ddyncd relation describe forward computing algorithms dynamic information flow analysis dynamic slicing build ddyncd algorithm 

direct dynamic control dependence section algorithm computing direct dynamic control dependence relation ddyncd 
algorithm shown crucial computing dynamic information flows dynamic slices precisely avoiding spurious dependences applicable structured unstructured programs 
algorithm applies individual method requires control flow graph immediate see appendix computed done statically class loaded 
important data structure algorithm stack denoted stores predicate actions dynamic scope summary steps 
push decision node reached 
pop decision node ipd reached 
current node directly control dependent tos 
pop control node node ipd reached step ensures stack size bounded compute direct dynamic control dependence input executing statement output ddyncd null ipd immediate postdominator statement tos top empty ipd tos pop endif empty ddyncd tos ddyncd null endif decision statement empty ipd ipd tos pop endif push endif ddyncd algorithm exited 
dynamic scope predicate action exited ipd reached time popped 
note loops arbitrary number dynamic scopes may open point execution ensure size bounded number decision vertices latest action sequence predicate actions involving predicates immediate postdominator kept 
permissible results trace decomposed sequence segments demonstrate chain ddyncd relationships statements sequence vertices involved relationships decomposed blocks vertices immediate postdominator 
results stated formally proved extended version 
presentation graphically illustrates steps taken ddyncd algorithm 
table shows computing ddyncd relationships algorithm leads results directly applying definition ddyncd relation 
note slicing algorithm described computes ddyncd relation termed dynamic compute input action compute see section endfor store subsequent store subsequent sink defined policy contains sensitive object execution log control dependence 
statement set cd predicate statements statically control dependent computed 
action determined dynamically control dependent action algorithms cd latest time stamp executed predicate cd 
algorithm requires lg worst case time action processed number predicate statements method 
ddyncd algorithm hand requires constant time action processed assuming immediate precomputed 
dynamic control dependence chain captured potentially useful debugging 

dynamic information flow analysis dynamic slicing shows high level description dynamic information flow analysis dynamic slicing algorithms integrated 
algorithms apply equations ii sequentially action ai executing program store results subsequent 
algorithms forward computing equations applied ai values depend computed available 
respect algorithms similar dynamic slicing algorithm 
slicing algorithm computes accurate slices precision control dependence sub algorithm ddyncd data dependences computed dynamically object array resolved 
number statements number active objects program 
discussed time complexities action 





print 
print 
print respectively 
space complexity action respectively 

implicit flows 





id 
print 
id 
id 
print 
print original code transformed code algorithm section capable detecting explicit information flows described section dynamic nature impedes detecting implicit flows 
note flows resulting control constructs considered implicit 
characterization implicit flow somewhat different statement defining target flow executes flow considered explicit 
flow detectable algorithm 
innovative aspect approach includes optional preliminary static analysis phase identifies implicit flows transforms explicit ones 
resulting hybrid mechanism capable detecting explicit implicit information flows 
clear advantage hybrid mechanism purely static ones accurately determine sources flows involve object array 
hand false positive instances illegal flows arise implicit flows considered analysis implicit flows optional feature tool 
purpose aforementioned transformation tool api provides method declared void id id id identifies decision statement id identifies variable records influence adding sets computed suppose id id invoked branch define realizes implicit flow variable call effect analysis executing statement branch 
effect converts implicit flow explicit 
code transformation process involves statically identifying implicit flows implicit influences inserting calls appropriate locations 
discuss example transformations transformation algorithm discuss limitations 
note section assume intruder trying access sensitive information may knowledge code information flows analyzed 
assume sake discussion information flows monitored online 

examples consider snippet code binary variables 
line executes 
holds basic algorithm detect explicit information flow line line print statement line 
hand line execute 
holds basic algorithm detect implicit flow line line intruder infer observing 
implicit flows missed algorithm transformation shown performed 
transformed code inserted call records implicit influence statement variable allowing algorithm track resulting implicit flows 
note intruder familiar code realize stay condition hold stay condition hold 
cases illustrate transformation needed sensitive line execute call prevents line executing disclosing intruder infer 
note line contains result recording implicit influence line 
sensitive line execute call prevents line executing disclosing intruder infer 
sensitive known line execute call prevents line executing disclosing intruder infer 
note sensitive line executes disclosing consequently 
disclosed value conditional expression true matter value addition predicate uses line execute 

id 
id 



id id engender explicit implicit information flows 
summary result transformation line discloses information leak sensitive information execute sensitive 
line discloses information leak sensitive information execute sensitive 
line discloses information see arguments leak sensitive information execute sensitive 
shows transformed java code snippets involving various control constructs introduced code shown italics 

transformation algorithm 
switch case id 
break case id 
id id various transformed code section presents algorithm identifies potential implicit flows performs appropriate code transformation enable algorithm monitor implicit explicit flows 
currently algorithm handles implicit flows targets simple variables local static variables object 
note sources may involve object array 
algorithm shown applies individual method requires control flow graph immediate computed decision vertex algorithm inserts start branch calls reflecting explicit influences explicit control flows due execution encountered alternative branches taken 
example true branch statement inserts call assume predicates immediate postdominator additional dummy vertices inserted ensure 
proc decision vertex successors successors defs reachable ipd procedure targets inserts basic block calls id targets id identifier line decision statement function reachable start returns nodes reachable start inclusive function defs returns set variables defined sub graph transformation algorithm reflects influence line defined false branch false branch inserts call reflects influence line defined true branch 
note control statements false branch skips body statement points immediate postdominator decision vertex 
calls inserted 
note calls inserted immediate postdominator effectively ops body statement execute influence explicit recorded 
note dynamic slicing algorithm optionally identify statements implicitly influence variable due method adds recording influence statement variable debugging valuable know information flow statement variable occurred implicitly explicitly 
convey implicit flow occurred tool add call statement slice flow implicit 
decided runtime start method checking comprises explicitly influenced discuss limitations transformation algorithm addressed 
second parameter method identifies target flow 
current transformation algorithm handles implicit flows involving targets simple variables easily identified statically 
points analysis enable algorithm support implicit flows involving targets public class public static void int size 
input vlist vector employee objects note employee highest rank pay order static void vector vlist employee null string null int find employee highest rank int vlist size employee vlist elementat employee vlist elementat string order size vlist size bill account outlet outside world public static void main string args vector new vector populate list objects type employee get meeting time information time starttime start time time endtime time reserve room large attendees size endtime exceeds meeting past pm 
insecure java code implementing meeting scheduler object array 
tools perform points analysis java programs soot employ intermediate representation java byte code making integration tool infeasible 
current transformation algorithm handle inter procedural implicit flows flows targets defined called functions 
providing support straightforward static functions non static ones 
statement calling non static function algorithm determine reasonable accuracy functions called 
type inference related points analysis increase accuracy process 
array region analysis summarizes subregion array affected statements loops enable algorithm identify accuracy implicit flow targets array 

implementation implemented information flow analysis dynamic slicing algorithms prototype tool comprising lines java code 
current version tool user define desired information flow policies programmatically describing entities source objects monitor referred sources 
sensitive objects sources involved illegal flow referred 
sink methods illegal flows checked referred sinks 
illegal flow detection sources typically 
debugging typically subset sources 
sinks typically methods expose internal application data outside world print send 
tool comprises main components instrumenter profiler 
preliminary step applying tool instrument target byte code classes jar files instrumenter implemented byte code engineering library 
instrumenter inserts number method calls profiler points interest 
runtime instrumented application invokes profiler passing information enables monitor information flows build program slices 
note applying tool program instrument subset program classes source code required java libraries 
generally classes instrumented accurate costly analysis 
experimental results verify utility dynamic information flow analysis dynamic slicing tool applied case studies 
section briefly discuss performance impact tool 

case study applied tool component open source java application server apache tomcat exhibits file disclosure vulnerability described mcclure 
vulnerability versions widely java application servers including bea weblogic ibm websphere 
show vulnerability weblogic component servlet designed serve publicly available text files clients exploited reveal java server pages jsp source code application may contain sensitive data 
describe learned disclosed jsp source code execute malicious remote commands 
tomcat intended serve publicly available text files exploited similarly reveal contents file servlet root directory simply passing relative path file 
initially case study capability tool detect illegal flows utilized log information flows analysis security analyst 
note servlet may send response data client object object 
write print methods objects information sinks natural monitor illegal information flows 
accordingly instrumented implicit flow detection option turned defined information flow policy sources objects sinks write print methods 
issued requests serve various files including ones located directories intended public access directories containing jsp source code 
tests information flows sink object involved single write method call parameters associated 
log recorded information flows slices write parameters computed time defined 
request flows different source objects sink byte code instructions affected 
logged state source objects included full pathname requested file sufficient security analyst determine illegal request took place 
note opted instrument tomcat libraries java api library information logged 
learned illegal requests occurring sense redefine information flow policy follows sources objects type java io file java io associated files belonging public directories sinks write print methods class java api provide access name file associated 
information flow policies require information tool loads modified version limitation 

policy prevent leaks ones described 

case study applied tool java program implementing meeting scheduler pentagon employees application built fictitious requirements 
suppose pentagon class employees activities concealed outside world pentagon information systems type employee represented class high security low security represents employees 
derive class employee contains information name rank expense 
suppose pentagon systems meeting scheduler 
order set meeting office administrator enters start time expected time identification numbers attendees 
meeting expected past pm system automatically orders food outside fax server 
fax includes number attendees expense account number employee paying bill attendee 
recipient fax aware pattern exhibited expense account numbers employees type cases able infer high ranking high security employee attending meeting late night special operations planned 
shows java code insecure implementation described application relevant code shown exhibits potential information leak object representing fax machine 
insecure implementation result developer aware security requirement security requirement exist time application developed developer failed check type bug remained despite subsequent visual code inspection 
order test implementation tool instrumented implicit flow detection option turned defined information flow policy sources objects attributes identifying high security employee name sinks methods api 
executing test cases highest ranking employee represented object meeting ended pm tool detected insecure information flows attribute method 
logged set comprised objects endtime instance belonging object instances rank belonging objects local variables declared employee constructor shown 
instance determined sensitive attribute identifying object 
object corresponded highest ranking attendee expense account number printed fax order 
note defined sources comprised single object sensitive 
necessary detection illegal leaks additional objects cases valuable analysis 
applied tool number java programs order assess time storage impact 
expected cases considerable slowdown storage impact 
results clear processing intensive applications having relatively large execution traces request diff javac average slowdown feasible apply tool online 
hand interactive intensive applications average slowdown feasible apply tool offline online 
web interactive business applications typically processing intensive believe candidates deployed tool 

new algorithms dynamic information flow analysis dynamic slicing 
algorithm precise forward computing algorithm proposed applies structured unstructured programs 
slicing algorithm incorporates innovative efficient way computing dynamic control dependences 
described implementation algorithms works java byte code programs 
knowledge information flow analysis tool support configurable information flow policies implicit flows dynamic setting 
currently algorithms address intraprocedural inter procedural control dependences resulting halt exit instructions exceptions 
plan augment algorithms tool provide capability modifying ddyncd algorithm employ extended form control flow graph similar static inter procedural control dependence analysis 
plan address limitations implicit flow detection algorithm described section 
appendix background definitions customary control flow data flow dependence analysis computer programs model programs subprograms control flow graphs type directed graph digraph 
vertices control flow graph represent simple program statements basic blocks edges represent possible transfers control 
initial vertex vi final vertex vf represent entry point exit point respectively vertex successors called decision vertex represents conditional branch predicate 
walk sequence vertices vn vi vi edge 
call walk vi initial walk 
concept postdominance plays important role characterizing control dependence program statements 
vertex postdominates vertex iff vf walk contains postdominator postdominator occur vf walk called immediate postdominator denoted ipd 
see table 
classical graph theoretic definition static control dependence due ferrante code optimization research 
form control dependence call direct control dependence applicable structured unstructured programs 
definition 
vertices control flow graph directly control dependent denoted dcd iff successors postdominates 
set vertices directly control dependent denoted dcd 
see table 
table ipd cd dcd relationships control flow graph ipd cd dcd seminal certifying secure information flow programs denning graph theoretic characterization conditions implicit information flow occur 
relation denning defined transitive closure dcd relation 
call relation control dependence qualifier direct 
definition 
vertices control flow graph control dependent denoted cd walk contain ipd walk said demonstrate cd set vertices control dependent denoted cd 
see table 
proven dcd iff walk demonstrates cd vertex dcd said demonstrate dcd easily seen walk strictly postdominates vertex 
agesen constraint type inference parametric polymorphism 
international static analysis symposium sas 
agrawal horgan dynamic program slicing 
sigplan notices pp 
june 
agrawal horgan london incremental regression testing 
proceedings ieee conference software maintenance montreal canada 
dynamic slicing method maintenance large programs 
th european conference software maintenance re engineering lisbon portugal march 
denning lattice model secure information flow 
comm 
acm vol 
may 
denning denning certification programs secure information flow 
communication acm 
denning secure information flow computer systems 
ph thesis computer science dept purdue lafayette ind may 
handling pointers unstructured statements forward computed dynamic slice algorithm 
acta cybernetica 
fenton memoryless subsystems 
computer journal 
ferrante ottenstein warren 
program dependence graph optimization 
acm transactions programming languages systems october 
relevant slicing method debugging 
proceedings th european software engineering pages 
toulouse france september 
hind pointer analysis 
international symposium software testing analysis 
jones lipton enforcement security policies computation 
journal computer systems sciences 
korel computation dynamic program slices unstructured programs 
ieee tse 
korel laski algorithmic software fault localization 
proceedings th annual hawaii international conference system sciences volume ii pages korel laski dynamic program slicing 
information processing letters october 
korel forward computation dynamic program slices 
issta 
lampson note confinement problem 
communication acm oct 
podgurski leon detecting debugging insecure information flows extended version 
tech 
rep edu index html 
dynamic information flow analysis slicing profiling 
edu index html 
mcclure shah shah web hacking attacks defense 
addison wesley pub 


podgurski clarke formal model program dependencies implications software testing debugging maintenance 
ieee tse september 
podgurski significance program dependences software testing debugging maintenance 
ph thesis 
computer sc 
dept mass sept 
sabelfeld myers language information flow security 
ieee journal selected areas communications jan 
sinha harrold rothermel interprocedural control dependence 
acm transactions software engineering methodology 
soot java optimization framework 
www sable mcgill ca soot 
byte code engineering library apache jakarta project jakarta apache org 
apache software foundation 
tip survey program slicing techniques journal programming languages 
wang compressed bytecode traces slicing java programs 
intl 
conf 
software engineering edinburgh uk may 
weiser program slicing 
ieee transactions software engineering 
wolfe high performance compilers parallel computing 
addison wesley pub 


zhang gupta zhang efficient forward computation dynamic slices reduced ordered binary decision diagrams 
intl 
conf 
software engineering edinburgh uk may 

