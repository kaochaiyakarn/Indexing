java programs interact virtual machines microarchitectural level andy georges koen de department electronics information systems ghent university st gent belgium kdb java workloads increasingly prominent various platforms ranging embedded systems generalpurpose computers high servers 
understanding implications aspects involved running java workloads extremely important design system run workloads 
words understanding interaction java application input virtual machine runs key succesful design 
goal study complex interaction microarchitectural level analyzing branch behavior cache behavior done measuring large number performance characteristics performance counters amd microprocessor 
performance characteristics measured virtual machine configurations collection java benchmarks corresponding inputs coming specjvm benchmark suite specjbb benchmark suite java grande forum benchmark suite open source raytracer called raja scene descriptions 
large amount data analyzed statistical data analysis techniques principal components analysis cluster analysis 
techniques provide useful insights understandable way 
experiments conclude behavior observed microarchitectural level primarily determined virtual machine small input sets specjvm input set ii behavior quite different various input sets short running versus longrunning benchmarks iii long running benchmarks hot spots behavior primarily determined java program virtual machine virtual machines optimize hot spots similarly behaving native code iv general behavior java application running virtual machine significantly different running virtual machine 
warn researchers working java workloads careful limited number java benchmarks permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla october anaheim california usa 
copyright acm 
virtual machines lead biased 
categories subject descriptors performance systems design studies measurement techniques performance attributes general terms measurement performance experimentation keywords workload characterization performance analysis statistical data analysis java workloads virtual machine technology 
years java programming language prominent role software field 
high application servers desktop applications small applications portable embedded devices java applications virtually area computing sector 
java applications abundant advent language introduced various virtual machines capable executing applications merits drawbacks 
distinguish important aspects possibly large impact behavior java workload virtual machine executing java bytecode java application input java application 
example concerning virtual machine choice interpretation versus just time jit compilation important 
mechanism implemented supporting java threads supporting garbage collection large impact performance 
secondly nature java application large impact behavior observed microprocessor 
example expect database application behave differently game application 
third input java application significant impact behavior java workload 
example large input cause large number objects created execution java application stressing memory subsystem 
aspects large impact behavior observed microarchitectural level terms branch behavior cache behavior instruction level parallelism 
close virtual machine java application input hard understand due complex behavior java workloads 
need techniques get better insight interaction 
main question want address behavior observed microprocessor level due virtual machine java application input application 
example virtual machines currently employ jit compilation optimization strategy 
big impact actual implementation jit engine observed behavior 
virtual machines implementing strategy behave similarly 
secondly large impact java application 
behavior java workload primarily determined java application virtual machine 
impact input java application 
years valuable research done characterizing java workloads get better insight behavior see related section 
previous typically considered virtual machines methodology benchmark suite specjvm 
addition studies small input set specjvm limit simulation time study 
raise questions relation previous 
methodology reliable java workloads 
happens behavior java workload highly dependent chosen virtual machine 
translate virtual machine virtual machine 
specjvm representative java applications 
taken specjvm valid java programs 
small input specjvm yielding short running java workload representative large input yielding long running java workload 
answer questions methodology 
measure workload characteristics performance counters running java workloads real hardware case amd microprocessor 
done large number virtual machine configurations total large number java applications corresponding inputs 
benchmarks inputs taken specjvm suite specjbb suite java grande forum suite 
addition include raytracer scene descriptions 
second statistical analysis done data principal components analysis pca 
pca multivariate statistical data reduction technique capable increasing understandability large amounts data 
basic idea statistical analysis follows 
java workloads displayed dimensional space number performance characteristics measured previous step 
dimension space large understandable study 
pca reduces high dimensional space lower dimensional uncorrelated space typically experiments loosing important information 
increases understandability reasons lower dimension ii correlation axes space 
third step methodology display java workloads lower dimensional space obtained pca 
addition analyze reduced java workload space cluster analysis ca 
methodology allow address questions raised 
java workloads far away space show dissimilar behavior java workloads close show similar behavior 
java workloads clustered virtual machine java applications running particular virtual machine close conclude behavior primarily determined virtual machine java application 
likewise java workloads clustered java application conclude java application largest impact virtual machine 
java program running different inputs results clustered data points conclude input small impact behavior 
answering questions raised interest various research domains 
java application developers get insight behavior code developing code interacts virtual machine input 
example behavior primarily influenced virtual machine java application application developers pay attention performance code focus reusability reliability 
second virtual machine developers get better insight sense behavior java workload influenced virtual machine implementation particular java programs interact virtual machine design 
information virtual machine developers design better vms 
third microprocessor designers get insight java workloads behave microprocessors designed address specific issues posed java workloads 
microprocessor designers heavily rely time consuming simulations extremely useful know small inputs result similar behavior large inputs reduce total simulation time compromising accuracy simulation runs 
organized follows 
section experimental setup 
distinguish components setup java workloads consisting virtual machine java benchmarks available various inputs benchmarks ii hardware platform amd microprocessor iii measurement technique chip performance counters iv workload characteristics methodology 
section discuss statistical data analysis techniques principal components analysis pca cluster analysis ca 
section results obtain analysis extensively discuss taken 
section discusses related characterizing java workloads 
conclude section 
experimental setup java workloads section discusses virtual machines java applications study 
virtual machines study virtual machine configurations tabulated table sun blackdown beta ibm jikesrvm jrockit kaffe 
sun blackdown beta virtual machines sun hotspot virtual machine core 
hotspot uses mixed scheme interpretation just time jit compilation optimization execute java applications 
degree optimization specified choosing client mode server mode 
client mode virtual machine performs fewer runtime optimizations resulting limited application startup time reduced memory footprint 
server mode virtual machine performs classic code optimizations optimizations specific java null check range check elimination 
interesting note hotspot maps java threads native os threads 
garbage collector uses fully accurate generational copying scheme 
new objects allocated nursery moved old object space nursery collected 
objects old object space reclaimed mark sweep compacting strategy 
bea weblogic jrockit virtual machine targeted server side java 
jrockit compiles methods invocation 
runtime statistics gathered hot methods scheduled optimization 
optimized code replaces old code virtual machine keeps running 
way adaptive optimization scheme realized 
jrockit uses mixed threading scheme called java threads multiplexed native threads 
virtual machine comes possible garbage collection strategies 
generational copying version experiments default heap sizes mib 
jikes research virtual machine rvm previously known jalape targeted server side java applications 
jikes written entirely java uses compilation entire execution interpretation 
possible configure jikesrvm different compiling modes baseline compiler optimizing compiler adaptive compiler 
baseline adaptive modes experiments 
threading system multiplexes java threads native threads 
range garbage collection strategies available virtual machine 
copying mark sweep generational collectors combinations strategies 
non generational copying scheme semispace 
kaffe open source virtual machine 
version experiments 
kaffe uses interpretation jit compilation 
addition native threads 
ibm uses mixed strategy employing ibm jit compiler ibm mixed mode interpreter mmi 
note choice garbage collector consistent virtual machine configurations 
chosen default garbage collector virtual machine 
leads different garbage collector mechanisms different virtual machines seen table 
section evaluate impact garbage collector workload behavior 
evaluation www kaffe org www ibm com show choice garbage collector minor impact results change 
java applications inputs numerous java applications available public commercial domain 
highly interactive 
applications purposes unsuitable measurements 
non interactive java programs command line inputs 
applications taken sources see table specjvm specjbb java grande forum suite raja 
specjvm client side java benchmark suite consisting benchmarks 
specjvm provides inputs 
contradictory input set names suggest size input set increase linearly 
benchmarks larger input increases problem size 
benchmarks larger input executes smaller input multiple times 
evaluation section discuss impact various input sets behavior java programs virtual machines 
specjvm designed evaluate combined hardware cpu caches memory software aspects virtual machine kernel activity java environment 
include graphics networking awt window management 
specjbb java business benchmark benchmark suite focussing middle tier business logic tier system 
run specjbb benchmark different numbers warehouses warehouses 
java grande forum benchmark suite intended study performance java context called grande applications applications requiring large amounts memory bandwidth processing power 
examples include computational science engineering codes large scale database applications business financial models 
chosen large scale applications sequential suite suitable uniprocessor performance evaluation 
benchmarks available problem sizes small large 
raja raytracer java 
included raytracer analysis distribution comes scene descriptions 
able quantify impact input behavior raytracer 
unfortunately unable execute benchmark jikes kaffe virtual machines 
ran benchmarks standard mib virtual machine heap size 
specjbb heap size mib 
hardware done experiments compatible platform ghz amd model 
microarchitecture amd identical amd athlon microarchitecture reduced size www spec org jvm www spec org jbb www org raja sourceforge net virtual machine configuration sun hotspot client generational non incremental garbage collection blackdown hotspot client generational non incremental garbage collection jikesrvm base baseline compiler copying garbage collection jikesrvm adpt adaptive compiler copying garbage collection jrockit adaptive optimizing compiler generational copying collector kaffe interpretation jit compilation non generational garbage collection ibm interpretation jit compilation table virtual machine configurations perform measurements 
specjvm compress compression program lzw method ported compress suite 
compress processes real data files 
various inputs obtained performing different number iterations various input files 
requires heap size mib allocates mib objects 
jess expert shell system adapted clips system 
various inputs consist set puzzles solved varying degrees difficulty 
benchmark requires heap size mib allocating mib objects 
db benchmark performs set database requests memory resident database mib 
various inputs obtained varying number requests database 
requires heap size mib allocates mib objects 
javac jdk source code compiler 
various inputs obtained making multiple copies input files 
requires heap size mib allocates mib objects 
mpegaudio commercial application decompressing mpeg layer audio files 
input consists mib audio data 
number objects allocated negligible 
mtrt raytracer threads render scene 
various inputs determined problem size 
benchmark requires heap size mib allocates mib objects 
jack early version javacc java parser generator 
various inputs passes data 
execution requires heap size mib mib objects allocated 
specjbb tier transaction system user interaction simulated random input selection third tier database represented set binary trees 
benchmark focuses business logic middle tier 
loosely ibm pbob benchmark 
mib heap space required run benchmark 
java grande forum search program solving connect game alpha beta pruning technique 
problem size determined starting position game solved 
heap size mib inputs 
euler solution set time dependent euler equations modeling channel bumped wall fourth order runge kutta scheme 
model evaluated timesteps 
problem size determined size mesh solution computed 
heap size required mib small input mib large input 
evaluation body model particles interacting jones potential cubic space 
problem size determined number particles 
inputs need heap size mib 
raytracer raytracer rendering scene containing spheres 
problem size determined resolution rendered image 
inputs require heap size mib 
raja raytracer 
latest pre version 
input variation obtained set scene descriptions 
table benchmarks measurements 
component subcomponent description memory hierarchy cache kb way set associative byte lines lru replacement line prefetching cache kb way set associative banks byte lines lru write allocate write back access ports bits cache kb way set associative unified chip exclusive tlb entries fully associative tlb entries way set associative tlb entries fully associative tlb entries way set associative branch prediction btb branch target buffer way set associative entries ras return address stack entries taken taken gshare entry branch predictor bit counters system design bus mhz gib second pipeline stages integer cycles floating point cycles integer pipeline pipeline integer execution unit address generation unit allows integer multiply pipeline integer execution unit address generation unit pipeline idem floating point pipeline pipeline dnow 
add mmx alu shifter floating point add dnow mmx multiply mmx alu floating point multiply divide square root pipeline floating point constant loads stores cache kb kb 
athlon belong amd processor family 
details amd study refer table 
amd superscalar microprocessor implementing ia instruction set architecture isa 
pipelined microarchitecture instructions fetched 
instructions fetched large kb instruction cache cache 
dealing branches instruction stream branch prediction done global history gshare taken taken branch predictor branch target buffer btb return address stack ras 
fetched variable length instruction decoded number simpler fixed length macro ops 
instructions translated cycle 
macro ops passed stage pipeline instruction control unit icu basically consists entry reorder buffer 
reorder buffer macro ops scheduled entry integer scheduler entry floating point scheduler integer floating point operations respectively 
entry integer scheduler organized collection entry deep reservation stations reservation station serving integer execution unit address generation unit 
entry floating point scheduler fpu floatingpoint unit serves floating point pipelines executing mmx dnow 
operations 
schedulers macro ops broken ops execute outof order 
schedulers amd microarchitecture entry load store unit 
load store unit consists queues entry queue cache load store accesses entry queue cache memory load store accesses requests missed table amd microprocessor summary 
cache 
cache organized cache having bit access ports 
interesting aspect amd microarchitecture fact unified cache exclusive cache 
means cache blocks previously held caches evicted held 
newer cache block stored previously resided cache block evicted room block swap operation done 
newer cache block stored previously reside cache block need evicted memory 
performance counters amd set microprocessor specific registers 
registers obtain information processor usage execution computer program 
kind information held called performance counter registers 
performance counter registers available amd measure characteristics benchmark executions 
performance counters important benefits alternative characterization methods 
characteristics obtained fast run computer programs native hardware 
alternative options significantly efficient 
example measuring characteristics instrumented binaries inevitably results serious slowdown 
measuring characteristics simulation worse detailed simulation approximately factor slower native execution 
second advantage performance counters setting infrastructure doing experiments extremely simple simulators instrumentation routines written 
third measuring kernel activity performance counters comes free 
instrumentation simulation hand require instrumenting kernel code employing full system simulator 
fourth advantage performance counters characteristics measured real hardware software model 
lead inaccuracies due higher abstraction level 
unfortunately performance counters come disadvantages 
measuring event executions computer program lead slightly different results 
reason cache contention due multitasking interrupts cope problem event measured multiple times average number measurements analysis 
study measured event times arithmetic average analysis 
second problem performance counters limited number events measured program execution events amd 
measure events listed table run program times 
note slowdown factors result fact program needs run times times making average program runs multiplied times measuring events events program run 
approach performance counters running native hardware yields slowdown factor single native program execution 
note faster instrumentation slowdown factor heavily depending instrumentation routines typically simulation slowdown factor 
third disadvantage performance counters sensitivity performance microarchitectural parameter measured microarchitecture fixed 
disadvantage remedied measuring characteristics multiple platforms having different microprocessors 
environment reading contents performance counter registers done version package provides patch common linux kernels 
linux red hat kernel 
package keeps track contents performance counter registers process basis 
means contents performance counters saved context switch restored context switch 
allows precise measurements multi tasking operating system linux 
order package purpose extend package deal multithreaded java 
original package capable measuring performance counter values single threaded process 
modern virtual machines running java applications java threads run native threads linux separate processes 
vms multiplex java threads set native threads example jrockit jikes 
vms map java threads single native thread 
case java threads called green threads 
able measure characteristics threads running virtual machine uses multiple native threads extended package 
way java threads created execution java application profiled 
user uu se linux workload characteristics processor events measured study amd tabulated table 
workload characteristics roughly divided groups general characteristics 
group events contains number clock cycles needed execute application number retired instructions number retired operations recall instructions broken fixed length simpler operations number retired branches processor frontend 
grouped characteristics related processor frontend cache fetch unit number fetches cache number cache misses number instruction fetches instruction cache number instruction fetches main memory 
characteristics measure tlb misses hit tlb tlb misses tlb 
addition measure number fetch unit stall cycles 
branch prediction 
group measures performance branch prediction hardware number branch taken taken mispredictions number branch target mispredictions performance return address stack ras processor core 
performance counters deal processor core basically measure stall cycles cycles new instructions pushed pipeline due data control structural hazards example due read write dependency unavailable functional unit unresolved cache branch misprediction group distinction events integer control unit icu full stall reservation station full stall floating point unit fpu full stall load store unit queue full stalls dispatch stall result number combined stall events 
data cache 
distinguish characteristics related data cache number dcache accesses number cache misses number number main memory number 
measure tlb misses hit tlb tlb misses tlb 
bus unit 
monitor number requests main memory seen bus 
performance characteristics statistical analysis divided number clock cycles 
doing events measured unit time 
example particular performance characteristic number cache misses unit time clock cycle 
note performance measure appropriate cache rate studies directly related component abbrev 
general cycles number clock cycles instr number retired instructions ops number retired operations br number retired branches br taken number retired taken branches far ctrl number retired far control instructions ret number retired near return instructions processor frontend ic fetch number cache fetches ic number cache misses ic fetch number instruction fetches ic mem number instruction fetches memory itlb number tlb misses tlb hits itlb number tlb misses fetch stall number fetch unit stall cycles branch prediction br number retired mispredicted branches br taken number retired mispredicted taken branches ret number retired mispredicted near return instructions target number mispredicted branches due address ras hits number return address stack hits ras number return address stack overflows processor core dispatch stall number dispatch stall cycles combined stall events icu full number integer control unit icu full stall cycles res stat full number reservation station full stall cycles fpu full number floating point unit fpu full stall cycles lsu full number load store unit lsu full stall cycles concerning cache access queue lsu full number load store unit lsu full stall cycles concerning memory access queue data cache dc access number data cache accesses equals number load store operations dc number data cache misses dc number cache dc mem number main memory dc wb number dtlb number tlb misses tlb hits dtlb number tlb misses system bus mem requests number memory requests seen bus table workload characteristics obtained performance counters amd 
actual performance 
high cache rate result low number cache misses unit time number cache accesses low 
stated previous section performance counters measured kernel user activity 
known previous java programs spend significant amount time kernel activity measured 

statistical analysis previous sections clear amount data obtained measurements huge 
performance counter event measured benchmark virtual machine input 
total amount data large analyzed understandably 
addition exists correlation various events interpretation data difficult purpose 
methodology statistical data analysis principal components analysis pca cluster analysis ca different view measured data 
applying statistical analysis techniques done commercial software package statistica 
discuss pca ca subsections 
principal components analysis basic idea approach java workload java workload determined java application input virtual machine viewed point multidimensional space built performance counter events 
applying statistical analysis technique normalize data mean variance event zero respectively 
subsequently apply principal components analysis pca transforms data uncorrelated data 
beneficial purpose measuring dis similarity java workloads 
measuring dis similarity java workloads original non normalized correlated events hand give distorted view 
euclidean distance java workloads original space reliable measure reasons 
non normalized data gives higher weight events higher variance 
normalization events get equal weights 
second euclidean distance correlated space gives higher weight correlated variables 
correlated variables essence measure underlying program characteristic propose remove correlation pca 
pca computes new variables called principal components linear combinations original variables principal components uncorrelated 
pca variables 
xp principal components 
zp zi 
transformation properties ar ar 
ar zp means contains information zp ii cov zi zj means information overlap principal components 
note total variance data remains transformation ar xi ar zi 
stated property previous paragraph principal components high variance small variance 
removing components lowest variance analysis reduce number program characteristics controlling amount information thrown away 
retain principal components significant information reduction cases example 
measure fraction information retained dimensional space amount variance ar zi ar xi accounted principal components 
typically total variance explained retained principal components 
study original variables events measured performance counters see section 
examining important principal components linear combinations original performance events zi 
meaningful interpretations principal components terms original program characteristics 
coefficient aij close implies strong impact original characteristic xj principal component zi 
coefficient aij close hand implies impact 
step analysis display various java workloads points dimensional space built principal components 
view java workload space 
note projection dimensional space easier understand view original dimensional space reasons smaller ii dimensional space uncorrelated 
cluster analysis cluster analysis ca data analysis technique aimed clustering java workloads groups exhibit similar behavior 
done number variables case principal components obtained pca 
commonly algorithm doing cluster analysis linkage clustering starts matrix distances java workloads 
starting point algorithm java workload considered group 
iteration algorithm groups close smallest distance called linkage distance combined form new group 
close groups gradually merged cases single group 
represented called dendrogram graphically represents linkage distance group merge iteration algorithm 
having obtained dendrogram user decide clusters consider 
decision linkage distance 
small linkage distances imply strong clustering large linkage distances imply weak clustering 
exist methods calculating distance groups 
pair group average strategy 
means distance groups defined average distance members group 
reason chose perform pca subsequently cluster analysis applying cluster analysis initial data follows 
original variables highly correlated implies euclidean distance space unreliable due correlation explained previously 
performing pca alleviates problem 
addition pca gives opportunity visualize understand java workloads different 

evaluation results evaluation section extensively discuss results obtained analysis 
results input sets specjvm benchmark suite 
second analyze behavior java grande forum workloads 
complete picture java workloads considered study 
results specjvm benchmark java grande forum presenting complete picture reasons 
results obtained comparable previous done specjvm 
second understanding easier building complexity data 
third allows demonstrate relativity methodology 
words results obtained pca ca quantify dis similarity java workloads included analysis say behavior workloads comparison java workloads included analysis 
specjvm specjvm benchmark suite offers input sets commonly referred input set 
benchmarks executed virtual machines summarized table maximal heap size mib 
discuss results input set discuss results 
analysis input set data input set retain principal components account observed variance measurements java workloads specjvm benchmarks times vm configurations 
factor loadings obtained principal components 
factor loadings account instr ops br br taken far ctrl ret ic fetch ic principal component principal component principal component principal component ic fetch ic mem itlb itlb fetch stall br br taken ret target ras hits general processor frontend branch prediction processor core data cache bus factor loading specjvm input set 
total variance respectively 
take closer look factor loadings aij retained principal components obvious component far important 
contributions measured characteristics second third fourth component relatively smaller 
enumeration discuss contributions performance characteristics principal component main positive influence principal component caused branch prediction characteristics processor frontend characteristics amount fetch stalls see table 
principal component negatively influenced stall events amount fetch stalls dispatch stalls icu full stalls memory lsu full stalls 
addition negatively affected number data cache misses data cache data cache memory 
negatively influenced amount memory requests seen bus 
second principal component positively influenced number instructions retired clock cycle number retired operations cycle amount retired near return instructions number stalls caused full lsu unit amount data cache accesses 
component negatively influenced number instruction fetches memory number tlb misses branch prediction accuracy number stalls caused full reservation stations 
negatively influenced number tlb misses 
ras dispatch stall icu full res stat full fpu full lsu full lsu full dc access dc third principal component see amount taken branches number stalls caused full reservation stations deliver major positive contributions 
negatively influenced amount retired far control instructions amount tlb misses hit tlb amount tlb misses 
fourth principal component positively dominated amount tlb misses hit tlb negatively dominated amount branches amount tlb misses 
factor loadings give indication correlated characteristics set java workloads 
example results conclude principal component branch characteristics correlate frontend characteristics 
correlation positive correlation characteristics positive contribution principal component 
frontend characteristics correlate negatively amount fetch stalls 
words implies example high number cache fetches unit time correlates low number fetch stalls unit time understood intuitively 
display java workloads dimensional space built principal components 
shown figures versus second principal component third versus fourth principal component respectively 
dealing dimensional space important consider plots simultaneously get clear picture dimensions 
note figures different specjvm benchmarks running virtual machine represented symbol 
graphs dc dc mem dc wb dtlb dtlb mem requests principal component blackdown ibm jikes base jikes adaptive sun kaffe jrockit compress compress compress compress principal component scatterplot specjvm workload set function second principal component 
different specjvm benchmarks running virtual machine represented symbol 
principal component blackdown ibm jikes base jikes adaptive jrockit kaffe sun compress compress principal component compress compress scatterplot specjvm workload set function third fourth principal component 
different specjvm benchmarks running virtual machine represented symbol 
interpreted follows 
java workload having high coefficient principal component shows behavior characterized see high numbers branch characteristics frontend characteristics 
addition low numbers observed stall characteristics fetch dispatch icu memory lsu number data cache misses number data memory number data number memory requests bus 
graphs figures clearly show data points clustered virtual machine 
observe tight clusters jrockit baseline version jikes adaptive version jikes ibm vm 
clusters corresponding sun vm blackdown vm clustered tightly 
notice clusters quite close 
obviously due fact virtual machines built hotspot virtual machine core 
graph reveals kaffe exhibits tightly clustered behavior 
results conclude input set virtual machine larger impact behavior java application 
words virtual machine running java application small input exhibit similar behavior irrespective java application running 
understood intuitively input set results short running benchmarks order seconds startup time virtual machine initializing loading significant parts jdk library highest factor contributing behavior 
data conclude input set specjvm performance analysis method primarily interested measuring startup times just long running performance 
interesting note data points corresponding compress benchmark part clusters discussed previous paragraph 
words java benchmark interaction application virtual machine large impact behavior microarchitectural level various virtual machines compress spread java workload space 
close inspection compress reveals small code size processing fairly large amount data case input set 
profiling shows benchmark top methods called account method calls 
clearly compress small number hot methods smaller specjvm benchmarks 
leads small working set allows fairly aggressive optimizations virtual machine native code generator 
virtual machine implements run time optimizer different way result behavior quite different virtual machine 
note sun vm blackdown vm ibm vm yield quite similar behavior compress 
way visualizing dis similarity transformed space pca obtained cluster analysis ca 
dendrogram displayed graphically represents linkage distance ca 
dendrogram shown 
dendrogram data points connected small linkage distances clustered early iterations algorithm exhibit similar behavior 
case java workloads exhibiting similar behav ior connected small linkage distances 
visualization reduced space obtained pca see figures 
example clearly observe tight clusters virtual machine baseline jikes virtual machine ii adaptive jikes virtual machine iii jrockit virtual machine iv ibm virtual machine 
clearly observe sun blackdown vms loosely clustered 
addition kaffe virtual machine results tight cluster 
concerning compress observe java workloads linked large linkage distances tight cluster observed sun vm ibm vm blackdown vm running compress 
analysis input set input set retain principal components pca account observed variance measurements 
principal components account total variance respectively 
note components account variance variance explained principal components 
indicates data correlated 
factor loadings various characteristics 
principal component positive contributions mainly number retired instructions cycle number icache fetches branch prediction accuracy number cache accesses 
negative contributions come number fetch stalls dispatch stalls number cache misses number cache number requests memory seen bus 
second principal component positive contributions number fpu full stalls amount cache accesses number retired instructions cycle negative contributions branch prediction accuracy number cache misses 
third principal component single important positive contribution number branches 
negative contribution number return address stack ras overflows number lsu full stalls 
fourth component positively influenced number tlb misses number retired far control transfers 
negatively influenced number mispredicted indirect branches number mispredicted near returns number ras overflows 
fifth component positively dominated number instruction fetches memory negatively dominated number icu full stalls 
sixth retained principal component positively influenced number fetches cache number cache misses 
jess db javac jack compress blackdown sun blackdown mpegaudio mtrt sun kaffe jess db javac kaffe jack ibm jrockit compress kaffe mpegaudio mtrt jrockit jikes adaptive jikes adaptive jikes base compress jikes base dendrogram specjvm workload set obtained cluster analysis average pair group strategy 
compress sun blackdown jess jrockit jikes adaptive jess mtrt kaffe db mtrt sun blackdown ibm jikes adaptive javac jack sun blackdown ibm mtrt kaffe javac ibm jess sun blackdown jack db mpegaudio jikes base kaffe javac jack dendrogram specjvm workload set obtained cluster analysis average pair group strategy 
component negatively influenced mainly number retired taken branches number retired near returns number ras hits 
reduced dimensional space obtained pca significantly smaller original dimensional space displaying dimensional space understandable way impractical impossible 
display dendrogram obtained ca java workload space function principal components 
dendrogram shown 
interesting observation clusters formed input set compare 
clusters formed necessarily formed virtual machines case input set 
input set observe benchmark clusters benchmark run different vms small impact vm behavior virtual machine clusters virtual machine running different java applications large impact vm behavior 
observe tight benchmark clusters cluster corresponding compress ii cluster corresponding mpegaudio iii cluster corresponding db 
clusters contain virtual machines baseline version jikes 
cluster db contains virtual machines kaffe baseline version jikes 
interestingly shuf labeled specjvm benchmarks simple benchmarks 
fact virtual machines running simple benchmarks result clustered data points probably surprisingly due fact virtual machines optimized simple benchmarks nearly native code long running time benchmarks 
note contrast widespread behavior compress input input results tight cluster 
addition benchmark clusters observe tight virtual machine clusters iv baseline version jikes virtual machine jrockit virtual machine 
cluster baseline jikes vm contains specjvm benchmarks 
fact various java programs run baseline jikes exhibit similar behavior explained follows 
baseline configuration jikes compiles method just time number dynamic optimizations performed limited 
expect code sequences generated different java programs yielding similar behavior 
cluster jrockit contains specjvm benchmarks compress db mpegaudio 
interestingly benchmarks part benchmark clusters ii iii 
close inspection results observed sun vm blackdown vm yield similar behavior 
note contrast results true benchmark basis 
java grande forum java grande forum benchmark suite includes benchmarks having problem sizes see table retain principal components pca 
principal components explain total variance 
dendrogram obtained cluster anal ysis dimensional space shown 
conclude java workloads associated kaffe java workloads associated baseline configuration jikes form tight clusters respectively ii tight cluster observed search virtual machines running search cluster kaffe baseline version jikes iii sun vm blackdown vm show similar behavior benchmark virtual machines close euler benchmark iv small large problem sizes generally yield behavior 
java workloads analysis discussed section java workloads included varying virtual machine java application input sets 
virtual machine configurations mentioned table added server mode sun vm server mode blackdown vm 
results principal components analysis retain principal components accounting total variance 
dendrogram obtained cluster analysis done dimensional space shown 
interesting observations 
number virtual machine clusters observed contain various java applications virtual machine ibm vm running raja benchmark ii jikes baseline configuration iii kaffe running java grande forum benchmarks specjvm benchmarks input set iv adaptive configuration jikes minor clusters jrockit ibm vm 
note sun vm blackdown vm form single cluster raja benchmark specjbb indicating strong similarities behavior virtual machines benchmarks 
specjbb client server modes sun blackdown virtual machines quite close global picture linkage distance smaller observe clear distinction 
addition noticed specjbb server mode blackdown vm shows similarities ibm vm server mode sun vm 
second observe number benchmark clusters containing various virtual machines running java benchmark java grande forum benchmarks search euler raytracer specjvm compress specjvm db input specjbb 
third observe clusters formed specjvm benchmarks input set showing workloads exhibit dissimilar behavior java workloads 
results interpreted researchers object oriented programming community depends research goals 
virtual machine developers benchmarking virtual machine select sun blackdown euler large ibm euler large small ibm sun blackdown jikes adaptive jrockit search small large jikes base search euler small large jikes base raytrace jrockit ibm sun blackdown raytrace large small jikes adaptive kaffe ibm raytrace small jrockit small jrockit search small dendrogram java grande forum benchmarks obtained cluster analysis average pair group strategy 
specjbb sun blackdown server client ibm ibm specjvm single search small large db jrockit compress jess javac jrockit specjvm specjvm jrockit jikes adaptive mpegaudio raja sun blackdown client compress raja ibm kaffe raytracer small large euler jrockit jikes adaptive jikes base jikes base specjvm specjvm jikes adaptive euler dendrogram java workloads obtained cluster analysis average pair group strategy 
compress jess javac mtrt jack db mpegaudio javac parallel gc jack parallel gc linkage distance measuring impact garbage collector java workload behavior 
number benchmarks cover sufficiently large behavioral spectrum virtual machine 
collection benchmarks different different virtual machines 
example jrockit recommend specjbb compress mpegaudio jack javac db benchmarks 
baseline configuration jikes hand recommend specjvm benchmarks benchmark 
java application developers benchmarking java program recommended sufficiently large number virtual machines 
results suggest waste effort consider sun vm blackdown vm 
comments garbage collector noted section choice garbage collector consistent different virtual machine configurations different garbage collectors 
due fact chosen default garbage collector virtual machine 
quantify impact choice garbage collector results set experiment 
considered specjvm benchmarks input set various virtual machine configurations table 
jrockit vm considered additional garbage collectors generational copying garbage collector single spaced concurrent generational concurrent parallel garbage collection 
dendrogram obtained pca ca shown 
jrockit garbage collectors highlighted specjvm benchmark 
graph shows benchmarks various garbage collectors tightly clustered parallel garbage collector javac jack 
conclude choice garbage collector minor influence 

related section discusses related understanding characterizing java workloads 
bowers characterize specjvm benchmarks bytecode level 
conclude java applications large number loads dynamic bytecode stream 
hsieh compare performance sun jdk java interpreter bytecode native code translator called caffeine compiled version code 
done simulations 
conclude interpreter exhibits poor branch target buffer btb performance poor cache behavior poor cache behavior compared approaches 
chow compare java workloads non java workloads spec cpu spec cint principal components analysis 
study authors focus branch behavior number conditional jumps direct calls indirect calls indirect jumps returns simulation results conclude java workloads appear indirect branches non java workloads 
number indirect branch targets small 
considering number indirect target changes java workloads worse spec cint benchmarks 
study different done chow reasons 
chow large number workloads number virtual machines study limited 
second chow limit study branching characteristics java workloads 
third goal chow compare java workloads versus non java workloads different goal getting insight interaction vms java programs inputs 
radhakrishnan analyze behavior specjvm benchmarks instrumenting virtual machines simulating execution traces 
virtual machines sun jdk kaffe 
conclude bytecodes constitute dynamic bytecode stream ii oracle translation scheme optimal translation selection case jit compiler improve performance iii cache cache performance better java applications applications cache jit mode iv write misses due installing jit compiler output significant impact cache performance jit mode amount ilp higher jit mode interpreter mode 
li characterize behavior specjvm java benchmarks complete system simulation 
done sun jdk virtual machine simos complete system simulator 
conclude specjvm applications spend average time system kernel activity compared spec cint benchmarks studied 
generally amount time kernel activity higher jit compiler mode interpreter mode 
kernel activity mainly due tlb handler invocations 
conclude specjvm benchmarks inherently poor instruction level parallelism ilp com pared classes benchmarks 
li analyze impact kernel activity branch behavior java workloads 
conclude branches os code exhibit different biased behavior increases branch misprediction rate significantly 
propose os aware branch prediction schemes outperform conventional branch predictors 
shuf characterize memory behavior java workloads 
conclude specjvm benchmarks truly object oriented representative real java workloads 
propose server oriented pbob benchmark studies java workloads addition specjvm benchmarks 
experiments specjbb benchmark suite pbob 
results confirm behavior observed specjbb dissimilar specjvm 
secondly conclude number hot spots small java programs 
consequently expensive algorithms justified run time optimizations 
third conclude cache behavior java workloads poor resulting high cache rates fairly large caches increase performance significantly 
addition conclude tlb cache behavior worse java workloads technical benchmarks comparable commercial workloads 

studied behavior java workload seen microarchitectural level due virtual machine java application input java application 
words addressed question behavior java workload primarily determined virtual machine java application input 
experimental setup virtual machine configurations collection java benchmarks taken specjvm varying input sets specjbb java grande forum open source raytracer called raja large number scene descriptions 
workloads number performance characteristics measured hardware performance counters amd microprocessor 
large amount data subsequently analyzed statistical data analysis techniques principal components analysis cluster analysis 
data reduction techniques gave excellent opportunity answer questions raised 
conclude input set specjvm behavior observed microarchitectural level mainly determined virtual machine 
due fact input set leads short running benchmarks 
causes startup virtual machine largest contributor behavior 
suggests input set java system performance analysis practice mainly interested measuring startup time results obtained analysis highly biased virtual machine 
short running input set representative long running input set specjvm clearly practice behavior observed microarchitectural level quite different input sets 
reason obviously fact virtual machine opportunities run time optimizations long running benchmarks short running benchmarks 
java grande forum benchmark suite hand problem size minor impact behavior cases 
smallest problem size confidence 
specjvm input set virtual machine clusters observed containing various virtual machines running java program benchmark clusters containing various java benchmarks running virtual machine 
implies virtual machine clusters impact java application higher impact virtual machine 
interestingly virtual machine clusters observed previously reported simple benchmarks compress db mpegaudio 
benchmark clusters impact virtual machine higher impact java program 
example benchmark cluster baseline configuration jikes virtual machine 
specjbb benchmark run aggressive runtime optimizing virtual machines observe behavior dissimilar java workloads 
including server oriented java workload important obtain representative java workload 
general researchers careful reporting results virtual machines 
results clearly show behavior observed microarchitectural level highly dependent virtual machine 
results obtained virtual machine applicable virtual machine vice versa 
want emphasize importance results object oriented programming community 
clearly showed selection representative java workloads done scientific arguments 
principal components analysis cluster analysis provide researchers valuable information reason quality java workloads reliable way 
allow draw studies confidence 
postdoctoral fellow fund scientific research flanders belgium 
andy georges supported project sponsored flemish institute promotion scientific technological research industry iwt 
authors anonymous reviewers valuable comments 

advanced micro devices amd athlon processor code optimization guide february 
www amd com 
alpern attanasio barton burke cheng 
choi cocchi fink grove hind hummel lieber litvinov mergen ngo russell sarkar serrano shepherd smith sreedhar srinivasan whaley 
jalape virtual machine 
ibm systems journal february 
arnold grove hind sweeney 
adaptive optimization jalape jvm 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla pages october 
austin larson ernst 
simplescalar infrastructure computer system modeling 
ieee computer february 
fink arora 
java server benchmarks 
ibm systems journal february 
bea systems bea weblogic jrockit server jvm increasing server side performance manageability august 
www bea com products weblogic jrockit 
bose 
performance evaluation validation microprocessors 
proceedings international conference measurement modeling computer systems sigmetrics pages may 
bowers 
characterizing specjvm benchmarks java virtual machine 
technical report ece northeastern university department electrical computer engineering september 
bull smith davey 
benchmark suite high performance java 
concurrency practice experience may 
chow wright lai 
characterization java workloads principal components analysis indirect branches 
proceedings workshop workload characterization held conjunction st annual acm ieee international symposium microarchitecture micro pages november 
burger 
measuring experimental error microprocessor simulation 
proceedings th annual international symposium computer architecture isca pages july 

challenges intel 
microprocessor report october 
de 
designing workloads computer architecture research 
ieee computer february 
de 
quantifying impact input data sets program behavior applications 
journal instruction level parallelism february 
www org vol 
hsieh conte johnson gyllenhaal hwu 
study cache branch performance issues running java current hardware platforms 
proceedings compcon pages february 
hsieh gyllenhaal hwu 
java bytecode native code translation caffeine prototype preliminary results 
proceedings th international symposium microarchitecture micro pages december 
johnson 
applied multivariate statistical analysis 
prentice hall fifth edition 
li john vijaykrishnan rubio 
understanding improving operating system effects control flow prediction 
proceedings tenth international conference architectural support programming languages operating systems asplos pages october 
li john vijaykrishnan murthy 
complete system simulation characterize specjvm benchmarks 
proceedings th international conference supercomputing ics pages may 
radhakrishnan vijaykrishnan john 
architectural issues java runtime systems 
proceedings sixth international symposium high performance computer architecture hpca pages january 
radhakrishnan vijaykrishnan john rubio 
java runtime systems characterization architectural implications 
ieee transactions computers february 
rosenblum bugnion devine herrod 
simos machine simulator study complex computer systems 
acm transactions modeling computer simulation january 
shuf serrano gupta singh 
characterizing memory behavior java workloads structured view opportunities optimizations 
proceedings acm sigmetrics international conference measurement modeling computer systems pages 
acm press june 
statistica windows 
computer program manual 

www com 
takeuchi komatsu nakatani 
overview ibm java just time compiler 
ibm systems journal february 
sun microsystems java hotspot virtual machine september 
