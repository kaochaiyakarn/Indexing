copyright murthy dissertation committee murthy certifies approved version dissertation hdl slicing verification test committee jacob abraham supervisor tony ambler adnan aziz craig chase hdl slicing verification test murthy tech dissertation faculty graduate school university texas austin partial fulfillment requirements degree doctor philosophy university texas austin may dedicated parents foremost teachers acknowledgments possible ideas insights support sacrifices individuals 
borrowing line song composed saint composer van meaning noble people world 
express deepest gratitude thesis advisor prof abraham invaluable guidance encouragement 
novel ideas deep understanding research guiding force 
am deeply indebted helping change major computer engineering providing financial support stay university 
ma jor motivating factor research insistence development methodology theory tools applied problems real world 
am thankful committee members constructive criticism suggestions steering course completion dissertation 
committee chairman prof ambler instrumental helping understand goals expectations committee 
prof chase pointed related research software led develop theoretical basis 
prof aziz class formal verification interest subject deeply appreciate willingness discuss research offering insightful comments 
dr laid foundation significant portion helping understand develop ideas 
offer special people supported personally professionally 
wife love constant agement helped tide difficult phases research 
taken special interest understanding research provided vital technical feedback key ideas 
person close friend randy helped right graduate studies 
guided step changing major computer engineering needed help course research 
technical publications seen light day help proof reading technical writing times moment notice 
owe lot special people 
wish acknowledge technical help received people various stages dissertation motorola flemming andersen colleagues strategic cad labs intel jeff russell arun university texas austin prof daniel saab case western reserve university jason baumgartner ibm 
fortunate stimulating discussions current colleagues ut victor satish kamal suresh ravi ramesh krishna bala soo whitney adam 
special proof reading parts dissertation 
am grateful financial support extended funding vi agencies semiconductor research state texas advanced technol ogy program intel national semiconductor ibm 
am thankful linda shirley ruth andrew administrative support making life wonderful experience 
helped prof roth prof melanie prof gray ut settle early years graduate studies 
probably lost sanity friends especially rio gang stay austin brought stressful times studies 
words express gratitude family members immensely responsible success 
constant love encourage ment integral part life 
wish teachers various schools colleges attended india thoughts making want learn 
university texas austin may murthy vii hdl slicing verification test publication 
murthy ph university texas austin supervisor jacob abraham semiconductor industry increasingly relying computer aided de sign cad tools order meet demand high performance gent time market requirements 
practical application state art cad tools severely limited sheer size design sizes 
appropriate methodology exploits inherent modular structure complex designs desired 
dissertation proposes methodology useful variety cad tools design verification manufacturing test generation 
functional test generation sequential automatic test pattern generation atpg tools extremely computation intensive produces acceptable results relatively small designs 
hierarchical approaches necessary reduce atpg complexity 
promising approach previously proposed individual modules design targeted time ad hoc abstraction reminder design derived register transfer level viii rtl model 
approach elegant systematic approach program slicing allows scalable large designs developed 
theoretical basis applying program slicing hardware description lan guages hdls established tool called factor implemented automate approach test generation testability analysis 
design verification requires exploring complete design space ensure correctness design 
proof contradiction approach called bounded model checking bmc proposed utilizes satisfiability sat capa bilities find counterexamples temporal properties specified number time steps 
proposed scheme harnesses power sequential atpg tools structural information hardware design perform bmc efficiently 
approach augmented hdl slicing methodology test generation accelerate verification methodology 
symbolic simulation uses symbols actual values simulating hardware design responses class values computed checked correctness single run 
effectiveness approach incorporated powerful verification methodology called symbolic trajectory evaluation ste verify properties bounded state sequences intermixed properties invariant behavior 
assertions described limited form tem logic symbolically validated design verification 
hdl slicing tool factor appropriately applied speed cation floating point adder unit pentium design intel forte verification framework 
ix contents acknowledgments viii list tables xiii list figures xiv chapter manufacturing test generation 
design verification 
bounded model checking 
symbolic trajectory evaluation 
organization dissertation 
chapter hdl slicing basic definitions 
hdl slicing 
taming design complexity 
hierarchical slicing 
cone influence reduction 
chapter test generation slicing piers 
factor 
complexity analysis 
experimental results 
chapter fundamentals bounded property checking model checking 
bounded model checking 
symbolic trajectory evaluation 
trajectory formulas 
assertions 
chapter atpg property checking proposed approach 
property monitors 
results 
selecting bounds 
sat versus atpg engines 
chapter design verification slicing unbounded liveness 
results analysis 
symbolic trajectory evaluation 
forte verification framework 
xi verification methodology 
results 
chapter concluding remarks bibliography vita xii list tables modules arm 
test generation original design 
slicing synthesis times 
test generation raw slicing 
test generation hierarchical slicing piers 
test generation hierarchical slicing piers 
checking ef property outputs bound 
checking property outputs various bounds benchmark characteristics 
bounded property checking hdl slicing 
cpu times ste hdl slicing 
xiii list figures motivation hierarchical test generation 
basic approach complexity reduction 
construction transitive fan cone 
snapshot design hierarchy 
original design 
sliced design 
internal data structure 
reduction surrounding logic 
illustration ctl formulas 
property verification approach atpg 
monitor 
monitor 
sequential circuit ila model 
monitor 
simplified state transition graph viper control 
peak bdd sizes case table 
xiv chapter current advances integrated circuit ic manufacturing technology allow design ers incorporate large amounts functionality single die 
resulting increases design complexity demand shorter design cycles necessitated various levels abstraction design evolving specification final physical design 
hardware description lan guages hdls verilog vhdl developed represent design way computer aided design cad tools manipulate analyze order produce desired chip 
success failure chip depends heavily quality vali dation effort invested design process 
effort commonly performed level abstraction appropriate cad tools methodologies 
design verification refers validating high level abstraction design hdl program respect specification manufacturing test generation refers generating test patterns high level abstraction check manufacturing defects constitute significant portions validation effort 
existing cad tools automate tasks scale poorly increasing complexity sizes current designs 
appropriate methodologies exploit modular structure inherently large designs needed 
manufacturing test generation generating effective manufacturing tests poses severe challenge transistor density increases due reduced accessibility various parts chip 
daunting task exacerbated increasing sequential elements implementing deeply pipelined stages modern day processors 
test generation complexity grows exponentially respect number se elements 
result test coverage measure test quality severely affected 
automatic test pattern generation atpg techniques ineffective complete designs expensive testability features partition design incorporated 
example scan approaches incorporate additional circuitry allow sequential elements chip level inputs outputs 
similar techniques built self test bist require extra hardware circuitry generates test patterns chip determines correctness signature analysis test responses 
design testability dft techniques alleviate test genera tion problem significant impact performance area chip 
state art vlsi designs implemented deep sub micron tech functional testing continues widely accepted method detecting manufacturing defects 
functional tests applied speed detect commonly prevalent defects opens shorts delays deep sub micron technologies 
generating functional tests manually te 
sequential atpg tools may generate tests sized description design hdl complete design large complex tools handle 
complexity sequential atpg order initial state known increases initial state unknown number sequential elements design 
inherent hierarchy hdl design may exploited reduce com plexity sequential atpg 
illustrates motivation develop func tional test generation techniques module embedded relatively large design 
targeting individual module result significantly higher fault coverage tool complete access inputs outputs module 
test generation time fraction neces sary patterns generated rest design place 
due constraints imposed inputs outputs remainder de sign patterns generated translated chip level resulting heavy loss fault coverage 
translation pat terns involves exhaustive reasoning behavior surrounding logic reverts complexity full chip test generation 
suitable tech nique derive test patterns module test mut valid processor level possessing test coverage test generation time comparable stand module desired 
variety strategies suggested generate test patterns modules design extracting behavior surrounding logic 
test generation methodology test procedures pattern restrictions described 
lee patel proposed solution custom atpg packages full chip level justification prop test generation module level 
thomas suggested synthesis approach functional constraints extracted synthesis process guide custom atpg tool 
developed tool called extract functional constraints vhdl register transfer level rtl design custom test generation tool obtain test patterns 
similar suggested approaches extraction useful test generation knowledge hdl descriptions require custom atpg packages synthesis complete designs 
test quality full chip test generation time full chip motivation hierarchical test generation suggested hierarchical abstraction technique module design hierarchy targeted time 
logic surrounding module extracted synthesized gate level 
synthesized con straints provided commercial atpg tool generate test patterns mut 
approach shown promising results generating high quality tests reasonable amount time 
larger designs submodules may prove complex atpg tool technique may directly applicable 
imperative target modules lower levels hierarchy surrounding logic may prove complex abstraction 
design verification estimated design effort design cation percentage expected increase 
conse quences ignoring phase design process may result faulty designs causing huge market losses industry 
existing verification tools methodologies unable scale increasing design complex ities 
functional simulation design validation tests main technique industry verify large designs owing simplicity scalability 
unfortunately designs larger likelihood tests uncover subtle bugs smaller 
exhaustive simulation possible input sequences impractical 
simulation expected remain key technique validating complex designs considerable interest formal meth ods complementary approach examining cases cov ered simulation 
techniques incorporate unambiguous specification design mathematical reasoning systematically explore possi ble ways establish design correctness 
entire design space searched implicitly order establish definitive correctness existing formal approaches applicable small portions design 
automation methods requires finite state machine system represented binary decision diagrams bdds de cision diagram variations 
bdd sizes extremely sensitive variable ordering circuits adders multipliers achieve exponential complexity 
formal techniques wide application establish ing equivalence rtl logic level 
state art commercial tools require correspondence state elements rtl description logic level description essentially dealing combinational equivalence problem 
difficult problem establishing equiv boolean functions np complete heuristics combination different techniques including bdds atpg satisfiability sat solvers allow industry tools formally verify boolean equivalence combinational blocks commercial designs 
check correctness rtl approaches theo rem proving model checking symbolic trajectory evaluation proposed 
approach tradeoff expressiveness capacity 
theorem proving techniques attempt show exists formal proof correctness formulas characterizing design 
generic ap proach generating proof automatically difficult theorem provers mainly check proofs generated manually 
result approach lacks level automation required useful practice 
model checking uses state transition graph stg represent digital system specify properties temporal logic formulas 
prop erties validated traversing stg powerful algorithmic search strate gies 
stg easily extracted hdl traversed automatically property specification performed relative ease 
factors model checking viable approach existing tools gies property checking bdds form represent stg quickly reaching existing computational limits 
bounded model checking practice automated formal method applied reveal presence bugs provide proof correctness 
observation biere introduced symbolic model checking technique called bounded model checking bmc searches counterexamples maximal length bound temporal properties system described linear temporal logic ltl 
approach involves generating solving bility propositional decision procedures bdds 
proven diameter state transition diagram design larger maximum bound time steps bmc complete proving unreachability target 
benefits approach demonstrated real designs taken intel pentium processor contain ing state variables 
structural algorithms computing bound diameter stg proposed guarantee completeness bounded property check 
sat solvers operate boolean expressions suffer po space explosion problem bdd methods cal representations 
sat techniques successfully applied various domains 
sat bmc usually requires explicit unrolling circuits perform depth search find satisfying variable assignment 
result sat clauses large tedious solve 
checking safety properties shown atpg techniques may able overcome limitations 
approaches atpg shown perform efficient state space search building representations stg 
symbolic trajectory evaluation verification conventional simulation requires tedious analysis pos sible input states sequences analysis responses 
order overcome limitation symbolic simulation uses boolean variables input values introduced 
resulting responses boolean functions capture behavior circuit entire class input values 
boolean functions represented bdds efficient comparison sim ulation results correctness possible canonicity representa tion 
symbolic simulation techniques seger bryant pro posed efficient lattice model checking approach called symbolic tory evaluation ste 
approach improved symbolic simulator ver ify correctness circuit behavior described trajectory assertions 
derived restricted subset temporal logic bounded length state sequences 
efficient quaternary circuit model enhanced capability symbolic manipulation rendered technique attractive verifying industrial strength designs companies intel motorola ibm 
serious drawback approach restricted expressiveness temporal assertions 
property extends infinitely long state sequence expressed ste 
yang seger proposed generalized ste methodology express verify richer set properties shows great promise verifying larger wider class designs 
underlying bdd representations quickly grow size require tedious application incremental methodologies 
organization dissertation chapter describes development elegant technique easing complexity hdl programs easier analysis cad tools 
theoretical basis program slicing hardware programs established adapting key definitions software engineering 
formal semantics hdl slicing sequential atpg tools established prove sound ness completeness technique 
followed discussion related technique called cone influence reduction coi relevance slicing methodology 
chapter explains test generation approach hdl slicing 
presentation methodology tool developed automate approach followed experimental results verilog benchmarks tool 
chapter introduces basic ideas model checking verifying correctness designs 
sat bounded model checking approach check properties bounded intervals time described motivate development better atpg approach 
followed details symbolic tory evaluation powerful technique check bounded property assertions 
chapter presents novel methodology applying sequential atpg property checking 
monitor state machines developed sequential atpg engines described supporting results generated benchmark circuits 
chapter describes application hdl slicing atpg prop erty checking methodology ste verification forte framework intel 
dissertation concludes chapter final remarks possi ble cad applications may benefit abstraction methods similar described 
chapter hdl slicing program slicing originally proposed weiser static program analysis technique extract appropriate portions programs relevant application 
portions referred slices artifacts maintain exact information program behavior projected relevant seg ments original program 
technique potentially removes large quantities extraneous code original program maintaining functional equiv respect aspect analysis 
technique widely studied applied myriad applications software engineering de testing maintenance reuse 
software debugging example involves tracing back statement generates incorrect re sult 
procedure may perceived computing examining slice program respect variables associated statement order identify statement statements causing erroneous evaluation 
automated approach derive desired slice asset software development environment 
source source transformation technique offers opportunity formulate methodical approach simplify design described hdl test generation having synthesize prohibitively large design 
algorithms developed sequential languages directly applied hdls verilog vhdl allow concurrent con structs 
static slicing concurrent software programs adapted hdls 
suggested approach program slicing ana vhdl designs reduction obtained set benchmarks outputs slicing criterion 
automated program slicing approach vhdl proposed clarke vhdl constructs mapped constructs procedural languages :10.1.1.31.914
primary focus reduce reachable state space formal property tion 
previous contributions suggested potential applications simulation functional testing regression testing testability analysis design modification maintenance supporting experimental results 
related approaches data flow analysis propagate test pat terns mut perform accessibility analysis improve dft improve testability propagation value ranges variables 
techniques directly applied commercial tools test generation verification operate gate level descriptions designs 
systematic approach strong theoretical basis program slicing hdl programs necessary apply technique practical 
basic definitions section consists key definitions elements constitute pro gram dependence graph earlier program slicing 
definitions provide foundation slicing hdl programs control flow def graphs 
definition digraph structure set nodes set edges 
definition edge said predecessor said successor pred succ set predecessors successors node respectively 
definition indegree node denoted number pre outdegree node denoted number successors definition flowgraph structure di graph 
definition hammock graph structure flowgraphs definition control flow graph cfg hammock graph inter program procedure 
nodes cfg represent simple statements assignments branch loop conditions edges represent control flow transfer state ments 
discussion represents set nodes graph definition def graph structure set variables procedure functions mapping nodes set variables defined statements corresponding nodes respectively 
definition node definition set set variables left part assignment operator statement defined usage set set variables right part assignment operator statement definition slicing criterion pair procedure statement subset variables 
slicing criterion set statements said affect directly transitively values computes subset similarly said affected directly transitively values subset defined computes variables definition slice procedure slicing criterion exe subset containing statements may affect may affected values slices may classified ways static dynamic forward backward closure executable 
static slice contains statements may relevant computation dynamic slice extracts statements relevant computation specific set inputs outputs 
forward slice set statements values may affected values backward slice set statements may affect values closure slice relates variable interest closure dependencies necessarily syntactically valid program 
executable slice hand reduced program preserves behavior original program respect slicing criterion 
definition set variables immediately relevant slicing criterion denoted defined superscript indicates set variables directly relevant 
subset base case second marks variables assign values relevant variables relevant 
third subset removes relevant variable immediately relevant variables 
definition set statements included slice defined denoted set allow execution statements statement set denoted mt introduced 
set statement set control statements regulate execution defined follows 
include control flow branch statements definition set control statements dominate execution state ments denoted hdl slicing defined typical design described hdl non halting program commu processes execute concurrently 
processes communicate signals shared processes 
definitions slicing procedures software programs may directly extended hdl process 
procedures software program process called explicitly activated appropriate changes signal values sensitivity list process 
changes may triggered processes executing concurrently 
software programs explicit procedure call statements activate procedure definition dependence process sig nal definition process es potentially activate process execution 
incorporate inter process communication notion signal dependency introduced 
definitions process region denotes executable subset statements process 
definition process region said signal dependent statement assigns value signal sensitive 
set definitions deals inter process communication 
definitions explained respect commonly synthesizable subset verilog semantics precludes constructs including functions tasks forks delay control statements non blocking assignments 
definition inter process control flow graph module structure processes module signal dependencies processes 
control flow graphs rep set edges representing definition inter process def graph module structure set signals module functions mapping nodes set signals defined statements corresponding nodes 
definitions hold concurrent statements continuous assignments considered single line unique processes 
definition inter process slice module criterion executable subset obtained recursively containing statements may affect may affected values process defined slices slicing criterion set statements defining set signals process dependent 
definitions form basis applying slicing techniques ing verilog designs hdl chosen implementation 
pro posed methodology derives static slice executable consists forward backward slices 
taming design complexity digital system described verilog hierarchical composition mod ules composed processes 
consider verilog pro gram process program composition operator :10.1.1.31.914
division processes modules may integers exploited existing cad tools employing divide conquer approach 
basic approach illustrated 
necessary definitions explain prove methodology derived section 
ms constraint slicing basic approach complexity reduction integer sub module design represented rest design represented definition constraint slicing criterion surrounding logic encompasses pair set input output signals ments set input output nodes representing declarative state definition constraint slice slice obtained slice criterion con executable subset containing statements strain values declared set processes represented set input constraints obtained backward slicing input signals output constraints obtained forward slicing output signals 
combined set constraint slices represent behavior visible analyze module reduced surrounding logic may synthesized gate level test generation verification 
integer constraint slice built recursively equations 
iterative steps terminate primary inputs outputs reached new statements signals included 
definition termination condition tc defined iteration step lemma distributivity constraint slice slicing criterion set verilog signals statement dis proof consider iterative step signal integer obtain overlap slice signal equations union step computes slice may slices contains statements signals computed results slice obtained union signals statement lemma shows constraint slice inputs outputs mod ule built composing slices obtained separately input output 
lemma shows generated slice correctly encompasses constraints imposed inputs outputs mut original design 
lemma correctness constraint slice obtained re spect slicing criterion process trace sequence relevant signals surrounding logic simulation cycle process traces identical respect signals defined proof integer 
definitions equations proof mathematical induction 
basis 
base set includes immediately relevant signals potential effects def chain sub slice represented values subset includes hypothesis assume sub slice defined equa tions computes identical subset trace produced induction step 
part iterative step compute rives statements relevance def chain sub slice hypothesis second part de captures dependencies signals sures computation identical subset trace produced sub slice step iteration represented en lemma establishes accuracy methodology providing accu rate constraint slice inputs outputs mut 
theorem proves reduced model retains transitive fan transitive fan cones chip level inputs outputs faulty signal mut 
cones traditionally defined respect signals gate level description needed justification propagation signal assignments atpg 
rt level gates correspond statements signals lie slice particular signal statement 
transitive fan cone tfi signal set statements signals design transitively drive signal 
similarly transitive fan cone signal set statements signals design transitively driven signal 
theorem consistency atpg algorithm generate valid set test patterns faults mut constraint slice 
proof referring consider faulty signal mut atpg algorithm require signals statements justification propagation preserved 
sf construction transitive fan cone justification tfi subset union parts signals statements transitively affect represented affect inputs originating signals statements transitively part implicitly included set processes part slicing criterion originating inputs program tfi input represented set signals statements transitively affect defi nition shows contained executable subset set processes defined includes tfi sufficient signal justification 
propagation proof follows similar reasoning shown justification 
addition represented propagation requires set signals signals statements need justified primary inputs 
set justifying signals subset union parts signals set signals part contained including set shown proof justification 
equation recursively includes signals tfi shown defini tion 
equations recursively include relevant statements tfi compute statements including signals computed equation 
necessary propagation paths faulty signal constraint slice 
hierarchical slicing included application methodology may tedious large designs multiple levels hierarchy 
cases mut effectively handled atpg tool may embedded levels hierarchy sur rounding logic may big extract constraint slice directly 
solution problem perform slicing hierarchically module level hierarchy 
hierarchical slices composed obtain complete constraint slice 
referring processes environment com posed subsets representing surrounding logic snapshot design hierarchy level hierarchy obtained composing mut subset processes surround module level hierarchy ing logic contained represented slice subset module represented theorem composition composition constraint slices level hierarchy yields desired constraint slice proof integer 
basis trivial case constraint directly obtained defined hypothesis assume hierarchical slices composed hierarchy contained desired constraint slice induction 
slicing criterion constraint slice pair obtained recursively equations defined reduces desired constraint slice composed hierarchy 
composing slice obtained additional benefit slices higher levels hierarchy may reused extracting constraint slices modules formed subset pro cesses say level hierarchy say 
sufficient derive constraint slice module compose slices processes constraint extraction time reduced methodology scales large designs 
cone influence reduction closely related technique hdl slicing approach cone influence coi re duction differ respects 
primary idea coi construct dependence graph program traverse starting vari ables specification 
dependence graph usually represented vector transition functions generated symbolic encoding system bdds 
set state variables reached necessary transition relations tween traversal form coi variables specification 
may viewed post encoding slicing 
designs grow size generation transition relation description language bottleneck 
approach localized reduction complexity specific site gate level description 
pre encoding slicing techniques needed reduce complexity large designs cad tasks 
hdl slicing operates hdl source code directly uses infor mation language semantics case loops generate relevant subset program 
coi reduction viewed special case slicing assignment statement language con struct 
hdl slicing applied rt level handle complete designs 
proposed scheme performs slicing mut interface individual fault sites gate level descriptions 
added advantage synthesis tool need generate gate level netlist rele vant sliced design chip 
disadvantage hdl slicing specific language 
clarke discussed differences detail respect model checking :10.1.1.31.914
proposed slic ing methodology complements existing post encoding reduction techniques coi state art commercial cad tools design verification test generation 
chapter test generation slicing functional test generation sequential atpg tools extremely computation intensive full chip designs 
necessary adopt divide conquer strategy generating high quality test patterns reasonable amount time 
strategy may realized exploiting hierarchical structure inherently prevalent current designs 
naive approach targeting faults individual modules necessitate cumbersome translation patterns chip level 
addition tests faults mut may impossible apply chip level searching alternate tests faults comparable generating tests complete design 
scalable systematic methodology hierarchically generate effective test patterns desired 
chapter describes proposed test generation methodology rtl model full chip design derive atpg view mut synthesizable form 
illustration simple rtl example shown corresponding gate level structure 
module chosen mut 
module definitions corresponding gate level descriptions provided necessary illustrating approach 
clk rst rtl example original design original design module top clk reset input clk reset input output wire clk reset clk reset clk reset module clk reset input clk reset input output reg wire assign assign clk reset clk reset clk reset test generation targeting faults mut requires relevant surrounding logic 
rest logic removed methodically rtl design program slicing methodology described sections chapter 
sliced rtl synthesized provide gate level atpg view shown corresponding rtl description 
clk rst sliced design rtl example constraint slice module top clk reset input clk reset input output clk reset module clk reset input clk reset input output reg wire assign clk reset clk reset commercial sequential atpg tool generate desired test pat terns targeting faults 
test generation faults module sliced design faster targeting faults original design sliced design simpler 
tests generated slice directly mapped original design entire environment captured slice 
rest chapter describes process generating slices provides theoretical proofs experimental evidence soundness completeness approach 
piers constraint slice may reduced set directly accessible internal registers called piers primary input output accessible registers 
registers read written load store instructions identified priori treated pseudo primary inputs outputs design constraint slicing 
iterative equations derived chapter terminate earlier pier applicable 
results faster slicing results smaller slice reducing sequential depth test generation process 
instructions load unload piers translate patterns chip level 
generating tests piers performed conventional techniques 
piers implemented register file tradi tional memory test algorithms march sufficient 
piers implemented random locations functional testing method proposed abraham effective 
approach assigns unique code registers ensuring conflict generated patterns 
factor methodology described section implementation fac tor functional constraint extractor 
tool automatically derives con straint slices modules verilog program 
implemented perl rough verilog parser 
parser supports register transfer rt gate level verilog constructs 
parse tree supporting internal data structure suitably modified incorporate def chains def chains signal order calculate slices efficiently 
chains contain statements signal definition signal usage defined respectively 
statement program traversal 
statement controlling statement case added existing parse tree 
new node initialized statement stored 

current statement added def chain params assigns signals nets instances inst def def module statement library primitive ports internal data structure case lhs assignment operator signal def chains rhs assignment operator signal respectively 
algorithm explained notation introduced defined previous chapter 
statement module associated set signal statement associated immediately relevant statements constitute def def chains statements program 
data structure constructed parser shown 
note leaf nodes connectivity tree verilog statements library primitives 
slices hierarchically derived signal executable sub set surrounding logic produced 
signal process input signal mut recursive subroutine find bck slice called output signal recursive subroutine find fwd slice called 
function maps pair set pairs signal represents immediately relevant signal corresponding process set pairs defined 
function maps pair signal corresponding process 
skeleton algorithms recursive subroutines 
signal represents immediately relevant compute backward constraint slice find bck slice compute search save signal find save find bck slice signal find bck slice rhs signals compute forward constraint slice find fwd slice compute search save control signals signal find save find bck slice signal find fwd slice rhs signals lhs signals signal find bck slice control signals backward slices obtained input signals mut composed provide input constraint slice defines justification paths inputs mut 
similarly forward slices obtained output signals mut composed provide output constraint slice defines propa gation paths 
piers design identified manually provided tool pseudo primary inputs outputs 
computation slices termi primary inputs outputs case may encountered 
slicing preserves necessary statements signals necessary hdl analysis forward slice thorough case constructs may remove irrelevant branches 
branches happen default branch taken slicing may introduce asynchronous latches synthesis potentially produce errors test generation 
cases default statement generated assigns dont care value signal assigned branch 
constraint slicing tool provides trace signals aborted path 
information provides valuable early insight testability design designer choose suitable tions remove testability bottlenecks 
complexity analysis complexity factor algorithm lies building data structure calculating backward forward slices 
total number statements program signals build data structure space complexity worst case def def chains signal consist statements program resulting complexity 
similar argument complexity build mt set statement time complexity def chain lhs signal adds statement 
worst case complexity statement rhs signals need examined add statement respective def chains resulting mt set obtained traversing parse tree may contain statements complexity calculate backward constraint slice space complexity worst case statements surround ing logic occur slice space 
time complexity statements def chain signal ob tained constant time 
statements mt set obtained constant time 
reaching definition rhs signals signals mt set combined set statements worst case backward slice computed 
complexity calculate forward constraint slice slice space complexity computing backward constraint time complexity statements def chain signal ob tained constant time 
lhs signal statement forward slice computed obtained constant time 
unique reaching definition rhs signals dif time 
statement def chain mt set ferent def chain index signals mt set backward slice computed time 
experimental results verilog rtl model arm processor benchmark study effectiveness factor 
proposed technique applied mod ules embedded levels hierarchy 
table gives tics modules test 
table modules arm module hierarchy primary primary gates gates surrounding stuck name level inputs outputs design logic faults alu rf str exc fwd commercial atpg tool generate test patterns targeting stuck faults mut original design slicing 
re sults table generated mhz ultrasparc ii dual processor gb ram 
processor level test generation run completion time consuming 
sufficient table test generation original design module processor level stand name test coverage time test coverage time alu rf str exc fwd average examine test coverage versus time system cpu seconds taken atpg tool understand difficulty test generation modules embedded fairly large design 
average geometric mean test coverages times illustrates complexity sequential atpg 
gates original design raw slicing hierarchical slicing hierarchical slicing piers alu rf str exc fwd reduction surrounding logic factor derive required constraint slices 
shows reduction surrounding logic constraint slices extracted raw technique composition slices composed hier technique 
composition theorem validates hierarchical technique obtain desired constraint slice 
hierarchical technique applied piers study contribution methodology 
modules alu exc fwd instantiated level hierarchy module 
slices obtained higher level hierarchy slicing alu reused constraint slicing exc fwd 
constraint slice provides required subset consistency theorem original program 
higher level slices derive constraint slice rf str embedded deeper hierarchy 
constraint slicing performed ghz athlon processor mb ram ultrasparc ii processor specified previously synthesis 
table shows time system cpu seconds constraint slicing synthesis 
note hierarchical slicing time may marginally higher involves multiple steps 
difference substantially synthesis test generation due smaller amount surrounding logic obtained 
note partial slices level hierarchy include smaller relevant set statements instantiated modules 
con trast instantiated modules raw slicing include union state ments required various instantiations 
final constraint slice ob tained hierarchical slicing smaller slice obtained raw slicing 
slices synthesized combined respective gate level 
commercial atpg tool original design generate test patterns targeting faults mut 
consistency theorem implies resulting patterns may translated full chip level loss test coverage 
table shows test generation results table slicing synthesis times hierarchical slicing raw slicing piers piers module slicing synthesis slicing synthesis slicing synthesis name time time time time time time alu rf str exc fwd raw slicing 
tables show corresponding results hierarchical slicing piers respectively 
abort limit maintained situations 
table test generation raw slicing module test atpg atpg total name coverage efficiency time time alu rf str exc fwd average total time mut includes time taken constraint slicing synthesis 
stuck test coverage tool efficiency improve signif achieving drastic reduction test generation time 
particular case module rf str hierarchical slicing piers improved coverage significantly 
hierarchical slicing enhanced piers able reduce test generation time factor 
module biggest modules considered deeply em table test generation hierarchical slicing piers module test atpg atpg total name coverage efficiency time time alu rf str exc fwd average table test generation hierarchical slicing piers module test atpg atpg total name coverage efficiency time time alu rf str exc fwd average design shows hierarchical approach useful deal large hierarchical designs 
note coverage test generation times module exc remain cases 
case raw slicing able achieve smallest possible slice surrounding logic 
piers improved majority modules targeted test coverage raw hierarchical slicing 
mainly slicing terminates piers eliminates additional registers slicing terminate primary inputs outputs piers 
fact illustrated results hierarchical slicing piers show test generation times higher enhanced piers 
process constraint slicing tool helps estimate loss fault coverage 
example coverage obtained alu module restricted inputs driven signals decoded single alu operation signal 
factor flags warning cases provides details mut signal affected trace signals aborted path 
information exploited modify add design elements improve testability 
results benchmarks illustrate various aspects method ology 
slicing approaches helped obtain higher test coverage unit time 
averages geometric means test coverage time prove constraint slicing reduces atpg complexity acceptable level 
slicing methodology produces smaller design atpg tool effectively identifies coi fault site generates test pattern reason able amount time 
results validate test generation methodology program slicing technique holds great promise reduce test generation complexity large designs 
chapter fundamentals bounded property checking formal verification depends recognition programs mathematical ob jects defined semantics behavior 
principle possible prove formally programs correct respect certain spec define allowed behaviour system 
main approaches specifying hardware behaviour temporal logic express properties generating high level model system 
correspondingly verification performed showing system satis fies properties consistent high level model 
model checking takes approach specifying properties temporal logic validate system behavior 
temporal logic logic usually propositional order augmented temporal modal oper allow reasoning truth values assertions change time 
logic express properties system behavior broadly classified safety liveness properties 
safety property expresses fact bad happen 
liveness property expresses behavior eventually happen 
instance logic express assertion proposition holds proposition holds instant 
ways specifying properties temporal logic depending underlying model time temporal operators 
linear time logic ltl notion time linearly ordered set thought possible sequence states 
operators describe ltl properties dealing hardware verification viz 
formulas defined recursively 
ltl formulas true moment true 
expresses fact true moment 
means hold true moment time hold moments 
true true instant time 
additionally ltl formulas 
operator called weak necessarily hold strong definitely holds 
temporal logic framework computational tree logic ctl express fact instant time exist possible futures 
addition operators defined ltl properties uses universal existential quantifiers express properties discrete model time 
branch defined maximal linearly ordered set states 
exam ple necessarily true branches represented formula possibly true branch represented formula illustrates ctl formulas 
truth falsehood tense formulas thought relative branch tree ordered frame 
example true state represented root node exists sequence states holds 
true false illustration ctl formulas illustrate operators express safety liveness prop erties consider design processor 
fetches instructions decodes fetches operands executes instructions writes results back returns fetch state 
design control processor includes sequence states may include illegal states depending state assignment 
safety property processor enters illegal state say expressed ltl 
order find counterexample bug property sufficient check existence witness ctl property execution path time processor enters illegal state 
liveness property processor hangs ways return fetch state expressed ltl coun infinite sequence states include fetch state expressed ctl execution path fetch state reached 
model checking process analyzing design validity properties stated temporal logic called model checking 
input model checker formal description design result set states satisfies property witness sequence violates property 
model checking done explicitly checking property holds state possible designs small numbers states 
lan developed efficient techniques manipulate boolean formulas model checking ordered binary decision diagrams obdds 
obdds allows analysis designs explicitly enumerating states 
obdds vulnerable state explosion problem moderately complex designs 
practice primary benefit model checking finding bugs providing formal proofs establishing design correctness 
designers usually define bounds number steps property hold 
leads idea bounded model checking exploits ideas pragmatic approach 
bounded model checking paradigm finite prefix path may solution tial model checking problem considered 
instance checking universal property equivalent finding witness dual ex property key idea searching coun finite unfolding respect time steps design verification 
systematically increasing unfolding depth bounded inte ger approach checks target reached steps 
approach suggested biere introduced sat bounded model checking procedure checking ltl properties 
involved stage process generating set propositional clauses design consideration efficient sat solver find satisfying variable assignment polynomial time 
approach avoids expensive fixed point computations model checking algorithms practically useful verifying temporal proper ties 
described benefits bounded model checking intel designs taken pentium processor 
bmc checker sat solver reported superior bdd package 
approach com plete proves unreachability target conclusively proven diameter stg larger largest bound property checked 
structural algorithms estimate tight bound ter linear sweep design shown great promise making approach robust viable verifying large designs 
current implementations rely sat techniques originally analyze boolean expressions hardware circuits 
imperative cad technique uses sat solver translate prob lem boolean formula usually represented propositional clauses described conjunctive normal form cnf 
cnf function circuit general exponentially larger circuit intro duces variables internal wire 
means sat approach hardware verification structural information de sign inherently hdl program 
additionally sequential designs need time wise unrolled pre determined set time frames purely combinational circuit 
serious limitation technique ap plied large sequential circuits prevalent today 
circuits artifacts tri state logic handled native sat solvers extensive 
simulation approach bmc proposed overcome limitations proposed bingham hu 
case splitting heuristics hallmark sat solvers sacri capacity simulation techniques offer 
may severely undermine capability establish unsatisfiability leaving need structural techniques incorporating simulation sequential atpg 
symbolic trajectory evaluation traditional simulation hardware designs check correctness ineffective catching subtle bugs tedious process 
symbolic simula tion uses symbols actual values proposed hardware reasoning late 
development obdds efficient representation boolean functions manipulation gave impetus approach 
ternary simulation vlsi circuits uses third value set possi ble signal values indicate unknown indeterminate logic value 
value lower bound pair values allows tremendous speedup simulation pattern potentially represents operating conditions 
information ordering introduced efficient reasoning simulation results 
order operations monotonic informa tion ordering upper bound completes lattice structure representing constrained logic value introduced imply node time 
quaternary model developed efficiently represent manipulate simulation process 
trajectory formulas new generation symbolic simulation hardware verification uses modified symbolic simulator verify formulas described limited form temporal logic 
logic allows user express properties circuit bounded length valid sequences trajectories circuit states 
formulas describing trajectories trajectory formulas tfs defined recursively follows 
simple predicates 
node digital circuit model trajectory formulas 
conjunction 
trajectory formulas time 
trajectory formula domain restriction 
trajectory formula boolean expression symbolic variables trajectory formula 
conjunction natural interpretation upper bound lattice elements 
example specifies node particular time step specifies node time step specifies node time step 
may flagged inconsistency specification 
disjunction correspond greatest lower bound disjunction negation conjunction imply disjunction allowed tfs 
tf set tuples tuple form boolean guard condition name node circuit boolean value start time time 
tuple may translated statement node value time condition true 
false tuple part antecedent node takes value state function applied state 
false tuple part consequent check performed node 
logic retains expressive power describe timing state tran sition information remains simple checked symbolic simu 
designed compromise expressive power ease evalu ation 
assertions trajectory assertion form trajectory representing antecedent consequent 
antecedent user con straint inputs consequent asserts expected values simulation output nodes 
trajectory assertion implicitly universally quantified symbolic variables appear 
example simple assertion asserts state state 
succinct specifications may expressed symbolic variables represent set assertions 
types assertions describe sequences iterations allow expressiveness 
successful simulation es sequence states circuit model satisfies satisfies mismatch reported bug trace encompasses com plete set failing bugs useful feature debugging 
assertions usually expressed general purpose language suit able simulation engine 
complex assertions may naturally expressed hierarchical manner functions procedure calls provided language 
modified event driven symbolic simulator sufficient check complex target design 
chapter atpg property checking atpg techniques originally developed generating ing tests capabilities techniques successfully deal complex de signs attracted considerable attention design automation domains 
example atpg algorithms successfully utilized logic synthesis design rule checking equivalence checking false path identification 
interest atpg techniques design verification restricted subset properties 
counterexample safety property implies bad happens circuit 
processor example previous chapter bad event processor goes illegal state 
atpg tool search potential solution space seeking find counterexample justifying illegal state back initial state 
sequential atpg model checking proposed bop 
focused primarily safety properties studied ef sequential atpg algorithms state space exploration 
noted main benefits atpg implicit storage states time frame optimum balance breadth search depth search 
cheng discussed atpg verification including combinational equivalence checking safety property checking 
properties suggested included bus contention asynchronous feedback loops 
atpg sat algorithms compared parthasarathy 
iden tradeoffs algorithms pointed atpg deal naturally real world primitives tri state buses high impedance logic values 
hsiao jain suggested sequential atpg verifying safety properties type compared obdd approaches simulation atpg genetic algorithm 
approaches shown atpg perform state space search needing complete state space information time 
checking safety property precisely finding coun invariant done easily atpg techniques shown liveness properties checked 
methodology ing limitation section 
proposed approach key requirement technique usable designers fit seamlessly normal design flow 
approach existing atpg tool modifications circuit description compatible atpg tool 
addition small circuit guide atpg tool checking desired property 
properties stated temporal logic formulas type re path formula state sub formulas atomic propositions considered 
proposed approach automatically maps safety liveness properties upper bound number steps verified monitor circuit target fault 
allows existing atpg tool generate test fault 
test fault witness property 
fault determined property guaranteed hold bound 
atpg aborts generates test proves fault concluded property 
original design property property property monitor fault monitor fault sequential atpg monitor fault property monitors property monitor fault fn testability fault fi determines property satisfied property verification approach atpg illustrates essential features approach 
monitor circuits generated properties interest relevant signal names original design modifying original design atpg tool 
atpg suited finding test witness value chosen signal circuit 
checking ltl property circuit reduced finding witness dual equivalent existential ctl property 
order test ltl property bound time cycles true atpg find sequence length true witness 
finite state machines representing monitor circuits properties described section bound property satisfied final accepting state reached 
target fault atpg output gate encodes final state 
property monitors illustrates monitor property 
search starts state indicated time satisfied transition accepting state indicated atpg generate stuck fault output gate encoding final state valid test generated fault indicates property satisfied fault proves exist state sequence length equal satisfies property start monitor similar monitor check property bounded liveness de noted illustrated bound transition accepting state labeled satisfied state state sequence starting start state 
successfully generated test sequence proves existence sequence true state state sequence witness property 
start monitor case actual number states witness sequence longer states sequence returned atpg 
design forced start state atpg initialization sequence 
results technique applied iscas benchmark circuits 
property mon described verilog synthesized gate level composed original design 
commercial sequential atpg tool generate witnesses 
results compared free research version bounded model checker originally developed carnegie mellon university available cadence berkeley labs 
experiments performed sun microsystems ultrasparc ii system dual processors running mhz gb memory 
properties iscas benchmark circuits derived logical composition outputs specific distinction sufficient eval approach 
ltl properties nesting required cadence smv 
bmc ltl properties accomplished searching witness dual corresponding existential ctl property 
benchmark circuits safety property considered output circuit times exists output zero 
atpg find witness exists state outputs simultaneously 
table shows results experiment 
columns give circuit name details number pins number combinational gates number sequential elements respectively 
fifth column indicates counterexample exists indicated property satisfied circuits 
final columns show cpu times seconds bmc atpg respectively 
bmc unable generate sat clauses largest circuits indicated table 
liveness property considered output exists state sequence length outputs 
atpg find witness dual ctl property sequence states length state outputs simultaneously 
results table different values bound respectively 
bound column indicates counterexample property exists indicated columns give times taken bmc atpg respectively 
table checking ef property outputs bound circuit primary comb 
seq 
counter bmc atpg name gates elem 
example 
cpu cpu table checking property outputs various bounds bound bound bound circuit ctr bmc atpg ctr bmc atpg ctr bmc atpg name ex 
sec 
sec 
ex 
sec 
sec 
ex 
sec 
sec 
peak memory usage bmc smv zchaff sat solver ap mb largest circuit handle 
handle larger designs 
contrast peak memory requirement atpg including largest design mb 
smallest de sign atpg requires mb bmc requires mb 
sat approach requires memory small circuits memory requirement grows quickly number generated clauses grows size circuit bound contrast memory requirement atpg grows rapidly increasing design size primary memory requirements representation circuit structure values nodes 
verification gate level structural techniques atpg allows proving properties designs real artifacts tri states multiple clocks switches 
selecting bounds table highlights interesting trends behavior ap proaches bound increased 
described previously recommended approach bounded model checking start small bound look counterexample progressively increase bound checking property holds larger larger bounds 
time required bmc increases bound increased 
particular circuit time increases second seconds contrast time required atpg remains approximately independent bound circuit 
real designs large sequential depths easy guess accurate initial value bound 
atpg ap proach start relatively large bound incurring large penalty cpu time 
techniques estimating diameter stg provide bound priori guaranteeing completeness methodology property checking 
sat versus atpg engines sat atpg computationally expensive algorithms belong class np complete problems 
practice heuristics proposed techniques prune search space effec tively 
solutions search techniques possible combi nations inputs searched implicitly 
leading non commercial sat solvers davis putnam procedure identification unit clauses comput ing resulting implications 
best known version procedure backtracking search algorithm node search tree selects assignment prunes subsequent search space iteratively applying unit clause pure literal rules 
sat solver grasp com previously proposed search pruning techniques identifies new ones 
additionally grasp uses powerful conflict detection procedure records causes conflicts increase speed pruning 
zchaff high perfor mance sat solver achieves improvement orders magnitude previous sat solvers clever efficient implementation boolean constraint propagation bcp low overhead decision strategies 
hybrid approach combining advantages structural conjunctive normal form cnf algorithms shown faster zchaff 
combinational atpg algorithms struc tural information design decision ordering justifying propagating decision assignments 
algorithms comparable complexity sat techniques 
search algorithms employed sequential systems modified version combinational circuit search system 
illustrates itera tive logic array ila model sequential circuit shown 
ila model unrolled version sequential circuit flip flops replaced environment variables represent state circuit primary inputs respectively time model copy circuit time referred note frame combinational circuit primary inputs consisting set 
primary inputs combinational logic state state flip flops primary outputs po pi po pi sn pin tn sequential circuit model iterative model sequential circuit ila model pon algorithms developed sat combinational atpg ap plied ila model naive approach inherently limited size designs handle 
number time frames designs need unrolled grows exponentially large number sequential elements increase 
time frames identical structure need construct complete model ila 
single copy structural model stored signal values different time frames need maintained 
time frames incremented step wise manner find shortest possible test memory efficient unrolling design described previously 
efficient atpg search algorithm uses ila model assumes circuit starts unknown state xs finds reset synchronization sequence known state 
property checking framework atpg starts circuit state searches sequence input vectors activate circuit property producing logic output property monitor 
framework consistent classical bmc tries find set states satisfy contradict property 
search determines monitor output set guaranteed sequence states length satisfy contradict property 
clear sequential atpg state justification phase needed order prove property satisfied 
memory requirements significantly lower atpg sat atpg needs store states flip flops primary inputs time frame 
chapter design verification slicing complexity verification process requires division simpler tasks exploiting modular structure system 
achieved ing abstracting implementation specification 
methodologies hierarchical verification include assume guarantee reasoning compo minimization 
compositional techniques shown improve scalability model checking 
rtl reduction eliminate essary portions circuit proposed speedup practical verification symbolic model checking 
section develops similar approach hdl slicing improve performance proposed atpg approach bounded model checking 
sequential atpg tools moderately large designs able handle complete processor design example 
order able atpg property checking de scribed chapter divide conquer approach desired check prop erties individual components modules large design 
re quire counterexample generated property translated system interface 
additionally assumptions interactions module verification muv surrounding modules need incor temporal logic specification 
proposed approach extends atpg property checking un bounded liveness properties uses program slicing methodology accel erating test generation described chapter provide powerful framework validating designs 
program slicing approach overcome problems modular bounded property checking dealing large designs 
constraint slice muv encompasses interactions surrounding environment synthesized constraint slice implicitly forces gate level atpg tool generate witness counterexample valid system level 
fault constraint slice place property muv holds true bound 
note program slicing techniques sat ap proach bmc 
size modules handled cadence smv zchaff sat solver limited shown re sults chapter 
require selecting smaller deeply embedded modules design result surrounding environment large tool cadence smv handle 
approach designed check ltl properties may suitable kinds properties described synthesizable hdl 
constraint slicing approach directly accessible internal registers called piers primary input output accessible registers pseudo primary inputs outputs constraint slicing 
piers methodol ogy accelerate generation witnesses counterexamples properties 
note target fault output piers pseudo primary outputs required 
sufficient identify regis ters written able translate generated witness counterexample system level load instruction 
piers act additional inputs provide better controllability target fault fault implies test pattern system level 
similarly successfully generated test pattern translated back chip level load instructions pseudo primary inputs valid witness counterexample property checked 
unbounded liveness monitor circuit described checks bounded liveness searching sequence states true selected bound 
unbounded liveness checking requires finding loop stg state satisfies means final accepting state arrived witness state reached prior time steps 
done additional set bound registers added synthesizable hdl description monitor defining memory 
valid sequence state encoding stored memory search expands 
clock cycle desired state reached compared set prior valid states repetition inferred loop 
approach performs exactly check sat bmc approach check loop stg 
example generic monitor checking unbounded liveness follows 
checks counterexamples steps monitor state machine states 
values shown illustration changed appropriately suit requirements specific instances bmc 
property monitor unbounded liveness module monitor clk state sa parameter parameter parameter input clk input state output sa reg state ctr reg state mem reg loop flag assign sa loop flag clk state ctr state ctr state ctr state mem state ctr state state ctr break state state mem loop flag disable break loop flag state ctr loop flag property monitor conforms standard definition strong operator ctl shown 
property checks state exists finite sequence inputs true state resulting application input sequence true prior states 
argument circuit guide atpg finding witness property similar property 
improvements lead elegant approach check properties type expressed existential operators ctl necessary bounded check may performed searching witness easy start monitor fer monitors existential properties described earlier may directly find counterexample important property 
property checking technique easily adapted check existential ctl properties equally suitable ctl property checking 
achieved searching witness existential property number time steps 
counterexample property holds true oth property hold specified bound 
methodology limited checking ctl ltl properties 
check properties design expressed synthesizable hdl may direct correspondence formal languages 
unique nature approach powerful verifying designs practice 
results analysis proposed methodology uses factor described section implemented generating constraint slices test generation 
methodology implemented verilog rtl model viper verifiable integrated proces sor enhanced reliability bit microprocessor designed safety critical applications 
wr io wr mem start exec halt simplified state transition graph viper control control module chosen muv finite state machine 
set properties checked follows 
vp exists finite input sequence resulting state tion raised 
vp exists finite input sequence resulting halt state 
vp instruction fetched requires clock cycles complete exception raised 
vp possible execution instruction may return fetch state clock cycles exception allowed raised 
vp possible enter halt state remain forever 
unbounded liveness implied 
vp system halt state exists finite input sequence resulting state having reset machine 
vp system state start state infinite sequence inputs true resulting state 
unbounded liveness checked memories 
vp true signal remains un asserted system enters halt state 
methodology checking ctl properties type 
vp trivial case checking property vp eliminated re checked 
properties methodically chosen check impor tant features explained section muv eliminate chance non trivial solutions 
fetch state refers 
dummy outputs needed property monitors observe signals muv added original viper design synthesized gate level 
piers design identified pseudo primary inputs generation constraint slice factor 
relevant slice design viper generated combining muv generated constraint slice syn gate level 
slicing case viper synthesis times taken generating target designs viper viper characteristics combinational gates sequential elements ta ble 
table benchmark characteristics module comb 
seq 
time name gates elem 
secs 
viper viper times shown user cpu seconds include synthesis time ing flatten mode slicing time viper time target 
experiments conducted mhz ultrasparc ii dual processor gb ram 
commercial tools gate level synthesis sequential atpg 
monitors property described implemented sizable verilog rtl synthesized gate level 
simple top level wrapper module generated target instantiates target monitor 
characteristics monitors synthesis times shown table 
note monitors need generated target designs 
monitors generated current monitors generic reused check properties designs 
commercial atpg tool generate test sequence targeting stuck fault output monitor determines existence witness counterexample depending property 
results test generation targets table 
table bounded property checking hdl slicing monitor generation test generation property comb 
seq 
time test property time secs checked gates elem 
secs 
valid 
viper viper vp vp vp vp vp vp vp vp vp time cpu seconds taken generating monitors prop erty characteristics monitor shown columns 
test gen eration performed monitors composed original sliced designs 
test indicated column specified bound column indicates property checked valid indicated respectively bound 
columns show test generation times cpu seconds original sliced design 
order check property vp avoid generating trivial coun necessary verify existence sequence inputs raises exception verify system enters halt state 
prop erties vp vp verified purpose 
property vp checks validity vp allowing exception raised 
test pattern generated showed true system enters halt state 
logical step check possible system enter halt state remain forever 
property vp checked condition bound possible 
property vp verified see possible come halt state having reset system 
property vp checks address lines fetch assign write ddr assigned 
achieved checking unbounded liveness condition bit wide memory register save set valid prior states check current state 
test dual ectl property indicating property valid 
properties vp vp verify property type order demonstrate approach suggested section 
test pattern generated vp asserted case eliminated produce interesting property vp 
properties useful check system halt illegal instruction fetched overflow condition occurs 
generated test patterns manually verified control flow state machine ensure correctness validity 
note generated slices include forward slices outputs muv necessary verification targeted fault output gate encoding accepting state monitor 
size slice slicing verification times significantly change tool suitably modified 
results show tremendous reduction time taken property checking applying program slicing 
benefits approaches systematically incorporated proposed methodology 
symbolic trajectory evaluation symbolic trajectory evaluation ste derives strength factors simple specification language symbolic simulation model checking algo rithm quaternary circuit model 
quaternary abstraction circuit assigns node value possible values represent specific fully defined values low high voltages denotes unknown value absence information indicates constrained value 
real circuits start initial state 
node value time antecedent assumed initial value doing model checking complexity vastly reduced respect circuit representation 
general circuit boolean nodes unique states combinations 
quaternary model quaternary assignments 
performance improvements technique applicable fairly large designs 
bdd representation state space grow exponentially size operations especially complex circuits adders multipliers 
sequential circuit verification needs hierarchical methodologies hdl slicing reduce size target verification process faster 
forte verification framework robust framework evolved voss verification system simulator back language front 
front com piler interpreter small fully lazy delayed evaluation necessity meta language ml precisely defined semantics 
specification program built language executed build simulation sequence completely verifies specification 
symbolic simulator event driven handle gate level switch level descriptions 
forte scripting language strongly typed functional language fl derived ml family bdds built language 
provides flexible interface interfacing orchestrating model checking runs serves macro language expressing specifications provides control language forte theorem prover 
forte includes graphical interface tcl tk programming debugging 
provides node browser waveform viewer circuit browser 
hdl source code compiled formal circuit model uses graph ical interface display circuit structures waveforms 
ste model checker automatically validates simple temporal logic formula arbitrary inputs computes exact characterization disagreement formula uncon satisfied 
verification methodology direct application forte ste verification tool impossible com plete processor designs require hierarchical approach tar individual modules design 
modules processor designed properly certain environmental constraints 
example decoder may require inputs legal instructions pipelined execution unit may require certain delay consecutive operations 
ing constraints guide tool correctly check muv daunting task 
techniques sequential parallel composition case splitting verify complex designs forte frame 
approach requires theorem prover link low level proofs specification chip level 
hdl slicing methodology proposed chapter extracts constraints rtl description surrounding design 
factor achieves statically analyzing rtl identify relevant statements signals respect muv interface 
generated synthesizable rtl description surrounding logic performed hi necessary implicitly describes desired environment constraints 
lemma shows process trace slice preserved respect muv interface implies simulation muv sliced design equivalent performing original design 
previously verified module ste assertions described respect constraints imposed surrounding logic chosen 
objective compare cpu performance checking assertions original sliced designs 
results floating point fp adder intel pentium design chosen muv evaluating effectiveness slicing methodology 
modules embedded fp cluster pentium logically divided clusters 
adder performs ieee compliant fp addition subtraction single double extended precision 
supports rounding modes nearest real number representable floating point format 
pentium processor validation effort project kind intel formal verification large scale 
formally verifying cluster level reach state art tools 
fp add sub module originally verified ste assertions writ intermediate level fp cluster 
assertions split cases easier debugging 
high level design implemented internal intel clone vhdl language 
suitable factor implemented handle verilog designs 
internal translator translate intermediate level model verilog introduced bugs assertions cases caught checking previously described assertions 
model sufficient demonstrating slicing method ology provided bug trace produced sliced model 
bug trace symbolic domain describes complete set failures assertion 
forte operates intel internal compiled version rtl code 
size original compiled model kb 
factor applied obtain constraint slice inputs outputs muv 
original rtl de scription muv combined constraint slice compiled intel internal format 
sliced design reduced target kb reduction 
sliced model check previously described assertions 
cpu times seconds verification case orig inal sliced model shown table 
experiments performed ghz pentium processor gb ram running linux 
comparison verification run times reveals sliced table cpu times ste hdl slicing case original slice speed case original slice speed secs secs secs secs indicates cases bugs 
design brings execution times significant amount 
third column gives speed ups obtained rounded nearest decimal place computed follows 
original sliced design speed table shows sliced design original de sign resulted speed ups varying 
note results ob tained compiler optimizations eliminate redundant constraints rtl slice 
similarly piers golden assertions described 
improvements speed result reduction sizes bdd nodes needed simulation due slicing 
peak bdd sizes needed case assertion checking original sliced designs shown 
results reinforce fact proposed hdl slicing methodology effective reducing analysis time cad tools industrial scale circuits 
improvement addition existing structural coi reduction ste framework 
forte computes nodes specified irrespective coi nodes traced checking assertions 
hdl slicing potentially identify set nodes traced assertion speedup ste 
verifying design requires showing circuit exhibits correct behavior possible initial states input sequences 
process compu intensive requires reduction abstraction techniques lose necessary information 
abstraction mechanisms require counterexample trace simulated original design establish true negative 
additionally require inference rules remove chance false positives 
proposed methodology eliminates necessity post analysis verification effort retains necessary environmental constraints muv original form 
peak bdd size original slice original slice case peak bdd sizes case table chapter concluding remarks complex designs hierarchical hierarchy design process easier 
proposed approach utilizes inherent hierarchy designs simplify complexity sequential atpg uses derive tests individual modules design existing atpg tools 
surrounding logic mut distilled produce relevant slice defines atpg view mut 
proposed approach formalizes extends previous approach exploits hierarchy simplify generation slices 
allows reuse previously derived slices 
technique exploits efficiency netlist graph traversal performing search stg 
elegant theoretical foundation proposed program slicing hdls benefits test generation demonstrated 
methodology successfully imple mented prototype tool factor effectively improving coverage time taken generate test patterns verilog designs 
tool reduces test generation time providing valuable insight testability design 
results generated tool show capability ease atpg complexity offers systematic sound technique scalable large designs 
atpg property checking approach described vali dating hdl designs 
approach fits normal design flow require significant modifications design verified 
basic ap proach explained detail chapter 
sequential atpg capabilities matured decades successfully check im portant class temporal properties bounded semantics 
atpg framework allows designers easily specify properties currently checked simulation 
results show atpg search techniques superior conventional sat search able deal larger designs possible sat approaches 
atpg knowledge structural information design verification missing sat approach 
hybrid approach combines benefits approaches proposed may offer solution problem 
approach proposed dissertation able prove prop erties designs real artifacts tri state buffers inserted seamlessly normal design flow making easy apply real designs 
approach needs augmented strategy check nested prop erties 
novel verification approach successfully integrated proposed slicing methodology produce powerful technique speed design verification orders magnitude 
verification requires backward slices signals specify property factor potentially restricted generate slices 
slicing approach success fully applied industrial scale design ste verification framework 
methodology augments existing target reduction techniques helps speed verification process 
capability incrementally derive constraint slices reuse pre derived slices opens new approach efficient hdl analysis cad applications 
derive functional test patterns systems chip designs dft testability analysis regression testing atpg sequential equivalence checking 
bibliography bushnell agarwal 
essentials electronic testing digital memory mixed signal vlsi circuits 
kluwer academic publishers 
williams 
structured logic testing 
englewood cliffs new jersey prentice hall 
agarwal tutorial built self test part principles ieee design test computers vol 
mar pp 

agarwal tutorial built self test part principles ieee design test computers vol 
jun pp 

nag wei modeling economics testing dft perspective ieee design test computers vol 
jan feb pp 

maxwell aitken test sets reject rates fault cov created equal ieee design test computers vol 
mar pp 

breuer friedman 
digital systems testing testable design 
piscataway new jersey ieee press revised printing 
test generation ultra large circuits atpg constraints test pattern templates proc 
international test con ference oct pp 

lee patel hierarchical test generation architectural level functional constraints ieee trans 
computer aided design integrated circuits systems vol 
sep pp 

thomas behavioral test generation mixed integer non linear programming proc 
international test conference oct pp 

abraham automatic test knowledge extraction vhdl proc 
design automation conference jun pp 

framework method hierarchical test generation proc 
international test conference sep pp 

bhattacharya hayes hierarchical test generation methodol ogy digital circuits electronic testing theory applications vol 
may pp 

hierarchical sequential test generation large circuits ph dissertation university texas austin may 
weiser program slicing ieee trans 
software engineering vol 
se jul pp 

deng program slice browser proc 
interna tional workshop program comprehension may pp 

lyle gallagher program decomposition scheme ap plications software modification testing proc 
hawaii international conference system sciences vol 
ii jan pp 

gallagher lyle program slicing software nance ieee trans 
software engineering vol 
aug pp 

extracting reusable functions flow graph program slicing ieee trans 
software engineering vol 
apr pp 

cheng slicing concurrent programs graph theoretical approach lecture notes computer science automated algorithmic debugging may pp 

ramesh slicing concurrent programs proc 
international symposium software testing analysis pp 

program slicing vhdl de evaluation ieice trans 
fundamentals electronics communications computer science vol 
dec pp 

clarke fujita rajan reps shankar teitelbaum program slicing hardware description languages proc :10.1.1.31.914
conference correct hardware design verification methods sep pp 

roy abraham high level test generation data flow descriptions proc 
european design automation conference mar pp 

chen wu saab accessibility analysis data flow graph approach design testability proc 
international conference computer design oct pp 

seshadri hsiao integrated approach behavioral level design testability value range variable testability tech niques proc 
international test conference sep pp 

functional verification silicon intensive systems proc 
de chip system design conference jan 
kang simulation automation sys tem sas concepts implementation results ieee trans 
vlsi sys tems vol 
mar pp 

kern formal verification hardware design sur acm trans 
design automation electronic systems vol 
apr pp 

bryant complexity vlsi implementations graph rep boolean functions application integer multiplication ieee trans 
computers vol 
feb pp 


huang 
cheng 
formal equivalence checking design debugging frontiers electronic testing vol 
kluwer academic pub jun 
boyer moore 
computational logic handbook 
new york academic press 
burch clarke mcmillan dill hwang sym model checking states information computa tion vol 
jun pp 

aziz formal methods vlsi system design ph dissertation uni versity california berkeley may 

seger bryant formal verification symbolic evaluation partially ordered trajectories formal methods system design vol 
mar pp 

biere cimatti clarke zhu symbolic model checking bdds tools algorithms analysis construction systems mar pp 

du gu pardalos 
satisfiability problem theory appli cations 
dimacs series discrete mathematics theoretical computer science american mathematical society vol 

fix giunchiglia vardi benefits bounded model checking industrial setting proc 
computer aided verification jul pp 

baumgartner abraham property checking structural analysis proc 
computer aided verification jul pp 

boppana rajan fujita model checking sequential atpg proc 
computer aided verification jul pp 


huang 
cheng word level atpg modular arith constraint solving techniques assertion property checking ieee trans 
computer aided design integrated circuits systems vol 
mar pp 

hsiao jain practical sequential atpg model check ing going extra mile pay proc 
high level design validation test workshop nov pp 

sheng hsiao effective safety property checking simulation sequential atpg proc 
design automation confer ence jun pp 

bryant graph algorithms boolean function manipulation ieee trans 
computers vol 
aug pp 

yang 
seger generalized symbolic trajectory evaluation proc 
international conference computer design sep pp 

abraham saab verifying properties sequential atpg proc 
international test conference oct pp 

aho sethi ullman 
compilers principles techniques tools 
reading massachusetts addison wesley 
venkatesh semantic approach program slicing proc 
acm conference programming language design implementation jun pp 

abraham program slicing hierarchical test generation proc 
vlsi test symposium apr pp 

abraham hierarchical test generation approach program slicing techniques hardware de scription languages electronic testing theory applications vol 
apr pp 

graphical parallel composition operator process algebras proc 
joint international conference formal de scription techniques distributed systems communication protocols protocol specification testing verification oct pp 

abraham novel methodology hierarchical test generation functional constraint composition proc 
international high level design validation test workshop nov pp 

abraham factor hierarchical methodology functional test generation testability analysis proc 
design automation test europe mar pp 

van de 
testing semiconductor memories theory practice 
chichester john wiley sons 
abraham functional testing microprocessors ieee trans 
computers vol 
jun pp 

html rough verilog parser ver 
www com html html 
specification verification pipelining arm risc microprocessor acm trans 
design tion electronic systems vol 
oct pp 

emerson temporal modal logic handbook theoretical com puter science vol 
pp 

lamport proving correctness multiprocess programs ieee trans 
software engineering vol 
se mar pp 

pnueli temporal semantics concurrent programs theoretical computer science vol 
jan pp 

clarke emerson sistla automatic verification finite state concurrent systems temporal logic specifications acm trans 
programming languages systems vol 
pp 

clarke grumberg peled 
model checking 
mit press 
mcmillan 
symbolic model checking 
kluwer academic publishers 
bingham hu semi formal bounded model checking proc 
computer aided verification jul pp 

carter jr brand symbolic simulation cor rect machine design proc 
design automation conference pp 

jain formal hardware verification symbolic trajectory evaluation ph dissertation carnegie mellon university july 
cheng current directions automatic test generation ieee computer vol 
nov pp 

parthasarathy 
huang 
cheng analysis atpg sat algorithms formal verification proc 
high level design validation test workshop nov pp 

clarke grumberg look ltl model checking formal methods system design vol 
feb pp 

mentor graphics www mentor com dft scan html flex 
cheng back algorithm sequential test generation proc 
international conference computer design aug pp 

cadence berkeley laboratories www cad eecs berkeley edu smv garey johnson 
computers intractability 
new york freeman 
ibarra sahni polynomial complete fault detection prob lems ieee trans 
computers vol 
mar pp 

davis putnam computing procedure quantification ory acm vol 
pp 

zabih mcallester rearrangement search strategy de propositional satisfiability proc 
national conference artificial intelligence pp 

silva sakallah grasp new search algorithm satisfiability proc 
international conference computer aided design nov pp 

moskewicz madigan zhao zhang malik chaff en efficient sat solver proc 
design automation conference jun pp 

zhang gupta malik combining strengths circuit cnf algorithms high performance sat solver proc 
design automation conference jun pp 

saab abraham formal verification bounded model checking sat versus sequential atpg engines proc 
ternational conference vlsi design jan 
appear 
henzinger qadeer rajamani assume guarantee methodology case studies proc 
computer aided verification jul pp 

grumberg long compositional model checking modular verification trans 
programming languages systems vol 
may pp 

mcmillan microarchitecture verification com positional model checking proc 
computer aided verification jul pp 

nakata techniques effectively applying model checking design projects fujitsu scientific technical journal jun vol 
pp 

el complexity anal ysis sequential atpg ieee trans 
computer aided design integrated circuits systems vol 
nov pp 

culler 
implementing safety critical systems viper cessor kluwer academic publishers 

seger voss formal verification system user guide cal report tr university british columbia 
narasimhan formal verification pentium floating point multiplier proc 
design automation test europe mar pp 

hinton sager boggs microarchitecture pentium processor intel technology st quarter 
vita murthy born india january twelfth year son rama murthy 
received bachelor technology degree chemical engineering indian institute technology madras 
joined ate program petroleum engineering university texas austin year changed major electrical computer engineering university 
received master science degree electrical computer engineering continued pursue ph degree depart ment 
graduate studies various semiconductor companies advanced micro devices austin tx national semiconductor santa clara ca intel austin tx 
permanent address apts lawson bay colony india 
