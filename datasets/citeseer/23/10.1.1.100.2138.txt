siam comput 
society industrial applied mathematics vol 
pp 
shortest path algorithm real weighted undirected graphs seth pettie vijaya ramachandran 
new scheme computing shortest paths real weighted undirected graphs fundamental comparison addition model 
efficient preprocessing phase algorithm creates linear size structure facilitates single source shortest path computations log time slowly growing inverse ackermann function number edges number vertices 
special cases algorithm implies new bounds pairs single source shortest paths problems 
solve pairs problem time ratio maximum minimum edge lengths bounded log solve single source problem nlog log time 
results theoretical improvements dijkstra algorithm previous best real weighted undirected graphs 
algorithm takes hierarchy approach invented thorup 
key words 
single source shortest paths pairs shortest paths undirected graphs dijkstra algorithm ams subject classifications 
doi 


problem computing shortest paths studied problems computer science 
thoroughly surprising setting real weighted graphs basic shortest path problems seen little progress early dijkstra bellman ford floyd warshall clrs 
instance algorithm computing shortest paths arbitrarily weighted graphs improve bellman ford mn time bound number edges vertices respectively 
fastest uniform pairs shortest path apsp algorithm dense graphs requires time log log log just slight improvement bound floyd warshall algorithm 
similarly dijkstra log time algorithm dij ft remains best computing weighted graphs algorithms pettie pet pet pet dijkstra algorithm best computing sparse graphs dij ft 
order improve bounds shortest path algorithms depend restricted type input 
algorithms geometric inputs see mitchell survey mit planar graphs fr graphs randomly chosen edge weights spi fg mt ks hag :10.1.1.56.2239
years received editors december accepted publication revised form october published electronically july 
supported texas advanced research program nsf ccr 
preliminary version titled computing shortest paths comparisons additions th annual acm siam symposium discrete algorithms san francisco ca 
www siam org journals html max planck institut informatik saarbr cken germany pettie mpi sb mpg de 
author supported alexander von humboldt postdoctoral fellowship mcd graduate fellowship 
department computer sciences university texas austin austin tx vlr cs utexas edu 
shortest path algorithm undirected graphs focus computing approximate shortest paths see zwick survey 
common assumption graph integer weighted structurally unrestricted machine model able manipulate integer representation weights 
shortest path algorithms scaling gt fast matrix multiplication sei gm agm tak sz running times depend magnitude integer edge weights yield improved algorithms sufficiently small edge weights 
case matrix multiplication algorithms critical threshold low edge weights sublinear large 
dijkstra algorithm sped integer weight model integer priority queue 
best bounds dijkstra algorithm date log log expected ht log log tho 
algorithms multiplication non ac operation see tho bounds ac model 
thorup tho considered restricted case integer weighted undirected graphs showed ac random access machine ram shortest paths computed linear time 
thorup invented call hierarchy approach shortest paths 
techniques developed integer weighted graphs scaling matrix multiplication integer sorting thorup hierarchy approach depend crucially graph integer weighted 
state affairs unique shortest path problem 
weighted matching gt gt maximum flow problems gr instance best algorithms real graphs running times differing polynomial factor 
shortest path problem positively weighted graphs integer real gap logarithmic 
great interest integer approach inherently yield faster algorithm general real weighted inputs 
generalize thorup hierarchy approach comparison addition model see section corollary real weighted input graphs 
undirected apsp problem nearly eliminate existing integer real gap reducing log log slowly growing inverse ackermann function 
stating results detail give overview hierarchy approach discuss hierarchy shortest path algorithms tho hag pet pet 
hierarchy algorithms thought preprocessing schemes answering sssp queries weighted graphs 
idea compute small non source specific structure encodes useful information shortest paths graph 
measure running time hierarchy algorithm quantities worst case preprocessing cost graph marginal cost sssp computation preprocessing 
solving sources shortest path problem requires time 
solving apsp known hierarchy algorithms term negligible 
may dominant asymptotic real world sense smaller values thorup original algorithm tho recall algorithm works integer weighted undirected graphs 
hagerup hag adapted thorup algorithm integer weighted directed graphs incurring slight loss efficiency process 
hag min log log sped integer sorting algorithm conjunction thorup reduction tho priority queues sorting 
hagerup proved min log mn see pet bound 
seth pettie vijaya ramachandran maximum edge weight log log 
initial publication results pr pettie pet pet gave adaptation hierarchy approach real weighted directed graphs 
main result pet apsp algorithm running time mn log log improved mn log bound derived multiple runs dijkstra algorithm dij ft 
result pet stated terms apsp problem preprocessing cost mn making efficient close pet see pet nonuniform complexity apsp considered main result pet algorithm performing mn log comparison addition operations 
bound essentially optimal due trivial lower bound apsp 
give new bounds computing undirected shortest paths real weighted graphs 
algorithm preprocessing cost mst min log log log mst complexity minimum spanning tree problem ratio maximum minimum edge weight 
bound worse log excessively large log say log log 
show marginal cost algorithm asymptotically equivalent split findmin decision tree complexity certain data structuring problem name 
known split findmin improve bound log 
marginal cost algorithm essentially precisely linear 
theorem gives general result corollaries relate canonical apsp sssp problems respectively 
theorem 
mst min log log log number edges vertices undirected graph bounds ratio edge lengths mst cost computing graph minimum spanning tree 
time space structure built allows computation split findmin time split findmin log represents decision tree complexity split findmin problem inverse ackermann function 
corollary 
undirected apsp problem solved real weighted graph split findmin mn log time 
corollary 
undirected sssp problem solved real weighted graph split findmin mst min log log log min log log log time 
running time sssp algorithm corollary unusual 
consists terms unknown bounded third depends nonstandard parameter maximum ratio edge lengths 
natural question sssp algorithm substantially improved 
section formally define class hierarchy sssp algorithms show comparison undirected sssp algorithm class take time min log log log 
implies sssp algorithm optimal class inverse ackermann factor sssp algorithm improve dijkstra algorithm unbounded 
pettie ramachandran sridhar prs implemented simplified version algorithm 
observed marginal cost prs implementation nearly linear line asymptotic analysis 
little slower dinic implementation din din dijkstra algorithm depends time space consumption 
shortest path algorithm undirected graphs dijkstra algorithm solving sssp faster solving sources shortest path problem cases small 
practical situations sources problem sssp needs solved 
instance graph represents physical network network roads computers change 
situations nearly linear preprocessing cost small price pay efficient shortest path computations 

overview 
section define sssp apsp problems review comparison addition model dijkstra algorithm dij 
section generalize hierarchy approach real weighted graphs give simple proof correctness 
section propose implementations general hierarchy algorithm proving asymptotic bounds theorem simpler uses standard data structures 
running times implementations depend heavily having balanced hierarchy 
section give efficient method constructing balanced hierarchies hierarchical clustering graph minimum spanning tree 
section prove lower bound class hierarchy undirected sssp algorithms 
section discuss avenues research 

preliminaries 
input weighted undirected graph sets vertices edges respectively assigns real length edge 
distance vertex vertex denoted length minimum length path path path minimum length 
apsp problem compute sssp problem compute specified source undirected graph connected component contains edge negative length say distance vertices component construct path arbitrarily small length concatenating path followed repetition sufficient number times followed path loss generality assume assigns positive edge lengths 
slightly restricted problem forbids types paths described shortest simple path problem 
problem np hard generalizes hamiltonian path problem 
edmonds showed negative weight simple cycle problem solvable polynomial time reduction weighted matching see amo 

comparison addition model 
term comparison addition model mean uniform model real numbers subject comparison addition operations 
term comparison addition complexity refers number comparison addition operations ignoring computational costs 
comparison addition model leave unspecified machine model data structuring tasks 
results stated hold machine model ram 
assume pointer machine tar algorithms slow inverse ackermann factor 
comparison addition model aesthetic appeal simplest model appropriate computing shortest paths network opti structure complexity changes ram pointer machine models split findmin structure 
pointer machine matching upper lower bounds lap ram complexity log see appendix seth pettie vijaya ramachandran mization problems 
common belief simplicity necessarily gained price practicality true 
setting algorithms library leda mn important practical data types fully separated algorithms interface generic possible 
room fast algorithms specialized integers floats 
assumptions gains speed surprisingly minor see prs example 

techniques 
algorithm subtraction real numbers operation directly available comparison addition model 
lemma shows simulating subtraction incurs constant factor loss efficiency 
lemma 
comparisons additions subtractions simulated comparison addition model comparisons additions 
proof 
represent real xi ai bi reals ai bi 
addition xi xj ai aj bi bj subtraction xi xj ai bj bi aj simulated actual additions 
comparison xi xj equivalent comparison ai bj aj bi involves actual additions comparison 
key point algorithm need approximate ratio numbers 
division clearly available real numbers comparison addition model little thought see simulated exactly 
lemma bounds time find certain approximate ratios model sufficient purposes 
lemma 
pk real numbers pk smallest largest respectively 
find set integers qi qi pi log pk log log pk time 
qi proof 
generate set log log pk additions pi find qi log log log pk time binary search algorithm pi correspond certain edge lengths 
need approximate ratios lemma source peculiar log log term running time theorem 
note bound stated lemma pessimistic sense 
randomly select pi uniform distribution natural distribution time find approximate ratios reduced high probability linear search binary search 

lower bounds 
lower bounds shortest path problems comparison addition model truly startling 
pan sp showed additions free comparisons necessary solve sssp complete graph 
karger koller phillips proved directed apsp requires mn comparisons summation corresponds path graph 
kerr showed oblivious apsp algorithm performs comparisons stein ks proved fixed sequence edge relaxations solving sssp length mn 
fixed sequence mean depends graph structure 
ahuja observed implementation dijkstra algorithm requires log comparison addition operations 
pettie pet gave true shortest path algorithms satisfy condition 
example algorithm tak han pet pet 
shortest path algorithm undirected graphs min log log lower bound computing directed sssp algorithm bounds ratio edge lengths 
section prove lower bound min log log log hierarchy type algorithms undirected sssp 
lower bounds essentially tight algorithms directed undirected graphs respectively 
graham yao yao proved information theoretic argument prove nontrivial lower bound comparison complexity apsp additions granted free 
simple see nontrivial information theoretic lower bound sssp 

dijkstra algorithm 
algorithm tho hag best understood circumventing limitations dijkstra algorithm 
give brief description dijkstra algorithm order illustrate complexity introduce vocabulary 
vertex set ds denote distance subgraph induced 
dijkstra algorithm maintains tentative distance function set visited vertices satisfying invariant 
henceforth denotes source vertex 
invariant 
source vertex arbitrary vertex ds choosing initial assignment andd clearly satisfies invariant 
dijkstra algorithm consists repeating step times choose vertex minimized set update tentative distances restore invariant 
part involves relaxing edge setting min 
invariant positive weight assumption imply selected 
simple prove relaxing outgoing edges restores invariant 
problem dijkstra algorithm vertices selected increasing distance source task hard sorting numbers 
maintaining invariant demand particular ordering 
fact seen selecting vertex maintain invariant 
hierarchy type algorithms tho hag pet pet maintain invariant generating weaker certificate minimal certificate show 
example dijkstra algorithm presumes negative length edges choice ensures 
clearly sufficient certificate 
dinic version din dijkstra algorithm lower bound min min minimum edge length 
dinic free visit min minimal 
hierarchy type algorithms tho hag pet pet included precompute stronger lower bound min 

hierarchy approach correctness 
section generalize hierarchy approach tho real weighted graphs 
algorithm follows directly proof correctness give kind correctness proof 
denotes set vertices denotes source vertex 
real interval 
notation refers subset seth pettie vijaya ramachandran distance source lies interval 
definition 
vertex set safe ii ds 
words subgraph safe determine distances lie interval looking parts graph outside subgraph clearly finding safe subgraphs potential compute distances cheaply 
definition 
set xi partition xi partition edge xi xj note partition need maximal xk partition xk 
lemma 
suppose safe 
xi partition min xi partition xi min safe ii min safe 
suppose proof 
prove part 
min lemma false ds xi 
assumed safeness know ds 
means shortest path pass xi 
vertex xi shortest path 
definition edge xi length min min definition contradicting selection xi 
part ii claims min safe 
consider definition regarding safeness 
assumption safe definition min min satisfying definition 
assumption safe ds implies weaker statement min ds ds 
thorup noted tho lemma leads simple recursive procedure computing sssp guarantee efficiency 
input procedure safe subgraph task compute set xi performs recursive calls corresponding lemma ii directly consists single vertex 
essentially major obstacles making general algorithm efficient bounding number recursive calls bounding time decide recursive calls computing 
thorup gave simple way choose partitions integer weighted graphs number recursive calls 
adapted directly comparison addition model time decide calls log amounts problem implementing general priority queue 
reduce overhead deciding recursive calls linear balanced hierarchy specialized priority queue exploiting kind balance 
techniques rely heavily graph undirected generalize directed graphs way 
hierarchy type algorithms generalize distance tentative distance notation dijkstra algorithm include just single vertices sets vertices 
set vertices associated set vertices def def min min 
shortest path algorithm undirected graphs procedure generalized visit takes vertex set safe computes distances vertices xi placing vertices set distances known 
maintain invariant times 
definition compute set xi looking parts graph outside ifx happens contain single vertex compute xi directly xi 
general case lemma says compute xi finding partition computing xi phases 
ik subinterval disjoint width ik may leftover interval width si xi ii assumption safe lemma set si ii safe 
compute sk xi series recursive calls follows 
assume current set visited vertices si 
determine xii ii recursive calls form generalized visit ii ii 
start things initialize set empty set values tentative distances invariant call generalized visit 
definition safeness clearly safe 
visit works specification completes invariant satisfied implying vertices 
generalized visit generalized hierarchy type algorithm graphs 
input guarantee safe invariant satisfied 
output guarantee invariant satisfied set call 

contains vertex ds equality invariant second assumption safe 

relax edges incident restoring invariant return 

band positive real xk arbitrary partition xi xi min xi xi generalized visit xi min min lemma 
input guarantees generalized visit met call generalized visit invariant remains satisfied subset visited vertices proof sketch 
base case single vertex simple handle 
turning general case prove time statement examined step safe current value follows treat variable specific vertex set 
time step follows input guarantee generalized visit safe 
similarly input guarantee recursive calls holds lemma 
show safe assignment min definition show min assume inductively output guarantee recursive call generalized visit fulfilled seth pettie vijaya ramachandran completion generalized visit xi min includes set min time loop step generalized visit recursive calls complete proof show min 
ify min clearly imply min 
output guarantee generalized visit clearly satisfied step executed step executed loop finishes safe implying generalized visit simplified minor ways 
seen step need check recursive call taken place case 
step final line shortened change occurrences min crucial procedure correctness 
assumed guaranteed divides procedure prepared deal fractional intervals width section show proper hierarchy fractional interval problem arise 

efficient implementations generalized visit 
propose implementations generalized visit algorithm called visit visit 
time bound claimed theorem proved analyzing visit section 
visit asymptotically fast impractical real world implementation 
section give visit implementation generalized visit uses fewer specialized data structures 
asymptotic running time visit just little slower visit 
visit visit differ generalized visit input output specification slightly 
accepting set vertices generalized visit implementations tho hag pet pet accept hierarchy node represents set vertices 
implementations correctly proper hierarchy defined 
prove bounds running times function certain function different visit visit 
order compute sssp near linear time proper hierarchy satisfy certain balance conditions visit visit 
section give requisite properties balanced hierarchy show construct balanced proper hierarchy mst min log log log time 
definition describes exactly meant hierarchy proper hierarchy 
definition 
hierarchy rooted tree leaf nodes correspond graph vertices 
hierarchy node parent deg number children set descendant leaves equivalent graph vertices diam upper bound diameter diameter defined max 
node value norm 
hierarchy proper hold norm norm ii norm norm integer diam norm iii deg iv children xi norm partition 
refer definition meaning norm partition part iv definition crucial computing shortest paths 
part iii guarantees proper hierarchy nodes 
second part ii admittedly little strange 
allows replace occurrences min shortest path algorithm undirected graphs generalized visit just greatly simplifies analysis algorithms 
part useful bounding total number recursive calls algorithms 

visit 
consider visit procedure 
prove visit correctly computes demonstrating implementation generalized visit proved correct 
visit 
input node proper hierarchy safe invariant satisfied 
output guarantee invariant satisfied set call 

leaf relax edges incident restoring invariant return 

visit called time create bucket array diam norm buckets 
bucket represents interval ax norm ax norm diam ax norm norm 
initialize ax insert children bucket array 
bucket invariant node hin bucket array appears logically bucket interval spans 
xi set bucketed nodes xi norm partition 

band bucket norm norm norm remove bucket array insert children bucket array bucket norm visit norm norm step generalized visit arbitrary partition subset vertices input 
visit input hierarchy node associated vertex set 
represent partition norm set bucketed nodes xi see step sets xi partition 
clearly xi descendants set xi children xi may contain mixture children grandchildren 
consider inner loop step 
assuming inductively bucketed nodes represent norm partition bucketed node norm norm replacing children bucket array produces new norm partition 
follows definitions partitions proper seth pettie vijaya ramachandran case fully aligned norm case aligned norm ax case aligned norm ax ax norm divides ax norm divides norm norm divides ax diam diam diam diam norm norm norm norm fig 

observe ax initialized ax 
ax chosen norm divides ax definition ii norm divides norm puts case norm putting case norm divide norm ax matter ll reach norm anyway 
ax chosen norm divide ax ax diam putting case meaning reach note definition diam definition invariant vertex diam diam 
hierarchies definitions 
bucketed nodes form norm partition easily see recursive calls step visit correspond recursive calls generalized visit 
interval arguments different 
sketch change affect correctness 
generalized visit intervals passed recursive calls form min visit norm 
argue norm main idea show cases portrayed 
norm divides norm ax chosen step norm divides ax freely substitute interval min identical 
note algorithm norm 
problems arise norm divide norm ax 
order prove correctness visit show input guarantee regarding safe ness satisfied recursive call 
consider cases recursive call visit subsequent call 
suppose recursive call visit 
choice ax step ax norm integer orb diam ax diam 
case time outer loop entered strictly speaking hold initial call case root isthe root hierarchy node 
argument goes just fine root denote dummy node norm root 
shortest path algorithm undirected graphs integral implies min norm norm 
consider second case diam ax diam recursive calls visit norm step 
lemma min norm safe norm safe diam implying 
recall definition diam satisfies diam diam 
consider recursive call visit call visit 
definition ii norm multiple norm ora diam identical cases treated 
data structural problems need solved order efficiently implement visit 
need way compute tentative distances hierarchy nodes values defined section 
problem improved version gabow split findmin structure 
problem efficiently implementing various bucket arrays solve new structure called bucket heap 
specifications structures discussed sections respectively 
interested reader refer appendices details implementations split findmin bucket heap proofs respective complexities 

split findmin structure 
split findmin structure operates collection disjoint sequences consisting total elements associated key 
idea maintain smallest key sequence operations 
split split sequence containing sequences elements including rest 
decrease key set key min key 
findmin return element minimum key sequence 
theorem establishes new bounds problem just slightly better gabow original data structure 
refer appendix proof 
thorup tho gave similar data structure integer keys ram model runs linear time 
relies ram ability sort small sets integers linear time fw 
theorem 
split findmin problem solved pointer machine time making log comparisons inverse ackermann function 
alternatively split findmin solved ram time split findmin split findmin log decision tree complexity problem 
split findmin structure maintain values follows 
sequence consisting leaves order consistent depth search traversal leaf maintain appropriate decrease key operations key 
execution visit say node unresolved lies node bucket array tentative distance value finalized 
value node finalized sense decreases step visit removed bucket array passed time recursive call visit 
follows definition invariant atthe recursive call 
verify couple properties unresolved nodes 
seth pettie vijaya ramachandran unvisited leaf exactly unresolved ancestor 
second implement visit need query values unresolved nodes 
maintain unresolved node sequence split findmin structure corresponding descendants suppose previously unresolved node resolved step visit 
deg children immediately unresolved maintain correspondence sequences unresolved nodes perform deg split operations sequence resulting subsequences correspond children 
split findmin structure simplified slightly know advance splits occur 
knowledge affect asymptotic complexity problem 

bucket heap 
turn problem efficiently implementing bucket array visit 
information theoretic bottleneck built comparison addition model bucket nodes constant time comparison extracts bit information properly bucketing bucket array requires extract log diam norm bits information 
thorup tho hagerup hag assume integer edge lengths ram model face limitation 
give specification bucket heap structure supports bucketing operations visit 
structure logically operates sequence buckets implementation really simulation logical structure 
lemma proved appendix bounds complexity implementation bucket heap 
create create new bucket heap buckets associated intervals 
item lies bucket interval spans key 
buckets initially open 
insert insert new item key 
decrease key set key min key 
guaranteed moved closed bucket 
enumerate close open bucket enumerate contents 
lemma 
denote number buckets open bucket time insertion bucket enumerated 
bucket heap implemented pointer machine run log time number operations 
visit called time initialize bucket heap call create norm ax followed number insert operations children key child value 
ax real interval represented bucket array norm width bucket 
time value bucketed node decreases easily detected split findmin structure perform decrease key corresponding item bucket heap 
usually refer buckets cardinal number associated real interval bucket ax ax norm 

analysis visit 
section bound time required compute sssp visit function hierarchy see dominant term running time corresponds split findmin shortest path algorithm undirected graphs structure complexity log turn linear 
lemma 
proper hierarchy 
computing visit takes time split findmin split findmin complexity split findmin problem norm norm diam norm diam log norm proof 
split findmin term represents time relax edges step update relevant values nodes described section 
costs associated updating values time visit linear number recursive calls bucketing costs 
terms represent costs 
consider number calls visit particular step visit zero calls norm norm 
case norm norm recursive calls interval width norm ancestor definition norm norm number recursive calls diam norm extra counts recursive calls may cover negligible parts interval diam 
definition iii total number recursive calls bounded diam norm summation nodes norm values differ parents norm values 
consider bucketing costs visit implemented bucket heap 
steps node bucketed visit called time parent removed open bucket bucket array say bucket norm 
case means norm norm diam 
terminology lemma diam norm total bucketing costs buckets scanned insertions dec keys log diam norm 
section give method constructing proper hierarchy 
bound lemma shows compute sssp split findmin time suitable hierarchy 
asymptotically speaking bound best able achieve 
promising experimental results simplified version algorithm prs led design alternate implementation generalized visit theoretically fast easier code 

practical implementation generalized visit 
section implementation generalized visit called visit 
visit bit slower visit asymptotic sense advantages 
visit visit treats internal hierarchy nodes way generally streamlined 
visit works optimal shelf priority queue fibonacci heap ft 
prove asymptotic running time visit nlog 
log visit visit run optimal time 
pseudocode visit follows 
seth pettie vijaya ramachandran visit 
input node proper hierarchy safe invariant satisfied 
output guarantee invariant satisfied set call 

leaf relax edges incident restoring invariant return 

visit called time put children heap associated key node value 
choose ax visit initialize ax 

band heap nonempty exists heap norm remove heap visit norm set norm proof correctness visit follows lines visit 
easy establish loop step executed norm straightforward implementation generalized visit visit 
norm partition corresponds children visit partition begins children decomposed progressively 
lemma 
proper hierarchy 
computing visit takes time split findmin split findmin complexity split findmin problem diam deg norm proof 
split findmin term plays role visit visit 
visit different visit recursive calls hierarchy nodes just different norm values parents 
argument lemma bound number recursive calls form visit norm gives summation 
assuming optimal heap example fibonacci heap ft decrease keys take time deletions take deg time 
bound deletions follows deg children inserted deleted heap 
section construct hierarchy nlog implying bound visit nlog split findmin nlog 
nlog worst case able construct contrived graphs lower bound tight 

efficient construction balanced hierarchies 
section construct hierarchy works visit visit 
construction procedure distinct phases 
phase find graph minimum span shortest path algorithm undirected graphs ning tree denoted classify edges length 
classification immediately induces coarse hierarchy denoted analogous component hierarchy defined thorup tho integer weighted graphs 
proper run visit visit may result slow sssp algorithm 
particular easily log giving improvement dijkstra algorithm 
phase facilitates phase produce refinement called balanced hierarchy referred earlier 
refined hierarchy constructed minimize terms running times visit visit 
particular nlog 
constructed directly graph minimum spanning tree able prove time bound theorem method 
purpose phase generate collection small auxiliary graphs loosely speaking capture structure edge lengths certain subtrees minimum spanning tree 
auxiliary graphs lieu able construct phase time 
section define notation properties phases sections respectively 
section prove nlog 

definitions properties 

coarse hierarchy 
refined hierarchy derived coarse hierarchy defined section 
typically simple describe general definition complicated take account certain extreme circumstances 
defined increasing sequence norm values norm norm edge lengths large norm 
typically true general 
say edge level alternatively may write norm express level level subgraph maximal connected subgraph restricted edges level length strictly 
level zero subgraphs consist single vertices 
level node corresponds nonredundant level subgraph level subgraph redundant level subgraph 
property guarantees nonleaf nodes children 
ancestor relationship clear ancestor subgraph contained subgraph 
leaves naturally correspond graph vertices internal nodes subgraphs 
coarse hierarchy clearly satisfies definition iii iv careful choosing norm values want proper hierarchy satisfy definition ii 
method choosing norm values deferred section 

minimum spanning tree 
cut property minimum spanning trees see clrs pr identical minimum spanning tree mst remainder section mainly concerned graph 
set vertices minimal connected subtree containing notice include vertices outside need rooted tree order talk coherently vertex parent ancestors children 
assume rooted arbitrary vertex 
notation root refers root subtree 
seth pettie vijaya ramachandran 
mass diameter 
mass vertex set defined mass def 
extending notation mass mass hierarchy 
mst path vertices upper bound shortest path mass bound diameter 
recall definition diam denoted upper bound diameter henceforth freely substitute mass diam 

refinement coarse hierarchy 
say refinement nodes represented equivalent definition provides better imagery derived replacing node rooted subhierarchy root corresponds referred leaves correspond children 
consider refinement internal node satisfies deg norm norm 
easily verify definitions proper hierarchy course order linear near linear satisfy certain properties 
particular sufficiently short balanced 
balanced mean node mass smaller parent mass 
lambda values 
values order quantify precisely notion balance lemma gives lower bound growth values give short proof moving 
lemma 
min log proof 
sq stack example 
prove giving lemma 
verify statement holds 
assume holds definition inductive assumption holds 
third line follows inequality holds 

ranks 
recall section refined hierarchy derived replacing node subhierarchy 
assign nodes nonnegative integer rank 
analysis construction simple rank node mass norm 
ideal situation nature construction allow place nontrivial lower upper bounds mass assign ranks order satisfy property ensures sufficiently shortest path algorithm undirected graphs approximation ideal 
mainly internal nodes ranks assign ranks leaves representing children close ideal possible 
point assignment ranks purpose analysis 
rank information stored explicitly hierarchy nodes rank information implicitly explicitly computation shortest paths 
refer ranks construction analyzing effect functions 
property 

internal node norm norm deg 
child rank maximal mass norm 
child rank node 
call mass norm 
node child 
rank children divided sets singleton mass mass norm 
nodes specific rank 
mass mass 
moving examine features property 
part asserted guarantee proper 
part shows set rank leaves 
part says child node half ideal mass part little technical basically says rank node mass may huge children divided sets reasonable mass norm 
bound placed mass contributed part says restrict attention nodes particular rank subgraphs overlap places 
see subgraphs overlap consider xi set nodes rank 
construction case vertex sets xi disjoint imply subtrees xi edge disjoint xi general larger xi 
show section refinement satisfies property nlog 
recall lemmas terms running times visit visit respectively 

phase mst coarse hierarchy 
pettie ramachandran pr gave mst algorithm runs time proportional decision tree complexity mst problem 
complexity mst trivially known unknown cost dominate dominated split findmin term 
issue mainly theoretical interest 
analysis mst denote cost computing mst 
may interpreted decision tree complexity mst pr randomized complexity mst known linear kkt pr 
recall section defined arbitrary increasing sequence norm values 
describe exactly norm values chosen prove proper hierarchy 
method depends large ratio maximum minimum edge length minimum spanning tree 
easily determined time possible min log min minimum edge length graph 
en edges nondecreasing seth pettie vijaya ramachandran order length ej ej indices mark large separations ei sequence 
possible norm values ej ej ej 
definition ith largest norm value edge norm 
notice edge length falls interval unused 
need keep track norm values 
lemma 
coarse hierarchy proper hierarchy 
proof 
observed parts iii iv definition satisfied monotonically increasing sequence norm values 
definition ii states hierarchy node norm norm integer diam norm 
suppose hierarchy node norm norm integral norm ej norm ej 
method choosing norm values lengths mst edges ej ej edges length ej ej diam ej ej norm 
lemma 
compute minimum spanning tree norm ino mst min log log log time 
proof 
mst represents time find lemma find norm log log log log log time 
log log log simply sort edges determine indices log time 
suppose nj edges norm form ej ej nj need generate nj log values form ej list nj log log possible norm values easily generated sorted order 
merging list list mst edge lengths determine norm log time 
lemma come handy bounding running time preprocessing sssp algorithms 
says total normalized mass linear variations lemma core hierarchy approach tho hag pet pet 
lemma 
mass 
norm proof 
recall notation norm stands ith largest norm value 
observe mst edge norm included mass levels 
follows definitions mst edge norm 
bound normalized mass mass norm norm norm norm norm 
shortest path algorithm undirected graphs black vertices fig 

left subtree mst set vertices 
center minimal subtree connecting right derived splicing degree nodes adjusting edge lengths appropriately 
marked edges example length 
implicit lemma simple accounting scheme treat mass accurately normalized mass currency equivalent computational 
hierarchy node owns mass norm units currency 
show share computation relating bounded times currency total time computation kn course computation attributable hierarchy node 
simple accounting scheme powerful quite involved pet pet pet 

phase constructing trees 
possible construct satisfies property working directly subtree unable efficiently compute way 
problem time roughly proportional size construct significantly larger 
solution construct succinct tree preserves essential structure having size roughly 
subtree derived single child vertices replace chain vertices vertices potentially single edge length edge sum corresponding edge lengths 
correspondence vertices refer vertices names gives examples trees set vertices 
xj set children tree root xj note root included root xj edges represented possible total length significantly total length mass require subgraph roughly mass equivalent subgraph 
order accomplish attribute certain amounts mass vertices follows 
suppose child root corresponding root vertex 
mass mass 
vertices zero mass mass subtree sum edge lengths plus collective mass vertices 
think subtree corresponding subtree 
edge corresponds naturally path vertex nonzero mass corresponds subtree 
lemma 
deg deg ii subtree corresponding tree 
seth pettie vijaya ramachandran traversed root tx lca root tx new new fig 

vertices represent known 
active path traversal shown bold edges 
processed left stack consists vertex traversal known lca implies 
processed right stack set 
mass mass mass 
proof 
part follows observations 
degree vertices 
second deg leaves leaf corresponds vertex root child 
part ii follows mass represented edge contributes mass edge vertex 
construct kind depth traversal minimum spanning tree procedure succinct tree 
succinct tree focuses fixed node explain succinct tree works aid diagram 
point traversal maintain stack vertices uq consisting vertices known parents fixed 
stack properties ui ancestral ui uq active path traversal uq vertex known encountered traversal 
stack consists active path traversal marked bold edges 
preprocessing making recursive calls root xj update stack reflect new knowledge edges vertices 
vertex lca uq lca 
cases ultimate penultimate vertex stack uq uq know lies path uq uq 
diagrams third situation 
vertices encountered traversal uq new vertices discovered path uq pop uq stack designating parent push stack 
situations uq uq simpler 
uq simply push stack uq stack push 
consider postprocessing performed recursive calls uq uq vertices stack 
suppose uq 
simply active path retracts stack vertices uq uq outside active path contrary stack properties 
vertices discovered uq uq safely say uq shortest path algorithm undirected graphs parent uq 
maintain stack properties pop uq add edge uq uq tot 
succinct tree procedure constructing 
argument vertex mst stack consists vertices uq known parents known 
uq active path dfs traversal 
initially stack empty 

root child 
lca uq 
uq 
pop uq stack 
designate uq edge 
uq 
push stack 
push stack 
call succinct tree children 
uq uq refer elements current stack 
uq 
pop uq stack 
designate uq uq uq edge lemma 
mst list edges ordered level constructed time 
proof 
construct union find structure mark vertices roots 
easy see construct tree traversal procedure succinct tree 
simply maintain different stack tx construction 
root yi simply lines succinct tree roles 
known union find common ancestors lca algorithm ahu tar compute line time number finds linear number nodes 
scheme buchsbaum cost finding linear algorithm offline handle lca queries middle tree traversal ahu tar need determine lca queries initial pass tree 
compute length function follows 
ancestral dm root dm root dm distance function clearly dm root function computed time 
see lemma simulation subtraction comparison addition model 

phase constructing refined hierarchy 
show section construct consistent property 
refine hierarchy procedure pseudocode constructs bottom fashion traversing tree 
call refine hierarchy seth pettie vijaya ramachandran produce array sets elements nodes represent collectively subtree rooted set holds rank nodes taken massive rank node 
extend mass notation sets follows 
bear mind mass tree 
lemma ii mass approximation mass equivalent subtree mass mass refine hierarchy constructing vertex 

initialize 
root child 
maximal mass norm 
implicitly designated rank node 
child 
refine hierarchy 

maximal mass norm 
promote see definition 
root promote node remains 
final node root 
structure refine hierarchy fairly simple 
initialize array empty sets 
root vertex child create node representing put proper set set receives depends mass 
process children pass loop pick unprocessed child recurse producing sets representing subtree rooted merge sets counterparts 
point mass sets may critical threshold threshold norm 
order restore quiescent state sets perform promotions set mass threshold 
definition 
promoting set involves removing nodes making children new rank node placing node 
exception comply definition iii simply move node 
promoting sets means promoting order 
suppose merging maximal mass threshold norm need 
promote sets effect emptying adding new node representing nodes 
lemma shows compute trees linear time 
lemma 
constructed satisfy property time 
proof 
argue refine hierarchy produces refinement satisfies property 
look implement linear time 
shortest path algorithm undirected graphs property states internal nodes norm values equal satisfy simply assigning proper norm values node child 
treatment element sets promotion procedure definition simply impossible create child node 
property follows lemma ii observation mass represented nodes rank disjoint 
consider property regarding nodes 
show set accepts new node immediately promoted promotion represents promotion construction 
consider pattern promotions line 
promote sets cascading fashion 
set accepting new node immediately promoted order prove property show node derived promoting 
choice mass norm mass tree 
lemma ii mass equivalent tree norm exactly threshold node 
consider property 
merging step line sets massive promoted 
denote sets associated merging step denote set associated step 
definition mass mass mass mass norm 
edge arbitrarily large compared norm meaning place reasonable bound mass merging step 
consider property maintained 
suppose promoted lines resulting rank node 
terminology property node derived promoting 
sufficiently massive promoted merged mass mass norm 
slightly stronger property calls inequality 
ll see needed 
suppose implemented refine hierarchy straightforward manner 
known maximum possible index nonempty set course refine hierarchy 
easily see initialization lines takes time exclusive recursive calls time line takes amortized time 
bound line amortized promoting set takes worst case time constant amortized time 
hidden costs procedure updating mass sets done follows 
merging step line simply set mass mass mass total cost computing iso 
bound log follows 
node placed previously empty set lemma maximum nonempty set rank log mass norm 
lemma ii construction mass mass norm 
order reduce cost linear couple adjustments refine hierarchy procedure 
represented linked list nonempty sets 
second update mass variables lazy fashion 
time steps dominated time find appropriate step takes time see seth pettie vijaya ramachandran 
time merging sets line proportional shorter list time bound expression 
log mass norm log min mass mass norm mass just total mass represented sets 
update mass sets rule update half 
routine show refine hierarchy lower bound mass factor function leads conspicuous property 
bound cost refine hierarchy model computation binary tree leaves represent creation nodes lines internal nodes represent merging events line 
cost leaf log mass norm cost internal node children log min mass norm mass norm 
think charging cost collectively mass subtree whichever smaller 
unit mass charged nodes total mass twice total mass total cost cost mass norm log mass norm equality follows mass norm mass norm 
summing total cost constructing lemma 
lemma 
mst min log log log time construct coarse hierarchy refinement satisfying property 
proof 
proof follows lemmas 

analysis 
section prove bounds running times visit visit appropriate refined hierarchy constructed section 
theorem follows directly lemma lemma 
lemma 
refinement satisfying property 
visit computes sssp split findmin time visit computes sssp nlog time 
proof 
prove nlog 
lemmas complete proof 
observation mass upper bound diameter substitute mass diam functions 
lemma sum 
sum sum nodes just nodes appear 
property lemma maximum rank node proof somewhat tedious 
basically shows mass updated times mass updated 
neglecting update mass causes negligible error 
shortest path algorithm undirected graphs log mass norm log property total mass nodes rank bounded mass 
bound sum mass norm log mass norm nlog lemma 
turn second summations written deg log mass norm deg respectively 
deg mass norm bound established summation extend second 
rank node 
terms property mass mass norm mass norm 
property imply deg represents child child property deg log mass norm log see explanations max log mass norm line follows bound deg definitions 
second line follows log max log 
line follows log 
bound property deg log mass norm mass norm 
lemma second summations bounded 

limits hierarchy type algorithms 
section state simple property property hierarchy type algorithms give lower bound undirected sssp algorithm satisfying property 
upshot sssp algorithm optimal inverse ackermann factor fairly large class sssp algorithms includes hierarchy type algorithms variations dijkstra algorithm heuristic sssp algorithm :10.1.1.10.3772
state property terms directed graphs 
cycles denote set cycles including cycles pass sep min cycles 
note undirected graphs sep corresponds exactly longest edge mst path property 
sssp algorithm hierarchy property computes aside shortest paths permutation vertices find sep source distance function 
permutation corresponds order vertices visited source property says loosely sorted distance may invert pairs vertices relative distance sep value 
see hierarchy algorithm satisfies property consider vertices lca ancestors respectively children construction norm sep 
sep norm recursive calls cause visited passed interval argument intervals width norm 
recursive call seth pettie vijaya ramachandran 
group group group fig 

minimum spanning tree graph 
precede recursive call visited theorem 
suppose computational model allows set functions comparison reals 
sssp algorithm real weighted graphs satisfying property min log log log operations worst case ratio maximum minimum edge length 
proof 
integer 
assume loss generality divides 
mst input graph depicted 
consists source vertex connected vertices top row paired vertex bottom row 
vertices divided disjoint groups group consists exactly randomly chosen pairs vertices 
exactly 
possible group arrangements 
show algorithm satisfying property able distinguish 
choose edge lengths follows 
edges group length includes edges group top row rows 
non mst edges chosen shortest paths correspond paths mst 
vi denote vertex bottom row group vi sep vi vj max property vi visited vj vi sep vi vj vj true algorithm satisfying property prepared visit vertices distinct permutations log log log comparisons worst case 
include non mst edge operation gives lower bound 
theorem shows sssp algorithm optimal hierarchy type algorithms tiny inverse ackermann factor 
lower bound directed sssp algorithms satisfying property pet 
theorem differs lower bound respects 
pet bound min log log log reasonably small values second pet bound holds algorithm allowed compute sep function sort values free 
contrast sssp algorithm main obstacle achieving linear time need sort sep values 

discussion 
shown near linear time investment preprocessing sssp queries answered close linear time 
furthermore natural class sssp algorithms captured property sssp algorithm optimal aside tiny inverse ackermann factor 
imagine shortest path algorithm undirected graphs avenues research interesting developing feasible alternative property intrinsic sorting bottleneck 
backward approach algorithm design define desirable property hunt algorithms property 
avenue real world impact reduce preprocessing cost directed shortest path algorithm pet mn near linear algorithm 
marginal cost computing sssp algorithm may may linear depends complexity split findmin structure 
data structure invented gabow weighted matching algorithm connections fundamental problems 
instance solve minimum spanning tree shortest path tree sensitivity analysis problems pet 
sensitivity analysis problem decide edge length perturbed changing solution tree 
theorem problems complexity log log improvement tarjan path compression algorithm tar 
consider offline version split findmin problem splits decrease keys advance show reducible mst problem mst sensitivity analysis problem 
reductions proves mst dominates split findmin vice versa suggest hope solving mst problem pr pr solving manifestly simpler split findmin mst sensitivity analysis problems 
experimental study pettie ramachandran sridhar prs shows algorithm efficient practice 
prs study explore possible implementation choices proper heap best preprocessing algorithm different implementations split findmin structure 
knowledge investigated hierarchy type algorithms tho hag pet competitive real world scenarios 
outstanding research problem parallel computing bound time complexity sssp 
published algorithms subject cmms ks tz runs worst case polylogarithmic time comparable dijkstra algorithm 
clearly lot parallelism hierarchy algorithms 
approach effectively parallelized intriguing question 
appendix bucket heap 
bucket heap structure consists array buckets ith bucket spans interval fixed reals 
logically speaking heap item key appears bucket interval spans 
concerned relative order items bucket 
proof lemma 
structure simulates logical specification consists levels bucket arrays 
level zero buckets ones referred bucket heap specification level buckets disjoint intervals level zero buckets 
interval represented higher level bucket union component level zero buckets 
bucket level active closed level zero buckets see 
suppose item logically level zero bucket maintain invariant descending lowest active bucket active bucket level zero buckets insert node put open level zero bucket label ascending 
clearly satisfies invariant 
result decrease key depends seth pettie vijaya ramachandran closed buckets marked active buckets shaded level effect closing open bucket fig 

active buckets shaded 
node ascending descending 
suppose ascending bucket level spanning interval 
key relabel descending 
descending just relabeled descending move lowest level active bucket consistent invariant 
drops levels assume accomplished time search current level bottom 
suppose close open level zero bucket invariant items logically descending enumerating problem general ascending items logically belong 
order maintain invariant deactivate active buckets including 
consider bucket level move descending node level active bucket 
ascending node level depending key move level active bucket keep ascending relabel descending move proper active bucket level 
invariant follows node appears log distinct buckets log buckets ascending node log descending node 
aside cost moving nodes costs clearly 
bucket heap need label items 
item ascending descending inferred context 
appendix split findmin problem 
split findmin problem maintain collection sequences weighted elements operations split split sequence containing sequences elements including rest 
decrease key set key min key 
findmin return element sequence minimum key 
gabow gave elegant algorithm problem nearly optimal 
initial sequence elements handles splits decrease keys time 
gabow algorithm runs pointer machine tar 
prove theorem section 
proof theorem 
gabow decrease key routine sequence roughly variables needs updated known values shortest path algorithm undirected graphs monotonically decreasing 
observe pointer machine task accomplished time log comparisons binary search 
simple level scheme easily reduce term running time gives split findmin algorithm performs log comparisons 
get potentially faster algorithm ram model construct possible split findmin solvers inputs log log elements choose close optimal problem sizes 
show compose optimal split findmin solver elements gabow structure get optimal solver elements 
consider instances decrease keys 
decrease keys encountered revert gabow algorithm trivial runs time 
represent state solver components bit vector length representing splits directed graph vertices representing known inequalities current keys older keys retired decrease key operations mapping elements vertices may easily confirm state represented log bits 
may confirm split decrease key update state time 
turn findmin operation 
consider findmin action function determines step findmin procedure 
represented findmin action state represents argument findmin query 
function perform comparison represented performed alter state return answer findmin query represented second 
simply applies findmin action function produces answer 
represent findmin action function table 
state represented log bits keep machine word computing findmin action function updating state takes constant time ram 
see split findmin solver converted loss efficiency performs comparisons calls findmin 
finding optimal findmin action function tantamount finding optimal solver 
reduced split findmin problem brute force search findmin action function 
distinct findmin action functions produce correct answers 
distinct instances problem number decrease keys splits furthermore operation split findmin giving term decrease key requires choose element fit new key permutation giving term 
findmin action problem instance pair tested correctness time correct findmin action functions chosen time log log meaning time brute force search affect constant factors involved 
choose optimal split findmin solver 
trivial question possibility solver dominates seth pettie vijaya ramachandran input sizes 
consider charting worst case complexity solver function gs number operations input sequence 
plausible certain solvers optimal certain densities need show solver gs constant factor lower envelope gs ranges correct solvers 
sk optimal solver operations 
solver mimics sk operations operation resets state operations sk continues sk operation gsk gsk follows gs mins gs 
algorithm simple 
divide elements representing contiguous block elements 
unsplit sequence consists parts subsequences leftmost rightmost third subsequence consisting unsplit 
gabow algorithm unsplit key minimum constituent elements 
split split findmin solver constructed 
cost gabow algorithm cost split findmin construction cost split findmin 
easily extend proof randomized split findmin solvers defining findmin action selecting distribution actions 
note time bound theorem pointer machines provably optimal 
la lap gave lower bound pointer machine complexity split find problem subsumed split findmin problem 
results section address ram complexity decision tree complexity unrelated la result 
agm alon galil margalit exponent pairs shortest path problem comput 
system sci pp 

ahu aho hopcroft ullman finding lowest common ancestors trees siam comput pp 

amo ahuja orlin network flows theory algorithms applications prentice hall englewood cliffs nj 
ahuja mehlhorn orlin tarjan faster algorithms shortest path problem acm pp 

buchsbaum kaplan rogers westbrook linear time pointer machine algorithms mst verification dominators proceedings th acm symposium theory computing stoc dallas tx acm new york pp 

tr aff parallel priority queue constant time operations parallel distrib 
comput pp 

chazelle minimum spanning tree algorithm inverse ackermann type complexity acm pp 

clrs cormen leiserson rivest stein algorithms mit press cambridge ma 
cmms mehlhorn meyer sanders parallelization dijkstra shortest path algorithm proceedings rd international symposium mathematical foundations computer science mfcs lecture notes comput 
sci 
springer new york pp 

dij dijkstra note problems connexion graphs numer 
math pp 

din dinic economical algorithms finding shortest paths network transportation modeling systems pp 
russian 
shortest path algorithm undirected graphs din personal communication ben gurion university er israel 
fg frieze grimmett shortest path problem graphs random arc lengths discrete appl 
math pp 

fr rao planar graphs negative weight edges shortest paths near linear time proceedings nd ieee symposium foundations computer science focs las vegas nv ieee press piscataway nj pp 

frederickson planar graph decomposition pairs shortest paths acm pp 

fredman new bounds complexity shortest path problem siam comput pp 

ft fredman tarjan fibonacci heaps uses improved network optimization algorithms acm pp 

fw fredman willard surpassing information theoretic bound fusion trees comput 
system sci pp 

goldberg simple shortest path algorithm linear average time proceedings th european symposium algorithms esa lecture notes comput :10.1.1.10.3772
sci 
springer new york pp 

gabow scaling algorithm weighted matching general graphs proceedings th ieee symposium foundations computer science focs portland ieee press piscataway nj pp 

gabow scaling algorithms network problems comput 
system sci pp 

goldberg scaling algorithms shortest paths problem siam comput pp 

gm galil margalit pairs shortest distances graphs small integer length edges inform 
comput pp 

gr goldberg rao flow decomposition barrier acm pp 

gt gabow tarjan faster scaling algorithms network problems siam comput pp 

gt gabow tarjan faster scaling algorithms general graph matching problems acm pp 

graham yao yao information bounds weak shortest distance problem acm pp 

hag hagerup improved shortest paths word ram proceedings th international colloquium automata languages programming icalp lecture notes comput 
sci 
springer new york pp 

hag hagerup simpler computation single source shortest paths linear average time proceedings st annual symposium theoretical aspects computer science stacs montpellier france springer new york pp 

han han improved algorithm pairs shortest paths inform 
process 
lett pp 

henzinger klein rao subramanian faster shortest path algorithms planar graphs comput 
system sci pp 

ht han thorup integer sorting log log expected time linear space proceedings rd annual symposium foundations computer science focs vancouver ieee press piscataway nj pp 

johnson efficient algorithms shortest paths sparse networks acm pp 

kerr effect algebraic structure computational complexity matrix multiplication technical report tr computer science department cornell university ithaca ny 
karger koller phillips finding hidden path time bounds pairs shortest paths siam comput pp 

kkt karger klein tarjan randomized linear time algorithm finding minimum spanning trees acm pp 

ks klein subramanian randomized parallel algorithm single source shortest paths algorithms pp 

ks stein finding real valued single source shortest paths expected time algorithms pp 

seth pettie vijaya ramachandran lap lower bounds union find split find problem pointer machines comput 
system sci pp 

meyer single source shortest paths arbitrary directed graphs linear time proceedings th annual acm siam symposium discrete algorithms soda washington dc siam philadelphia pp 

meyer buckets strike back improved parallel shortest paths proceedings th international parallel distributed processing symposium ipdps ft lauderdale fl ieee computer society press los alamitos ca pp 

mit mitchell geometric shortest paths network optimization handbook computational geometry north holland amsterdam pp :10.1.1.56.2239

mn mehlhorn leda platform combinatorial geometric computing cambridge university press cambridge uk 
mt moffat takaoka pairs shortest path algorithm expected time log siam comput pp 

pet pettie comparison addition complexity pairs shortest paths proceedings th international symposium algorithms computation isaac vancouver springer new york pp 

pet pettie shortest path minimum spanning tree problems ph thesis department computer sciences university texas austin austin tx available online technical report tr www cs utexas edu ftp pub techreports tr ps gz 
pet pettie new approach pairs shortest paths real weighted graphs special issue selected papers th international automata languages programming icalp theoret 
comput 
sci pp 

pr pettie ramachandran computing shortest paths comparisons additions proceedings th annual acm siam symposium discrete algorithms soda san francisco ca siam philadelphia pp 

pr pettie ramachandran minimizing randomness minimum spanning tree parallel connectivity set maxima algorithms proceedings th annual acm siam symposium discrete algorithms soda san francisco ca siam philadelphia pp 

pr pettie ramachandran optimal minimum spanning tree algorithm acm pp 

prs pettie ramachandran sridhar experimental evaluation new shortest path algorithm proceedings th workshop algorithm engineering experiments san francisco ca springer new york pp 

sei seidel pairs shortest path problem unweighted undirected graphs comput 
system sci pp 

sp pan finding updating spanning trees shortest paths siam comput pp 

spi new algorithm finding shortest paths graph positive arcs average time log siam comput pp 

sz zwick pairs shortest paths undirected graphs integer weights proceedings th annual ieee symposium foundations computer science focs new york ieee press piscataway nj pp 

tak takaoka new upper bound complexity pairs shortest path problem inform 
process 
lett pp 

tak takaoka cost algorithms pairs shortest path problem algorithmica pp 

tar tarjan class algorithms require nonlinear time maintain disjoint sets comput 
system sci pp 

tar tarjan applications path compression balanced trees acm pp 

tar tarjan sensitivity analysis minimum spanning trees shortest path trees inform 
process 
lett pp 
corrigendum inform 
process 
lett 
tho thorup floats integers single source shortest paths algorithms pp 

shortest path algorithm undirected graphs tho thorup integer priority queues decrease key constant time single source shortest paths problem proceedings th annual acm symposium theory computing stoc san diego ca acm new york pp 

tho thorup undirected single source shortest paths positive integer weights linear time acm pp 

tz tr ff simple parallel algorithm single source shortest path problem planar digraphs parallel algorithms irregularly structured problems lecture notes comput 
sci 
springer new york pp 

zwick exact approximate distances graphs survey proceedings th european symposium algorithms esa university aarhus denmark pp 
available online www cs tau ac il zwick 
zwick pairs shortest paths bridging sets rectangular matrix multiplication acm pp 

zwick slightly improved sub cubic algorithm pairs shortest paths problem real edge lengths proceedings th international symposium algorithms computation isaac lecture notes comput 
sci 
springer new york pp 

