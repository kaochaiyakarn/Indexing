dynamic compilation framework controlling microprocessor energy performance qiang wu wu jin lee dan connors david brooks margaret martonosi douglas clark depts 
computer science electrical engineering princeton university dept electrical computer engineering colorado boulder programming systems lab corporate tech 
group intel division engineering applied science harvard university mrm doug princeton edu wu jin lee intel com vijay colorado edu eecs harvard edu dynamic voltage frequency scaling dvfs effective technique controlling microprocessor energy performance 
existing dvfs techniques primarily hardware os static compiler techniques 
substantially greater gains realized control opportunities explored dynamic compilation environment 
advantages deploying dvfs managing energy performance tradeoffs dynamic compiler 
importantly dynamic compiler driven dvfs fine grained code aware adaptive current microarchitecture environment 
presents design framework run time dvfs optimizer general dynamic compilation system 
prototype dvfs optimizer implemented integrated dynamic compilation system 
obtained optimization system deployed real hardware platform directly measures cpu voltage current accurate power energy readings 
experimental results physical measurements spec olden benchmarks show significant energy savings achieved little performance degradation 
spec fp benchmarks benefit energy savings performance loss 
addition spec int show energy savings performance loss spec fp save performance loss olden save performance loss 
average technique leads energy delay product edp improvement better static voltage scaling vs better reported dvfs results prior static compiler 
proposed technique effective method microprocessor voltage frequency control design framework methodology described broader potential address energy power issues di dt thermal control 

dynamic voltage frequency scaling dvfs effective technique microprocessor energy power control implemented modern processors 
current practice dvfs control os power scheduling management os selects new voltage setting new application task scheduled processor switched idle active states 
focus fine grained intra task dvfs voltage fre proceedings th annual ieee acm international symposium microarchitecture micro ieee quency scaled program execution take advantage application phase changes 
significant research efforts devoted dvfs control hardware os time interrupt static compiler techniques :10.1.1.60.8609
brief description existing techniques available section 
little done explore dvfs control opportunities dynamic compilation optimization environment 
consider dynamic compiler dvfs techniques optimize application binary code insert dvfs control instructions program execution time 
dynamic compiler run time software system compiles modifies optimizes program instruction sequence runs 
years dynamic compilation increasingly important foundation run time optimization binary translation information security 
examples dynamic compiler infrastructures include hp dynamo ibm daisy intel ia el intel pin :10.1.1.12.7138
dvfs implementations allow direct software control mode set instructions accessing special mode set registers dynamic compiler insert dvfs mode set instructions application binary code run time 
exists cpu execution slack cpu idle cycles waiting memory instructions scale cpu voltage frequency save energy little impact performance 
dynamic compiler driven dvfs offers unique features advantages approaches 
importantly fine grained code aware hardware os interrupt schemes 
adaptive runtime environment static compiler dvfs 
section give statistical results motivate dynamic compiler driven dvfs discuss advantages disadvantages 
presents design framework run time dvfs optimizer rdo dynamic compilation environment 
key design issues considered include code region selection dvfs decision code insertion transformation 
particular propose new dvfs decision algorithm analytic dvfs decision model 
prototype rdo implemented integrated industrial strength dynamic optimization system variant intel pin system 
obtained optimization system deployed real hardware platform intel development board pentium processor allows directly measure cpu current voltage accurate power energy readings 
evaluation experiments phys misses thousands average cache misses time instructions number cache misses instructions retired execution spec benchmark applu 
numbers mark memory characteristic phases 
symbol marks recurring point program phases 
ical measurements spec olden benchmarks 
evaluation results show significant energy efficiency achieved 
example energy savings performance loss accomplished spec benchmarks 
average technique leads energy delay product edp improvements spec fp spec fp spec int olden benchmarks 
average results better static voltage scaling vs vs vs vs better vs reported static compiler dvfs scheme 
main contributions twofold 
designed implemented run time dvfs optimizer deployed real hardware physical power measurements 
optimization system effective terms energy performance efficiency compared existing approaches 
second knowledge efforts develop dynamic compiler techniques microprocessor voltage frequency control 
previous provides partial solution java method dvfs java virtual machine provide complete design framework apply dvfs general dynamic compilation environment general applications 
structure rest follows 
section motivates dynamic compiler dvfs 
section presents design framework rdo 
section describes implementation deployment rdo system 
followed experimental results section 
section highlights related 
section discusses 
offered section 
dynamic compiler driven dvfs 
section discuss detail unique features advantages disadvantages dynamic compiler driven dvfs compared existing dvfs techniques 
advantages hardware os dvfs existing hardware os time interrupt dvfs techniques typically monitor system statistics issue queue occupancy fixed time intervals decide dvfs settings time intervals 
time intervals pre determined independent program structure dvfs control methods may efficient adapting program phase changes 
reason program phase changes proceedings th annual ieee acm international symposium microarchitecture micro ieee memory transactions average memory bus transactions qsort input size millions average number memory bus transactions instructions function qsort different input sizes different input patterns random input versus pre sorted input 
generally caused invocation different code regions observed 
hardware os techniques may able infer application code attributes find effective adaptation points 
reason program phase changes recurrent loops 
case hardware os schemes need detect adapt recurring phase changes repeatedly 
illustrate reasoning shows example trace program phase changes spec benchmark applu 
trace part program instructions 
axis number cache misses instructions program execution 
results section obtained hardware performance counters processor setup described section 
see distinct memory phases characterized different cache values duration 
shown section phases correspond distinct code regions functions program 
see phase changes recurrent shown marked points 
compiler driven dvfs schemes static dynamic apply dvfs fine grained code regions adapt naturally program phase changes 
hardware os dvfs schemes fixed intervals lack fine grained code aware adaptation 
advantages static compiler dvfs existing compiler dvfs primarily static compiler techniques 
typically profiling learn program behavior 
offline analysis techniques linear programming decide dvfs settings code regions 
limitation static compiler dvfs due different runtime environments profiler actual program dvfs setting obtained static compile time may appropriate program runtime 
reasoning dvfs decisions dependent program memory boundedness cpu slowed waiting memory operation completion 
program behavior term memory boundedness turn dependent run time system settings machine architecture configuration program input size patterns 
example machine architecture settings cache configuration memory bus speed may affect cpu slack idle time exists 
different program input sizes patterns may affect memory going 
illustration shows average number memory bus transactions instructions function qsort table examples different memory behavior spec programs train inputs 
average num cache misses instructions mem average num memory bus transactions inst sweep means th loop function sweep benchmark code train region mem mem su cor corr su cor sweep mgrid mg lucas bzip transform 
curve random input elements different input sizes curve pre sorted input elements 
shows average numbers memory bus transactions vary significantly different input sizes input patterns 
surprisingly larger input sizes lead cache misses memory bus transactions 
example small program illustration table shows examples different memory behavior spec programs train inputs 
show average number cache misses average number memory bus transactions instructions example code regions 
similarly see numbers may different input changed train vice versa 
observation see different input sizes patterns different dvfs needed best energy performance results 
qsort example aggressive lower dvfs setting large input size take advantage memory boundedness program save energy 
conversely conservative higher dvfs setting small input size avoid excessive performance losses 
spec benchmark su cor table code region function sweep need different dvfs settings different input sets 
empirical experience intel pentium processor shows assuming performance loss constraint code region clocked ghz input clocked maximum ghz train input 
inherently difficult static compiler dvfs decisions adaptive factors dynamic compiler dvfs utilize run time system information input adaptive architecture adaptive decisions 
disadvantages challenges having discussed advantages point dynamic compiler dvfs disadvantages 
significant just dynamic optimization technique cycle spent optimization cycle lost execution optimizations performed side line optimizations chip multiple processor 
challenge dynamic compiler driven dvfs design simple inexpensive analysis decision algorithms order minimize run time optimization cost 

design framework dvfs decision algorithms section design framework run time dvfs optimizer rdo dynamic compilation optimization environment 
start considering key design issues start dispatcher monitor dynamic optimizer cold code execution proceedings th annual ieee acm international symposium microarchitecture micro ieee hot code execution os hardware run time dvfs optimizer rdo block diagram showing operation interactions different components dynamic compiler dvfs optimization system 
general 
give detailed design new dvfs decision algorithm 
key design issues candidate code region selection dynamic optimization techniques want optimize frequently executed code regions called hot code regions order cost effective 
addition dvfs relative slow process voltage transition rate typically mv want optimize long running code regions 
design choose functions loops candidate code regions 
dynamic optimization systems equipped light weight profiling mechanism identify hot code regions example profiles possible loop target extend existing profiling infrastructure monitor identify hot functions loops 
dvfs decisions candidate code region important step decide beneficial apply dvfs operate lower voltage frequency save energy significant impact performance appropriate dvfs setting mentioned earlier dynamic optimization system analysis decision algorithm needs simple fast minimize overhead 
offline analysis techniques static compiler dvfs typically time consuming appropriate 
designed fast dvfs decision algorithm analytical decision model uses hardware feedback information 
dvfs code insertion transformation candidate code region beneficial dvfs dvfs mode set instructions inserted entry point code region start dvfs exit point code region restore voltage level 
design question adjusted regions want program 
existing static compiler algorithms choose single dvfs code region program avoid excessively long analysis time 
design allow identify multiple dvfs regions provide energy saving opportunities 
things complicated dvfs regions nested 
child region nested parent region child may know dvfs setting parent exit points 
provide design solutions 
maintain relation graph run time allow parent region scaled 
dvfs setting stacked parent child regions scaled 
addition code insertion dynamic compiler perform code transformation create energy saving opportunities 
example merge separate small memory bound code regions big 
course need check code merging hurt performance correctness program 
exist interactions dvfs optimizer conventional performance optimizer 
operation block diagram block diagram shows operation interactions different components dynamic compiler dvfs optimization system 
start dynamic optimizer dispatches patches original binary code delivers code execution hardware 
moment system cold code execution mode 
cold code executed dynamic optimization system monitors identifies frequently executed hot code regions 
rdo optimization applied hot code regions conventional performance optimizations conducted 
hot code region rdo optimization applied program execution multiple times call periodic re optimization 
lastly code transformation desirable rdo query regular performance optimizer check feasibility code transformation 
describe detail key design component dvfs decision algorithm 
dvfs decision algorithms dvfs decisions rdo inserts testing decision code entry exit points candidate code region 
candidate region viewed single entry multiple exits code region 
testing decision code collects run time information number cache misses memory bus transactions code region 
information collected rdo decides appropriate dvfs setting candidate code region collected information rdo setup 
decision rdo removes testing decision code prepares possible dvfs code insertion transformation 
testing steps assume candidate code region relatively stable slowly varying run time characteristics input 
obtained decision testing information valid rest program execution valid re optimization point choose periodic re optimizations 
note assumption shown reasonable valid practice studies 
key testing step dvfs decision making 
mentioned earlier order beneficial dvfs code region needs long running easily checked 
harder question long running code region decide beneficial dvfs appropriate dvfs setting answer question look analytical decision model dvfs 
analytical decision model dvfs discussion analysis model section assume goal energy control minimize energy consumption subject performance constraints 
note analytical model different objective thermal control different 
general scaling cpu voltage frequency certainly reduce processor power consumption slow cpu execution speed resulting energy delay product improvement low negative 
key insight beneficial dvfs saves energy little mem memory operation proceedings th annual ieee acm international symposium microarchitecture micro ieee cpu operation concurrent dependent execution time analytical decision model dvfs 
mem asynchronous memory access time number execution cycles concurrent cpu operation number cycles dependent cpu operation cpu frequency 
performance impact exists asynchronous memory system independent cpu clock times slower cpu 
identify cpu execution slack cpu stall idle cycles waiting completion memory operations scale cpu voltage frequency save energy performance impact 
rationale shows analytical decision model dvfs extension analytical model proposed 
processor operations categorized groups memory operation cpu operation 
memory asynchronous respect cpu frequency denote time memory operation mem 
cpu operation time separated parts part cpu operations run concurrently memory operations part cpu operations depend final results pending memory operations 
cpu operation time dependent cpu frequency denote concurrent cpu operation time number clock cycles concurrent cpu operation 
similarly denote dependent cpu operation time 
note actual program execution memory operation cpu operation concurrent dependent interleaved 
analytical model execution model lumping occurrences category 
treatment 
see overlap period memory bound mem exists cpu slack time defined cpu slack time mem ideally concurrent cpu operation slowed consume cpu slack time 
model want decide frequency scaling factor candidate code region 
original clock frequency new clock frequency voltage scaled accordingly 
assume execution time candidate code region categorized 
frequency scaling effects cpu operation 
increase concurrent cpu operation time reduce cpu slack time 
second dependent cpu operation time cause performance loss 
give detailed method select compute scaling factor 
dvfs selection method introduce new concept called relative cpu slack time 
definition cpu slack time define mem relative cpu slack time total time total time total execution time 
memory bound case total time mem see larger relative cpu slack frequency reduction system affecting performance 
frequency reduction proportional relative cpu slack time 
mem total time total time constant coefficient 
note value chosen relatively large aggressive energy reduction relatively small preserve performance 
take account effect maximum allowed performance loss replace mem total time total time intuitively equation means scaling factor negatively proportional memory intensity level term mem positively proportional cpu intensity level term 
time ratios equation estimated hardware feedback information hardware performance counter hpc events 
example processor time ratios equation estimated ratios hpc events 
mem total time total time num mem bus transactions num ops retired num fp int instructions num ops retired hpc event number memory bus transaction section measure memory busy ness 
second hpc event total number ops retired 
ratio events estimate relative memory busy ness 
similarly hpc event number fp int instruction retired outstanding memory operation 
second event number ops retired 
ratio hpc event estimate concurrent cpu busy ness 
constant coefficients depend machine configurations estimated empirically reset installation time dynamic compiler 
method computes directly runtime hardware information simple fast 
downside formulation relatively ad hoc especially way considers constraint 
developed alternative method precise handling performance constraint complicated computes separate sub factors details omitted due space limit 
see alternative method complement method 

implementation deployment methodology experience implemented prototype proposed run time dvfs optimizer rdo integrated rdo real dynamic compilation system 
evaluate results live system physical power measurements 
start instrument code region profiling functions plus loops main executing code region hot 
dvfs decision check memory remove profiling instrumentation insert dvfs instruction proceedings th annual ieee acm international symposium microarchitecture micro ieee memory bound 
cpu bound 
application execution remove profiling instrumentation jit instrument loops inside function long running function loops 
medium case operation flow diagram prototype implementation rdo 
implementation intel pin system basic software platform implement dvfs algorithm develop rdo 
pin dynamic instrumentation compilation system developed intel publicly available 
pin system regular pin modified suited convenient dynamic optimizations 
convenience refer pin optimization pin 
compared standard pin package pin added features support dynamic optimizations adaptive code replacement instrumented code update replace run time customized trace code region selection 
addition pin jit executes generated code pin takes partial jit approach executes mix original code generated code 
example pin configured patch instrument profile original code coarse granularity function calls 
run time selectively generates jit code fine grained profiling optimization dynamically compiled code loops inside function 
pin operation overhead compared regular pin 
shows operation flow graph prototype implementation rdo system 
start rdo instruments function calls program loops main function order monitor identify frequently executed code regions 
strongly connected components call graph treated single nodes 
candidate code region hot execution count greater hot threshold dvfs testing decision code started collect run time information decide memory bound code region code region memory bound rdo remove instrumentation code insert dvfs mode set instructions resume program execution 
hand code region cpu bound dvfs instructions inserted 
medium case candidate code region may exhibit mixed memory behavior contains memory bound cpu bound sub regions 
case rdo check long running function containing loops 
copy function running system signal conditioning unit data acquisition unit data logging unit measurement noise reduction sampling reading processing unit processor power measurement setup 
setup consists components 
system diagram showing cpu voltage current measurement points marked development board 
dynamically generated loops inside function identified instrumented 
process continues 
dvfs selection method section check memory boundedness code region select dvfs setting 
required hpc events equation number memory bus transactions number ops retired countable hpc events provided pentium processor 
core hardware platform discussed subsection 
hpc event equation estimate time ratio available pentium total time processors 
approximate estimation new ratio obtained available related hpc events 
ways choose hpc events 
implementation ratio number ops retired number instructions retired 
empirical experience larger ratio concurrent cpu instructions code region 
note section show inverse ratio average number instructions ops retired 
scaling factor obtained dvfs decision algorithm choose actual dvfs setting code region new old 
existing processors limited number dvfs setting points pick setting point close desired dvfs setting 
desired setting available setting points pick identify loops linear time loop analysis techniques 
implementation reduce run time analysis overhead simple fast loop identification heuristic 
loop identified conditional branch going higher address lower address 
experience shows heuristic works quite applications practice 
proceedings th annual ieee acm international symposium microarchitecture micro ieee conservative higher 
course fine grained dvfs settings available better control effectiveness 
deployment real system deployed rdo system real running system 
hardware platform intel development board pentium processor gme fw db shown 
pentium processor maximum clock frequency ghz caches unified cache 
board mhz bus ddr ram 
dvfs settings called pentium expressed frequency voltage pairs ghz ghz ghz ghz mhz mhz 
voltage transition rate dvfs mv measurements 
os linux kernel gcc updated 
implemented loadable kernel modules provide user level support dvfs control hpc reading form system calls 
system allows accurate power measurements 
procedure power measurements collect sampling points cpu voltage current values compute power trace total energy sampling points 
shows processor power measurement setup includes components detailed 
running system voltage current measurement unit unit isolates measures cpu voltage current signals 
reason isolating measuring cpu power power board want deterministic accurate results affected random factors board 
system diagram showing cpu voltage current measurement points marked gme development board 
seen output sense resistors main voltage regulator precision resistors measure current going cpu measure voltage drop bulk capacitor measure cpu voltage 
note shown simply measure power supply line going voltage regulator obtained power reading undesirably include power consumed components cpu hub 
signal conditioning unit unit reduces measurement noise get accurate readings 
measurement noise inevitable noise sources cpu board 
particular voltage drop sense resistor table statistical results obtained spec benchmarks 
average number ops name means th loop name total total region total average average average dvfs benchmark hot dvfs name ops cache memory inst setting regions regions misses trans hz th loop main tomcatv th loop main th loop main th loop main hydro check applu rhs gcc mem candidate regions dvfs mcf primal net simplex crafty mem candidate regions dvfs mp mp gap order mv noise order mv practice noise system times larger measured signal 
noise typically higher frequency measured signals layer low pass filter reduce measurement noise includes national instrument ni signal conditioning module ai simple rc filter shown 
filters able reduce relative noise error 
data acquisition daq unit unit samples reads voltage current signals 
order capture program behavior variations especially dvfs fast sampling rate required 
ni data acquisition system maximum sampling rate aggregate shown 
measurement channels needed cpu current cpu voltage set sampling rate channel total 
gives sample length channel 
minimum voltage transition time sampling length adequate 
data logging processing unit host logging machine processes sampling data 
seconds daq unit sends collected data host logging machine high speed fire wire cable 
channel samples stored internal buffer daq unit sent 
logging machine processes received data 
regular laptop running ni labview daq software process data 
configured labview various tasks monitoring raw data recording power energy computation 

experimental results experimental setup experiments software hardware platforms described previous sections 
run time dvfs optimization system set performance loss constraint 
larger resulting frequency settings lower allowing aggressive energy savings 
conversely smaller lead larger conservative dvfs settings 
candidate code region hot threshold chosen code region hot executed times 
results sensitive value proceedings th annual ieee acm international symposium microarchitecture micro ieee varied 
voltage transition time different machine set long running threshold code region described dvfs algorithm section ms cycles ghz processor bigger voltage transition time 
nested functions handle relation graph described section evaluation spec fp spec int benchmarks 
previous static compiler dvfs spec fp benchmarks include benchmark suites 
addition include olden benchmarks popular integer benchmarks study program memory behavior 
benchmark intel fortran compiler get application binary compiled 
test benchmark largest ref input set running completion 
power performance results reported average results obtained separate runs 
illustrate give insight rdo operation table shows statistical results obtained rdo system spec benchmarks 
table give total number hot code regions program total number dvfs regions identified 
dvfs code region show total number ops retired code region single invocation average cache misses average number memory bus transactions average number instructions retired ops obtained dvfs settings 
dvfs settings average number memory bus transactions average number instructions retired 
general higher numbers lower dvfs setting 
benchmark hydro example see numbers contributed final dvfs settings 
quantitative relationship numbers dvfs setting formulas section 
available frequency voltage settings system obtained needs rounded available frequency point 
see number dvfs opportunities identified rdo ranges large low ghz tomcatv small dvfs gcc 
order look closely rdo operation exam olden manipulates different kinds data organizations structures ranging linked list heterogeneous octree 
choose benchmarks cover kinds data organizations studied 
voltage power ghz mhz cpu voltage power ghz ghz time seconds partial trace cpu voltage power spec benchmark applu running rdo ine detail particular benchmark applu 
recall section observed recurring memory phase behavior applu 
analysis rdo reveals phase changes mainly caused invocations different functions shown table 
functions different memory behavior terms average number cache misses average number memory bus transactions 
note observation consistent behavior shown 
inserting dvfs instruction directly code regions rdo adjusts cpu voltage frequency adapt program phase changes frequency settings ghz regions ghz ghz region 
shows part cpu voltage power trace applu running rdo 
compare figures section interesting see cpu voltage frequency adjusted adapt recurring phase changes shown lower clock frequencies corresponding higher cache misses 
power trace interesting 
initially fluctuates value due different system switching activities 
program execution enters dvfs code regions power drops dramatically level low shown experimental results section dvfs optimization applied code regions applu led considerable energy savings little performance loss 
energy performance results view run time dvfs optimizer rdo addition regular dynamic performance optimization system shown 
isolate contribution dvfs optimization report energy performance results relative pin system dvfs want mix effect dvfs optimization underlying dynamic compilation optimization system developed heavily researchers intel colorado 
addition comparison report energy results static voltage scaling simply scales supply voltage frequency statically benchmarks get roughly proceedings th annual ieee acm international symposium microarchitecture micro ieee table average results benchmark suite rdo versus 
benchmark performance energy energy delay suite degradation savings product improvement rdo static rdo static rdo static spec fp spec fp spec int olden amount average performance loss results 
chose ghz static voltage scaling voltage setting point system get average performance loss close 
figures show performance loss energy savings energy delay product edp improvement results spec fp spec fp int olden benchmarks 
note results taken account dvfs optimization overhead time cost check memory boundedness code region 
convenience refer result runtime dvfs optimizer rdo refer results static voltage scaling 
interesting observations 
terms edp improvement rdo outperforms static scale big margin nearly benchmarks 
shows efficiency design fast effective dvfs decisions 
second energy performance results individual benchmarks benchmark suite vary significantly 
high achieved energy savings performance loss spec fp tomcatv energy savings performance loss spec fp swim energy savings performance loss spec int mcf energy savings performance loss olden benchmarks health 
low see close slightly negative edp improvement benchmarks benchmark suite 
understand reasons see efficiency dvfs control largely constrained memory boundedness application 
memory bound application opportunities energy saving potentials dvfs 
relative experimental system large cache benchmarks show variety memory boundedness leads variety edp results 
see distribution spec int edp results concentrated close low distribution olden spec fp edp results spread high low 
average results benchmark suite summarized table 
show results techniques results 
average achieved edp improvement spec fp spec fp spec int olden benchmarks 
represent fold better results compared edp improvement spec fp spec fp spec int olden benchmarks 
average spec int edp result relatively lower compared benchmark suites 
spec int benchmarks cpu bound shown previous studies 
intrinsic floating versus integer data 
just amount memory traffic 
want rough comparison static compiler dvfs results reported energy performance numbers 
able re implement optimizer replicate experiments 
compared tomcatv tomcatv tomcatv swim swim swim su cor su cor su cor hydro hydro hydro mgrid mgrid mgrid applu applu applu turb turb apsi fpppp energy savings apsi fpppp edp improvement turb apsi fpppp wave wave wave fp avg fp avg fp avg performance degradation swim swim swim mgrid mgrid mgrid applu applu applu mesa mesa mesa art art art equake equake equake ammp ammp ammp rdo lucas lucas lucas fma fma fma apsi rdo apsi performance degradation energy savings energy delay product edp improvement spec fp benchmarks left spec fp benchmarks right 
show results runtime dvfs optimizer rdo andthe voltage scaling 
reported results spec fp benchmarks average performance loss energy savings edp improvement achieved average energy savings amount performance loss 
apart dynamic versus static benefits described section key factors contributing different results 
static compiler dvfs algorithm picks single dvfs code region program avoid excessive offline analysis time online dvfs design identify multiple dvfs code regions program long beneficial illustrated examples table 
second decision algorithm offline timing profiling code region algorithm microarchitecture oriented directly uses information run time environment hardware proceedings th annual ieee acm international symposium microarchitecture micro ieee rdo performance counts 
results figures table show proposed technique promising addressing energy performance control problem microprocessors 
attribute promising results efficiency design advantages dynamic compiler driven approach 
basic pin overhead dynamic optimization system basic setup operation overhead time spent basic setup monitor identify frequently executed code regions 
overhead offset amortized subsequent performance optimization gain see net performance improvement 
shown dynamic optimizer aggressive performance apsi avg avg avg gzip gzip gzip vpr vpr vpr gcc gcc gcc mcf mcf mcf crafty crafty crafty performance degradation parser parser parser eon eon eon perlbmk perlbmk gap energy savings gap edp improvement perlbmk gap vortex vortex vortex bzip bzip bzip twolf twolf twolf kint avg kint avg kint avg bh bh bh em em em rdo health health health mst mst mst perimeter perimeter perimeter power rdo power performance degradation energy savings energy delay product edp improvement spec int benchmarks left olden benchmarks right 
show results runtime dvfs optimizer rdo voltage scaling 
optimizations significant performance gains various benchmarks 
pin system dynamic optimization infrastructure include implemented performance optimizations 
users infrastructure implement performance optimizations loop unrolling data prefetching scope 
compared native application basic pin system negative performance gain 
words performance energy overhead associated basic pin infrastructure 
give complete picture show results pin dvfs relative native 
shows performance energy overhead basic pin infrastructure computed relative native 
proceedings th annual ieee acm international symposium microarchitecture micro ieee rdo see individual benchmarks performance overhead low benchmarks gzip swim high benchmarks gcc 
average performance overhead pin spec fp spec fp spec int olden benchmarks 
energy overhead values similar 
note values significantly lower basic overhead regular pin system low overhead implementation pin described section 
look dvfs results scheme computed inherited infrastructure overhead edp numbers lower subsection expected 
average edp improvement inherited overhead spec fp spec fp spec int power olden avg olden avg olden avg tomcatv gzip swim vpr su cor gcc hydro mgrid mcf applu crafty turb parser apsi eon pin overhead fpppp wave fp avg pin overhead perlbmk gap vortex swim bzip mgrid twolf applu mesa kint avg bh art equake em ammp health performance energy lucas fma performance performance energy overhead basic pin infrastructure applying optimizations 
olden benchmarks 
general clearly promising results 
discussion micro architectural suggestions experimental results section desirable potential upper bound dvfs numbers show far results upper bound numbers 
open research question effectively accurately compute upper bound dvfs results 
possible way estimate upper bound extend mathematical formulation optimizing multiple sequential scaling points optimizing multiple dvfs code regions 
leave possible exploration 
experimental results section promising improved micro architectural support available 
possible support logic identify predict cpu execution slack proposed 
dvfs computation easier accurate 
possible support power aware hardware monitoring counters events monitor power consumption processor unit voltage variations 
addition finegrained dvfs settings intra task dvfs design effective 
experience shows code regions benchmarks rdo forced select unnecessarily high voltage frequency setting due lack middle steps current pentium processors 

related mentioned nearly existing dvfs schemes hardware os static compiler techniques :10.1.1.60.8609
little done direction dynamic compiler driven dvfs 
proceedings th annual ieee acm international symposium microarchitecture micro ieee energy piece related direction java virtual machine dvfs 
similar sense run time software decide dvfs settings application 
differs aspect 
java virtual machine target java applications granularity java method general dynamic optimization system target general applications fine grained granularity including code regions loops 
second dvfs algorithm take account memory boundedness code region assume execution time code region scales linearly frequency matter memory bound 
dvfs algorithm assumes sort time budget called projected time compares current execution time time budget decide scale 
treatment suitable multimedia applications pre determined time budget frame suitable general applications 
contrast dvfs algorithm considers memory boundedness code region works general applications 
third power evaluation simulation evaluation live system physical power measurements 

possible avenues 
focus new concept dynamic compiler driven dvfs design framework 
direct follow look specific design issues techniques depth code transformation periodic re optimization dvfs 
deeper analysis done experimental results breakdown results benefits regions different contributing factors 
real system opposed simulation challenging break results benefits mst perimeter power apsi avg olden avg effective way 
possible implement conventional performance optimizations loop unrolling data prefetching study interactions energy optimizations performance optimizations run time system 
addition new processors allow dvfs memory bus 
possible direction generalize analytical decision model dvfs algorithm case cpu memory dvfs 

represents efforts developing dynamic compilation framework microprocessor energy performance control 
focus dynamic voltage frequency scaling dvfs 
specifically reasoning statistical results highlight unique features advantages dynamic compiler driven dvfs existing techniques 
design framework run time dvfs optimizer general dynamic compilation system 
described methodology reported experiences implementing deploying run time dvfs optimization system 
experimental results physical measurements show spec benchmarks benefit energy savings performance loss 
average results spec olden benchmarks show technique leads energy delay product edp improvement better static voltage scaling better reported static compiler dvfs scheme 
attribute promising results efficiency design fast effective decisions multiple code regions advantages dynamic compiler driven approach terms fine grained phase adaptation ability utilize accurate run time information 
proposed technique effective method microprocessor voltage frequency control design framework methodology described generalized emerging microprocessor issues di dt thermal control 
pilot studies shown dynamic compiler feedback information collaborating hardware control system provide novel approach tackling di dt problem 
feel proposed dynamic compilation framework great potential addressing energy performance power control problem modern processors 
acknowledgments ulrich kremer chung hsu luk robert cohn kim helpful discussions development anonymous reviewers useful comments suggestions 
supported part nsf ccr itr cns ccf intel ibm src 

pin manuals apis 
rogue colorado edu pin index html august 
bala duesterwald banerjia :10.1.1.12.7138
dynamo transparent dynamic optimization system 
proceedings pldi june 
wang 
ia execution layer phase dynamic translator designed support ia applications itanium systems 
proc 
th micro dec 
proceedings th annual ieee acm international symposium microarchitecture micro ieee brock rajamani 
dynamic power management embedded systems 
proceedings ieee soc conference sep 
amarasinghe 
infrastructure adaptive dynamic optimization 
proceedings march 
carlisle rogers reppy andl hendren 
early experiences olden 
proceedings th international workshop languages compilers parallel computing august 
choi soma pedram 
fine grained dynamic voltage frequency scaling precise energy performance trade ratio chip access chip computation times 
proceedings date feb 
ebcioglu altman 
daisy dynamic compilation architectural compatibility 
proceedings isca june 
fields bodik hill 
slack maximizing performance technological constraints 
proceedings isca may 
shamir 
intel pentium processor power estimation budgeting optimization validation 
intel technology journal 
ronen intel pentium processor microarchitecture performance 
intel technology journal 
probst franz 
virtual machine driven dynamic voltage scaling 
technical report cs university california irvine ca oct 
brooks 
eliminating voltage emergencies microarchitectural voltage control feedback dynamic optimization 
proceedings islped august 
hsu kremer 
design implementation evaluation compiler algorithm cpu energy reduction 
proc 
pldi pages june 
huang torrellas 
positional adaptation processors application energy reduction 
proceedings isca june 
hughes adve 
formal approach frequent energy adaptations multimedia applications 
proc 
st isca june 
intel santa clara ca 
intel architecture software developer manual volume system programming guide 
luk cohn muth muth patil lowney wallace 
pin building customized program analysis tools dynamic instrumentation 
proceedings pldi june 
marculescu 
microarchitecture driven dynamic voltage scaling 
workshop complexity effective design vancouver canada june june 
steven muchnick 
advanced compiler design implementation 
morgan kaufman publishers 
national instruments 
data acquisition daq hardware www ni com 
semeraro dwarkadas scott 
dynamic frequency voltage control multiple clock domain microarchitecture 
proc 
th micro pages november 

process cruise control event driven clock scaling dynamic power management 
proceedings case oct 
xie martonosi malik 
bounds power savings runtime dynamic voltage frequency scaling exact algorithm linear time heuristic approximation 
proc 
islped august 
fen xie margaret martonosi sharad malik 
compile time dynamic voltage scaling settings opportunities limits 
proc 
pldi june 
wu quek fang 
accuracy initial prediction phase dynamic binary translators 
proceedings march 
