efficiently computing static single assignment form control dependence graph ron cytron jeanne ferrante barry rosen mark wegman ibm research division kenneth zadeck brown university optimizing compilers data structure choices directly influence power efficiency practical program optimization 
poor choice data structure inhibit optimization slow compilation point advanced optimization features undesirable 
static single assignment form control dependence graph proposed represent data flow control flow programs 
previously unrelated techniques lends efficiency power useful class program optimization 
structures attractive difficulty construction potential size discouraged 
new algorithms efficiently compute data structures arbitrary control flow graphs 
algorithms dominance frontiers new concept may applications 
give analytical experimental evidence data structures usually linear size original program 
presents strong evidence structures practical optimization 
categories subject descriptors programming languages language constructs control structures data types structures procedures functions subroutines programming languages processors compilers optimization algebraic manipulation algorithms analysis algorithms artificial intelligence automatic programming program transformation preliminary version efficient method computing static single assignment form appeared conference record th acm symposium principles programming languages jan 
zadeck partially supported ibm office naval research defense advanced research projects agency contract arpa order amendment 
authors ac ferrante wegman computer sciences department ibm research division box yorktown heights ny rosen mathematical sciences department ibm research division box yorktown heights ny zadeck computer science department box brown university providence ri 
permission copy fee part material granted provided copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
acm acm transact ons programmmg languages systems vo october le pages ron cytron general terms algorithms languages additional key words phrases control dependence control flow graph clef chain dominator optimizing compilers 
optimizing compilers data structure choices directly influence power efficiency practical program optimization 
poor choice data structure inhibit optimization slow compilation point advanced optimization features undesirable 
static single assignment ssa form control dependence graph proposed represent data flow control flow properties programs 
previously unrelated techniques lends efficiency power useful class program optimizations 
structures attractive difficulty construction potential size discouraged 
new algorithms efficiently compute data structures arbitrary control flow graphs 
algorithms dominance frontiers new concept may applications 
give analytical experimental evidence sum sizes dominance frontiers usually linear size original program 
presents strong evidence ssa form control dependence practical optimization 
illustrates role ssa form compiler 
intermediate code put ssa form optimized various ways translated back ssa form 
optimizations benefit ssa form include code motion elimination partial redundancies constant propagation discussed section 
variants ssa form detecting program equivalence increasing parallelism imperative programs 
represen tation simple data flow information clef chains may compact ssa form 
variable definitions uses clef chains 
similar information encoded ssa form def chains number edges control flow graph 
clef information encoded ssa form updated easily optimizations applied 
important constant propagation algorithm deletes branches code proven compile time 
specifically def information just list variable places program text variable 
value provided unique assignment see intuition ssa form helpful straight line code 
assignment variable unique name shown subscript uses reached assignment renamed match assignment new name 
programs branch join nodes 
join nodes add special form assignment called function 
acm transactions programming languages systems vol 
october static single assignment form control dependence graph opt intermediate code intermediate code 
pn fig 
vertical arrows represent translation static single assignment form horizontal arrows represent optimizations vi vi fig 

straight line code single assignment version 
vi vf times 
fig 
assignment version 

operands function indicate assignments reach join point 
subsequent uses uses 
old variable replaced new variables vl vz vi reached just assignment vi 
assignment vi entire program 
simplifies record keeping 
especially clear example constant propagation ssa form subsection sketches application 
constant propagation elaborate version 
branch includes test propagating constant true tells compiler branch falls join point 
constant true uses join point really uses constant 
possibilities taken account ssa form processing costly difficult understand 
ssa form algorithm fast simple 
initially algorithm assumes edge followed run time variable constant unknown value denoted 
worklists initialized appropriately assumptions corrected stabilize 
suppose algorithm finds variable constant denoted branch acm transactions programming languages systems vol 

october 
ron cytron vi return return 

fig example propagation outer conditional may 
outedges test ofp marked executable statements reach processed 
vi processed assumption vi changed uses vi notified uses 
value single assignment property 
particular function combines vz 
second operand function point corresponds falling branch 
long edge considered algorithm uses second operand matter currently sumed vz 
combining yields uses tentatively assumed uses 
eventually assumption may change known constant change false lead discovery second join point followed vz combines vi yield 
change true effect assumption 
traditional constant propagation algorithms hand see assign ments different constants reach uses join point 
decide constant uses 
algorithm just sketched linear size ssa program sees size nonlinear size original program 
particular safe inefficient place function variable join point 
shows obtain ssa form efficiently 
functions placed carefully nonlinear behavior possible practice 
size ssa program typically linear size original program time essentially linear ssa size 
place functions glance careful placement require enumeration pairs assignment statements variable 
checking assignments reach common point intrinsically nonlinear 
fact look domi nance fi node control flow graph 
leaving technicalities sections sketch method 
acm transactions programming languages systems vol october static single assignment form control dependence graph suppose variable just assignment original program value entry program value vi execution assignment basic block code assigns determine value control flows edge basic block entered code see vi unaffected 
paths go case said strictly dominate code ways see vi 
node strictly dominated see vl matter far may 
eventually control may able reach node strictly dominated suppose node path sees vi may see 
said dominance frontier clearly need function general matter assignments may appear original program matter complex control flow may place functions finding dominance frontier node assigns dominance frontier node function placed 
concept dominance frontiers computing ssa form compute control dependence identify conditions affecting statement execution 
informally statement control dependent branch edge branch definitely causes statement execute edge cause statement skipped 
information vital detection parallelism program optimization program analysis 
outline rest section reviews representation control flow directed graph section explains ssa form sketches construct 
section considers variants ssa form defined 
algorithm adjusted deal variants 
section reviews dominator tree concept formalizes dominance frontiers 
show compute ssa form section control dependence graph section efficiently 
section explains translate ssa form 
section shows algorithms linear size programs restricted certain control structures 
give evidence general linear behavior reporting experiments fortran programs 
section summarizes algo rithms time bounds compares technique techniques presents 

control flow graphs statements program organized necessarily maximal basic blocks program flow enters basic block statement leaves basic block statement 
basic blocks indicated column numbers parentheses 
control graph directed graph nodes basic blocks program additional nodes entry exit 
edge entry acm transactions programming languages systems vol 
october ron cytron repeat ktk print repeat fig simple pro flow graph basic block program entered edge exit basic block exit program 
reasons related representation control dependence explained section edge entry exit 
edges graph represent transfers control jumps basic blocks 
assume node path entry path exit 
node successor node edge graph set successors similarly predecessors 
node successor branch node node predecessor join node 
variable considered assignment entry represent value variable may program entered 
assignment treated just ones appear explicitly code 
cfg denotes control flow graph program discussion 
nonnegative integer path length cfg consists sequence nodes denoted xo xj sequence edges denoted 
ej runs xj 
write ej 
usual sequences item node edge may occur times 
null path acm transactions programmmg languages systems vol october static single assignment form control dependence graph allowed 
write xj unrestricted path xj known nonnull 
nonnull paths xj yo yk said converge node yo xj yk xj 
intuitively paths start different nodes node disjoint come 
deliberate 
paths may happen cycle need consider possibility convergence 

static single assignment form section initially assumes programs expanded intermediate form statement evaluates expressions uses results determine branch assign variables 
program constructs considered section assignment statement form lhs rhs left hand side lhs tuple distinct target variables 
right hand side rhs tuple expressions length lhs tuple 
target variable lhs assigned corresponding value rhs 
examples discussed tuples tuples need distinguish 
section sketches longer tuples expanding program constructs proce dure calls explicit variables changed statements source program 
explicitness prerequisite optimization anyway 
novelty tuples fact provide simple uniform way fold results analysis intermediate text 
practical concerns size inte ate text addressed section 
translating program ssa form step process 
step trivial functions 
inserted join nodes program control flow graph 
second step new variables 
generated 
mention variable program replaced mention new variables mention may branch expression side assignment statement assignment statement may ordinary assignment function 
displays result translating simple program ssa form 
function entrance node form 

variables 
number operands number control flow predecessors predecessors listed arbitrary fixed order jth operand associated jth acm transactions programming languages systems vol 
october 
ron cytron repeat jl kl tl repeat ji print print repeat repeat fig simple program 
predecessor 
reaches jth predecessor run time remembers executing functions value 
just value jth operand 
execution uses ofthe operands depends flow control just entering functions executed ordinary statements variants functions defined useful special purposes 
example function tagged ssa form intermediate form need provide support 
semantics important assessing correctness intermediate steps sequence program transformations code functions useful give parameter incidentally encodes various restrictions control flow 
acm transactions programming languages systems vol 
october static single assignment form control dependence graph node appears 
control flow language suitably restricted function tagged information conditionals loops :10.1.1.24.3070
algorithms apply variants 
ssa form may considered property single program oy relation programs 
single program defined ssa form variable target exactly assignment statement program text 
translation ssa form replaces original program new program control flow graph 
original variable conditions required new program nonnull paths converge node nodes contain assignments original program trivial function 
inserted new program 
mention original program inserted replaced mention new variable leaving new program ssa form 
control flow path consider variable original program corresponding new program 
vi value 
translation minimal ssa form translation ssa form proviso number functions inserted small possible subject condition 
optimizations depend ssa form valid extraneous functions appear minimal ssa form 
extraneous functions cause information lost add unnecessary overhead optimization process 
important place functions required 
variant ssa form forego placing function convergence point long uses function omitted risk losing condition 
called pruned ssa form preferable placement convergence points 
section illustrates form preferable pruned form 
desired pruned ssa form obtained simple adjustment algorithm section 
variable nodes insert functions original program defined recursively condition definition ssa form 
node needs function convergence point paths originate different nodes nodes containing assignments needing functions may observe node needs function convergence point nonnull paths start nodes containing assignments contain assignment function inserted adds set nodes contain assignments nodes consider origins paths may observe nodes appearing convergence points acm transactions programming languages systems vol 
october 
ron cytron nonnull paths originating nodes assignments set nodes needing functions iterating observation insertion cycle 
algorithm obtains results time 
program constructs source program computes expressions constants scalar variables assign values scalar variables straightforward derive intermediate text ready put ssa form analyzed transformed optimizing compiler 
source programs commonly constructs variables scalars computations explicitly indicate variables change 
section sketches map important constructs explicit intermediate text suitable compiler 
arrays 
suffice consider dimensional arrays 
arrays higher dimension involve notation concerns 
array variables array assignment statements allowed source language treated just assignments scalar variables 
mentions source program mentions index may taken integer variable 
treating variable awkward assignment may may change value value changed assigning 
easier approach illustrated 
entire array treated single scalar variable may operands access update 
expression access evaluates ith component expression update evaluates array value size component values value jth component 
assigning scalar value equivalent assigning array value entire array new array value depends old index new scalar value translation ssa form values variables large objects operators mean 
scalars translation array ssa form removes anti output dependences 
program dependence analysis may prohibit reordering statement definition second statement 
translation ssa form renamed reordering possible 
example statements execute concurrently 
optimiza tion reorder section describes transla typical cases paths originating functions add contributions paths originating ordinary assignments 
straightforward iteration slow typical cases notation similar select update turn similar notation referencing aggregate structures data flow language 
acm transactions programming languages systems vol 
october static single assignment form control dependence graph access access update access access fig 

source code array component equivalent code explicit access update operators treat array just scalar 
ssa form proceeds usual 
tion ssa form reclaims storage necessary maintain distinct variables 
consider loop shown assigns component array value assigned component depend indirectly values previously assigned components terms effect loop assignment form 
assignment component entering initialization loop dead code eliminated 
ssa form update operator appear live entry loop 
reasonable response update operator accept 
address calculations genuine scalar calculations optimized extensively 
response perform dependence analy sis determine subsequent accesses require values produced assignment case execution assignment 
assignment statement viewed initialization problem uses update arrays scalars communicate results dependence analysis optimizations dead code elimination usually formulated terms scalar variables 
simple solution formal problem shown operator mention assigned array operand 
actual code generated assignment expression exactly assignment corresponding update expression hidden operand supplied target assignment 
structures 
structure generally regarded array structure fields treated elements array 
assignment structure field translated update structure structure field translated access structure 
prevalent case simple structure field treatment results arrays elements indexed constants 
dependence analysis determine independence accesses optimization may move assignment field far assignment field 
analysis language semantics reveals structure fields accessed acm transactions programming languages systems vol 
ron cytron integer oo integer ao loo il repeat repeat integer loo integer ii fio update lz iz iz integer ao loo integer loo integer il repeat fig 
source loop array assignment equivalent code update operator treats array just scalar section explains eventual translation ssa form leave just array purely formal way results dependency analysis available 
structure decomposed distinct variables 
elements structures united source program organizational reasons expression structure decomposition ssa form program actual structure apparent subsequent optimization 
implicit variables 
construction ssa form requires knowing variables modified statement 
addition variables explicitly referenced statement may modify variables mentioned statement 
examples implicit global variables modified procedure call aliased variables dereferenced pointer variables 
obtain ssa form account implicit explicit assumptions analysis 
heap storage conservatively mod representing entire heap single variable modified statement may change heap 
refined modeling possible conservative approach strong support optimization code involve heap interspersed heap dependent code 
statement types affect translation ssa form set variables modified execution 
set variables may modified execution 
may set variables values prior execution may represent implicit statement transformation assignment statement variables appear acm transactions programmmg languages systems vol october static single assignment form control dependence graph lhs variables may appear rhs 
optimizing compiler may may access bodies procedures called directly indirectly summaries effects 
specific information available customary conservative sumptions 
call change global variable parameter passed reasonable assume variables local caller change 
assumptions limit extent transformations performed 
techniques available extract detailed information determine parameter aliasing effects procedures global vari ables see determine pointer aliasing see 
sophisticated analysis technique applied usual result side effects tuples lhs rhs small 
small tuples represented directly 
sophisticated analysis unavailable 
compilers interprocedural analysis 
consider call external procedure analyzed 
tuples call contain global variables 
compilers representation tuples compact 
representation structure includes flag set indicate globals tuple plus direct representation local variables tuple parameter transmission 
intuitive explanations cal analyses optimization techniques ssa form conveniently formulated terms explicit tuples compact representations implementations 
overview ssa algorithm translation minimal ssa form done steps dominance frontier mapping constructed flow graph section 
dominance frontiers locations functions variable original program determined section 
variables renamed section replacing mention original variable appropriate mention new variable 

dominance section reviews dominance relation nodes control flow graph summarize relation dominator tree 
section introduces dominance frontier mapping gives algorithm computation 
dominator trees nodes control flow graph cfg program 
appears path entry dominates domination reflexive transitive 
dominates strictly acm transactions programming languages systems vol 
october ron cytron entry exit exit exit exit xit exi exit exit li exit exit exit exit fig 
control flow graph tree simple program listed brackets summarize frontier calculation section node annotated sets df third set 
dominates formulas write strict domination domination 
strictly dominate write immediate dominator denoted idom closest strict dominator path entry dominator tree children node immediately dominated root dominator tree entry node entry idom parent tree 
dominator tree cfg shown 
numbers nodes edges cfg 
dominator tree constructed ea time difficult algorithm time 
practical purposes small constant consider dominator tree linear time 
dominator tree cfg exactly set nodes cfg different set edges 
words predecessor successor path refer cfg 
words parent child ancestor descendant refer dominator tree 
definition analyzing dominator tree algorithm implies logz ll logz 
acm transactions programming languages systems vol 
october static single assignment form control dependence graph dominance frontiers dominance frontier df cfg node set cfg nodes dominates predecessor strictly dominate df pe pred pand 

computing directly definition require searching dominator tree 
total time compute df nodes quadratic sets small 
compute dominance frontier mapping time linear size ex df mapping define intermediate sets node equation holds df 
node successors may contribute dif 
local contribution defined node root entry dominator tree nodes df may contribute df idom 
contribution passes idom defined ye df idom 
lemma 
dominance frontier equation correct 
proof 
dominance reflexive df 
dominance transitive child df 
show df accounted 
suppose df edge dominates strictly dominate done 
hand child dominates strictly dominate strictly dominate implies ye 
intermediate sets computed simple equality tests follows lemma 
node succ idom 
proof 
assume succ show idom 
part true immediate dominator defined strict dominator 
part suppose strictly dominates acm transactions programming languages systems vol 
october 
ron cytron bottom traversal dominator tree df succ local id llf iif children lif df llf fig 

calculation df cfg node child dominates appears path entry goes follows edge dominates dominate idom idom lemma 
node child dominator tree ye df idom 
proof 
assume show idom 
part true strict dominance transitive closure immediate dominance 
part suppose strictly dominates child dominates choose predecessor dominates appears path entry goes follows edge dominates idom idom done 
suppose dominates derive contradiction 
child dominate dominates contradicts hypothesis ye df 
results imply correctness algorithm computing dominance frontiers 
local line effectively com fly uses needing devote storage 
line similar 
traverse dominator tree bottom visiting node visiting children 
illustrate working algorithm annotated dominator tree information brackets 
theorem 
algorithm correct 
proof 
direct preceding lemmas 
cfg nodes edges 
loop succ examines edge just executions local line acm transactions programming languages systems vol 
october static single assignment form control dependence graph complete time 
similarly executions line complete time size df 
time size df amounts worst case complexity 
section shows practice size mapping df usually linear 
implemented algorithm observed faster standard data flow computations compiler 
relating dominance frontiers joins start stating formally nonrecursive characterization functions located 
set cfg nodes set join nodes defined set nodes nonnull cfg paths start distinct nodes converge iterated join limit increasing sequence sets nodes yu 
particular happens set assignment nodes variable set function nodes join iterated join operations map sets nodes sets nodes 
extend dominance frontier mapping nodes sets nodes natural way df join iterated dominance frontier df limit increasing sequence sets nodes df df df df df actual computation df performed efficient worklist algorithm section formulation convenient relating iterated dominance frontiers iterated joins 
set set assignment nodes variable show df equation depends fact entry location functions computed worklist algorithm computing df section 
lemmas relating dominance frontiers joins lemma 
nonnull path cfg node df dominates dominates node node chosen dff 
proof 
dominates node just choose get claimed properties 
may assume nodes acm transactions programming languages systems vol 
october 
ron cytron dominated sequence nodes xo xj smallest dominate predecessor dominated puts df 
choices xj df 
consider xj largest xj df 
show suppose 
dominate xh 
predecessor xh dominated puts df 
xh df df df contradicting choice lemma 
nodes cfg suppose nonnull paths cfg converge df df 
proof 
consider cases obviously exhaustive 
cases prove df df 
show cases exhaustive third case leads contradiction 
lemma path sequence nodes xo xj lemma path sequence nodes yo yk case 
suppose show df 
definition convergence specifically section may assume dominates node 
lemma asserts df 
dominates predecessor xj strictly dominate df df 
case 
suppose show df reasoning just case 
case 
derive contradiction yk dominates predecessors yk 
particular yk 
yk continue inductively show particular 
hand similar reasoning supposition show 
nodes strictly dominate case impossible 

lemma 
set cfg nodes df 
proof 
apply lemma 
lemma 
set cfg nodes entry df proof 
consider xc ye df 
path nodes dominated path entry nodes dominated paths converge theorem 
set nodes need functions variable iterated dominance frontier df set nodes assignments acm transactions programmmg languages systems vol 
october static single assignment form control dependence graph proof 
lemma induction definition show induction step follows 
ji gj df 
node entry lemma induction yield induction step follows df 
df df sdf gj yu 
set nodes need functions precisely prove theorem 

construction minimal ssa form dominance frontiers find functions needed algorithm inserts trivial functions 
outer loop algorithm performed variable program 
data structures worklist cfg nodes processed 
iteration algorithm initialized set nodes contain assign ments node worklist ensures node df receives function 
iteration terminates orklist empty 
array flags flag node indicates added current iteration outer loop 
array flags node indicates function inserted flags ha independent 
need flags property assigning independent property needing function flags implemented just values true false require additional record keeping reset true flags iterations expense looping nodes 
simpler devote integer flag test flags comparing current iteration count 
node ao original assignments variables ordinary assignment statement lhs rhs contributes length tuple lhs 
counting assignments variables acm transactions programming languages systems vol 
ber 
ron cytron node variable wu take df place jv fig 
placement functions 
measures program size 
measure program expands size ao xx ao size xx ato function placed contributes 
similar expansion number mentions variables xx xx function placed contributes plus indegree 
placing function cost linear indegree ex contribution running time done 
replacing mentions variables contribute ot running time ssa translation algorithm cost placement ignored analyzing tion 
bound process 
cost various measures relevant reviewed ssa translation process summarized section 
acm transactions programming languages systems vol 
october static single assignment form control dependence graph initialization similarly ignored subsumed cost dominance frontier calculation 
ignored cost managing worklist statement take performed times time incurs cost linear df ye df polled 
contribution running time process zx ot df 
sizing output natural way tot describe contribution weighted average df aw emphasizes dominance frontiers nodes assignments 
section shows dominance frontiers small practice effectively tot 
turn effectively ao 
renaming algorithm renames mentions variables 
new variables denoted integer generated variable begins top traversal dominator tree calling root node entry 
visit node processes statements associated node sequential order starting functions may inserted 
processing statement requires variables mentioned statement 
contrast fig ure need loop variables initialize arrays data structures array stacks stack variable stacks hold integers 
integer top construct variable vi replace array integers variable value tells assignments processed 
integer telling predecessor cfg jth operand function corresponds jth predecessor listing assignment statement form lhs rhs right hand side rhs tuple expressions left hand side lhs tuple distinct target variables 
tuples change mentions variables renamed original target tuple remembered 
minimize notation conditional branch treated ordinary assignment special variable value indicates edge branch follow 
real implementa tion recognize conditional branch involves little genuine assignment lhs part processing omitted 
acm transactions programmmg languages systems vol 
october ron cytron variable empty stack call search entry search statement ordinary assignment variable rhs replace top lhs replace new tj lhs push loop succ tt function replace th operand rhs top children call search assignment pop search fig 
renaming mentions 
grows replacement ina rhs processing ofan assignment statement considers mentions variables simplest case target variable lhs 
anew variable 
keeping ofthe number assignments processed find appropriate new variable incrementing 
facilitate renaming uses push identifies stack integers identify new variables replacing acm transactions pro languages systems vol october static single assignment form control dependence graph subtler computation needed right hand side rhs 
consider variable rhs appears expressions tuple 
want replace vi target assignment produces value rhs 
subcases ordinary assignment function 
subcases get top stack inspect different times 
lemma introduced section shows correctly chosen subcases 
correctness proof renaming depends results section lemmas 
start showing sense speak assignment variable transformed program 
lemma 
new variable vi transformed program target exactly assignment 
proof 
counter incremented processing assignment assignment 
show assignment consider ways mentioned 
mentioned lhs assignment show 
value vi op true time algorithm renamed old vi 
earlier time pushed pushed assignment just changed assignment vi 
node may contain assignments variable appeared original program introduced receive value function er denote new variable effect statements node considered loop 
specifically consider top stack loop define top 
assignments top traversal ensures er inherited closest dominator assigns lemma 
variable cfg edge rp function idom 
proof 
may assume idom 
function node ye df assign new variable derived fact twice 
lemma ye df assign new variable derived node sequence idom idom idom 
assigns variable 

acm transactions programming languages systems vol 
october 
ron cytron assigns new variable derived follows df 
dominates predecessor strictly dominates idom get edge choice implies assign new variable derived follows 
idom preceding lemma helps establish condition definition ssa form extend specify new variable corresponds just just statement iteration loop consider top stack just just iteration define top processing top processing particular happens statement block 
hand followed statement ler 
lemma 
consider control flow path transformed program path original program 
consider variable occurrence statement path 
original program value executing original program value just executing transformed program 
proof 
induction path 
consider kth statement executed path assume jth statement original variable agreeing just assume kth statement original program show agrees just case 
suppose original statement basic block statement just induction hypothesis semantics assignment agrees just agrees just case 
suppose original statement basic block edge followed control path 
claim agrees control flows edge 
entry vo hold entry value entry statement induction hypothesis semantics assignment agrees nominal entry assignment function acm transactions programming languages systems vol october static single assignment form control dependence graph 

idom fig 

proof lemma node mayor may function just control flows bridge gap knowing agrees knowing agrees just doing illustrates may may function ahead transformed program 
case 
suppose function vi 
operand corresponding loop successors 
operand value assigned vi 
agrees just doing case 
suppose function lemma agrees idom just doing theorem 
program put minimal ssa form comput ing dominance frontiers applying algorithms 
ot total number assignments variables resulting program 
total number mentions variables resulting program 
number edges cfg 
avr weighted average dominance frontier sizes 
running time process df 
proof 
places functions nodes iterated dominance frontier df set assignments original program 
theorem df set nodes need ordinary assignment lhs rhs contributes length tuple lhs function contributes ot 
acm transactions programming languages systems vol 
october 
ron cytron functions obtained condition definition translation ssa form fewest possible functions 
show renaming done correctly 
condition definition follows lemma 
condition follows lemma 
number nodes cfg 
dominator tree edges runs time 
term subsumed df cost computing dominance frontiers contributes 
explained section contributes 

construction control dependence section show control dependence essentially dominance frontiers reverse graph control flow graph 
nodes cfg 
appears path exit postdominates dominator relation postdominator relation reflexive transitive 
postdominates strictly postdominates immediate postdominator closest strict postdominator path exit 
postdominator tree children node immediately cfg node control dependent cfg node hold nonnull path postdominates node 
node strictly postdominate node words edge definitely causes execute path avoids executing associate control dependence label control flow edge causes execute 
definition control dependence easily shown equivalent original definition 
lemma 
cfg nodes 
postdominates successor iff nonnull path postdominates node proof 
suppose postdominates successor choose path exit 
appears initial segment reaches appearance node get exit path exit 
postdominates appear postdominate 
path starts edge proceeds postdominates node postdominance relation irreflexive definition reflexive 
relations identical pairs distinct elements choose reflexive postdominance dual dominance relation acm transactions programming languages systems vol 
october static single assignment form control dependence graph build build dominator tree apply algorithm find dominance frontier mapping rdf node cd node rdf cd cd fig 

algorithm computing set cd nodes dependent node entry cd node fig 

control dependences 
conversely path properties node successor postdominates reverse control flow graph nodes control flow graph cfg edge edge cfg 
roles entry exit reversed 
postdominator relation cfg dominator relation 
corollary 
nodes cfg 
control dependent cfg iff df 
roof 
lemma simplify condition definition control dependence find control dependent iff successor strictly postdominate means dominates predecessor strictly dominate df 
applies result computation control 
building dominator tree standard method time ea spend size rdf finding dominance frontiers inverting 
total time size rdf acm transactions programming languages systems vol 
october ron cytron practical purposes 
applying algorithm control flow graph obtain control dependence 
note edge entry exit added cfg control depend ence relation viewed graph rooted entry 

translating ssa form powerful analysis transformation techniques applied programs ssa form 
eventually program executed 
functions precise semantics generally repre sented existing target machines 
section describes translate ssa form replacing function ordinary assign ments 
naive translation yield inefficient object code efficient code generated useful optimization applied dead code elimination storage allocation coloring 
naively input function entrance node replaced ordinary assignments control flow predecessor correct ordinary assignments perform deal useless 
naive replacement preceded dead code elimination followed coloring resulting code efficient 
dead code elimination original source program may dead code code effect program output 
intermediate steps compilation procedure integration may introduce dead code 
code live may dead course optimization 
possible sources dead code natural perform repeat dead code tion late optimization process burden intermediate steps concerns dead code 
translation ssa form compilation steps may introduce dead code 
suppose assigned branch join point 
original assignments live added assignment function dead 
dead functions useful equiva redundancy elimination algorithms ssa form 
shown 
avoided placement dead functions translating ssa form prefer include dead functions increase optimization opportunities 
different definitions dead code literature 
dead code defined unreachable code defined code 
cases desirable broadest possible definition subject correctness condition dead code really safely removed 
procedural version definition definition broader usual similar faint variables 
acm transactions programming languages systems vol 
october static single assignment form control dependence graph pi yi xl 
pi xl zi pi xl yi 
fig 

program containing dead function assigns toy 
value numbering technique determine value computations produce eliminated 
dead function brought 
intuitive recursive version prefer procedural style 
initially statements tentatively marked dead 
statements need marked live conditions listed 
marking statements live may cause marked live 
natural worklist eventually empties statements marked dead truly dead safely removed code 
statement marked live iff holds statement assumed affect program output statement assignment parameter call routine may side effects 
statement assignment statement statements marked live outputs 
statement conditional branch statements marked live control dependent conditional branch published algorithms eliminate dead code narrower sense requires conditional branch marked live algorithm goes step eliminating dead conditional branches 
unpublished algorithm paige 
readily accessible contains typographical error earlier technical report consulted correct version 
acm transactions programmmg languages systems vol 
october 
ron cytron statement pre live live true live false pre live worklist take live false live true block cd liz false live true statement live false worklist worklist delete block fig 
dead code data structures ive indicates statement live 
set statements execution initially assumed affect program output 
statements result side effects outside current procedure scope typically included 
worklist list statements discovered 
set statements provide values statement statement terminates basic block block basic block containing statement 
basic block immediately postdominates block 
acm transactions programming languages systems vol october static single assignment form control dependence graph cd set nodes control dependence predecessors node corresponding block rdf 
algorithm discovers live statements marked live deleted 
optimizations code motion may leave empty blocks ample reason late optimization remove 
empty blocks left dead code elimination removed empty blocks 
fact statements considered dead marked live crucial condition 
statements depend transitively marked live required live statement 
condition handled loop cd block 
basic block tion controls block live statements live 
allocation coloring possible simply map occurrences vi back delete functions 
new variables introduced translation ssa form eliminated optimization may capitalized storage independence new variables 
useful persistence new variables introduced translation ssa form illustrated code motion example 
source code assigns twice uses twice 
ssa form optimized moving invariant assignment loop yielding program separate variables separate purposes 
dead assignment eliminated 
optimization leave region program vi vz simultaneously live 
variables required original variable substitute renamed variables 
graph coloring algorithm reduce number variables needed remove associated assignment statements 
choice coloring technique guided eventual output 
goal produce readable source code desirable consider original variable separately coloring just ssa variables derived goal machine code ssa variables considered 
cases process coloring changes assignments inserted model functions identity assignments assignments form identity assignments deleted 
storage savings especially noticeable arrays 
optimization perturb order statements arrays assigned color share storage 
array assigned update iden colored array 
operations implemented inexpensively lla conditional branch deleted transforming unconditional branch prior targets 
acm transactions programming languages systems vol 
october 
ron cytron 

lj read read wi vi 
vo read vi wi fig 
program really uses instances variable code motion 
source program unoptimized ssa form result code motion assigning just component array share storage 
inparticular actual operation performed form 

analysis measurements number nodes contain functions variable function program control flow structure assignments program structure determines dominance frontiers number control dependence 
possible dominance frontiers may larger necessary computing function locations programs actual assignments taken account 
section prove size dominance frontiers linear size program control flow branching restricted constructs loops 
assume expressions predicates perform internal branching 
programs described grammar fig ure 
give experimental results suggest behavior linear actual programs 
theorem 
programs comprised straight line code constructs dominance frontier cfg node contains nodes 
proof 
consider top parse program grammar shown 
initially single program node parse tree control flow graph cfg nodes edge entry exit 
initial dominance frontiers df entry df exit 
production consider associated changes cfg dominance frontiers nodes 
production expands nonterminal parse tree node new subgraph inserted cfg place new subgraph node corresponds symbol right hand side production 
show applying productions preserves invariants cfg node corresponding unexpanded statement symbol node dominance frontier 
acm transactions programmmg languages systems vol 
october static single assignment form control dependence graph program statement statement statement predicate statement statement statement predicate statement statement variable expression fig 

grammar control structures cfg node corresponding terminal symbol nodes dominance frontier 
consider productions 
production adds acfg node sand edges entry exit yield ing df exit 
production applied acf node odes si sz 
edges previously entering leaving enter si leave sz 
single edge inserted si sz 
control flow graph changed consider production affects nodes nodes additionally sz 
wehave df sl df dif sj 
production applied cfg node replaced nodes ti 
sel te 
edges previously entering leaving enter leave 
edges inserted ti mand edges inserted st te 
dominator tree ti dominate nodes domi nated additionally ti dominates 
argument production df df df 
consider nodes sel definition dominance fr obtain df df fl 
production applied cfg node replaced nodes 
edges previously associated node associated node 
edges inserted tw sd 
tu 
node dominates nodes dominated node additionally tu dominates 
df 
df df 
application production new control flow graph isomorphic old graph 
corollary 
programs comprised straight line code constructs node control dependent nodes 
proof 
consider program composed allowed constructs associated control flow graph cfg 
reverse control flow graph cfg acm transactions programmmg languages systems vol 
october 
ron cytron statements package name procedures fl spice totals table 
summary statistics experiment statements procedure min median max description dense matrix eigenvectors values flow past airfoil circuit simulation fortran procedures structured control flow graph program 
df contains nodes theorem 
corollary control dependent nodes 
unfortunately linearity results hold program struc tures 
particular consider nest repeat loops illustrated 
loop dominance frontier entrance loop includes entrances surrounding loops 
nested loops leads dominance frontier mapping total size nz variable needs functions 
dominance frontier mapping placing functions computation dominance frontiers take excessive time respect resulting number actual functions 
wish measure number dominance frontier nodes function program size diverse set programs 
implemented algorithms constructing dominance frontiers placing functions system offered required local data flow control flow analysis 
ran algorithms library procedures procedures perfect benchmarks 
summary statistics procedures shown table fortran programs chosen contain irre intervals unstructured constructs 
plot shows size dominance frontier mapping appears vary linearly program size 
ratio sizes ranged entry node empty dominance frontier 
programs tested plot shows number functions linear size original program 
ratio sizes ranged 
largest ratio occurred procedure statements percent procedures ratio 
remaining procedures contained fewer statements 
plot shows size control dependence graph linear size original program 
ratio sizes ranged close range ratios dominance frontiers 
ratio defined section measures cost placing functions relative number assignments resulting acm transactions programmmg languages systems vol 
october oo loo static single assignment form control dependence graph oo fig 

size dominance frontier mapping versus number program statements 
loo fig 
number rj functions versus number program statements ssa form program 
ratio varied median 
correlation program size 
measured expansion number assignments translating ssa form 
ratio varied 
lly measured expansion mo number mentions assignments acm transactions programming languages systems vol 
october 
ron cytron loo fig 

size control dependence graph versus number program statements 
uses variables translating ssa form 
ratio varied 
ratios correlation program size 

discussion summary algorithms time bounds conversion ssa form done steps dominance fi mapping constructed control flow graph cfg section 
cfg nodes edges 
df mapping nodes dominance frontiers 
time compute dominator tree dominance frontiers cfg xx df 
dominance frontiers locations functions variable original program determined section 
total number assignments variables resulting program ordinary assignment statement lhs rhs contributes len tuple lffs ot function contributes 
placing functions contributes time weighted average sizes df 
variables renamed section 
total number mentions variables resulting program 
renaming contributes time 
state time bounds terms fewer parameters size original program maximum relevant numbers acm transactions programming languages systems vol october static single assignment form control dependence graph nodes edges original assignments variables mo original mentions variables 
worst case iv ordinary assignments require insertions 
tot worst 
worst case function 
operands 
ot worst 
parameter worst case time bounds finding dominance frontiers translation ssa form 
data section suggest entire translation ssa form linear practice 
dominance frontier node cfg small number functions added variable 
effect constant ot ao mo 
entire translation process effectively 
control dependence read dominance frontiers reverse graph section time size rdf 
size rdf size output control dependence calculation algorithm linear size output 
quadratic behavior caused output fl worst case 
data section suggest control dependence calculation effectively 
related minimal ssa form refinement shapiro saint notion 
nodes exactly nodes need functions closer precursor ssa form associated new names nodes inserted assignments new name 
explicit functions difficult manage new names reason flow values 
suppose control flow graph cfg nodes 
edges program variables 
algorithm requires ea bit vector operations vector length find 
simpler algorithm reducible programs com ssa form time 
lengths bit vectors taken account algorithms essentially programs size simpler algorithm inserts extraneous functions 
method worst section gives evidence practice 
earlier algorithms provision running faster typical cases appear intrinsically quadratic 
cfg nodes edges previous general control dependence algorithms take quadratic time 
analysis worst case depth post dominator tree 
section shows control dependence determined computing dominance frontiers reverse graph 
general approach take quadratic time quadratic behavior caused output fl worst case 
particular suppose program comprised straight line code constructs 
corollary algorithm computes control dependence linear time 
obtain better time bound programs algorithm dominance frontiers sizes necessarily related depth acm transactions programming languages systems vol 
october 
ron cytron dominator tree 
languages offer constructs control dependence computed parse tree linear time algorithm robust 
handles cases quadratic time typical cases linear time 
previous shown ssa form control dependence support powerful code optimization algorithms highly efficient terms time space bounds size program translation forms 
shown translation performed efficiently leads moderate increase program size applying early steps ssa translation reverse graph efficient way compute control dependence 
strong evidence ssa form control dependence form practical basis optimization 
acknowledgments fran allen early encouragement fran allen avery julian bob paige tom reps randy jin fan shaw various helpful comments 
especially grateful referees thorough reports led improvements 

aho sethi ullman principles techniques tools 
addison wesley reading mass 
allen burke charles cytron overview analysis system multiprocessing 
parallel distrib 
comput 
oct 

allen dependence analysis subscripted variables application program transformations 
ph thesis department computer science rice univ houston tex apr 
allen johnson compiling vectorization parallelization inline expansion 
proceedings sigplan symposium construction 
sigplan 
acm june 
alpern wegman zadeck detecting equality values programs conference record th acm symposium principles programming languages jan acm new york pp 

maccabe ottenstein program dependence web representation supporting control data demand driven interpretation languages proceedings sigplan compiler construction 
sigplan 
acm june 

banning efficient way find side effects procedure calls aliases variables 
conference record th acm um principles programming languages jan acm new york pp 

barth interprocedural data flow analysis algorithm 
conference record th acm symposium principles programmmg languages jan acm new york pp 


burke interval approach exhaustive incremental interprocedural data flow analysis 
acm trans 
program lang 
syst 
july 

burke cytron interprocedural dependence analysis parallelization 
proceedings sigplan symposium compiler construction sigplan acm june 
acm transactions programming languages systems vol 
october static single assignment form control dependence graph 
cartwright felleisen semantics program dependence 
proceedings sigplan 
symposium compiler construction 
sigplan 
acm july 
chaitin register allocation spilling graph coloring 
proceedings sigplan symposium compiler construction 
sigplan 
acm june 

chaitin auslander chandra hopkins markstein register allocation coloring 
comput 
lang 


chase safety considerations storage allocation optimizations 
proceedings sigplan symposium compiler construction 
sigplan 
acm june 

chase wegman zadeck analysis pointers structures 
proceedings sigplan symposium compiler construction 
sigplan 
acm june 
choi cytron ferrante automatic construction sparse data flow evaluation graphs 
conference record th acm symposium principles programming languages jan 
acm new pp 


chow portable machine independent global optimizer design measurements 
ph 
thesis tech 
rep computer systems laboratory stanford univ stanford calif dec 

chow hennessy priority coloring approach register allocation 
acm trans 
program 
lang 
syst 
oct 

cooper interprocedural data flow analysis programming environment 
ph thesis dept mathematical sciences rice univ houston tex 

cytron ferrante improved control dependence algorithm 
tech 
rep rc ibm 

cytron ferrante name 
proceedings international conference parallel processing aug pp 

cytron lowry zadeck code motion control structures high level languages 
conference record th acm symposium principles programming languages jan 
acm new york pp 


dennis version data flow procedure language 
tech 
rep comput 

group memo mac tech 
memo mit cambridge mass may 

ferrante ottenstein warren program dependence optimization 
acm trans 
program 
lang 
syst 
july 

giegerich formal framework derivation machine specific optimizers 
acm trans 
program 
lang 
syst 
july 

harel linear time algorithm finding dominators flow graphs related problems 
proceedings th acm symposium theory computing may 
acm new york pp 


horwitz pfeiffer reps dependence analysis pointer variables 
proceedings sigplan symposium compiler construction 

acm june 

horwitz prins reps integrating non interfering versions programs 
acm trans 
program 
lang 
syst 
july 

jones muchnick flow analysis optimization structures 
program flow analysis muchnick jones eds 
prentice hall englewood cliffs chap 
pp 


kennedy global dead computation elimination 
tech 
rep setl 
courant institute mathematical sciences new york univ new york aug 

kennedy survey data flow analysis techniques 
program flow analysis muchnick jones eds 
prentice hall englewood cliffs 

kuck structure computers computations 
wiley new york 

larus restructuring symbolic programs concurrent execution multiprocessors 
tech 
rep ucb csd computer science dept univ california berkeley berkeley calif may 
acm transactions languages systems vol 
october 
ron cytron larus hilfinger detecting conflicts structure accesses proceedings acm sigplan construction 
sigplan 
july 
lengauer tarjan fast algorithm finding dominators flowgraph 
acm trans 
program 
lang 
syst 
july 
muchnick jones eds program flow analysis 
prentice hall englewood cliffs nj precise interprocedural data flow algorithm conference record th acm symposium principles programming languages jan 
acm new york pp 


ottenstein data flow graphs intermediate form 
ph thesis dept computer science purdue univ lafayette ind aug 

pointer perfect report 
tech 
rep csrd center supercomputing research development univ illinois urbana champaign urbana july reif lewis efficient symbolic analysis programs 
comput 
syst 
june 

reif tarjan symbolic program analysis linear time 
siam comput 
feb 
rosen data flow analysis procedural languages acm apr 

rosen wegman zadeck global value numbers redundant computations 
conference record th acm programming languages jan 
acm new york pp 

murtagh lifetime analysis dynamically allocated objects 
conference record th acm principles programming languages jan 
acm new york pp 


shapiro saint representation algorithms 
tech 
rep ca massachusetts computer associates feb 

smith boyle dongarra moler eigensystem routines guide 
springer verlag new york 
tarjan finding dominators directed graphs 
siam comput 
wegbreit property extraction founded property sets 
ieee trans 
softw 
eng 
se sept 

wegman zadeck constant propagation conditional branches 
conference record th acm symposium programm mg languages jan 
acm new york pp 


wegman zadeck constant propagation conditional branches 
acm trans 
program 
lang 
syst 
published 
wolfe optimizing supercompilers supercomputers 
ph thesis dept computer science univ illinois urbana champaign urbana 
yang horwitz reps detecting program components equivalent behaviors 
tech rep dept computer science univ wisconsin madison madison apr received july revised march accepted march acm transactions programming languages systems vol october 
