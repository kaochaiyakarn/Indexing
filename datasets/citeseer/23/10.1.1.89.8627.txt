diplomarbeit combined static dynamic analysis effective buffer minimization streaming xquery evaluation ausgef hrt der universit des saarlandes lehrstuhl informationssysteme unter von professor christoph koch durch michael schmidt der diplomarbeit der diplomarbeit rung ich dass ich die von mir diplomarbeit bzw 
die von mir und die habe 
saarbr cken 
juli special go professor christoph koch stefanie 
particular want professor christoph koch having exciting topic excellent supervision discussions time spent supporting diploma thesis 
stefanie contributed thesis valuable ideas background information critics support possible 
contributions significantly improved quality thesis 
go family particular father gerhard schmidt mother schmidt 
enabled studies supported years 
furthermore want people supported studies contributions thesis especially eric ha marie christoph stefan schmidt markus thiele proof reading members saarland university database group discussions suggestions 
go professor gerhard weikum agreed revise thesis 
professor christoph koch und stefanie 
ich professor christoph koch die wahl des die und die zeit die er diplomarbeit hat 
stefanie hat mit und unterst zum der arbeit 
diese ge haben die der arbeit 
gerhard schmidt und schmidt 
durch ihre unterst und haben sie erm und mir den hrend der 
weiterhin ich allen die mir der zeit und der diplomarbeit unterst zur seite haben eric ha marie stefan schmidt und markus thiele das der diplomarbeit und allen der saarland university database group und 
nicht professor gerhard weikum die die diplomarbeit zu 
ii coming proliferation internet increasing bandwidths relevance data stream processing rapidly increased years 
way xml evolved de facto standard format data interchange 
applications developed follow trends deal xml data streams 
efficient extraction data xml streams non trivial challenge streaming data may arrive high rates 
consequence growing importance different languages proposed query data xml documents xquery xpath 
efficient evaluation xquery powerful xpath subject extensive studies years 
native xml database management systems rely physical database ill suited data stream processing storing streamed data physical volumes query evaluation amount incoming data high hard disk access slow compared inmemory data manipulation 
systems evaluate data main memory practice deal strictly limited main memory size 
large data streams effective buffer management key prerequisite performance 
existing approaches reducing size memory buffers rely static query analysis 
propose buffer management scheme combines static dynamic analysis keep main memory consumption low 
system aims minimizing high watermark memory consumption keeping average memory consumption low possible 
approach relies technique call active garbage collection actively buffers runtime progress query evaluation 
order implement active garbage collection assign roles buffered nodes 
roles express relevance buffered nodes query evaluation 
query evaluation nodes incrementally lose roles fulfill respectively 
technique similar garbage collection counting ensures tokens lost roles purged buffer early 
prototype system designed practical fragment xquery employ buffer management scheme 
experimental results demonstrate significant impact combined static dynamic analysis reducing main memory consumption running time 
iii mit der des internets und daten hat die von men einen 
parallel hat sich xml zu einem den 
der wurden diverse anwendungen entwickelt die auf xml str men arbeiten und trends 
die ausf hrung von auf xml men ist nicht zu einem der forschung 
des von xml wurden diverse zur xml entwickelt xquery und xpath und sind 
hrend ein gro teil der forschung auf zur ausf hrung dieser im xml management systeme war die daten vor der einer werden die auswertung auf men andere 
die 
das der daten auf ist unm glich um ein sind als die im 
systeme die daten ohne ssen mit einem der praxis stark 
die dieser systeme ist eng eine 
alle ans tze zur auf rein analyse 
unser ansatz und analyse 
auf dem der hrung werden nicht ben xml fr aus dem 
um dieses zu werden xml 
dabei stellt eine funktion des den noch teil der auswertung dar 
hrend der ausf hrung die zum ihre 
wird die eines kann er mit garbage collection counting aus dem werden 
wir haben unser einem ein xquery fragment 
der mit anderen systemen die die durch die kombination von und analyse werden kann 
iv contents buffer design xquery engines 
garbage collection xquery engines 
contributions 
chapter overview 
related 
xquery engine categorization 
streaming xquery evaluation 
stream preprojection 
garbage collection 
preliminaries document projection 
projection paths 
projection trees 
minimal projection 
role association 
query language semantics xq 
introducing signoff statements xq 
roles dependency paths 
static analysis deriving projection trees 
assigning roles buffered nodes 
xq rewriting 
query normalization 
inserting signoff statements 
active garbage collection irrelevant nodes 
buffer cleanup algorithm 
system implementation system architecture 
system components runtime interaction 
buffer representation 
projection tree construction 
projection trees projection paths 
base projection path extraction 
base projection path conversion 
projection tree setup algorithm 
projection tree determinization 
projection tree fusion 
role aggregation 
lazy dfa construction 
syntax expression implementation 
optimizations 
elimination redundant roles 
tag name hashing 
pushing signoff statements 
experimental results correctness tests 
stream preprojection 
evaluation time memory consumption 
standard database techniques 
exploiting schema knowledge 
reducing memory consumption 
accelerating query evaluation 
incorporating aggregation 
role representation 
xq concrete syntax uml conditional expressions uml ii non conditional expressions queries correctness tests xmp xquery 
dbms milestone test queries 
user defined queries 
xmark test queries vi list figures projection tree 
active garbage collection 
document projection 
projection path evaluation 
xquery fragment xq 
projection role assignment 
projection tree example 
semantics role assignment 
decomposition statements 
pushing statements 
static query rewriting 
inserting signoff statements 
localized active garbage collection 
system architecture 
system interaction 
inference rules non conditional expressions 
inference rules conditional expressions 
projection tree setup algorithm 
projection tree setup example 
deterministic projection tree setup 
deterministic projection tree 
stream preprojection test queries 
xml stream preprojection tests 
dtd 
list tables stream preprojection results 
benchmark results 
vii past years xquery evolved powerful widely accepted query language xml processing 
various memory xquery engines developed repeatedly observed main memory consumption remains crucial bottleneck xquery evaluation :10.1.1.10.6782
particular xquery evaluated streams input completely buffered prior query evaluation 
buffer management key prerequisite performance 
buffer design xquery engines claim desiderata buffer design ideally buffer manager streaming xquery engine 
put data relevant query evaluation buffer 
keep data buffered longer necessary 
keep multiple copies data buffers 
strictly speaking goals unattainable 
instance system optimal desiderata able check satisfiability xquery expressions undecidable problem implicit 
claim order come closer meeting desiderata combination static analysis dynamic buffer minimization techniques needed 
virtually current systems decisions regarding buffer delete buffers compile time purely static query analysis :10.1.1.10.6782
review buffer management strategies existing xquery engines 
early xquery buffer management static projection technique implemented galax refined query relevant parts input loaded memory 
projected document computed query evaluation start buffer management query evaluation issue 
galax memory xquery engine systems specifically designed operate xml streams :10.1.1.10.6782
works evaluate parts query fly little buffering static analysis data dependencies schema information available 
practical queries involving blocking operators descendant axes wildcards little evaluated fly :10.1.1.10.6782
systems decision buffers purged compile time 
case engine similarly lifetime buffer associated scope xquery variable 
buffers conveniently deleted scope associated variable ends difficult avoid data buffered twice 
situations arise xml node bound different variables required checking condition producing output 
particular queries descendant axes wildcards may difficult avoid duplicate buffering 
argue order come closer satisfying desiderata 
static dynamic analysis required static query analysis incrementally compute projection input document loading query relevant data buffers 
addition statically infer moments query evaluation buffered nodes may irrelevant remaining query evaluation time query subexpression evaluated 
delete nodes buffer early query evaluation dynamic analysis required takes account current contents buffers state query evaluation progress reading input 
obviously may expect impact combined static dynamic analysis main memory consumption greater achieved static analysis 
garbage collection xquery engines thesis propose active garbage collection novel buffer management technique xquery engines static dynamic analysis exploited 
garbage collection understood technique automatic memory management programming languages 
basic principle garbage collector determine data objects program accessed consequently reclaim storage objects 
simple effective garbage collection strategy counting object counts number 
created object count incremented 
likewise count decremented removed 
count reaches zero object deleted memory reclaimed 
major advantage approach memory overhead small 
approach strongly related counting insofar single node buffer keeps track relevant remaining xquery evaluation 
counting employ concept roles assigned nodes 
intuitively role serves metaphor relevance node 
traditional garbage collector passive sense invoked space allocate new objects approach differs active 
purge buffers irrelevant nodes early 
fact garbage collection invoked scope variable ends 
high watermark average main memory consumption remain low 
bib price descendant self node projection tree 
book title descendant self node basic idea active garbage collection clean simple path expressions xquery statically derive set roles 
reading input stream tokens matched set possible roles 
node assigned roles query different contexts 
role assigned node times happen queries involve xpath expressions descendant axes 
compile time determine moments query evaluation nodes lose roles 
runtime buffer manager notified nodes reachable path current variable binding lose certain role 
node lost roles safely deleted descendants assigned roles 
example 
xquery expression outputs children bib node price exists 
book titles contained document output 
result bib bib return bib return exists price bib book return title result refer loop introducing variable bib bib likewise static analysis derive projection tree nodes shown 
projection tree defines parts input copied buffer 
consider example node refers condition query 
projection tree node defines child bib node price tag descendants needs buffered 
buffering occurrence price node existence check evaluates true occurrences 
due projection tree node forced buffer children bib node subtrees 
intuitively spoken node subsumes node 
emphasize price tag carries different roles query evaluation output expression existence check expression 
projection tree node ni assigned unique role ri 
input stream parsed runtime nodes document incrementally projected buffer marked roles fly 
mentioned nodes describe relevance node 
matching price tag example marked roles role capturing relevance existence check role corresponding output expression 
evaluation signoff statements statically inserted query 
runtime statements notify buffer manager certain nodes lose roles 
signoff statement refers nodes exactly role 
rewritten query sketched 
result bib bib return bib return exists price signoff signoff price signoff descendant self node bib book return title signoff signoff title descendant self node signoff bib result query sequentially evaluated buffer input required buffered 
case query evaluator blocks requests input input stream read token matched projection tree stream exhausted 
soon matching token assign matched projection tree node ni role ri token token loaded buffer query evaluation resumed 
contrast projection implemented galax document projected buffer starting evaluation pull approach buffer filled incrementally evaluation needed evaluator 
query evaluator encounters signoff statement notifies buffer certain nodes lose roles 
buffer performs role updates invokes active garbage collection 
consider evaluation query streamed input document bib book title author book bib contains single book empty title author tags 
shows steps read input stream current buffer contents output produced far 
step 
step opening tag result output 
query evaluator tries evaluate bib block required input available buffer 
step 
bib read 
matched projection tree node document node copied buffer assigned role 
query evaluator evaluates bib binds variable bib buffered node 
tries evaluate block relevant data missing 
step 
book matched projection tree nodes buffered assigned roles 
variable bound book node evaluation query subexpression exists price wait input 
step 
opening closing tags title node read 
tokens matched projection tree consequently buffered annotated roles 
evaluation expression blocks reading author node 
step 
opening closing tags author node read 
matched projection tree node annotated role written buffer 
step input buffer output stream contents stream result bib bib book bib book title bib book title author bib book title author book bib book title author bib book title bib bib book title bib book book title author book title title bib result active garbage collection 
step 
tag book read 
expression evaluated node bound output 
sequence signoff statements evaluated 
signoff causes buffered book node lose role 
signoff price takes effect match price relative current binding signoff descendant self node removes matching nodes book title author 
author node lost single role course evaluating signoff statements descendants purged buffer 
step 
remaining nodes carries role marks relevant evaluation query evaluation returns evaluating blocks token loaded buffer 
step 
token bib completes buffer 
second binding variable evaluation proceeds variable bound book buffer title output 
step 
command signoff executed causes book lose single role 
time book resides buffer exists marked title descendant 
execution signoff title descendant self node title loses single role 
book title removed buffer 
step 
execution signoff bib removes role buffered bib tag 
buffer empty result written 
query evaluation finishes step 
nodes lost roles evaluation buffer empty 
contributions propose buffer manager streaming xquery engines employs static dynamic analysis reduce main memory consumption 
introduce notion assigning roles buffered nodes 
roles serve metaphor relevance node query evaluation 
show roles assigned nodes nodes lose roles query evaluation nodes deleted buffers 
extend established technique static document projection roles assigned document nodes fly projection 
optimizations stream preprojection techniques works 
propose active garbage collection novel buffer management technique streaming xquery engines 
explore technique practical fragment composition free xquery 
prototype implementation shows significant impact active garbage collection main memory consumption query evaluation time 
confirmed experiments xmark data queries combined static dynamic analysis outperforms systems rely static analysis 
chapter overview provide preliminaries section 
formal definition xml cover basic principles stream preprojection roles role assignment 
xquery fragment xq introduced section 
syntax fragment discuss semantics properties expressiveness xq formally extend language signoff statements 
static analysis section forms groundwork active garbage collection runtime 
task document projection preliminaries section address topics role extraction query rewriting inserting signoff statements right positions query expression 
active garbage collection discussed section 
describe system runtime behaviour identify rules purging buffers runtime garbage collection 
section focuses efficient implementation buffer management scheme 
previous chapters describe ideas mathematical point view emphasis chapter lies optimizations algorithms implementation techniques 
experimental results discussed section 
correctness tests experimental validation prototype benchmark results stream preprojection query evaluation 
thesis concludes ideas section short section summarizes ideas new buffer management schemes 
related years efficient xquery evaluation subject extensive studies 
works cover xquery evaluation physical databases evaluation streaming data 
discuss related focus streaming scenarios 
xquery engine categorization xquery evaluation engines categorized classes 
class native xml database management engines 
systems characterized physically stored xml data general query evaluation constant memory usage 
focus systems lies efficient storage xml data 
hard disk access expensive appropriate indices data structures xml ensure relevant data accessed efficiently 
query evaluation cases requires techniques similar relational database management systems advanced join techniques join reordering indexing query evaluation plans pipelined evaluation 
challenge native application techniques structured ordered hierarchical data flat relational data relational dbms 
system developed emphasis efficient management tree structured data level page allocation physical placement 
system compiles xquery expressions interpreting 
main focus system lies order preserving join reordering appropriate choice wellsuited join algorithms 
timber system basically addresses issues 
reusing standard techniques relational database management systems tree value hash indexing carefully designed tree algebra introduced forms mathematical foundation optimization xquery expressions 
native xml database management systems exist memory xml engines 
xml data stored physically hard disk query evaluation relevant parts data loaded processed main memory 
engines share important property third class xquery engines streaming xquery engines data processed memory main memory resources limited practice strong focus types engines lies buffer minimization 
streaming xquery evaluation previous evaluation xquery xpath streaming data includes 
due increasing bandwidths increasing number world wide connections data streams scenarios may arrive high rate 
high traffic scenarios storing data physically hard disk unfeasible streams large stored hard disk access slow compared main memory data manipulation 
main memory resources strongly limited practice desirable decrease amount buffering 
resources exhausted systems start swapping cases query evaluation time unacceptable 
buffer minimizing technique static stream preprojection 
projecting away non relevant parts input stream query evaluation amount buffered data significantly reduced 
refer subsection discussion related stream preprojection 
stream preprojection single pass query evaluation xml documents subject various works 
desideratum plays minor role native xml database systems topic important streaming scenarios input document delivered token token 
pure single pass evaluation stream processing means buffered principle evaluated fly 
unfortunately practical cases certain amount buffering inevitable computing joins subtrees 
discuss strategies existing systems designed streaming xquery evaluation 
system exploits situations data evaluated thefly 
analysis query dtd identifies parts input stream evaluated buffering 
query language extended query rewritten exploit situations 
system behaves practical queries drawbacks 
particular system support queries descendant axes cases buffers parts input stream multiple times dealing wildcard descendant axes 
xml stream machines hand buffer management explicit low level reading tokens writing tokens buffer 
step query subexpressions translated xml stream machines 
resulting stream machines composed network optimized dtd information 
network compiled program evaluates specific query 
parts input stream buffered multiple times system supports acyclic dtds xquery fragment restricted descendant axes 
streaming system offers support aggregations user defined functions 
system similar engine insofar aims fly evaluation possible 
called stream data flow graph constructed reflects relations variables underlying xquery expression 
decision query evaluated fly analyzing stream data flow graph 
optimized query compiled executed input stream 
unfortunately details buffer management discussed 
pipelining proposed technique help reduce amount cached data 
system particularly designed evaluate simple queries produce output far smaller input stream size 
key idea compile xquery subexpressions called iterators connected pipelines 
stream pushed iterator network 
simple queries evaluated efficiently evaluation complex queries xquery joins backward axes efficient requires stream duplication cases 
bea streaming xquery processor commercial product fully compliant xquery standard 
analogy native xml database systems step query optimized heuristics cost estimations 
optimization phase includes standard database techniques join optimizations techniques primarily apply streaming scenarios example rewriting xquery subexpressions require input stream reverse traversals 
query compiled executed stream intermediate results stored memory 
systems described covers desiderata xquery buffer management postulated 
systems aim fly evaluation query evaluation purely techniques stream preprojection query rewriting query compilation 
dynamic buffer management runtime takes consideration current state query processing topic 
stream preprojection stream preprojection non relevant parts input document projected away query evaluation 
query evaluated projected document 
projection realized deriving set paths called projection paths xquery expression 
document path match paths discarded accessed query evaluation reason change evaluation result 
stream preprojection crucial xquery evaluation streaming data significantly reduce amount buffered data coming optimization decreases main memory usage 
stream preprojection xquery proposed time 
ideas works implemented galax system 
shown technique significantly reduce size input document 
applying technique xmark case queries example cases resulted document size reduction 
extension stream preprojection technique discussed 
galax approach fails analyze navigations constructed elements expressions covered analysis extends rules accordingly cover constructs 
approach xml document projection called type projection 
projection extended support backward xpath axes optimizations fast processing descendant axes proposed 
drawback technique requires external schema knowledge dtd xml schema 
approaches focus disk resident xml data 
loading algorithm decides tokens projected away buffered closing tag token read 
approach insufficient streaming scenarios aim discarding tokens early soon opening tag read 
loading algorithm 
question technique applicable streaming scenarios remains unanswered 
preprojection technique consists single pass traversal input document implementation details efficient integration approach questionable 
contrast approach designed streaming scenarios 
pass traversal algorithm ensures tokens projected fly 
decision token discarded early reading opening tag 
furthermore compared optimization exploits semantic properties xquery expression existence check paths buffer observation token required condition check 
address topic descendant axes propose improvement projects away tokens galax approach 
refer section experimental comparison stream preprojection techniques 
algorithms stream preprojection provided section 
implementation techniques task stream preprojection similar evaluation xpath expressions streaming data 
challenge set xpath expressions extract matching document nodes 
valuable groundwork filtering xml streams set xpath expressions refined 
systems deterministic finite automata dfas process input stream 
system xpath backward axes rewritten forward axes enable single pass filtering document 
xquery fragment covers forward xpath axes child descendant axes optimizations required 
approach lazily construct deterministic finite automaton 
similar approach proposed 
shown computational overhead small documents lazy dfas behave streaming scenarios general deal large xml documents 
shown resulting deterministic automata acceptably small practice 
shown experiments holds approach 
construction lazy dfa stream preprojection covered section 
garbage collection garbage collection known technique automatic memory management programming languages 
techniques proposed implemented far 
main task garbage collector identify remove dead objects objects know sure accessed program evaluation 
shortly sketch common garbage collection techniques 
counting garbage collection counting garbage collection object counts number 
runtime new created old expire 
soon number object reaches zero object inaccessible removed 
mark sweep garbage collection pass buffer object reachable marked flag 
unmarked objects safely removed buffer second pass known inaccessible 
copying garbage collection copying garbage collection heap stores objects divided areas 
objects initially buffered area 
soon area filled garbage collection started active objects copied second part buffer ignoring dead objects 
program executed second buffer area expires 
basic techniques exist various combinations garbage collection techniques 
system relies technique strongly related garbage collection counting 
buffered xml node maintains set roles role indicates relevance node 
number roles assigned node seen count object soon node loses role removed buffer 
memory overhead counting garbage collection small general 
copying garbage collection example half buffer storing objects counting garbage collection approach node small amount additional information needs stored roles assigned node counting approach allows time garbage collection 
counter object zero immediately principle save space simply store number roles 
optimization discussed section 
removed buffer 
consequently main memory usage minimized incrementally early 
crucial efficient buffer minimization xquery evaluation aim decreasing high watermark average memory consumption evaluation process 
mark sweep copying garbage collection contrast offer support aggregated collection usually started memory resources expire 
removing single objects early dead objects collected time 
preliminaries preliminaries tag set node labels tags char set characters 
consider xml attributes data model 
poses substantial restriction attributes handled way children node 
xml document root node refer root 
repeatedly switch dual views 
xml documents unranked ordered node labeled trees sorted domain nodes tag names tag values strings alphabet char 
streams opening closing tags character sequences 
depth left right traversal tree document order yields corresponding xml stream stream encodes unranked labeled tree 
example dual views xml documents xml document bib book title dbms title author ramakrishnan author author gehrke author price price book bib described tree title author bib book author price dbms ramakrishnan gehrke vice versa 
document tree dom set nodes 
comparing node sets sets domain dom compare node identifiers 
denotes size number nodes preliminaries document tree root document projection document projection 
introduce concept document projection projection trees 
goal document projection keep parts input document relevant query evaluation 
previous projecting xml includes 
discuss refined restructured case techniques particularly aims projecting xml streams 
comparison projection techniques experimental results 
definition document projection document tree dom set nodes dom node set root projection denoted document tree consisting node set relationships example document projection shows xml document tree nodeset tag names projected tree root 
convenience omit root node printing document trees part document tree 
emphasize contrast stream preprojection techniques definition allows interleaving nodes paths projecting document forced keep paths complete useful dealing descendant axes 
projection paths path expressions primitives navigating tree structure xml documents 
formally introduce paths internally stream preprojection role association 
paths expressions query slightly different preliminaries covered section 
refer syntax definition xquery fragment 
definition path path sequence sn absolute path starting root node sn relative path 
denotes empty path 
location step expressions denoted path step expressions si form axis node test axis child descendant descendant self axis 
node test name tag wildcard symbol matching tag node wildcard node matching node type 
predicate true position accustomed xpath abbreviations 
omit predicate true write bib bib true 
write bib descendant bib child 
shorten bib book position bib book 
denote evaluation path expression context node xpath semantics 
define evaluation path expression projection path function pp characterized equation 
pp intuition formula 
denote subscript expression pp formula 
describes document tree obtained projecting nodes selected evaluating projection path interpreted xpath query computes node set evaluated intuitively spoken projecting xml documents projection path retain nodes relevant xpath expression 
require minimal naive evaluation projection paths identity practice aim discarding nodes relevant evaluating xpath expression 
define evaluation strategy projection paths satisfies semantics 
yield minimally projected tree performed efficiently streams 
motivation considering predicate position streaming evaluation existence checks xquery conditions interested witness node 
preliminaries axis location step expression 
pp root pp root pp pp pp pp axis axis projection path evaluation 
example projection path evaluation consider evaluation projection path descendant descendant root node root document tree 
evaluation strategy pp descendant descendant root root pp root root pp root root pp root pp root pp pp root root projected document tree shown 
obviously characteristic equation projection path evaluation holds root root root descendant descendant expressions evaluate 
projection trees extend definition projection paths projection trees 
projection tree unranked unordered tree root node labeled remaining inner nodes labeled relative path expressions 
projection tree seen collection projection paths path root node leaf defines projection path 
preliminaries intuitively spoken fork projection tree defines projection paths relative context node 
extend function pp evaluating projection tree natural manner 
refer node labeled projection tree set children pp pp pp 
unifying results evaluation projection paths described path tree document get exactly result 
consequently evaluation strategy 

identify path described projection tree 

path compute ni pp root root root node document projected 

result union ni 
example projection tree evaluation consider document trees 
pp projection projection tree minimal projection principle interested minimal projection fulfills equation 
obviously pair projection tree document exists minimal projection 
tree document computation possible streaming scenarios face problem stream delivered token token 
consequently decision project away keep current token projected prefix input stream 
projection technique aims trade effectiveness keeping projected document small possible efficiency little buffering overhead parsing input document possible 
considerations mind implement projection xml streams follows 
simply check power sets document nodes valid projection choose smallest 
preliminaries similar processing xpath streams projection tree compiled automaton matches tokens xml stream nodes projection path 
due restriction fragment forward xpath evaluation semantics decision discard keep document node reading opening tag input stream 
actual streaming algorithm straightforward omitted point discuss possible optimizations technique implementation section 
role association roles finite set elements 
role set multiset roles defined function roles maps roles multiplicity role set 
naturally multiplicity zero means role contained role set 
role set empty roles multiplicity zero 
syntactic convenience denote empty role set 
annotate nodes document trees role sets introduce role assignment function dom yields multiset roles assigned node 
introduce functions adding removing roles node role executing add 
likewise executing rem ifi removal roles undefined 
query language query language section define xquery fragment xq comprises arbitrarily nested expressions conditions joins 
argued xquery fragment covers queries aggregates arise practice 
syntax xq query shown tag string denotes string value var set xquery variables distinguished root variable root unique free variable query 
syntactically richer fragments rewritten fragment large set practical queries expressed full xquery expressions rewritten expressions replaced constructs multi step paths transformed nested loops 
example path step rewriting queries equivalent 
result return result result return return result contrast queries equivalent 
result return result result return return result evaluated stream query extracts xml document result result second returns result result query language semantics xq query query query query query var var axis var var axis return query cond query query cond true exists var axis var axis relop string var axis relop var axis cond cond cond cond cond axis child descendant text relop xquery fragment xq 
semantics xq standard xquery semantics 
operating xml streams interpret xq expressions strictly sequentially 
particular role update mechanism signoff statements relies evaluation order 
define evaluation xq expression free variables function takes tuple trees input environment variables 
symbol denotes list concatenation li th element list 
list constructor denotes empty list 
loop sequentially evaluated list xml tokens follows query language xk axis return li axis variable xk bound successively node list nodes obtained evaluating location step expression axis body loop evaluated immediately new variable binding 
listing complete evaluation strategy xq refer 
introducing signoff statements xq implementing garbage collection assign roles buffered nodes 
nodes lose roles irrelevant remaining query evaluation 
need mechanism signalling buffer manager runtime certain nodes lose roles 
signoff statements inserted queries compile time 
definition syntax signoff statements signoff statement expression form signoff variable relative path expression role 
definition describes semantics signoff statements 
node matching path step expression specified role removed exactly 
definition semantics signoff statements document tree role assignment function 
environment variables variable role semantics 
signoff 
define node set node variable currently bound 
set nodes reachable node xpath expression 

remove role nodes executing rem 
state requirements safe evaluation xquery signoff statements 
query language definition safety xquery evaluation signoff statements evaluation xquery expression signoff statements incoming xml stream called safe exactly conditions hold 

node removals runtime defined 

query evaluated roles removed 
definition enforces exactly instances roles assigned document nodes removed query evaluation 
way strong relation role assignment query rewriting established 
principle safety requirements stated absolutely necessary correct query evaluation 
thing need guarantee node loses role loses relevance query evaluation 
safety statement contributes simple clear system 
principle definition requires role assigned node exactly node role evaluation 
vice versa strictly strategy safety conditions stated hold automatically 
example safety xquery evaluation consider xquery expression result return return result labeled descendant root query outputs node labeled nests labeled descendants current node 
rewriting roles ra rb sketched 
result return return signoff rb signoff ra result query language ra rb rb ra rb ra rb ra rb document tree tree roles tree roles projection role assignment 
evaluation query document tree safe 
evaluation variable bound labeled node exactly 
consequently executed appearance labeled tag nodes buffer lose role 
left side labeled tag node matched twice labeled ancestor receives updates loses roles 
second labeled node contrast matched loses single role rb 
contrast evaluation query document tree safe 
reason labeled node receives updates role rb carries role rb 
condition definition violated 
roles dependency paths query expressions write resp denote subexpression resp proper subexpression 
denote set variables occurring query variables say parent variable denoted exists loop expression axis return inq 
say ancestor variable denoted exists variable write variable tree query summarizes parent child ancestor relationships variables 
variable trees unranked unordered defined nodes edge relation query language example subexpressions parent variables variable trees consider query expression result bib bib return book bib book return book article bib article return article result introduce abbreviation denoting loop introducing variable book bib likewise article bib bib book bib article 
variable tree sketched 
root bib book article variables variable path defined follows 

variable query expression axis return inq 
query example compute book bib child book article bib descendant article 
rq xq roles injective function assigning role xq expression 
define dependencies dep sets tuples variable path expression role 
informally dependencies contain paths relative binding variable particular evaluating existence checks xml streams interested witness output comparison expressions interested relevant nodes subtrees 
definition dependencies query xq 
set dependencies variable denoted dep defined follows 
rq 
axis dep exists axis 
axis descendant self node dep output expression form axis node value node node test expression form axis relop relop axis 
descendant self node dep output expression 
query language example dependency paths consider xquery expression book book return exists book price book author book outputs book document author case price tag exists book 
set dependency paths variable book dep book child price child author descendant self node descendant self node role associated existence check expression role associated subexpression book author role associated output expression book 
static analysis static analysis static analysis input query system tracks goals 
projection tree computed query runtime projected version xml input stream computed query irrelevant parts input copied buffer place 

set roles derived query 
processing input roles assigned buffered nodes fly prerequisite active garbage collection 

query normalization insertion signoff statements buffered nodes deleted runtime irrelevant query evaluation 
particular guarantees approach 
theorem correctness xq query input document tree 
rewritten query signoff statements projected document tree roles assigned nodes 

deriving projection trees xquery fragment statically derive projection tree documents projected sound document tree pp 
key ideas approach 
existence checks conditions suffices keep witness path witnesses irrelevant query evaluation 
node output compared conditions node descendants need contained projected document tree 
loops iterate node sets nodes variables bound relevant query evaluation subtrees irrelevant variable bindings se 
considerations captured dependencies see definition 
query derive projection tree mapping nodes roles steps 

construct variable tree 
extend variable tree nodes labeled path expressions variable dep add node label edge define static analysis root book title root child price descendant self book title descendant self variable tree partially rewritten variable tree child dblp child child price descendant self child dblp child book child title descendant self projection tree projection tree example 
root node relabeled variable node labeled corresponding loop axis return relabel axis define rq 
implementation section discuss simplifications projection trees merging subsuming branches 
example projection tree construction consider xquery expression result dblp return return exists price dblp return book return title result static analysis execution rr role document node execute add child document node execute rr semantics role assignment 
step wise extraction projection tree query shown 
part shows variable tree query 
part variable tree extended corresponding dependencies 
variable dependencies child price existence check expression role associated dependency descendant self node output expression associated role 
variable single dependency child title descendant self node role output expression title 
part shows final projection tree obtained relabeling variable nodes 
assigning roles buffered nodes active garbage collection assign roles buffered nodes 
role assignment tightly bound document projection 
projection tree function assigning role node projection tree 
input document implement role assignment function 
node projection tree labeled set children current context node 
evaluated shown 
example query example roles ra rb illustrates role assignment concrete document tree note labeled node carries role rb twice matched times algorithm 
assignment role implicit root node xml document shown 
static analysis xq rewriting ii iii iv decomposition statements 
runtime goal issue signoff statements early possible size main memory buffer remains small 
time update commands issued early corrupt query result 
insertion signoff statements queries assure 
start discussion query normalization rules discussing insertion signoff statements 
query normalization query rewriting phase push statements loops 
expression decomposed transform expression sequence statements part part respectively decomposition easily realized inference rules 
inference rules cover special cases part empty common practice 
parts empty produces output eliminated completely 
formal extension xq syntax simple statements parts straightforward ignored 
static analysis axis nt return axis nt return pushing statements 
rules ii iii cover cases exactly parts empty rule vi covers general case optimized 
rules pushing statements 
pushing statement sequence expression example covered rule realized application parts sequence 
rule applies node construct expressions rule covers loops similar 
set inference rules applied query normalized fixpoint reached pushes expressions deep possible expression syntax tree 
query normalization necessary ensure correctness active garbage collection system 
shown subsection signoff statements inserted loops 
execution loops encapsulated statements depends value condition undecidable rewriting phase 
consequently sure signoff statements executed 
obviously safe query evaluation introduced definition guaranteed 
pushing statements loops sure role updates runtime depend conditions 
demonstrate sets inference example 
statements decomposed query rewritten inference rules pushing 
static analysis example query normalization consider xq expression result bib bib return exists bib book book list book bib book return book book title book book list books result application decomposition rules yields query 
result bib bib return exists bib book book list book bib book return book book title book book list exists bib book books result sequentially apply rules 
resulting query shown 
result bib bib return exists bib book book list book bib book return exists bib book book book title book exists bib book book list exists bib book books result static analysis normalization rules useful founded theory inefficient practice 
illustrated example pushing statements creates multiple instances statement 
evaluated condition evaluated multiple times 
caching reusing result complicates evaluation process decided slightly different approach 
query normalization changed xq statement semantics 
usual evaluate condition result part 
subsequent evaluation signoff statements nested non matched part ensures independence undecidable conditions computes result 
inserting signoff statements definition straight variables xq query 
variable straight root query expression axis return straight loop expression axis return ancestor variable definition straight ancestor query 
straight ancestor variable defined def straight fsa 
example straight variables straight ancestors variables query example straight aand query variable straight particular root 
position state rules inserting signoff statements queries 
informally scope variable nodes depend straight ancestor variable lose assigned roles 
static xq rewriting rules shown algorithm var provided 
note rewriting rules algorithm apply normalized queries 
root return return static analysis algorithm variable root defined axis return emit signoff rq variable fsa dep emit signoff static query rewriting 
rule applies query inserts corresponding signoff statements root variable 
second rule loop subexpressions rewritten original body evaluated signoff statements executed 
example xquery rewriting consider query example valid rewriting buffered document node variable bound loses role scope respective variable ends 
document trees verify 
ignore signoff command root variable 
reason elimination role assigned root node document signoff statement corresponding variable root possible 
refer reader subsection discussion redundant role elimination 
show document root node figures variable root queries corresponding statement ignored consistency reasons 
shortcut bib root bib 
static analysis result return return result result return return signoff ra signoff root rb result query rewritten query inserting signoff statements 
active garbage collection active garbage collection active garbage collection relies correct interplay assignment roles buffered document nodes timely removal roles ultimately document nodes buffer 
irrelevant nodes specify nodes irrelevant query evaluation safely purged buffer affecting ongoing query evaluation 
node irrelevant conservatively assume relevant query evaluation 
definition irrelevant document nodes buffered document node irrelevant descendants 
discussion assumes buffer contains projected input document buffered nodes closing tag read marked unfinished 
runtime streaming document projection role assignment coupled document node matched set nodes nk projection tree assigned roles associated nk copied buffer 
nodes copied buffer relevant carry role 
discuss loss roles runtime 
buffer cleanup algorithm normally traditional garbage collectors start searching memory freed space allocate new objects 
approach differs garbage collection active 
purge buffers irrelevant nodes time signoff statement issued query evaluator 
garbage collector invoked quite desirable restrict search space irrelevant nodes buffer 
shows handle signoff statements perform localized garbage collection node lost role due signoff statement garbage collector checks deleted 
possible garbage collection proceeds bottom tree 
deletion nodes buffer propagate document root node 
treatment unfinished nodes buffer requires extra care 
unfinished node deleted avoid buffer corruption 
marked deletion ultimately purged buffer corresponding closing tag read input stream 
active garbage collection algorithm signoff role node bound node set defined follows node execute algorithm rem remove role nodes root irrelevant local search parent node finished delete mark deleted ultimately delete closing tag read localized active garbage collection 
system implementation system implementation implemented active garbage collection prototype xquery engine called garbage collected xquery system implemented contrast garbage collected languages gives direct control memory allocation deallocation crucial aspect designing query engine targeting low memory consumption 
system architecture system architecture 
shows system architecture functional point view 
set projection paths computed query analysis 
redundant paths eliminated see subsection path tree constructed 
incoming stream matched tree doing project away unneeded tokens assign roles tokens pass preprojection 
evaluation query rewritten set minimized projection paths 
main task query rewriting insertion signoff commands minimized projection path 
query evaluated buffer contains projected marked stream 
part evaluation process signoff commands emitted requested rewritten query causing buffered nodes lose roles 
system implementation system components runtime interaction system interaction 
described system architecture point view subsection switch implementation details discuss interaction system components query evaluation 
system comprises main components query evaluator stream buffer manager 
pull interaction components illustrated 

query evaluator evaluates rewritten xq expression block new node required variable bound node loop signoff statement encountered 
cases request issued buffer manager query evaluation remains blocked buffer manager responded 

buffer manager answers requests query evaluator 
data required resident buffer buffer manager turn sends requests stream data available buffer evident data exist input input exhausted 
reception signoff statements triggers active garbage collection discussed section 
activated buffer manager stream projector reads input stream token matched projection tree 
case token copied directly buffer roles assigned fly 
chain commands query evaluator incrementally reads input stream evaluates query fly 
note pull approach query evaluator control time new tokens loaded buffer 
evaluation blocked due system implementation incomplete buffer new tokens requested evaluator 
soon evaluation proceed stream preprojection interleaved evaluation resumed 
approach significantly contributes small buffers low main memory consumption evaluation process 
system components large parts independently 
communication components works simple clear interfaces getnext command requests binding variable buffer manager call tells stream project node buffer 
interfaces underline strict separation system components functionality 
buffer manager responsible query evaluation involved buffer management stream preprojection 
cares computation bindings variables execution active garbage collection algorithm buffer aware stream preprojection query evaluation 
task stream project away unneeded tokens buffer needed tokens assigned roles 
note time query processing exactly components control 
crucial avoid conflicts shared data structures 
consider example stream buffer manager 
components buffer running parallel threaded architecture require special care appending tokens removing tokens buffer time result inconsistent states 
problem exist approach time stream buffer manager active 
buffer representation query fragment composition free xquery variables bound existing document nodes 
single buffer contains projected document tree nodes marked unfinished closing tags read 
buffer representation general trade memory consumption evaluation time buffering unstructured encoded string minimizes memory usage efficient access child descendant nodes 
contrast complex data structures proposed require space offer support efficient search indices 
system primarily aims low main memory consumption decided simple tree data structure parent child nextsibling pointers nodes 
additionally buffered tag node maintains flag indicates closing tag read far role information application role aggregation optimization subsection tag nodes carry roles 
system implementation projection tree construction projection trees interpreted collection projection paths projection tree path root node leaf describes projection path 
subsection formal approach projection tree computation 
reconsider topic algorithmic point view 
chapter discuss issues problems arise implementation solution similar dfa determinization order realize efficient stream preprojection 
start discussion relation projection trees projection paths subsection inference rules base projection path extraction subsection describe base projection paths extended projection paths conclude efficient algorithm projection tree setup basing set projection paths subsection 
projection trees projection paths example projection trees multisets projection paths xquery expression bib bib return book bib book return book title cited authors book bib book return exists book cited book author cited authors query returns list book titles subsequently encapsulated cited authors tag book cited list authors 
rules projection tree setup subsection compute projection tree 
child book child title descendant self node child bib child book child cited child author projection tree describes projection paths 
descendant self node system implementation path child bib child book child title descendant self node path child bib child book child cited path child bib child book child author descendant self node principle projection tree define path multiple times 
assume example output titles authors second pass 
projection paths equal 
projection tree defines multiset projection paths set 
labeled paths distinguished underlying query subexpression derived 
cases subexpression variable expression may part expression 
path child bib child book child cited example derived expression book cited subexpression existence check expression 
variable uniquely identifies path exists identical path bound variable usually refer path path relies corresponding variable 
base projection path extraction set inference rules base projection path extraction 
extracted set paths slightly differs projection paths example reason called set base projection paths 
name chosen base projection paths capture prefix original projection path 
names base projection paths base paths interchangeably 
extension full projection paths discussed subsection 
presenting inference rules formally introduce notion path environments 
definition path environment path environment penv function maps variables absolute paths 
empty path environment penv maps variable empty path 
function penv returns current binding variable path environment penv 
write penv denote path environment penv extended mapping absolute path 
example path environment penv penv bib penv penv bib book path environments 
system implementation penv bib penv bib penv bib book penv 
position inference rules base projection path extraction 
inference algorithm started xq expression path environment 
returns tuple base path partition multiset non existence check base paths 
contains output expression paths paths node node comparison checks 
base path partition multiset existence check base paths contains paths existence checks 
base path partition multiset variable paths contains base paths variables bound query evaluation 
shows inference rules non conditional expression shows inference rules conditional expression respectively 
shortly discuss inference rules 
empty empty query contains base projection paths 
string output fixed string implies base projection paths 
variable variable output expressions introduce new non existence check base path defined path variable bound current path environment 
sequence sequence expression form extract base paths subexpression second base paths subexpression 
result union corresponding base projection path partition multisets computed 
base projection paths defined node construction expression computed evaluating encapsulated subexpression 
variable step expressions introduce new non existence check base projection path 
base projection path constructed appending step expression path variable bound current path environment 
ii inference rules covering loops complicated 
rules introduce new path environment adding mapping introduced variable new environment infer base projection paths 
additionally variable implies base projection path variable projection path 
consequently path bound new path environment added partition set variable projection paths 
system implementation penv empty penv string penv penv variable penv penv penv penv penv penv penv axis nt axis nt sequence penv penv penv axis nt penv penv axis nt return axis nt penv penv axis nt penv penv axis nt return axis nt penv penv penv inference rules non conditional expressions 
ii system implementation penv penv exists axis nt axis nt existence penv penv axis nt relop axis nt relop px penv py penv penv relop px py relop penv penv negation penv penv penv op op penv true true inference rules conditional expressions 
system implementation inference rule captures loops introduce variable relative variable second rule covers loops introduce variable relative document root 
step evaluate condition inference rules conditions subsequently compute partition sets part 
result obtained merging extracted base projection path partition sets 
note cover expression replaced query normalization phase subsection 
existence existence check expressions imply existence check base projection path 
base projection path obtained appending corresponding path step expression current binding involved variable 
node value comparisons introduce non existence check base path 
node node comparison expressions similar node value comparison expressions 
carry paths introduce non existence check base paths 
negation base projection paths defined negation expression form paths defined inner expression 
boolean expressions connected operator evaluated independently 
result obtained conjoining corresponding partition sets 
true true expressions introduce new base projection path 
base projection path conversion start discussion base projection path conversion relation base projection paths projection paths demonstrating extraction algorithm previous short example 
example base projection path extraction consider query example 
application inference rule query returns tuple child bib child book child title child bib child book child author child bib child book child cited child bib child bib child book child bib child book note path child bib child book occurs twice 
extracted variables book book 
comparing set base projection paths set projection paths example observe strong relation paths set projection paths 
detail relations hold 
convenience operator conditional expression inference rules 
system implementation non existence check base path child bib child book child title prefix path child bib child book child title descendant self node non existence check base path child bib child book child author prefix path child bib child book child author descendant self node existence check base path child bib child book child cited structural identical child bib child book child cited example multiset projection paths constructed appending descendant self node non existence check base path adding attribute existence check base path 
note extension similar projection tree setup algorithm discussed subsection 
discuss role variable base paths certain circumstances may imply projection paths 
running inference algorithm path environment initially empty extended new bindings variables 
consider inference rule expression 
child return applying inference rule new path environment penv penv child computed path variable bound current path environment penv 
new path environment binds variable path child nested loops xq fragment single step loops proper prefix path empty path base path exists variable bound prefix path path environment penv 
denote variable associated prefix path base projection path pp pp 
example prefix path variables consider base projection path pa child bib child book child author example 
pa child bib pa child bib child book proper prefix paths pa pa pa bib pa pa book 
base projection path pt child bib child book child title proper prefix paths paths pt child bib pt child bib child book 
pt pt bib vpt pt book 
pa pt identical prefix path variables different 
reason pa introduced variable book pt variable book origin xquery expression 
system implementation formally introduce base path variable trees 
definition base path variable tree base projection path length pi prefix path length describes variable variable output expression base path variable tree tree contains variables pi valid variable pm ancestor pn exactly denote set variables pi tree example base path variable tree pa pt projection paths example 
base path variable tree projection path pa bib book bib ancestor book 
base path variable tree base path pt bib book bib ancestor variable book 
variable trees left side right side shown 
note base path variable tree describes single path reason contains branches 
bib book bib book definition subsumption base path variable trees 
subsumed definition naturally extends base paths 
base projection path subsumed base path base path variable tree tp subsumed base path variable tree tp 
definition require parent child relation variable trees identical 
requirement automatically holds assume variable names xquery expressions unique goal compute set projection paths starting set base projection paths query expression 
convert existence check base paths nonexistence check base paths illustrated example role variable base paths discussed 
variable base path generate projection path subsumed projection path 
case projection path identical base projection added set projection paths 
unique variable names easily obtained alpha renaming 
system implementation definition projection path reconstruction sets base projection paths extracted inference rules subsection 
set pp projection paths constructed follows 

path add projection path descendant self node pp 

path add projection path pp 

path subsumed path add projection path pp 
definition example variable base path contributes set projection path variable paths subsumed 

base variable path child bib subsumed variable paths paths labeled child bib child book 

variable path child bib child book refers variable book original query shown example subsumed non existence check base path child bib child book child title 

variable path child bib child book contrast refers variable book subsumed non existence check base path child bib child book child author 
example projection path reconstruction consider xquery expression bib bib return book bib book return book running inference algorithm query returns tuple child bib child bib descendant book 
base projection path child bib subsumed base path child bib descendant book base path subsumed path 
definition set projection consists single path pp child bib descendant book 
projection tree setup algorithm far analysis covers projection paths extraction 
sketch projection tree constructed set projection paths 
algorithm projection tree setup sketched 
creating root node step projection path new branch added root node step 
final step algorithm merges branches rely variable origin xquery expression 
system implementation create new tree root node labeled 
projection path set branch child root node 
new branch represents ordered sequence path steps path step node constructed parent child relation extended pair successive path step expressions 
projection tree node ni describes prefix path projection path 
final step merge level projection tree nodes 
starting level traverse levels order 
projection tree nodes ni mi describing prefix paths pni pmi projection paths pn pm merged exactly conditions hold 
ni mi share parent node ni mi carry identical path step expressions pn pn equals pm pm projection tree setup algorithm 
example projection tree setup algorithm consider set projection paths extracted example 
construction projection tree illustrated 
part illustrates projection tree immediately application step algorithm 
exist projection paths root node contains branches projection path 
part bib nodes branches merged 
share parent root node carry label bib share common base variable bib 
final projection tree shown example 
obtained merging book nodes second third branch 
note book node branch merged base path variable book differs base variable book book nodes condition violated 
projection tree determinization describe projection tree efficient stream preprojection marking 
shown subsection projection tree exists function assigning unique role node 
key idea fails projection trees descendant axes see example simple straightforward 
projection tree interpreted finite automaton system implementation child bib child book child title descendant self node child bib child bib child book child book child author child cited descendant self node projection tree application steps child book child title descendant self node child bib child book child book child author child cited descendant self node partially merged projection tree projection tree setup example 
track incoming stream 
initially start root state 
reading token input stream distinguish cases 

opening tag exists transition current state node ni path step expression ni matches buffered role ni current state changed state ni correspondingly 
closing tag case corresponding buffered tag marked finished previous state restored 

character data exists transition current state node ni step ex note cases role assigned multiple times certain node 
simplicity topic ignored orthogonal issue discussed subsection 
system implementation child descendant self node child bib descendant book descendant self node child bib child descendant book origin projection tree partially transformed tree deterministic projection tree setup 
pression ni matches buffered node role ni 
state remains unchanged 
algorithm works fine path trees descendant axis labels wildcard nodes technique fails projection tree contains nodes descendant axis labels 
due sibling tag wildcard nodes cases required track different states parallel 
problems discussed example 
example problems stream preprojection consider xquery expression bib root bib return bib return bib book return corresponding projection tree shown 
function mapping projection tree node ni role ri 
discuss preprojection input stream starting sequence bib book 
projection tree nodes interpreted states notions nodes states interchangeably 
initially start state projection tree 
tag bib matched state consequently buffer tag role change current state 
read tag book matches child nodes 
case captured rules 
intuitively track states parallel 
doing assign roles change current state composed state 
problem arises descendant axis node 
assume encounter nested book current book read book tag receiving tag book current book 
obviously book tag matched node describes path child bib descendant book 
problem current state subsequent states discard matching tag strictly rules 
descendant axis nodes require special handling 
system implementation example shows type projection trees introduced far hard stream preprojection reasons 
document paths matched multiple projection tree nodes parallel introducing composed states complicate implementation 
descendant axis nodes require special care 
intuitively spoken handled different levels original document tree 
problems particular special handling descendant axis nodes imply problems reconstruction previous state difficult time consuming 
argue problems rule efficient clean implementation stream preprojection 
reason lazily transform nondeterministic projection tree deterministic finite automaton stream preprojection 
lazy dfa construction known technique automata theory successfully employed 
sketch technique projection tree determinization 
projection tree fusion step projection tree determinization merge labeled sibling nodes top traversal projection tree 
origin projection tree role assigned exactly projection tree node 
fusion nodes demands extended role assignment function maps nodes set roles single role 
extended role assignment function constructed rules 

node new function defined follows 
def informally spoken returns set containing role node 
merging nodes ni nij single node ni new role assignment function maps aggregated set roles def ni nik 
special case worth mentioning 
existence check expressions introduce projection tree nodes additional attribute position 
aim projection tree determinization nodes merged nodes carrying attribute true 
system implementation attribute true merged node drop attribute position 
information contained attribute position decoded role carried existence check node role aggregation described definition non existence check base projection path introduces descendant self node child node corresponding projection path 
nodes match document subtrees single document nodes corresponding role assigned document node matching base projection path descendants 
implementation non existence check role create aggregated role assigning role matching node descendants simply assign aggregated role single node role minimizing technique simplifies update mechanism single node carries aggregated role needs updated 
implementation optimization definition 
definition implementation role aggregation implement role aggregation follows 
descendant self node projection tree leaf node role parent node 
discard node 
extend role assignment function follows 
note aggregated roles induces minor changes signoff gc algorithms role updates sent aggregated role carrying node 
changes straightforward discussed 
example role aggregation application role aggregation rules projection tree derived query example yields projection tree 
associated role assignment function contains mappings 
simply realized function returns true existence check roles false 
note nodes leaf nodes 
system implementation lazy dfa construction projection tree resulting previous subsection deterministic 
labeled nodes merged remain scenarios causing problems straightforward stream preprojection algorithm interprets tree automaton manner 
wildcard nodes may matched parallel tag nodes 
descendant axis nodes may matched parallel non descendant axis nodes 
descendant axis nodes may matched different levels 
order give intuition construct deterministic projection tree describe key ideas informally examples 
algorithm technical contains special cases contribute understanding techniques omitted 
strategy removing nondeterminism caused wildcard nodes simple 
problem wildcard nodes matched parallel tag nodes projection tree 
assume example exists wildcard node labeled child sibling non wildcard nodes say child author child title 
wildcard node relabeled child author title expressing node matches tag author title tags 
coming rewriting adjustments 

roles wildcard node added child title child author node role set 

child subtrees wildcard node added subtrees child title child author nodes nodes child title child author represent composed states 
node matches child title gets assigned roles title node roles wildcard node added role set title node 
matching title node match children title node subtrees wildcard copied title node 
example wildcard node transformation consider projection tree role assignment function defined example 
wildcard transformation rules transform projection tree follows 
step introduce labeled children merging required 
system implementation child bib child book descendant book new role assignment function described mappings 
note wildcard node roles added set book node roles 
elimination problems introduced descendant axis nodes sophisticated 
key idea throw away axes projection tree 
coming transformation descendant axis nodes distributed subtree spanned descendant node matched sub level 
role assignment function adapted accordingly roles distributed subtree 
resulting deterministic projection tree infinite reason computed lazily stream preprojection 
nodes matched stream preprojection unfolded demand size deterministic projection tree limited structure document 
branch unfolded matched identical input document paths recomputation 
computational overhead small documents technique behaves streaming scenarios general deal large input documents 
structure input documents homogeneous practice size deterministic automaton remains acceptably small 
example deterministic projection tree shows deterministic projection tree derived projection tree introduced example shown 
left side projection tree unfolded level right side level level structurally equal left side 
nodes labeled computed 
role association function deterministic projection tree contains mappings roles ri roles example 
deterministic projection tree carry axis information 
book node distributed subtrees 
level descendant match node book reading book tag match sibling node book reading tag different book entering deeper level node book matched 
system implementation book 
book book 
book book 
book bib book 
book 
deterministic projection tree 
book book 
covering exact rules stream preprojection conclude discussion detailed example illustrates ideas stream preprojection role assignment deterministic projection tree 
example stream preprojection role assignment consider deterministic projection tree associated set roles shown example 
describe process marking xml stream 
bib book title book title title author book author author book article title article title title author article author author cite book book title book cite article bib projection tree 
reading tag bib match initially start state child node bib tag buffered role set current state changed 
tag book matched state buffered roles 
subsequently title read principle discard document nodes match nodes matches node implied dtd xml schema information restrictions 
system implementation empty role set node carries aggregated role 
recall aggregate roles inherited subtree buffer title tag empty role set 
current state changed character data book title buffered reason 
note processing character data change current state 
reading closing tag title buffered title marked finished current state reset author processed analogously title buffered empty role set state 
read closing tag book buffered book marked finished current state reset parent state buffer tags article matching state title matching state corresponding character data tag author character data 
having processed closing tag author state tag cite read matched projection tree node buffered empty role set 
book tag matched node consequently buffered role set 
note role set different role set assigned book 
stream processed state 
previous example projected away 
reason original query see example expression bib return forces keep children bib node 
general stream preprojection discard token matched projection tree node matched projection tree node empty role set cases valid exists ancestor node carries aggregated role 
syntax expression implementation syntax implementation strongly related syntax shown appendix note allow brackets absolutely necessary sequence expressions conditions 
worth mentioning operators operators bind identically strong 
require variable names unique introduce variable root free variable xq expression initially bound document root 
uml class concept expressions illustrated appendix 
readability reasons divided parts 
appendix illustrates implementation conditional expressions non conditional expressions appendix expressions base class expression defines common set virtual functions expressions offers default implementation 
interesting functions nodes result descendant axis rewriting roles intuitively spoken purpose keep track current document tree level 
system implementation void eval environment env unsigned modus evaluates expression environment 
modus restrict evaluation nested signoff statements addresses implementation approach subsection topic statements nested inside loops 
bool checks variable scopes valid void pp extracts projection paths expression fills passed class pp void vt extracts variable tree set structure expression extracts variable straight ancestor mappings expression class directly inherits non conditional expressions 
conditional expressions base class 
class introduces virtual function bool environment env evaluate conditional expressions 
class inherits expression class 
conditional expression node node node value test expressions inherit directly 
node node node value test expressions contrast share common base class inherited provides function relational operator evaluation 
optimizations optimizations contribute space runtime improvements 
optimizations implemented prototype 
refer discussion unimplemented optimization techniques section 
elimination redundant roles immediately base projection path computation drop redundant roles corresponding role assignment function 
elimination redundant comes step consequently query evaluation speeds 
elimination applies roles implied variable base paths 
notion subsumption introduced definition roles generated subsumed variable base paths dropped note implementation requires minor changes buffer update stream preprojection query rewriting algorithm discussed 
skip details technical 
system implementation example role elimination consider set variable base paths example 
drop roles implied base paths variable paths subsumed base projection path 
corresponding path tree shown example roles nodes dropped 
tag name hashing stream preprojection construct bidirectional hash table mapping tags integers vice versa 
data simply store identifying integer buffered tag node 
small computational overhead stream preprojection phase common technique saves space speeds query evaluation node node comparisons implemented fast integer equality tests 
pushing signoff statements query preprocessing improve effectiveness garbage collection 
rewritten query command signoff book title descendant self node issued title node output 
book title garbage collection invoked titles output 
easily avoided rewriting output expressions contained original query equivalent expressions return new variable 
rewritten query shown 
result bib bib return bib return exists price bib book return title return result corresponding signoff command pushed new loop introduces variable updates sent immediately title 
experimental results experimental results experimentally evaluated prototype implementation 
section queries correctness tests discuss benchmarking results stream preprojection query evaluation 
correctness tests experimentally verified correctness system miscellaneous queries different projects 
evaluation results compared results delivered xquery implementation galax 
detail queries correctness tests 
note queries slightly adapted system support full xquery standard 
xmp xquery queries xmp xquery provided appendix 
queries evaluated original xml documents 
dbms milestone test queries furthermore queries saarland university dbms course held summer term 
set verified queries appendix 
xmark benchmarking project verified correctness xmark queries benchmarking tests subsection 
set queries xq syntax shown appendix user defined queries set user defined queries check correctness crucial system components 
query collection focuses queries descendant axes assignment multiple role instances 
user defined queries listed appendix 
test queries verified safety requirement stated definition 
cases buffer empty query execution undefined role updates sent query evaluation 
stream preprojection experimentally evaluated stream compared results stream preprojection techniques 
experimental results compared system stream preprojection technique proposed implemented galax 
unfortunately get galax stream preprojection computation preprojection paths succeeded 
manually applied projection paths input document strictly rules 
compared results type stream preprojection system freely available download 
unfortunately type projection implementation offers support single xpath expressions xquery 
path extraction xquery expression requires manual extraction xpath expressions described query 
queries containing xpath expression evaluated xpath expressions sequence computed resulting document union computed documents 
furthermore type projection support position attributes useful dealing existence check projection paths witness node needs buffered 
consequently xpath position attributes rewritten attribute true 
xpath lacks support discarding subtrees prototype offers flag enables projecting away unneeded subtrees 
tests flag set possible 
tests carried set user defined queries cover different aspects stream preprojection 
test queries xq syntax shown 
cases queries evaluated xml stream shown 
table shows results stream preprojection 
query easily projected standard stream preprojection techniques 
single path child book child title descendants needs extracted thrown away 
systems able compute minimal projected document 

second query contains single projection path child book child author 
author output contrast subtrees thrown away 
consequently type projection executed flag 
systems compute minimal projected document 

third query addresses descendant processing 
smart implementation throw away single path steps bib tag closing tag thrown away required query evaluation 
clear table system line breaks tabs ignored discussion table readability reasons 
experimental results book root book return title book title return title book root book return author book author return author match author match section root section return section section book root book return exists book author book title exists root section stream preprojection test queries 
experimental results book title data web title author serge abiteboul author author peter buneman author author dan suciu author section title title section title audience title section section title web data cultures title title traditional client server architecture title image section section section title syntax data title title graph representations structures title image section title base types title section section book xml stream preprojection tests 
experimental results galax expected result type projection book title data web title book book author author author author author author book section section section section section section section section section section section section book title data web title author author book section section book title data web title book book author author author author author author book book section section section section section section section section section section section section book book title data web title author author author author author author book book section section section section section section section section section section section section book table stream preprojection results 
manages apply optimization book title data web title book book author author author author author author book book section section section section section section section section section section section section book book title data web title author author author author author author book book section section section section section section section section section section section section book 
query contains existence check expression 
book occurrence title buffered 
system applies optimization systems unnecessarily keep author nodes 

final query combines descendant existence check scenario 
supports combination techniques computes minimal projected document 
document root node bib projected away result interpreted sequence xml streams evaluated order 
experimental results examples demonstrate power stream preprojection algorithm 
computation minimal projected document single pass undecidable general system managed compute minimal projected document example queries 
evaluation time memory consumption order assess merits active garbage collection implementation experimentally evaluated number xmark queries 
prototype implemented exactly described 
xq fragment introduced section cover full xquery standard queries adapted correspondingly 
detail converted xml attributes subelements replaced aggregations count outputting value 
identical 
considered xmark documents sizes mb mb generated xmark data generator 
tests carried ghz cpu intel pentium iv gb ram running linux 
java systems executed re 
implementations considered broad spectrum xquery engines appropriate systems saxon java java open java 
capable evaluating xquery large input documents 
particular flux query engine designed xml stream processing 
experiments provided xmark dtd 
considered monetdb system combined xquery module relies secondary storage 
memory xquery engine galax implementation xquery standard 
galax designed xml stream processing mind consulted xquery benchmarks reason included 
note static projection galax 
focus experiments primarily main memory consumption considered query execution time 
main memory consumption measured undecidability immediately follows undecidability conditional expression decide projection paths encapsulated statements accessed 
experimental results query galax monetdb saxon mb mb mb mb mb mb mb xmark mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb xmark mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb gb mb mb mb mb mb mb mb mb xmark mb mb mb mb mb mb mb mb mb mb timeout mb mb mb mb timeout timeout timeout mb gb mb mb mb mb mb mb mb mb xmark mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb gb mb mb mb mb mb mb mb mb xmark mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb mb gb mb gb mb table benchmark results 
linux top command 
system query set timeout hour 
shows results experiments 
system size input document measured high watermark non swapped memory consumption total query evaluation time 
indicates query expressed language supported specific engine 
java engines observe due effects caused automatic memory management java virtual machine memory consumption increased document size buffer size remained constant 
experimental results table confirm expectations significant impact combined static dynamic buffer minimization xquery evaluation 
regarding memory usage small stream sizes outperforms competitors factor 
notably evaluate queries little buffering shows performance small large documents 
gap significantly increases document size 
queries memory consumption prototype independent input stream size 
little buffered time observe low main memory consumption coincides low evaluation time system 
note contains descendant axis xpath expressions supported 
involves xquery join nodes buffered 
system manages evaluate query low main memory consumption 
similar system joins implemented naive nested loop joins experimental results runtime deteriorates larger input documents 
runtime vital practical systems orthogonal issue easily improved standard database techniques 
summary experiments confirm buffer management approach active garbage collection performs main memory consumption execution time show large class queries beat query engines exploit schema information 
standard database techniques system uses simple straightforward operator implementation 
search realized simple buffer scans joins implemented nested loop joins 
significantly improve query runtime standard database optimization techniques 
simple nested loop joins advanced join techniques hash joins index joins 
common database techniques join reordering query rewriting cost estimation improve performance 
strategy extend stream set indices onthe fly 
consider example projection paths implied variables introduced loops 
node variable bound evaluation recognized matches associated projection path 
construction indices easily embedded current system 
fly evaluation embedded system 
early buffer cleanup compensate fly evaluation practical queries outputting parts input stream fly possible improve evaluation performance buffer minimization 
note system primarily aims low main memory consumption 
techniques advanced join implementation indexing degree contradict dogma streaming xquery evaluation insofar require additional space maintain data structures hash tables indices 
decision indices trade runtime space efficiency handled care order maintain benefits low memory consumption 
exploiting schema knowledge query optimization schema knowledge subject extensive studies 
document type definitions dtds xml schemata help improve memory consumption runtime 
far system uses schema information 
dtds imply structural constraints document 
document said valid dtd satisfies constraints imposed dtd 
example dtds consider dtd 
book document valid restricted consist exactly title followed set authors followed set followed single price tag 
tags required occur order book authors listed tags 
elem root bib elem bib book article elem book title author price elem article title author journal elem title pcdata elem author pcdata elem pcdata elem title pcdata elem price pcdata elem journal pcdata dtd reducing memory consumption system example exploits dtd order information decrease amount buffering 
demonstrate key idea example 
example exploiting dtd order constraints consider xquery expression 
result bib bib return book bib book return author book author return author book return result query extracts author followed book child bib tag 
consider evaluation streamed input document 
title dbms author ramakrishnan bib book book book price assume dtd available 
tags bib book need buffered required navigation 
author discarded immediately output 
reading tag allowed output 
exist book authors output 
reasoning holds second tag 
reading book sure author child 
output buffered purge buffer immediately 
assume evaluate query document satisfying dtd 
implies book authors listed 
reading tag guaranteed author current book exists 
consequently evaluating query authors output fly 
amount buffered data decreases 
uses static dtd query analysis detect situations described example 
query language extended constructs fly evaluation results static analysis query rewritten accordingly execution 
system offers support descendant axes clear extended accordingly 
question extension ideas incorporated approach investigated 
accelerating query evaluation situations dtds speed query evaluation 
optimizations capture stream preprojection query evaluation 
sketch optimization approaches 
dtd stream preprojection 
stream matches set projection paths incoming stream filtering unmatched document paths 
knowledge dtd useful exclude paths 
initially projection path checked valid dtd 
invalid paths thrown away matched valid document 
optimization purely static stream preprojection run situations projection paths excluded 
exist projection paths descendant axis path steps point input stream processing detect descendant current subtree projection path excluded subtree 
reducing number projection paths early reduces search space speeds query evaluation 
example dtd stream preprojection consider dtd 
assume query set existence check variable projection paths 
pp bib bib book bib book section price static dtd analysis exclude projection path bib book section priori path matched document valid dtd book contains section tags 
assume stream starts bib book projection paths bib bib book matched current subtree projection path matched path price 
reading article exploiting dtd information sure price projection path matched current subtree books carry price children 
article descendants projected away checks 
accelerating buffer scans 
query evaluation dtd knowledge useful 
computation new bindings variables requires search buffer scan buffer nodes matching path step relative node 
problem similar stream preprojection described previous paragraph 
preprojection scenario match set path document 
runtime search principle special case requires match single example dtd runtime search improvement consider xquery expression price return price schema information computation binding requires scan complete buffer 
tag checked price tag 
high number equality checks significantly slow query evaluation 
dtd information get rid runtime checks 
consider evaluation query document valid dtd 
assume read article scanning buffer binding variable scanning buffer price tag 
implies articles carry price descendants skip subtree nodes resuming search sibling article 
incorporating aggregation currently system support xquery aggregation operators 
corresponding extension xq fragment straightforward challenge embed aggregation buffer management scheme 
fragment supports single step path expressions 
role representation safety requirement stated definition enforces exactly instances roles assigned document nodes removed query evaluation 
implementation currently assign sets roles nodes 
similar garbage collection counting single role counter node keeps track current number roles assigned node 
decreased time node receives role update 
role counter reaches zero safety requirement ensures node lost roles 
technique accelerates role update mechanism set operations deal simple counter increment decrement operations 
important amount memory required saving role information decreased 
maintaining set roles node simply associate single integer counter node 
optimization significantly reduce amount main memory consumption large number nodes needs buffered time 
roles internally stored integers 
shown experimental results combined static dynamic buffer management scheme behaves practical xquery expressions 
conclude combination static dynamic buffer management crucial performance regarding space time efficiency 
think system relies ideas similar garbage collection counting follows intuitive paradigm 
static analysis project away irrelevant parts input stream 
tokens pass projection phase get assigned set roles loaded buffer way preparing garbage collection runtime 
established technique lazy dfa construction stream preprojection proves efficient practical queries xmark benchmark project 
runtime overhead preprojection phase low benefit stream preprojection high 
single buffer tree ensures buffered twice evaluation 
buffer tree structure minimal parent child sibling pointers 
index structures queries buffer representation proves efficient 
lack index structures cases compensated fast buffer scans buffer solely contains evaluation relevant data 
active garbage collection runtime approach similar garbage collection counting ensures tokens irrelevant evaluation purged buffer early 
technique significantly contributes goal low memory consumption query evaluation process 
xq concrete syntax xq concrete syntax start exp exp exp exp var exp axis axis axis child descendant xq concrete syntax true relop fixed string tag identifier root variable initially bound document root node xq concrete syntax uml conditional expressions expression pp type exp type expression type exp type expression print ostream void def vars vector unsigned bool void env void vt void fsa parent var unsigned void vector unsigned vars void updates vector expression eval env environment modus unsigned void instance static tab int static void void void type exp type env environment bool left right left right exp exp type exp type const char op comp type const char static bool left right left right left op comp type nt const char op comp type nt const char left op comp type right left comp type op right xq concrete syntax uml ii non conditional expressions vector vector void var var axis axis type nt const char axis axis type nt const char axis type const char varname expression instance static varname names vector const char static varname varname name const char unsigned id unsigned const char varname pp type exp type expression type exp type expression print ostream void def vars vector unsigned bool void env void vt void fsa parent var unsigned void vector unsigned vars void updates vector expression eval env environment modus unsigned void instance static tab int static void void void id unsigned name const char unsigned text const char text const char var exp expression var exp expression var unsigned path index int var unsigned path index int exps vector expression left expression right expression vector expression cond expression expression cond expression expression queries correctness tests queries correctness tests xmp xquery result bib bib root bib return book bib book return book publisher addison wesley book year book book year book title book bib result results bib root bib return book bib book return title book title return author book author return result title author result results results bib root bib return book bib book return result book title book author result results queries correctness tests result bib book root book return exists book author book book title book author book book root book return exists book editor book title editor book editor return editor affiliation bib result queries correctness tests dbms milestone test queries result root section return return result result root return root section return result title list section root section return exists section image title section title return title title list title list section root section return section image title section title return title title list queries correctness tests title list section root section return title section title return new title child title return child new title title list title list section root section return section exists section section subsection subsection title section title return subsection child title return child subsection element root return element element section title list title list section root section return exists section section title section title return title title list queries correctness tests result root section return title title result doc root doc root section root title bla bla root root return queries correctness tests user defined queries result bib root bib return exists bib book book bib book return book title book bib book return book author result result bib root bib return book bib book return exists book test match book title match result result book root book return book result result title root title return title result result root book root book return exists book test book result queries correctness tests result bib root bib return book bib book return match book title book author match result result bib root bib return book bib book return book bib book return book author book author match book title book title match result result bib root bib return book bib book return book bib book return book author book author book title book title match book title book title match result queries correctness tests result bib root bib return book bib book return book author author match book title match book title result xmark test queries xmark test queries query site root site return people site people return person people person return person person id person result person name result query query auction root auction return site auction site return regions site regions return regions item query query site root site return people site people return person people person return item person person name person items bought site root site return cas site closed auctions return ca cas closed auction return buyer ca buyer return buyer buyer person person person id result ca result items bought item query xmark test queries query site root site return regions site regions return australia regions australia return item australia item return item name item name name desc item description desc item query query site root site return people site people return person people person return exists person income person query franklin 
efficient filtering xml documents selective dissemination information 
proc 
icde pages 
bar yossef 
memory requirements xpath evaluation xml streams 
proc 
pods pages 
benedikt fan 
xpath satisfiability presence dtds 
proc 
pods pages 
benzaken castagna nguyen 
implementation type xml projection vldb 
www lri fr kn 
benzaken castagna nguyen 
type xml projection 
proc 
vldb 
catania lacroix li 
accelerating queries pruning xml documents 
tkde 
bry 
xml stream query processor 
icde pages 
fischer franklin 
yfilter efficient scalable filtering xml documents 
proc 
icde 
dtd tutorial 
www schools com dtd default asp 
fegaras dash wang 
fully pipelined xquery processor 

fegaras levine bose 
query processing streamed xml data 
proc 
cikm pages 
florescu kossmann lucas riccardi carey agrawal 
bea streaming xquery processor 
proc 
vldb pages 
engine 
www db cs de html 
galax 
www org 
gottlob koch pichler 
xpath processing nutshell 
acm sigmod record 
green miklau suciu 
processing xml streams deterministic automata 
proc 
icdt pages 
koch 
tight lower bounds query processing streaming external memory data 
proc 
icalp pages 

moerkotte 
xquery processing emphasize join ordering 

jagadish chapman lakshmanan patel srivastava wu yu 
timber native xml database 
proc 
vldb pages 
koch 
complexity nonrecursive xquery functional query languages complex values 
proc 
pods pages 
koch 
role composition xquery 
webdb pages 
koch 
complexity nonrecursive xquery functional query languages complex values 
acm transactions database systems 
appear 
koch 
schema scheduling event processors buffer minimization queries structured data streams 
proc 
vldb pages 
li agrawal 
efficient evaluation xquery streaming data 
proc 
vldb pages 
lud scher mukhopadhyay papakonstantinou 
transducer xml query processor 
proc 
vldb pages 
madden franklin 
stream architecture queries streaming sensor data 
proc 
icde 
marian sim 
projecting xml documents 
proc 
vldb pages 
monetdb xquery 
monetdb cwi nl xquery 

forward node selecting queries trees 
tods 
conditionally accepted 

streamed progressive evaluation xpath 
tkde 
conditionally accepted 
bry 
efficient single pass query evaluator xml data streams 
proc 
th annual acm symposium applied computing sac mar 
technical report 
bry 
evaluating complex queries xml streams polynomial combined complexity 
proc 
pages 
xpath looking forward 
edbt proceedings xml data management multimedia engineering revised papers pages 
evaluation regular path expressions qualifiers xml streams 
proc 
icde page 
peng chawathe 
xpath queries streaming data 
proc 
sigmod pages 
peng 
extending xml document projection data integration 
information reuse integration conf 
iri ieee international conference pages 
open 
www com 
ramakrishnan gehrke 
database management systems rd edition 
mcgraw hill higher education 
saarland university database group 
database systems 
www db cs uni sb de teaching dbs 
saarland university database group 
database systems xquery test cases 
www de teaching dbs html 
saxon 
saxon sourceforge net 
su rundensteiner mani 
semantic query optimization xquery xml streams 
proc 
vldb pages 
native xml management 
www com corporate products default asp 
wilson 
uniprocessor garbage collection techniques 
proc 
pages 
world wide web consortium 
document object model dom 
www org dom 
world wide web consortium 
case xmp 
www org tr wd xquery cases 
world wide web consortium 
xml path language xpath 
www org tr rec xpath 
world wide web consortium 
xml path language xpath 
www org tr cr xpath 
world wide web consortium 
xml query xquery 
www org xml query 
world wide web consortium 
xml schema 
www org xml schema 
world wide web consortium 
xquery xpath formal semantics 
candidate recommendation june 
www org tr query algebra 
open source xml native xml database system 
www com corporate products default asp 
xmark 
monetdb cwi nl xml 
