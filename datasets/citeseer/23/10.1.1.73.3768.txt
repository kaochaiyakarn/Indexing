best case complexity asynchronous byzantine consensus dutta rachid guerraoui marko school computer communication sciences epfl ch lausanne switzerland 
establishes theorem relating resilience time complexity authentication distributed computing 
study consensus algorithms tolerate byzantine failures arbitrary long periods asynchrony 
measure ability processes reach consensus decision minimal number rounds information exchange function ability authentication number actual process failures rounds total number failures tolerated system constellation 
constellations considered distinguish different roles processes directly derive meaningful bound time complexity implementing robust general services replicas coordinated consensus 
prove theorem establish certain lower bounds give algorithms match bounds 
algorithms variants generic asynchronous byzantine consensus algorithm interesting right 
context establish theorem complexity consensus problem general distributed framework composed kinds processes proposers acceptors learners fig 

basically problem consists learners decide common value proposed proposers acceptors witnesses help ensure agreement 
learner supposed eventually learn value liveness proposed value learners safety 
measuring complexity learning decision framework automatically derives measure complexity state machine replication general technique build robust distributed services consensus :10.1.1.20.4762
study consensus algorithms tolerate byzantine failures processes 
byzantine failure correspond crash malicious behavior default failure means byzantine failure 
process malicious deviates algorithm assigned way different simply stopping activities crashing 
process failures algorithms consider tolerate arbitrarily long periods asynchrony relative speeds processes communication delays unbounded 
algorithms called asynchronous :10.1.1.127.6130
assume duration asynchronous periods number occurrences finite consensus known impossible 
processes fail called correct processes eventually communicate timely manner 
model assumed called eventually synchronous model matches practical systems internet synchronous asynchronous 
important tolerate periods asynchrony failures possible important optimize algorithms favorable frequent situations system synchronous processes fail 
question address fast decision learned favorable situations 
words explore best case complexity asynchronous byzantine consensus 
clearly possible learn decision round information exchange say communication round ensure agreement despite possible byzantine failures 
conjectured show favorable situations quite common practice learning achieved communication rounds call fast learning proposer value learned fast called privileged proposer 
furthermore algorithms certain slightly favorable situations decision learned communication rounds correct learners call fast learning :10.1.1.127.6130
precisely set proposers similarly denote set acceptors set learners 
fix consensus algorithm value na 
definition favorable runs 
run favorable synchronous acceptors faulty definition fast learning 
proposer achieves fast resp 
fast learning despite failure acceptors favorable run correct proposes value correct learner learns value proposed resp 
communication rounds privileged proposer 
proposer achieve fast learning despite failure acceptors called privileged proposer 
denote priv set contains privileged proposers consensus algorithm said achieve fast learning despite failure acceptors priv 
theorem give establishes general tight bound resilience consensus algorithms achieve fast learning despite failure acceptors 
addition establishes tight lower bound resilience call gracefully degrading consensus algorithms 
definition graceful degradation 
consensus algorithm said gracefully degrading achieves fast learning despite failure acceptors priv proposer priv achieves fast learning despite failure acceptors definition features consensus resilience thresholds define 
convenience say gracefully degrading consensus algorithm achieves fast learning despite failure acceptors addition achieving fast learning despite failure acceptors theorem general sense accounts classes parameters vary independently different consensus resilience thresholds different system constellations ability processes authentication primitives public key cryptography achieve fast fast learning 
precisely furthermore presentation simplicity saying fast resp 
fast learning despite failure resp 
acceptors simply say fast resp 
fast learning obvious context 
simplification graceful degradation vs graceful degradation 
proposers privileged prop 
acceptors propose na learners fast learning rounds constellation fast learning rounds proposers priv prop acc 
acceptors na learners propose process failure constellation fig 

fast fast learning constellation 
distinguish resilience thresholds denotes maximum number acceptor malicious failures despite consensus safety ensured consensus algorithms eventually synchronous model remain safe despite crash failure number acceptors denotes maximum number acceptor failures despite consensus liveness ensured 
particularly interesting case consensus safety preserved despite acceptor malicious failures liveness guaranteed number acceptor failures literature special case usually considered 
advantages distinguishing thresholds 
highlight influence lower bounds malicious behavior processes process non responsiveness 
boundary case acceptor failure model non byzantine crash failure model 
bounds derived general case parameters bridge gap byzantine crash failure models establishing result applicable 
furthermore approach allows flexibility construction practical hybrid algorithms 
example want tolerate certain relatively small number byzantine failures system prone crash failures approach requires fewer processes expected failure modeled byzantine failure 

distinguish system constellations constellation privileged proposer acceptor privileged proposers fig 
constellation exactly privileged proposer acceptors fig 

formally system constellation priv priv constellation priv priv 
interested case priv 
show choice constellation clear impact optimal resilience consensus algorithms achieve fast learning ability gracefully degrading 

distinguish case processes allowed authentication achieve fast resp 
fast learning authentication resp 
communication rounds case 
cases indifferent processes authentication runs enable fast fast learning typically non favorable runs proposer failures asynchronous periods 
roughly speaking authentication allows recipient message validly claim third party received message original sender message 
authentication major source overhead typically avoid authentication fast learning 
theorem show consensus algorithm 
achieves fast learning despite failure acceptors constellation total number acceptors system na na 
addition gracefully degrading consensus algorithm achieves fast learning despite failure acceptors authentication total number acceptors na 
achieves fast learning despite failure acceptors authentication na greater min 

achieves fast learning despite failure acceptors constellation resp 
authentication na resp 
na max 
addition gracefully degrading consensus algorithm achieves fast learning despite failure acceptors authentication total number acceptors na 
achieves fast learning despite failure acceptors authentication na greater min 
note scope theorem consensus algorithms inherently satisfy general consensus solvability lower bound na 
help better understand parameters illustrate specific interesting cases focus constellation authentication impact optimal resilience algorithms achieve fast learning 

consider consensus algorithms correct acceptors fail 
extreme fast learning resp 
graceful degradation possible authentication acceptor fails na third total number acceptors fail 
extreme fast learning possible authentication maximum possible number acceptors fail na fifth total number acceptors fail 


consider consensus algorithms correct acceptors fail acceptors malicious 
algorithms example acceptor fails fast learning possible na 
na acceptors graceful degradation possible authentication 
achieve graceful degradation authentication na min acceptors required 


consider consensus algorithms correct acceptors fail possibly safe acceptors malicious algorithms correct failures safe may live malicious failures 
algorithms example acceptor fails fast learning possible na 
time number acceptors allows graceful degradation authentication na greater min 
short theorem expresses general precise way fundamental trade resilience complexity asynchronous byzantine consensus 
sides complexity considered communication complexity called latency depicts number rounds information exchange decision learned authentication complexity considered major overhead factor 
proof overview lower bounds necessary parts theorem consist set lower bounds 
prove bounds indistinguishability arguments simultaneously exploit temporary asynchrony network byzantine failures processes order contradict ability achieve fast learning resp 
graceful degradation 
example show fast learning despite failure acceptors impossible insufficient number acceptors construct favorable runs exactly privileged proposer proposes value learner learns distinct values fast communication rounds 
second exhibit asynchronous runs byzantine failures respectively indistinguishable favorable synchronous runs learns distinct values asynchronous runs 
third asynchrony byzantine failures way asynchronous runs indistinguishable learner distinct helps build eventually synchronous run agreement violated 
assuming processes authentication effect restrict range possible byzantine behavior exploit proof 
proof overview dgv algorithm sufficiency parts theorem shown exhibiting algorithms match corresponding lower bounds 
interestingly algorithms viewed variants generic algorithm call distributed consensus grande dgv 
dgv parameterized underlying constellation considered vs 
algorithm constitutes appealing building block implement robust efficient distributed services internet 
basically dgv allows fast learning favorable runs time gracefully degrades allow fast learning conditions slightly desirable favorable runs 
dgv matches lower bounds stated theorem optimal algorithm terms time complexity resilience runs system synchronous acceptors fail exactly correct proposer proposes value 
favorable runs constitute runs encountered steady state various practical distributed applications 
intuitively privileged proposer commences dgv proposing value 
resp 
favorable run correct learners learn decision value resp 
communication rounds acceptors 
correct learner learn value certain period time proposer px elected 
process tries impose estimate decision value acceptors estimates point execution 
dgv guaranteed decision value learned time proposer successfully impose value time achieve value acceptors accept carefully selected basis acceptors estimates point execution value may learned missed 
certain cases potential disputes value accepted may arise solved detecting existence malicious acceptors cause disputes 
dgv composed parts locking module election module 
short locking module ensures consensus safety election module ensures consensus liveness eventual synchrony assumption 
key element dgv choose function locking module determines value accepted acceptor point execution 
variants dgv obtained mainly slightly changing implementation function 
roadmap section discuss related 
section recall consensus problem define model consider 
section show necessary part consensus theorem establishing proving certain lower bounds constellations followed 
section give algorithms match lower bounds variants generic dgv algorithm 
related recall historical context asynchronous byzantine consensus solvability complexity bounds 
compare dgv algorithm previous byzantine consensus algorithms 
solvability bounds 
byzantine consensus introduced pease shostak lamport synchronous model distributed computation established correct processes necessary sufficient solve problem processes authentication 
bound extended asynchronous case processes authentication 
general framework consider translates na framework general case difficult extend proof show na necessary sufficient condition solve asynchronous byzantine consensus 
synchronous complexity 
shown synchronous byzantine consensus algorithm needs communication rounds reach consensus number failures tolerated 
bound considering case processes simultaneously reach decision 
decision need reached simultaneously early decision possible min rounds needed deciding runs processes faulty 
bounds depict worst case complexity 
asynchronous complexity 
model arbitrarily long asynchronous periods called eventually synchronous model introduced dwork lynch stockmeyer mentioned algorithms model called asynchronous 
clearly worst case lower bound algorithms 
asynchronous algorithms crash failures established rounds needed achieve consensus synchronous runs failures 
best case complexity 
bounds established restricted framework processes play role 
lamport motivated study consensus complexity bounds general framework distinct proposers acceptors learners ability framework better match practical consensus state machine replication protocols 
conjectured fundamental tight bound maximum resilience achieve fast learning asynchronous byzantine consensus 
concurrently lamport proved conjecture non byzantine failures 
theorem generalizes conjecture prove byzantine case 
generalization goes directions 
consider graceful degradation possibility fast learning run fast learning achieved second consider impact authentication 
doing highlight fact lamport conjecture holds fast learning authentication precluded 
systems authentication far expensive rounds communication 
primary importance state precise impact authentication number communication rounds needed achieve consensus 
asynchronous byzantine consensus algorithms 
certain byzantine consensus algorithms synchronous assume subset system synchronous 
asynchronous byzantine consensus algorithm castro liskov :10.1.1.127.6130
algorithm called practical byzantine fault tolerance considered special case na 
fast learning achieved synchronous runs acceptors malicious call favorable runs leader correct 
fast learning possible setting considered 
dgv algorithm enables fast learning leader correct run synchronous acceptors fail favorable runs 
acceptors fail dgv degrades gracefully features complexity fast learning 
modular asynchronous consensus algorithms 
deconstruction paxos algorithm similar decomposition dgv give non byzantine case 
decomposition possible reusable locking module capturing consensus safety properties combined different election algorithms providing consensus liveness vein 
instance election module easily shifted level proposers implemented deterministic scheduler 
comparison techniques ensuring safety incorporated liveness providing part leader change algorithm 
introducing pair additional messages certain non favorable runs dgv way critically degrade performance algorithm runs safety providing part algorithm locking module independent liveness providing part algorithm election module 
practical implementations course consider removing additional messages 
notice lower bounds algorithms consider time complexity synchronous runs privileged proposer correct 
assumptions correctness privileged proposers synchronous runs require rounds achieve 
asynchronous byzantine consensus algorithms fast learning 
asynchronous byzantine consensus algorithms fast learning achieved proposed 
kursawe optimistic byzantine agreement martin alvisi fab paxos fast byzantine paxos oracle protocol friedman raynal lamport algorithm 
kursawe algorithm considers specific case na achieves fast learning acceptor fails 
consider graceful degradation allow fast learning acceptor fails feasible case 
developed concurrently martin alvisi fab paxos algorithm simple elegant considers constellation case assuming optimal number acceptors setting na achieves fast learning despite acceptor failures 
algorithm match lower bound constellation adapt general case constellation 
oracle randomized protocol friedman considers case constellation achieves fast learning na acceptors required lower bound 
lamport algorithm achieves fast learning constellation 
summarize certain algorithms special values special case constellation suggested literature dgv algorithm generic respect delivers optimal performance 
furthermore special case aware solution handles case constellation 
case optimal consensus resilience constellation better constellation particularly interesting 
addition algorithm gracefully degrading algorithms combines fast fast learning 
achieving properties trivial especially handling general values precluding authentication 
preliminaries address consensus problem defined distributed system composed sets processes set proposers pnp set acceptors ana set learners lnl 
problem proposer starts proposal value 
proposers may propose value may propose times 
learners need learn proposal value 
acceptors act witnesses help learners agree 
proposing value proposer communicates acceptors learners learn value receiving appropriate messages acceptors 
precisely run consensus algorithm proposers propose values learners learn values properties hold validity learner learns value proposer proposes agreement learners learn different values termination correct proposer proposes value eventually correct learner learns value 
processes may fail arbitrarily deviating algorithm assigned 
process fails crashing simply execution say crashed deviates statement imprecise presentation simplicity 
fact impossible ensure malicious proposer proposing value pretend proposed different value 
precise definition validity learner learns value run run possibly different proposer proposes distinguish algorithm way different crashing say malicious 
consider consensus algorithms provide safety properties validity agreement despite malicious acceptors 
words safety properties consensus preserved regardless number acceptor crashed long number malicious acceptors hand consensus algorithms required provide liveness termination total number acceptor failures case validity agreement preserved runs acceptors fail 
termination guaranteed number actual acceptor failures number learners fail crashing 
assume learners malicious 
pair processes connected bi directional channel may duplicate delay lose messages may deliver order 
channels alter messages 
assume message sent unique sender field supposed contain unique identifier sending process 
assume computationally bounded adversary standard cryptographic techniques design byzantine consensus algorithms :10.1.1.127.6130
consider public key cryptography pkc message authentication codes message digests denotes digest message denotes accompanied digitally signed process pkc usually considered pretty expensive :10.1.1.51.6690
consequence pointed distinguish case processes pkc say authentication case processes authentication fast fast learning achieved 
circumvent impossibility fault tolerant consensus asynchronous system eventual synchrony assumptions run bound time gst global stabilization time message sent correct process correct process time gst received time processes need know values gst assume upper bound auth local computation time required authentication 
assume local computations require negligible time 
assume process starts consensus estimate auth bounds message transmission delay local computations 
say run consensus algorithm synchronous correct processes estimates auth say auth respectively auth auth gst 
roughly speaking synchronous run correct process times waiting messages correct process 
lower bounds precisely state lower bounds underlying theorem assume full information protocols round round eventually synchronous model 
round processes send messages processes receive messages round update states move round properties hold 
denote alive set processes complete round round round message sent correct process alive correct process alive delivered round synchronous run simply run 
lower bounds assume proposers learners 
prove lower bounds constellation 
recall system constellation single privileged proposer acceptor constellation privileged proposer regardless acceptors constellation 
consider constellation single privileged proposer acceptor 
constellation consider case single privileged proposer acceptor constellation 
proposition 
algorithm achieves fast learning despite failure acceptors priv pl pl na 
details proposition 
states algorithm exactly proposer pl holds favorable run pl proposes pl correct correct learner learns value proposed pl round 
pl acceptor na 
proof 
suppose contradiction na 
divide set acceptors sets sets size third set size sets size respectively 
loss generality assume set consists process 
set process simply modify runs processes inside set receive set messages fail fail time way proof holds bounds 
assume learners proposers privileged proposer pl proposer px 
suppose pl correct proposes value round 
proposal value learned round possible communication pattern remember proposing value proposer communicate acceptors learners learn message receiving appropriate messages acceptors round proposer pl sends messages acceptors round acceptor forwards message received round process 
learners receiving sufficient number messages acceptors learn value 
consider cases pl proposes round sufficient prove lower bound 
authenticated messages sent pl round pl correct proposes respectively 
say acceptor ai plays resp 
acceptor learner qj round run qj distinguish round run run ai received resp 
pl round ai correct 
important note due cryptographic assumptions ai play ai received resp 
pl 
pl faulty pl may send ai pl proposed ai may play 
favorable partial run prefix favorable run 
assumption run pl proposes correct learners learn proposal value pl round 
consider favorable partial runs message patterns rounds runs illustrated 
processes correct 
proposer pl proposes round crashes sending message round learner receives round messages acceptors 
assumption learns round crashes sending message round 
pl pl propose pl run run run learn propose px propose pl pl propose px learn run run byzantine fault delayed message process crash learning value sender plays sender plays legend learn propose px fig 

illustration proof lower bound fast learning constellation case single privileged proposer acceptor learn processes correct 
proposer pl proposes round crashes sending message round learner receives round messages acceptors 
assumption learns round crashes sending message round 
construct runs favorable 
processes correct proposer pl malicious acceptor crashes sending message round crashes sending message round 
round proposer pl sends acceptors rest acceptors 
acceptor crashes process receives round message crashes process receives round message 
round acceptors play processes play processes 
round correct proposer px proposes 
correct proposer proposes eventually correct learner learns value say round processes correct proposer pl acceptor malicious learner crashes sending message round 
round proposer pl sends acceptor rest acceptors 
round higher rounds acceptor plays processes acceptors play processes 
malicious acceptor plays learner plays processes 
received 
learner receives round message acceptors 
clearly round distinguish receives set messages acceptors round runs learns 
learner crashes sending message round 
round correct proposer px proposes 
round non crashed processes correct malicious processes receive messages non crashed processes distinct messages sent lost round 
round correct process distinct distinguish non crashed acceptor different plays identical values runs learner learns round non crashed processes receive messages non crashed processes including rounds higher processes correct proposer pl acceptor malicious learner crashes sending message round 
round proposer pl sends acceptor rest acceptors 
round higher rounds acceptor plays processes acceptors play processes 
malicious acceptor plays learner plays processes 
received 
learner receives round message acceptors 
clearly round distinguish receives set messages acceptors round runs learns 
learner crashes sending message round 
round correct proposer px proposes 
round non crashed processes receive messages non crashed processes distinct messages sent lost round 
round correct process distinct distinguish non crashed acceptor different plays identical values runs learner learns round non crashed processes receive messages non crashed processes including rounds higher clearly violates consensus agreement decides runs decides 
runs acceptors faulty contradiction requirement violate validity agreement processes faulty 
remarks 
round proposal px required ensure decides 
px propose possible proposal run malicious proposer pl termination property require learner decide 
secondly ease presentation state proof pl sends messages round 
fact pl may sends single message recover 
pl malicious collude achieve 
similar argument holds messages pl round 
sketch proof bound case constellation privileged proposers 
proof similar proof contains subtle differences point sketch 
refer proof proof 
proposition 
algorithm achieves fast learning despite failure acceptors priv 
na 
details proposition 
states algorithm proposers pv pw holds favorable run exactly correct proposer pv pw proposes correct learner learns value round 
na 
proof sketch 
split proof cases proposers pv pw acceptor pv pw acceptors 
consider case 
loss generality assume pv acceptor 
proof proposition 
trivially obtained proof 
having proposer pv playing role proposer pl proposer pw propose runs 
consider case 
distinguish exhaustive subcases respect values parameters 
consider case 
modify proof 
follows 
run proof modified get new runs message patterns rounds runs illustrated 
get run ri ri round remove propose proposer pl add propose pv propose pw define message sent pv proposing message sent pw proposing 
runs sets contain acceptors 
addition proposing pv resp 
pw acts way acceptors belong set resp 

round ri acceptor receives receives ri similarly 
receives messages pv pw round 
acceptors play receiving play receiving pv pw pv pw propose pv pw run run run learn learn pv pw pv pw propose run run byzantine fault delayed message process crash learning value sender plays sender plays legend fig 

illustration proof lower bound fast learning constellation case privileged proposers acceptors learn learn recall assume processes correct proof 
addition assume remaining round messages sent pv pw delivered round delivered round similarly runs 
influence correctness proof 
rest proof remains proof 
consider subcase 
case proof derived proof 
similar fashion case sets contain acceptors addition proposing pv resp 
pw acts way acceptors belong set resp 

case particularly interesting case bound strictly consensus solvability bound prove rest part theorem 
establishes bound number acceptors required gracefully degrading algorithms achieve fast learning authentication constellation proof migrated constellation similar way proof derived proof 
refer proof proof 
clearly gracefully degrading algorithm achieves fast learning authentication restricted authentication pattern 
messages sent privileged proposer acceptors round messages sent acceptors learners round may may authenticated allow authentication achieve fast learning 
messages exchanged acceptors round messages sent acceptors learners round authenticated 
proof indistinguishability arguments exploit fact malicious process claim received different value correct process correct process sent 
possible assume messages fast fast learning authenticated 
addition exploit asynchrony network fact malicious processes cooperate 
proposition 
gracefully degrading algorithm satisfies restricted authentication pattern priv pl pl na min 
details proposition 
states algorithm exactly proposer pl holds favorable run pl proposes pl correct correct learner learns value proposed pl round 
pl acceptor satisfies restricted authentication pattern favorable run pl proposes pl correct correct learner learns value proposed pl round na min 
proof 
consider case suppose contradiction na divide set acceptors sets mq sets size third set size sets size loss generality assume sets consists process 
set process just modify runs processes slightly simplify proof proposer px may removed 
recall proposal correct proposer px introduced ensure eventually learns value 
pv pw correct propose value proposal px required learn value 
inside set receive set messages fail fail time way 
proof holds 
assume learners proposers potentially malicious privileged proposer pl proposer px 
consider cases pl proposes sufficient prove lower bound 
authenticated messages sent pl round pl correct proposes respectively 
say acceptor ai plays resp 
process aj round run aj distinguish round run run ai received resp 
pl round ai correct 
furthermore say acceptor ai plays tuple mq process aj round run aj distinguish round run run ai received value mq mq round ai correct 
ai receives value xj xj means xj played xj ai round ai received message round 
correct acceptor ai receive message xj round ai plays place xj round 
favorable partial run prefix favorable run 
similarly favorable partial run prefix favorable run 
assumption favorable run correct privileged proposer pl proposes correct learners learn proposal value pl round 
furthermore favorable run correct privileged proposer pl proposes correct learners learn proposal value pl round 
keeping mind satisfies restricted authentication pattern consider runs favorable partial run favorable partial run 
patterns messages exchanged initial rounds runs depicted 
processes correct 
proposer pl proposes round crashes sending message round learner receives round messages acceptors 
assumption learns round crashes sending message round 
processes correct 
proposer pl proposes round crashes sending message round learner receives round messages acceptors 
assumption learns round crashes sending message round 
construct non favorable runs 
processes correct proposer pl malicious acceptor crashes sending round message crashes sending message round 
round proposer sends acceptors mq 
round messages sent mq messages sent lost possible crashes 
messages round delivered round message sent delivered round 
note round plays plays mq plays plays plays 
note round distinguish round send messages round run including send pl mq pl mq pl mq run propose px run propose px learn pl mq pl mq learn round plays round plays run run propose px run learn byzantine fault delayed message process crash learning value sender plays sender plays legend fig 

illustration proof lower bound gracefully degrading algorithms authentication achieve fast learning authentication gracefully degrade achieve fast learning constellation learn 
learner crashes process receive round message 
round correct proposer px proposes 
correct proposer proposes eventually correct learner learns value say round processes correct proposer pl acceptors mq malicious learner crashes sending message round 
round proposer pl sends acceptor mq 
messages round delivered 
round round non crashed processes receive messages non crashed processes distinct 
round message delivered delivery messages sent round delayed round 
furthermore round malicious acceptors mq play received round messages possible messages exchanged acceptors round authenticated processes play algorithm point 
learner receiving round messages learns distinguish receives set messages acceptors round runs 
learner crashes sending message round 
round correct proposer px proposes 
round non crashed processes receive messages non crashed processes distinct messages sent round delayed round 
round correct process distinguish acceptor different plays identical values runs 
learner learns round correct processes receive messages correct processes including rounds higher processes correct proposer pl acceptors mq malicious learner crashes sending message round 
round proposer pl sends acceptor correct acceptors mq 
round acceptor plays processes acceptors play processes 
malicious acceptors mq play learner play processes 
round messages delivered 
furthermore round plays mq plays algorithm 
learner receives round message acceptors 
clearly round distinguish receives set messages acceptors round runs learns 
learner crashes sending message round 
round correct proposer px proposes 
round round non crashed processes receive messages non crashed processes distinct messages sent round delayed round 
round correct process distinguish acceptor different plays identical values runs learner learns round non crashed processes receive messages non crashed processes including rounds higher absence authentication exploited point proof allowed play round falsely claims received correct acceptor round 
messages exchanged acceptors authenticated round possible 
clearly violates agreement decides runs decides 
runs acceptors malicious contradiction requirement violate validity agreement acceptors malicious 
case divide set acceptors time sets size size prove lower bound case similar runs case acceptor plays role acceptor role acceptor mq exist 
prove part theorem constellation 
constellation sketch proof lower bound number acceptors required fast learning authentication constellation 
refer proof proof 
proposition 
algorithm achieves fast learning despite failure acceptors priv pl na 
details proposition 
states algorithm exactly proposer pl holds favorable run pl proposes pl correct correct learner learns value proposed pl round 
pl acceptor na 
proof sketch 
proof simple modification proof 
try directly apply proof pl acceptor run acceptors faulty run acceptors crash faulty acceptor malicious 
property agreement need hold termination need hold 
consequently show desired contradiction 
modify proof acceptors acceptors 
suppose contradiction na 
divide set acceptors distinct pl sets sets size third set size sets size respectively 
runs pl acts proposer acceptor sending messages learner acceptors round 
run round pl receives message processes higher rounds plays value processes 
continue proof obtain contradiction 
diagrams depicting runs 
notice size runs run acceptors faulty run acceptors faulty pl additional faulty acceptor 
prove bound possibility fast learning constellation restriction authentication fast learning 
refer proof proof 
proposition 
algorithm achieves fast learning despite failure acceptors authentication priv pl na pl pl propose pl run run run learn propose px propose pl pl propose px learn run run byzantine fault delayed message process crash learning value sender plays sender plays legend learn propose px learn fig 

illustration proof lower bound possibility fast learning constellation details proposition 
states algorithm exactly proposer pl holds favorable run pl proposes pl correct correct learner learns value proposed pl round authentication 
pl acceptor na proof 
suppose contradiction na 
divide set acceptors distinct pl sets set size second set size sets size say acceptor ai plays run process different ai distinguish run run ai receive message round 
construct partial runs derive contradiction 
runs depicted give short descriptions 
runs favorable partial runs correct proposer pl proposes respectively receives messages acceptors round 
property follows learns respectively round 
subsequently crashes sending message round 
run process pl correct 
malicious proposer pl sends send messages 
pl crash sending message round 
note acceptors crash 
round plays plays plays 
proposer px proposes round 
termination property follows learner decides value say round process correct 
proposer pl proposes sends acceptors message lost 
round onwards pl play processes plays processes malicious acceptor plays processes 
round distinguish learns crashes sending message round 
proposer px proposes round 
round round messages send pl lost 
round learner distinguish learns run similar pl proposes malicious plays plays processes 
learner distinguish learns crashes 
round distinguish decides clearly violates consensus agreement decides runs decides 
runs acceptors faulty contradiction requirement violate validity agreement processes faulty 
easy see runs proof constructed authentication communication round fast learning play play receiving message correct proposer pl similarly 
circumvent problem presence authentication need assume pl malicious maintain upper bound number malicious acceptors pl pl propose pl run run learn propose px run propose pl pl propose px learn run run legend byzantine fault delayed message process crash learning value sender plays sender plays sender plays learn propose px fig 

illustration proof lower bound possibility fast learning authentication constellation learn contains acceptors 
gives lower bound na 
bound strictly weaker bound na shown proof 
show modify proof prove rest part theorem prove bound number acceptors required gracefully degrading algorithms achieve fast learning authentication addition achieving fast learning authentication constellation 
refer proof proof 
proposition 
gracefully degrading algorithm satisfies restricted authentication pattern priv pl na min 
details proposition 
states algorithm exactly proposer pl holds favorable run pl proposes pl correct correct learner learns value proposed pl round 
pl acceptor satisfies restricted authentication pattern favorable run pl proposes pl correct correct learner learns value proposed pl round na min 
proof sketch 
basically proof relies proof show reused constellation similar way reused proof proof 
runs similar runs proof change size acceptors sets 
distinguish cases case case 
case adapt proof way size set size set mq 
additional proposer acceptor plays roles privileged proposer pl acceptor belongs set proof 
case divide set acceptors time sets size size size 
prove lower bound case similar runs proof acceptor plays role acceptor role acceptor mq exist 
addition case additional proposer acceptor plays roles privileged proposer pl acceptor belongs set proof 
dgv algorithm prove sufficiency part theorem describe algorithms match lower bounds 
algorithms variants byzantine consensus algorithm call dgv algorithm 
detail variant algorithm denoted matches lower bounds part theorem constellation case single privileged proposer call section constellation 
fact variant consider matches interesting case constellation proposers acceptors authentication fast learning 
show proposition alg 
consensus algorithm achieves fast learning despite failure acceptors authentication case priv pl pl case constellation na 
matches bound established proposition section 
addition gracefully degrading algorithm achieves fast learning authentication na min 
achieves fast learning authentication na min 
matches bound established proposition section 
furthermore matches lower bounds theorem special case proposers acceptors 
words achieves fast learning despite failure acceptors authentication case priv pl na max 
matches bound established combining propositions section 
addition case gracefully degrades achieves fast learning authentication na min 
achieves fast learning authentication na min 
matches bound established proposition section 
special case constellation proposers acceptors particular practical interest state machine replication uses multiple consensus instances 
basically single consensus instance privileged proposer pl roughly speaking pl example fails correct proposer px elected leader time run synchronous time px completes instance time privileged proposer subsequent consensus instances despite fact original privileged proposer pl failed 
section interestingly simplify obtain lower bound matching algorithms general case constellation covers cases proposer acceptor 
particular assumes na max acceptors resp 
na max constellation resp 

adaptively uses authentication graceful degradation necessary case na min resp 
na min constellation resp 
provides graceful degradation authentication 
discuss difficult modify obtain algorithm achieves proposition alg 
consensus algorithm achieves fast learning despite failure acceptors authentication case priv case constellation na matches bound established proposition section 
addition gracefully degrading algorithm achieves fast learning authentication na min achieves fast learning authentication na min 
basically matches lower bounds theorem case constellation privileged proposer call constellation section 
note jointly match lower bounds constellation general 
prove proposition alg show proposition alg derived proving correctness section 
section describe dgv variants match lower bounds part theorem constellation general highlight dgv efficiently adapted special case overview dgv composed parts locking module election module 
short locking module ensures consensus safety election module ensures consensus liveness eventual synchrony assumption 
key element dgv choose function locking module determines value accepted acceptor point time 
locking election modules section figures respectively 
algorithm proceeds sequence views fig 

view time frame pre determined proposer leader 
leader proposer messages considered acceptors view 
dgv rotating coordinator paradigm leader view number pk mod np 
algorithm starts initial view iew constant known processes iew 
privileged proposer pinit init leader iew 
view leader executes locking module dgv consists phases read write phase 
basically read phase sure value learned learner previous view proposed new view 
determined key part read phase choose function 
algorithm starts iew pinit proposes iew pinit skips read phase executes write phase 
write phase leader tries impose learners estimate decision value intermediation acceptors 
basically write phase allows fast learning favorable runs time provides graceful degradation allow fast learning favorable runs 
words correct privileged proposer pinit proposes algorithm achieves fast resp 
fast learning favorable resp 
favorable run 
privileged proposer proposition alg difficult obtain variant dgv allow privileged proposer px achieve fast resp 
fast learning provided px proposer proposes value favorable resp 
favorable run 
done setting iew allowing acceptors accept value privileged proposer px iew 
view leader suspected making progress changed basis timeouts election module algorithm 
soon acceptors initialize algorithm start timer permanently stopped soon hear correct learner learned value 
expiration timer acceptor suspects leader 
na correct acceptors suspect current leader leader eventually changed 
set na acceptors non malicious majority set set size na run contains majority non malicious acceptors describe write phase locking module 
prove statement section lemma 
leader proposers acceptors learners pre prepare prepare commit view change new view na prepare messages received learn value na commit messages received learn value write rit phase phase read phase lazy proof obtaining election lpo election sign req sign ack new view ack write phase locking module prepare messages exchanged acceptors signed na min configuration na min configuration lpo optional prepare messages signed na view view fig 

communication pattern structure dgv communication round leader sends pre prepare message acceptors including proposal value view number ritep roof set authenticated messages certifies proposal value come back generation set section 
time assume acceptors check validity ritep roof 
iew ritep roof nil 
acceptor ai view reception pre prepare message leader valid ritep roof adds pre prepare message set kai simplicity say ai pre prepares kai 
acceptors pre prepare value particular view 
acceptors second communication round echoing pre prepare message learners prepare message value view number 
riteproof set echoed 
furthermore acceptors send prepare message acceptors 
na min case constellation na min case constellation prepare messages exchanged acceptors authenticated 
reception na prepare messages different acceptors value view number learner learns reception na prepare messages different acceptors value view number furthermore match value view number kai current view acceptor acceptor ai adds prepare messages set pai simplicity say ai prepares pai say ai accepts mean ai pre prepares prepares 
ai sends commit message third communication round containing learners 
reception na commit messages view number different acceptors learner learns learned value 
changing leader initialization acceptors trigger timer imeout initially equal value imeout conveniently chosen respect estimates auth 
imeout expires acceptor suspects current leader 
sufficient number acceptors suspect current leader leader changed 
basically leader view changed faulty run synchronous 
done election module dgv 
acceptor suspects leader sends signed view change message leader view doubles imeout triggers 
new leader elected expiration imeout acceptors send signed view change messages leader 
proposer pj receives na view change messages different acceptors valid signatures view number mod np pj leader say pj elected 
leader uses set received signed view change messages view proof iewp proof legitimate leader view new leader sends acceptors new view message containing view number view proof 
reception valid new view message higher view acceptor updates view number view proof updates value timeouts line fig 

values imeout chosen way acceptors trigger timeout value sending view change message particular view number 
imeout stopped acceptor receives confirmation learner learned value 
learner learns value sends periodically signed decision message contains value acceptors learners presentation simplicity authenticated decision messages learners enable acceptors halt locking election modules 
authentication avoided case variation consistent broadcast show appendix 
acceptor receives decision message learner stops permanently imeout halts locking election modules 
learners learn value time start periodically query acceptors decision message decision pull message 
reception query acceptor received signed decision message learner forwards decision message learners 
reception correctly signed decision message contains value learner learns learn value 
note learner learn value basis decision message correctly signed learner learners assumed malicious 
read phase choose function elected new leader view pw sends new iew iewp message acceptors iewp proof authenticated messages pw legitimate elected leader reception new view message view sent pw acceptor ai wai replies pw signed new view nack message includes valid proof iewp fact wai iewp view proof ai received leader wai 
ai updates view number wai view proof iewp iewp 
na prepare messages write phase authenticated ai replies signed new view ack message containing sets kai pai na authentication write phase ai sends sign req vai wai message set acceptors ai received rep vai wai messages set pai na acceptors keep track prepare messages sent 
reception sign req message acceptors respond signed sign ack message contains signed prepare message corresponding request sign req sent prepare message 
liveness guaranteed acceptors fail case non malicious acceptor ai guaranteed obtain na sign ack messages 
acceptor ai includes na received signed sign ack messages new view ack message sends leader new view 
pair vai wai reported pai new view ack message sent ai considered valid leader new view accompanied matching valid set na signed sign ack messages 
technique generalization known lazy proof obtaining lpo technique 
reception na valid new view ack messages valid new view nack message leader updates view number aborts current proposal 
leader receive new view nack message adds na received new view ack messages set ritep roof 
define candidate values ritep roof way definition candidate values 
say value candidate candidate value set ritep roof cardinalities respectively candidate na different kai sets new view ack messages ritep roof contain value kai 
candidate na different valid pai sets new view ack messages ritep roof contain value associated view number pai 
new leader pw chooses value going propose acceptors choose function give 
function choose input parameters initial proposal value pw riteproof set na valid new view ack messages view main idea choose value resp 
learned learner previous view resp 
reception na resp 
na rep resp 
commit messages resp 
certainly candidate resp 
candidate value riteproof view subsequent view 
true na resp 
na acceptors sent prepare resp 
commit message learners na resp 
na non malicious acceptors new view ack messages part riteproof 
may happen multiple candidate values riteproof 
say candidate value associated view number view view st highest view number associated kai sets new view ack messages belong riteproof 
addition say candidate value associated view number view na valid pai sets new view ack messages belong riteproof pai view 
candidate value riteproof happens candidate value highest associated view number selected 
multiple candidate values associated highest view number choose finely tuned return value learned previous view candidate value 
details obtained refer reader correctness proof dgv variant section 
case value learned learner previous view choose return value different ensure agreement 
informally dispute candidate values say view number value associated set kai pa 
note value associated multiple view numbers vice versa 
choose ritep roof returns view view view nil flag true sort candidate values associated view highest view single candidate value associated view elseif value flag false abort endif single candidate value elseif candidate values order sets contain respectively descending view numbers view view view numbers st highest view number associated respectively 
view view elseif view view view view new view ack sent leader view view view riteproof abort elseif na elseif na endif endif endif endif nil view st highest view number associated sets endif view view return view elseif view view return view view view prepare messages authenticated return view elseif view view prepare messages authenticated system constellation flag false abort system constellation case proposers acceptors new view ack sent leader view view view riteproof abort case na na return view na na return view na na flag false abort endif endif endif endif return fig 

choose function associated view number candidate values learned previous view leader malicious case proposer acceptor riteproof contains malicious acceptors 
case riteproof contains message leader choose aborts 
case exploit fact malicious acceptor leader view riteproof adapt calculations respect candidate value learned cardinality na riteproof see lines fig 

case malicious acceptor necessarily leader disputed view choose aborts 
choose riteproof aborts lines fig 
sure riteproof contains malicious acceptor 
new leader wait additional new view ack message na st invokes choose possible valid riteproof subset received new view ack messages size na choose aborts subset new leader waits new view ack message 
termination guaranteed presence na correct acceptors choose aborts riteproof consists new view ack messages sent correct acceptors 
finding riteproof choose returns value new leader sends pre prepare message acceptors way leader iew time ritep roof nil 
acceptor checks riteproof mentioned section choose function accepts pre prepare message proposed value extracted ritep roof 
write phase continues described section 
dgv distinguish main parts dgv algorithm 
locking part algorithm described consists read write phase 
part algorithm captures safety properties algorithm validity agreement 
phases locking part explained section 
note lines locking module fig 
write phase acceptors learners wait na na prepare commit messages respectively prepare messages exchanged acceptors write phase authenticated line fig 

set na acceptors non malicious majority set set size na run contains majority acceptors optimization dgv possible described case fast learning synchronous run privileged proposer correct despite failure na na acceptors 
second part algorithm election module described 
election module assumption eventually synchronous system provides liveness 
part algorithm elects new leaders basis timeouts 
give simple wrap algorithm 
entering view proposer pj leader done election module algorithm pj executes locking module algorithm 
assume privileged proposer proposes due external event 
achieve fast learning privileged proposer propose algorithm 
proposer pj propose iewp nil read phase send acceptors new iew iewp wait reception valid signed new iew ack ka pa iewp wa messages ka view pa view set na received new iew ack messages received valid new iew nack message highest valid wa ritep roof iewp iewp corresponding view return choose ritep roof endif write phase send acceptors re rep acceptor aj read phase reception new iew iewp pi wa iewp matches wa iewp iewp nil min na constellation min na constellation lpo send sign req pa pa acceptors rep message pa reception na signed sign ack messages correspond sent sign req set received signed sign ack messages endif send signed new iew ack ka pa nil nil pi send signed new iew nack nil nil nil wa pi reception sign req ai lpo rep sent send sign ack rep ai endif write phase reception re rep fresh pi valid ritep wa mod np re rep received st time wa iew matches choose ritep roof ka received re rep message ka rep send learners na min constellation na min constellation send acceptors reception na signed rep matching ka wa pa set received rep messages pa send learners commit learner lj reception na rep na commit lj learned value learn endif fig 

pseudocode dgv locking module learner lj learning value periodically send signed decision acceptors learners reception valid signed decision lj learned value learn endif value learned wait preset time send decision ull acceptors acceptor aj initialization imeout imeout trigger imeout expiration imeout imeout imeout mod np send iew change trigger imeout reception valid new iew iewp wa imeout imeout reception valid decision learner imeout reception decision ull learner lj received valid signed decision forward decision lj endif proposer pj reception na signed iew change mod np wp iewp received signed iew change wp send proposers signed new iew wp iewp reception valid signed new iew iewp wp wp iewp iewp fig 

pseudocode dgv election module process rj wp iew initialization iewp rj nil wp mod np wp iew propose wp iewp propose invoked due external event fig 

pseudocode dgv wrap algorithm dgv correctness section prove correctness dgv variation described section prove proposition alg 
give definitions 
definition value learned view 
say value learned learned view learner eventually learns value receiving respectively learned rep messages na different acceptors 
learned commit messages na different acceptors 
definition pre prepares 
say acceptor ai pre prepares value view eventually adds re rep message kai set eventually line fig 

kai definition prepares 
say acceptor ai prepares value view eventually adds na different signed rep messages pai set eventually pai line fig 

definition accepts 
say acceptor ai accepts value view pre prepares prepares view trivial see learner learns value learned learned view 
note non malicious acceptor ai prepared value view follows ai pre prepared value view proceed correctness proof proving simple crucial lemmas 
lemma 
na na 
proof 
algorithm assumes na general bound solvability consensus 
na na na 
na na 
hand na na na na 
na na conclude na na 
lemma 
sets containing na acceptors intersect non malicious acceptor 
set na acceptors set na acceptors intersect non malicious acceptor 
sets containing na acceptors intersect non malicious acceptor 
set na different acceptors set na acceptors intersect non malicious acceptor 
set na different acceptors set na different acceptors intersect na non malicious acceptors 
set na acceptors non malicious majority 
set na acceptors contains acceptors 
proof 

inequality na na obvious intersect acceptors 
acceptors malicious conclude intersect non malicious acceptor 

follow directly lemma part lemma 

na na applying part lemma conclude intersect non malicious acceptor 

sets intersect na na na na acceptors malicious 
intersect na non malicious acceptors 

straightforward part lemma 

constellation na na 
constellation na na 
lemma 
values learned view proof 
suppose def 
set na acceptors sent rep messages set na acceptors sent rep messages 
sets intersect na acceptors na non malicious na na 
exists non malicious acceptor sent different prepare messages view contradiction 
lemma 
learned view set na acceptors sent rep message proof 
suppose def 
set acceptors sent rep messages view set na acceptors sent rep sets intersect non malicious acceptor ai lemma conclude ai sent different prepare messages view contradiction 
lemma 
learned view learned view proof 
lemma simple corollary lemma 
lemma 
values learned view proof 
suppose def 
set na acceptors sent commit messages set na acceptors sent commit messages 
sets intersect non malicious acceptor ai lemma conclude ai sent different commit messages view number contradiction 
lemma 
different values learned view 
proof 
follows directly lemmas 
lemma 
choose ritep roof view returns candidate value riteproof non malicious acceptor ai pre prepared value view higher equal proof 
assume choose riteproof view returns candidate value riteproof 
definition follows set na acceptors reported valid 
set valid prepare messages exchanged acceptors signed prepare messages signed accompanied lazy proof na signed sign ack messages na prepare messages signed na 
prove exhaustive cases set na acceptors sent rep messages 
case sets reported acceptors set contain signed prepare messages na acceptors 
applying lemma lemma conclude set contains non malicious acceptor ai pre prepared view case set basically accompanied na signatures 
na na conclude signatures comes non malicious acceptor ai pre prepared view case cardinality set na sets reported non malicious acceptor ai pre prepared view assume candidate value riteproof 
implies definition exists set na acceptors reported pre prepared set acceptors pre prepared view higher equal note lemma implies set contains acceptors 
malicious acceptors conclude set contains non malicious acceptor pre prepared value view higher equal lemma 
validity learner learns value proposer proposed proof 
learner learns pre prepared na acceptors prepared na acceptors view non malicious acceptor accepted prove statement induction view numbers non malicious acceptor accepts proposer proposed base step prove non malicious acceptor accepted proposer proposed non malicious acceptors accept values proposed pinit conclude proposed proposer 
highlight impossible ensure malicious proposer pinit proposing value pretend proposed different value 
precise definition validity learner learns value run run possibly different proposer proposes distinguish proof corresponds validity definition follows footsteps proof 
inductive hypothesis ih view non malicious acceptor accepted proposer proposed inductive step prove statement true view view acceptor accept values returned choose riteproof riteproof valid 
choose riteproof returns candidate value lemma non malicious acceptor accepted view ih proposed proposer 
choose riteproof returns line initial proposal value leader conclude base step proposed proposer 
lemma 
sending new view ack message view non malicious acceptor accept value view number proof 
difficult see lemma holds non malicious acceptor aj accept value view number aj view lower equal aj replied new view ack message view view aj accept lemma 
lowest view number value learned acceptor ai pre prepares value view higher proof 
prove lemma induction view numbers 
base step prove non malicious acceptor ai pre prepare value different view 
non malicious acceptor ai pre prepares value choose function valid ritep roof view returns sufficient prove valid riteproof choose returns assume loss generality learned learner view def 
set na acceptors pre prepared valid ritep roof view consists new view ack messages set na acceptors subset set cardinality sz na contains non malicious acceptors lemma 
lemma acceptor ai pre prepared replying new view ack message leader view 
acceptor pre prepared value mean higher view replying new view ack impossible 
ai kai ritep roof 
sz na candidate value riteproof view st highest view number exists follows lemma equal note case size equals na learned view acceptor aj acceptors new view ack messages ritep roof non malicious aj pre prepared aj replied new view ack view aj replied new view message view 
candidate value ritep roof line fig 
view line fig 

candidate value st view number view chosen lines fig 
view line fig 

impossible view valid riteproof view line fig 
consider case view case difficult see leader view faulty 
set na acceptors lemma accepted view set acceptors accepted view implies non malicious acceptors accepted different values leader view malicious 
choose function case view occurs valid riteproof contain new view ack message leader view line fig 

case possible constellation 
case size set sz na sure new view ack message malicious acceptor leader view included ritep roof 
non intersecting subsets size na set size na na na na contradict assumptions number acceptors line fig 

candidate value value associated view number view choose returns lines fig 

possible view discuss case view exhaustive possibilities prepare messages exchanged acceptors authenticated prepare messages exchanged acceptors authenticated cardinality candidate value prepare messages exchanged acceptors authenticated case digital signatures sets contain certify na different acceptors sent rep message 
due lemma contradiction 
case existence sets contain including sent non malicious acceptor certifies na different acceptors sent rep message 
similarly case reach contradiction 
consider case 
constellation riteproof valid line fig 

consider constellation 
case sets accompanied lazy proofs valid pai set certified na signatures including signature acceptor 
words distinct non malicious acceptors accepted different values leader view malicious 
choose function case occurs valid riteproof contain new view ack message leader view lines fig 

case size set sz na sure new view ack message malicious acceptor leader view included ritep roof 
exhaustive subcases na na case choose returns line fig 

case riteproof valid line fig 

case messages riteproof malicious acceptors message malicious leader view riteproof non malicious acceptor ai sent pai contains similarly case conclude due lemma contradiction 
inductive hypothesis ih assume non malicious acceptor ai pre prepare value different view prove non malicious acceptor ai pre prepare value different view 
inductive step sufficient prove choose function valid riteproof view returns lemma set size na contains non malicious acceptors acceptor pre prepared new view ack message part ritep roof view 
fact set contains non malicious acceptors applying ih yields ai wi kai wi ritep roof 
candidate value st highest view number associated wv choose view return value associated view number sets valid ritep roof view contain values associated view numbers line fig 

choose return 
ih value pre prepared non malicious acceptor view lemma order choose return non malicious acceptor pre prepared consider case wv difficult see results choose returning 
candidate value conclude exists non malicious acceptor aj accepted view higher equal st highest view number associated 
ih know view higher conclude aj accepted view know acceptor set accepted contains non malicious acceptors conclude leader view malicious 
case modified choose function valid riteproof contain new view ack message leader view lines fig 

case size set sz na sure new view ack message malicious process leader view outside ritep roof 
non intersecting subsets size na set na acceptors line fig 

assume candidate value associated view number reasoning base step repeated completeness 
exhaustive possibilities prepare messages exchanged acceptors authenticated prepare messages exchanged acceptors authenticated cardinality candidate value prepare messages exchanged acceptors authenticated case digital signatures sets contain certify na different acceptors sent rep message 
due lemma contradiction 
case existence sets contain including sent non malicious acceptor certifies na different acceptors sent rep message 
similarly case reach contradiction 
consider case 
constellation riteproof valid line fig 

consider constellation 
case sets accompanied lazy proofs valid pai set certified na signatures including signature acceptor 
words distinct non malicious acceptors accepted different values leader view malicious 
choose function case occurs valid riteproof contain new view ack message leader view lines fig 

case size set sz na sure new view ack message malicious acceptor leader view included ritep roof 
exhaustive subcases na na case choose returns line fig 

case riteproof valid line fig 

case messages riteproof malicious acceptors message malicious leader view riteproof non malicious acceptor ai sent pai contains similarly case conclude due lemma contradiction 
lemma 
lowest view number value learned acceptor ai pre prepares value view higher proof 
prove lemma induction view numbers 
base step prove non malicious acceptor ai pre prepare value different view 
non malicious acceptor ai pre prepares value choose function valid ritep roof view returns sufficient prove valid riteproof choose returns assume loss generality learned learner view def 
set na acceptors pre prepared valid ritep roof view consists new view ack messages set na acceptors non empty subset set lemma contains non malicious acceptors cardinality sz na lemma acceptor ai pre prepared prepared replying message new view ack leader view 
ai pai ritep roof candidate value 
valid riteproof candidate values view number line fig 

highest view number appear ritep roof follows view line 
similarly candidate value st highest associated view number valid riteproof view 
candidate value selected lines associated view number view line fig 

value view view prepare messages exchanged acceptors authenticated choose returns lines fig 

consider possible case left case prepare messages exchanged acceptors authenticated view sz system constellation riteproof valid 
consider constellation 
case sets accompanied lazy proofs valid pai set certified na signatures including signature non malicious acceptor 
furthermore candidate value associated view number view lemma acceptors non malicious accepted words distinct non malicious acceptors accepted different values leader view malicious 
choose function case occurs valid riteproof contain new view ack message leader view line fig 

case size set sz na sure new view ack message malicious acceptor leader view included ritep roof 
lines difficult see case choose returns line riteproof valid line 
inductive hypothesis ih assume non malicious acceptor ai pre prepares value different view prove non malicious acceptor ai pre prepare value different view 
inductive step sufficient prove valid riteproof view witnesses base step argue set containing sz na non malicious acceptors pre prepared prepared new view ack message part ritep roof view 
sets valid ritep roof view contain values associated view numbers line fig 

assume choose riteproof returns 
ih value pre prepared non malicious acceptor view lemma order choose ritep roof return non malicious acceptor pre prepared view higher equal hand possible presence messages sent acceptors set riteproof guarantees candidate value associated view number higher equal choose ritep roof return value associated view number similar reasoning base step conclude candidate values associated view number valid ritep roof candidate value associated view number selected candidate value conclude choose ritep roof returns lemma 
lowest view number value learned non malicious acceptor ai pre prepares value view higher proof 
follows directly lemmas 
lemma 
agreement different values learned 
proof 
follows lemma fact value learned view acceptor pre prepared lemma proves agreement 
help prove liveness termination property show dgv allows fast resp 
fast learning identify weak termination properties locking part algorithm 
fast weak termination run synchronous correct privileged proposer pk proposer proposes value sufficiently long time acceptors faulty correct learner learns value communication rounds 
fast weak termination run synchronous correct privileged proposer pk proposer proposes value sufficiently long time acceptors faulty correct learner learns value communication rounds 
eventual weak termination run eventually synchronous correct proposer pk proposes value time gst gst highest view number proposals invoked time proposer proposes value higher view number sufficiently long time acceptors faulty correct learner eventually learns value 
notion sufficiently long time case means proposer pk proposes na correct acceptors receive pre prepare message pinit 
synchronous run acceptors faulty time bounded correctly estimated acceptor 
case sufficiently long time means proposer pk proposes na correct acceptors receive na prepare messages correspond pre prepare message sent pinit 
synchronous run acceptors faulty time bounded correctly estimated acceptor 
case sufficiently long time means proposer proposes value na correct acceptors receive pre prepare message pk na correct acceptors receive na prepare messages corresponding pk proposal 
lemma 
locking module satisfies fast weak termination 
proof 
run synchronous correct acceptors receive pre prepare message correct privileged proposer known time period 
proposer proposes sufficiently long time na correct acceptors receive pre prepare message na correct acceptors pre prepare leader proposal send prepare message learners 
run synchronous correct learner receives na prepare messages value proposed learns value 
correct learner learns value communication rounds correct proposer proposed value 
lemma 
locking module satisfies fast weak termination 
proof 
proof analogous lemma 
property locking part prove dgv provides fast learning 
lemma 
dgv algorithm achieves fast learning 
proof 
prove lemma sufficient prove run favorable privileged proposer pinit correct proposes value correct learners learn value proposed pinit communication rounds 
prove recall assumption pinit proposes immediately initialization algorithm 
line see correct pinit proposes skips read phase directly sending pre prepare message acceptors 
run synchronous messages sent correct processes delivered correctly estimated correct process bound message transmission delay 
guarantees correct acceptor receives pre prepare message timers acceptors set acceptor times 
words pinit proposes immediately initialization algorithm correct acceptor suspect leader correct acceptors receive pre prepare message proposer proposes valid view proof proposer proposes sufficiently long time 
property locking module conclude correct learners learn value communication rounds dgv achieves fast learning 
lemma 
dgv gracefully degrading algorithm 
proof 
prove lemma sufficient prove favorable run privileged proposer pinit correct proposes value correct learner learns value proposed pinit communication rounds 
proof analogous lemma 
proceed lemmas prove termination 
lemma 
valid riteproof consists new view ack messages sent acceptors choose riteproof aborts 
proof 
sufficient prove choose riteproof aborts riteproof contains new view ack message malicious acceptor 
consider case choose riteproof aborts flag true lines 
consider exhaustive subcases case choose aborts line candidate values st highest associated view number leader view riteproof 
riteproof acceptors aw leader view ai claims received aw view aj claims received aw view difficult see acceptors malicious 
case choose aborts line candidate value st highest associated view number candidate value associated view number leader view riteproof 
similarly case riteproof acceptors aw leader view ai claims received aw view aj claims received aw view difficult see acceptors malicious 
consider case choose riteproof function flag false lines fig 

consider exhaustive subcases case flag false candidate value line 
case acceptors ai aj claim set na acceptors accepted value set na acceptors accepted value view na sets intersect non malicious acceptor acceptor ai acceptor aj malicious 
case flag false candidate value candidate value associated view number constellation prepare messages exchanged acceptors authenticated line 
case bound number acceptors na na 
ritep roof set na acceptors claim accepted 
set na acceptors claim received independently na acceptors 
acceptor set claims acceptor sent 
obviously malicious acceptor set case flag false candidate value cardinality na candidate value cardinality na associated view number constellation case prepare messages exchanged acceptors authenticated new view ack message malicious leader view ritep roof line 
case bound number acceptors na na na yields 
riteproof set na acceptors claim accepted 
set na acceptors claim received independently na acceptors 
acceptor set claims acceptor sent 
obviously malicious acceptor set property locking module hold malicious acceptors need prevented sending false valid new view nack messages 
satisfy sufficient guarantee acceptor valid view proof view number proposed 
call property creation property view proofs 
lemma 
locking module satisfies eventual weak termination view proofs satisfy creation property 
proof 
run eventually synchronous correct proposer pk proposes time gst highest view number proposals proposer pk proposes value sufficiently long time conclude na correct acceptors receive new view message pk complete lpo subprotocol necessary reply new view ack message pk eventually receives messages correct acceptors 
lemma choose riteproof abort returns furthermore creation property view proofs holds malicious acceptor reply valid new view nack message pk 
pk sends pre prepare message containing proposal value process proposes na correct acceptors receive pre prepare message pk na correct acceptors receive na prepare messages conclude na prepare messages na commit messages sent correct learner 
note na correct acceptors case exist na na correct acceptors guaranteed exist 
acceptor failures na commit messages sent na correct acceptors pre prepare pk proposal proposer pk proposes value sufficiently long time 
run eventually synchronous prepare messages case commit messages case sent gst eventually correct learner lj receives na prepare messages na commit messages lj learns value learn value 
eventually correct learner learns value 
lemma 
view proofs generated election module dgv algorithm satisfy creation property 
proof 
prove lemma show way view proofs generated lines fig 
lemma guarantee process leader view generate valid iewp leader received signed view change messages correct acceptors contained iewp 
note valid iewp contains view change messages na acceptors majority acceptors lemma non malicious acceptors send view change message view leader view lines lines fig correct proposer pk leader view immediately propose value reception necessary view change messages acceptor receive view proof view iewp pk proposes value 
hand malicious proposer follow algorithm 
note safe assumption malicious leader view pb proposed value soon malicious process generated notion proposing consider propose invocations valid view proofs 
valid iewp 
reasonable distinguish case pb invoke propose case pb invokes propose valid view proof pb send protocol message 
pb receive signed view change messages sent non malicious acceptors process receives safely argue pb followed algorithm proposed 
say pb proposed send protocol message 
view proofs algorithm satisfy creation property 
prove termination property 
requires correct learners learn value correct proposer proposes acceptors faulty assumption eventually synchronous system 
note immediately initialization algorithm correct acceptors trigger imeout timer 
triggering imeout correct acceptor timer permanently receives decision message learner 
lemma 
termination correct proposer proposes value eventually correct learner learns value 
proof 
suppose single correct proposer pk proposes time gst highest view number proposals invoked upper bound time interval required execution sequence operations gst acceptor sends view change message necessary iewp pk checks signatures generates iewp pk sends new view message acceptors pk completes successfully read phase including possible lpo pk generates ritep roof chooses proposal value pk sends pre prepare messages acceptors receive proposal check riteproof proposal value send prepare messages learners acceptors correct acceptors prepare pk proposal 
assume upper bound time required local computation related authentication auth upper bound message transmission delay gst finite upper bound exists sufficient auth communication rounds described sequence rounds involve local computations related authentication 
suppose contradiction correct learner learns value correct proposer proposes 
distinguish cases correct acceptor receives decision message learner correct acceptor receives decision message learner 
consider case 
claim case correct acceptor goes infinite number views 
basically show infinite number new views gst system eventually synchronous 
suppose finite number views highest view number 
due assumption correct acceptor receives decision message correct acceptor stops imeout permanently 
imeout keeps expiring reset acceptor consequently correct acceptor issues view change messages infinite number views 
assume na correct acceptors na na lemma messages correct processes delivered timely manner gst view number higher correct proposer sends new view message 
correct acceptor accept new view message view higher view case correct acceptor higher view contradiction 
correct acceptor goes infinite number views imeout grows infinitely correct acceptor 
note acceptor sends view change message view triggers timeout duration imeout imeout initial value imeout 
value imeout acceptor 
time view change messages sent gst lost delivered 
time exists finite number view change messages sent gst messages lost eventually delivered 
max gst time ai wai log imeout set correct acceptors 
wmin min wai ai max ai time words time correct acceptors view higher equal wmin imeout wmin lowest view number higher correct proposer pk leader 
infinite number view changes correct acceptors send view change message view latest tw imeout wmin 

furthermore correct acceptor send view change message view higher tw imeout note time tw tw proposer proposes higher view number pk 
pk propose latest right tw receives na view change messages 
note tw tw imeout wmin 
imeout wmin basically pk proposer proposes value period time greater highest view number proposals tw 
words pk propose tw gst highest view number tw sufficiently long time 
eventual weak termination property locking module correct learner eventually decides contradiction 
consider case correct acceptor receives decision message learner 
correct learner periodically sends query acceptors learn value gst messages sent correct processes delivered correct acceptor eventually forward decision message correct learner learn value 
ai correct gst messages correct processes delivered bounded time new leader wait additional new view ack message choose function detects malicious acceptor ritep roof 
reception additional message new leader invokes choose function subset size na set received new view ack messages set na new view ack messages na subsets size na 
choose invocation aborts flag false subset received new view ack messages size na leader waits new view ack message 
dgv variants give dgv variants match lower bounds constellation 
followed discussing dgv optimization special case parameter values constellation 
pointed earlier dgv variation addressed special case constellation proposers acceptors authentication fast learning 
variant optimized state machine replication model privileged proposer acceptor single consensus instance privileged proposer acceptor 
give generic lower bound matching solution constellation part theorem need modify 
give general solution constellation case authentication fast learning 
show proposition alg 
consensus algorithm achieves fast learning despite failure acceptors authentication case priv pl constellation na max 
matches bound established combining propositions section 
addition gracefully degrading algorithm achieves fast learning authentication na min achieves fast learning authentication na min 
matches bound established proposition section 
interestingly prove proposition alg simplify way fast learning techniques 

acceptors send prepare messages learners view 

acceptors modify kai sets view iew 
rest algorithm stays performance optimizations possible 
practically small changes significantly simplify dgv variation especially proof 
basically solving potential disputes candidate values lot easier candidate candidate value associated view number higher 
match lower bound part theorem case authentication fast learning 
show proposition alg 
consensus algorithm achieves fast learning despite failure acceptors authentication case priv pl constellation na 
matches bound established proposition section 
prove proposition alg need introduce additional changes 
addition changes fast learning techniques view introduce modifications privileged proposer pl pinit authenticates signs pre prepare message 
simplify somewhat modify choose function 
note simplicity give variant dgv satisfies proposition alg gracefully degrade 
variant allows graceful degradation authenticated messages fast learning respect number available acceptors obtained merging original choose function gave section variant choose function give 
choose function variant 
note special variant dgv assumes na max 
special case interesting cases part lower bound theorem dgv variant authentication fast learning feasible 
choose ritep roof returns view view view nil sort candidate values associated view highest view candidate value associated view endif single candidate value elseif candidate values new view ack sent privileged proposer pinit riteproof abort elseif na elseif na endif endif nil view endif view view return view elseif view view return view return endif fig 

constellation matching lower bound authentication fast learning choose function sketch correctness proof variant 
value learned reported na acceptors ritep roof 
inequality na hold case need show na 
na max na max 
conclude na 
value learned certainly candidate value riteproof na acceptors report non malicious acceptors change kai set view 
value learned similar reasoning lemma section conclude choose riteproof view return difficult see value learned view accepted non malicious acceptor true 
show learned non malicious acceptors accept 
proof uses induction view numbers prove base step 
candidate value riteproof choose riteproof returns candidate value obviously privileged proposer pinit malicious valid riteproof contain message sent pinit 
case valid riteproof na candidate values cardinalities na contradict na choose riteproof returns agreement violated 
may argue validity violated set malicious acceptors single candidate value thin air 
case 
see consider case pinit malicious 
case pinit authenticates pre prepare message malicious acceptors forge signature candidate value 
hand pinit malicious value malicious acceptors pinit proposed non malicious acceptors distinguishing cases 
fast learning provide additional guarantees respect fast learning 
write phase dgv variant prepare messages exchanged acceptors necessary 
case dgv variants extends write phase view 
algorithm simpler write phase locking module consists communication rounds regardless algorithm parameters grateful lorenzo alvisi leslie lamport jean philippe martin piotr helpful comments 

marcos aguilera carole hugues sam toueg 
consensus byzantine failures little system synchrony 
technical report universit denis laboratoire informatique applications liafa september 

bowen alpern fred schneider 
defining liveness 
information processing letters 

dutta fr lund rachid guerraoui 
deconstructing paxos 
sigact news distributed computing 

gabriel bracha sam toueg 
asynchronous consensus broadcast protocols 
journal acm october 

miguel castro barbara liskov 
authenticated byzantine fault tolerance public key cryptography 
technical report mit lcs tm mit laboratory computer science 

miguel castro liskov 
practical byzantine fault tolerance 
proceedings third symposium operating systems design implementation new orleans usa february 

miguel nuno ferreira lung paulo ver 
low complexity byzantine resilient consensus 
di tr department informatics university lisbon august 

dolev strong 
authenticated algorithms byzantine agreement 
siam journal computing 

danny dolev reischuk raymond strong 
early stopping byzantine agreement 
journal acm 

rachid guerraoui 
encapsulating failure detection crash byzantine failures 
proceedings int 
conference reliable software technologies vienna may 

dutta rachid guerraoui 
inherent price 
proceedings annual symposium principles distributed computing pages 
acm press 

cynthia dwork nancy lynch larry stockmeyer 
consensus presence partial synchrony 
journal acm april 

fischer lynch 
lower bound time assure interactive consistency 
information processing letters 

michael fischer nancy lynch michael paterson 
impossibility distributed consensus faulty process 
journal acm april 

roy friedman michel raynal 
simple efficient oracle consensus protocols asynchronous byzantine systems 
rd ieee international symposium reliable distributed systems pages brazil october 
ieee computer society press 

eli gafni 
round round fault detectors extended unifying synchrony asynchrony 
proceedings seventeenth annual acm symposium principles distributed computing pages 
acm press 

keidar sergio rajsbaum 
simple proof uniform consensus synchronous lower bound 
information processing letters 

klaus kursawe 
optimistic byzantine agreement 
proceedings st ieee symposium reliable distributed systems page 
ieee computer society 

leslie lamport 
time clocks ordering events distributed system 
communications acm july 

leslie lamport 
part time parliament 
acm transactions computer systems 

leslie lamport 
lower bounds asynchronous consensus 
directions distributed computing springer verlag lncs pages 

leslie lamport 
lower bounds asynchronous consensus 
technical report msr tr microsoft research 

leslie lamport 
private communication 
november 

malkhi michael reiter 
high throughput secure reliable multicast protocol 
journal computer security 


martin alvisi 
fast byzantine paxos 
technical report tr university texas austin department computer sciences 

pease shostak lamport 
reaching agreements presence faults 
journal acm april 

michael reiter 
secure agreement protocols reliable atomic group multicast rampart 
proceedings nd acm conference computer communications security pages 
acm press 

michael reiter kenneth birman 
securely replicate services 
acm transactions programming languages systems 

ronald rivest 
md message digest algorithm 
internet rfc 

ronald rivest adi shamir leonard adleman 
method obtaining digital signatures publickey cryptosystems 
communications acm 

fred schneider 
implementing fault tolerant services state machine approach tutorial 
acm computing surveys december 

philip park 
interactive consistency multiple failure modes 
proceedings seventh symposium reliable distributed systems pages 
ieee computer society press 

gene tsudik 
message authentication way hash functions 
proceedings th annual joint conference ieee computer communications societies pages 
removing authentication decision messages section argued signing decision message learners send learning value avoided 
decision message permanently stops imeout election acceptor module 
idea generalized consistent broadcast subroutine 
primitives 
properties validity correct learner correct acceptors creation learner learner 
relay correct acceptor correct acceptors eventually priority correct acceptor correct learners eventually implementation general consistent broadcast 
slightly modified generalized respect constellation learners acceptors distinct implementation 
message sent subroutine retransmitted periodically circumvent assumption unreliable channels implement virtual reliable channels 
learner lj send init acceptors reception ready different acceptors value acceptor aj reception init learner echo message sent send echo acceptors reception echo na different acceptors echo message sent send echo acceptors ready message sent send ready acceptors learners reception ready different acceptors echo message sent send echo acceptors ready message sent send ready acceptors learners reception ready na different acceptors value fig 

implementation generalized consistent broadcast having implementation election module modified learner lj value lj learns furthermore lj learn lj lj learned value 
furthermore acceptor aj permanently stops imeout value 
proof correctness similar proof consistent unique broadcast lemmas section prove intersection subsets acceptors 
omit complete proof 

