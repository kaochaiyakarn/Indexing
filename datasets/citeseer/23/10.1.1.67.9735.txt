walkabout retargetable dynamic binary translation framework cristina cifuentes brian lewis david ung walkabout retargetable dynamic binary translation framework cristina cifuentes brian lewis david ung tr january dynamic compilation techniques renaissance years due high performance implementations java language 
techniques originally developed virtual machines object oriented languages smalltalk commonly java virtual machines jvm java just intime compilers 
techniques applied binary translation years commonly appearing binary optimizers platform improve performance binary programs execute 
walkabout project investigates develops dynamic binary translation techniques properties retargetability ease experimentation separation machine dependent machine independent concerns debugging support 
walkabout framework experimenting dynamic binary translation ideas techniques related areas interpreters instrumentation tools optimization 
report design walkabout framework initial implementation 
tools generated initial framework include disassemblers machine code interpreters emulators binary rewriting tools sparc architectures 
mtv san antonio road palo alto ca email address cristina cifuentes sun com brian lewis intel com david ung itee uq edu au sun microsystems rights reserved 
sml technical report series published sun microsystems laboratories sun microsystems printed unlimited copying fee permitted provided copies distributed direct commercial advantage credit source 
part covered copyright may reproduced form means graphic electronic mechanical including photocopying recording storage information retrieval system prior written permission copyright owner 
trademarks sun sun microsystems sun logo solaris java jvm java hotspot trademarks registered trademarks sun microsystems countries 
sparc trademarks license trademarks registered trademarks sparc international countries 
products bearing sparc trademarks architecture developed sun microsystems unix registered trademark united states countries exclusively licensed open information regarding sml technical report series contact editor chief eng sun com technical reports available online website research sun com 
walkabout retargetable dynamic binary translation framework cristina cifuentes sun microsystems laboratories palo alto ca usa cristina cifuentes sun com david ung sun microsystems laboratories palo alto ca usa david ung sun com brian lewis sun microsystems laboratories palo alto ca usa brian lewis sun com binary translation process translating binary executables possible run code compiled source input machine target output machine 
interpreter emulator binary translator possible approach speed native code machine 
translated code may run slowly native code low level properties machine modeled machine 
example digital express translator dig simulates byte order sparc architecture fx translator tho hh simulates calling sequence source machine native target alpha architecture 
walkabout framework retargetable binary translation framework experimenting dynamic translation binary code 
framework inspiration university queensland binary translator uqbt framework ce 
took learned areas retargetability separation machine dependent machineindependent concerns applied techniques new dynamic framework 
course code transformations support different due differences dynamic intel microprocessor research labs 
email brian lewis intel com author intern sun microsystems laboratories conducted 
current address university queensland david ung itee uq edu au document terms binary executable executable files synonyms refer binary image file generated compiler assembler run particular computer 
static translation 
example static translator operates target program executes afford expensive optimizations 
dynamic translator hand operates target program executing time requires unavailable target program 
goals objectives binary translation requires machine level analyses transform source binary code target binary code emulating features source machine identifying features transforming equivalent target machine features 
walkabout system types transformations determine safe native target features 
question answered early development binary translation system intermediate representation 
uqbt system rtls 
register transfer language explicit transfer control high level register transfer language resembles simple imperative languages explicit control transfers 
binary translation systems machine code intermediate representation mainly systems binary code generating code machine 
systems include dynamo wiggins mojo 
walkabout initially machine code intermediate representation 
plan rtl step 
want experiment rtls support translation target representation 
rtls machine dependent expose features delayed branches register windows 
goals project derive components binary translators possible machine descriptions understand instrument interpreters retargetable way determine rtl representation best suited dynamic machine translation best map rtls rtls understand debugging support needs integrated dynamic binary translation system develop framework quick experimentation dynamic binary manipulation techniques 
limit binary translation user level code operating systems solaris tm linux 
rtls machine denoted rtls 
previous dynamic binary translation techniques evolved emulation simulation techniques efficient way running programs machines generating target native code fly 
techniques dynamic binary translation systems originally developed language interpreters virtual machines languages apl forth smalltalk self java tm 
review literature main areas existing examples dynamic binary translators binary rewriting tools virtual machines object oriented languages 
dynamic binary translators daisy dynamically architected instruction set yorktown vliw virtual machine emulates existing machines order run applications including low level system programs daisy machine ea 
machines supports powerpc 
daisy developed ibm watson aid determining features new vliw architecture order successfully run variety existing programs 
daisy system provides simulations new architecture perform built 
hp aries pa risc ia dynamic translator hp ux operating system planned shipped ia hp ux systems zt 
aries combines fast interpreter dynamic optimizing compiler just time jit compiler 
operates compiling frequently interpreted code sequences native ia code 
aries allows users migrate pa risc applications transparently user intervention 
runtime verification support built part tool 
transmeta crusoe architecture dynamic binary translation term code morphing support running applications crusoe processor vliw machine instruction level parallelism kla 
code morphing software resides rom effectively layer sits bios vliw processor 
crusoe support hardware level features hard expensive support software level 
precise exception handling done shadowing registers holding state information providing commit rollback operation copy registers working shadow copies 
alias detection hardware guards illegal moves load instructions ahead store instructions store instruction overwrites previously loaded data 
self modifying code supported detecting happens previously translated code flagged invalid 
done protecting pages translated bit 
academic systems described literature uqdbt uc pro 
systems show retargetable dynamic binary translation feasible 
uqbt system intermediate representation code generation machine independent translation purposes 
intermediate representation compiles code decoded fly achieving better performance limited class architectures tested 
binary rewriting tools areas related dynamic binary translation include emulation simulation done 
emulators simulators include sun microsystems tools shade ck hmr fn stanford research simulators simos embra wr 
years dynamic developed research projects 
goal transparently binaries runtime improve performance 
systems commercially number open research questions implement systems 
example hard achieve consistently performance correctly executing programs 
systems include hp labs dynamo pa risc code compaq wiggins alpha code microsoft research mojo windows binaries 
dynamo mojo count branching instructions interpreting code detect frequently executed code generate native code applying variety optimizations 
wiggins samples cpu events frequently executed instructions target program hardware event counters digital continuous profiling infrastructure dcpi abd 
allows tool determine seed instruction trace frequently executed code determined 
systems show mixed results spec benchmark programs perform faster perform slower 
programs performance study reported literature aids understanding features affected programs programs worked dynamo wiggins example 
addition common problems involving changes program phase behaviour studied 
virtual machines object oriented languages years renaissance dynamic compilation techniques mainly due popularity java programming language drive build high performance java virtual machines jvm tm run java code faster 
jvms sun microsystems java hotspot tm virtual machine gm pvc dynamic compilation techniques produce quality native code 
techniques derived time virtual machine technology implement object oriented languages smalltalk gr ds self hol 
self inspiration original java hotspot virtual machine 
architecture optimizing virtual machines premise programs spend time code vm optimizes code interprets generates naive code rest little time spent 
terms java virtual machine jvm mean virtual machine java tm platform 
architecture walkabout walkabout framework designed retargetability mind 
interested supporting binaries different input output machines designed framework retargetable input output machines 
notation refer input machine source machine output machine target machine 
framework designed users instantiate new translators framework source target machines choice run target machine refer host machine 
interpreter translator dispatcher ms binary file code generator optimizer architecture walkabout framework architecture walkabout framework borrows architecture existing dynamic compilation systems 
illustrates architecture walkabout framework 
source binary program loaded virtual memory initially interpreted hot path 
code generated hot path placed translated instruction cache called fragment cache 
code generation simple optimizations applied obtain better code locality 
generated code executed control transfers dispatcher decides interpret code transfer control code fragment cache 
interpreted process repeats 
reoptimization translated code occurs piece translated code fragment cache executed 
retargetability supported walkabout framework specifications machine descriptions specifications hot path selection methods 
machine descriptions specify syntax semantics machine instructions allow automatic generation machine code interpreters emulators instruction encoders 
hot path frequently executed path program 
interpreter code generator dispatcher ms binary file walkabout framework implementation walkabout framework implement complete framework 
system built stages starting interpreters period months help 
illustrates implementation components walkabout implementation 
describe different tools built initial implementation 
interpreter interpreters walkabout framework automatically generated specifications syntax semantics machine instruction sets 
reused specifications uqbt project ce new jersey machine code toolkit sled descriptions rf uqbt ssl descriptions cs 
sled specifications allow users specify mapping binary assembly representation machine instruction set machine registers names registers 
ssl specifications allow users specify mapping assembly instructions equivalent register transfers name new registers declare overlaps define superoperators macros commonly set condition codes specify cycle machine 
combined sled ssl specifications provide complete information generate user level interpreter 
user level restriction imposed ssl descriptions describe semantics user level instructions goals uqbt project 
conceptual view interpreter generator illustrated 
interpreter generator takes input sled ssl description machine generates source code sled ssl interpreter generator interpreter generator interpreter interpreter java interpreter specified machine java language 
generated code compiled executable representation resulting interpreter 
interpreter generator creates interpreters java language interested comparing performance interpreters implemented languages relatively fair basis 
java interpreters object oriented desired due implementation issues explained section 
implementation tool implementation interpreter generator walkabout framework 
relies new jersey machine code toolkit provides matching statement decode machine instructions 
syntax matching statement resembles language statement 
matches series bits identifies instruction extracts operands field values instruction 
process generate java language interpreters illustrated 
sled ssl files machine parsed checked consistency 
matching file file generated consisting core decoder machine instructions associated language code implement semantics instruction predefined interpreter data structures capture state machine interpreted 
toolkit transforms matching file language code 
optionally postprocessing phase tool transform language file java language file making transformations syntax 
generated java language decoders compiled pieces information file loading system calls operating system interest personality machine stubs ms stub 
implementation os support elf binaries operating systems solaris tm linux 
system call support oss part 
machine stubs written initialize state machine interpreted interpreter internal data structures program startup time 
tool automatically generate disassemblers java language machine sled description needed case 
sled toolkit post proc java performance results ssl ms stub cc ms stub java compiler personality cc jni java compiler ms interpreter ms interpreter class interpreter generation process sparc architecture sled ssl descriptions generated interpreters sparc architectures running solaris linux operating environments respectively 
section report experimental results language interpreter sparc architecture 
shows results running language interpreter sparc architecture lightly loaded cpu ultrasparc machine running mhz cpu gb memory 
results runs specint programs compiled sparc machine 
program size program bytes listed interpretation time native time run programs seconds 
native time reported average runs 
interpretation time reported result run 
slowdown interpreter compared native code shown average approximately 
java language interpreters considerably slower language counterpart 
partly due difficulty dynamically compiling program implements interpreter 
execution time spent dispatching loop switches instruction significant amount time spent path statement 
practice observed slowdown java language version interpreter sparc architecture compared unoptimized language version interpreter slowdown compared optimized version language interpreter program size interpreted native slowdown go ksim li ijpeg perl vortex sieve fibo mean performance results automatically generated language interpreter sparc architecture small benchmarks 
results point slowdown programs executed java interpreter compared native code 
results observed java sdk sparc machine 
instrumenting interpreter hot path detection optimizing virtual machines rely instrumented interpreter determines hot paths program interpreted 
native code generated hot paths 
walkabout framework interested experimenting different ways determine hot paths interpreter 
challenging dynamic translator binary programs include high level information procedure boundaries loop information 
addition binary programs typically structured regular byte code programs executed virtual machines harder find natural instrumentation points 
designed simple language called instr instrumentation language allow instrument interpreters automatically generated tool 
instr allows easily create different instrumented interpreters different instrumentation rules 
illustrates instr 
instrumented interpreter generator parses sled ssl machine descriptions instr instrumentation description generates interpreter machine instrument instructions way specified instr specification file 
instrumented interpreter generated language 
walkabout framework instr language write specification dynamo executing tail tracing method db variations method 
similar way specify method java hotspot gm virtual machine example sled ssl instr instrumented interpreter generator instrumented interpreter generator instrumented ms interpreter method considered determine hot paths interpreter long specified instruction time information 
sections describe instr language give examples applications 
instr language instr language designed conjunction interpreter relied simple abstractions available interpreters 
interpreter interprets code instruction time 
knows fetch execute cycle machine interpreted 
consequently instr abstractions centered individual instructions fact interpreter fetch execute cycle decode instructions machine 
interpreters interest automatically generated walkabout framework tool language required way relate instruction names sled ssl specifications interpreters generated 
instrumentation languages tools atom es sev available high level abstractions program developers aims languages different needs integrated automatically generated interpreter reused purposes 
instr allows developers instrument instruction different points time instruction fetched instruction semantics executed instruction semantics executed 
instrumenting fetch execute cycle allows instrumentation repetitive actions instructions get fetched example observe record instruction opcode count number instructions executed 
instrumenting instruction semantics means actions executed particular instruction instruction fetched 
instrumentation file consists main sections 
definition 
fetch execute cycle 
support code 
definition section specifies instructions instrumented corresponding instrumentation code 
fetch execute cycle section specifies commands need executed iteration cycle 
support code section contains support functions instrumentation code code expressed language 
provides ebnf language 
specification parts parts definition support code definition definition table semantics table string sled names semantics string parameter list instrument code instrument code parameter list string string instrument code action support code implementation routines code ebnf instr language instr language action code denote valid language code difference action predefined keywords refer fields instruction 
keywords meaning 
ssl inst semantics keyword denotes standard semantics instruction described ssl specification file 

param string param keyword stands parameter way refer value named parameter operand instruction 
example instrumenting label instruction param label refers value branch label 

ssl string ssl keyword denotes ssl named register locations 
example ssl pc location holding value emulated pc register 
examples instr language allows walkabout framework construct instrumentation tools insert code interpretation order understand behaviour running programs 
tools basic block counting profiling 
record dynamic memory accesses branches taken instruction traces 
data collect drive related tools pipeline memory system simulators 
basic block counting want count number basic blocks executed program need increment counter time instruction causes basic block condition reached 
instr group sparc architecture branching instructions table called branch give semantics group instructions instrumentation instructions 
example code branching instructions kind branch increment counter count instrumented interpreter maintain original semantics specified ssl representation instructions 
definition branch ba bn bne bg ble bl bgu bleu bcc bcs bpos bvs bea bga bla ret call branch label bb count ssl inst semantics load monitor load monitor specified way 
load instructions interest grouped aload table 
load instructions take operands effective address load eaddr register value loaded reg 
load instruction decoded monitor mode flag set function monitor eaddr called semantics load instruction executed interpreter 
eaddr function monitors runtime value effective address load instruction referred eaddr records memory load instruction ssl pc pc value 
monitor eaddr function defined support section specification file 
definition load ld lda ldf load eaddr reg monitor mode monitor eaddr ssl pc param eaddr ssl inst semantics edge counting order instrument branches architecture define table jump names branches 
want count number occurrences edges taken program extend behaviour branches incrementing counter instruction semantics executed interpreter follows definition jump jump label increment counter ssl pc param label ssl inst semantics counter defined support code section specification file 
example branches take operand target address branch instruction referred example 
illustration purposes show support code section specification counter implemented 
implementation routines include map include map pair unsigned unsigned int edge cnt void increment counter int addr int addr pair unsigned unsigned edge pair unsigned unsigned addr addr map pair unsigned unsigned int iterator edge cnt find edge edge cnt edge cnt edge second increment counter routine edge cnt counts order record occurrences branch taken edges execution time 
count taken edge incremented routine gets iterator traverse map pairs edges increment counter edge 
runtime instrumented emulator increase count edge taken execution input program 
support print routine display number occurrences edge 
pathfinder pathfinder simple semi optimizing virtual machine sparc machine code generates sparc code hot paths performs simple optimizations code generation places generated code fragment cache 
pathfinder dynamic binary rewriting tool experiment dynamic code optimization 
pathfinder core implementation walkabout framework 
illustrates pathfinder architecture 
instrumented sparc interpreter automatically generated tool sled ssl specifications sparc instruction set different instr specification files 
form pathfinder tool sparc architecture resembles dynamic optimizing systems dynamo wiggins mojo written pa risc alpha platforms respectively 
part objective pathfinder able contrast techniques systems context retargetable framework 
pathfinder currently implement fully compared experimentally systems 
conceptually translators similar ways generate target code hot pieces source machine code criteria determining paths frequently executed perform varying levels optimization 
pathfinder code generator performs code layout optimizations simple optimizations explain turn 
intermediate representation built pathfinder code generator relies transforming sparc assembly instructions directly instructions 
sparc instrumented interpreter sparc code generator dispatcher sparc binary file sparc pathfinder implementation walkabout framework pathfinder memory system trivial 
reserve fixed sized fragment cache cache full flushed attempt fragments keep 
code layout code layout simple optimization achieved placing basic blocks execute frequently sequential fashion contiguous memory achieve better code locality reduce number branches needed code 
shows example code layout 
left diagram control flow graph program 
program executes loop quite large number times path 
note loop includes call routine return routine 
right side diagram illustrates code placed fragment cache improving code locality 
diagram placed sequentially memory 
nodes exit portals fragment 
exit portal exit basic block fragment code 
contains code allows program go back interpreter fragment code fragment linking implemented see 
branch inversion part code layout inversion certain branch instructions necessary keep basic blocks contiguous memory 
branch targets part trace jump exit portals fragment 
return call code layout example inversion delayed control transfer instructions sparc architectures straightforward replacing branch inverse branch instructions may antonyms delay slot semantics 
code branch address xfe inverted common behaviour program branch equals 
branch executes delay slot instruction branch taken 
trace xfe cmp xfe bne xfe xfe ld xc 
inverting branch requires non branch equal delay slot branch fall case executes code previously located addresses xfe xfe located starting code cache 
code fragment looks follows 
code cache cmp code cache code cache code cache nop code cache ld xc 
branch linking branch linking relates removal unconditional branches target branch moved located immediately branch instruction fragment cache 
branches typically include branch ba branch bn instructions counterparts 
code serves example branch address removed fragment cache code source address ae placed delay slot instruction 
fe ba fe add 
ba ae add ba ld sparc call instruction special case unconditional branch affects state register program counter written register order preserve return address 
case semantics assignment preserved instruction modified example includes call instruction 
ld call fa mov 
fragment generated trace computes return address source program stores register standard call semantics leading code code cache ld code cache sethi hi code cache add code cache mov 
shows sample sparc assembly code program left hand side corresponding code fragment 
left hand side shows bold face instructions belong trace program 
branch xfe transfers control xfe cc branch xfe transfers control xfe cad branch xfe cad jumps back start trace xfe 
example code layout branch inversion branch linking applied code 
right hand side shows bold face branch ca inverted branch ccc jumps start fragment 
pieces code cd exit portals 

xfe sll xfe bl xfe ca xfe srl xfe xfe bl xfe cc xfe srl xfe xfe bl xfe xfe srl 
xfe cc xfe bl xfe fc xfe srl xfe xfe dc bl xfe xfe srl xfe xfe ba xfe cad xfe ec add xfe xfe ba xfe cad xfe add 
xfe cad xfe cad xfe xfe tst xfe cae bl xfe cae xfe cae add xfe cae tst 
sll bl srl ca ca srl ca cac bl cb srl cb cb bl cbc srl cc cc add cc ccc cd tst cd exit xfe cae 
exit xfe 
exit xfe fc 
exit xfe 
exit xfe ca 
code layout example sample trace bold face generated code trace inline caching inline caching technique originally developed smalltalk virtual machines cache line lookup result message send call removing overhead system lookup routine ds 
inlined routine adds prologue guard code determine receiver type expected 
inline caching pathfinder predict target address indirect transfers control 
technique simple trace targets transfers control point program frequent target predicted 
example indirect jump contents register offset xf jmp xf transformed unconditional branch predicted location code 
lets say target address jump predicted stored predicted val code predicted location ensures jumps reaching code right ones compares predicted value expected value 
code transformation avoids indirect transfer control common destination address branch predicted add xf scratch set predicted val scratch cmp scratch scratch bne exit scratch 
similar way indirect calls returns corresponding call instructions fragment treated indirect jumps 
sparc architecture return instructions indirect transfers control contents register holds address instruction invoked procedure 
code shows trace return instruction corresponding call instruction trace 
return executed execution continues address fb 
fc sll fc mov fc ld fc ld fc cmp fc fc fc cmp fc ret fc restore fb cmp fb bne fb fb clr 
code fragment shows return instruction address fc trace replaced instructions fragment cache starting address code cache 
guard placed check correct jump targets reach address code cache address contiguous rest trace code 
code cache sll code cache mov code cache ld code cache ld code cache cmp code cache code cache code cache cmp code cache add code cache sethi hi code cache add fb code cache sub code cache pn code cache code cache restore code cache cmp code cache bne code cache code cache clr 
fragment linking fragment linking process joining fragment avoid going dispatcher reduces context switching 
fragment linking done code generation fragment reoptimization patches existing portal new fragment 
code generation generating fragment exits leads address start fragment creating exit portal direct jump second fragment generated 
performing reoptimization code fragment code shows frequently executed behaviour generate new hot traces note traces code fragment cache 
traces exit portals patched flow control need go dispatcher longer 
peephole optimizations code sparc architecture integer multiply division instructions hardware level library routines available implement instructions software making additions subtractions 
post machines implement multiply division instructions hardware 
day natively compiled sparc binaries library routines perform multiplication division 
tend compile lowest common denominator machine cases 
simple peephole optimization binaries transform library calls associated instructions set parameters return value equivalent multiply divide instruction host platform 
example multiplying values registers expecting result register code mov mov call nop mov replaced simple efficient instruction experimental results pathfinder tested spec benchmarks 
note reoptimization code performed pathfinder results improved 
report experimental results dynamo executing tail net trace selection method db mb cache size optimizations code layout branch inversion branch linking fragment linking 
shows results 
program static size bytes user execution time running interpreter pathfinder native machine 
results obtained lightly loaded cpu ultrasparc ii machine mhz cpu gb main memory 
tight loop performs bulk program benchmarks show slowdowns compared native execution runs 
results collected system tuned performance simple optimizations constant propagation inline caching better fragment linking missing 
interest ijpeg behave badly benchmarks ones dynamo system system accurately predict paths compile 
net method maintains counts executed targets backward taken branches 
counter target exceeds threshold executing path predicted collecting information iteration loop trace buffer element named trace head 
trace conditions net 
target backwards branch trace head 
current instruction backward taken branch new start trace 
history buffer reached size limit 
program static size interpreter time pathfinder time native time compress go ksim li ijpeg perl vortex sieve experimental results interpreter pathfinder performing optimization code pathfinder implement bail option 
case execution time pathfinder approaches running program interpretation mode 
classes programs showed bad behaviour trace selection method recursive programs statement programs 
recursive programs back branch easily detectable trace condition trace hot method net 
existing virtual machines self vm inlining recursive methods optimize recursive programs 
inlining done count method entry hot fact self version highly recursive programs fibonacci takeuchi runs faster native version program hol 
day java virtual machines perform inlining recursive methods 
note inlining procedures machine code programs straightforward inlining methods vm languages self java 
boundaries procedure binary program defined vm languages 
shows results running highly recursive program fibonacci different trace selection methods pathfinder net variation call recursive 
recursive method keeps track stack levels formed trace adds new trace condition net method building trace levels stack trace levels call returns 
way calls procedure fibonacci replaced setting register 
stack frames removed may exits interpreter 
program static size scheme pathfinder time native time fibo net fibo recursive experimental results problematic programs pathfinder configured net trace selection method results show version pathfinder net approach behaves just slowly interpreter vs see 
results show considerable improvement execution time procedure inlining method 
programs core execution time spent jumping arms statement normally exhibit behaviour vms particular arms switch statement compiled 
net method pathfinder detects hot instructions hot trace determined executing iteration loop trace collected type programs tends incorrect times 
debugging support goals walkabout project provide better debugging support uqbt counterpart 
debugger built integrate components walkabout system relying automatic generation disassembler interpreter core components 
walkabout debugger graphical java language tool provides windows display assembly instructions program state register contents 
users set breakpoints run program state 
programs run language version interpreter 
interpreter debugger run separate processes communicate socket allowing debugger remain active interpreter crashed 
disassembler java language version walkabout disassembler 
shows view walkabout debugger 
windows display different information state program disassembly window output shows disassembly program 
column allows users set breakpoints second column shows virtual address instruction loaded third column displays instruction hexadecimal format assembly format 
command window allows simple debugging control basically re start program run step instruction time continue program execution breakpoint program met program execution 
relocation memory program set 
register values window displays state registers condition codes program counters machine execution instruction details current instruction 
miscellaneous window displays breakpoint information trace window displays hot trace obtained running pathfinder tool 
view walkabout debugger experience walkabout framework designed partially implemented period months researchers 
done time final experiments static binary translation framework uqbt 
total effort researcher months intern months 
experiences implementation results walkabout framework positive 
results achieved design supported retargetability separation machine dependence concerns 
retargetability achieved specifications machine instruction sets instrumentation 
implementation walkabout framework staged 
disassemblers generated machine code interpreters emulators followed instrumented emulators determine hot paths program followed creation binary code rewriting tool called pathfinder 
components tools generated automatically 
machine code emulator generator big win 
able reuse existing syntactic semantic descriptions sparc instruction sets generate automatically emulators machines 
emulators able run existing programs including spec benchmark suite 
emulator generator able generate different versions emulator language java language 
allowed compare languages worked purpose 
emulator generator allowed quickly experiment multiple machines generate correct emulators extensive testing past ensured specifications correct 
development new specification language instrumenting machine code emulators instr big win 
emulator generator constructed way allowed easy integration instrumentation support code different points program 
instrumentation language simple easy specify new profiling schemes 
kinds instrumentation traditional eel instrumentation binaries 
restricted dynamic interpreter 
specify generate instrumented machine code emulators step decide determine program hot paths 
proved straightforward specify criteria 
code generation hot paths sparc architecture done reusing syntactic instruction specifications sparc architecture 
hot path analysis code concerned deciding types transformations apply source machine code simplified development time 
current implementation walkabout framework incomplete 
pathfinder tool code needed improve performance running applications 
pathfinder optimizations time automatically generated tuned expect consistently improve performance programs 
confirmed performance results obtained 
runtime programs native code interpreted code 
programs require close native time run times slower native code run close interpretation time slower walkabout generated interpreters 
optimizations fine tuning code generated pathfinder improve results 
graphical walkabout debugger proved help debugging system 
implemented java language relied components automatically generated walkabout framework 
includes java version disassembler version interpreter version pathfinder hot trace generator 
report describes design walkabout framework dynamic binary translation framework designed simplify experiments binary manipulation ideas specifications simplify retargetability 
implementation walkabout framework provides mechanisms automatically generate machine code interpreters emulators disassemblers java languages 
supports automatic creation instrumented interpreters language new specification language called instr 
walkabout includes general purpose binary rewriting tool called pathfinder implement example binary code 
walkabout framework generate tools sparc platforms 
acknowledgments authors nathan keynes implementation interpreter generator bernard wong implementation debugger 
mario wolczko suggestions ways improve presentation report 
walkabout distribution available online open source license 
please refer walkabout home site information project links distribution research sun com walkabout abd anderson dean ghemawat henzinger leung sites vandevoorde waldspurger weihl 
continuous profiling cycles gone 
technical report src technical note digital systems research center lytton avenue palo alto ca july 
www research digital com src 
bala duesterwald banerjia 
dynamo transparent dynamic optimization system 
proceedings acm sigplan conference programming language design implementation pages vancouver canada june 
acm press 
ce cifuentes van emmerik 
uqbt adaptable binary translation low cost 
computer march 
cifuentes van emmerik ramsey lewis 
university queensland binary translator uqbt framework december 
documentation uqbt open source distribution available fromhttp www itee uq 
edu au csm uqbt html 
cifuentes van emmerik ramsey lewis 
experience design implementation retargetable static binary translation framework 
technical report tr sun laboratories palo alto ca january 
ck cmelik keppel 
shade fast instruction set simulator execution profiling 
technical report tr sun microsystems laboratories july 
chen lerner 
mojo dynamic optimization system 
proceedings third acm workshop feedback directed cs dynamic optimization monterey california december 
cifuentes 
specifying semantics machine instructions 
proceedings international workshop program comprehension pages italy june 
ieee cs press 
db duesterwald bala 
software profiling hot path prediction 
proceedings ninth international conference architectural support programming languages operating systems boston usa november 
acm press 
rubin 
wiggins line program dig specializer 
slides compendium hot chips 
stanford ca august 
alpha migration tools 
express 
www support compaq 
com amt index html 
ds peter deutsch alan schiffman 
efficient implementation smalltalk system 
conference record th annual acm symposium principles programming languages pages 
acm press january 
ea ebcioglu altman 
daisy dynamic compilation architectural compatibility 
technical report rc ibm ibm watson research center yorktown heights new york august 
es eustace srivastava 
atom flexible interface building high performance program analysis tools 
proceedings usenix technical conference pages january 
digital western research laboratory technical note tn july 
fn 
opening windows 
sun microsystems press 
gm robert 
compiler java hotspot virtual gr machine 
szl sz rm nyi gutknecht editors school niklaus wirth art simplicity 
morgan kaufmann publishers los altos ca usa 
adele goldberg david robson 
smalltalk language implementation 
addison wesley reading ma 
lzle bak 
java sun high performance java implementation 
proceedings ix august 
hh 
digital fx combining emulation binary translation 
digital technical journal 
hmr reese 
cpu emulation 
proceedings hot chips viii 
hol urs holzle 
adaptive optimization self reconciling high performance exploratory programming 
thesis cs tr stanford university department computer science august 
kla 
technology crusoe processors 
transmeta freedom circle santa clara ca january 
white 
pro probst 
fast machine adaptable dynamic binary translation 
proceedings workshop binary translation barcelona spain september 
pvc michael cliff click 
java hotspot server compiler 
proceedings virtual machine research technology symposium jvm pages monterey usa april 
usenix association 
rf ramsey fern ndez 
specifying representations machine instructions 
acm transactions programming languages systems 
rosenblum herrod witchel gupta 
complete computer simulation simos approach 
ieee parallel distributed technology pages 
sev srivastava edwards vo 
binary transformation dis tho tributed environment 
technical report msr tr microsoft research microsoft way redmond wa april 
thompson 
alpha pc clothing 
byte pages february 
uc ung cifuentes 
machine adaptable dynamic binary translation 
acm sigplan workshop dynamic adaptive compilation optimization pages boston ma january 
acm press 
ungar smith 
self power simplicity 
conference object oriented programming systems languages applications pages 
acm press october 
wr witchel rosenblum 
embra fast flexible machine simulation 
proceedings conference measurement modeling computer systems sigmetrics philadelphia usa 
acm acm press 
zt zheng thompson 
pa risc ia transparent execution recompilation 
computer march 
authors cristina cifuentes senior staff engineer sun laboratories mountain view california investigates techniques applications binary translation 
cristina published areas binary translation program comprehension software maintenance compiler construction reverse engineering decompilation copyright legal aspects computing 
edited books invited lectures worldwide various topics served program committee numerous conferences workshops 
cristina principal investigator walkabout uqbt dcc projects 
prior joining sun microsystems laboratories july held academic positions university queensland university australia 
cristina obtained ph queensland university technology australia 
brian lewis senior staff software engineer programming systems lab intel microprocessor research labs 
interests include binary translation virtual machine programming language implementation 
previously sun implemented automatic checkpointing high performance java virtual machine 
implemented tcl clarity virtual machines 
developed monitoring debugging tools spring distributed operating system 
prior joining sun brian worked olivetti research implemented user interface toolkit runtime software 
xerox led team developed shared books distributed multi user publication management system 
implemented portions mesa programming system developed software version management tools 
received ph computer science university washington 
david ung ph student university queensland brisbane australia works area dynamic binary translation optimization 
areas interest include binary translation emulation compilers reverse engineering mobile computing 
david graduated university class computer science 
intern sun microsystems laboratories worked object cache simulation walkabout project 

