improving small file performance object storage james hendricks raja gregory ganger cmu pdl may parallel data laboratory carnegie mellon university pittsburgh pa proposes architectural refinements server driven metadata prefetching namespace flattening improving efficiency small file workloads object storage systems 
server driven metadata prefetching consists having metadata server provide information capabilities multiple objects just response lookup 
doing allows clients access contents small files metadata server interaction reducing access latency metadata server load 
namespace flattening encodes directory hierarchy object ids namespace locality translates object id similarity 
doing exposes namespace relationships objects hints storage devices improves locality metadata indices enables ranges exploiting 
trace driven simulations experiments prototype implementation show significant performance benefits small file workloads 
members companies pdl consortium including apc emc hewlett packard hitachi ibm intel microsoft network appliance oracle seagate sun symantec interest insights feedback support 
intel ibm network appliances seagate sun hardware donations enabled 
material research sponsored part national science foundation cns air force research laboratory agreement number army research office agreement number daad 
james hendricks supported part fellowship sponsored department defense 
keywords object storage object id assignment algorithms multi object capabilities namespace flattening osd range operations server driven metadata prefetching client get metadata ities de es direct client access 
client interacts metadata server obtain mapping information object ids access storage devices capabilities evidence access rights 
second client interacts appropriate storage device read write data providing capability request 
scalable storage solutions increasingly rely direct client access achieve high bandwidth 
cases direct access achieved specialized san protocols object storage protocols 
illustrated direct client access offers scalable bandwidth removing centralized server bottleneck shifting metadata management critical path 
result storage architecture standard high scientific computing 
destined niche architecture effectively support broader range workloads despite potential additional value object storage document management automation 
excellent high bandwidth access large files direct access systems struggle workloads involving access small files 
particular direct client access file data requires accessing metadata server mapping information capabilities accessing storage device 
large files time file metadata access amortized data accesses 
small files double latency data access system bottleneck 
proposes architectural refinements increase small file efficiency systems 
high level approach combines restoring lost file inter relationships metadata prefetching 
client requests metadata file metadata server provides mapping information capabilities related files 
caching clients potentially eliminate metadata server interactions small file data access reducing load metadata server access latencies clients 
prefetching key challenge identifying strong relationships right objects prefetched 
today file systems namespace hint regarding inter file relationships organizing prefetching metadata data accordingly 
object storage level indirection file naming object naming obscures hint 
restore namespace flattening encoding file hierarchical directory position object id assigned 
preservation namespace locality object ids naturally retains traditional hint storage devices provides spatial locality metadata structures enables compact representations groups ranges related objects 
describes architecture protocol changes required support server driven metadata prefetching 
efficiency requires capabilities authorize access multiple objects course appropriate client cache management 
interface changes required namespace flattening 
measurements prototype implementation show significant benefits workloads dominated small file access 
client applications cvs system compilation achieve significantly higher throughput 
metadata server loads decrease allow system scale larger facing metadata server scalability problems 
addition benchmark experiments prototype analysis real nfs traces confirm value namespace prefetching potential metadata server load reductions 
traces metadata server interactions eliminated prefetching mechanisms 
small files object stores section reviews object storage small files propose address related 
object storage storage object byte addressed sequence bytes plus set attributes accessed file interface create delete read write 
object store filesystem ascii names 
objects named object ids drawn flat numerical namespace bit numbers 
object storage originally conceived architecture illustrated achieving cost effective scalable bandwidth storage 
metadata server called file manager gibson store file system metadata handle metadata actions creation deletion lookup 
access data client fetch mapping information capabilities metadata server read write data directly object storage devices 
doing clients potentially exploit full switching bandwidth network interconnect data accesses 
contrast conventional server model limited bandwidth available file server interposed clients disks 
object storage gaining popularity traction 
working group storage networking industry association produced draft specification ansi body reviewed interface standard 
research object storage continues early products appeared 
addition scalable bandwidth exploit object storage mechanism bundle data application defined attributes long term maintenance regulatory compliance 
object storage viable outside niche domains able support small file workloads effectively 
problems small files required architecture object storage systems map file object multiple data striped 
systems struggle workloads access large numbers small files software development user workspaces reasons file metadata server interactions loss namespace locality storage devices 
file metadata server interactions access file data client corresponding mapping information capabilities 
get client interact metadata server 
client communicate directly storage devices access data 
metadata server interaction happens access 
client accessing contents large file interaction usually minor overhead amortized data accesses 
small file hand data access 
performance problems result increased latency client access heavy load metadata server 
accessing file data requires interacting metadata server client latency doubled rpc metadata server asked service requests storage devices combined 
loss storage locality object storage storage devices allocate disk locations objects store 
performance consequences goals essentially local file systems 
large objects performance usually achieved ensuring object contents placed sequentially 
small objects performance requires inter object locality keeping objects accessed close disk 
file systems achieve small file locality exploiting relationship hints exposed directory structures 
object storage systems difficult hiding information storage devices metadata server knows directory structures 
storage devices see object ids effectively employ locality enhancing tricks common file systems 
solving problems server driven metadata prefetching namespace flattening address problems minimal changes object storage architecture 
server driven metadata prefetching returning metadata just object queried metadata server return metadata related objects 
doing allows client populate cache additional mapping information capabilities form prefetching orchestrated metadata server 
client determines keep replace server determines prefetch 
necessary metadata cache client access storage device immediately 
right additional metadata returned number metadata server interactions drop dramatically 
common model prefetching client specify get 
server driven prefetching natural context fundamental practical reasons 
foremost knowing prefetch requires knowing exists 
metadata server information clients track existence inter relationships files redundantly local disk 
contrast large file streaming done simply asking sequential range data 
second server vendors differentiate performance things 
giving server control metadata prefetching increases likelihood utilized tuned aggressively 
third metadata server knows prefetched minimal cost 
example choose prefetch metadata blocks cache metadata block boundaries located 
promote server driven metadata prefetching requires mechanism overhead traditional client driven prefetching 
key insight batched metadata prefetching needed address file metadata server interactions problem 
client driven prefetching engineered just effort duplication metadata clients 
namespace flattening namespace flattening translates traditional file system approach improving small file performance object storage 
assigning object ids allocation policy monotonically increasing number object ids chosen reflect locality file namespace 
analogous inode number selection policies file systems utilize directory structure information enhance locality 
fact object storage explained splitting file system inode layer upper half metadata server lower half object storage device 
encoding namespace relationships object ids provides benefits 
storage devices treat object id locality hint closeness indicating relationships exploited internal layout cache management policies 
analogous file systems map namespace locality block number locality disk layouts 
second index structures object metadata storage devices typically organized tables trees indexed object id naturally better locality 
third set related files identified compact object id range enumerated list 
data identifiers hints spatial locality long history storage systems fact foundation disk system performance tuned 
file systems databases assign related data numerically close block numbers storage devices provide higher performance accesses numerically close block numbers 
making object id hint locality follows approach allowing basic non mandatory cooperation changes object storage interface standardization hint attributes 
block number locality traditional storage effect client storage device conforming implicit convention lower performance 
promote particular namespace flattening schemes noted convention specify object ids assigned simply suggests numerically close object id numbers indicate locality 
related section discusses related 
note prefetching long history storage systems cover 
namespace locality long recognized indicator inter file relationships exploited file system disk layouts 
ffs introduced cylinder group file systems call allocation groups mechanism placing related file system structures common disk region simple rules inode new file allocated cylinder group directory names data blocks file allocated cylinder group inode describes 
space cylinder group runs short rules effectively place metadata data small files directory small region disk 
ffs go locating related data metadata sequential runs blocks disk namespace locality just attempting get nearby 
namespace locality reasonable assumption information access patterns available 
explored approaches application hints observed access patterns controlling prefetching caching disk layout 
approaches identifying relationships accurate namespace locality metadata prefetching namespace flattening 
namespace locality remains predominant approach real systems part avoids additional mechanisms hints api application changes 
believe enabling exploitation namespace locality right place start minimal changes required 
proposes new approach addressing client latency metadata server load objectbased storage systems handling small file workloads 
approaches taken addressing issues systems 
metadata partitioned multiple servers doing scales throughput address extra roundtrip locality issues requires multi server consistency operations rename snapshot 
second requests batched reduce quantity readdirplus compound rpcs server driven metadata prefetching viewed form batching orchestrated server clients 
third metadata server store data small files objects eliminate extra round trip associated accessing small files exacerbate reduce metadata server load issues 
approaches complementary approach proposed competitors large scale systems require combination 
improving small file efficiency section describes mechanics server driven metadata prefetching example namespace flattening algorithms 
server driven metadata prefetching access data object storage system client fetch metadata capabilities metadata server interact directly object storage devices 
section reviews object metadata describes mechanics server driven metadata prefetching including changes required major component object storage architecture 
describes multi object capabilities means avoiding increased cryptographic network costs prefetched capabilities 
object metadata capabilities metadata object includes mapping information descriptive information 
capabilities credentials created metadata server shown storage device demonstrate client right access particular objects 
mapping information mapping information describes location data corresponding particular file location involved data spread locations 
location composed identity storage device object id device 
file data spread multiple storage devices ways disk arrays striping parity raid replication 
descriptive information different systems store different descriptive information metadata managed metadata server 
examples includes object length access control lists acls access modification times 
acls managed metadata server information allows determine requests service capabilities give 
conversely authority length time values may lie metadata server storage devices 
simpler requires extra interactions clients metadata server order update values 
allows values updated reads writes occur storage devices eliminating metadata server interactions regarding length times 
data file spread storage devices obtaining authoritative values length times simpler metadata server manages 
capabilities capability provides cryptographic proof storage device client permission perform particular operation 
metadata server constructs capabilities clients deciding client access 
capability generally consists mac mapping information access rights conveyed freshness fields avoid replay attacks 
key generating mac shared secret metadata server storage device allows storage device verify metadata server created capability entity shared key 
changes component object storage architecture primary components metadata server clients storage devices 
section describes changes realizing server driven metadata prefetching 
metadata server metadata server services metadata queries updates clients 
traditional object storage systems client request interacts metadata server respect object 
server driven metadata prefetching metadata server extended respond lookup request metadata capabilities client specified object objects believes client access 
collective response array singleton 
desirable minimize prefetching overheads additional responses valuable 
increased network bandwidth reduced compression techniques needed substantial practice metadata small relative small files 
disk cryptography overheads hand greater concern 
terms disk overhead issue extracting prefetched metadata persistent data structures object inodes table tree 
synergy namespace flattening helps spatial locality creates solves problem looking sequence values table tree efficient 
terms cryptography overhead capability traditionally provides access single object means prefetching requires generation capabilities 
section describes way mitigating cost having capability authorize access multiple objects 
clients primary change clients receive additional responses metadata server 
cache responses addition requested 
client cache management straightforward 
example client maintain distinct caches requested entries server pushed entries 
client pay attention hit rates avoid space server pushed entries useful 
pathological case working set just barely fit full sized client cache longer fits prefetched values 
constructed client cache notice server pushed entries useful workload retain fewer 
storage devices metadata prefetching namespace flattening change interfaces internal functionality storage devices 
change storage devices better performance 
particular namespace locality corresponds access locality numerically similar object ids exhibit temporal locality 
locality turn translate disk locality assuming traditional ffs disk management structures objects device internal metadata mappings object offsets disk locations 
multi object capabilities traditional object storage uses capability authorize access object 
proposed metadata prefetching objects require generation capabilities 
capability generation non trivial computational expense significant overhead prefetched information ends needed 
propose extending model capability authorize access multiple objects 
capabilities reduce prefetching overhead reducing metadata server cpu load reducing total number capabilities generated 
crucial capability size remain small recall clients send capability part request object storage device 
ideally capability compact constant sized regardless number objects covered 
ideal achieved capabilities cover range object ids mapping information formulaic access rights granted consistent 
range objects specified just start object ids 
mapping information collection related objects similar specified list storage devices simple scheme determining location index list hash object id 
altogether capability approximately twice size single object capability bytes 
ranges natural choice namespace flattening employed sequences object ids share locality directory hierarchy 
user permission access file directory permission files nearby directories 
note permissions question metadata server manages object length times storage devices returned part metadata 
need part capability 
client machine file permission nuances execute permission affect ability generate capability multiple objects 
said careful definition access rights required specifying objects covered range 
specifically access rights rely storage device assist deciding access allowed 
reads access right allow read access object exists allow sparse ranges 
writes access right allow write access existing bytes existing objects allow writes unbounded space growth 
capacity usage controlled quotas individual interactions metadata server required creating new data 
additional change needed multi object capabilities freshness information 
osd specification storage device stores version number object 
metadata server updates version number operation restrict previously issued capability object object deleted access rights change 
client requests capability metadata server includes version number capability 
storage device verify capability valid version number client provides capability equal version number object stored storage device 
avoid requiring separate version number object group capability change follows 
require metadata server monotonically increasing version number updating version number storage device issuing capabilities 
require storage device verify version number greater equal version number stored 
changes group capability contain version number valid objects updated capability issued 
addition constant sized allows capability remain valid objects group longer current objects 
namespace flattening namespace flattening object id assignment strategy encodes directory structure object id space 
context common assignment policies pseudo random create order 
pseudo random policy assigns object ids random number generator computing hash filename contents preserves locality information 
create order policy keeps counter simply assigns value created object 
preserve locality information creation order matches access order tends suffer fragmentation time 
section explains fragmentation problem detail describes namespace flattening algorithms 
fragmentation object id space object id assignment algorithms subject analogue inode fragmentation problem traditional block filesystems analyzed smith 
object ids assigned objects created subsequent operations modify namespace creates removes disrupt relationship namespace locality object id closeness simple policies create order 
time disruption tends slowly randomize relationship reducing locality extent namespace predictor 
recall modern file systems rely namespace way 
simple algorithm create order suffers especially fragmentation related problems creates perfectly dense object id space leaving room growth churn creations deletions files directories 
example create order files created directory different days assigned different object ids 
graphs illustrate create order susceptibility fragmentation 
graphs show object id assigned create order versus order traversal find command find non existent file linux source tree checked cvs repository 
leftmost graph shows initial state linux source tree soon checked repository 
cvs checkout command creates files depth order assigned object rag replacements initial state fifteen patches patches create order object id state psfrag replacements initial state state create order object id state fifteen patches find traversal state order dfs patches find traversal order dfs state patches psfrag replacements create order object id initial state state state fifteen patches find traversal order dfs fragmentation time object id space create order assignment algorithm 
ids exactly match order traversal find 
depth searches exactly right objects prefetched 
middle graph shows state checked source tree fifteen patches retrieved cvs repository applied 
resulting fragmentation clearly visible items accessed similar times close axis longer sequential object ids 
state patch applications shows fragmentation 
additional source fragmentation rename operations move files directories creates mismatch original allocation choices new namespace location 
fortunately operations extremely rare practice significant analysis traces section indicate comprise fewer operations 
systems cope fragmentation proactively reactively 
file systems proactively segment id space allocation groups create sparseness separate unrelated growth churn 
related objects matched segment id space allocations de allocations segment affect 
file systems reactively periodically sweeping changing assignments match ideal 
tends difficult largescale distributed storage systems contrasted desktop file systems complement proactive techniques 
method home home person home person submit ps home person submit pdf child closest cousin closest table namespace flattening example 
table illustrates namespace flattening policies showing object ids files directory hierarchy 
numbers hexadecimal 
namespace flattening algorithms section describes namespace flattening algorithms assigning object ids proactively avoiding fragmentation 
segment object id slots directory depth avoid fragmentation keeping directory contents slot 
child closest assigns depths statically explicitly placing subtrees children oid space 
second cousin closest uses shifting place directories hierarchy level cousins close oid space 
table illustrates showing file names translate oids 
table examples section assume bit oids presentation shown hexadecimal 
child closest child closest algorithm assigns slot level directory hierarchy moving left right numbers file directory directory 
example home assigned subdirectory person assigned xa id home person submit pdf start assuming slot bits size 
file number grows right left 
submit pdf assigned object id home person submit pdf 
object containing contents directory zeroth file directory assigned file number directory number space 
child closest algorithm perform particularly depth traversals exhibited find command workloads similar access patterns 
specifically algorithm closeness object id directory file function vertical distance directory hierarchy followed horizontal distance immediate descendants directory assigned oids close directory descendants assigned oids close 
additional feature policy represent entire subtrees single range 
example range ffff describe entire subtree rooted home person cvs project src 
cousin closest cousin closest algorithm uses slots assigns number file subdirectory directory 
object ids grow right left shifting parent directory bits slot 
example home assigned person assigned xa submit pdf assigned object id home person submit pdf 
child closest object containing contents directory zeroth file directory 
cousin closest algorithm perform particularly breadth traversals workloads similar access patterns 
algorithm closeness object id directory file function horizontal distance directory hierarchy followed vertical distance 
additional feature cousin closest tends produce denser representations directory hierarchies 
excessively deep wide hierarchies namespace flattening policies statically sized slots directory file number 
means possible width running numbers slot depth running slots 
address overflow partition object id space distinct regions high order bits 
concreteness descriptions provide examples bit object id space bits specify region leaving bits region 
primary region primary region uses namespace flattening policies non overflow files directories 
example lets assume bits directory slot bits file number directory 
primary region accommodates levels directories files directory 
deep region directory directory hierarchy deep greater levels example unallocated segment deep region 
deep region contains prefix bits slotted region file slot directory slots 
prefixes allocated sequential order new root new slotted region grows downward 
locality lost re rooted directory parent locality subdirectories maintained 
despite name deep region excess subdirectories directory 
example directories numbered slot 
ninth re rooted deep region prefix described 
wide region directory files example unallocated segment wide region overflow directory 
wide region divided prefix bits large file segment bits 
sample numbers files grouped prefixes 
deep region id locality lost original directory object id files rooted wide region 
wide directories significant penalty 
final region runs prefixes wide region deep region final region 
object ids final region example assigned create order 
guide slot size choices explore extent overflow expected reasonably sized filesystem studied departmental lab server houses home directories software development activities graduate students faculty staff 
server directories contain fewer directories files fewer 
files directories fewer levels directories away root directory 
server overflow rare example 
experimental apparatus section describes prototype implementation trace driven simulator evaluate proposed techniques 
prototype object storage system minor implemented namespace flattening algorithms server driven metadata prefetching objectbased storage system called minor 
detailed description minor available conforms basic architecture illustrated 
centralized metadata server manages metadata distributes capabilities object ids 
storage devices implemented application level software store object data clients access data 
nfs server acts object storage client behalf unmodified clients 
server driven metadata prefetching involved changes metadata server client metadata cache 
metadata server stores metadata tree indexed object id easy prefetch remaining items tree page containing metadata requested client 
prefetch size number additional objects prefetch metadata set experiments greater number metadata items contained page appropriate number items surrounding pages prefetched 
current implementation support multi object capabilities metadata compression replies metadata requests just lists contain requested prefetched metadata 
client metadata cache replaced segmented lru cache con taining primary prefetch segment 
demand fetched entries inserted primary cache evicted lru policy 
prefetched entries inserted prefetch cache moved front primary cache evicted 
implemented namespace flattening algorithms nfs server 
nfs server translates nfs requests data requests object data understood underlying object storage system 
mapping objects maintained nfs server object ids assigned time creation 
specifically receiving create mkdir request nfs server allocates object id creates object constructs nfs includes new object id object ids system bits size high bits dedicated specifying partition number 
namespace flattening algorithms bits 
bit object id osd specification limit system bits 
chose bits file number bits directory slots 
minor metadata accesses classified categories mandatory non mandatory 
mandatory accesses accesses due operations propagated metadata server immediately guarantee consistent namespace view clients 
specifically accesses due operations modify namespace create rename remove 
system metadata server manages length information append truncate operations incur mandatory accesses 
operations incur non mandatory accesses read write 
namespace flattening server driven metadata prefetching eliminate non mandatory accesses prevent mandatory accesses 
trace driven object storage simulator extended object storage simulator allow evaluation large traces real workloads fewer implementation artifacts 
simulator takes input nfs trace outputs number metadata cache accesses incurred client indication load placed metadata server required client latency 
simulator proceeds phases reconstruction simulation 
reconstruction phase scans trace recreate state file system possible time simulated portion trace 
uses information yielded traced operations create lookup readdir reconstruct namespace 
phase object ids assigned items reconstructed namespace whichever policy 
reconstructed namespace imperfect 
importantly files directories accessed visible trace unused parts original file system absent 
tend file system look smaller densely accessed 
addition creation order files exist trace began known 
predicted modification time available accessed files files created written traced environment 
believe despite limitations simulation results represent reasonable expectations traced environments 
simulation phase models client metadata interactions reconstructed file system 
simulates metadata cache segmented lru client 
file accessed trace check see metadata file exists appropriate client metadata cache 
number cache hits incremented 
number metadata accesses incremented metadata surrounding object ids prefetched client metadata cache 
accesses files reconstructed namespace ignored fit unclear 
files account files accessed implementation namespace flattening algorithms uses bits region number bits needed 
artifact current implementation 
traces analyzed trace eecs account 
files created simulation added reconstructed namespace assigned object id object storage system metadata accesses simulation phase categorized mandatory non mandatory 
prototype system clients granted authority manage length file certain amount time propagating updates metadata server 
result mandatory accesses include accesses result operations modify namespace create rename 
operations including length updates modeled non mandatory accesses 
model file length management accurately reflects existing object storage systems 
evaluation evaluated server driven metadata prefetching namespace flattening algorithms ways 
quantify benefits techniques actual system ran benchmarks modified version minor section 
determine effects fragmentation object id assignment algorithms evaluated techniques trace replay large real nfs traces objectbased storage simulator section 
evaluations report reduction accesses metadata server compared case prefetching performed measure decrease latency seen clients saved metadata server 
evaluation minor ran benchmarks minor determine benefits prefetching child closest cousin closest namespace flattening algorithms compared prefetching performed 
comparison purposes implemented create order assignment algorithm assigns monotonically increasing object id objects created 
benchmarks run total machines 
run storage devices stored data metadata 
nfs server benchmark located machine communicated loopback network interface 
setup emulates direct client access albeit additional software overhead 
single machine dedicated metadata server 
machine contained ghz pentium processor intel pro network card gigabyte western digital wd disk drives ran ware series raid controller mode 
items prefetched access metadata server segmented lru client metadata cache configured entry demand cache entry prefetch cache 
benchmarks evaluation listed 
popular benchmarks exhibit inter file locality 
example postmark uses random number generator select file access uses single file benchmarking 
synthetic workloads noteworthy benefits seen namespace flattening metadata prefetching 
custom benchmarks represents specific common filesystem 
tar benchmark consists linux source tree 
potential benefit prefetching limited benchmark metadata interactions creates mandatory accesses eliminated 
build benchmark consists building linux source 
involves reading source files creating object files 
due reads involved maximum potential benefit prefetching greater tar 
maximum benefit limited large number mandatory create operations object files 
patch rebuild benchmark consists patching linux source linux psfrag replacements prefetch metadata accesses prefetching create order child closest mandatory non mandatory tar build patch rebuild search cousin closest benefit obtained various object id assignment algorithms server driven metadata prefetching minor lower better 
graphs show decrease metadata accesses prefetching performed various object id assignment algorithms compared baseline prefetching performed benchmarks considered 
rebuilding 
maximum potential benefit prefetching greater build re build phase creates fewer files 
search benchmark consists depth search non existent word linux source tree command find type grep nonexistent 
workload readonly benchmark involves mandatory accesses metadata server 
reduction metadata accesses limited number items prefetched efficacy object id assignment algorithm 
compared benchmarks search exhibits greatest potential reduction metadata server accesses 
shows results benchmarks 
results show search potential benefit greatest server driven metadata prefetching possible object id assignment algorithms eliminates metadata accesses 
patch rebuild non mandatory accesses metadata accesses eliminated child closest cousin closest algorithms slightly fewer accesses eliminated create order algorithm 
accesses mandatory build potential benefit limited 
prefetching namespace flattening algorithms eliminates accesses benchmark non mandatory accesses 
create order eliminates fewer non mandatory accesses namespace flattening algorithms yields difference total metadata access prevented 
accesses tar mandatory prefetching yields benefit benchmark 
create order child closest cousin closest algorithms perform similarly benchmarks 
create order algorithm performs benchmarks exhibit concurrency create additional files fragment object id space brief runtimes 
difference visible create order algorithm performs worse child closest cousin closest algorithms build patch 
evaluation trace driven object storage simulator addition evaluating server driven metadata prefetching namespace flattening algorithms modified object storage system performed trace evaluation techniques object storage simulator 
evaluation simulator configured prefetch size cache configuration experiments run minor items prefetched cache segmented lru client metadata cache configured entry demand cache entry prefetch cache 
creation order files known files created start trace period create order algorithm approximated earliest modification time seen file trace 
comparison purposes implemented pseudo random object id assignment algorithm 
expected algorithm perform worse assignment algorithms significant cache pressure exists worse prefetching performed 
section describes traces evaluation 
section discusses aggregate results obtained 
section discusses effects individual client workloads aggregate benefit achieved 
traces nfs traces harvard university trace evaluation 
describe trace constituent workload 
eecs eecs trace captures nfs traffic observed network appliance filer february th th 
filer serves home directories electrical engineering computer science department 
sees engineering workload research software development course www traffic 
detailed characterization environment 
deas deas trace captures nfs traffic observed network appliance filer february th th 
filer serves home directories department engineering applied sciences 
sees heterogenous workload research development combined email small amount www traffic 
workload seen deas environment best described combination seen eecs environment mail traffic 
detailed characterization environment 
campus campus trace captures subset nfs traffic observed campus storage system october th th 
campus storage system provides storage email web computing activities students staff faculty comprised fourteen gb storage disk arrays 
subset activity captured campus trace includes traffic disk arrays home general mail login servers 
nfs traffic generated serving web pages students working cs assignments included 
despite exclusions campus trace contains operations day average eecs deas trace 
detailed characterization environment 
due differences number operations seen trace size restrictions database simulator store reconstructed namespace raw time required processing unable time periods trace 
eecs trace reconstructed server namespace february th trace performed simulation february th trace 
reconstruction simulation deas trace performed dates eecs trace 
campus reconstructed october th october st trace simulated october nd th trace 
results graphs show aggregate metadata accesses incurred clients trace prefetching various algorithms 
left graph shows number total metadata accesses prefetch metadata accesses eecs deas psfrag replacements frag replacements campus percent non accesses prevented policy mandatory non mandatory pref 
random order cousin child non mandatory prefetch accesses eecs deas campus pref 
random order cousin child percentage accesses required object id assignment algorithm compared case prefetching performed lower better 
leftmost graph metadata accesses categorized mandatory non 
mandatory accesses rightmost graph non accesses 
required percent required prefetching disabled 
graph gray bar shows contribution mandatory accesses white bar shows contribution non mandatory accesses 
mandatory accesses eliminated prefetching right graph shows results obtained mandatory accesses excluded 
aggregate results shown graphs yield major results 
server driven metadata prefetching namespace flattening results large reduction metadata accesses eecs trace benefit techniques offer limited deas trace campus trace 
second create order algorithm perform worse child closest cousin closest algorithms traces difference evident cases benefit derivable prefetching limited cases choice items prefetch paramount inter file relationships exposed child closest cousin closest algorithms serve realize small potential benefit 
traces study eecs trace probably representative academic research workload deas campus dominated mail traffic 
worthy note eecs trace stands gain benefit techniques 
metadata accesses trace non mandatory eliminated 
potential realized child closest cousin closest algorithms eliminate 
problems due fragmentation affect create order trace performs slightly worse namespace flattening algorithms 
potential benefit prefetching limited deas campus trace eecs trace 
effects fragmentation create order algorithm visible traces 
deas metadata accesses mandatory predominance mandatory accesses results large number temporary files incur mandatory create remove operations seen trace 
accesses non mandatory child closest cousin closest algorithms eliminate create order eliminates 
deas benefit limited campus trace due temporary file accesses 
peak hours files referenced campus trace temporary lock files coordinate access 
additionally campus users mail applications create temporary files mail compositions 
non mandatory accesses comprise metadata accesses campus accesses eliminated child closest cousin closest algorithms rag replacements deas campus accesses prefetching enabled child closest reduction reduction reduction eecs accesses prefetching disabled campus campus psfrag replacements eecs deas accesses prefetching enabled psfrag replacements eecs accesses prefetching enabled deas accesses prefetching disabled accesses prefetching disabled factor reduction number metadata accesses client 
log log scale scatter plot shows number metadata accesses prefetching disabled axis number metadata accesses prefetching enabled axis 
eliminated create order algorithm 
trace evaluation shows server driven metadata prefetching namespace flattening algorithms yield noticeable benefits academic research workloads yield reduction non mandatory metadata accesses eecs trace exact choice namespace flattening algorithm critical 
possible inferred identical performance child closest cousin closest algorithms prefetching metadata files directory level useful prefetching metadata descendants 
alternatively access patterns seen traces useful prefetch metadata items directory demand fetched files 
individual client performance graphs show reduction non mandatory metadata accesses seen individual client traces 
differences observable child closest cousin closest algorithms accesses incurred shown 
graphs show individual workloads generated various clients significantly impact benefit obtainable server driven metadata prefetching namespace flattening 
example aggregate reduction metadata accesses limited deas trace clients see factor factor reduction accesses 
aggregate benefit limited client generates metadata accesses sees benefit prefetching 
conversely eecs trace clients see benefit prefetching 
single client accounts metadata accesses sees factor reduction 
clients campus trace clients account accesses combined account 
clients account majority accesses see benefit prefetching 
summary aggregate reduction metadata accesses may limited workloads limiting metadata server scalability individual client latencies may see large benefits 
server driven metadata prefetching namespace flattening mitigate small file efficiency problems object storage systems 
having clients interact metadata server file server provides metadata multiple files time 
reduces metadata server load client access latency 
namespace flattening translates namespace locality object id similarity providing hints prefetching policies enhancing metadata index locality allowing compact range representations 
combined techniques help object storage satisfy larger range workload types just high bandwidth large file workloads 
craig soules insights comments reviews 
dan ellard margo seltzer sharing nfs traces 
michael abd el malek william ii chuck cranor gregory ganger james hendricks andrew michael prasad brandon salmon raja john strunk eno matthew jay wylie 
minor versatile cluster storage 
conference file storage technologies san francisco ca december pages 
usenix association 
marcos aguilera ji mark lillibridge john maccormick erwin dave andersen mike burrows timothy mann thekkath 
block level security disks 
conference file storage technologies san francisco ca march april pages 
usenix association 
thomas anderson michael dahlin neefe david patterson drew roselli randolph wang 
serverless network file systems 
acm transactions computer systems 
acm february 
pei cao edward felten kai li 
application controlled file caching policies 
summer usenix technical conference boston ma pages june 
daniel ellard jonathan pia margo seltzer 
passive nfs tracing email research workloads 
conference file storage technologies san francisco ca march april pages 
usenix association 
daniel ellard jonathan margo seltzer 
utility file names 
technical report tr 
harvard university march 
daniel ellard margo seltzer 
new nfs tracing tools techniques system analysis 
systems administration conference san diego ca pages 
usenix association october 
emc emc content addressed storage system 
www emc com products systems jsp platform 
michael factor kalman meth naor rodeh julian 
object storage building block storage systems 
ieee symposium mass storage systems sardinia italy june pages 
ieee 
gregory ganger frans kaashoek 
embedded inodes explicit grouping exploiting disk bandwidth small files 
usenix annual technical conference anaheim ca pages january 
gregory ganger john strunk andrew 
self storage brick storage automated administration 
technical report cmu cs 
carnegie mellon university august 
garth gibson david nagle khalil amiri jeff butler fay chang howard gobioff charles hardin erik riedel david jim zelenka 
cost effective high bandwidth storage architecture 
architectural support programming languages operating systems san jose ca october 
published sigplan notices november 
james randy appleton 
reducing file system latency predictive approach 
summer usenix technical conference boston ma pages june 
ramakrishna spencer love bradley 
caching strategies improve disk performance 
ieee computer march 
jeffrey katcher 
postmark new file system benchmark 
technical report tr 
network appliance october 
kent 
clustered san filesystem sgi 
www sgi com products pdf pdf 
thomas kroeger darrell long 
case efficient file access pattern modeling 
hot topics operating systems rio rico arizona march pages 
lustre 
www lustre org 
marshall mckusick william joy samuel leffler robert fabry 
fast file system unix 
acm transactions computer systems august 
mike gregory ganger erik riedel 
object storage 
communications magazine 
ieee august 


www com 
william don 
filesystem benchmark program 
information technology scsi object storage device commands osd ralph weber editor 
ansi technical committee july 
ftp ftp org drafts osd osd pdf 
www com 
hugo patterson garth gibson daniel jim zelenka 
informed prefetching caching 
acm symposium operating system principles copper mountain resort december 
published operating systems review 
solutions www com 
keith smith margo seltzer 
file system aging increasing relevance file system benchmarks 
acm sigmetrics conference measurement modeling computer systems seattle wa june 
published acm sigmetrics performance evaluation review 
acm press 
tivoli 
tivoli helping reach full san potential 
www tivoli com products documents ds pdf 
feng wang scott brandt ethan miller darrell long 
file system objectbased storage devices 
nasa goddard ieee conference mass storage system technologies md april 
ieee 
sage weil pollack scott brandt ethan miller 
dynamic metadata management scale file systems 
acm international conference supercomputing pittsburgh pa november 
ieee computer society 

