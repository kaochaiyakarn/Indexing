brics ds brabrand domain specific languages interactive web services brics basic research computer science domain specific languages interactive web services claus brabrand brics dissertation series ds issn january copyright claus brabrand 
brics department computer science university aarhus 
rights reserved 
reproduction part permitted educational research condition copyright notice included copy 
see back inner page list brics dissertation series publications 
copies may obtained contacting brics department computer science university aarhus ny munkegade building dk aarhus denmark telephone telefax internet brics brics dk brics publications general accessible world wide web anonymous ftp urls www brics dk ftp ftp brics dk document domain specific languages interactive web services claus brabrand phd dissertation department computer science university aarhus denmark domain specific languages interactive web services dissertation faculty science university aarhus partial fulfilment requirements phd degree claus brabrand march dissertation shows domain specific languages may applied domain interactive web services obtain flexible safe efficient solutions 
show key aspects interactive web services involving sessions dynamic creation html xml documents form field input validation concurrency control may benefit design dedicated language 
show notion metamorphic syntax macros facilitates integration individual domain specific languages complete language 
result domain specific language bigwig supports virtually aspects development interactive web services provides flexible safe efficient solutions 
acknowledgments michael schwartzbach supervising ph especially bringing attention ph program 
special go office mate colleague friend anders ller 
undergraduate study group tom rensen thomas flemming entire bigwig team particular anders sandholm olesen 
brics research center providing inspiring truly international environment particular set brics people jesus marco olivier danvy engberg jesper martin lange paulo oliva pagh frank valencia mads maria 
ibm research valuable months spent 
go manager roger pollak mentor john colleagues rose office mates 
people got know studying year strasbourg particular jacob patricia 
furthermore friends 
mom lise krause dad brabrand brother mads brabrand rest family 
tak vii claus brabrand aarhus march 
contents acknowledgments vii context domain specific languages interactive web services 
domain specific languages 
interactive web services 
structure dissertation 
sessions 
session centered approach 
structure bigwig services 
session runtime model 
related 
dynamic generation xml documents 
language dynamic generation xml 
flexibility 
safety 
efficiency 
related 

static validation dynamically generated xml 
summary graph analysis 
dtd xhtml 
validation 
experiments 
related 

ix caching dynamically generated xml 
solution 
evaluation 
related 

form field validation 
powerforms 
field interdependency 
related 

concurrency control 
solution 

metamorphic syntax macros 
related 
solution 

growing language concepts 
integration 
domain specific languages 
flexibility safety efficiency 
sessions 
dynamic documents 
form field validation powerforms 
concurrency control 
metamorphic syntax macros 
domain specific languages interactive web services 
ii publications bigwig project 
motivation 
bigwig language 
overview 
session centered web services 
script centered approach 
page centered approach 
session centered approach 
structure bigwig services 
session runtime model 
dynamic construction html pages 
analysis template construction form input 
html validity analysis 
caching dynamically generated html 
code gaps document clusters 
form field validation 
concurrency control 
syntax macros 
web service aspects 
html deconstruction 

databases 
security 
evaluation 
experience bigwig 
performance 

acknowledgments 
runtime system interactive web services 
motivation 
session concept 
cgi scripts sequential session threads 
cgi shortcomings 
handling safety requirements consistently 
components runtime system 
dynamics runtime system 
execution thread 
starting session thread 
interaction client 
interaction controller 
extending runtime system 
related 

powerforms declarative client side form field validation 
input validation 
field interdependencies 
javascript programming 
solution powerforms 
related 
validation input formats 
xi syntax 
semantics regular expressions 
semantics format declarations 
examples 
interdependencies form fields 
syntax 
semantics boolean expressions 
semantics interdependencies 
examples 
applet results 
translation javascript 
availability 

static validation dynamically generated html 
xhtml documents bigwig 
summary graphs 
gap track analysis 
summary graph analysis 
dtd xhtml 
validating summary graphs 
experiments 
related 
extensions 

language caching dynamically generated html 
related 
dynamic documents bigwig 
dynamic document representation 
client side caching 
caching 
compact representation 
clustering 
experiments 


growing languages metamorphic syntax macros 
related survey 
general properties 
syntax properties 
type properties 
definition properties 
xii invocation properties 
implementation properties 
related 
designing macro language 
syntax 
parsing definitions 
parsing invocations 
formedness 
hygienic macros 
growing language concepts 

parsing invocations 
formedness 
hygienic macros 
multiple results 
metamorph arguments 
growing new languages 
implementation 
transparent representation 
generic pretty printing 
error reporting 

appendix bibliography xiii part context list publications bigwig project anders ller michael schwartzbach 
transactions internet technology toit vol 
pp 
acm may 
runtime system interactive web services anders ller anders sandholm michael schwartzbach 
proceedings eighth international world wide web conference www pp 
elsevier may 
journal computer networks vol 
pp 
elsevier may 
powerforms declarative client side form field validation anders ller michael schwartzbach 
world wide web journal vol 
pp 
baltzer science publishers december 
static validation dynamically generated html anders ller michael schwartzbach 
proceedings acm sigplan sigsoft workshop programming analysis software tools engineering paste pp 
acm june 
language caching dynamically generated html anders ller olesen michael schwartzbach 
world wide web journal vol 
pp 
kluwer academic publishers 
growing languages metamorphic syntax macros michael schwartzbach 
proceedings acm sigplan workshop partial evaluation semantics program manipulation pepm pp 
acm january 
chapter domain specific languages interactive web services dissertation shows domain specific languages domain interactive web services achieve flexible safe solutions 
examine thesis breaking domain interactive web services relatively independent aspects 
aspects analysed addressed dedicated domain specific language 
show resulting sub languages integrated language bigwig developing interactive web services 
show integration supported notion metamorphic syntax macros 
briefly introduce concepts title domain specific languages interactive web services 
domain specific languages domain specific languages dsl general purpose languages gpl designed write particular kind programs 
course domain specific languages add expressive power turing completeness program written dsl written gpl 
domain specific languages advantages general purpose languages 
paramount advantage level abstraction correspond directly problem domain 
concepts inherent problem domain turned abstractions dsl 
similar abstractions defined libraries general purpose languages full context gpl details parameter mechanisms scope rules 
furthermore limited abstraction mechanisms invocation syntax gpl 
contrast domain specific languages may syntax chapter 
directly reflects idiom problem domain 
certain problematic constructions may explicitly prohibited syntax 
domain specific languages permit sophisticated domain specific analyses may restrict usage basis optimization 
comparatively achieved library gpl 
general prevents programmer library instance calling certain functions wrong order 
domain specific languages declarative easier read write modify 
simple domain experts 
programs concise point self documenting embody directly knowledge domain 
domain specific languages really considerable disadvantage cost construction 
realization requires iterations analysis design implementation evaluation 
created increase productivity reliability maintainability 
refer information domain specific languages including advantages general purpose languages 
interactive web services hypertext transfer protocol originally designed browsing static html documents world wide web 
need date customized documents spawned creation common gateway interface cgi platform independent method creating documents dynamically client input 
html equipped collection standard input widgets selecting entering various kinds data 
notion interactive web services obtained appropriately sequencing client interactions 
focus interactive web services web servers clients initiate sessions involve exchanges information mediated html forms 
identified relatively independent key aspects interactive web services addressed realistic services sessions clients guided appropriately interactions retaining state dynamic documents html documents constructed dynamically form field validation data entered clients validated concurrency control session processes run parallel means concurrency aspects dealt database integration services employ database integrated security web services inherently distributed means various security aspects addressed 

structure dissertation analysed aspects designed domain specific language targeted uniquely particular domain 
structure dissertation chapter introduces concept session presents main challenges solution runtime system 
runtime system explained chapter 
chapter presents language dynamically constructing html xml documents forms basis chapters 
chapter shows language analysed statically guarantee valid html documents shown client 
result included chapter 
chapter shows static parts dynamically generated documents cached clients 
solution topic chapter 
chapter presents sub language addressing form field input validation powerforms included chapter 
chapter describes concurrency control sub language 
chapter introduces notion metamorphic syntax macros may integrate sub languages bigwig language 
macro language explained chapter 
chapter concludes demonstrating domain specific languages obtained flexible safe efficient solutions domains 
shown sub languages integrated bigwig language developing interactive web services 
bigwig language included chapter 
see bigwig project homepage www brics dk bigwig documentation implementation 
chapter 
chapter sessions interactive web services today implemented single interaction paradigm focus single interaction client 
conceptually program interaction service constructed appropriate sequential composition essentially independent programs 
program executed request client receiving form data input producing html output terminating 
individual requests tied inserting appropriate links programs reply pages 
web service defined collection loosely related programs 
process illustrated 
major problem approach flow control implicit 
behavior service distributed numerous individual programs depends implicit manner pass control 
design complicates maintenance hard identify programs form service related 
design precludes sort automated global analysis leaving class errors detected running service 
particular way html page html page html page program compute compute program save state restore state interactive web service specified sequential composition essentially independent programs 
left client browser right programs running server 
chapter 
sessions checking interaction correspondence programs form input fields output program correspond expected input 
major problem handling local state 
persistent data shared session threads stored naturally database data local particular session sequence interactions managed explicitly 
individual programs terminate interactions local state passed programs 
solution pass local session data client subsequent programs hidden input fields cookies encoded part url 
approaches store state clients obvious security implications may tampered contain sensitive information disclosed 
solution program explicitly save state server terminates reloaded restored program 
case programmer needs deal low level issues handling serializing state 
single interaction paradigm divided main approaches script centered page centered 
supported various tools suggests particular set concepts inherent web services 
approaches briefly outlined 
script centered approach script centered approach builds directly top plain stateless cgi protocol 
interaction specified form program written general purpose programming language obeying cgi protocol receiving input producing output 
input form textual data form input fields decoded special environment variable query string standard input depending submission method invoking script 
html output typically created fly print statements 
prototypical scripting language perl programming language suggested role 
cgi scripting supported large collection library functions decoding form data validating input accessing databases realizing semaphores 
libraries targeted domain web services language 
java servlets language fits category 
structure service written servlets perl 
possible interaction essentially defined separate script cookies hidden input fields similar techniques connect sequences interactions clients 
servlets provide session tracking api hides details 
servlet servers cookies browser supports automatically revert url rewriting cookies unsupported explicitly disabled 
api exemplified code inspired servlet tutorials www apl jhu edu hall java servlet tutorial java sun com docs books tutorial servlets 
public class extends public void request response throws ioexception context session request true response text html response println html head title servlet demo title head body session println form action enter name input name handle input type submit form session state string state string session getvalue state state equals string name string request handle int users integer context users intvalue context users new integer users session name name println form action hello name user number users input type submit form session state state equals string name string session getvalue name println goodbye name session invalidate println body html clients running service guided series interactions service prompts client name name total number invocations shown goodbye page shown 
object contains information shared sessions object local session 
code essentially switch statement branches current interaction 
alternative approach servlet kind interaction 
spite api needs explicitly maintain state identity session 
model sessions supported servlets script centered approaches tends fit better shopping basket applications client browses freely dynamically generated pages complex services need impose strict control interactions 
page centered approach page centered approach covered language asp php jsp dynamic code embedded html pages 
sense inverse script centered languages html fragments chapter 
sessions embedded program code 
client requests page specialized web server interprets embedded code typically produces additional html snippets accessing shared database 
case jsp implementations compiling jsp page servlet simple transformation 
approach beautifully motivated simple examples pages mainly static sporadically contain computed contents 
example page displays time day number accesses clearly fits mold 
jsp page dynamically inserts current time title user name cgi input parameters html head title jsp demo title head body hello string name request name null name stranger 
print name page updated new date body html special tags contain java code evaluated time request 
long code parts generate strings markup easy statically guarantee shown pages valid html relevant properties 
services complex approach tends converge script centered 
mainly static html page code inserted typical picture single large code tag dynamically computes entire contents 
approaches closely related page centered technologies superior degree scripting languages generally better designed 
asp php languages reminiscent jsp 
asp closely tied microsoft internet information server implementations exist 
java defines language independent connection html pages scripting languages typically visual basic script microsoft version javascript 
php popular open source variant scripting language mixture java perl 
languages generally provide low level support tracking client sessions maintaining session state 
cookies hidden input fields library support common solution 
web service aspects databases security wide range libraries available direct language support 
session centered approach pure session centered approach pioneered mawl project 
service viewed collection distinct sessions access shared data 
client may initiate session thread conceptually process running server 
interaction client viewed remote procedure 
session centered approach html page html page html page compute show compute service program state preserved client server sessions web services 
left client browser right session thread service program running server 
thread initiated client request controls sequence interactions 
calls server known classical construction distributed systems roles reversed 
flow entire session programmed single sequential program closer ordinary programming practice offers compiler chance obtain global view service 
illustrates flow control approach 
important issues concurrency control simpler understand context standard programming solutions applicable 
mawl program equivalent previous servlet example static int users session auto form handle hello auto string name hello put handle auto form string int count greeting users greeting put name users auto form string goodbye goodbye put name html templates hello greeting goodbye placed separate files 
hello html head title mawl demo title head body enter name input name handle body html greeting html head title mawl demo title head body hello mvar name user number mvar name count body html chapter 
sessions template goodbye similar 
form tag continue button implicitly inserted 
variables declared static contain persistent data declared auto contain session data 
form variables declared record types 
defines set gaps occur template defines input fields 
templates gaps written mvar tags 
template variables put method 
executed arguments inserted gaps resulting page sent client fills fields submits reply turned record value program 
note notion sessions explicit program private shared state simply matter variable declaration modifiers templates cleanly separated service logic 
obviously session flow clear programmer compiler non session approaches 
concrete benefit easy statically check validity correct input fields 
main force session centered approach services control flow complex 
simple web services actuality loosely structured 
sessions tiny simply server module page centered approach overhead associated sessions may large 
script centered services seen subset session centered session contains client interaction 
clearly restriction script centered page centered languages allow significant performance improvements 
instance ee servlet jsp servers employ pools short lived threads store little local state 
involved services session centered approach programming easier session management comes free 
structure bigwig services structure bigwig programs directly inspired mawl 
bigwig program contains complete specification web service 
contains collection named sessions essentially ordinary sequential program 
client initiative invoke thread session process server executes corresponding sequential code exclusively communicates originating client 
communication performed showing client html page implicitly form appropriate url return address 
client views document session thread suspended server 
eventually client submits form causes session thread resumed form data entered client received program variables 
simple bigwig service communicates client servlet mawl examples service html hello html enter name input name handle html html greeting html hello user number count html 
session runtime model html goodbye html goodbye html shared int users session hello string name show hello receive name handle users show greeting name count users show goodbye name program structure obviously mawl session code templates wrapped service block 
show receive statements produce client interactions similarly put methods mawl 
bigwig provides number new features 
importantly html templates class values 
html built data type values passed stored variables data type 
html templates higher order 
means allowing text strings inserted template gaps allow insertion templates 
done special plug operator inserts string template gaps template 
clearly constitutes flexible document construction mechanism calls new ideas statically verifying instance html validity 
topic chapter 
new features include techniques improving form field validation concurrency control syntax macro mechanism described chapters 
session runtime model session model implemented top cgi protocol 
naive approach create session threads cgi scripts local state stored disk 
session interaction thread started restore local state including call stack order continue execution 
better approach implement session thread process runs duration session 
interaction tiny transient cgi script called connector process executed acting pipe web server session process 
approach resembles fastcgi described detail 
newest implementation specialized apache server module naturally faster cgi solutions create new process single interaction session processes 
runtime system available stand implementation called common sources problems standard implementations sessions history buffers bookmarking features browsers 
see httpd apache org 
available www brics dk bigwig 
chapter 
sessions www web server html file session process session runtime model reply indirection 
session thread implemented separate process writes html reply designated file 
history buffers back button users step back page previous interaction intentionally unintentionally resubmit old input form 
useful feature causes confusion annoyance users may instance order twice 
general problem information shown user way obsolete tailor exact time initial request 
information generated shared database may changed entirely generally sense step back time history buffer 
different ordinary programs 
problem external side effects 
observation may consequences known quantum theory modification observation able backtrack render high score feature number guessing game obsolete 
programmer aware stepping back time added serial number checks history buffer full urls obsolete requests 
service really needs back feature programmed explicitly flow sessions 
hazardous try bookmarks temporarily suspend session 
invoking bookmark typically cause cgi script executed second time just displaying results 
bigwig provides simple unique solution problems session thread associated url points file server containing latest html page shown client 
sending contents directly client show statement redirect browser url illustrated 
url serves identification session thread solves problems mentioned history list browser contains single entry duration session sessions bookmarked addition session identity url passed manually browser instance problems 
urls cookies represent session identity possible single user simultaneously run multiple sessions different windows browser 
simple solution furthermore automatically provide client feedback server processing request 
done seconds writing temporary response html file 
related informs client status request 
temporary file reloads frequently client browser allowing updated status reports 
final response ready simply overwrites temporary reply file causing reloading response shown 
functionality provided flash construct takes html document instruments necessary automatic reloading writes associated reply file 
default runtime system redirects client seconds providing message stating reply ready 
please wait 
simple technique may prevent client impatient abandoning session 
bigwig runtime system additionally contains garbage collector process monitors service shuts session processes abandoned clients 
default occurs client responded hours 
sessions allowed execute clean actions terminating 
related guide rule language belonging single interaction paradigm 
context carried scripts handles state distinguishing local session global variables 
contexts managed explicitly programmer 
wash cgi embedded dsl server side web scripting purely functional programming language haskell particular monads 
hanus curry library provides session abstraction callback mechanism submit handlers bound submit buttons permitting evaluation continue different points button depressed 
allows session backtracked idempotent reevaluation submit handler local state stored hidden input field client 
addition efficiency issues storing state client security issues vulnerable tampering may expose sensitive information 
example high score easily achieved wash cgi game inspecting local state backing session number guessed 
chapter 
sessions chapter dynamic generation xml documents important aspect web service development construction html reply documents customized individual clients request 
currently nearly web services construct document replies script page centered programming approaches 
approaches appear fundamentally different related interesting duality 
script centered approach default programming programmer escape printing html print command page centered approach default printing html escaping programming available special embedded scripting tags 
case jsp 
fact exactly happens jsp page lexically transformed java servlet html entities wrapped invocations print embedded code inlined resulting servlet program 
purely lexical process illustrated legal jsp fragment bold bold bold print bold italic print italic example shows structure illusion reason presence html constituents independent scripting elements 
means script centered approach parts reply document just dynamic content assumed come output turing complete computation 
output document essentially constructed concatenation dynamically constructed strings 
hard reason statically resulting documents 
specifically way constructing documents precludes static validation impossible statically analyse program determine possible documents produce valid html chapter 
dynamic generation xml documents prevents checking interaction correspondence impossible statically determine form input fields output document way checking corresponds expected input interaction 
addition absence static safety important limitations flexibility 
way constructing documents designer programmer aspects bits pieces html markup program code scattered service program making difficult designers programmers identify respective parts operate independently forces linear document construction documents constructed linearly html element html element opposed composed components logical manner 
fundamental limitations current developers willing accept 
mawl approach mawl language addressed issues introducing notion order html templates 
mawl template complete html document fixed collection named variables substituted simple dynamically computed string values document client 
templates placed separate files completely separating service code html code permitting programmers designers operate independently 
possible issue static safety guarantees template readily contains html markup reply document 
disadvantage approach reply documents customized fixed number simple parameterizations dynamically inserted string data may vary 
partially alleviated special iteration construction permits unbounded list simple values inserted repetitions html fragment 
insufficient produce nested lists tree structures 
language dynamic generation xml flexible safe language dynamically generating xml documents solves problems 
show regain flexibility lost compromising safety generalizing mawl solution higher order templates 

language dynamic generation xml document construction plug operator document template constant delimited html html may addition normal html contain number named gaps gap named syntactically written 
documents class values may assigned passed stored variables 
special plug operation available document construction 
expression creates new document value inserting copies gaps copy documents designated may contain gaps highly flexible dynamic mechanism constructing documents 
reminiscent higher order functions alpha conversion implicit layer binding gap names outermost level 
full generality plug operation accepts full document expressions document variables 
value plugged may string integer case coerced document converting angled braces lt gt respectively ensures markup comes constant templates 
multiple gaps may plugged syntactic sugar 
introduced notion attribute gaps gaps written inside elements may provide attribute dynamically computed value 
syntactically written name attribute gap name 
course attribute gaps plugged html string integer values 
example gradually composes welcome brics document 
service html cover html head title hi title head body bgcolor color contents body html html greeting html hello welcome html service html cover contents greeting show color ff stranger html brics html contents gap template cover plugged document greeting assigned yields new document attribute gap chapter 
dynamic generation xml documents brics head title hi title head body bgcolor color body contents greeting hello welcome ff stranger brics contents color head title hi title head body bgcolor color hello welcome body head title hi title head body bgcolor ff hello stranger welcome brics body building document plugging template gaps 
construction starts constants left ends complete document right 
color original cover template html gaps stemming greeting document 
gaps plugged succession result shown client 
document construction process illustrated client interaction show statement client interaction provided show statement takes document value implicitly plugs remaining gaps empty string shows client suspends computation 
document automatically wrapped form element appropriate action url client submits document process state paused 
default submit button added allowing form submitted 
show statement may receive part provides mechanism receiving values form input fields program variables 
example illustrates show receive mechanism service int string html input html name input type text name name br age input type text name age html html output html hello em user em year years old 
html session inputoutput show input receive name age 
flexibility show output user shows document input prompting client name age text input fields name age document submitted values entered received program variable increased plugged output document shown client 
flexibility section evaluate flexibility document construction approach contrast mechanisms 
service needs display page presenting dynamically generated list data instance list results search engine 
jsp example displays entries array options select field select name choice option value array option value array 
option value array select clearly number entries determined compile time hardwired template 
number required template 
number options known compile time page constructed big generate script element select name choice int print option value array select static html marking individual entries hidden away inside script element hard discern programming 
mechanism list instance generated templates simple recursive function html select html select name choice options select html html option html option value value option options html html int return select return options option value option array chapter 
dynamic generation xml documents select template responsible rendering context list 
gap options list entries inserted 
option template contains layout entry followed options gap subsequent entries plugged 
function may invoked arbitrary number instance generate list entries 
note html markup completely separated program logic 
fact change layout independent program code 
replace templates html select html ul options ul html html option html li option input type radio name choice value value options html program displays choices bullet list radio buttons 
separation enhanced placing html fragments individual files including compile time lexical inclusion directive include 
long designer programmer agree gaps fields html fragment may operate completely independently 
facilitate added language construction dynamic inclusion contract explicit 
template constant may followed url 
semantics html file gaps fields url inlined prototype document 
enables programmer rapidly prototype service may incrementally improved designer 
note bigwig general languages producing xml trees possible define different element tiny fragment html ul type type items ul html corresponds constructor function 
typical larger fragments convenience bigwig programmer 
higher order construction mechanism overcomes flexibility limitations earlier 
may documents constructed top bottom combination 
shall see section flexibility gained sacrificing static safety 
safety plug show operations may misused number ways 
plug operation fails document held gap html fragment plugged attribute gap 

safety case course sensible semantics evaluate copy chosen interpret program error ensures html plugged lost 
plugging html elements attribute gap create non wellformed html 
show receive statement fails field designated receive part document shown field received received program variable wrong type 
guarantees interaction correspondence shown received mentioned earlier 
regarding types values received distinguish atomic values vector values 
atomic values instance produced text input field number radio buttons name 
vector values produced instance multiple checkbox fields single select multiple field permitting number items selected 
want intercept errors compile time clearly need know names kinds gaps fields documents plugged shown 
solution declare exact types html variables program 
means gaps fields individual kinds described may voluminous 
drawback html variables required type program points 
document gradually constructed variables hold temporary documents 
reasons rely flow sensitive type inference determine exact types document expressions variables program points 
experience results liberal useful mechanism 
employ standard data flow analysis techniques highly specialized lattice structures represent document types 
document variable expression occurs program associate lattice element captures relevant gap field information abstracts away 
possible define monotone transfer functions abstractly describe effect program statements 
bigwig program construct flow graph 
straightforward higher order functions virtual methods bigwig 
language constructs involve documents abstracted away 
produces constraint system solve classical fixed point iteration technique 
solution inspect plug show operations sure errors mentioned occur 
case appropriate error messages indicating causes generated 
approach programmer restricted requirement program point template type expression fixed 
practice limit expressibility tends enforce comprehensible structure programs 
chapter 
dynamic generation xml documents hello welcome leaf greeting node node plug constituents representation 
implemented bigwig monovariant interprocedural data flow analysis 
extensive evaluation exposed recurring annoyance 
gaps plugged branch yielding errors points confluence 
consequently programmers needed explicitly plug empty string branch 
lots code dedicated decided automate process 
solved carefully placing gap absence gap presence lattice upper bound kinds confluence points yielded absence gap 
maintain consistent runtime representation solution inspection augmented instrument code inserting missing plug statements 
believe implicit plugging increases usability document construction mechanism 
important safety aspect ensure valid html documents shown clients 
task covered extensively chapter 
efficiency having devised document construction mechanism need efficient representation handle documents runtime 
representing documents naively complete parse trees cause space complexity document proportional printed size 
time complexity plug operation linear lexical sizes documents involved 
describes switchboard data structure shares template constants involved supports plug constant time 
data structure support multiple gaps name generalized compromising constant plug time bound 
efficient data structure overcomes limitation 
dynamic document runtime represented binary directed acyclic graph 
leaves html string constants plugged document nodes represent constructed document 
data structure supports operations constructing constant documents constant string plugging document plugging plug showing documents show 
constant template represented ordered sequence text 
efficiency color contents cover contents color ff greeting person brics anonymous fragment representation document shown brics example 
gap constituents 
instance greeting template welcome brics example represented displayed text entries gaps 
constant template shared documents plugged represented memory 
causes data structure dag general tree 
string plug operation combines dag constant string adding new string plug root node name gap illustrated 
analogously plug operation combines dags shown 
operations left branch document containing gap plugged right branch value plugged gap 
data structure merely records plug operations defers actual document construction subsequent show operations 
shows representation document constructed welcome brics example 
show operation linearizes document dag recursively traversing dag data structure 
constant plug show operations optimal complexities respectively lexical size document 
asymptotic complexities plug show operations old switchboard representation new considerably faster 
plugging simple document times implementation times faster new representation linearization document times faster 
note documents representation exponentially succinct expanded document 
instance case function bound assumes documents gaps 
chapter 
dynamic generation xml documents html list html ul li gap li gap ul html html tree int return html foo html return list gap tree ino time space produce document lexical size 
chapter show push show complexity sub linear time complexities exploiting browser standard caching mechanism 
related guide provides flat template mechanism mawl templates 
templates may contain named gaps fields implicitly plugged received variables name associated context 
wash cgi notion monad transformers permits higher order class document construction 
embedded gpl haskell requires intricate details underlying host language monads 
particular html construction conducted explicit invocation haskell constructor libraries look feel html library misuse signalled haskell errors 
input field handlers bound input fields permit interaction correspondence type checked 
relationship input handlers html permits modular construction new input widgets 
similar functionality conceivably achieved documents adding receive code collate input fields template externally visible input fields received 
curry library capable typing interaction correspondence logical variables tie input fields submit handler code 
xduce statically typed domain specific language xml processing 
notion order xml documents typed regular expression types correspond schemas 
values program statically typed explicit programmer annotations 
flexibility approach practically useful subtyping relation directly tree automata 
provides typed document deconstruction mechanism regular expression pattern matching 
successor bigwig language 
essentially java extended sessions dynamic documents form field validation concepts bigwig 
main differences pertaining document construction interaction correspondence analysis run summary graphs introduced chapter special gap field lattices 
gaps implicitly plugged just pluggable branches 

receive part detached show statement meaning unused input values received 
domain specific language capable dynamically generating xml documents flexible safe efficient way solves problems mentioned 
chapter 
dynamic generation xml documents chapter static validation dynamically generated xml chapter look ensure clients valid html documents sense conform official dtd html xhtml 
static html documents easy readily validated tools available 
documents dynamically generated scripts frequently employed strategy validate produced runtime 
incomplete costly process provide static guarantees behavior script 
chapter show analyse document construction mechanism statically guarantee valid html documents clients 
short approach conservatively approximate possibly infinite set xml documents may constructed show statements capture infinite set valid xml documents schema formalism decide validation inclusion sets xml documents 
summary graph analysis previous chapter employ standard data flow analysis techniques collect information documents 
time lattice consist summary graphs approximates set html documents document expression may evaluate 
structure essentially records plug operations involved construction document 
precisely set template constants set gap names set constant strings occuring program summary graph constituents 
constituent set designates possible outermost templates document 
second set contains edge template labelled written template plugged gap chapter 
static validation dynamically generated xml template wheres function gap template contains set constant strings plugged gap may contain strings values determined compile time 
example consider summary graph consisting root template node plug edges single attribute labeling large kind items ul class kind items ul items li text li items text items template nodes root nodes attribute labels drawn circles double circles boxes respectively 
node models empty template 
summary graph defines possibly infinite set xml documents denoted 
intuitively set obtained unfolding graph root performing possible enabled edges labeling function 
language summary graph depicted set ul lists class large character data items 
summary graphs turns provide ideal abstraction level verifying html validity 
possible model document string plug operations precision transfer functions 
plug transfer function takes summary graphs gap name 
second summary graph plugged adding edges relevant template gaps roots second 
ignoring internal edges summary graphs depicted disjoint plug operation illustrated follows similarly string plug transfer function models effect plugging string 
order achieve sufficient precision analysis preliminary analyses required 
tracking string constants called gap track analysis tracking origins gaps 
tells template variable gap name constant templates containing gap flow variable program point 

dtd xhtml helps cut number new edges introduced summary graph plug operation 
clearly analyses highly specialized domain dynamic document construction bigwig higher order template mechanism fit standard data flow analysis frameworks 
details refer 
dtd xhtml summary graphs show statements need verify sets documents define valid html official definition 
simplify process reformulate notion document type definition dtd simpler convenient formalism call dtd 
dtd consists number element declarations designated root 
element declaration defines requirements particular type elements 
declaration consists element name set names attributes subelements may occur boolean expression constraining element type instances respect attribute values contents 
official dtd html easily rewritten dtd notation 
fact dtd version captures validity requirements expressible standard dtds merely appear comments html dtd 
technicality xhtml xml reformulation html 
conceptual differences xml version provides cleaner tree view documents analysis 
validation summary graph dtd description html validity checked recursive traversal summary graph starting roots 
intermediate results ensure termination summary graphs may contain loops 
violations encountered summary graph valid 
validity properties local single elements contents able produce precise error messages case violations 
analysis soundness ensured property summary graphs corresponding show expressions verified valid respect dtd concrete documents guaranteed valid html 
experiments program analyses described high worst case complexities complex lattices 
implementations experiments show practice large intricate programs 
validation analysis fully implemented part bigwig system 
applied available benchmarks shown table chapter 
static validation dynamically generated xml name lines templates size shows sec chat guess calendar bachelor courses eatcs entries benchmark name lines code derived pretty print source macros expanded number templates size largest summary graph number program points show statements analysis time seconds mhz pentium iii linux pc 
analysis numerous validation errors benchmarks fixed yield services 
false errors reported 
seen table enhanced compiler remains efficient practical 
error diagnostics bigwig compiler provides detailed diagnostic messages case validation errors 
flawed example service html cover html head title welcome title head body color table contents table body html html greeting html td hello br clear clear welcome 
td html html person html stranger html session welcome html cover color ff contents greeting person clear show html brics html 
related compiler generates messages single show statement brics wig html validation brics wig warning illegal attribute body template body color form form body brics wig warning possible illegal subelement td table template table contents table contents td plugs contents brics wig brics wig warning possible element constraint violation br template br clear clear constraint value clear left right clear plugs clear brics wig error message line number xml element printed abbreviated form involved template names root elements template plugged gaps constraint violated line numbers involved plug operations 
reasonably precise error diagnostics clearly useful debugging 
related documents mawl guide restricted templates parameterizable character data may 
shows achieve validity encoding dtd instance classes extension haskell type system 
author reports encodings restrictive practically useful generating parameterized documents validity requirements attributes relaxed 
addition documents having composed style validation errors reported haskell instance class type errors may hard decode 
previously mentioned xduce values statically typed regular expression types essentially equivalent dtd form xduce incapable coping attributes 
preliminary attempts integrate attributes unclear proceed 
apart attributes xduce achieves validation relies explicit programmer annotations 
extended validation dtd powerful schema language dsd 
combined data flow analysis generalized validation algorithm enable bigwig compiler guarantee html xhtml docu chapter 
static validation dynamically generated xml ments shown client valid official dtd 
analysis efficient generate spurious error messages practice 
furthermore provides precise error diagnostics case program fails verify 
algorithm parameterized dtd technique generalizes straightforward manner arbitrary xml languages described dtds 
fact handle expressive grammatical formalisms 
analysis proved feasible programs realistic sizes 
lends support unique design dynamic documents bigwig language 
chapter caching dynamically generated xml caching documents client side important technique saving bandwidth time clock cycles 
protocol provides support associating expiration time documents sent server client 
document rarely changes may associated appropriate expiration time browsers proxy servers may avoid reloading time 
mechanism clearly applicable dynamically generated documents change request 
documents expiration set benefits caching 
caching dynamically generated documents web services construct html documents sort constant parts ideally ought cached observed 
show condensed view typical html pages generated different web services document construction mechanism described chapter 
column depicts dynamically generated raw html text output produced interaction benchmark web services 
non space character colored grey black 
grey sections characters originate large number small constant html templates source code black sections dynamically computed strings character data specific particular interaction 
templates appear constitute significant part generated documents 
experiments shown templates tend occur documents shown client lifetime service occur times document different documents simply documents shown times 
templates account large part potentially gain cached client 
show exploit document generation mechanism 
chapter 
caching dynamically generated xml lycos bachelor benchmark services grey vs dynamic black parts 
solution representation described section useful property explicitly maintains separation constant templates occurring document strings plugged document structure describing assemble document 
constituents depicted framed rectangles oval rectangles circles respectively 
templates inherently static 
strings structure document typically customized individual interaction change document 
solution move unfolding data structure server client 
transmitting unfolded html document server transmit compact representation dynamic parts data structure generic javascript code capable reconstructing document client 
templates document transmitted placed javascript file server merely referenced javascript include directive file transmitted 
way javascript template file cached browser just file 
fact generic javascript unfolding code placed file cached 
consequently dynamic string structure constituents transmitted browser standard caching mechanism ensure templates seen reloaded 
templates statically known compile time compiler enumerate templates generate file appropriate javascript code 
template filenames version numbers caching enabled recompilations certain templates 
evaluation kb lycos sec lycos original static dynamic dynamic bachelor bachelor download rendering isdn experiments template representation 
modified 
chosen java javascript javascript lightweight sufficient purposes 
alternatively similar effects obtained browser plug ins proxies implementation installation difficult 
approach adapted languages asp php jsp text markup structured template essentially cut strings gaps 
pieces smaller unstructured yielding bigger overhead opportunities reuse 
evaluation effect applying caching technique web service benchmarks mentioned earlier 
show sizes data transmitted client 
grey columns show original document sizes ranging kb 
white columns show sizes total data transmitted technique exceeds kb 
ultimate interest black column shows asymptotic sizes transmitted data reached templates cached client 
case see reductions factors compared original document size 
employing technique amount data downloaded indicated white black columns depending templates cached 
case technique substantially reduces number bytes transmitted server client 
chapter 
caching dynamically generated xml protocol introduces automatic compression generalpurpose algorithms gzip 
course adding compression drastically reduces benefits caching technique 
see asymptotic reduction factors suggesting approach remains worthwhile circumstances 
clearly documents asymptotic reduction factors arbitrarily large large constant text fragments count zero side scales gzip compress certain size 
compression essentially orthogonal approach 
cutting network traffic course seize client clock cycles unfolding 
context fast client machines comparatively slow networks sensible tradeoff 
quantify latency technique 
total download rendering times services shown standard documents cached versions 
client internet explorer running mhz pentium iii windows pc connected server isdn modem 
realistic configurations august vast majority internet subscribers dial connections situation change significantly couple years 
times averaged downloads plus renderings browser caching disabled 
download rendering times reduce factors 
benchmark presents lots dynamically generated data benefits setup 
higher bandwidth dimensions results course impressive 
related caching dynamic contents received increasing attention years evident traditional caching techniques insufficient 
existing techniques labeled dynamic document caching instance 
primary goal server caching techniques lower network load latency aim relieve server generated documents order avoid redundant computations 
techniques orthogonal propose 
techniques proxy require installation special proxy servers 
technique hpp language client require intrusive modifications existing protocols 
hpp language closely related approach 
observation dynamically constructed documents usually contain common constant fragments 
hpp html extension allows explicit separation static dynamic parts dynamically generated document 
static parts document collected template file dynamic parameters separate binding file 
template file contain simple instructions akin embedded scripting languages asp php jsp specifying assemble complete document 

assembly caching templates done cache proxies browser java applets plug ins possible javascript 
essential difference hpp approach hpp solution integrated programming language web service 
possible combine hpp popular embedded scripting languages effort explicitly programming document construction remains 
approach source language meaning caching specifications automatically extracted web service source code compiler programmer required aware caching aspects 
regarding hpp advantage instructions describing structure resulting document located template file cached solution equivalent information dynamic file 
hpp constant fragments constituting document collected single template 
means html fragments common different document templates reused cache 
solution fine grained caches individual fragments separately 
hpp templates highly specialized difficult modify reuse programmer 
fully automatic approach guarantees cache soundness 
analogously optimizing compilers claim bigwig compiler generates caching code competitive human hpp programmer achieve 
claim substantiated lycos benchmark equivalent hpp reconstruction course bigwig 
seen size residual dynamic data bytes virtually identical obtained hpp bytes 
solution caching aspects hand coded benefit human insight automatically generated bigwig compiler 
benchmarks construct complicated documents challenging hpp 
approach programmer need aware caching issues decomposition pages dynamic parts performed automatically compiler 
resulting caching policy guaranteed sound experiments show results significantly smaller transmissions reduced latency 
technique non intrusive requires extensions existing protocols clients servers proxies 
result obtain simple practically useful technique saving network bandwidth cache mechanism modern web browsers context dynamically generated web pages 
chapter 
caching dynamically generated xml chapter form field validation considerable effort web programming expended making sure data supplied client form input field right format 
field instance expect valid number date email address entered certain way 
achieved server side input validation 
page containing input fields submitted program server determines entered data required form 
case program outputs page containing appropriate error messages erroneous input fields allowing client correct 
process repeated input fields contain valid data 
widely approach considerable drawbacks takes time causes excess network traffic requires explicit programming 
note drawbacks affect parties involved 
client clearly annoyed extra time incurred round trip server validation server extra network traffic wasted cycles programmer having explicitly wrap showing documents loops retransmit documents appropriate error messages input validates 
adding extra control structures clutter main logic service validation code 
drawbacks solved moving validation server client yielding client side input validation 
actual validation undertaken client side scripting language typically javascript 
move server side client side opens important benefit possibility performing validation incrementally 
client longer needs click submit button getting validation report 
allows errors signalled occur clearly eases task correctly filling form 
browser features chapter 
form field validation available scripting language may help provide sophisticated interactions client pop error help messages coloring erroneous input fields 
writing javascript input validators time capture validity requirements signal errors appropriately tedious error prone task complicated diverging browser implementations 
fact web sites dedicated explaining javascript implementations differ browsers exist context gpl javascript may unsupported disabled client server perform second validation 
code essentially written client server scripting languages may different nature 
powerforms address issues designed language powerforms targeted uniquely domain input validation 
allow service programmer define formats attach textual input fields 
submission form input server prohibited data entered input fields comply attached formats 
clients allowed continue session input fields contain appropriate data 
formats specified standard regular expressions enhanced intersection complement integer intervals convenience 
motivations choosing regular expressions specification formalisms context free grammars turing complete languages 
regular expressions simple known widely text pattern matching purposes instance perl 
regular expressions inherently declarative away operational details making validation easier read write modify 
comparatively operational formalisms javascript force programmers deal details fields contents validated order 
programming operational sense required input validation available wider audience 
efficiently decided string language defined regular expression deterministic finite automata dfas 
experience regular expressions sufficiently expressive capture common validation requirements validating dates email addresses zip codes 
requiring expressiveness regularity deferred server side rarely needed 
see www com articles javascript limitations html www xs nl js version html 
developer netscape com docs examples javascript overview html 
powerforms document shown regular expressions compiled minimized dfas html instrumented javascript code incrementally run automata data entered associated input fields 
automata server side double check submitted data reception 
compilation generates code subset javascript known common browser implementations 
regarding efficiency automata remembered avoid trivial recompilation placed individual javascript files may cached browser 
bigwig compiler statically compile regular expressions available compile time dynamically generated regular expressions subjected dynamic compilation 
provide continuous feedback client state validation visualize states automata images displayed textual input fields 
images dynamically changed reflect state automaton 
default compiler uses traffic light icons displaying red yellow green light corresponding automaton crash reject accept state run input 
red means prefix valid input yellow strict prefix valid input green valid input 
input fields may instructed icons means visualization auto complete possible suffix yielding valid input 
example definition formats syntactically disjoint form 
allows modular development validation added input field existing html form knowing name 
consider instance html document input field address expecting valid email address html 
email input type text name address size 
html email addresses easily captured regular expression 
valid emails instance defined follows assuming word appropriately defined regexp id email regexp idref word const value plus regexp idref word const value plus repeat low high range low high repeat regexp alternatively compact perl style syntax regexp id email exp word word chapter 
form field validation checking email addresses 
conference questionnaire 
email defined concatenation word character words followed dot alphanumeric characters 
format independently added html page definition format field address help enter email address error illegal email regexp idref email format field attribute refers input field regular expression bound 
input field focus help string appears status line browser 
client attempts submit form invalid data field error text appears alert box 
initially field yellow light 
status persists seen enter text brabrand brics legal prefix email address 
entering yields red light 
deleting character entering give legal value green light 
field interdependency forms contain fields values constrained selections text entered fields 
exhibits simple questionnaire conference participants invited state attended past conferences compared 
second question clearly depends may answered answer positive 
conversely answer second question may required answer 
interdependencies handled server rest validation addressed client side 
reason presumably interdependencies require delicate javascript code 

field interdependency collecting customer information 
address issues extensions 
firstly permit formats associated kinds input fields just textual ones 
individual checkbox radio buttons automatically depressed checked values language regular expression 
select fields illegal options automatically filtered menu 
secondly formats extended describe boolean decision trees conditions probe values fields leaves simple regular expression formats 
addition conjunction disjunction negation basic predicates equal match exist specifying boolean expressions 
match predicate takes field name regular expression decides value designated input field language regular expression 
equal predicate shorthand comparing value constant string 
example consider form displayed customers select country write phone number check want visit new york city office 
option available customers living new york city constrained format format field visit equal name country value match name phone regexp exp match regexp exp regexp exp format acceptable values visit field option selected country field phone text field contains new york city area code prefix 
value accepted 
evaluation format may produce side effects selections may order formats evaluated clearly matters 
chosen process formats sequence appear document typically coincides order client supposed consider 
formats processed repeatedly fixed point reached 
buttons released iteration guaranteed chapter 
form field validation terminate 
experience practise evaluation order matter fixed point reached iterations 
related provides direct support server side validation 
validation produces error report involving internal names input fields unknown client 
required corrections remembered erroneous form 
xhtml fml language provides client side input validation adding attribute textual input fields 
attribute restricted collection predefined input validation types support field 
validation compiled javascript solution non intrusive require installation special software client 
extensible form description language elaborate language deals lifecycle form including workflow 
provides simple rigid mechanism defining new formats flexible permit definition valid emails new york city example 
proposal separates data presentation forms 
form data represented returned server xml 
validation xml data xml schema interdependency achieved xpath referencing parts data form 
capable handling dependency new york city example involving operational programming 
main problem complete implementation exists requires processor client 
really useful feature fields may hidden visualized incrementally required 
similar approach translates language client side validation javascript server side revalidation code 
validation performed incrementally client specification requires explicit programming general purpose functional language 
powerforms provides incremental interdependent validation declarative way require programming skills 
furthermore modular sense validation added input field existing html form knowing name 
validation markup completely separate form markup allows layout form redesigned time html editor 
powerforms fully implemented part bigwig language available stand tool available www com available www brics dk bigwig powerforms 
java implementation available www brics dk powerforms 
chapter concurrency control services session threads need synchronization concurrency control discipline concurrent behavior active threads 
simple case control access shared variables mutex regions readers writers protocol 
issue enforcement priorities different session kinds management session may block sessions running 
example event handling session thread may wait certain events caused threads 
deal scenarios uniform manner central controller process runtime system general enforce wide range safety properties 
support concurrency control previously mentioned web languages limited traditional solutions file locking monitor regions synchronized methods 
solution bigwig service associated set event labels 
execution session thread may request permission controller pass specific event checkpoint 
permission granted session thread suspended 
policy controller programmed maintain appropriate global invariants entire service 
clearly calls domain specific sub language 
chosen succinct known general formalism temporal logic 
particular variation monadic second order logic 
formula describes set strings event labels associated semantics trace event labels passed threads belong set 
guide controller bigwig compiler uses mona tool translate formula minimal deterministic finite state automaton controller process permissions individual threads 
thread asks pass event label placed corresponding queue 
controller continually looks non empty queues event labels correspond enabled transitions current dfa state 
match corresponding transition chapter 
concurrency control performed chosen thread resumed 
course controller implemented satisfy fairness requirements 
regular trace languages 
applying temporal logics approach harsh average programmer 
syntax macros described chapter possible capture common concurrency primitives semaphores mutex regions readers writers protocol monitors provide high level language constructs hiding actual formulas 
advantage bigwig extended constructs highly customized particular applications maintaining simple core language concurrency control 
example illustrates simple service implements critical region event labels enter leave service shared int session critical constraint label leave enter enter enter leave wait enter wait leave formula states enter events leave event implies time thread allowed critical region 
syntax macros programmers allowed build higher level abstractions written service shared int session critical region omit macro definitions 
full generality wait statement switch statement allows thread simultaneously attempt pass event labels request timeout waiting specified time 
different example implements asynchronous event handler 
macros programmed service shared int constraint 
label handle cause handle cause handle session handler true wait handle session application wait cause non trivial formula allows handler proceed blocking application associated event caused invocation handler 
fortunately macros permit highlevel abstractions introduced palatable syntax service shared int event increment session application cause increment dubbed concurrency language abbreviation synthesizing controller logic 
runtime model centralized controller process ensuring satisfaction safety constraints described detail 
centralized process hardly qualifies efficient approach 
pointed possible analyse constraints distribute safety controller 
context relatively fast machines comparatively slow networks network bottleneck 
monadic second order logic controller synthesis introduced additionally notions triggers counters introduced gain expressive power regular sets traces conditions distributing controller better performance defined 
session model provides opportunity get global view concurrent behavior service 
current approach exploit knowledge control flow 
plan investigate specialized program analyses check liveness concurrency requirements complied 
chapter 
concurrency control chapter metamorphic syntax macros previously mentioned bigwig contains notion macros 
specific web services abstraction mechanism essential part bigwig serves keep sub languages minimal tie 
compiler syntax macros accepts collections grammatical rules extend syntax subsequent program may written 
long advocated means extending programming languages 
interest domain specific customizable languages poses challenge macros realize new language concepts constructs grow entire new languages 
existing macro languages unsafe expressive live challenge syntax allowed macro invocations restrictive 
macro languages resort compile time meta programming making difficult safely 
chapter propose new macro language sufficiently expressive entirely simple declarative concepts grammars substitutions 
contributions macro language design guaranteed type safety termination macro expansion process concept allow user defined grammar invocation syntax mechanism operating simultaneously multiple parse trees full efficient implementation syntactically rich host language survey related identifying classifying relevant properties carried context bigwig project find uses host languages top parser constructed 
application approach knowledge host chapter 
metamorphic syntax macros grammer required 
special properties grammar 
fact possible build generator host grammar automatically provide parser supports notion syntax macros 
related closely investigated macro languages individual semantic characteristics preprocessor cpp unix macro preprocessor tex built macro mechanism macro mechanism dylan templates scheme hygienic macros macro mechanism jakarta tool suite jts meta syntactic macro system ms 
system version dylan macros adapted java treated independently 
survey led identify group properties characterize macro language think relevant comparing 
details survey 
macro language shares features previous extensible syntax macro language 
framework defining new syntax represented parse tree data structures target language type checking code generation performed 
contrast new syntax directly translated parse trees host language 
host language syntax available equal footing new syntax 
expressiveness extensible syntax permitted close argument syntax allow technical differences including definition selection parsing ambiguities expansion strategy error trailing 
allow general translation scheme 
paramount characteristic macro language operates lexical syntactical level 
lexical macro languages allow tokens substituted arbitrary sequences characters tokens 
definitions may parameterized substitution sequence contains placeholders actual parameters just arbitrary character sequences 
cpp known lexical macro languages 
conceptually lexical macro processing precedes parsing ignorant syntax underlying host language 
fact cpp language independent preprocessors concept host language 
direct consequence syntactic independence lexical macro languages share dangers avoided clever hacks workarounds folklore 
representative example square macro define square works expected cases 
invoked argument result character sequence interpreted 
solution particular problem explicitly add parentheses arguments control subsequent parsing 
solution original macro program definition repeats expanded program repeats repeats syntax macros operators parse trees 
white parts written service programmer gray parts macro programmer 
define square programmers required consider individual macro invocations expanded parsed 
syntactic macros amend operate parse trees token sequences 
types added macro arguments bodies form nonterminals host language grammar 
macro definitions syntax checked definition time guaranteeing parse errors longer occur consequence macro expansion 
syntax macros syntax programming language simply appears extended new productions 
contrast syntactical languages operate parse trees depicted course requires knowledge host language grammar 
case nonterminals standardized version bigwig grammar available extension 
solution macros syntactic entirely simple declarative concepts grammars substitution making easy safe ordinary web service programmers 
macro languages ms scheme macros maya apply full turing complete programming languages manipulating parse trees compile time making difficult 
example extend core language bigwig repeat control structure easily defined terms loop 
macro shown 
macro stm repeat stm exp bool true false chapter 
metamorphic syntax macros line header macro definition 
specifies nonterminal type macro abstraction invocation syntax including typed arguments 
expected type repeat macro stm representing statements 
causes body macro parsed statement announces invocations allowed places ordinary statement 
allow programmer design invocation syntax macro 
guide parsing adds transparency macro abstractions 
particular macro designed parse appropriately delimited arguments statement expression body macro implements abstraction boolean variable loop 
macro invoked identifiers occurring body converted avoid name clashes invocation context 
macro definitions specify important aspects syntax definitions characterizing syntactic structure invocations syntax transformations specifying new syntax morphed host language syntax 
show move macro fixed number arguments described host grammar nonterminal declarative way compromising syntactic safety 
initially focus syntax definition aspects 
solution illustrate languages approach enum abstraction known running example 
step greater syntactic definition flexibility permit definition macros name different invocation syntax arguments 
notion specificity selects definition closely matches invocation 
relying notion specificity advantage independent order macros defined 
permits define enum abstraction take identifier arguments macro decls enum id const int macro decls enum id id const int const int macro decls enum id id id const int const int const int evidently possible define macros arbitrary arity specifications exhibit high degree redundancy 
terms syntax definition 
enum definitions correspond adding unrelated right hand side productions nonterminal decls decls enum id enum id id enum id id id scheme introducing special ellipsis construction specify lists nonterminal expressions 
ms moves step permitting tuples optional arguments corresponding allowing regular expressions terminals nonterminals host grammar right hand sides productions 
ubiquitous ebnf syntax available designating options lists tuples grouping 
addition ms provides convenient variation kleene star specifying token separated lists nonterminals 
notation comma separated repetitions nonterminal enum macro defined construction corresponds extending grammar follows decls enum id dylan language taken full step allowing programmer describe macro invocation syntactic structure user defined grammar permitting new user defined nonterminals 
context free language approach clearly general regular language approach handle balanced tree structures 
enum invocation syntax described grammar fragment introduces user defined nonterminal called enums underlined readability decls enum id enums enums id enums dylan result parsing user defined nonterminal yields result substituted macro body 
result unparsed chunk tokens associated lexical macro language pitfalls 
want combine great definition flexibility type safety 
need way specifying checking type result parsing user defined nonterminal 
clearly nonterminals exist equal footing host language syntax macro ultimately produce host syntax return user defined asts 
associate user defined nonterminal host nonterminal result type resulting parse tree derived 
syntax defined user defined nonterminals morphed directly host syntax 
specification morphing inductively production grammar 
contrast ms relies programming computation specifying transforming regular expressions nonterminals parse trees 
chapter 
metamorphic syntax macros distinguish clearly host grammar call user defined nonterminal productions typed host nonterminals 
rule specifying macro syntax morphed host language syntax 
parameter may form na meaning named invocation syntax described metamorph nonterminal result type metamorph syntax inductive translation host language described metamorph rules 
left token result type name metamorph nonterminal right parameter list defining invocation syntax body defining translation host language 
metamorph rules may define arbitrary grammar 
full generality metamorph rule may take parse trees arguments produce multiple results defined separate body 
ready define general enum macro macro language 
production rules translates definitions macro decls enum id enums decls ds int const int ds metamorph decls enums id enums decls ds const int ds metamorph decls enums rule defines macro enum metamorph argument enums decls ds describing piece invocation syntax generated nonterminal enums metamorph grammar 
enums parse trees materialized instantly morphed parse trees nonterminal decls host grammar 
body enum macro commences declaration variable enumerating declared variables runtime 
declaration followed morphing identifier constant integer declaration initialization expression 
comes ds decls result remaining identifiers constant integer declarations 
productions enum grammar translates metamorph definitions 
take comma identifier followed metamorph argument morph identifier constant integer declaration return matched metamorph invocation 
second metamorph definition offers termination condition parsing returning empty declarations 
simplicity constant integer declarations bodies rules identical 
alleviated placing constant declaration body macro introducing returning declaration place identifiers 

growing language concepts macro formula allow id formula restrict macro formula forbid id formula allow macro formula mutex id id forbid macro toplevel region id constraint label mutex macro stm exclusive id stm wait wait macro resource id region constraint 
macro stm reader id stm wait wait macro stm writer id stm wait exclusive macro protected type id resource concurrency control abstractions 
metamorph nonterminals checked definition time intercept top specificity parsing terminates 
verified possible invocations exist uniquely specific match definition selection remains unambiguous 
growing language concepts macro language allows host language grow simply handy abbreviations new concepts constructs 
chapter 
metamorphic syntax macros 



reader protected resource region mutex forbid allow bigwig core language writer exclusive stack macro abstractions 
shows stack increasingly high level concepts introduced top possibility define macros nonterminals host language 
allow forbid mutex macros abbreviate common constructs temporal logic chapter produce results type formula 
macro region type toplevel different introduces new concept regions declared equal footing native concepts 
exclusive macro type stm defines new control structure secures exclusive access previously declared region 
resource macro type toplevel list declares instance novel concept macros reader writer realizes reader writer protocol specified resources 
protected macro seemingly provides modifier allows declared variable subject protocol 
macros build top produce levels abstraction depicted 
example program high level abstractions service protected shared int counter html doc html visitor number number html session access html reader counter doc number counter writer counter counter show program web service shows page ubiquitous page counter declared protected macro 
client issues request run session access value counter read inside 
integration reader region document showing value assembled 
subsequently counter incremented writer region 
document transmitted client 
similar development implemented primitives semaphores monitors fifo pipes 
demonstrates host language highly tailorable simple means 
bigwig language employs extensive collection predefined macros enrich core language 
bundled packages extending various sub languages bigwig different ways helping keep bigwig language minimal 
instance form field validation language extended optional regular expression construct database language macros transform sql queries iterative construction called factor 
integration macros tie different sub languages making collaborate provide tailor extensions language 
instance sub languages dealing sessions dynamic documents concurrency control combined publish macro 
macro useful service wishes publish page static needs recomputed underlying data changes 
macros efficiently implements abstraction macro publish id exp shared html cache shared bool cached session exclusive cached cache cached true show cache macro stm touch id cached false publish macro recomputes document cache expired shows document touch macro causes cache expire 
operator create new identifiers concatenation 
extended syntax service maintaining example high score list look require publish service shared int record shared string holder publish record holder chapter 
metamorphic syntax macros session play int score play score record show receive holder name record score touch show html sorry record html high score document regenerated player beats record 
code clearly easier understand maintain corresponding expanded code 
domain specific languages university aarhus undergraduate computer science students complete bachelor degree fields 
requirements satisfied surprisingly complicated 
guide students goal maintain called bachelor contract plans remaining studies discovers potential problems 
process supported web service student iteratively accepts past course activities checks requirements diagnoses violations legal contract composed 
service written straight bigwig application quickly annoying maintain due constant changes curriculum 
redesigned form study fields requirements conceptualized defined directly natural language style 
possible non programmers maintain update service 
small example input require bachelor studies course math title mathematics points fall term course phys title physics points spring term course lab title lab point fall term exclusions math math prerequisites math math math math math math cs cs cs cs math cs cs math stat 
domain specific languages cs cs cs cs cs cs phys phys phys phys phys phys phys phys phys lab lab lab lab lab lab lab lab lab lab lab lab lab field cs mathematics field courses math math math math stat cs cs cs cs cs cs cs cs cs cs project courses math math phys phys phys phys constraints passed cs cs courses cs cs cs math math courses stat math math points project cs cs total points syntax displayed plain bigwig macro package require instruction 
entire program argument single macro studies expands complete code corresponding web service 
file bachelor lines defines complete implementation new language 
bigwig macro mechanism offers rapid inexpensive realization new ad hoc languages syntax desired 
chapter 
metamorphic syntax macros chapter flexibility safety efficiency section conclude investigating thesis domain specific languages provide flexible safe solutions interactive web services 
investigating claim sub languages designed aspects mentioned chapter 
show domain specific languages contribute design bigwig language developing interactive web services 
sessions session model runtime system provide service session abstractions explicitly reflected structuring bigwig services 
offers show receive abstraction state preserving client interaction flash language feature addressing client impatience 
flexibility runtime system automatically preserves state client interactions programmers able show documents time deeply mutually recursively nested function calls 
show abstraction programmers manually encode save call stack termination decode restore continuation 
flash feature runtime system reply indirection enables asynchronous feedback clients state execution 
reply indirection gives clients freedom bookmark running session continue 
features hard achieve manually 
form field values submitted automatically decoded reception handed bigwig service 
means programmers exposed cgi encoded data 
safety automatically preserving state show statements server local state exposed clients error prone task having encode save decode restore local state avoided altogether 
chapter 
problems concerning backtracking displaying old interactions avoided session model runtime system 
addition random interaction key protects pages old interactions submitted 
efficiency simplicity single interaction paradigm permits optimization tricks possible session paradigm 
complex services implementation runtime system alleviates server resources having preserve local state start new processes interaction 
dynamic documents sub language provides html xml documents data type equal footing host language types 
plug show operations available document construction client interaction 
flexibility notion class higher order templates gaps enables documents constructed order outside inside combination 
explicit separation programming html enables programmers designers operate independently 
furthermore documents written standard html xml syntax designers may write templates html xml authoring tools microsoft 
safety domain specific static analyses provide strong compile time safety guarantees interaction correspondence validation available languages 
efficiency datastructure provides efficient runtime representation documents 
furthermore enables static parts cached clients saves bandwidth server resources performing document unfolding client 
form field validation powerforms powerforms sub language provides concept regular expressions form field validation 
introduces simple conditional branching regular expressions specifying field interdependencies 
flexibility declarative formalism regular expressions validation easy read write modify 
inherently non operational focuses opposed available wider audience non programmers 
clients benefit approach automatically getting validation incrementally visual feedback 

concurrency control safety problems pertaining diverging incomplete javascript implementations different browsers completely eliminated 
compiler generates code uses simple subset javascript known correctly common browser implementations 
powerforms compiler automatically generates server side validation identical performed client side 
additionally server side revalidation augmented double check forms tampered instance attribute text fields bypassed options submitted selection widgets available 
efficiency javascript implementation works interpreting minimized deterministic finite automata highly efficient 
possibly sped inlining automaton javascript control flow 
performing validation incrementally client saves time bandwidth cycles 
concurrency control concurrency sub language integrated bigwig language wait statement label declarations monadic second order logic 
flexibility approach presents programmers uniform way dealing concurrency control aspects separating service code safety logic 
means safety logic may added independently constrain behaviour service changes service code 
regular expressions monadic second order logic declarative formalism focuses opposed rendering safety requirements easier maintain 
logic succinct formula may non elementarily smaller operational counterpart minimized deterministic finite automaton 
safety safety controller queues token ring strategy ensure session threads waiting enabled checkpoints blocked indefinitely 
efficiency centralized process hardly qualifies efficient approach 
pointed possible analyse constraints distribute safety controller 
context relatively fast machines comparatively slow networks network bottleneck 
chapter 
metamorphic syntax macros syntax macros bigwig really classified dsl serve extend language glue sub languages 
may create new domain specific languages 
syntax macros provide uniform abstraction mechanism language extension works alike syntactic categories host language 
entirely declarative concepts pattern matching substitution 
provide flexible invocation syntax grammars inductive type safe transformation host language syntax 
macros geared extensibility providing notion specificity resolves grammar ambiguities locally way disregards order macros defined 
macros syntactically safe checked definition time guarantee termination syntax errors occur result macro expansion 
automatic alpha conversion avoids identifier name clashes 
metamorphic grammars checked ensure specificity resolution unique final winner possible invocations exist macros defined 
domain specific languages interactive web services domain specific languages applied domain interactive web services achieve flexible safe efficient solutions sessions documents forms concurrency 
sub languages may integrated host language conveniently tied metamorphic syntax macros 
result domain specific language bigwig provides support virtually aspects development interactive web services 
part ii publications chapter bigwig project anders ller michael schwartzbach results bigwig project aims design implement high level domain specific language programming interactive web services 
fundamental aspect development world wide web decade gradual change static dynamic generation web pages 
generating web pages dynamically dialogue client advantage providing date tailor information 
development systems constructing dynamic web services emerged new research area 
bigwig language designed analyzing application domain identifying fundamental aspects web services inspired problems solutions existing web service development languages 
core design consists session centered service model flexible template mechanism dynamic web page construction 
specialized program analyses certain web specific properties verified compile time instance valid html shown clients 
addition design provides high level solutions form field validation caching dynamic pages temporal logic concurrency control proposes syntax macros making highly domain specific languages 
language implemented widely available web technologies apache server side javascript java applets client side 
conclude experience evaluation project 
bigwig project founded brics research center university aarhus design implement high level domain specific language programming interactive web services 
argue existing web service programming languages various ways provide low level solutions problems specific domain web services 
chapter 
bigwig project ambitions project identify key areas web service domain analyze problems existing approaches provide highlevel solutions support development complex services 
motivation specifically look web service technologies cgi web protocol sun java servlets pages jsp microsoft active server pages asp related open source language php research language mawl 
cgi platform development web services 
simple idea letting script generate reply incoming requests dynamically server returning static html page file 
typically script written general purpose scripting language perl language supported server 
general purpose programming languages special support web specific tasks generation html pages knowledge low level details protocol required 
cgi stateless protocol provides help tracking guiding users series individual interactions 
degree alleviated libraries 
case compile time guarantees correct runtime behavior comes web specific properties instance ensuring invalid html sent clients 
servlets popular higher level java specific approach 
servlets special java programs offers common java advantages network support strong security guarantees concurrency control 
significant problems exist 
services programmed servlets consist collections request handlers individual interactions 
sessions consisting interactions client carefully encoded cookies url rewriting hidden input fields tedious error prone library support hard maintain overview large services complex interaction flows 
second smaller problem state shared multiple client sessions simple services explicitly stored name value map called servlet context java standard variable declaration scoping mechanism 
thirdly dynamic construction web pages improved compared cgi 
web pages built printing string fragments output stream 
guarantee result valid html 
situation slightly improved html constructor libraries preclude possibility dividing programmers html designers 
furthermore client sessions split individual interactions combined implicitly instance storing session ids cookies possible statically analyze page sent client contains exactly input fields servlet session expects 
jsp asp php countless variants designed different starting point 
aiming complex services parts pages dynamically generated fit niche pages 
static contents little fragments dynamically generated 
service written languages typically consists collection server pages html pages program code embedded special tags 
page requested client code evaluated replaced resulting string 
gives better control html construction gives advantage simple services page static 
mawl language designed especially domain interactive web services 
innovation mawl client sessions explicit program logic 
idea building html pages templates 
mawl service contains number sessions shared data html templates 
sessions serve entry points client initiated session threads 
producing single html page terminating cgi scripts servlets session thread may involve multiple client interactions maintaining data local thread 
html template mawl html document containing named gaps text strings special lists may inserted 
client interaction performed inserting appropriate data gaps html template sending client fills form fields submits reply back server 
notions sessions document templates inherent language compilation allows important properties verified statically running service 
html documents constructed templates html validity verified statically 
clear service code execution resumes client submits form input statically checked input fields match program expects 
practical limitation mawl approach html template mechanism quite restrictive insert markup template gaps 
describe details existing languages sections 
studying services written language common problems show 
surprisingly large portions service code tend deal form input validation 
client server interaction takes place mainly input forms usually fields filled certain kind data depending entered fields 
invalid data submitted appropriate error message returned client try 
handled client side typically javascript server code combination 
case tedious encode 
secondly drawback dynamically generated web pages compared static ones traditional caching techniques 
browser caches proxy servers cause major improvements saving network bandwidth load time clock cycles moving interactive web services benefits disappear 
thirdly web services act interfaces underlying databases instance contain information customers products orders 
accessing databases general purpose programming languages database queries integrated requires queries built text strings sent chapter 
bigwig project database engine 
means static type checking queries 
known modern programming languages type systems allow programming bugs caught compile time run time improve reliability reduce development cost 
fourthly running web services contain concurrently executing threads access shared information instance databases server fundamental need concurrency control 
threads may require exclusive access critical regions blocked certain events occur required satisfy high level behavioral constraints 
service run smoothly deadlocks abrupt obstacles 
existing solutions typically provide little support instance low level semaphores perl synchronized methods servlets 
difficult guarantee correct concurrent execution entire services 
web services usually operate internet secure local networks important protect sensitive information hostile attacks programming leaks 
big step forward secure sockets layer ssl protocol combined authentication 
techniques ensure communication authenticity confidentiality properly requires insight technical protocol implementation details 
furthermore protect programming bugs unintentionally leak secret information 
taint mode perl offers solution 
run time compile time guarantees 
checks certain predefined properties specialized properties added 
bigwig language motivated languages problems described identified areas key aspects web service development sessions underlying paradigm interactive web services dynamic documents html pages constructed flexible efficient safe fashion concurrency control web services consist collections processes running concurrently sharing resources form field validation validating user input requires attention web programmers higher level solution desirable database integration core web service database number sessions providing web access security ensure authenticity confidentiality regarding malicious clients programming bugs 
attack problems scratch designed new language called bigwig descendant mawl language 
language highlevel domain specific language meaning employs special syntax 
constructs tailored fit particular application domain allow specialized program analyses contrast library solutions 
core java skeleton surrounded domain specific sub languages covering key aspects 
notion syntax macros tie sub languages provide additional layers abstraction 
macro language operates parse tree level token sequence level conventional macro languages proved successful providing extensions core language 
helped sub languages remain minimal desired syntactic sugar macros 
syntax macros taken extreme little effort define completely new syntax domain specific languages tailored highly specialized application domains 
important bigwig compilation interpretation scripting language 
approaches apply type systems static analysis catch classes errors service installed 
bigwig compiler uses common web technologies target languages 
includes html javascript java applets 
current implementation additionally relies apache web server 
important apply standard technologies client side order place restrictions clients 
particular browser plug ins subset javascript works common browsers 
new technologies standard compiler merely obtain corresponding opportunities generating better code 
degree possible attempt hide low level technical details underlying technologies 
effort contribute graphical design web services 
provide clean separation physical layout html pages logical structure service semantics 
expect standard html authoring tools conceivably web programmer 
focus efficiency providing higher levels abstraction developers 
regard important generate solutions seamlessly scale thousands interactions second scalability course issue design 
main contributions bigwig project results notion client sessions explicit web service programming languages dynamic construction web pages time flexible fast permitting powerful compile time analyses form field validation easier domain specific language regular expressions boolean logic temporal logic useful formalisms expressing concurrency constraints synthesizing safety controllers syntax macros create domain specific high level languages extremely narrow application domains 
chapter 
bigwig project focus key contributions remainder describe central contributions technique performing clientside caching dynamically generated pages built relational database simple security mechanisms 
individual results published previous specialized papers 
results show need high level programming languages tailor domain web service development 
overview section classifying existing web service languages script page session centered arguing best choice complex services 
section show html template mechanism mawl extended flexible notion higher order templates 
novel type systems static analyses safety benefits mawl templates remain spite increased expressibility 
show solution cache considerable parts dynamically generated pages browser 
section address problem validating form input easily 
section describes technique generating concurrency controllers temporal logic specifications 
section gives syntax macro mechanism ties sub languages bigwig 
section mention various central bigwig language 
section describe implementation number applications evaluate various practical aspects bigwig 
session centered web services web programming covers wide spectrum activities composing static html documents implementing autonomous agents roam web 
focus interactive web services web servers clients initiate sessions involve exchanges information mediated html forms 
definition includes large classes known services news services search engines software repositories bulletin boards covers services complex specialized behavior 
variety techniques implementing interactive web services 
divided main paradigms script centered session centered 
supported various tools suggests particular set concepts inherent web services 
script centered approach script centered approach builds directly top plain stateless ht tp cgi protocol 
web service defined collection loosely related scripts 
script executed request client receiving form data input producing html output terminating 
individual requests 
session centered web services tied explicitly inserting appropriate links scripts reply pages 
prototypical scripting language perl programming language suggested role 
cgi scripting supported large collection library functions decoding form data validating input accessing databases realizing semaphores 
libraries targeted domain web services language 
major problem behavior distributed numerous individual scripts depends implicit manner pass control 
design complicates maintenance precludes sort automated global analysis leaving errors detected running service 
html documents created fly scripts typically print statements 
means static guarantees issued correctness 
furthermore control presentation service mixed script code difficult factor programmers html designers 
java servlets language fits category 
structure service written servlets perl 
possible interaction essentially defined separate script cookies hidden input fields similar techniques connect sequences interactions clients 
servlets provide session tracking api hides details cookies hidden input fields url rewriting 
servlet servers cookies browser supports automatically revert url rewriting cookies unsupported explicitly disabled 
api exemplified code inspired servlet tutorials public class extends public void request response throws ioexception context session request true response text html response println html head title servlet demo title head body session println form action enter name input name handle input type submit form session state string state string session getvalue state state equals string name string request handle int users integer context users intvalue context users new integer users session name name println form action www apl jhu edu hall java servlet tutorial java sun com docs books tutorial servlets chapter 
bigwig project hello name user number users input type submit form session state state equals string name string session getvalue name println goodbye name session invalidate println body html clients running service guided series interactions service prompts client name name total number invocations shown goodbye page shown 
object contains information shared sessions object local session 
code essentially switch statement branches current interaction 
alternative approach servlet kind interaction 
spite api needs explicitly maintain state identity session 
model sessions supported servlets script centered approaches tends fit better shopping basket applications client browses freely dynamically generated pages complex services need impose strict control interactions 
page centered approach page centered approach covered language asp php jsp dynamic code embedded html pages 
sense inverse script centered languages html fragments embedded program code 
client requests page specialized web server interprets embedded code typically produces additional html snippets accessing shared database 
case jsp implementations compiling jsp page servlet simple transformation 
approach beautifully motivated simple examples pages mainly static sporadically contain computed contents 
example page displays time day number accesses clearly fits mold 
jsp page dynamically inserts current time title user name cgi input parameters html head title jsp demo title head body hello string name request name null name stranger 
print name page updated new date body html 
session centered web services html page session thread client server sessions web services 
left client browser right session thread running server 
thread initiated client request controls sequence interactions 
special tags contain java code evaluated time request 
long code parts generate strings markup easy statically guarantee shown pages valid html relevant properties 
services complex approach tends converge script centered 
mainly static html page code inserted typical picture single large code tag dynamically computes entire contents 
approaches closely related page centered technologies superior degree scripting languages better designed 
asp php languages reminiscent jsp 
asp closely tied microsoft internet information server implementations exist 
java defines language independent connection html pages scripting languages typically visual basic script microsoft version javascript 
php popular open source variant scripting language mixture java perl 
languages generally provide low level support tracking client sessions maintaining session state 
cookies hidden input fields library support common solution 
web service aspects databases security wide range libraries available direct language support 
session centered approach pure session centered approach pioneered mawl project 
service viewed collection distinct sessions access shared data 
client may initiate session thread conceptually process running server 
interaction client viewed remote procedure calls server known classical construction distributed systems roles reversed 
flow entire session programmed single sequential program closer ordinary programming practice offers compiler chapter 
bigwig project chance obtain global view service 
illustrates flow control approach 
important issues concurrency control simpler understand context standard programming solutions applicable 
mawl program equivalent previous servlet example static int users session auto form handle hello auto string name hello put handle auto form string int count greeting users greeting put name users auto form string goodbye goodbye put name html templates hello greeting goodbye placed separate files 
hello html head title mawl demo title head body enter name input name handle body html greeting html head title mawl demo title head body hello mvar name user number mvar name count body html template goodbye similar 
form tag continue button implicitly inserted 
variables declared static contain persistent data declared auto contain session data 
form variables declared record types 
defines set gaps occur template defines input fields 
templates gaps written mvar tags 
template variables put method 
executed arguments inserted gaps resulting page sent client fills fields submits reply turned record value program 
note notion sessions explicit program private shared state simply matter variable declaration modifiers templates cleanly separated service logic 
obviously session flow clear programmer compiler non session approaches 
concrete benefit easy statically check validity correct input fields 
main force session centered approach services control flow complex 
simple web services actuality loosely structured 
sessions tiny simply server module page centered approach overhead associated sessions may large 
script centered services seen subset 
session centered web services session centered session contains client interaction 
clearly restriction script centered page centered languages allow significant performance improvements 
instance ee servlet jsp servers employ pools short lived threads store little local state 
involved services session centered approach programming easier session management comes free 
structure bigwig services structure bigwig programs directly inspired mawl 
bigwig program contains complete specification web service 
contains collection named sessions essentially ordinary sequential program 
client initiative invoke thread session process server executes corresponding sequential code exclusively communicates originating client 
communication performed showing client html page implicitly form appropriate url return address 
client views document session thread suspended server 
eventually client submits form causes session thread resumed form data entered client received program variables 
simple bigwig service communicates client servlet mawl examples service html hello html enter name input name handle html html greeting html hello user number count html html goodbye html goodbye html shared int users session hello string name show hello receive name handle users show greeting name count users show goodbye name program structure obviously mawl session code templates wrapped service block 
instance statements produce client interactions similarly put methods mawl 
bigwig provides number new features 
importantly html templates class values 
html built data type values passed stored variables data type 
html templates higher order 
means allowing text strings inserted template gaps allow insertion templates 
done special chapter 
bigwig project plug operator inserts string template gaps template 
clearly constitutes flexible document construction mechanism calls new ideas statically verifying instance html validity 
topic section 
new features include techniques improving form field validation concurrency control syntax macro mechanism described sections 
session runtime model session model implemented top cgi protocol 
naive approach create session threads cgi scripts local state stored disk 
session interaction thread started restore local state including call stack order continue execution 
better approach implement session thread process runs duration session 
interaction tiny transient cgi script called connector process executed acting pipe web server session process 
approach resembles fastcgi described detail 
newest implementation specialized apache server module naturally faster cgi solutions create new process single interaction session processes 
common sources problems standard implementations sessions history buffers bookmarking features browsers 
history buffers back button users step back previous interaction intentionally unintentionally resubmit old input form 
useful feature causes confusion annoyance users may instance order twice 
general problem information shown user way obsolete tailor exact time initial request 
information generated shared database may changed entirely generally sense step back time history buffer 
different ordinary programs 
programmer aware added serial number checks history buffer full urls obsolete requests 
service really needs back feature programmed explicitly flow sessions 
hazardous try bookmarks temporarily suspend session 
invoking bookmark typically cause cgi script executed second time just displaying results 
bigwig provides simple unique solution problems session thread associated url points file server containing latest html page shown client 
sending contents directly client show statement redirect browser url illustrated 
url serves identification session thread solves problems mentioned history see httpd apache org 

dynamic construction html pages www web server html file session process session runtime model reply indirection 
session thread implemented separate process writes html reply designated file 
list browser contains single entry duration session sessions bookmarked addition session identity url passed manually browser instance problems 
urls cookies represent session identity possible single user simultaneously run multiple sessions different windows browser 
simple solution furthermore automatically provide client feedback server processing request 
done seconds writing temporary response html file informs client status request 
temporary file reloads frequently allowing updated status reports 
final response ready simply overwrites temporary reply file causing reloading response shown 
simple technique may prevent client impatient abandoning session 
bigwig runtime system additionally contains garbage collector process monitors service shuts session processes abandoned clients 
default occurs client responded hours 
sessions allowed execute clean actions terminating 
dynamic construction html pages mawl html templates placed separate files viewed kind procedures arguments strings plugged gaps template results values form fields template contains 
allows complete separation service code html code 
benefits static guarantees possible programmers html designers separated previously mentioned 
disadvantage template mechanism rigid compared flexibility print statements available script centered languages 
languages permit essentially static guarantees separation 
furthermore script centered solutions html constructed linear fashion top bottom composed components logical manner 
bigwig chapter 
bigwig project brics head title hi title head body bgcolor color body contents greeting hello welcome ff stranger brics contents color head title hi title head body bgcolor color hello welcome body head title hi title head body bgcolor ff hello stranger welcome brics body building document plugging template gaps 
construction starts constants left ends complete document right 
solution provides best worlds 
higher order html templates class values practice flexible print statements mawl benefits preserved 
define sub language bigwig deals document construction control structures html template constants variables assignments plug operations show receive statements 
template constants delimited html html 
gaps written special tags 
special attribute gaps place attribute values shown example 
course strings plugged gaps templates markup 
plug operation creates new template inserting copy gaps copy show receive statement template converted complete document implicitly plugging empty strings remaining gaps 
automatically wrapped form element action continue session session terminates immediately 
inserted outermost template html head title service title head body body html inside body element 
example illustrates documents built gradually higher order templates service html brics html head title hi title head body bgcolor color contents body html html greeting html hello welcome html session welcome html brics contents greeting show color ff stranger brics 
dynamic construction html pages construction process shown 
note gaps may plugged order necessarily bottom 
mawl provide little functionality plugging text strings gaps 
special tag allows list structures built iteratively precludes general tree structures 
bigwig example uses recursive function construct html document representing binary tree service html list html ul li gap li gap ul html html tree int return html foo html return list gap tree session show tree similar done mawl order templates 
script centered page centered language course possible simple program structure reflecting logical composition document generated linearly printing output stream 
alternative html tree constructor library forces documents built bottom inconvenient 
higher order templates generally leads programs large number relatively small template constants 
reason convenient able inline constants program code examples placing separate files 
offer explicit support factoring graphical designers include construct alternatively html constant appearing bigwig program may associated url pointing alternate presumably elaborate version service session hello show html hello world html fancy hello html compiler retrieves indicated file uses contents place constant provided exists contains formed html 
manner programmer plain versions templates graphical designer simultaneously produces fancy versions 
compiler checks versions gaps fields 
order accommodate html authoring tools permit gaps specified alternative syntax special tags 
sub language introduced shown template model implemented efficiently compact runtime representation 
plug operation takes constant time showing chapter 
bigwig project document takes time linear size output 
size runtime representation document may fraction printed size 
example binary tree height shown earlier representation size 
analysis template construction form input wish devise type checker allows liberal dynamic documents possible guaranteeing errors occur 
precisely verify properties compile time plug operation exists gap gap types compatible values plugged particular html markup tags inserted attribute gaps show receive statement fields receive part exist document shown field types compatible receive parts instance select menu allowing multiple items selected yields vector value valid html sent clients 
properties addressed summarized 
property covered section 
infeasible explicitly declare exact types higher order templates reasons 
firstly gaps fields individual capabilities described may voluminous 
secondly imply html variable type program point restrictive allow templates composed intuitive manner 
consequently rely flow analysis infer types template variables expressions program point 
experience results liberal useful mechanism 
employ monovariant interprocedural flow analysis guarantees form fields shown document correspond received gaps plugged 
analysis fits standard data flow frameworks applies highly specialized lattice structure representing template types 
template variable expression occurs program associate lattice element abstractly captures relevant template properties 
lattice consists components gap map field map 
gap map records occurring gap name gap occurs point case occur html gap attribute gap 
similarly field map records occurring input field name information input fields type text radio select checkbox representing different interaction methods 
bigwig program construct flow graph 
quite easy higher order functions virtual methods 
language 
dynamic construction html pages large kind text ul class kind items ul items items li text li items text summary graph representing set html fragments 
constructs included abstracted away 
possible define transfer functions abstractly describe effect program statements 
produces constraint system solve classical fixed point iteration technique 
solution inspect properties mentioned satisfied generate error messages indicating cause 
approach programmer restricted requirement program point template type expression fixed 
practice limit expressibility tends enforce comprehensible structure programs 
compiler silently resolves conflicts flow join points implicitly plugging superfluous gaps empty contents 
html validity analysis fifth property html validity addressed similar complicated approach described 
main idea define finite structure called summary graph approximates set templates html expression may evaluate 
structure contains plug operations constant templates strings involved 
example consider summary graph 
nodes correspond program constants edges correspond plug operations 
instance li template may plugged items gaps ul template 
node represents arbitrary text strings empty string 
root graph corresponds outermost template 
unfolding graph plug edges summary graph defines possibly infinite set html fragments gaps case set ul lists class large character data items 
structure turns provide ideal abstraction level verifying html validity 
apply data flow analysis approximate flow template values program 
time lattice consisting summary graphs 
possible model plug operations precision transfer functions preliminary analyses required 
tracking string constants called gap track analysis tracking origins gaps 
tells template variable gap name constant templates containing gap flow variable program point 
clearly analyses highly specialized domain dynamic chapter 
bigwig project document construction bigwig higher order template mechanism fit standard data flow analysis frameworks 
details refer 
summary graphs show statements need verify sets document fragments define valid html official definition 
simplify process reformulate notion document type definition dtd simpler convenient formalism call dtd 
dtd consists number element declarations designated root 
element declaration defines requirements particular type elements 
declaration consists element name set names attributes subelements may occur boolean expression constraining element type instances respect attribute values contents 
official dtd html easily rewritten dtd notation 
fact dtd version captures validity requirements expressible standard dtds merely appear comments html dtd 
technicality xhtml xml reformulation html 
conceptual differences xml version provides cleaner tree view documents analysis 
summary graph dtd description html validity checked recursive traversal summary graph starting roots 
intermediate results ensure termination summary graphs may contain loops 
violations encountered summary graph valid 
validity properties local single elements contents able produce precise error messages case violations 
analysis soundness ensured property summary graphs corresponding show expressions verified valid respect dtd concrete documents guaranteed valid html 
program analyses described high worst case complexities complex lattices 
implementations experiments show practice large intricate programs 
experiments mentioned section 
caching dynamically generated html traditional web caching works associating expiration time documents sent servers clients 
helped decreasing network server load response times 
default expiration set caching effectively disabled 
technique designed primarily documents contents rarely changes documents dynamically generated interactive web services 
gradual change statically dynamically generated documents caused impact web caching degrade 
existing proposals addressing include active cache hpp various server techniques explained survey 
server techniques aim relieving server redundant computations decreasing network load 
typically simplifying assumptions instance 
dynamic construction html pages interactions handled side effects global service state interactions identical clients dynamics pages limited banner ad rotation 
applies complex interactive services 
active cache proxy solution employs programmable cache applets 
effective requires specialized proxy servers careful programming ensure consistency proxies main server 
hpp tries separate constant parts dynamic parts generated documents 
apply similar technique 
contrast hpp solution entirely automatic hpp requires extra programming 
idea exploit clear division service code html templates bigwig 
normal implementation internal template representation converted html document server show statement executed 
store template constant fixed file server defer conversion client javascript representation dynamic parts 
template files cached ordinary browser caches 
details technique 
summarize evaluation results section 
code gaps document clusters describe extensions language 
occasionally page centered approach admittedly appropriate session centered 
consider example gives current time day service session time html html right time html show equivalent clumsy version written code gaps implicitly represent expressions values computed plugged gaps document shown service session time html html right time html show documents code gaps remain class values code access global scope 
note code gaps bigwig powerful usual page centered approach code exists full context sessions shared variables concurrency control 
fact idea published documents described section page centered approach included special case bigwig 
chapter 
bigwig project services may want offer client single document browse example response tiny customized web site 
bigwig experimented support showing document clusters 
difficulty provide simple notation specifying arbitrary graph documents connected links 
introduce html variable document notation right hand side plug operation 
eventually expand url document shown 
flow analysis just records connection gap variable 
document shown transitive closure document computed resulting cluster documents produced replaced corresponding urls 
example shows cluster documents cyclically connected 
notice cluster browsed freely cluttering control flow service session cluster html greeting html hi 
click href kind word 
html html kind html nice see 
href back html kind kind greeting show greeting kind compiler checks cluster documents submit buttons contain form fields 
necessary perform escape analysis ensure document variables exported scope 
form field validation considerable effort web programming expended form field validation checking data supplied client form fields valid producing error messages requesting fields filled 
apart details regular expression matching main problem program solution robust efficient user friendly 
approach server side validation form fields validated server page submitted 
languages mentioned section provides help regular expression matching perl 
main logic service cluttered validation code 
sense program part sends page client wrapped loop repeats input valid 
disadvantages include wasting bandwidth causing delays users 
proposal addressing problems requiring browser extensions java applets alternative client side validation usually requires programmer javascript pages generated 
permits 
form field validation sophisticated user interactions reduces communication overhead 
client side validation 
reason client perfectly capable bypassing javascript code additional server side validation performed 
code essentially written javascript server scripting language 
practice writing javascript input validators time capture validity requirements user friendly difficult browsers unfortunately differ javascript support 
web sites dedicated explaining various subsets javascript different browsers bigwig introduced domain specific sub language called powerforms form field validation 
handles complex interdependencies form fields compiler generates required code client server 
compiling javascript powerforms implementors need know details browsers support javascript web service programmers 
programmer needs anymore write essentially code server side version client side version 
powerforms declarative language 
informally means programmer specifies input requirements check 
simplest form powerforms allows regular expression formats associated form fields service format digit range format number plus digit format alpha union range range format word concat alpha star union digit alpha format name concat word star concat word format email concat word word star concat word session validate html form html please enter email address input name email type text size format name email field email html string show form receive email example shows constrain input email field certain regular expression 
bigwig compiler generates javascript code checks user input client side provides help error messages code performing server side double check 
traffic light icons input fields user provided continuous feedback string entered far 
green means valid yellow means invalid prefix valid red means prefix valid 
alternatives chosen checkmark symbols arrows see www com articles javascript limitations html www xs nl js version html 
chapter 
bigwig project allow usual perl style syntax regular expressions subset notation excludes intersection complement operators 
formats associated kinds form fields just type text 
select fields format filter available options 
radio checkbox fields permitted buttons depressed 
noted forms contain fields values may constrained entered fields 
typical example field applicable field certain value 
interdependencies handled server rest validation performed client 
reason presumably interdependencies require delicate javascript programming 
bigwig solution allow field interdependencies specified extension regular expressions format tags extended describe boolean decision trees conditions probe values form fields leaves simple formats 
interdependence resolved fixed point process computed client javascript code automatically generated bigwig compiler 
simple example client chooses letter group select menu dynamically restricted letters service format vowel charset format consonant charset html form html favorite letter group input type radio name group value vowel checked vowels input type radio name group value consonant consonants br favorite letter select name letter option value option value option value 
option value select format field letter equal field group value vowel format name vowel format name consonant format html session letter string show form receive letter provides mechanism reminiscent powerforms 
support field interdependencies validation non text fields 
powerforms shown simple language clean semantics appears handle realistic situations 
implemented 
concurrency control part bigwig compiler stand tool add input validation general html pages 
concurrency control services session threads need synchronization concurrency control discipline concurrent behavior active threads 
simple case control access shared variables mutex regions readers writers protocol 
issue enforcement priorities different session kinds management session may block sessions running 
example event handling session thread may wait certain events caused threads 
deal scenarios uniform manner central controller process runtime system general enforce wide range safety properties 
support concurrency control previously mentioned web languages limited traditional solutions file locking monitor regions synchronized methods 
bigwig service associated set event labels 
execution session thread may request permission controller pass specific event checkpoint 
permission granted session thread suspended 
policy controller programmed maintain appropriate global invariants entire service 
clearly calls domain specific sub language 
chosen known general formalism temporal logic 
particular variation monadic second order logic 
formula describes set strings event labels associated semantics trace event labels passed threads belong set 
guide controller bigwig compiler uses mona tool translate formula minimal deterministic finite state automaton controller process permissions individual threads 
thread asks pass event label placed corresponding queue 
controller continually looks non empty queues event labels correspond enabled transitions current dfa state 
match corresponding transition performed chosen thread resumed 
course controller implemented satisfy fairness requirements 
regular trace languages 
applying temporal logics approach harsh average programmer 
syntax macros described section possible capture common concurrency primitives semaphores mutex regions readers writers protocol monitors provide high level language constructs hiding actual formulas 
advantage bigwig extended constructs highly customized particular applications maintaining simple core language concurrency control 
example illustrates simple service implements critical region event labels enter leave chapter 
bigwig project service shared int session critical constraint label leave enter enter enter leave wait enter wait leave formula states enter events leave event implies time thread allowed critical region 
syntax macros programmers allowed build higherlevel abstractions written service shared int session critical region omit macro definitions 
full generality wait statement switch statement allows thread simultaneously attempt pass event labels request timeout waiting specified time 
different example implements asynchronous event handler 
macros programmed service shared int constraint label handle cause handle cause handle session handler true wait handle session application wait cause non trivial formula allows handler proceed blocking application associated event caused invocation handler 
fortunately macros permit highlevel abstractions introduced palatable syntax 
syntax macros service shared int event increment session application cause increment runtime model centralized controller process ensuring satisfaction safety constraints described 
monadic second order logic controller synthesis introduced additionally notions triggers counters introduced gain expressive power regular sets traces conditions distributing controller better performance defined 
session model provides opportunity get global view concurrent behavior service 
current approach exploit knowledge control flow 
plan investigate specialized program analyses check liveness concurrency requirements complied 
syntax macros previously mentioned bigwig contains notion macros 
specific web services abstraction mechanism essential part bigwig serves keep sub languages minimal tie 
macro language characterized level operation lexical syntactic 
lexical macro languages operate sequences tokens conceptually precede parsing 
independence syntax macros unintended effects parse errors discovered invocation time 
consequently programmers required consider individual macro invocations expanded parsed 
syntactic macros amend operate parse trees token sequences 
types added macro arguments bodies form nonterminals host language grammar 
macro definitions syntax checked definition time guaranteeing parse errors longer occur consequence macro expansion 
syntax macros syntax programming language simply appears extended new productions 
macros syntactic entirely simple declarative concepts grammars substitution making easy safe ordinary web service programmers 
macro languages ms scheme macros maya apply full turing complete programming languages manipulating parse trees compile time making difficult 
initial example extend core language bigwig repeat control structure easily defined terms loop 
chapter 
bigwig project macro stm repeat stm exp bool true false line header macro definition 
specifies nonterminal type macro abstraction invocation syntax including typed arguments 
expected type repeat macro stm representing statements 
causes body macro parsed statement announces invocations allowed places ordinary statement 
allow programmer design invocation syntax macro 
guide parsing adds transparency macro abstractions 
particular macro designed parse appropriately delimited arguments statement expression body macro implements abstraction boolean variable loop 
macro invoked identifiers occurring body converted avoid name clashes invocation context 
concept packages macros bundled collections 
experience bigwig programming led develop standard macro package std extends sub languages bigwig various ways helped keep language minimal 
instance form field validation language extended optional regular expression construct database language macros transform sql queries iterative factor construction 
various composite security modifiers defined concurrency control macros region section gradually build top implement increasingly sophisticated abstractions 
macros tie different sub languages making collaborate provide tailor extensions language 
instance sub languages dealing sessions dynamic documents concurrency control combined publish macro 
macro useful service wishes publish page static needs recomputed underlying data changes 
macros efficiently implements abstraction macro publish id exp shared html cache shared bool cached session exclusive cached cache cached true show cache 
syntax macros macro stm touch id cached false publish macro recomputes document cache expired shows document touch macro causes cache expire 
operator create new identifiers concatenation 
extended syntax service maintaining example high score list look require publish service shared int record shared string holder publish record holder session play int score play score record show receive holder name record score touch show html sorry record html high score document regenerated player beats record 
code clearly easier understand maintain corresponding expanded code 
expressive power syntax macros extended concept explained 
declaratively permits tree structures transformed host language syntax compromising syntactic safety possible macro languages 
mechanism extreme way possible define new languages 
call concept domain specific language 
university aarhus undergraduate computer science students complete bachelor degree fields 
requirements satisfied surprisingly complicated 
guide students goal maintain called bachelor contract plans remaining studies discovers potential problems 
process supported web service student iteratively accepts past course activities checks requirements diagnoses violations legal contract composed 
service written straight bigwig application quickly annoying maintain due constant changes curriculum 
redesigned form study fields requirements conceptualized defined directly natural language style 
possible non programmers maintain update service 
small example input chapter 
bigwig project require bachelor studies course math title mathematics points fall term course phys title physics points spring term course lab title lab point fall term exclusions math math prerequisites math math math math math math cs cs cs cs math cs cs math stat cs cs cs cs cs cs phys phys phys phys phys phys phys phys phys lab lab lab lab lab lab lab lab lab lab lab lab lab field cs mathematics field courses math math math math stat cs cs cs cs cs cs cs cs cs cs project courses math math phys phys phys phys constraints passed cs cs courses cs cs cs math math courses stat math math points project cs cs total points syntax displayed plain bigwig macro package require instruction 
entire program argument single macro studies expands complete code corresponding web service 
file bachelor lines defines complete implementation new language 
bigwig macro mechanism offers rapid inexpensive realization new ad hoc languages syntax desired 
similar features occur web service languages mentioned previous sections 
web service aspects course features bigwig necessary support web service development major innovations 
briefly section 

web service aspects html deconstruction template mechanism construct html documents run reverse allows deconstruction 
realized templates patterns gaps play role variables illustrated example service html template html img src source alt today dilbert comic html session dilbert string data get www dilbert com string match data template source exit template source www dilbert com grabs daily strip dilbert home page 
gaps names serve wildcards 
interaction patterns strict session model inappropriate client server alternate active suspended 
furthermore information pushed server initiative client viewing page 
simple example chat room new messages appear automatically client having reload page viewed new message entire new page transmitted 
essence concept client side computations able contact server accord 
bigwig solution notion 
kind lightweight session allowed ordinary session perform show operations 
invoked client arguments eventually returns reply bigwig type 
typically performs database operations waits certain events occur reports back client 
limited existing technologies client side current implementation restricted java applets javascript 
facilitate writing applets bigwig compiler generates java code class extending applet inherited order access available 
alternatively experimented javascript interface 
approach limited lack clientserver communication support javascript currently apply cookies communication 
important allow client side code synchronize active threads server 
example chat room solution employ uses concurrency control mechanisms bigwig wait message available returned applet 
way client pulling busy waiting required 
chapter 
bigwig project databases web services centered database 
general case existing external database service connect 
bigwig system supports odbc interface purpose 
queries built strings written query language part bigwig syntax 
allows compile time checking syntax types queries eliminating source errors 
smaller services simple data offer internal database implemented top file system 
security aspects web service security security bigwig divided categories depending generically applicable services specific behavior particular service 
category relates runtime environment communication dealing concepts integrity authenticity confidentiality 
integrity session thread local state achieved keeping exclusively server 
integrity shared data provided database 
interaction key generated embedded document shown client serves prevent submission old documents 
clients session threads associated random key created server request carried interactions hidden input field 
mechanism may optionally combined security measures ssl provide necessary level security 
authenticity confidentiality addressed general declarative security modifiers programmer attach service session basis 
modifiers ssl enforce ssl authentication protocols communication 
selective modifier restricts access session clients ip numbers match set prefixes 
singular modifier ensures client ip address execution session 
envision performing simple static analyses relating behavioral security particular services 
values classified secret trusted contrast tainting perl compiler keeps track propagation properties 
furthermore restrictions kind data 
form data assumed untrusted gaps allowed plugged secret values 
variables declared modifiers secret trusted may contain corresponding values 
system function called trusted string value 
change classification value functions trust disclose 
programmer explicit choice coercions 
example involving trust service service session lookup www org security faq 
evaluation html error html invalid url html html html enter url input type text name url html string domain show receive url show error domain system usr domain stderr show error code performs url supplied user check domain exists 
value domain derived form field url trusted call system flagged compiler 
unfortunate client enters foo rm rf form 
similar analysis performed secret 
consider example service shared secret string password bool odd int return session reveal odd password show html foo html compiler sufficiently paranoid reject program branching statement depends function applied information derived secret value 
analyses particularly original seen web service programming languages 
done area 
far considered techniques ensure service integrity role certificates sophisticated static analyses 
evaluation bigwig language evaluated different criteria 
quality language design seen concrete programming experiences 
necessarily somewhat intangible subjective criterion 
second performance language implementation seen observed benchmarks 
experience bigwig bigwig mainly experimental research tool gained experiences numerous minor services written number services administrative purposes university aarhus couple production services collaborated 
apart applications estimate bigwig chapter 
bigwig project downloaded roughly times web site mainly received positive feedback users 
production service web site european association theoretical computer science www eatcs org handling newsletters membership services 
written lines bigwig html templates show statements 
web site conference www dk handling aspects advertisement schedules registration attendant services 
written lines bigwig html templates show statements 
experiences shown bigwig strong points 
session concept greatly simplifies programming complicated control flow multiple client interactions 
second html templates easy intuitive static guarantees catch numerous errors difficult find means 
particularly helpful html analyzers provide precise intuitive error messages 
application particularly interesting involved collaboration external html designer 
experience confirmed templates successful defining interface programmers designers gaps fields define useful contract 
main weak point identified core language lacking minor features 
plan address mentioned section 
stand version powerforms sub language surprisingly popular right 
active users integrated proprietary web deployment system 
performance evaluating performance bigwig implementation want focus areas attempted provide improvements 
aiming simple high load services focusing services intricate flow control 
informal tests show throughput services certainly comparable straight cgi services servlet applications running se 
automatic caching scheme html templates designed exploit intricate structure cache static fragments client side 
obtained real benefits approach 
experiments reported show size transmitted data may shrink factor dial connections translates reduction download times factor 
relevant evaluate performance bigwig compiler employ series theoretically quite expensive static analyses 
practice perform documented 
eatcs service analyzed html validity seconds service seconds 

bigwig project identified central aspects interactive web services provided solutions coherent framework programming language theory 
time bigwig project case study applications domain specific language design paradigm 
argued notion sessions essential web services constitute basic structure web service programming language 
higher order document templates sublanguage dynamic construction web pages time flexible making easy safe compile time guarantees regarding document validity input forms 
shown form field validation compared traditional approaches easier domain specific sub language powerforms automatically translates high level specifications combination low level client side code 
examined temporal logics synthesize concurrency controllers 
demonstrated macro mechanisms effective extending combining languages context sub languages bigwig 
version bigwig compiler runtime system freely available project home page www brics dk bigwig documentation examples 
regarding development bigwig move java 
developing extension java add successful features bigwig session model dynamic documents form field validation syntax macros 
design bigwig focused web specific areas hope standard programming issues web services easier develop 
number new challenges arise 
instance program analyses described section assume access precise control flow graphs programs 
trivial bigwig certainly java 
plans include type safe support xml document transformation wml support broadening view development management web sites comprising services 
acknowledgments tom ball provided extensive helpful information experiences mawl language 
anders sandholm key participant phd studies brics 
christensen olesen worked student programmers entire project 
niels engberg mads johan jurik lone olesen christian tommy thorn provided valuable feedback suggestions 
appreciate efforts participants wig projects course spring 
grateful insightful comments received anonymous reviewers 
chapter runtime system interactive web services anders ller anders sandholm michael schwartzbach interactive web services increasingly replacing traditional static web pages 
producing web services require tremendous amount laborious low level coding due primitive nature cgi programming 
ideas improved runtime system interactive web services built top cgi running virtually combination browser cgi server 
runtime system implemented extensively bigwig tool producing interactive web services 
interactive web service consists global shared state typically database number distinct sessions contain local private state sequential imperative action 
web client may invoke individual thread session kinds 
execution thread may interact client inspect modify global state 
way providing runtime system interactive web services simply plain cgi scripts 
designed simpler tasks cgi protocol inadequate implementing session concept 
supports long sessions involving user interactions kind concurrency control 
widespread standard running web services serious stumbling stone development complex modern web services 
runtime system built top cgi protocol features support sessions concurrency control 
motivate need runtime system 
done presenting advantages simple cgi script solution 
description runtime system different parts chapter 
runtime system interactive web services dynamic behavior 
round discussion related directions 
appendices briefly describe implementation suggested runtime system 
give short presentation bigwig tool producing interactive web services extensive self contained runtime system package 
motivation technology plain cgi scripts lacks properties expect modern programming environment 
discuss various shortcomings traditional cgi programming motivate solution problems design improved runtime system built top standard cgi protocol 
session concept describe motivate concept interactive web service 
protocol originally designed browsing static documents connected hyperlinks 
cgi forms allows dynamic creation documents contents document constructed server time document requested 
dynamic documents advantages static documents 
instance contents documents tailor date 
natural extension dynamic document model concept interactive services illustrated 
client browse fill forms client server start session show page submit compute reply interactive web session browse number independent statically dynamically generated pages guided session controlled session thread server 
session involve number user interactions 
session initiated client submitting start session request 
server 
motivation starts thread controlling new session 
thread generates reply page sent back client 
page typically contains input fields filled client 
information sent server generates reply session terminates 
session concept allows large class services defined 
number practical problems needs solved order implement model top cgi model 
cgi scripts sequential session threads explained web service session consists sequential computation way presents information client waits replies 
cgi state protocol meaning execution cgi script lasts page shown web client 
fact tedious program larger web services involving client interactions 
sequential computation split small bits computation happen client interactions 
small bits constitute cgi script instance cgi call 
furthermore achieve persistency local state store restore explicitly cgi calls instance hidden web page sent client 
simple services full session approach needed stateless server approach preferable clearly inadequate general 
problem forced termination cgi script client interaction fold having deal small scripts writing maintenance web service difficult control flow service tends clear program code 
starting new process time client interaction performed expensive 
top complete image local state stored restored time client interaction required 
local state potentially hold lot data database contents 
gets substantial overhead execution web service 
provide simple solution splits cgi scripts components connectors session threads 
connector tiny transient cgi script redirects input session thread receives response thread redirects back web client 
session threads persistent processes running web server 
survive cgi calls implement long sequential computation involving client interactions 
transient connectors persistent session threads decreases difficulty writing maintaining web services 
furthermore improves substantially overhead web server execution service 
chapter 
runtime system interactive web services cgi shortcomings traditionally reply pages session threads sent directly client 
session thread connector system described writes page standard output web server sends client browser 
basic approach imposes annoying problems client client able bookmarks identify session selecting bookmark imply resending old query server server expects reply interaction 
natural client selecting bookmarked session continue session current state 
obviously requires server keep kind backup latest page sent client 
session concept described previous section sense roll back execution session thread previous state 
thread continued current point execution 
result sending pages directly standard output method new page shown client gets stacked client browser 
means stack visited pages filled outdated pages 
result back button browser useless 
suggest simple solution sending reply session thread writes reply file visible client sends client reply file 
choosing url duration session function identification particular session 
solves problem bookmarks back button 
pressing back bring client back web page started session natural effect 
method opens easy solution problem 
server requires long time compute information page shown client 
naturally client may impatient lose interest service assume server connection response received certain amount time 
confirmation form temporary response page sent client know happening waiting vain 
extra feature implemented runtime system follows 
response ready instance seconds connector responds temporary page instance saying please wait terminates 
page automatically loaded clients web browser reload say seconds 
session thread finishes computation real response page ready thread just replaces temporary page real response page 
effect time page reloaded real response page shown client 
reloading done standard html functionality 
course reloading causes extra network traffic method probably close gets server pushing world cgi programming 

components runtime system handling safety requirements consistently serious problem traditional cgi programming concurrency control synchronization sessions locking shared variables gets handled ad hoc fashion 
typically done low level semaphores supplied operating system 
result web services implement aspects incorrectly resulting unstable execution damaging behavior 
solution allows put safety requirements mutual exclusion complex requirements separately centralized supervising process called controller 
approach significantly simplifies job handling safety requirements 
requirements formulated separately solution robust changes various parts code 
generally considered inefficient unsafe centralized components distributed systems 
case bottleneck cgi server network safety controller 
spite try distribute functionality safety controller discussed section 
components runtime system time number web clients accessing cgi server cgi protocol 
server side controller number session threads running 
session threads access global data produce response pages web clients 
time time connector started result request web client 
connector contact running session thread 
connector shut having delegated answer session thread back web client 
give detailed description components 
overview components runtime system see 
web clients web clients users provided web service 
service essentially filling forms submitting cgi requests browser 
cgi server cgi server handles incoming ht tp cgi requests retrieving web pages starting appropriate cgi scripts case connectors 
directs response pages back web clients 
session threads session threads resident processes running web server surviving cgi calls 
represent actual service code implements provided web service 
calculations search databases produce response web pages chapter 
runtime system interactive web services controller client internet cgi server connector session thread runtime system reply connectors web client request server connector started 
request controller starts new session thread corresponding request web client 
web client wants continue execution running session thread connector notifies relevant session thread request forwards input thread 
reply pages session thread designated file contains current web page visible client session 
writing file contents buffer updated atomically client may read file time 
controller controller central component 
supervises session threads possibility suspending execution various points 
way ensured stated safety requirements satisfied 
furthermore runtime system contains global state database file system full fledged database service manager care garbage collecting abandoned session threads administrative issues 
dynamics runtime system section describe dynamic behavior runtime system 
start explaining structure execution session thread 
starting possible thread transitions 
described session thread started 
transitions involving interaction web client showing web pages getting replies dealt 
transitions involving interaction controller 

dynamics runtime system transition give description components involved interaction 
execution thread lifetime session thread depicted diagram 
start active showing waiting possible states transitions session thread thread started enters state active 
sorts computations 
eventually reaches point composed response html page 
page shown web client thread enters state showing 
waits web client respond cgi request 
re submission thread state active resumes execution 
note world naive cgi programming moving active showing back store complete image local state terminating script 
started new process started local state reconstructed image saved 
substantial overhead saving restoring local state avoided completely transient connectors resident threads 
state active thread get point execution safety critical computation accessing shared resource needs carried 
reaching point thread asks controller permission continue enters state waiting 
permission granted controller thread active state continues execution 
traditional approach merge code implementing intricate details dealing concurrency control service code 
addition substantially reducing readability code increase risk introducing errors 
solution separates code dealing concurrency control service code 
session complete thread leave state active execution 
starting session thread section describes transition start active 
new web client cgi request server start new connector cgi script 
request chapter 
runtime system interactive web services web client new thread started session name request 
described response page sent back client thread reaches show call certain amount time instance seconds passed 
session thread initiated moves showing active contents reply file immediately overwritten web page containing reply ready please wait message refresh html command 
refresh command browser reload page seconds temporary reply file overwritten real reply described section 
default contents please wait page overridden service programmer simply overwriting reply file message appropriate specific situation 
interaction client execution running thread service show page web client continue execution receiving response client 
describe actions 
showing page section describes transition active showing 
execution session thread computations inspect input client produce response documents response document constructed execution reaches point page shown client actions taken 
document shown written reply file indicated 
file contains cache pragma command client browser fetches new page url duration session 
unfortunately lose possibility browser caching restricted building top existing standards get 

connector cgi script started web client terminated due second timeout session thread tells reply page ready 
thread goes sleep 

connector waiting seconds receives reply ready signal session thread connector writes location containing url reply page cgi location feature dies 

cgi server transmit url back web clients browser fetch reply page cgi server show client 
actions describe flow data starting session thread client 

dynamics runtime system receiving client response section describes transition showing active 
session thread sleeping showing state web client read page fill appropriate form fields resubmit 
result flow data client session thread see 
request client cgi protocol 
request initiated clicking link pressing submit button 

result cgi server starts cgi script connector 

connector see client associated running thread wake sleeping session thread supply new arguments 
interaction controller controller allows programmer restrict execution web service way stated safety requirements satisfied 
threads built checkpoints places safety critical code executed 
checkpoints thread ask controller permission continue 
controller turn constructed way restricts execution safety requirements allow threads violate requirements continue 
describe detail controller happens session threads ask permission permission granted controller 
controller controller consists parts control logic number checkpoint event queues timeout queue 
gives overview controller 
checkpoint event queues control logic timeout queue components controller chapter 
runtime system interactive web services control logic control logic actual component representing safety requirements 
controls events enabled various session threads may continue execution checkpoints 
imagine various approaches finite state machines petri nets 
reason internals control logic specified 
requirement interface contain functions available runtime system check enabled takes checkpoint event id argument replies event currently enabled 
event occurred takes id enabled checkpoint event argument updates internal state control logic information event occurred 
explain functions controller 
checkpoint event queues checkpoint event queues form interface running threads service 
queue possible checkpoint event 
thread reaches checkpoint asks controller permission continue adding process id queues corresponding events wants wait checkpoint 
timeout queue extra feature specify timeout asking controller permission continue 
purpose controller timeout queue 
permission granted specified time bound controller wakes thread information permission granted timeout event occurred 
specified timeouts put special timeout queue implemented priority queue 
asking permission checkpoints section describes transition active waiting 
mentioned earlier possibility adding checkpoints session code critical code executed 
runtime system interface functions available service programmer specifying checkpoints 
conceptually programmer uses specify checkpoint statement illustrated example 
example effect thread instance session reaches point 
tell controller waits event event timeout seconds 

having sent request controller thread goes sleep waiting response 

dynamics runtime system controller actions wait case case timeout 
checkpoint example controller running loops doing receives request pass checkpoint client controller pushes id client appropriate queues 
entries chained permission granted removed 
illustrates effect example timeout queues 
timeout occurred controller deletes affected entries queues informs involved thread 
look enabled event check enabled function control logic 
queue corresponding enabled event non empty controller event occur doing 
removes linked entries thread id enabled event respective queues 
tells control logic event occurred event occurred function 
wakes involved thread permission granted signal containing name event 
events enabled token ring scheduling policy 
ensures fairness sense thread waits enabled event point granted permission continue 
permission granted section describes transition waiting active 
having sent request permission continue thread sleeping waiting controller response 
permission granted signal sent thread wakes continues branching chapter 
runtime system interactive web services event signaled controller 
example checkpoint controller permission event execution continued code case 
controller sends timeout signal execution continues timeout 
extending runtime system runtime system described previous sections extended ways 
extensions implemented experimental version runtime system package near 
extensions believe reaching limits possible standard cgi protocol current functionality standard browsers 
distributed safety controller presentation far described controller centralized component 
cases possible divide control logic independent parts controlling disjoint sets checkpoint events 
controller divided number distributed control processes 
way problem controller bottleneck system successfully avoided 
service monitors idea connectors controllers construct remote service monitor program run super client able access logs statistics information generated connectors controllers inspect change global state state control logic controllers 
implemented having dedicated monitor process service 
secure communication system quite vulnerable hostile attacks 
easy hijack session url reply file identify session 
simple solution random keys urls making practically impossible guess session id course information sent clients browser server session id data written forms 
avoid doing experiments cryptography making communication completely secure practice 
requires browser plug ins unfortunately standardized 
protocols experiments rsa des ripe md 
prevent hijacking provide secure channels verify user id transparently client 

related document clusters session concept illustrated page generated shown client time 
service wants generate cluster linked documents client client browse documents involving session thread 
current implementation solution program possibility browsing cluster service code inevitably tedious complicated task 
document clusters implemented simply having reply file document cluster 
recall setup name reply file fixed duration session 
way history buffer browser got reasonable functionality 
get functionality need somewhat different approach reply files retrieved directly server connector process 
connector receives id session thread cgi query string document number hidden variable 
single process model server processes session threads safety controllers running machine possibility distributing processes exploited combined single process lightweight threads 
decreases memory operating system provides transparent sharing code memory removes overhead process communication 
resulting system close dedicated web server 
important difference builds cgi protocol 
related idea having persistent processes running server central fastcgi system 
difference fastcgi requires server dependent support approach works servers support cgi 
runtime system tailored support specific needs 
detailed formal description safety requirements written separately suitable logic 
language writing safety requirements compilation process safety controller described optimizations memory usage flow capacity controller developed 
generalizes ideas resulting standard scheme generating controllers discrete event systems controllable uncontrollable events 
mawl language suggested domain specific language describing sequential transaction oriented web applications 
highlevel notation compiled low level cgi scripts 
mawl directly provides programming constructs corresponding global state dynamic document sessions local state imperative actions client interactions 
system shows chapter 
runtime system interactive web services great promise facilitate efficient production reliable web services 
mawl offers automatic synthesis advanced concepts relies standard low level semaphore programming concurrency control 
fastcgi solution possible compile service dedicated server particular service 
faster simple cgi scripts solution opposed fastcgi solution easily ported different machine architectures 
implementation briefly described appendix constitutes core bigwig tool currently developed brics 
bigwig tool runtime system propose shown provide simple efficient solutions problems occurring due increased interactive web services 
furthermore session concept constitute framework natural designing complex services 
basing design runtime system widely protocols system easy incorporate 
development runtime system followed bigwig homepage 
implementation unix version runtime system implemented package containing components corresponding connector 
provides connection components clients cgi server 
safety controller handles concurrency control 
reasons described section control logic included package needs supplied separately 
runtime library linked service code 
provides functions easy interaction components 
experimental version runtime package implements extensions described section 
package including source code detailed documentation examples available online bigwig bigwig high level programming language developing interactive web services 
complete specifications compiled conglomerate lowerlevel technologies cgi scripts html javascript java applets plug ins running top runtime system 
bigwig www brics dk bigwig 
intellectual descendant mawl project completely new design implementation vastly expanded ambitions 
bigwig language really collection tiny domain specific languages focusing different aspects interactive web services 
minimize syntactic burdens contributing languages held skeleton language 
bigwig look feel programs special data control structures 
bigwig service executes dynamically varying number threads 
provide means controlling concurrent behavior thread may synchronize central controller enforces global behavior conform regular language accepted finite state automaton 
control logic bigwig consists finite state automata 
controlling automaton directly computed mona system collection individual concurrency constraints phrased order logic 
extensions counters negated alphabet symbols add expressiveness regular languages 
html documents class values may computed stored variables 
document may contain named gaps placeholders html fragments attributes tags 
gaps may runtime plugged concrete values 
values may contain gaps highly dynamic mechanism building documents 
documents represented compressed format plug operations takes constant time 
flow sensitive type checker ensures documents consistent manner 
standard service executes hardly security 
higher levels security may requested communications digitally signed encrypted bit rsa des 
required protocols implemented combination java javascript native plug ins 
familiar struct array datastructures replaced tuples relations allow simple construction small relational databases 
efficiently implemented sufficient databases bigger mbs quite lot 
relation may declared external automatically handle connection external server 
external relation accessed subset syntax internal relations translated sql 
important mechanism gluing components fully general hygienic macro mechanism allows bigwig programmers extend language adding arbitrary new productions grammar 
nonterminals potential arguments result types macros front macros soundly implemented full alpha conversions 
error messages remain sensible threaded back macro expansion 
allows definition domain specific languages contain specialized constructions building chat rooms shopping centers 
macros wrap concurrency constraints primitives layers user friendly syntax 
version bigwig currently undergoing internal evaluation brics 
want try contact information 
chapter 
runtime system interactive web services tation rough high priority months 
project scheduled deliver version bigwig tool june 
freely available open source distribution unix 
chapter powerforms declarative client side form field validation anders ller michael schwartzbach uses html forms may benefit validation specified input field values 
simple validation matches individual values specified formats advanced validation may involve interdependencies form fields 
currently standard specifying implementing validation 
today cgi programmers perl libraries simple validation program customized javascript solutions client side validation 
powerforms add html forms allows purely declarative specification input formats sophisticated interdependencies form fields 
may seen inspiration extension html available cgi programmers today preprocessor translates powerforms document combination standard html javascript works combinations platforms browsers 
definitions powerforms formats syntactically disjoint form allows modular development form automatically generated tools formats interdependencies added separately 
powerforms clean semantics defined fixed point process resolves interdependencies field values 
text fields equipped status icons default traffic lights continuously reflect validity text entered far providing immediate feed back user 
gui components available options dynamically filtered allowed values 
powerforms integrated bigwig system generating interactive web services freely available open source distribution stand package 
chapter 
powerforms declarative client side form field validation briefly review relevant aspects html forms 
cgi protocol enables web services receive input clients forms embedded html pages 
html form comprised number input fields prompting client information 
visual rendering input field enter information requests determined type 
widely fields range expecting lines textual input providing choices number fixed options determined time page constructed 
fields differ appearance indistinguishable server sense return kind information 
fields type text password rendered differently expect line textual input client 
multiple lines textual input handled field 
fields types radio select require exactly choice number static options arbitrary number choices permitted checkbox select multiple fields 
individual radio checkbox fields common name may distributed form constitute group selection requirements apply 
options select field hand grouped place form 
addition specialized fields image file button shall treat detail 
fields control behavior entire form reset submit respectively resets form initial state submits contents server 
input validation textual input fields possibly hold 
usually client expected enter data particular form instance number name zipcode mail address 
frequent solution determine server submitted data required form known server side input validation 
data invalid parts suitable error messages allowing client necessary corrections 
process repeated fields contain appropriate data 
solution simple known drawbacks takes time causes excess network traffic requires explicit server side programming 
note drawbacks affect parties involved 
client clearly annoyed extra time incurred round trip server validation server extra network traffic wasted cycles programmer explicit programming necessary implementing actual validation re showing pages 
obvious solution drawbacks 
conference questionnaire 
move validation server client yielding client side input validation 
third drawback partially alleviated 
details re showing pages longer required actual validation needs programmed 
move server side client side opens important benefit possibility performing validation incrementally 
client longer needs click submit button getting validation report 
allows errors signalled occur clearly eases task correctly filling form 
field interdependencies aspect validation involves interdependent fields 
forms contain fields values may constrained values entered fields 
exhibits simple questionnaire conference participants invited state attended past conferences compared 
second question clearly depends may answered answer positive 
conversely answer second question may required answer 
interdependencies handled server rest validation addressed client side 
reason presumably interdependencies require tedious delicate javascript code 
kind validation explicitly requested working draft extending forms 
easily imagine advanced dependencies 
useful illegal selections automatically 
javascript programming traditionally client side input validation implemented javascript 
argue may best choice web authors 
general purpose programming language relatively specific purpose exposes programmer unnecessary details choices 
small high level domain specific language dedicated input validation involve relevant concepts potentially easier learn 
assisting libraries exist context full programming language 
secondly javascript code operational form forcing programmer think order fields contents validated 
chapter 
powerforms declarative client side form field validation simplicity input validation task permits purely declarative approach 
declarative specification abstracts away operational details making programs easier read write maintain 
approach closer composing html writing javascript making input validation available people 
stated working draft extending forms possible define rich form including validations dependencies basic calculations scripting language solution precisely include mechanisms validations dependencies 
traditional implementation task complicated diverging javascript implementations various browsers 
forces programmer stay subset javascript supported browsers subset may hard identify 
fact number sites faqs dedicated identifying subset 
domain specific language compiled common subset javascript implying compiler writer concerned issue 
solution powerforms argued solution introduce high level declarative domain specific language called powerforms designed incremental input validation 
section presents solution simple validation section extends handle field interdependencies section exhibits common uses javascript handled declarative specification section presents strategy translation javascript section describes availability powerforms packages 
related authoring systems cold fusion automate server side verification simple formats result unsatisfactory 
typical response invalid data shown 
refers internal names input fields unknown client required corrections remembered form displayed 
active forms special browser supporting form applets programmed tcl scripts 
offer high level abstractions integration html 
web dynamic forms offer ambitious complex solution 
propose completely new form model technically unrelated html exists entirely java applet 
inside applet allow complicated interaction patterns controlled event programming model common actions provided directly may programmed java 
form submitted data extracted 
validation input formats typical server side validation 
applet treated ordinary html form data 
intervening years shown web authors prefer standard html forms program advanced behavior javascript 
simpler approach automatically generating javascript code remains relevant 
important reason stay exclusively html input fields integrated html tables control layout 
xhtml fml language provides means client side input validation adding attribute called ctype textual input fields 
attribute restricted large set predefined input validation types support field 
powerforms notation totally declarative requires programming skills 
furthermore modular sense validation added input field existing html form knowing name 
validation markup completely separate form markup allows layout form redesigned time html editor 
validation input formats language regular expressions embedded html subsequently translated combination standard html javascript 
approach benefits efficient implementation finite state automata interpreted javascript code 
named formats may associated fields values required belong corresponding regular sets 
client continuously receiving feedback form submitted formats satisfied 
server course perform double check javascript code open tampering 
regular expressions denoting sets strings simple familiar formalism specifying allowed values form fields 
demonstrate chapter 
powerforms declarative client side form field validation reasonable input formats captured manner 
underlying technology finite state automata gives simple efficient implementation strategy 
syntax define rich xml syntax regular expressions strings regexp const value empty charset value fix low intconst high intconst relax low intconst high intconst range low high intersection regexp intersection concat regexp concat union regexp union star regexp star plus regexp plus optional regexp optional repeat count intconst regexp repeat repeat low intconst high intconst regexp repeat complement regexp complement regexp exp regexp id regexp regexp regexp idref regexp uri include uri regexp denotes zero repetitions regexp nonterminals intconst usual meanings 
note verbose xml syntax allows standard perl syntax regular expressions construct regexp exp 
full syntax general includes intersection general complementation import mechanisms richer set primitive expressions 
regular expression associated form field declaration format name help error regexp format value optional help attribute appear status line browser field focus similarly value optional error attribute appear field contains invalid data 
format takes effect form field type type text password select radio attribute 
need input formats apparent text password fields need full generality section 

validation input formats semantics regular expressions regular expression denotes inductively defined set strings 
const element denotes singleton set containing value 
element denotes empty set 
element denotes set characters 
element denotes set strings 
charset denotes set characters value 
fix element denotes set numerals low high padded leading zeros length high 
relax element denotes set numerals low high 
range element denotes set singleton strings obtained characters low high 
intersection element denotes intersection sets denoted children 
concat element denotes concatenation sets denoted children 
union element denotes union sets denoted children 
star element denotes zero concatenations set denoted child 
plus element denotes concatenations set denoted child 
optional element denotes union set containing empty string set denoted child 
repeat element attribute count denotes fixed power set denoted child 
repeat element attributes low high denotes corresponding interval powers set denoted child low defaults zero high infinity 
complement element denotes complement set denoted child 
regexp element attribute exp denotes set denotes attribute value interpreted standard perl regular expression 
regexp element attribute id denotes set child addition names value id regexp element attribute idref denotes set regular expression name value idref 
required id value unique document idref value matches id value 
regexp element attribute uri denotes set recognized precompiled automaton 
include element performs textual insertion document denoted url attribute 
semantics format declarations effect form field regular expression denoting set defined follows 
text password field effect decorate field annotations green light current value member yellow light current value proper prefix member red light current value prefix member non empty empty set 
form submitted yellow red light 
default annotations placed immediately right field tiny icons inspired traffic lights customized arbitrary images chapter 
powerforms declarative client side form field validation green light yellow light red light traffic star check ok blank different styles status icons 
obtain different look feel indicated 
annotations colorings input fields reasonable current limitations technology impossible 
select field effect filter option elements allowing values members slight deficiency design singular select browser implementations show selected element 
account situation option allowed introduce extension standard html option value foo error legal irrespective format 
form submitted error option selected empty set 
radio field effect button depressed value member empty set form submitted button depressed 
note analogue error option case button depressed 
checkbox field effect button depressed value member mechanism possible create deadlocked form submitted 
simplest example assuming input field radio button group named foo input type radio name foo value aaa format name foo const value bbb format regardless radio button foo depressed foo satisfy requirements 
form submitted 
behavior exposes flaw design form inherent problem mechanisms 
examples reasonable data formats expressed regular expressions complicated 
simple example password format user 
validation input formats id registration seen characters alphabetic regexp id pwd intersection repeat low repeat complement star union range low high range low high union star complement intersection regexp alternatively perl syntax possible regexp id pwd intersection regexp exp complement regexp exp za complement intersection regexp enforce format existing form just add declarations format name password regexp idref pwd format format name password regexp idref pwd format user id registration 
web site show advanced examples legal dates including leap days uris time day 
final example consider simple format isbn numbers chapter 
powerforms declarative client side form field validation checking isbn numbers 
regexp id isbn concat repeat count concat range low high optional charset value optional concat repeat charset value concat regexp succinctly regexp id isbn regexp exp regexp input field exploits format enter isbn number input type text name isbn size format name isbn help enter isbn number error illegal isbn format regexp idref isbn format initially field yellow light 
status persists seen enter text legal prefix isbn number 
entering yields red light 
deleting character entering give legal value green light 
input field focus help string appears status line browser 
client attempts submit form invalid data field error text appears alert box 
isbn format includes checksums described complex regular expression yields state automaton 
full format accept digit correct checksum 
regular expression hardly written hand fact generated program 
precompiled automata may saved provided formats shows technology allows construct publish 
interdependencies form fields collection advanced default formats similarly datatypes employed xml schema predefined ctype formats suggested 
interdependencies form fields simple general mechanism expressing interdependencies 
develop purely declarative notation requires programming skills 
proposal dynamically evolving formats settled fixed point process 
syntax extend syntax formats follows format name format format format regexp format format format id format format format idref match name regexp match equal name value format applies field dependent values fields 
specification binary decision tree leaves regular expressions internal nodes boolean expressions 
boolean expression propositional combination primitive match equal elements test field indicated name 
simple language advanced required uses 
semantics boolean expressions boolean expression evaluates true false 
text password field equal true iff current value equals value match true iff current value member set denoted regexp 
field equal true iff value currently selected option equals value match true iff value currently selected option member set denoted regexp 
collection radio checkbox fields equal true iff button value equals value currently depressed match true iff button value member set denoted regexp currently depressed 
boolean operators true iff children true true children true true children false 
chapter 
powerforms declarative client side form field validation semantics interdependencies collection form fields 
fn associated formats values define iteration order fi evaluate current format current values form fields update field new current format 
updating varies type form field text field status light changed reflect relationship current value current format select field options filtered new format selected options longer allowed format unselected current selection singular select disallowed error option selected radio checkbox field depressed button released value longer allowed format 
iteration monotonic intuitively means delete user data 
technically iteration monotonic function specific lattice form status descriptions 
follows repeated iteration eventually reach fixed point 
fact total number radio checkbox buttons total number select options number singular selects iterations required 
usually fixedpoint stabilize iterations compile time dependency analysis keep number 
complex forms high degree interdependency require iterations 
behavior iterate new fixed point client changes input field furthermore form data submitted form fields status allows 
note fixed point obtain dependent order form fields updated permuting fields may result different fixed point 
choose update fields textual order appear document 
typically order client supposed consider resulting fixed point appears coincide intuitively expected behavior 
simpler forms order usually significant 
form interdependency possible create deadlocked form submitted create buttons depressed 
consider example section 
value aaa different bbb button instantly released depressed 
behavior course stem complicated interdependent behavior 
possible behaviors powerforms principle analyzed statically 
define size regular expression number states corresponding minimal deterministic finite state automaton size 
interdependencies form fields input field product sizes regular expressions may tested 
collection input fields fn determines finite transition system fn states reachability problem decidable hardly feasible practice 
leave web author avoid behavior 
examples example redo questionnaire attended past www conferences 
input type radio name past value input type radio name past value br www compare 
input type radio name compare value better better input type radio name compare value input type radio name compare value worse worse obtain desired interdependence declare format format name compare equal name past value complement const value complement empty format question answered positive may second group radio buttons may depressed answer required 
second example shows radio buttons may filter options selection favorite letter group input type radio name group value vowel checked vowels input type radio name group value consonant consonants br favorite letter select name letter option value option value option value 
option value option value option value select version form allows inconsistent choices group having value vowel letter having value add format format name letter equal name group value vowel charset value chapter 
powerforms declarative client side form field validation vowels 
charset value format apart enforcing consistency induced behavior sure client consistent options shown 
consider form personal info name input type text name name size br birthday input type text name birthday size br table border tr td top marital status td td input type radio name marital value single checked single br input type radio name marital value married married br input type radio name marital value widow widow er td tr table info name input type text name spouse size br deceased input type radio name deceased value deceased formats 
birthday select standard library state automaton recognizing legal dates including leap days format name birthday regexp uri www brics dk bigwig powerforms date dfa format fields obvious interdependencies 
info relevant marital status single spouse deceased marital status widow 
interdependencies form fields collecting personal information 
format name spouse equal name marital value married regexp idref handle equal name marital value single empty regexp idref handle format format name deceased equal name marital value widow const value deceased empty format handle refers regular expression names people 
note marital status changes widow single deceased button automatically released 
dually reasonable change single widow button automatically depressed 
action generally meaningful may cause form oscillate settings 
formalism violate monotonicity property guarantees termination fixedpoint iteration 
form submitted deceased button depressed widow 
initial form shown 
example complex boolean expression involves form 
simple formats determine correct style phone chapter 
powerforms declarative client side form field validation collecting customer information 
numbers chosen country 
option requesting visit nyc office open customers live new york city 
constraint enforced format format name nyc equal name country value match name phone concat union const value const value const value const value const value union concat match empty format residents cities find button 
final example detailed control offer consider form invites users request new version product 
client stated license impossible choose version 
choice licensed users choose versions limited versions 
format group radio buttons format name version equal name license value 
applet results collecting user information 
equal name license value union const value const value union empty format applet results java applets conjunction forms implement new gui components collect data client 
obvious extract validate data applet submit server equal footing ordinary form data 
propose simple mechanism achieving goal 
extend applet syntax allow result elements addition param elements 
example applet codebase www brics dk bigwig code class param name low value param name high value result name choice applet applet displayed shows slide bar ranging interval 
form submitted applet requested supply value choice result 
value assigned hidden form field named choice appear rest form data 
applet ready result form submitted 
extension works applets subclasses special class supply 
implements method applet programmer supply results methods getresult called javascript code implements form submission 
chapter 
powerforms declarative client side form field validation relation powerforms applet results play role input fields 
associated formats tested boolean expressions 
value optional error attribute appear alert box attempt submit form missing invalid applet result 
translation javascript powerforms document parsed liberal html grammar explicitly recognizes special elements format regexp 
generated html document retains original structure contains generated javascript code 
input field modified include functions react modifications client 
function update foo defined input field name foo 
function checks current data valid reacts accordingly 
function update responsible computing global fixed point 
regular expression compiler transformed minimal deterministic finite state automaton directly represented javascript data structure 
simple matter automaton checking data value valid 
text password fields status lights green yellow red correspond respectively accept state non accept state crash state 
efficiency generated automata time stamped cached locally recompiled necessary 
generated code quite small relies line standard library functions manipulating automata document object model 
availability powerforms system freely available open source distribution web site located www brics dk bigwig powerforms 
package includes documentation examples compiler written lines generated javascript code tested netscape unix windows explorer windows 
powerforms directly supported bigwig system high level language generating interactive web services 
likewise available www brics dk bigwig 
shown enrich html forms simple declarative concepts capture advanced input validation field interdependencies 
forms subsequently compiled javascript standard html 
allows design complex interesting forms avoiding tedious errorprone javascript programming 

entire bigwig team assisting experiments powerforms 
goes powerforms users particular frederik valuable feedback 
chapter static validation dynamically generated html anders ller michael schwartzbach describe static analysis bigwig programs efficiently decides dynamically computed xhtml documents client validate official dtd 
employ dataflow analyses construct graph summarizing possible documents 
graph subsequently analyzed determine validity documents 
evaluating technique number realistic benchmarks demonstrate sufficiently fast precise practically useful 
increasingly html documents dynamically generated scripts running web server instance php asp perl 
harder authors guarantee documents really valid meaning conform official dtd html xhtml 
static html documents easily validated tools available 
far best possibility script author validate dynamic html documents produced runtime 
incomplete costly process provide static guarantees behavior script 
alternatively scripts may restricted collection pre validated templates generally sufficiently expressive 
novel technique static validation dynamic xhtml documents generated script 
takes place context bigwig language full fledged programming language developing interactive web services 
bigwig xhtml documents class citizens subjected computations data values 
instrument compiler interprocedural data flow analysis chapter 
static validation dynamically generated html extracts grammatical structure called summary graph covering class xhtml documents program may produce 
information compiler statically determines documents class conform dtd xhtml 
accomplish need reformulate dtds novel way may interesting right 
analysis efficiently handled available examples 
furthermore technique generalized powerful grammatical descriptions 
outline section give brief dynamically generating xhtml documents bigwig language 
section formally defines notion summary graphs 
sections parts data flow analysis specified 
section notion dtds defined specifying xhtml 
section describes algorithm validating summary graphs respect dtds 
section evaluate implementation bigwig programs 
sections briefly describe related techniques plans ideas 
xhtml documents bigwig xhtml documents just xml trees 
bigwig language xml templates class data values may passed stored values 
templates general xml trees may contain gaps named placeholders plugged templates strings xml template gap named xml template text string plug operation results new template copy copy inserted gap bigwig service consists number sessions 
session thread invoked client subsequently guided number interactions controlled service code server 
document template gaps filled 
complete xhtml document built server shown client fills input fields selects menu options continues session submitting input session thread 
plug show mechanism provides expressive way dynamically constructing web documents 
described detail thorough comparison mechanisms aspects 
xhtml documents bigwig bigwig described 
templates plugged templates higher order templates opposed flexible templates mawl language strings plugged 
note number gaps may grow shrink result plug operation 
gaps may appear non local manner exemplified gap plugged template brics simple example actual bigwig syntax service html cover html head title welcome title head body bgcolor color contents body html html greeting html hello welcome 
html html person html stranger html session welcome html cover color ff contents greeting person show html brics html service contains constant templates session invoked assemble document plug operations show client 
note color attribute gap plugged string value gaps plugged templates 
constant templates delimited html html 
implicitly mandatory surrounding html element added document shown 
head title body elements form default submit button added 
simplify presentation distinguish html xhtml minor syntactical differences 
implementation allow html syntax convert xhtml 
note bigwig general languages producing xml trees possible define different element tiny template html ul style style items ul html corresponds constructor function 
typical larger templates convenience bigwig programmer 
chapter 
static validation dynamically generated html bigwig compiler contains interprocedural data flow analysis keeps track gaps input fields templates enable type checking plug show operations 
analysis statically ensures gaps performing plug operation input fields documents shown match code receives values 
validity documents shown considered bigwig knowledge programming language flexible document construction mechanism 
xml templates formally define xml template 
alphabet characters alphabet element names alphabet attribute names alphabet template gap names alphabet attribute gap names 
simplicity alphabets assumed disjoint 
xml template generated grammar xml template list ordered trees internal nodes elements attributes leaves empty nodes character data nodes gap nodes 
element attributes generated 
symbol represents arbitrary sequence character data 
ignore actual data constrained dtds attribute values accordingly represent explicitly 
example view cover template abstractly follows ignore character data nodes consisting white space introduce function head body bgcolor color title contents gaps 
xhtml documents bigwig gives set gap names occurring template attribute list gaps gaps gaps gaps gaps gaps gaps gaps gaps gaps gaps gaps gaps gaps template unique root element gaps considered complete document 
programs represent bigwig program abstractly control flow graph atomic statements program point 
actual syntax bigwig liberal resembles java code control structures functions 
bigwig simple task extract normalized representation 
underlying language richer control structure instance inheritance virtual methods higher order functions need preliminary control flow analysis provide control flow graph 
program uses set xml template variables set string variables 
atomic statements xi xj template variable assignment xi template constant assignment yi yj string variable assignment yi string constant assignment yi arbitrary string assignment xi xj xk template gap plugging xi xj yk attribute gap plugging show xi client interaction assignments obvious semantics 
plug statement replaces occurrences named gap value 
show statement implicitly plugs remaining gaps template displayed client 
template implicitly plugged wrapper template html head title title head body form action doc input type submit value continue form body html chapter 
static validation dynamically generated html completing document adding continue button 
head title body input elements course added 
ignore input fields documents receive part show statements omitted description 
summary graphs program control flow graph wish extract finite representation templates possibly constructed runtime 
program contains finite collection constant xml templates identified mapping function finite set indices templates occuring program 
program contains finite collection string constants shall denote define summary graph triple set roots set edges attribute labeling function 
intuitively denotes set strings 
summary graph defines set xml templates called language denoted 
intuitively set obtained unfolding graph root performing possible enabled edges labeling function 
formally define derivation relation defined templates attribute lists 
gap track analysis example consider summary graph consisting template nodes plug edges single attribute labeling large kind items ul class kind items ul items li text li items template nodes root nodes attribute labels drawn circles double circles boxes respectively 
language summary graph set ul lists class large character data items 
gap track analysis obtain sufficient precision actual validation analysis perform initial analysis tracks origins gaps 
show section exactly information necessary 
lattices lattice analysis simply text items ordered pointwise subset inclusion 
program point wish compute element derived lattice inherits structure intuitively element lattice tells variable gap name occur value constant templates originate 
transfer functions atomic statement defines transfer function models semantics forward manner 
argument results applying transfer function xi xj xi xj xi xi index xi xj xk xi xj xk xi xj yk xi xj auxiliary functions chapter 
static validation dynamically generated html gaps remaining statement types transfer function identity function 
function states gaps template originates just template 
function adds origins template inserted removes existing origins gap plugged 
analysis easy see transfer functions monotonic compute fixed point iteratively usual manner 
result program point environment track conservative upper approximation origins gaps 
omit proof correctness 
summary graph analysis wish compute program point variable summary possible values 
set xml templates represented summary graph set string values element lattices perform standard data flow analysis need representations lattices 
set clearly lattice ordered set inclusion top element 
set summary graphs called lattice ordering defined ordering lifted pointwise labeling functions 
clearly finite lattices 
program point wish compute element derived lattice env inherits structure constituent lattices 
transfer functions atomic statement defines transfer function env env models semantics 
argument pair functions entry program point statement results xi xj xi xj xi xi frag index yi yj yi yj 
summary graph analysis yi yi yi yi xi xj xk xi xj xk track xj xi xj yk xi xj yk track xj show xi auxiliary functions frag gi ri ei andg 
careful inspection shows transfer functions monotonic 
frag function constructs tiny summary graph language contains template 
function joins summary graphs adds edges relevant template gaps roots summary graph inserted illustrated follows function adds additional string values relevant attribute gaps position point need gap track analysis specified section 
initial analysis argument set constant template indices maintain soundness 
plugging value gap modeled adding edge nodes having gap nodes originate completely unrelated parts source code nodes gaps filled 
instance program building lists summary graph example section contain templates chapter 
static validation dynamically generated html gap named items requiring gap name appear constant template solve problem restriction limit flexibility document construction mechanism significantly 
rely program analysis disregard irrelevant nodes adding plug edges 
analysis working monotonic functions finite lattices standard iterative techniques compute fixed point 
proof soundness omitted similar 
result program point environment summary summary xi contains possible xml templates xi may contain 
templates associated show statements required validate respect xhtml specification 
assume implicitly surrounding continue button wrapper section added 
model implicit plugging empty templates strings remaining gaps statement show xi entry program point summary graph validate respect xhtml dtd close defined close summary xi track xi close assumed 
close function adds edges empty template remaining templates gaps adds empty string possibility remaining attribute gaps 
example revisited small bigwig example section summary graph describing document shown client inferred html 
html contents color ff head title welcome title head body bgcolor color contents body hello welcome 
stranger brics 
dtd xhtml expected simple case language summary graph contains exactly single template computed note xhtml template implicitly completed html fragment 
dtd xhtml xhtml described official dtd 
formalism ways restrictive strictly expressive 
case dtd xhtml captured restrictions merely appear comments official version 
define dtd quintuple set declared element names nis root element name ais indexed family attribute name declarations element name declarations family formulas 
represents arbitrary character data 
intuitively dtd consists number element declarations designated root 
element declaration consists element name set allowed attribute names set allowed contents formula constraining element respect attribute values contents 
formula syntax true attr content order ci value sk si define language follows gaps language set documents root element acceptance relation satisfied 
relation defined inductively templates follows names set chapter 
static validation dynamically generated html element checked attributes contents declared associated formula satisfied 
auxiliary functions names set formally defined names names names names names names set set set set set set set formulas relation defined relative attributes contents element true names attr exists word content word order names value sk si atts value sk attr formula checks attribute name content checks occurs contents 
value sk formula checks attribute values sk absent order checks occurence comes occurence contents sequence 
auxiliary functions atts word predicates exists formally defined atts atts atts atts atts atts 
dtd xhtml word word word word word word word exists wk wi wk wi wj common abbreviations unique order exclude content content exclude 
standard dtds restricted regular expressions describe content sequences 
boolean combinations basic predicates corresponds simple regular language 
expressive example express content sequence exactly occurrences element 
expressive dtds allow requirements contents attributes mixed formula 
formalism theoretically incomparable experience xml languages described dtds advanced schema languages typically scope notion 
examples xhtml dtd xhtml easily expressed formalism 
root element html examples declarations formulas html xmlns lang xml lang dir html head body html value dir ltr rtl content head content body unique head unique body order head body head lang xml lang dir profile head script style meta link object title base head value dir ltr rtl content title unique title unique base input id class style title lang xml lang dir type name value checked disabled readonly size src alt accept align input input value dir ltr rtl chapter 
static validation dynamically generated html value checked checked value disabled disabled value readonly readonly value align top middle bottom left right value type text password checkbox radio submit reset file hidden image button value type submit reset attr name instances able express requirements stated comments official dtd conjunct input 
full description xhtml available www brics dk bigwig xhtml 
exceptions bigwig situation bigwig allow non standard xhtml notation 
official dtd ul element required contain li element 
inconvenient items list generated iteratively vector may empty 
facilitate style programming bigwig allows empty ul elements removes runtime xhtml sent client 
accordingly dtd employ differs official respect 
similar exceptions allowed kinds lists tables 
implementation fragment removal rules specified way element constraints dtd xhtml essentially just moved dtd constraints separate file 
validating summary graphs show statement data flow analysis computes summary graph 
graphs decide validation requirement dtd 
root element name requirement checked separately verifying sub template template index perform checks element defined names attributes declared occurs content declared 
validating summary graphs validity relation true names attr occurs content order order names value sk si atts value sk atts sk value sk occurs function satisfying occurs occurs occurs occurs occurs occurs occurs occurs order restrictive function satisfying order true order order true order order true order order order occurs occurs errata unfortunately rules erroneous 
rules amended extending valued logic values know appropriate boolean connectives 
problem just true false predicate may hold conditionally presence negation implies conservatively answer 
instance case predicate content may hold depending templates plugged gap 
chapter 
static validation dynamically generated html definition validity relation straightforward 
duals definition acceptance relation section take gaps account 
auxiliary functions occurs order non trivial 
function occurs finds subset occur contents current element plugging gaps summary graph order checks possible obtain contents 
functions defined fixed points summary graphs may contain loops 
implementation ensure termination applying memoization numerous calls occurs order note validation algorithm sound complete respect summary graphs graph rejected language contains template language dtd 
validation analysis source imprecision data flow analysis constructs summary graph 
note notion dtds useful locality property requirements defined dtd specify properties single xml document nodes attributes contents requirement fulfilled summary graph possible give precise error message 
experiments validation analysis fully implemented part bigwig system monovariant data flow analysis framework 
applied available benchmarks shown table name lines templates size shows time chat guess calendar bachelor courses eatcs entries benchmark name lines code derived pretty print source macros expanded number templates size largest summary graph number show statements analysis time seconds mhz pentium iii linux 
errata due issues mentioned previous footnote validation sound complete 
encountered spurious errors practise dtd xhtml 

experiments chat benchmark simple chat service guess number guessing game calendar shows monthly calendar soccer match reservation system bulletin board service demonstration online shop conference administration system bachelor student management service courses course administration system eatcs collection services eatcs organization 
benchmarks taken bigwig documentation services currently developed brics 
analysis numerous validation errors benchmarks fixed yield services 
false errors reported 
seen table enhanced compiler remains efficient practical 
bachelor service constructs unusually complicated documents explains high complexity 
error diagnostics bigwig compiler provides detailed diagnostic messages case validation errors 
flawed example service html cover html head title welcome title head body color table contents table body html html greeting html td hello br clear clear welcome 
td html html person html stranger html session welcome html cover color ff contents greeting person clear show html brics html compiler generates messages single show statement brics wig html validation brics wig warning illegal attribute body template body color form form body chapter 
static validation dynamically generated html brics wig warning possible illegal subelement td table template table contents table contents td plugs contents brics wig brics wig warning possible element constraint violation br template br clear clear constraint value clear left right clear plugs clear brics wig error message line number xml element printed abbreviated form involved template names root elements template plugged gaps constraint violated line numbers involved plug operations 
reasonably precise error diagnostics clearly useful debugging 
related languages constructing xml documents consider validity 
xduce language functional language xml templates data types constructor element name pattern matching deconstruction 
type regular expression type inference pattern variables supported 
comparison richer language consequently need expressive types describe existence capabilities gaps 
simpler summary graphs 
rely type annotations 
perform interprocedural data flow analysis obtain high degree polymorphism difficult express traditional type system 
xm language compares similarly approach 
initial design bigwig template mechanism inspired mawl language 
main difference mawl allows strings plugged gaps 
validating mawl programs generate valid xhtml easy validating static documents simple document construction mechanism restrictive practical 
shown highly flexible mechanism require validity guarantees sacrificed 
web services currently written perl cgi embedded scripting languages asp php jsp server integrated modules instance apache 
common approaches inherent type system html xml documents 
general documents constructed concatenating text strings 
strings contain html xml tags attributes compiler interpreter completely unaware 
means formedness thatis tags balanced nested properly requirement validity difficult verify 
get free parsing individual constant xml fragments concentrate validity requirements specific dtds 

extensions common way programming services languages html xml constructor functions build documents abstractly trees strings 
style enforced language consistently formedness guaranteed 
difference bigwig bigwig templates may appear described section gives higher degree flexibility 
constructor style subsumed bigwig style described section summary graph technique applied languages 
extensions basic predicates allow general regular expressions alphabet validate summary graph reduce deciding general context free language subset regular language unwieldy algorithm compared simple transitive closures presently rely 
fortunately restricted regular languages appear sufficient 
possible include features richer xml schema language dsd particular context dependency regular expression constraints attribute values character data 
technique parameterized choice dtd easily generalizes xml languages described dtds 
enrich bigwig set operators combining deconstructing xml templates making general xml transformation language 
ideas readily permit analysis means summary graphs 
method translating dtd summary graph required 
combined data flow analysis generalized validation algorithm enable bigwig compiler guarantee html xhtml documents shown client valid official dtd 
analysis efficient generate spurious error messages practice 
furthermore provides precise error diagnostics case program fails verify 
algorithm parameterized dtd technique generalizes straightforward manner arbitrary xml languages described dtds 
fact handle expressive grammatical formalisms 
analysis proved feasible programs realistic sizes 
lends support unique design dynamic documents bigwig language 
chapter language caching dynamically generated html anders ller olesen michael schwartzbach increasingly html documents dynamically generated interactive web services 
ensure client newest versions documents customary disable client caching causing seemingly inevitable performance penalty 
bigwig system dynamic html documents composed higher order templates plugged construct complete documents 
show exploit feature provide automatic fine grained caching document templates service source code 
bigwig service transmits full html document compact javascript recipe client side construction document static collection fragments cached browser usual manner 
compare approach related techniques demonstrate number realistic benchmarks size transmitted data latency may reduced significantly 
central aspect development world wide web decade increasing dynamically generated documents html documents generated cgi asp php server time request client 
originally hypertext documents web considered principally static influenced design protocols implementations 
instance important technique saving bandwidth time clock cycles cache documents client side 
original protocol document rarely changes associated expiration time telling browsers proxy servers need reload document server time 
dynamically generated documents change chapter 
language caching dynamically generated html request feature disabled expiration time set benefits caching 
caching schemes consider dynamically generated documents non proposals attacking problem emerged 
described proposals typically applicable highly dynamic documents 
assumptions document dynamically generated construction server side effects instance request essentially database lookup operation clients provide arguments request dynamics limited rotating banner ads 
take step considering complex services essentially single document shown client unique construction side effects server 
typical example service web board current discussion threads displayed preferences user 
propose new caching scheme requiring intrusive modifications web architecture technique exploiting caches existing client side browsers resembling suggestions 
caching dynamically constructed html documents web services construct html documents sort constant templates ideally ought cached observed 
show condensed view typical html pages generated different bigwig web services 
column depicts dynamically generated raw html text output produced interaction benchmark web services 
non space character colored grey black 
grey sections appear constitute significant part characters originate large number small constant html templates source code black sections dynamically computed strings character data specific particular interaction 
lycos example simulates search engine giving results query caching dynamic objects bachelor service course roster generate list menus students plan studies service part conference administration system generates graphical schedule events service generates hierarchical list active discussion threads service generates lists participants course 
apart simulation examples sampled running services real data 
example dominated string data dynamically retrieved database seen included worst case scenario technique 
remaining suggests substantial potential gain caching grey parts 
main idea automatically source code web services exploit division constant dynamic parts order enable caching constant parts provide efficient transfer dynamic parts server client 
technique javascript shifting actual html document construction server client contributions 
lycos bachelor benchmark services grey vs dynamic black parts 
automatic characterization source code document fragments dynamic permitting standard browser caches significant effect dynamically generated documents compact representation information sent client constructing html documents generalization allowing group documents called document cluster sent client single interaction cached efficiently 
possible feasible due unique approach dynamically constructing html documents bigwig language foundation 
technique non intrusive sense builds preexisting technologies javascript special browser plug ins cache proxies server modules employed extra effort required service programmer 
result obtain simple practically useful technique saving network bandwidth cache mechanism modern web browsers 
outline section covers relevant related 
section describe bigwig approach dynamic generation web documents high level language html templates 
section describes actual document construction shifted server side client side 
section evaluate technique experimenting bigwig web services 
section contains plans ideas improvements 
chapter 
language caching dynamically generated html related caching dynamic contents received increasing attention years evident traditional caching techniques insufficient 
brief survey existing techniques related suggest 
existing techniques labeled dynamic document caching server proxy 
hpp language 
primary goal server caching techniques lower network load latency aim relieve server generated documents order avoid redundant computations 
techniques orthogonal propose 
server techniques services documents computed technique works services document unique 
presumably services mixture kinds different approaches support examine claim 
service programmer specifies simple cache invalidation rules instructing server caching module request dynamic document cached responses stale 
approach variant expressive invalidation rule language allowing classes documents specified arguments cookies client ip address technique provides complete api adding removing documents cache 
efficient low level approach extended object dependency graphs representing data dependencies dynamic documents underlying data 
allows cached documents invalidated automatically certain parts database modified 
graphs allow representation fragments documents represented technique caching client side 
related approach caching weave web site specification system described 
protocol proxy caching described 
resembles server techniques exploiting equivalences requests 
notion partial request equivalence allows similar non identical documents identified client quickly approximate response real response generated 
active cache powerful technique pushing computation proxies away server closer client 
document associated cache applet piece code executed proxy 
applet able determine document stale refresh 
document refreshed traditional way asking server extreme completely proxy involving server combination 
allows tailor caching policies compared server side approaches saves network bandwidth 
drawbacks approach requires installation new proxy servers serious impediment wide spread practical 
related general automatic mechanism characterizing document fragments dynamic requires tedious error prone programming cache applets non standard caching policies desired 
common techniques literature mentioned truly dynamic documents construction server side effects essentially unique contain common constant fragments cached require costly extra effort programmer explicitly programming cache 
furthermore techniques inherently server decrease network load require installation proxy servers 
delta encoding observation dynamically constructed documents fragments common earlier versions 
transferring complete document delta computed representing changes compared common base 
cache proxy full document regenerated near client 
compared active cache approach automatic 
drawback addition requiring specialized proxies necessitates protocols management past versions 
intrusions obviously limit widespread 
furthermore help repetitions single document 
repetitions occur naturally dynamically generating lists tables sizes statically known common web services produce html contents database 
repetitions may involve dynamic data database static markup lists tables 
hpp language closely related approach 
observation dynamically constructed documents usually contain common constant fragments 
hpp html extension allows explicit separation static dynamic parts dynamically generated document 
static parts document collected template file dynamic parameters separate binding file 
template file contain simple instructions akin embedded scripting languages asp php jsp specifying assemble complete document 
assembly caching templates done cache proxies browser java applets plug ins possible javascript 
essential difference hpp approach hpp solution integrated programming language web service 
possible combine hpp popular embedded scripting languages effort explicitly programming document construction remains 
approach source language meaning caching specifications automatically extracted web service source code compiler programmer required aware caching aspects 
regarding hpp advantage instructions describing structure resulting document located template file cached solution equivalent information dynamic file 
hpp constant fragments constituting document collected single template 
means chapter 
language caching dynamically generated html plug operator 
html fragments common different document templates reused cache 
solution fine grained caches individual fragments separately 
hpp templates highly specialized difficult modify reuse programmer 
fully automatic approach guarantees cache soundness 
analogously optimizing compilers claim bigwig compiler generates caching code competitive human hpp programmer achieve 
claim substantiated experiments section 
claim bigwig provides flexible safe easier template mechanism hpp embedded scripting language 
bigwig notion higher order templates summarized section 
thorough comparison various mechanisms supporting document templates 
mentioned compact javascript code combine cached dynamic fragments client side 
alternatively similar effects obtained browser plug ins proxies implementation installation difficult 
protocol introduces automatic compression general purpose algorithms gzip byte range requests advanced cache control directives 
compression features essentially orthogonal propose shown section 
caching directives provide features reminiscent javascript code require special proxy servers browser extensions apply caching dynamically constructed documents 
chosen java javascript javascript lightweight sufficient purposes 
dynamic documents bigwig bigwig web service programming language deals dynamic construction html documents called 
html fragments may contain gaps 
gaps runtime filled templates text strings yielding highly flexible mechanism 
bigwig service consists number sessions essentially entry points sequential action may invoked client 
invoked session thread local state started controlling interactions client 
built operations plug show form 
dynamic documents bigwig 
operation building documents 
illustrated operator takes templates gap name returns copy copy inserted gap 
template gaps considered complete document 
operation interacting client transmitting document client browser 
execution client session thread suspended server client submits reply 
document contains input fields show statement receive part receiving field values program variables 
mawl templates permits programmer designer tasks completely separated 
templates class values passed stored variables data type 
higher order templates plugged templates 
contrast mawl templates stored variables strings inserted gaps 
higher order nature mechanism flexible expressive compromising runtime safety compile time program analyses gap field analysis html validation analysis 
analysis guarantees plug designated gap runtime template show valid correspondence input fields document shown values received 
analysis guarantee document shown valid html specification 
variant known example illustrates concepts service html ask html 
input name html html hello html hello thing html session string show ask receive hello hello thing show hello html variables ask hello initialized constant html templates session declared 
entities html html merely lexical delimiters part actual templates 
invoked session shows ask template complete document client 
documents implicitly wrapped html element form default continue button shown 
client fills input field submits reply 
session resumes execution storing field value variable 
plugs value thing gap hello template sends resulting document client 
elaborate example remainder chapter 
language caching dynamically generated html service html cover html head title welcome title head body bgcolor color contents body html html greeting html hello welcome 
html html person html stranger html session welcome html cover color ff contents greeting person show html brics html builds welcome brics document plugging constant templates single text string shows client terminates 
higher order template mechanism require documents assembled bottom gaps may occur non locally instance gap show statement comes greeting template plugged cover template preceding statement 
existence statically guaranteed gap field analysis 
illustrate higher order templates expressive provide better compared order template mechanisms 
note asp php jsp fit firstorder category conceptually correspond having single order template special code fragments evaluated server implicitly plugged template 
consider unbounded hierarchical list messages typical web bulletin board 
easily expressed recursively small collection templates 
captured order solution casting templates strings losing type safety 
course willing fix length list explicitly template compile time expressed unbounded lengths 
case sharing repetitions html output sacrificed substantially cutting potential benefits caching 
shows benchmark appear generated entirely order templates 
dynamic documents bigwig hello welcome leaf greeting node node plug representation constituents 
outermost template remains message list produced big dynamic area 
nearly dynamic black compared higher order version displayed 
languages template mechanism perl simply generate documents low level print commands generally little structure output exploited caching purposes 
plug show mechanism bigwig successfully transferred advantages known static documents dynamic context 
step course caching 
dynamic document representation dynamic documents bigwig runtime represented data structure supporting operations constructing constant templates constant string plugging template plugging plug showing documents show 
data structure represents dynamic document binary dag directed acyclic graph leaves html templates strings plugged document nodes represent constructed document 
constant template represented ordered sequence text gap constituents 
instance greeting template brics example service represented displayed sequence containing gap entries text entries text gaps 
constant template represented memory shared documents plugged causing data structure dag general tree 
string plug operation combines dag constant string adding new string plug root node name gap illustrated 
analogously plug operation combines dags shown 
operations left branch document containing gap plugged right branch value plugged gap 
data structure merely records plug operations defers actual document construction subsequent show operations 
conceptually show operation comprised phases gap linking phase insert stack links gaps templates print traversal phase performs actual printing traversing gap links 
need stacks comes template sharing 
chapter 
language caching dynamically generated html color contents cover contents color ff greeting person brics anonymous fragment representation document shown brics example 
plug operations optimal complexities respectively lexical size document 
shows representation document shown brics example service 
simple example dag tree constant template 
note documents representation exponentially succinct expanded document 
instance case recursive function html tree int html list html ul li gap li gap ul html return html foo html return list gap tree ino time space produce document lexical size 
shows regarding network load highly beneficial transmit dag network resulting document ignoring cache aspects 
client side caching section show cache parts dynamically generated html documents store documents compact representation 
step direction move unfolding data structure server client 
transmitting unfolded html document server transmit representation document javascript link file containing generic javascript code interpret representation 
client side caching unfold document client 
caching obtained placing constant templates separate files cached browser files 
shall see section caching compact representation substantially reduce number bytes transmitted server client 
compromise course client clock cycles unfolding context fast client machines comparatively slow networks sensible tradeoff 
explained earlier client side unfolding computationally expensive task clients strained extra interpreted language javascript 
drawback approach extra tcp connections required downloading template files time keep connection alive feature 
worse downloading document images 
experiments show number transmissions interaction limited appear practical problem 
caching representation useful property explicitly maintains separation constant templates occurring document strings plugged document structure describing assemble document 
constituents depicted framed rectangles oval rectangles circles respectively 
experiments suggest templates tend occur documents shown client lifetime bigwig service occur times document different documents simply documents shown times 
strings structure parts typically dynamically generated change document 
templates account large portion expanded documents 
substantiated earlier explained 
consequently useful cache templates browser transmit dynamic parts strings structure show statement 
separation dynamic parts brics example illustrated 
mentioned solution place template file include link document sent client 
way caching mechanism browser ensure templates seen retransmitted 
time service shows document client browser obviously cached javascript template files documents shown client download fewer fewer files 
interactions client reaches point asymptotic caching constant templates cached dynamic parts downloaded 
chapter 
language caching dynamically generated html document structure color contents js js js js string pool ff dynamic document structure reply file 
color contents 
js js 
js js template files 
separation dynamic parts 
templates statically known compile time compiler enumerates templates generates file containing corresponding javascript code 
template numbers version numbers caching enabled recompilations templates modified 
contrast hpp approach entirely automatic 
distinction static dynamic parts structure identified compiler bigwig programmer gets benefits client side caching tedious error prone manual programming bindings describing dynamics 
compact representation show encode template files reply documents containing document representation 
reply documents transmitted show statement sizes small 
decompression conducted javascript interpreted browsers apply general purpose compression techniques 
exploit inherent structure reply documents obtain lightweight solution simple compact javascript representation string structure parts encoded decoded efficiently 
constant templates constant template placed file caching encoded call javascript constructor function takes number version template followed array text gap constituents respectively constructed calls javascript constructor functions instance greeting template brics example gets encoded follows hello welcome assuming version template number placed file called js 
gap identifiers replaced numbers respectively abstracting away identifier names 
note file needs downloaded client reused time template occurs document 

client side caching dynamics javascript reply files transmitted show contain document specific parts include directives loading javascript template files dynamic structure showing assemble document string pool containing strings document 
structure part representation encoded javascript string constant scheme tuned kinds dags occur observed benchmarks 
empirical analyses exposed interesting characteristics strings document relatively short occur times urls common prefixes 
strings quite short placing individual files cached transmission overhead 
reasons security want bundle strings string pool files 
multiple occurrences suggests collect strings document string pool inlined reply file sent client 
string occurrences document designated offsets pool 
common prefix sharing suggests collect strings trie precisely yields sharing common prefixes 
example strings foo www brics dk bigwig www brics dk bigwig misc gifs bg gif www brics dk bigwig misc gifs bigwig gif linearized represented follows foo www brics dk bigwig misc gifs gif gif applying trie encoding string data benchmarks observe reduction ranging bytes bachelor bytes 
reply document transmitted client show statement brics example looks html head script src www brics dk bigwig js script script script script ff script head body body html document starts including generic javascript library js unfolding representation 
file shared services downloaded client cached service interaction 
reason put effort writing chapter 
language caching dynamically generated html compactly 
include directives encoded calls function argument array designating template files included document version numbers 
constructor function reconstructs string trie example contains string plugged document ff 
expected document structure part reconstructed constructor function humanly readable uses extended ascii set encode dynamic structure 
arguments bytes encoding node number templates plus plug nodes number gaps respectively 
line document calls javascript function interpret constituents expand document 
document fully replaced expansion 
note script sections required ensure processing occurs distinct phases dependencies resolved correctly 
viewing html source browser display resulting html document encodings 
compact representation attempts actual compression gzip xml compression highly efficient encode server decode javascript client 
compression essentially orthogonal sense representation works independently transmission protocol compresses documents sent network shown section 
benefit factor scheme course reduced compression added 
clustering bigwig operation restricted transmit single document 
collection interconnected documents called cluster 
instance document input fields combined cluster separate document help information fields 
hypertext document cluster may created notation refer document held html variable time cluster shown 
showing document containing client browse individual documents involving service code 
control flow service code clear interconnections set cluster single document internal links 
example shows set cluster documents input help cyclically connected input main document service html input html please enter name input name name click href help help 
html html help html enter name family name nickname 

experiments href back back form 
html html output html hello name html session cluster example html string help back input help show receive name show output name cluster mechanism gives unique opportunity reducing network traffic 
encode entire cluster single javascript document containing documents cluster interconnections 
document original cluster generate javascript code overwrite current document browser referenced document cluster 
course need add code save restore entered form data client leaves re enters pages forms 
way takes place client browser server involved client leaves cluster 
experiments experiments performed 
applied caching technique web service benchmarks mentioned 
show sizes data transmitted client 
grey columns show original document sizes ranging kb 
white columns show sizes total data transmitted technique exceeds kb 
ultimate interest black column shows asymptotic sizes transmitted data templates cached client 
case see reductions factors compared original document size 
lycos benchmark similar hpp reconstruction course bigwig 
seen size residual dynamic data bytes virtually identical obtained hpp bytes 
solution caching aspects hand coded benefit human insight automatically generated bigwig compiler 
benchmarks challenging hpp 
repeat comparisons assumption data transmitted compressed gzip 
ofcourse drastically reduces benefits caching technique 
see asymptotic reduction factors suggesting chapter 
language caching dynamically generated html approach remains worthwhile circumstances 
clearly documents asymptotic reduction factors arbitrarily large large constant text fragments count zero side scales gzip compress certain size 
feel justified claiming compression orthogonal approach 
protocol supports compression represent string pool naive fashion trie gzip better job plain string data 
note cases uncompressed residual dynamic data smaller compressed version original document 
quantify latency technique 
total download rendering times services shown standard documents cached versions 
client internet explorer running mhz pentium iii windows pc connected server modem isdn modem 
realistic configurations august vast majority internet subscribers dial connections situation change significantly couple years 
times averaged downloads plus renderings browser caching disabled 
expected yields dramatic reduction factors modem 
isdn modem factors reduce 
worst case example benefits setup 
higher bandwidth dimensions results course impressive 
focus pure rendering times obtained averaging document accesses plus renderings initial download caching browser 
benchmarks times fact bit faster original html documents 
generating large document faster reading memory cache 
benchmarks somewhat slower 
figures course highly dependent quality javascript interpreter available browser 
compared download latencies rendering times negligible 
visualized 
describe ideas cutting number bytes files transmitted server client 
services certain templates occur show statements 
templates grouped file caching lowering transmission overhead 
bigwig html validation analysis approximates graph readily derive set templates reach show statement 
sets analyzed tightly connected templates various heuristics 
certain security concerns need taken consideration 
idea indirectly disclose template cache bundle show statement directly include 
original original dynamics dynamics 
kb lycos kb lycos sec lycos sec msec lycos lycos bachelor bachelor gzip size bachelor modem download rendering bachelor download rendering bachelor pure experiments template representation 
possible introduce language server side caching complementary client side caching 
idea exploit structure bigwig programs automatically cache invalidate documents generated 
resembles server side caching techniques mentioned section 
technique existing client side caching mechanisms context dynamically generated web pages 
approach programmer need aware caching issues decomposition pages dynamic parts performed automatically compiler 
resulting caching policy guaranteed sound experiments chapter 
language caching dynamically generated html show results significantly smaller transmissions reduced latency 
technique requires extensions existing protocols clients servers proxies 
exploit browser interpret javascript code 
results lend support unique design dynamic documents bigwig 
chapter growing languages metamorphic syntax macros michael schwartzbach main goal designing language plan growth guy steele growing language oopsla invited talk 
experiences syntax macro language claim forms general abstraction mechanism growing domain specific extensions programming languages 
syntax macro language designed guarantee type safety termination 
concept allows arguments macro inductively defined meta level grammar morphed host language 
show operate simultaneously multiple parse trees accept parse trees arguments 
result highly flexible mechanism growing new language constructs resorting compile time programming 
fact new languages defined surprisingly low cost 
fully implemented part bigwig system defining interactive web services find languages 
compiler syntax macros accepts collections grammatical rules extend syntax subsequent program may written 
long advocated means extending programming languages 
interest domain specific customizable languages poses challenge macros realize new language concepts constructs grow entire new languages 
chapter 
growing languages metamorphic syntax macros existing macro languages unsafe expressive live challenge syntax allowed macro invocations restrictive 
macro languages resort compile time meta programming making difficult safely 
propose new macro language sufficiently expressive entirely simple declarative concepts grammars substitutions 
contributions macro language design guaranteed type safety termination macro expansion process concept allow user defined grammar invocation syntax mechanism operating simultaneously multiple parse trees full efficient implementation syntactically rich host language survey related identifying classifying relevant properties carried context bigwig project find uses host languages top parser constructed 
application approach knowledge host grammer required 
special properties grammar 
fact possible build generator host grammar automatically provide parser supports notion syntax macros 
related survey contains detailed survey predominant macro languages previously proposed 
closely investigated macro languages individual semantic characteristics preprocessor cpp unix macro preprocessor tex built macro mechanism macro mechanism dylan templates scheme hygienic macros macro mechanism jakarta tool suite jts meta syntactic macro system ms 
system version dylan macros adapted java treated independently 
survey led identify group properties characterize macro language think relevant comparing 
macro language designed explicitly considering exactly properties comparison included column survey table 

related survey property language cpp tex dylan templates scheme jts ms bigwig level operation lexical lexical lexical hybrid syntactical syntactical syntactical syntactical syntactical language dependent programmable constant folding definition keyword define define def define macro template define syntax macro syntax macro formal argument def id id id id id nt id id nt id nt id id nt id id nt id formal argument id id id id id id id invocation syntax id id id id id id id id id 
argument types declared implicitly argument nonterminals token id type const exp argument types checked result types declared implicitly result nonterminals stm def decl exp result types checked multiple definitions definition selection order listed specificity order listed specificity definition scope pass pass pass pass pass pass pass pass pass redefine redefine redefine local macro definitions direct recursion rejected indirect recursion argument structure fixed fixed fixed grammar fixed list fixed option list tuple grammar body expansion lazy eager lazy lazy lazy lazy eager eager eager order expansion outer outer inner outer inner parsing ambiguities shortest shortest greedy greedy hygienic expansion macros results guaranteed termination transparent error trailing pretty printing package mechanism gen syntax type definition invocation macro language survey 
impl 
chapter 
growing languages metamorphic syntax macros general properties paramount characteristic macro language operates lexical syntactical level 
lexical macro languages allow tokens substituted arbitrary sequences characters tokens 
definitions may parameterized substitution sequence contains placeholders actual parameters just arbitrary character sequences 
cpp known lexical macro languages 
conceptually lexical macro processing precedes parsing ignorant syntax underlying host language 
fact cpp language independent preprocessors concept host language 
direct consequence syntactic independence lexical macro languages share dangers avoided clever hacks workarounds folklore 
representative example square macro define square works expected cases 
invoked argument result character sequence interpreted 
solution particular problem explicitly add parentheses arguments control subsequent parsing define square subtle problem arises invoking macro define swap int context swap program gives unexpected parse error statements keywords 
compound statement expansion swap macro second empty statement semicolon invocation swap macro 
workaround employed skilled cpp programmers rewrite macro body construct terminating semicolon constant false condition define swap int invocations swap macro safely terminated semicolon expanding statement 
kind low level issues plague lexical macro programmers 
contrast syntactical languages operate parse trees depicted course requires knowledge host language grammar 
syntactical macro languages include templates scheme jts 
related survey original macro program definition repeats expanded program repeats repeats syntax macros operators parse trees 
ms language dylan hybrid operates simultaneously token streams parse trees 
macro languages allow explicit programming parse trees constructed pattern matching substitution 
cpp allows simple conditionals offers simple arithmetic templates performs constant folding multiple definitions provide turing complete compile time programming language scheme ms allow arbitrary computations 
syntax properties syntax defining invoking macros varies greatly 
main point interest liberal invocation syntax allowed 
spectrum cpp requires parenthesized comma separated actual arguments dylan allows arbitrary invocation syntax initial identifier 
type properties notions type conjunction syntactical macro languages result types argument types ranging nonterminals host language grammar 
explicitly declared naming nonterminals standardized host language grammar 
syntactical macro languages possibility type checking definitions invocations 
definitions may checked comply declared nonterminal return type macro assuming placeholders types dictated arguments 
invocations may checked ensure arguments comply declared types 
argument type information guide parsing case check comes free 
checks performed parse errors occur direct consequence macro expansion 
jts ms take full advantage possibility 
mentioned fall short various ways example checking macro body conforms result nonterminal 
languages differ nonterminals host grammar types 
chapter 
growing languages metamorphic syntax macros definition properties relevant properties macro definitions 
languages dylan cpp allow macro defined name invocation selects appropriate definition trying order listed notion specificity 
macro languages pass scope rules macro definitions meaning macro visible lexical point definition onward 
ms employs pass strategy macro definitions available lexical point definition 
pass scope rules order macros defined significant scope rules macro definitions may viewed set 
nice property definition order rearranged affecting semantics 
completely true ms integrated compile time programming language pass scope rules 
languages allow macros undefined redefined course sense presence pass scope rules 
languages permit local macro definitions cpp dylan concept 
kinds macro recursion direct indirect 
direct recursion occurs body macro definition contains invocation 
causes non termination 
indirect recursion occurs self invocation created expansion 
result compile time language creating self invocation result expansion expansion strategy see 
compile time programming language side effects break recursion indirect recursion causes non termination 
generalizes straightforwardly mutual recursion 
languages tolerate form macro recursion cpp jts completely explicitly avoid recursion 
important issue argument structure allowed 
languages require fixed number arguments macro 
scheme allows lists arguments ms allows lists tuples optional arguments dylan flexible allowing argument syntax described user defined grammar 
invocation properties macro body may contain macro invocations 
languages evenly split macro body expanded eagerly definition lazily invocation 
eager strategy find errors macro body definition time macro invoked 
similarly actual arguments may contain macro invocations languages split inner outer expansion strategy 
cpp complex strategy known argument 
macro invocation discovered arguments parsed macros inside invoked 
expanded arguments substituted placeholders copy macro body 
entire result processing newly produced macro invocations 
note strategy 
designing macro language sense lexical macro languages 
languages allow liberal invocation syntax arguments properly face ambiguities deciding match actual formal macro arguments 
lexical languages tex dylan resolve ambiguities chosing shortest possible match contrast syntactical language ms employs greedy strategy formal argument parses possible 
languages investigated employed back tracking matching invocations definitions 
syntactical languages automatic conversion obtain hygienic macros ms requires explicit renamings performed programmer 
languages allow new macro definitions generated macro expansions 
cpp jts guarantee termination macro expansion fail naive treatment recursive macros allowing arbitrary computations expansion 
implementation properties macro languages generally designed transparent meaning subsequent phases compilation need aware macro expansions 
apart scheme allow pretty printing unexpanded syntax error trailing meaning errors subsequent phases traced back unexpanded syntax 
package concept macros considered scheme 
related macro language shares features previous extensible syntax macro language 
framework defining new syntax represented parse tree data structures target language type checking code generation performed 
contrast new syntax directly translated parse trees host language 
host language syntax available equal footing new syntax 
expressiveness extensible syntax permitted close argument syntax allow technical differences including definition selection parsing ambiguities expansion strategy error trailing 
allow general translation scheme 
designing macro language ideal macro language allow nonterminals host language grammar extended arbitrary new productions defining new constructs appear programmer part original language 
macro languages seen previous section approximate better 
section aim come close ideal practically possible 
take step allowing programmer define chapter 
growing languages metamorphic syntax macros new nonterminals 
goal obtain safe macro language type checking termination guaranteed 
carefully consider semantic aspects identified design 
syntax syntax macro language looks follows macro macro id param body param token id syntax macro constituents result type nonterminal host grammar identifier naming macro parameter list specifying invocation syntax body comply result type 
result type declares type body syntactic contexts invocations macro permitted 
adhering tennent principle abstraction allow range nonterminals host language grammar 
course nonterminals particular standardized grammar 
case bigwig host language nonterminals available 
ms macro start identifier 
technically possible lift restriction serves macro invocations easier recognize 
parameter list determines rest invocation syntax 
allow arbitrary tokens interspersed arguments identifiers typed nonterminals 
list ends token 
macro body enclosed braces conforms result type arguments identifiers angled brackets 
simple examples simplest possible macro arguments macro pi invocation pi allowed places may appear 
macro takes argument executes probability macro stm stm random interesting invocation syntax macro stm repeat stm exp bool true 
designing macro language false extends host language repeat construct looks feels exactly real thing 
identifiers repeat treated keywords scope macro definition 
semantic correctness course relies conversion 
incidentally macro 
example multiple definitions supplies syntax existing constructs macro stm si exp stm macro stm si exp stm stm definitions named si different parameters 
macro packages macros enrich host language potentially create confusion 
avoid problem created simple mechanism scoping packaging macro definitions 
package containing macro definitions viewed set pass scope rules definitions visible order insignificant 
dependency analysis intercepts rejects recursive definitions 
package may require extend packages 
consider package contains set macro definitions requires package extends package definitions visible inside bodies macros exported require obtaining local macros 
strict view package defines set eliminates potential problems confusions 
parsing definitions macro definitions parsed passes yielding set definitions 
macro headers collected structure guide parsing invocations 
bodies discover macro invocations dependency graph constructed 
second macro bodies parsed topological order respect dependencies 
ensure termination intercept reject cycles 
result body parse tree conforms result type contains placeholder nodes occurrences arguments 
checked body derived result nonterminal chapter 
growing languages metamorphic syntax macros placeholders assumed derived corresponding argument nonterminals 
note yields eager expansion strategy allowing parse errors macro body reported definition time 
parsing invocations macro invocations detected occurrence identifier naming macro 
point parser determines result type macro reachable current point parsing 
parsing aborted 
parsing guided nonterminal invocation parsing begins 
result parse tree inserted place invocation 
invocation parsing conducted interpreting macro parameter list matching required tokens collecting actual argument parse trees 
parameter list reached actual arguments substituted placeholders copy macro body 
process commonly referred macro expansion 
parsing greedy actual argument parsed far possible usual top parsing style 
basic mechanism powerful handle multiple definitions macro yields flexible invocation syntax crucial 
purpose interpret set parameter lists 
base definition selection concept specificity independent macro definition order 
done gradually challenging parameter list input tokens 
cases challenge list empty survives list starts token survives equals input token list starts argument survives input token belongs host grammar 
parameter lists may survive challenge 
keep specific ones 
empty list eliminated lists empty 
set non empty lists survivors parameter maximal ordering defined token singleton token host grammar 
tails surviving lists challenged input token 
intuition notion specificity summarized rules thumb prefer longer parameter lists shorter ones prefer token nonterminal prefer narrow nonterminal wider 
rule reason dangling problem example solved correctly 
strategy far reaching generality works metamorph rules introduced section 
example illustrates invocations parsed 
consider macro definitions 
designing macro language macro exp sync id 
macro exp sync exp 
macro exp sync exp 
macro exp sync 
parse sync 
challenge round situation sync id sync exp sync sync exp sync macro headers survive match sync token 
challenge round sync id sync exp sync sync exp sync shortest macro header loses prepared carry token 
round sync id sync exp sync exp sync sync macro headers survive match token tokens general exp non terminal 
fourth challenge round agree survive sync id sync exp sync sync exp sync fifth challenge round chapter 
growing languages metamorphic syntax macros sync id sync exp sync exp sync sync macro header declared winner matches token non terminal id id exp id exp 
chosen macro header survives remaining token expansion performed 
order expansion chosen inner strategy 
macros terminating expansion order semantically transparent apart subtle difference respect conversion 
inner strategy efficient arguments parsed 
formedness set macros name formed 
means result type 
restriction relaxed allow different return types macros name contravariant specificity ordering determine invoke 
furthermore guarantee challenge rounds described unique final winner impose requirement pairs parameter lists form equals equal 
hygienic macros achieve hygienic macros automatically convert identifiers inside macro bodies expansion 
scheme convert free identifiers guaranteed bind sensible context invocation 
convert identifiers macro needs recognize parse tree nodes nonterminal id symbol table information required 
communicate identifiers invocation context encourage macro programmer supply explicitly arguments type id unsafe free variable required avoid conversion 
necessary computed identifiers seen 
purpose introduce injective associative binary concatenation operator identifiers 
inductive predicate determines identifier converted false false argument type id 
growing language concepts true 
example illustrates effect conversion macro expansion repeat repeat bool true bool true false false growing language concepts macro language allows host language grow simply handy abbreviations new concepts constructs 
host language bigwig designed programming interactive web services general mechanism providing concurrency control session threads 
programmer may declare labels code temporal logic define set legal traces entire service 
bit harsh average programmer consequently opportunity macros 
shows stack increasingly high level concepts introduced top possibility define macros nonterminals host language 
details bigwig syntax need understood 
allow forbid macros abbreviate common constructs temporal logic produce results type formula 
macro region type toplevel different introduces new concept regions declared equal footing native concepts 
exclusive macro type stm defines new control structure secures exclusive access previously declared region 
resource macro type toplevel list declares instance novel concept macros reader writer realizes reader writer protocol specified resources 
protected macro seemingly provides modifier allows declared variable subject protocol 
macros build top produce levels abstraction depicted 
similar development implemented primitives semaphores monitors fifo pipes 
demonstrates host language highly tailorable simple means 
bigwig language employs extensive collection predefined macros enrich core language 
chapter 
growing languages metamorphic syntax macros 



reader protected resource region mutex forbid allow bigwig core language writer exclusive stack macro abstractions 
example program high level abstractions service protected shared int counter html doc html visitor number number html session access html reader counter doc number counter writer counter counter exit program web service shows page ubiquitous page counter declared protected macro 
client issues request run session access value counter read inside reader region document showing value assembled 
subsequently counter incremented writer region 
document transmitted client 
macro definitions specify important aspects syntax definitions characterizing syntactic structure invocations syntax transformations specifying new syntax morphed host language syntax 
far macros finite invocation syntax fixed number arguments described host grammar nonterminal 
move limitation focusing initially syntax definition aspects 

previously notion multiple definitions allow macros varying arity 
example defines enum macro known takes identifier arguments macro decls enum id const int macro decls enum id id const int const int macro decls enum id id id const int const int const int evidently possible define macros arbitrary arity specifications exhibit high degree redundancy 
terms syntax definition enum definitions correspond adding unrelated right hand side productions nonterminal decls decls enum id enum id id enum id id id scheme introducing special ellipsis construction specify lists nonterminal expressions 
ms moves step permitting tuples optional arguments corresponding allowing regular expressions terminals nonterminals host grammar right hand sides productions 
ubiquitous ebnf syntax available designating options lists tuples grouping 
addition ms provides convenient variation kleene star specifying token separated lists nonterminals 
notation comma separated repetitions nonterminal enum macro defined construction corresponds extending grammar follows decls enum id dylan language taken full step allowing programmer describe macro invocation syntactic structure user defined grammar permitting new user defined nonterminals 
context free language approach clearly general regular language approach handle balanced tree structures 
enum invocation syntax described grammar fragment introduces user defined nonterminal called enums underlined readability chapter 
growing languages metamorphic syntax macros decls enum id enums enums id enums dylan result parsing user defined nonterminal yields result substituted macro body 
result unparsed chunk tokens associated lexical macro language pitfalls 
want combine great definition flexibility type safety 
need way specifying checking type result parsing user defined nonterminal 
clearly nonterminals exist equal footing host language syntax macro ultimately produce host syntax return user defined asts 
associate user defined nonterminal host nonterminal result type resulting parse tree derived 
syntax defined user defined nonterminals morphed directly host syntax 
specification morphing inductively production grammar 
contrast ms relies programming computation specifying transforming regular expressions nonterminals parse trees 
distinguish clearly host grammar call user defined nonterminal productions typed host nonterminals 
rule specifying macro syntax morphed host language syntax 
syntax macro definitions generalized follows accommodate macro macro id param body metamorph id param body param token id id id introduced new constructs 
parameter may form na meaning named invocation syntax described metamorph nonterminal result type metamorph syntax inductive translation host language described metamorph rules 
left token result type name metamorph nonterminal right parameter list defining invocation syntax body defining translation host language 
metamorph rules may define arbitrary grammar 
full generality metamorph rule may produce multiple results defined separate body 
ready define general enum macro macro language 
production rules translates definitions macro decls enum id enums decls ds int const int ds 
metamorph decls enums id enums decls ds const int ds metamorph decls enums metamorph argument enums decls ds describing piece invocation syntax generated nonterminal enums metamorph grammar 
enums parse trees materialized instantly morphed parse trees nonterminal decls host grammar 
body enum macro commences declaration variable enumerating declared variables runtime 
declaration followed morphing identifier constant integer declaration initialization expression 
comes ds decls result remaining identifiers constant integer declarations 
productions enum grammar translates metamorph definitions 
take comma identifier followed metamorph argument morph identifier constant integer declaration return matched metamorph invocation 
second metamorph definition offers termination condition parsing returning empty declarations 
simplicity constant integer declarations bodies rules identical 
alleviated placing constant declaration body macro introducing returning declaration place identifiers 
statement syntax easily captured desugared nested statements macro stm switch exp stm typeof metamorph stm case exp stms ss break stm ss metamorph stm case exp stms ss break ss chapter 
growing languages metamorphic syntax macros parsing invocations strategy parsing invocations unchanged 
order generalized appropriately defining na metamorph grammar 
note possible abbreviate part invocation syntax introducing new metamorph nonterminal preserving semantics 
formedness syntax macros set productions metamorph nonterminal formed 
furthermore ensure termination greedy strategy prohibit left recursion metamorph grammar 
include sanity check metamorph nonterminal derive finite string 
hygienic macros metamorph productions initiate conversion 
done entire body syntax macro conceptually metamorphic arguments substituted 
seen enum example expansion enum int const int const int resulting parse tree local occurrence converted necessary yield proper semantics 
multiple results full generality metamorph production may morph invocation syntax resulting parse trees host grammar 
seen generalization divert primitive solution statically guarantees type safety combined result 
metamorph rules metamorph formals extended cope multiple returns arguments macro metamorph id param body param id id example illustrates simple way multiple metamorph results add expressive power macro language 
define macro reserve takes variable number identifiers denoting resources statement 
macro abstraction acquire resources order listed execute statement release resources reverse order 
macro stm reserve id res stms ss stms ss stm acquire ss ss release metamorph stms stms res id res stms ss stms ss 
metamorph arguments acquire ss ss release metamorph stms stms res definitions macro expands follows reserve db master slave acquire db acquire master acquire slave release slave release master release db multiple results transformations impossible require encodings 
metamorph arguments possible add typed arguments retaining safety 
permits context sensitive transformations sense parse trees may constructed supplied inner metamorph invocations 
extend syntax metamorph definitions follows macro metamorph id formals param body param id id actuals formals id id actuals body motivate simple example illustrating extension assume base language allow side effects initialization expressions 
longer expression 
inductively build appropriate constant expression passed argument macro decls enum id enums decls ds const int ds metamorph decls enums exp id enums decls ds const int ds metamorph decls enums exp variation enum macro obtain expansion chapter 
growing languages metamorphic syntax macros enum const int const int const int const int involved ambitious applications arguments play roles syntactic continuations 
growing new languages section contains examples macros enrich host language new concepts constructs 
radical particularly design implement completely new language little cost 
host language bigwig domain specific language designed facilitate implementation interactive web services 
program family highly specialized services advantageous define shall call domain specific language 
consider concrete example 
university aarhus undergraduate computer science students complete bachelor degree fields 
requirements satisfied surprisingly complicated 
guide students goal maintain called bachelor contract plans remaining studies discovers potential problems 
process supported web service student iteratively accepts past course activities checks requirements diagnoses violations legal contract composed 
service written straight bigwig application quickly annoying maintain 
redesigned form study fields requirements conceptualized defined directly pseudo natural language style 
possible secretary responsible faculty member maintain update service 
shows example input 
single macro studies accepts argument entire specification syntax defined metamorph rules 
result corresponding bigwig service 
apart keyword require syntax shown native bigwig 
file bach lines contains complete implementation new language including parser code generator 
macro mechanism offers rapid inexpensive realization new ad hoc languages arbitrary syntax 
error trailing unexpanded pretty printing supports illusion genuinely new language provided 
implementation fully implemented bigwig compiler 
implementation extensive support cpp available bigwig project homepage open source distribution 
important aspects implementation achieve transparency phases compiler 
transparent 
implementation inv 
arg 

ordinary 
inv 
arg 

weaved macro representations 
representation macros generic pretty printer responsible communicating macro conscious information 
aspects support illusion host language really extended 
transparent representation consider macro definition macro ids ids representation parse tree identifier list seen 
node kinds parse tree capable holding explicit macro nodes inv arg 
representation yields perfectly balanced structure complete knowledge scope macro invocations arguments 
clearly transparent subsequent phases compiler 
transparency achieved weaving phase new pointers parsing macro nodes giving ways traversing parse tree 
macro conscious phases follow paths macro ignorant phases see new short circuited paths 
desugaring fully compatible preserving macro information sense transparency completely achieved 
explicit desugaring really necessary compiler supports metamorphic syntax macros handled macros 
generic pretty printing indent directives control pretty printing macros param macro header augmented whitespace newline indent directives 
pretty printer instructed print si statement spaces conditional expression newline alternate branch macro stm si exp stm stm 

chapter 
growing languages metamorphic syntax macros html pretty print error message 
sophisticated correctly renders switch control structure macro stm switch exp stm 
extensions purely cosmetic semantics attached ignored invocation challenge rounds 
implementation supports generic nonterminal pretty printer specific terminal pretty printer code macro expansion 
depends choice arrows 
implementation currently terminal pretty printers printing ascii latex javascript far sophisticated 
inserts def hyperlinks visualizes expression types highlights errors expands individual macros click button 
error reporting generic pretty printing strategy error reporting special case pretty printing special kind terminal printer print nodes non empty error string 
consequently error messages viewed macro expansion 
shows simple error unexpanded syntax 
compiler instructed dump error trail follows symbol errors bach wig identifier cs declared macro argument macro invocation course ids bach wig defined bach macro argument macro invocation cons bach wig defined bach macro argument macro invocation cons list bach wig defined bach macro argument cn macro invocation fields bach wig defined bach macro argument macro invocation studies bach wig defined bach useful debugging macro definitions 

designed implemented safe efficient macro language sufficiently powerful grow domain specific extensions host languages entire new languages 
avenues 
take approach defining notion invocation constraints restrict possible uses macros 
constraints capture aspects static semantic analysis language extensions grown 
constraints exclusively parse tree similarly preserve transparency 
second build implementations host languages particular java 
third possible create parser generator host grammar builds parser automatically supports metamorphic syntax macros 
required techniques implementation 
acknowledgments authors anonymous referees tommy thorn eric kidd peter don batory roger crew daniel weise entire bigwig team helpful discussions 
macro formula allow id formula restrict macro formula forbid id formula allow macro formula mutex id id forbid macro toplevel region id constraint label mutex macro stm exclusive id stm wait wait tb macro resource id region constraint 
macro stm reader id stm wait wait macro stm writer id stm wait exclusive macro protected type id resource concurrency control abstractions require bach studies course math title mathematics points fall term course phys title physics points spring term course lab title lab point fall term exclusions math math prerequisites math math math math math math cs cs cs cs math cs cs math stat cs cs cs cs cs cs phys phys phys phys phys phys phys phys phys lab lab lab lab lab lab lab lab lab lab lab lab lab field cs math field courses math math math math stat cs cs cs cs cs cs cs cs cs cs project courses math math phys phys phys phys constraints passed cs cs courses cs cs cs math math courses stat math math points project cs cs total points field cs physics field courses stat cs cs cs cs cs cs cs cs cs cs project phys phys phys lab lab lab lab courses phys phys phys phys phys lab lab lab lab math math math constraints passed cs cs courses cs cs cs passed phys phys points math math points phys phys lab lab lab lab total points bachelor contracts 
appendix audio video recorded presentations microsoft research ibm research bigwig language developing interactive web services available www brics dk brabrand bigwig ms asf microsoft research redmond wa march min flexible safe efficient dynamic generation html available www brics dk brabrand bigwig ibm mpg ibm watson research center hawthorne ny july min bibliography document object model dom level specification october 
recommendation 
www org tr rec dom level 
arnold gosling holmes 
java programming language 
addison wesley rd edition june 
atkins ball benedikt bruns cox 
experience domain specific language form services 
proc 
conference domain specific languages dsl 
usenix october 
atkins ball bruns cox 
mawl domain specific language form services 
ieee transactions software engineering may june 
atkinson 
core php programming 
prentice hall nd edition august 
bachrach 
java syntactic extender 
object oriented programming languages systems oopsla 
baker hsieh 
maya multiple dispatch syntax extension java 
proc 
acm sigplan conference programming language design implementation pldi pages june 
barford bestavros bradley crovella 
changes web client access patterns characteristics caching implications 
world wide web journal january 
kluwer 
obraczka 
world wide web caching trends techniques 
ieee communications magazine internet technology series may 
batory smaragdakis 
jts tools implementing domain specific languages 
fifth international conference software reuse 
berners lee fielding frystyk 
hypertext transfer protocol may 
rfc 
www org protocols rfc rfc 
bibliography malhotra 
xml schema part datatypes may 
recommendation 
www org tr xmlschema 
brabrand 
synthesizing safety controllers interactive web services 
master thesis department computer science university aarhus december 
available www brics dk brabrand thesis 
brabrand ller olesen schwartzbach 
caching dynamically generated html 
world wide web journal 
kluwer 
see dissertation chapter 
brabrand ller schwartzbach 
powerforms declarative client side form field validation 
world wide web journal december 
baltzer science publishers 
see dissertation chapter 
brabrand ller sandholm schwartzbach 
runtime system interactive web services 
computer networks may 
elsevier 
proc 
th international world wide web conference www 
see dissertation chapter 
brabrand ller schwartzbach 
static validation dynamically generated html 
proc 
acm sigplan sigsoft workshop program analysis software tools engineering paste pages june 
see dissertation chapter 
brabrand ller schwartzbach 
bigwig project 
acm transactions internet technology 
see dissertation chapter 
brabrand schwartzbach 
growing languages metamorphic syntax macros 
proc 
acm sigplan workshop partial evaluation semantics program manipulation pepm january 
see dissertation chapter 
bray paoli sperberg mcqueen maler 
extensible markup language xml second edition october 
recommendation 
www org tr rec xml 
brooks 
programming 
reilly associates august 
campbell 
compiler definition facility syntactic macro 
computer journal 
cao zhang beach 
active cache caching dynamic contents web 
proc 
ifip international conference distributed systems platforms open distributed processing middleware 
springer verlag september 
bibliography cardelli matthes abadi 
extensible syntax lexical scoping 
src research report 
challenger dantzig iyengar 
scalable system consistently caching dynamic web data 
proc 
th annual joint conference ieee computer communications societies infocom march 
christensen ller schwartzbach 
extending java high level web service construction 
technical report rs brics march 
clark derose 
xml path language november 
recommendation 
www org tr xpath 
clinger rees 
macros 
principles programming languages popl pages 
cox ball 
tale ways program web services 
technical report bl tm bell laboratories 
klarlund schwartzbach 
parsing logical side constraints 
rozenberg thomas editors developments language theory 
foundations applications perspectives pages 
world scientific november 
douglis rabinovich 
hpp html support dynamic document caching 
proc 
st usenix symposium internet technologies systems usits december 

requirements april 
working draft 
www org tr xhtml forms req html 
dybvig hieb bruggeman 
syntactic abstraction scheme 
lisp symbolic computation 
fernandez suciu tatarinov 
declarative specification data intensive web sites 
proc 
nd conference domain specific languages dsl 
usenix acm october 
flanagan 
javascript definitive guide 
reilly associates june 
freier kocher 
ssl protocol version november 
home netscape com eng ssl draft txt 
gettys mogul frystyk masinter leach berners lee 
hypertext transfer protocol 
www org protocols rfc rfc html 
bibliography lee 
seamless integration interactive forms web 
computer networks isdn systems september 
elsevier 
proc 
th international world wide web conference www 

cgi programming world wide web 
reilly associates march 
hanus 
high level server side web scripting curry 
rd int 
symposium practical aspects declarative languages padl pages 
homer gibbs bell clark lee milner 
asp net programmer 
press september 
hosoya murata 
validation boolean operations attribute element constraints 
informal proceedings workshop programming language technologies xml plan 
hosoya pierce 
xduce typed xml processing language 
proc 
rd international workshop world wide web databases webdb volume lncs 
springer verlag may 
hosoya pierce 
regular expression pattern matching xml 
proc 
th acm sigplan sigact symposium principles programming languages popl january 
sandholm 
case study automata control synthesis 
proc 
rd international conference fundamental approaches software engineering fase volume lncs 
springer verlag march april 
newsletter august 
www com issue html 
iyengar challenger 
improving web server performance caching dynamic data 
proc 
st usenix symposium internet technologies systems usits december 
kelsey clinger 
eds 
revised report algorithmic language scheme rs 
kernighan ritchie 
programming language 
prentice hall 
klarlund ller 
mona version user manual 
brics department computer science university aarhus january 
notes series ns 
available www brics dk mona 
revision brics ns 
bibliography klarlund ller schwartzbach 
dsd schema language 
automated software engineering 
kluwer 
preliminary version proc 
rd acm sigplan sigsoft workshop formal methods software practice 
kohlbecker friedman felleisen duba 
hygienic macro expansion 
lisp functional programming pages 
kohlbecker wand 
macro example deriving syntactic transformations specifications 
principles programming languages popl pages 
acm 

javascript html possibilities caveats 
www hut fi forms javascript html 
ladd 
programming web language hypermedia services 
world wide web journal january 
reilly associates 
proc 
th international world wide web conference www 

syntax macros extended translation 
cacm 
levy 
web programming guide 
software practice experience 
suciu 
xmill efficient compressor xml data 
acm sigmod record june 
maddox 
semantically sensitive 
technical report university california berkeley 
technical report ucb csd 
meijer shields 
xm functional language constructing manipulating xml documents 
draft 
available www cse ogi edu mbs pub 
mogul douglis feldmann krishnamurthy 
potential benefits delta encoding data compression 
proc 
acm sigcomm conference applications technologies architectures protocols computer communication sigcomm september 
ller 
mona project home page 
www brics dk mona 
netscape javascript form validation sample code 
developer netscape com docs examples javascript overview html 
nielsen 
designing web usability practice simplicity 
new riders publishing december 
bibliography nielson nielson hankin 
principles program analysis 
springer verlag october 
open market 
fastcgi high performance web server interface april 
available www com whitepapers 
pemberton xhtml extensible hypertext markup language january 
recommendation 
www org tr xhtml 
jacobs 
html specification december 
recommendation 
www org tr html 
rajamani cox 
simple effective caching scheme dynamic content 
technical report cs dept rice university september 
sandberg 
language combining flexible syntax classes 
principles programming languages popl pages 
sandholm schwartzbach 
distributed safety controllers web services 
proc 
rd international conference fundamental approaches software engineering fase volume lncs 
springer verlag march april 
sandholm schwartzbach 
type system dynamic web documents 
proc 
th acm sigplan sigact symposium principles programming languages popl january 

xhtml fml forms markup language 
stack overflow ag 
www org documentation spec xhtml fml html 
schwartzbach bigwig project home page 
www brics dk bigwig 
scott sharp 
abstracting application level web security 
proceedings th acm international world wide web conference 

dylan manual 
addison wesley longman 
smith acharya yang zhu 
exploiting result equivalence caching dynamic web content 
proc 
nd usenix symposium internet technologies systems october 
stallman 
preprocessor online documentation 
gcc gnu org cpp toc html 
steele 
growing language 
lisp symbolic computation 
stroustrup 
programming language chapter 
addison wesley third edition 
bibliography sun microsystems 
java servlet specification version 
available java sun com products servlet 
sun microsystems 
pages specification version 
available java sun com products jsp 
tennent 
principles programming languages 
prentice hall 
thiemann 
typed representation html xml documents haskell 
journal functional programming july 
thiemann 
wash cgi server side web scripting sessions typed compositional forms 
th int 
symposium practical aspects declarative languages padl 
thistlewaite ball 
active forms 
computer networks isdn systems may 
elsevier 
proc 
th international world wide web conference www 
thomas 
automata infinite objects 
van leeuwen editor handbook theoretical computer science volume pages 
mit press elsevier 
thompson beech maloney mendelsohn 
xml schema part structures may 
recommendation 
www org tr xmlschema 
van deursen klint visser 
domain specific languages annotated bibliography 
acm sigplan notices june 
veldhuizen 
templates partial evaluation 
partial evaluation semantics program manipulation pepm 
waddell dybvig 
visualizing partial evaluation 
acm computing surveys symposium partial evaluation volume es es september 
waddell dybvig 
extending scope syntactic abstraction 
principles programming languages popl pages 
wang 
survey web caching schemes internet 
acm computer communication review october 
webb 
javascript form faq knowledge base 
developer irt org script form htm 
weise crew 
programmable syntax macros 
programming language design implementation pldi pages 
bibliography weise crew 
programmable syntax macros 
proc 
acm sigplan conference programming language design implementation pldi june 
wills 
studying impact complete server information web caching 
computer communications february 
elsevier 
proc 
th international web caching content delivery workshop 
wolman 
characterizing web workloads improve performance july 
university washington 
available www cs washington edu homes wolman generals 
florescu valduriez 
caching strategies data intensive web sites 
proc 
th international conference large data bases vldb 
morgan kaufmann september 
zhu yang 
class cache management dynamic web contents 
proc 
th annual joint conference ieee computer communications societies infocom pages april 
brics dissertation series publications ds claus brabrand 
domain specific languages interactive ds web services 
january 
phd thesis 
xiv pp 
pagh 
hashing randomness dictionaries 
october 
phd thesis 
pp 
ds anders ller 
program verification monadic second order logic languages web service development 
september 
phd thesis 
xvi pp 
ds jacob 
dynamic planar convex hull 
thesis 
xiv pp 
may 
phd ds stefan 
resolution complexity matching principles 
may 
phd thesis 
xii pp 
ds oliver ller 
structure hierarchy real time systems 
april 
phd thesis 
xvi pp 
ds jensen 
robust flexible scheduling evolutionary computation 
november 
phd thesis 
xii pp 
ds flemming 
compression fast random access 
november 
phd thesis 
xiv pp 
ds niels 
theory better tools 
october 
phd thesis 
ds nielsen 
study continuation passing style 
iv pp 
august 
phd thesis 
ds bernd 
topics semantics program manipulation 
august 
phd thesis 
ii pp 
ds daniel damian 
static dynamic control flow information program analysis transformation 
august 
phd thesis 
xii pp 
ds morten 
higher order program generation 
august ds 
phd thesis 
xiv pp 
thomas 
analyzing real time systems theory tools 
march 
phd thesis 
xii pp 
ds jakob 
time space trade offs 
march 
phd thesis 
xii pp 
