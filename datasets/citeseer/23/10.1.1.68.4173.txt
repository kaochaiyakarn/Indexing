shieldgen automatic data patch generation unknown vulnerabilities informed probing cui marcus helen wang microsoft research microsoft way redmond wa microsoft com shieldgen system automatically generating data patch vulnerability signature unknown vulnerability zero day attack instance 
key novelty leverage knowledge data format generate new potential attack instances call probes zero day detector oracle determine instance exploit vulnerability feedback oracle guides search vulnerability signature 
implemented shieldgen prototype experimented known vulnerabilities 
generated signatures false positives low rate false negatives due imperfect data format specifications sampling technique probe generation 
significantly precise signatures generated existing schemes 
conducted detailed study vulnerabilities microsoft issued security bulletins 
estimate shieldgen produce high quality signatures large portion vulnerabilities signatures superior signatures generated existing schemes 

seen rise zero day attacks exploit unknown vulnerabilities 
unfortunately current practice new vulnerability analysis protection generation manual 
aim automate process enable fast patch level protection generation unknown vulnerability michael columbia university amsterdam avenue new york ny cs columbia edu observation zero day exploit vulnerability 
particular consider fast patch level patch traditional software patch 
data patch serves policy data filter vulnerability software flaw needs protected 
filter uses data patch identify parts input data consumed 
result sanitized data stream exploit vulnerability 
shield vulnerability signatures firewalls filter malicious network traffic examples data patches network input 
similarly files crafted maliciously exploit vulnerability application consumes file input wmf vulnerability 
rise exploits anti virus software vendors started vulnerability signatures data files defend new attack variants 
data patch vulnerability signature interchangeably 
term data patch emphasizing purpose patch term vulnerability signature emphasizing form signature 
data driven data patches take form signatures automatically distributed enacted vulnerable hosts 
style protection achieved traditional software patches applying software patch inherently user driven 
automatic patch download users need enact downloaded patch restarting application rebooting machine 
furthermore enterprise environment patches typically tested prior deployment order avoid potentially high cost recovering faulty patch 
contrast rolling back data patch simple removing vulnerability signature 
shieldgen system suspicious traffic zero day attack oracle probe successful failed automatically generating data patch unknown vulnerability zero day attack instance 
key novelty shieldgen leverage knowledge data format generate new potential attack instances zero day detector oracle guide search vulnerability signatures 
particular assume knowledge data format zero day attack protocol format network attack file format file attack 
reasonable assumption type data input consumed application known common practice data formats specified purpose interoperability vendors simply purpose documentation proprietary setting 
design employ zero day attack detector detect zero day attacks high confidence 
detected zero day attack sent system producing data patch 
construct new potential attack instances call probes data format information 
send probes back oracle zero day attack detector see probes succeed real attacks 
answers oracle guide system construct new probes discard attack specific parts original attack data retain inherent vulnerability specific part 
output system vulnerability signature form refinement data format specification embeds vulnerability predicate set boolean conditions data fields 
stateful network attacks system able capture protocol context protocol state attack message sent 
gives overview shield gen system 
number probes shieldgen deriving vulnerability signature key measure probe data format data analyzer attack data semantics probe generator analyzer data patch 
shieldgen system overview efficiency 
goal probe generation algorithm minimize number probes 
leverage semantic information constraints data format specification 
example enforce dependency constraints data fields generate invalid probes 
implemented shieldgen prototype 
evaluation experimented vulnerabilities slammer blaster wmf attack 
generated signatures false positives 
low rate false negatives due imprecision data format specifications sampling technique probe generation 
conducted pencil evaluation vulnerability coverage approach 
examined vulnerabilities microsoft security bulletins issued 
vulnerabilities data input attack vector potentially data 
selected vulnerabilities understand set analyzed detail 
estimate shieldgen effective vulnerabilities 
estimate signature scheme effective vulnerabilities :10.1.1.164.7284
rest organized follows 
related section position shieldgen relation existing automatic signature generation 
give background building blocks system section 
section details design 
section implementation evaluation consists case studies vulnerabilities experimented shieldgen vulnerability coverage study 
discuss section conclude section 
related automatic signature generation zero day attacks received attention research literature 
section compare contrast shieldgen related automatic signature generation 
early efforts designed generate attack signatures single attack variant searching long invariant substrings network traffic signatures 
capturing polymorphic attack variants polygraph exemplifies approach finding multiple invariant substrings network traffic 
polygraph observes multiple invariant substrings variants worm payload worm function properly 
substrings typically correspond protocol framing control data return addresses poorly obfuscated code 
polygraph suffers significant false positives false negatives legitimate traffic contains multiple invariant substrings polymorphic attacks hijack control data invariant substring 
generates signatures network traffic 
fundamental drawback mechanisms carefully crafted attack traffic mislead generate incorrect signatures 
existing leverages information vulnerable applications improving accuracy coverage signatures 
employs protocol specifications provide protocol context attack signatures tries generalize signature observed attack instances 
signature finite state automaton fsa inferred clusters similar connections sessions 
edges connection level fsa fields messages edges session level fsa connections 
generalizes signatures replacing certain variable data elements wild card 
shield gen generalization dependent attack instances observed 
resulting signatures specific 
example attack variants different message sequence captured 
wild card generalization filter attack variants buffer overrun vulnerabilities 
validity generalization unchecked lead generalization false positives 
contrast shieldgen generates new attack instances single attack instance data format specification relying just observed attack instances shieldgen signature generalization process validated oracle 
covers uses address space zero day detector regular expression protocol specification generate signatures buffer overrun vulnerabilities 
key difference shieldgen signatures covers shieldgen signatures incorporate protocol context attacks happen protocol state attack happen covers signatures contain protocol context pattern matching predicate particular protocol message 
signatures protocol context result false negatives different message sequences lead attack result false positives pattern matching message non vulnerable protocol state 
covers signature generation uses length vulnerable input field buffer limit buffer overrun condition signature cause false negatives attacks shorter buffer length observed attack instance 
shieldgen find buffer limit help zero day detector dynamic data flow analysis 
experimental results indicate buffer limit yields zero false positives harmless false negatives section section 
furthermore coverage shieldgen signatures greater data format informed probing oracle 
previous research efforts discussed far dependent attack instances observed 
packet vaccine system breaks limitation manipulating packet payloads observing program reactions 
packet vaccine generates signatures steps constructs packet probes randomizing address strings 
detects exploit observing memory exception packet vaccine injection 
generates signatures finding attack input bytes take random values 
step constructs packet byte address string randomizing value 
similarity packet vaccine shieldgen leverage feedback loop improve coverage signatures 
probing feedback mechanism developed independently 
compared shieldgen packet vaccine limitations main probing scheme randomizes byte leveraging data format information 
compared shieldgen data format informed probing probing strategy suffers significantly probes particularly multiple messages involved attack 
fact authors packet vaccine mentioned scheme works reliably text proto cols binary ones lack protocol knowledge binary data formats 
authors packet vaccine briefly mentioned benefit leveraging protocol specifications 
unclear type protocol specification language considered protocol specifications leveraged 
includes intricate issues devoted 
packet vaccine detect controlflow hijacking attacks shieldgen uses zero day detector detect wider range attacks 
example packet vaccine detect exploits wmf vulnerability 
newsome song hinted research direction probing zero day detector oracle find attack invariants 
proposed flipping bits original attack data generate probes 
probing method prohibitively expensive 
shieldgen leverage data format information scales number probes significantly critical practicality scheme 
devoted techniques leverage data format information generate useful probes 
category automatic signature generation uses program analysis binary source code 
costa crandall newsome dynamic data flow analysis execution attack input generate signature form symbolic predicates :10.1.1.164.7284
attack signatures inherently specific attack input data flow analysis 
shieldgen generalize attack specific symbolic predicate signatures cover significantly attack variants data format informed probing oracle 
static program analysis extract program logic processes attack data triggers vulnerability :10.1.1.65.4914
extracted logic expressed form turing machines symbolic predicates regular expressions vulnerability signatures 
turing machine signatures may terminate regular expressions sufficiently expressive vulnerabilities 
symbolic predicates practical form 
authors introduce notion monomorphic execution path mep polymorphic execution path pep describe coverage vulnerability signatures 
mep considers single execution path point attack input consumed point compromise pep considers different paths 
fact signatures generated systems previous paragraph mep signatures :10.1.1.164.7284
call execution trace methods rest 
remained open challenge generate pep vulnerability specific kind signatures form symbolic predicates 
challenge combinatorial explosion number execution paths 
challenge potentially large attack data long file maliciously crafted iterative elements resulting symbolic predicate contain large number conditions number conditions grows number iterative elements input unnecessary overly restrictive causing high rates false negatives 
furthermore stateful network attack takes place sequence messages vulnerability may triggered message may message sequences lead message 
scenario symbolic predicate generated message sequence detect attacks message sequences reach vulnerability 
comparison shieldgen approach cope challenges easily knowledge data format 

background section gives brief summary building blocks construct shieldgen oracle data analyzer 

oracle zero day attack detector zero day attack detector takes suspicious data input outputs high confidence data contain exploit 
suspicious data obtained crash dumps 
zero day attack detector take forms 
detectors dynamic data flow analysis instrument software monitored track input data network packets files propagate address space program executes 
detectors type information test wide range vulnerability conditions 
example simple condition test executing ret instruction input data propagated return address stack 
small set simple conditions type sufficient give type detectors broad coverage low level control data flow vulnerabilities 
includes buffer overflows arbitrary vulnerabilities result code injection overwriting function pointers return libc style attacks 
hand data flow detectors detect higher level vulnerabilities incorrect access control settings incorrect security user interfaces sandboxing problems scripting engines 
shieldgen zero day detector dynamic data flow analysis :10.1.1.164.7284
detector implements vulnerability conditions 
tests arbitrary execution control aec detector tests input data moved instruction pointer 
detect attempts overwrite return addresses stack function pointers stack heap 
tests arbitrary code execution ace executing instruction detector tests instruction depends program input 
detects attempts execute injected code 
tests arbitrary function arguments afa performing certain critical system calls creating process detector checks certain critical arguments depend program input 
practice detector low rate false positives 
false positives eliminated completely expense higher rates false negatives means verification procedure :10.1.1.164.7284
addition issuing alert detector provide detailed information exploit vulnerability 
includes complete data flow history application state moment vulnerability detected 
detector output positions input stream values triggered alert 
example case aec condition bytes loaded instruction pointer 
case ace condition bytes executed 
furthermore detector output information instruction triggered alert 
example detector output aec alert triggered executing ret instruction overwritten return address indirect jmp call instruction overwritten function pointer 
information shieldgen 

data format specification data analyzer assume knowledge data format input vulnerable application 
assume input encrypted obfuscated 
consider types data network data file data 
data analyzer tool parses data data format specification giving semantics structure raw data 
data analyzer operate online offline 
online data analyzer serve main mechanism data filters prevent network file intrusions 
example shield employs protocol analyzer perform filtering application level protocol traffic file analyzer employed anti virus software prevent file attacks exploit file parsing vulnerabilities 
binpac gapa advocated specifying protocol format domain specific language generic protocol analyzer runtime parse protocol traffic specification 
binpac gapa able map protocol structure raw network data parsing packets messages contain various fields expressed specification extracting protocol state information sequence messages parsed 
employ gapa 
find gapa readily file format specification analysis 
gapa specification short spec specifies message format protocol state machine message handlers protocol state carries protocol state transition 
message format expressed enhanced bnf format similar rfc run time value earlier parts message may determine parts message parsed 
example size field item array indicates number items parse run time field value message may determine parse parts subsequent message 
context sensitive characteristics data formats supported gapa enhancing bnf notation embedding code bnf rules 

design 
goals goals shieldgen data patch generation false positives 
shieldgen signatures false positives oracle 
minimize number false negatives 
rate false negatives low possible 
minimize number probes 
shieldgen reasonably efficient 
ideally signature free false negatives 
computing signature false positives false negatives equivalent solving halting problem :10.1.1.65.4914
protocol sql transport udp grammar type byte rest state machine init init initial state init final state final 
shieldgen data patch handler condition vulnerability predicate added shieldgen type size rest return exploit return final 
data patch vulnerability slammer data patch generated shieldgen refinement data format specification fed data analyzer firewall anti virus program patch equivalent protection 
refinement includes vulnerability predicate fields input 
predicate evaluates true input classified exploit removed 
gapa language predicate expressed condition statement inserted appropriate data handler 
network data data handler message handler protocol state attacks happen 
adapt gapa file data entire file treated message protocol state machine specification contains just state just data handler 
shows example data patch vulnerability slammer attack 

data patch generation 
overview central shieldgen data patch generation derivation vulnerability predicate 
gives overview data patch generation procedure shieldgen 
step data analyzer check input attack instance violates data format constraints number bytes byte array correspond value size field 
violated constraints construct probes satisfy constraint changing size field correspond size byte array original attack packet 
probe reported unsuccessful oracle failed exploit vulnerability data patch simply data format specification enforces corresponding data format constraint 
probe successful move step 
step generate attack predicate 
predicate conjunction boolean conditions data field message attack value attack input 
easily obtain attack predicate sending attack input data format data analyzer 
course predicate incurs false positives attack detection restrictive admits attack input protocol state 
subsequent steps algorithm relax remove conditions specific original attack input admit attack variants 
generating probes potential attack variants data format sending oracle 
oracle determines probe new attack variant adjust vulnerability predicate confirmed new attack instance admitted 
example values data field tried oracle classifies corresponding probes attacks field don care field remove condition data field predicate 
challenge probe generation generate legitimate messages satisfy protocol semantics including session semantics cross field correlation message 
example session id field message session 
examples field correlations message length field sizeof fields checksum field checksum fields hash field hash field 
important semantics obeyed probes oracle answer illegitimate probes mislead judgment field experiment 
include protocol semantics know protocol spec 
prototype implemented protocol semantics lengths constraint data patch constraint checking probing generate attack predicate probe unsuccessful probe successful deal buffer overrun probe successful min probe construction probing vulnerability predicate data patch data field value sampling probing probe unsuccessful probe unsuccessful probe successful add back iterative element probing 
procedure shieldgen data patch generation procedure starts constraint check probing 
session ids previous shown probes obey semantics wide range protocols ftp rpc smb 
note probe may contain multiple protocol messages including messages precede offending message session initiation application context setup 
efficiency metric probing scheme number probes 
probes parallelized need sequential construction probe dependent outcome earlier probe 
machines parallel probes sped evaluating probes parallel 
typically infeasible probe oracle combinations values data field appears input 
reduce number probes ways 
may iterative elements attack data sequence records may expressed records record records nil size uint items int byte data format spec 
iterative elements introduce numerous repetitive data fields may matter vulnerability predicate construction case just particular iterative element triggers vulnerability 
recognize iterative elements spec issue probe contains just element see number elements matters oracle answer issue subsequent probes 
able recognize elements zero day attack significantly reduces number probes 
second obeying protocol semantics eliminating illegitimate probes reduction number probes needed 
possible expressed constraint may constraint implementation 
example application may allow size constraint violated 
probe determine constraint matters 
network input contains sequence messages highly vulnerability predicate dependent message 
vulnerabilities localized 
message handlers message typically separate code pieces attack happens handling message vulnerability affects message handling message 
case having conditions data fields earlier messages cause false negatives resulting vulnerability predicate capture attack variants take different message sequence 
assumption content message determines input exploits vulnerability data analyzer naturally traces protocol context reaching handler message 
discuss exceptions violate assumption section 

probe generation algorithm probe generation algorithm detail 
oracle detects attack outputs byte offset offending byte input section 
general offending byte may fall arbitrary field input packet 
buffer overrun heuristic character strings want find dealing buffer overrun vulnerability 
heuristic offending byte lies middle byte unicode string shieldgen diagnoses buffer overrun adds condition refinement 
sizeof buffer offset offset argument heuristic accurate depends type alert detector issued 
case ace alerts application execute ret instruction alert issued return address stack corrupted input data 
certain cause condition stack buffer overrun 
application execute indirect jmp call instruction corresponding function pointer contained input data 
represent legitimate application behavior application intended input data function pointer accurate spec declare function pointer byte integer substring byte unicode string 
case aec alerts application execute instruction originated middle byte unicode string input 
appears highly caused buffer overrun 
case afa alerts application critical system call parameter originated middle byte unicode string input 
legitimate application behavior parameter appear separate data field accurate spec 
case parameter lie middle larger string field 
strong indication buffer overrun 
iteration removal popular input formats include arbitrary sequences largely independent elements records 
example html files contain sequences tags 
audio video files consist sequences chunks compressed audio video data 
wmf files consist sequence drawing command records 
cases file contains sequence records 
rendering applications typically different handler functions different record types 
example wmf record types include ellipse rectangle escape 
record type processed corresponding handler function 
vulnerabilities typically located particular handler function 
case input contains malicious record attack irrespective records may exist input 
poses special challenges execution trace signature generation mechanisms section 
shieldgen cope iterative elements easily specified spec 
critical step algorithm remove iterative elements necessary exploit vulnerability 
reduces number probes needed improves accuracy generated signature 
high level generate probes removed iterative elements feed probes oracle 
probe exploits vulnerability iterative elements removed probe omitted 
iterative elements removed probe necessary need added 
search procedure described detail 
theoretical worst case procedure may lead simplification input iterative elements input necessary exploit vulnerability 
real world vulnerabilities observed procedure rapidly converges probe iterative elements left 
consistent observation records independent vulnerabilities typically located handler particular record type 
detail search aided fact detector identifies offending data input 
data analyzer map information particular iterative element offending element 
heuristic observation typically iterative elements necessary exploit vulnerability generate probe removing iterative elements offending element 
minimal probe succeed attack add iterative elements back probe 
iteration hierarchical iterative element iterative structure 
algorithm add back iterative elements original input lowest hierarchical level offending byte located 
send probe oracle 
oracle detects probe attack try eliminate iterative elements lowest level divide conquer mechanism split iterative elements level parts 
construct parallel probes probe dropping parts 
probe successful associated iterative elements dropped divide portion interactive elements ways send round parallel probes 
find iterative elements exist probe 
offending byte belong iterative element successful attack adding iterative elements levels offending byte need add iterative elements contain offending byte 
case take approach similar add back elements containing offending byte 
difference top starting highest hierarchical level 
divide conquer mechanism find elements highest level added back 
element added back go level inside mechanism find elements lower level added back 
continue procedure reach lowest level 
iterative element removal shares intuition hierarchical delta debugging technique leverages hierarchical structure input data expedite procedure minimizing inputs effective debugging 
eliminating irrelevant field conditions construct probes remaining data fields eliminate don care fields find additional values data fields attack succeeds 
afford sending probes combinatoric fashion result exponential number probes 
evaluate field time setting values fields respective values original input 
obey data format semantics probe construction mentioned earlier 
sampling heuristics reduce number probes evaluating field base type data field integer try minimum value maximum value sample number random values input value 
character strings generate random string random non zero value byte send samples random strings 
byte arrays random value byte non zero value 
samples field lead probes exploit vulnerability consider field don care remove predicate 
sampling produce false negatives false positives 
evaluation observed cases sampling introduces false positives 
discussed section may possible avoid problem leveraging filter conditions 
process left set input fields fi values field vi attack triggered value fi vi output algorithm conjunction conditions 
approximation vulnerability predicate 
possible complex vulnerability conditions involve complex calculations multiple fields 
discuss possible approaches complex conditions section 
implementation evaluation developed prototype shieldgen 
prototype system consists re implementation zero day detector oracle gapa data analyzer line perl script implements probe generation vulnerability predicate derivation :10.1.1.164.7284
evaluate shieldgen accuracy efficiency applicability ways 
conduct case studies shieldgen generate data patches known vulnerabilities 
evaluate accuracy data patches efficiency generation 
second conduct pencil vulnerability study estimate shieldgen coverage potential accuracy 
measure efficiency terms number parallel probes number sequential probes section 
probe takes seconds believe room efficiency improvement probe processing discuss detail section 

case studies ran shieldgen known vulnerabilities vulnerabilities slammer sql server resolution service blaster windows rpc service windows wmf vulnerability 
chose case studies cover file network vulnerabilities 
cover single message multiple message vulnerabilities vulnerable wmf application uses file input vulnerable sql rpc services take network input exploits sql vulnerability simple re quire just packet exploits rpc vulnerability complex require sequence messages 
conducted case study isolated testbed virtual machines vms running microsoft virtual pc 
vm installed windows server runs instrumented sql service rpc service serving oracle attacks exploiting vulnerabilities slammer blaster 
second vm send network probes sql rpc service 
third vm plays role oracle attacks wmf vulnerability 
vm installed version windows xp professional service pack 
windows picture fax viewer wmf application 
wmf probes generated vm 
current prototype base type field sampling phase probe generation section sample minimum value maximum value random value smaller corresponding value original attack data random value larger applicable 
strings byte arrays sample random string byte array times 

sql vulnerability sql vulnerability stack buffer overrun vulnerability sql server resolution service provides server resolution service multiple sql server instances running machine 
listens requests port udp returns ip address port number sql server instance runs requested database 
message format udp request consists just fields byte followed byte array 
obtained original attack trace launching attack standalone program replaces original self propagation payload slammer worm windows shell 
shieldgen determined attack stack buffer overrun output constructed buffer overrun vulnerability condition 
shieldgen issued parallel probes try different values byte 
shieldgen successfully generated correct vulnerability signature shown 
signature adds refinements gapa spec byte minimal size byte array bytes 
signature yields false positives may harmless false negatives 
false negatives input longer allocated buffer size shorter minimal size overwrite return address 
false negatives able compromise system 
signature similarly accurate 

rpc vulnerability rpc vulnerability stack buffer overrun vulnerability interface microsoft dcom rpc service 
experimented interface 
obtained rpc gapa spec including format interface 
framework generate attack instance 
shieldgen determined stack buffer overrun constructed buffer overrun vulnerability condition output minimal size buffer field successful attack bytes 
probed size session id constraints matter rpc implementation 
probes satisfy constraints 
shieldgen issued parallel probes find fields buffer field don care fields 
vulnerability condition excluding buffer overrun conjunction conditions rpc vers rpc minor packet version major extension ptr offset 
due lack space show signature signature lines 
signature false positives false negatives due conditions extension ptr offset 
false negatives arose gapa spec complete 
sampling values extension ptr probes include extension record message 
case offset capture offset constraint 
conditions benign understanding rpc protocol 
comparison filter produced filter generator contains conditions additional fields shieldgen classified don cares 

wmf vulnerability windows wmf file contains sequence records map graphic display interface gdi functions create images 
example rectangle record wmf file tells graphics rendering library draw rectangle image 
wmf vulnerability lies escape record 
attacker create malicious wmf file adding escape record byte array field record 
content byte array treated executable code abort procedure 
file opened code byte array executed 
developed gapa spec wmf file format 
wmf records iterative elements spec 
wrote standalone program creates malicious wmf files adding escape record piece code middle randomly generated sequence regular draw records 
shieldgen determined buffer overrun attack offending byte byte byte array stores piece code 
shieldgen issued probe removing iterative elements failed 
shieldgen issued log number regular draw records attack file sequential probes add back iterative elements 
regular draw record escape record application execute code 
issued parallel probes find field left minimal attack file don 
addition requirement regular draw record escape record vulnerability predicate contains conjunction mf type version number escape num file ended eof record 
due lack space show signature signature lines 
close inspection vulnerability source code level reveals conditions strong 
value mf type version number field attack succeed 
shieldgen find values samples field values exhaustively searching 
filter produced original filter generator contains conditions record wmf file including benign draw records 
filter attack specific 
contrast shieldgen correctly removed unnecessary iterative data fields 

vulnerability coverage methodology performed pencil vulnerability study order evaluate shieldgen larger sample real world vulnerabilities 
precisely trying determine claims significant number realworld vulnerabilities approach automatic data patch generation applicable 
iteration removal relevant shieldgen successfully remove iteration input 
filter condition produced shieldgen accurate 
furthermore compare filter quality shieldgen execution trace methods 
cover larger sample vulnerabilities limit amount effort needed vulnerability 
run shieldgen required building exploits gapa specs vulnerability 
analysis quite intensive requires understanding input formats low level application behavior diverse set applications 
clear count vulnerabilities 
number cases fault lies lower level code dynamically linked libraries dlls number applications 
counted cases single vulnerability evaluated application affected 
vulnerability classification step examined vulnerabilities microsoft issued security bulletins 
vulnerabilities exploited network file input 
vulnerabilities principle shielded data patches 
remaining vulnerabilities fall categories denial service vulnerabilities crashes vulnerabilities access control problems vulnerabilities scripting problems vulnerabilities miscellaneous problems vulnerabilities 
able classify vulnerabilities information 
filter quality shieldgen chose vulnerabilities vulnerabilities shielded data patches 
choice primarily analyze vulnerability reasonable effort depended amount information available knowledge applications input formats involved 
performed detailed pencil analysis vulnerabilities tried determine shieldgen generate precise signatures 
table displays results analysis 
considering iteration removal 
seventeen vulnerabilities associated complex input formats admit iteration 
examples include different multimedia file formats wmf html web pages word processor spread sheet files 
shieldgen remove unnecessary iterative elements exploits shieldgen execution trace methods precise filter imprecise filter total table 
assessment shieldgen coverage 
bilities 
remaining vulnerabilities iteration removal appears irrelevant involve rpc calls 
iteration removed shieldgen compute filter conditions remaining fields 
consider quality conditions 
consider shieldgen sufficiently precise vulnerability union small number shieldgen data patches covers vulnerability completely suffering false positives 
ideally single data patch able cover vulnerability 
vulnerabilities sample exploitable small number independent interfaces requiring number data patches 
example rpc blaster vulnerability exploited means different rpc calls 
believe practical setting shieldgen data patches considered precise cover vulnerability attack instance rpc calls 
criterion shieldgen produces precise filters vulnerabilities 
failure analysis vulnerabilities shieldgen produce precise filters categorized follows complex conditions vulnerabilities precise condition involves functions input fields 
example case vulnerability triggered combined length separate strings input exceeds certain limit 
case vulnerability triggered value integer field input larger value integer field 
unchecked array indices cases application uses field input index array checking index falls bounds array 
externally provided specification notoriously hard infer array bounds 
case application uses collection old buffers size match requirements data currently processing 
gives rise large number variants buffer overflows depending data buffers originally allocated 
conditions type hard formulate hard infer automatically 
comparison execution trace methods estimate existing filter generation algorithms execution traces behave vulnerabilities sample 
assume algorithms detect simple loops 
mechanism described easily added schemes :10.1.1.65.4914
mechanism filters specific lengths strings attack instance generated 
filters fragile 
vulnerabilities iteration removal relevant execution path application strongly manipulated attacker 
outlined earlier attacker generate exploits adding arbitrary sequences iterative elements 
sequence iterative elements produce corresponding sequence conditions execution trace filter 
execution trace filters vulnerabilities fragile exploit specific 
estimate execution trace methods generate precise filters remaining vulnerabilities 
vulnerabilities involve complex conditions associated multiple executions paths 
try determine filters schemes produce vulnerabilities 
general comparison section believe filters precise shieldgen filters 

discussion quality data format specification scheme quality data format specification matters 
example unspecified constraint result wasted probes yield unneeded vulnerability conditions cause false negatives 
example specification multiple fields byte array right semantic information data shieldgen may able determine buffer overrun occurred section 
obtaining high quality data format specification easy specification desirable different purposes time effort 
easy imagine high quality specification obtained context protocol file format compliance testing 
complex filter conditions vulnerability coverage study frequent reason shieldgen failed produce precise filter complex nature filter conditions 
shieldgen uses detector black box oracle 
fundamental limits complexity conditions inferred way 
practice deriving simple conditions involving field field field require oracle queries feasible 
contrast execution trace methods knowledge vulnerable program execution trace leads vulnerability computing filter conditions 
methods infer arbitrarily complex filter conditions long computed single execution path 
suggests possibility improving shieldgen data patches deriving filter conditions execution trace filter generator 
principle straightforward 
filters symbolic predicates values certain offsets input 
shieldgen knows map offsets fields defined spec obtaining filter conditions fields 
clear conditions improvement conditions shieldgen generate 
encode single execution path may correspond arbitrarily execution paths trigger vulnerability 
possible identify cases refining search logic shieldgen leave details 
probing time current implementation testing probe involves starting application attaching detector sending probe input application waiting result shutting application 
total time probe seconds 
estimate time reduced seconds probe help flash cloning virtual machines 
idea create vm application detector started 
probes tested clones vm 
test cloned vm discarded 
overhead cloning discarding vm appears second significantly startup shutdown times target applications detector 
attacks delivered message currently assume vulnerability occur message handling code message message sequence leads message handling trigger vulnerability 
practice exist exceptional cases 
example attack ftp server may create directory long name cause buffer overrun subsequent directory listing operation 
shieldgen handle kind attack return byte offset offending byte attack data message 
case just need generate probes messages starting contains offending byte 

concluding remarks shieldgen system automatically generating data patches unknown vulnerability zero day attack instance 
key contribution leverage data format information construct new attack instances probes zero day attack detector oracle guide search vulnerability signature 
system practical number techniques reduce number probes needed including eliminating iterative elements obeying data format constraints leveraging protocol context 
implemented working prototype experimented known vulnerabilities respective attack instances 
able generate high quality vulnerability signatures efficiently 
signatures contain don care data fields signatures generated existing execution trace methods 
scheme yield signatures significantly fewer false negatives 
false negatives come imperfect data format specifications sampling technique probe generation 
conducted study vulnerabilities published 
estimate shield gen significant coverage data vulnerabilities superior accuracy compared execution trace signatures 
acknowledgments manuel costa miguel castro useful discussions 
laurent generating signatures 
crandall dawn song valuable comments draft 
shepherd anonymous reviewers detailed suggestions insightful comments 
data patch rpc vulnerability 
research microsoft com research shield papers htm november 
wang joshi guo 
generic application level protocol analyzer language 
proceedings th symposium network distributed system security ndss feburary 
newsome song wang jha :10.1.1.65.4914
automatic generation vulnerability signatures 
proceedings ieee symposium security privacy may 
costa crowcroft castro rowstron :10.1.1.164.7284
containment internet worms 
proceedings th acm symposium operating systems principles october 
crandall chong 
minos control data attack prevention orthogonal memory model 
proceedings th international symposium microarchitecture micro december 
crandall su wu chong 
deriving unknown vulnerabilities zero day polymorphic metamorphic worm exploits 
proceedings th acm conference computer communications security november 
cui paxson weaver 
gq realizing system catch worms quarter places 
technical report tr icsi 
cui paxson weaver katz 
protocol independent adaptive replay application dialog 
proceedings th network distributed system security symposium february 

kim karp 
automated distributed worm signature detection 
proceedings th usenix security symposium august 
crowcroft 
creating intrusion detection signatures honeypots 
proceedings acm sigcomm hotnets ii workshop november 
liang sekar 
fast automated generation attack signatures basis building self protecting servers 
proceedings th acm conference computer communications security november 
microsoft 
microsoft security bulletin ms 
www microsoft com security bulletin ms 
microsoft 
microsoft security bulletin ms 
www microsoft com security bulletin ms 
microsoft 
microsoft security bulletin ms 
www microsoft com security bulletin ms 
microsoft 
microsoft virtual pc 
www microsoft com windows default 
su 
hdd hierarchical delta debugging 
proceedings th international conference software engineering may 
moore paxson savage shannon staniford weaver 
inside slammer worm 
ieee magazine security privacy august 
moore 
framework 
www 
com 
newsome song 
vulnerability specific execution filtering exploit prevention commodity software 
proceedings th symposium network distributed system security ndss february 
newsome karp song 
polygraph automatically generating signatures polymorphic worms 
proceedings ieee symposium security privacy may 
newsome song 
dynamic taint analysis automatic detection analysis signature generation exploits commodity software 
proceedings network distributed system security symposium february 
pang paxson peterson 
binpac yacc writing application protocol parsers 
proceedings internet measurement conference october 
lee 
misleading worm signature generators deliberate noise injection 
proceedings ieee symposium security privacy may 
singh estan varghese savage 
automated worm fingerprinting 
proceedings sixth symposium operating systems design implementation december 
sans institute 
top critical internet security vulnerabilities press date 
www sans org top spring update php 
cert 
microsoft windows handler gdi escape vulnerability 
www kb cert org id 
ma chen moore snoeren voelker savage 
scalability fidelity containment virtual 
proceedings th acm symposium operating systems principles october 
blaster worm 

symantec com data 
blaster worm html 
wang guo simon 
shield vulnerability driven network filters preventing known vulnerability exploits 
proceedings acm sigcomm august 
wang li xu reiter kil choi 
packet vaccine black box exploit detection signature generation 
proceedings acm conference computer communications security november 
data patch wmf vulnerability 
research microsoft com research shield papers htm november 
barford jha 
architecture generating semantics aware signatures 
proceedings th usenix security symposium july 
