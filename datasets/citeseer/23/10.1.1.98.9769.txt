physical design refinement merge reduce approach nicolas bruno surajit chaudhuri microsoft research redmond wa usa microsoft com physical database design tools rely dba provided workload pick optimal set indexes materialized views 
tools allow creating new configuration adding new structures existing ones 
tools provide adequate support incremental flexible refinement existing physical structures 
refinements valuable completely manual approach refinement lead infeasible solutions excessive space 
focus important problem physical design refinement propose transformational architecture novel primitive operations called merging reduction 
operators help refine configuration treating indexes materialized views unified way succinctly explain refinement process 
categories subject descriptors physical design access methods 
decade automated physical design relational databases studied research groups agrawal chaudhuri narasayya valentin agrawal nowadays database vendors offer tools automatically recommend tune physical design relational database management system dbms agrawal 
tools require dba gather representative workload possibly profiling tools dbms able recommend indexes materialized views fit available storage representative workload execute fast possible 
paradigm physical database design address key scenarios great importance enterprises responding incremental changes gradual changes data statistics usage patterns may existing physical design inappropriate 
time physical design changes disruptive query plans drastically change 
incremental changes data statistics workload desire changes physical design possible meet constraints physical design storage update cost limited degradation respect optimal physical design 
unfortunately altogether new design driven automated tools different original tools limited support incremental tuning 
acm transactions database systems vol 

month yy pages 
nicolas bruno surajit chaudhuri significant manual design input despite wide availability automated tools physical design process database installations moderate high complexity rely manual input 
need manual input arise due reasons 
automated tools reduce complexity physical design process nontrivial identify representative workload drive physical design entirety 
second automated tools consider factors impact physical design impact replication architectures 
output physical design tool may fine tuned lifelong experience 
configuration designed manual input results non obvious redundancy increases storage update requirements 
interested incrementally refining initial configuration remove redundancy significantly impacting efficiency 
examples show need additional tools go statically recommending configuration workload 
specifically believe important automatically refine configuration eliminating implicit redundancy compromising efficiency 
call physical design refinement problem 
idea start initial possibly redundant configuration progressively refine property satisfied configuration size performance degradation meets pre specified threshold 
vm merge vm merging operation 
reduction operation 
vm vr reduce vr base tables fig 

merging reduction primitive operators physical design tuning 
think refinement session composed series basic transformations locally change current configuration trading space efficiency 
identify atomic operations merging reduction provide basic functionality 
merging reduction unify different techniques apply indexes materialized views proposed earlier literature 
intuitively see merging combines views avoids storing common information twice requires compensating actions retrieve original views 
reduction turn keeps smaller sub expression view requires additional possibly accessing base tables recreate original view 
see merging reduction analogous union acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach subset operators sets generally see proposed techniques moving traditional bottom architecture tuning physical designs see chaudhuri narasayya agrawal valentin transformation engine gives flexibility allows different optimization goals stated tackled unified way 
analogous appearance transformation query optimizers cascades framework graefe alternative classical bottom query optimizers system selinger 
believe merge reduce operators transformation engine guide search configurations potential foundation generation design tuning tools unifying seemingly disparate ad hoc techniques common flexible framework 
automatic design physical deployment section physical configuration manual design physical workload changes data distribution size changes manual changes configuration cost space complexity constrained design refinement physical sections fig 

physical design refinement scheduling cycle 
builds bruno chaudhuri address challenges physical design refinement structured follows 
sections introduce primitive operations merging reduction 
section address physical design refinement problem pdr 
section introduce important variations generalizations original pdr problem variation attempts minimize space final configuration exceeding cost bound denoted dual pdr generalization limits number transformations may applied original configuration denoted 
section formally define physical design scheduling eventually obtain combination elements family sets applying union subset operations 
analogously merging reduction seen fundamental building blocks manipulate designs indexes materialized views dbms 
acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri task deploy refinement 
section report experimental evaluation techniques section review related 
shows typical interaction dba different techniques introduced 
initially dba uses automatic tools conjunction manual tuning obtain initial configuration deployed section 
new physical configuration place dbms processes workloads triggering condition happens changes data distribution manual changes configuration motivating example discussed earlier 
point dba intervenes refines physical design techniques discussed sections 
depending unique characteristics dbms workloads physical design select optimization problem address pdr dual pdr 
interacting refining tools new configuration obtained deployed closing cycle 

merging operation section describe merging operation materialized views 
merging materialized views results new materialized view vm reduces amount redundancy 
resulting view vm usually smaller combined sizes expense longer execution times queries exploit vm original ones 
simple example consider materialized views select select suppose space required materialize large 
case replace alternative vm defined vm select main property alternative view query answered answered vm reason rewrite terms vm follows select select vm vm tuples satisfy significant fraction smaller sum sizes original views 
infact vm smallest view generate 
important note queries answered efficiently answered vm reason vm generalization contains additional non relevant tuples respect original views 
words merging vm effectively trading space efficiency 
formally define view merging operation 
acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach formal model formalize view merging operation consider query languages 
li language defines input views lm language defines merged views lc language defines compensating actions re create original views terms merged view 
definition 
li merging properties hold vm belongs lm 
vm vm vm andc vm 
view matching algorithm matches sub query matches vm view matching algorithm matches view subquery answered 
vm restricted additional predicates continue satisfy previous properties 
view merging view matching related problems 
idea view merging obtain pair views sort minimal view matched sub query original ones 
problems different technical details introduced related view matching literature 
example suppose li lm subset sql allows simple conjunctions single tables lc full sql language 
consider views select select merging views results select case merged larger combined sizes input views depends number tuples satisfy included belong 
contrast suppose relax lm include disjunctions 
case select larger put tuples satisfy included 
general merged views larger combined inputs redundancy depending expressive power lm acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri language section focus specific query languages address view merging operation detail 
specifically set li lm subset sql dbms materialized view matching denote language 
view expression select project columns see tables database equi join predicates range predicates see residual predicates see group grouping columns si base table columns column expressions aggregates 
group clause si aggregate equal gj columns expression terms 
ri range predicates 
general form range predicate disjunction open closed intervals column point selections special cases intervals 
example range predicate 
zi residual predicates set predicates query definition classified equi join range predicates 
words express class spj queries aggregation 
reason predicates split disjoint groups join range residual pragmatic 
query optimization easier perform subsumption tests view matching view candidate sub query written structured way 
specifically perform simple subsumption tests component component fail simple tests fails 
instance check join predicates query superset join predicates view range predicates column column query subsumed corresponding ones view 
subsumption tests complex notably group clauses 
note procedure focuses simplicity efficiency valid matchings due complex logical rewritings considered optimizer 
specifically consider case residual predicates 
problem determining predicates equivalent arbitrarily complex reason matching procedure consider just checks conjunct residual predicate view appears syntactically candidate query 
view subsume query match produced 
simplify notation view set columns select clause set tables sets join consider table integer columns 
checking predicates equivalent essentially proving fermat theorem 
took years prove specific conjecture expecting capabilities view matching algorithm unrealistic 
acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach range residual predicates respectively set grouping columns 
restrict merging operation input views agree set tables reason twofold 
hand top optimizers restrict view matching operation queries views agree input tables presumably candidate view contains fewer tables input query matched sub query earlier optimization 
hand merging views different input tables done combining reduce operator section merging operation defined section 
define merging operator 
case grouping columns consider merging andv 
merging language expressive define select satisfies properties definition 
satisfy property rewriting option consider predicate clause single conjunctive residual predicate problem merged view matched matched property simple procedures view matching general respect residual predicates particular 
need obtain smallest view vm satisfies property 
purpose rewrite minimal predicate follows conjunction crossed disjuncts 
strategy relax expression obtain predicate written matches candidate query matched original views 
procedure general introduce lot redundancy result larger views experimentally determined real world scenarios case 
relax expression removing conjunct reason leaves conjuncts andz map groups predicates 
consider recall ji conjunct equi join predicates 
simply resulting view language specifies conjunction simple equi joins disjunctions allowed 
rewrite 

jj relax predicate follows keep conjunct discard relax remaining ones 
obtain set join predicates merged view 
note predicate general original view matching procedure acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri match vm respect join subsumption test case 
idea residual predicate vm zk zk turns better range predicates due specific structure 
argument rewrite ri rj ri disjunctions open closed intervals column 
ri defined different columns discard conjunct 
defined column keep predicate ri union corresponding intervals denote operation symbol 
avoid missing predicates add conjuncts range predicates column range predicate change semantics input predicates restricts result 
union predicate column discard conjunct result 
example consider obtaining join range residual predicates described assemble set columns merged view 
minimum set contain union columns input views 
general illustrated 
consider instance select select candidate merged view select satisfy property definition obtained reason need apply additional predicates obtain obtain expose column reason need add set columns merged view columns join range residual predicates eliminated merged view 
similarly range predicate changed input merged view need add range column output column able reconstruct original views 
summarize merging views described section follows required columns note transformations mentioned take account column equivalence 
input views contain join predicate range predicates considered 
example 
example illustrates ideas described section 
materialized views described acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach select select merge select case grouping columns consider case merging views involve group clauses 
grouping operators partition input relation disjoint subsets return representative tuple aggregates group 
conceptually see group operator post processing step evaluation spj sub query 
consider merged view obtained grouping columns eliminated input views 
group columns input views different view partitions input relation different ways 
need partition merged view coarsest way allows recreate input view 
purpose set group columns merged view union group columns input views 
additionally column added select clause due predicate relaxation input views added grouping column 
note need handle special case properly 
input views contains group clause merged view contain group clause compromise correctness implicitly define union set columns empty set empty set 
situations additionally unfold original aggregates base table columns original aggregates computed resulting merged view 
summarize define sm gm sm set columns obtained group case plus group columns input views 
resulting gm aggregates unfolded base table columns 
gm columns added sm note gm 
example 
example illustrates ideas section 
andv materialized views described tables unique constraints define set group columns query group clause set columns table keep definition union unchanged 
correct tables duplicate values group clause columns eliminates duplicate rows equivalent query group clause 
acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri select sum select select sum group group equalities hold select select sum sum group note order recreate original views presence general algebraic aggregates need add additional columns merged view sum count original aggregate avg 
indexes materialized views far discussed merging operation applied materialized views paying attention indexes materialized views 
reality materialized view associated set indexes indexes query processing 
previous literature considered index merging view merging separate operations 
know describe handle structures unified manner 
purpose consider indexes defined view base tables trivial views definition includes regular indexes 
specifically sequence columns view contains columns select clause denote index columns materialized view special case define unordered heap containing tuples simplicity interchangeably 
unified merging operator define merging arbitrary indexes views 
section overload operator operate indexes views indexes views explicitly state case referring clear context 
consider simplest case merging indexes defined view 
case traditional index merging operation defined bruno chaudhuri chaudhuri narasayya 
im im contains columns followed columns example index merging acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach effective input indexes share common prefix 
case penalty replacing usages second input index merged index pronounced 
merged index better alternative primary index heap enabling narrower scan relevant data index evaluate non predicate column merged index effective specially underlying table contains columns 
address general case need introduce notion index promotion 
consider index suppose vm view promoting vm denoted vm results index vm compensating action 
promoted index contains columns original index followed column added select clause vm instance consider merged view select select select 
index promotion define merging indexes views follows obtain merged index view promote merged index merged view 

reduction operation previous section described mechanism decrease amount redundancy pair indexes views 
idea merge new index view smaller combined inputs 
section second operator works single input 
specifically exploit fact query optimizer attempts match query expression consider views subsume completely views subsume sub expressions suppose optimizer matching query expression case view matching engine consider available views subsume query expression matches expression rewritten compensating actions 
query optimizers consider views match sub expressions column orderings possible omit details simplicity 
acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri example views subsume sub expression omits table additionally projects column compensating join applied recreate view matches additionally performing join primary index general restrict index view sub expressions apply compensating actions recreate original structure 
call operation reduction denote symbol 
formal model formalize view reduction operation consider query languages 
li language defines input views lr language defines reduced views lc language defines compensating actions re create original views terms reduced view 
definition 
li reduction properties hold vr belongs lr 
vr vr 
view matching algorithm matches query expression attempt succeed matching vr sub query address reduction operation detail li lr language see section commonly view matching engines 
reduction language efficiency purposes query optimizers restrict sub queries considered 
optimizers consider sub expressions fewer joins containing applicable predicates affect tables sub expression common scenarios reduction operation takes index view iv tables set columns inputs returns new index iv 
index operational semantics steps follows reduction ill defined 
obtain reduced version tables defined andz base table column referenced refers exclusively tables contains subset columns belong tables plus columns referenced contains columns belong tables plus columns 

acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach contains cartesian products consider reduction invalid cartesian product provide efficiency advantage larger input relations 
obtain removing columns belong tables adding columns step similar 
reduction ill defined 
define example 
example illustrates ideas described section 
view defined select group select group 
physical design refinement formally define physical design refinement problem motivated merging reduction basic building blocks 
consider physical database configuration vn composed indexes views recall base table indexes defined trivial views 
assume obtained tuning dbms typical workload skilled dba automated tool agrawal 
size configuration combined size indexes plus size heaps indexes views primary index need primary index heap view size size ij vj size vk vk primary index suppose time database grows dba manually adds additional indexes see section size larger allocated space 
obtain configuration fits storage constraint compromising quality original configuration measure quality impact representative workload explained section 
considering possible index new configuration restrict search initial configuration derived series merging reduction operations 
rationale way succinctly explain refinement process analyze impact physical changes easily 
alternative allows acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri locally adapt original execution plan local compensating actions uses views new configuration 
understand consider query execution plan left 
highlighted sub plan seeks index predicate outputs columns upwards tree 
suppose reduce index 
clearly simply replace plan contain required column construct alternative sub plan compensating action case record id lookup primary index view replace original sub plan uses index new sub plan uses gives equivalent results 
resulting plan shown right valid equivalent uses reduced index original dba original execution plan change physical design limited changes query execution plan 
note re optimize query obtain optimal plan new configuration 
seek project reduced rid lookup seek fig 

local transformation reuse query plan reduced index 
problem statement introducing physical design refinement problem define search space introducing closure configuration merging reduction operations definition 
configuration ci defined follows see sections formal definition operators ci ci iv iv compatible iv iv ci iv ci valid choices define closure ck smallest integer satisfies ck ck 
words closure configuration set indexes views derived elements series merging reduction operations 
goal obtain subset closure fits available storage efficient possible representative workload 
definition physical design refinement pdr problem 
configuration vn representative workload storage representative workload produced skilled dba broad knowledge dbms usage 
possible section explores different alternatives automatically generate representative workloads 
acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach constraint define pdr refined configuration closure 
size 
qi cost qi minimized cost optimizer estimated cost query configuration optional weight associated query qi 
unfortunately pdr problem np hard prove appendix obtaining representative workload optimizing function pdr problem described measure quality candidate configuration turn defined expected cost representative workload section approaches generate representative workload explicitly provided discuss relative benefits costs 
inferred workload alternative cheapest obtain situation 
insight note current configuration obtained result tuning session dba automated tool 
expected indexes views current configuration useful answering queries actual workload 
propose infer hypothetical workload queries mimic functionality index current configuration 
assume new configuration efficiently process hypothetical workload benefits original indexes preserved 
index ways scan vertical fragment view ii scan sorted vertical fragment view iii seek tuples view condition key columns 
associate index iv set queries called queries iv define inferred workload iv iv 
query queries iv stresses different kind index usage iv shown scan ordered scan seek select select select group group prefix order group having prefix inferred workload described convenient 
simple implement require server changes 
depends current configuration absence additional knowledge dbms usage 
show experimentally competitive variety having clause clause 
cases expression prefix refers predicate prefix index columns 
acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri scenarios 
point inferred workloads attractive approach situations resulting workloads quite representative illustrated example 
example 
consider workload consisting occurrences query occurrences query select select situation optimal configuration obtained dba automated tool 
suppose space taken large decide refine inferred workload consists queries select select order select select select order select assume tables size columns width 
case inferred workload symmetric pdr arbitrarily choose keep possibility index merging reduction closure situation 
suppose loss generality pdr results new configuration independently relative frequencies 
making get arbitrarily suboptimal compared alternative configuration 
reason inferred workload account relative importance index original configuration 
profiled workload previous section argued track frequency queries actual workload different types index usages able infer representative workloads 
address drawback propose track small overhead optimization execution queries database 
way able obtain accurate weights refine queries inferred workload 
specifically time query optimized traverse resulting execution plan identify index usage scan sorted scan seek 
additionally seek usages obtain expected number tuples sought index 
normal query execution maintain counters attached index database information gathered optimization total scan usages total sorted scan usages total seek usages total sought tuples 
time need profiled workload obtain inferred workload maintained index counters assign weights inferred query 
prefix predicates generate conjunctive predicate cardinality equals average number sought tuples total sought tuples total seek usages 
profiled workloads require slightly overhead runtime inferred ones acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach need analyze query optimization maintain counters queries executed 
time resulting workloads representative show experimental evaluation 
fact profiled workloads better handle scenarios workload changes compared workload obtain initial configuration 
property 
workload wp profiled workload generated processed dbms 
able optimize queries local transformations pdr pdr wp wp indistinguishable purposes refinement 
crucial assumption property optimizer faced different configurations locally transform plan optimized original configuration see 
specifically allow join reordering group pushing complex transformations 
optimizer finding best access plan base table view predicate execution plan 
case difference cost query plan configurations affected choice fixed set access path requests see bruno chaudhuri details 
wp encodes requests captures variable portion execution plans difference cost configurations wp pdr result answer 
course reality query optimization goes local transformations 
property illustrates profiled workloads stronger guarantees inferred ones purposes physical design refinement 
fully logged workload naturally accurate way generating representative workload fully log queries executed dbms traditional physical design tools 
technique results overhead previous need log queries executed dbms obviously accurate way generate representative workload 
simplicity rest section inferred workload default input pdr results analogous input workloads 
workload automatically generated initial configuration shorthand pdr 
pruning search space properties useful defining heuristics traversing search space approximating pdr see proofs appendix 
configuration closure define base iv original indexes part derivation uses merging reduction produce iv sampling stratified variants chaudhuri nig reduce logging overhead expense loss representability 
acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri property 
configuration iv iv indexes closure ivm iv iv 
ivm closure base iv include iv ivm property shows merge indexes iv iv cases optimal solution contain merged index inputs 
show certain indexes part optimal solution 
property 
configuration iv iv indexes closure ivm iv iv 
size ivm size iv size iv ii ivk closure ivm ivm ivk holds size ivm size iv size iv size ivk pdr 
analogous properties reduction operator exist shown omit proofs similar properties 
property 
configuration iv index closure ivr iv tables columns closure base iv pdr include iv ivr 
property 
configuration iv index closure ivr iv tables columns size ivr size iv ii ivk closure ivr ivr ivk holds size ivr size iv size iv size ivk pdr 
section exploit properties heuristically speed solution pdr problem 
heuristic approach approximate pdr section introduce heuristic approach solve pdr inspired greedy solution fractional knapsack problem brassard 
fractional knapsack problem integer capacity set objects oi volume bi 
output set fractions fi object combined volume larger value maximized see traditional knapsack formulation restricting fractional knapsack fi zero 
solve fractional knapsack problem sort input objects oi ascending order value volume ratio ai bi remove objects sequence remaining objects fill completely capacity removed object ok exceeds case add back fraction ok total volume exactly input capacity assignment optimal fractional knapsack problem 
case fractional objects allowed heuristic performs practice simple refinement guarantees factor approximation optimal solution brassard 
reality sort objects reverse order keep prefix sequence 
equivalent solution described leads easily adaptation 
acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach note adapt knapsack problem scenario 
initial set consists indexes closure original configuration 
define volume index size uses dbms value index cost workload index minus cost workload index 
case straightforward adaptation greedy solution described generate closure input configuration progressively remove configuration index smallest value volume ratio remaining ones satisfy storage constraint 
approach problems size closure worst case exponential number original indexes 
time intuitively best views original ones obtained short sequence operations recall operation degrades performance workload 
indexes closure optimal configuration 
size volume index constant depends configuration belongs 
reason need account primary index heap associated different view definition 
indexes share view definition need single primary index heap 
impact value index expected workload cost depends configuration 
assign constant value index complex interactions inside optimizer 
index answer query useful conjunction index merge join plans 
index useful index eliminated configuration 
greedy solution fractional knapsack problem exploit domain specific properties section pruning search space 
address issues propose progressive variation solution fractional knapsack problem 
simplified pseudo code shown 
essentially start original configuration line progressively refine new configurations smaller slightly expensive 
current configuration cf large fit available space line identify set transformations refine cf lines pick promising line line obtain configuration 
obtain configuration storage constraint return line 
class transformations line greedy solution fractional knapsack problem remove indexes 
transformations lines explore augmented search space closure original configuration demand replacing indexes merged reduced index 
remainder section discuss details algorithm consider transformations lines deletion index current configuration cf ii merging pair compatible indexes cf iii reductions index cf 
specifically iii consider acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri configuration workload storage bound cf size cf tr delete iv iv cf tr tr iv iv valid iv iv cf tr tr iv valid iv cf select transformation tr smallest penalty cf cf antecedents consequent merge antecedent input views consequent merged view reduction antecedent input view consequent reduced view deletion antecedent view consequent empty return cf fig 

progressive knapsack physical design refinement problem 
reductions iv columns resulting index subsets tables match view cf 
heuristic derived properties line remove input indexes introduce transformed merged reduced index cf 
note check transformed index generated derivations see properties false negatives 
heuristic derived properties line consider transformations merges reductions result times larger combined sizes inputs small value 
heuristic avoids considering merged views cartesian products originate disjoint sets join predicates 
general heuristic result false negatives 
assigning constant value volume index dynamic approach considers interactions optimizer 
configuration define penalty transformation deletion merging reduction cost space cost estimate degradation cost expect applied transformation space amount space save applying transformation 
penalty values measure units time lose unit space gain transformation 
obtain space time values bruno chaudhuri penalties dynamic version value volume ratio original knapsack formulation 
avoid incremental errors estimation re optimize inferred workload new configuration cf transformation 
minimize optimization calls re optimizing queries workload index got removed cf rationale keep replacing indexes coarser alternatives query say iv configuration iv iv iv additionally available 
heuristic saves significant time degrades quality final configurations 
handle triggers considering cascading queries triggering query single atomic block consider relevant indexes altogether 
acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach note update queries far implicitly focused workloads composed entirely select queries 
reality workloads consist mixture select update queries 
main impact update query indexes defined updated table dependent views updated side effect 
similarly bruno chaudhuri conceptually separate update query components pure select query process small update shell 
instance query update set seen pure select query update shell select update top set estimated cardinality select query 
presence updates penalty values cost space certain transformations negative transformation removes index decrease total execution time large update overhead relatively smaller benefits query processing 
reason updates transform configuration smaller efficient 
exit loop lines configuration fits available storage configuration efficient satisfying storage constraint 
handle scenarios relax condition line follows size cf transformation penalty simplify presentation algorithms section keep assuming select workloads understanding concepts section applicable resulting algorithms 
discussion merge reduce 
closure input configuration merge reduction operators induces restricted search space configurations 
explain merge reduction operators fact cover set relevant indexes views physical design problem described context typical query optimizers 
consider sub query exactly matches view semantically equivalent 
matched answered generalization obtained adding additional group columns relaxing selection predicates 
definition larger effective answering sub query 
consider search space larger efficient original 
reasonable answer query workload 
sub query matched perfectly 
scenario having acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri original beneficial space smaller combined sizes albeit efficient answering 
consider search space noting generalization 
appropriate choice results specific view generalizes generalizations larger efficient 
conclude merge operation covers interesting views answer query expressions originally matched input set views 
consider sub expressions 
fact view vr generalization query rewrite answer see section 
sense consider search space sub expressions speed processing 
general reductions look somewhat dependent view matching engine 
view matching engines typically restrict space transformations matching rules efficiency purposes 
specifically usually sub queries matched compensated restricted view contain fewer joins 
reduction operator defined eliminating joins original view 
principle view matching engine capable union ing horizontal fragments single template expression answer sub query certainly consider range partitioning column potential primitive operator contrast definition iv 
reduction operator generality definition covers interesting views rewrite queries originally matched input set views note generalization reduced view covered merge operator 
putting believe merge reduction operators primitive building blocks capable generating wide class interesting views consider expressive power typical view matching engines expands translate richer versions merge reduction operations 

variations original pdr problem section introduce important variations extensions original pdr problem discussed previous section 
start discussing geometric interpretation pdr problem greedy solution section 
shows dimensional scatter plot illustrate main ideas 
point plot corresponds configuration 
axis represents size configuration axis represents expected cost evaluating input workload configuration 
see initial configuration large size small cost 
base configuration configuration contains mandatory indexes smallest possible size high cost due lack additional indexes 
dotted horizontal line crosses delimits feasibility region pdr configuration line large valid 
see initial configuration unfeasible problem trivial base configuration feasible problem solution 
goal pdr find configuration feasible region acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach efficient possible left plot 
transformation deletion merging reduction operations transforms configuration smaller efficient moves configuration right direction 
graphically shows candidate transformations expected effect initial configuration 
heuristic section chooses transformation minimizes value cost space 
graphically transformation corresponds angle closest vertical line descends steepest feasible region 
size initial configuration candidate transformations expected solution unfeasible configurations feasible configurations base configuration cost fig 

geometric interpretation pdr problem 
geometric interpretation useful understanding extensions discussed 
specifically section study comprehensive way explore search space 
section introduce dual basic pdr problem 
section constrained version pdr problem disallows configurations different original 
adding backtracking looking observe objective proceed steepest descent get feasible region 
main difficulty iteration know true value cost space just estimate 
reason bound making mistakes choosing wrong transformation due greedy nature algorithm risk getting bad sub space solutions 
guaranteed single sequence transformations results configurations cost space skyline obtained different paths 
illustrate point ran tpc database workload see section details experimental setting obtained configurations connected lines 
ran multiple times iteration chose transformation random transformation top 
shows configurations discovered way illustrates configurations skyline necessarily ones obtained 
mitigate problem propose variation algorithm comprehensively searches space configurations 
specifically acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri space mb estimated cost secs 
fig 

discover configuration cost space skyline 
low multiple invocations original solution starting different initial points different transformations 
shows pseudocode bt implements idea note backtracking choices possible 
lines original 
key difference line select best unused transformation current configuration configuration considered multiple times 
iteration lines bt obtain new feasible configuration line maintain best configuration iterations 
line selects initial configuration iteration implements backtracking mechanism 
time start input initial configuration original 
subsequent iterations consider candidate starting points set ancestors best configuration far configurations iteratively transformed initial current best configuration 
pick resulted largest error estimating penalty value see dotted arrows represent estimated penalty values plain arrows actual ones 
rationale restarting configuration choosing transformation able correct previous mistakes 
function selects initial configuration new iteration main algorithm 
calling evaluated ancestors current best configuration actual values cost space obtain actual penalty value error estimation 
line bt controls time spend algorithm 
timeout function implemented different ways 
instance give wall clock limit bt bound number iterations inner loop lines 
dual pdr problem introduce dual pdr problem interesting variation physical design refinement 
putting constraint size resulting configuration require configuration cost worse certain percentage current configuration minimum possible size 
interested removing redundancy manually tuned configurations dual pdr problem attractive approach 
acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach size initial configuration backtracking solution cost fig 

backtracking configuration largest estimated penalty error 
bt configuration workload storage bound cbase cbase base configuration timeout cf cbase size cf tr delete iv iv cf tr tr iv iv valid iv iv cf tr tr iv valid iv cf select unused transformation tr smallest penalty cf cf antecedents consequent cost cf cost cf return configuration cs cp cp ancestor cp ancestor obtained cp transformations return cs maximum value score score expected penalty actual penalty fig 

backtracking configuration space obtain better solutions 
define dual pdr problem formally 
definition dual physical design refinement dual pdr problem 
configuration vn representative workload constraint define dual pdr refined configuration closure 
qi cost qi 
size minimized 
shows graphical interpretation dual pdr problem 
dual pdr problem feasibility region vertical line crosses 
contrast pdr initial configuration feasible problem solution generally base configuration unfeasible problem trivial 
address new scenario stratify penalty function transformations expected result configurations unfeasible region cost wise ranked lower transformations result valid acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri size feasible configurations unfeasible configurations initial configuration candidate transformations expected solution base configuration cost fig 

geometric interpretation dual pdr problem 
configurations 
refinement heuristic pdr applicable dual pdr problem reuse 
remaining difference dual pdr problem stopping criterion fact stopping return previous configuration current definition unfeasible 
shows pseudocode dual pdr problem slightly adapted greedy solution 
configuration workload mc cost bound cf cp null cost cf mc cp cf tr delete iv iv cf tr tr iv iv valid iv iv cf tr tr iv valid iv cf select transformation tr smallest penalty cf cf antecedents consequent return cp fig 

solution dual physical design refinement problem 
add backtracking capabilities analogously 
keep presentation short omit details 
constraining number transformations physical design refinement restricts exploration physical structures closure original configuration ensures incremental changes original design 
easily explain obtained resulting refined configuration detailing sequence transformations required arrive final configuration 
far small number changes objective implicit formulation problem way bounding different final configuration original 
section generalize pdr problem take constraints number acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach allowed transformations deletion merging reduction obtain final configuration initial 
formally define constrained pdr problem 
definition constrained pdr problem 
configuration vn representative workload storage constraint integer bound mt define mt refined configuration closure 
size 
tk ti valid transformations mt 
qi cost qi minimized 
words extends classic pdr problem imposing additional constraint number changes original configuration allowed result 
introducing additional constraint significantly change space solutions 
particular problems constrained unfeasible happen original pdr dual pdr problems recall base configuration initial solutions corresponding problems trivial exceptions 
additionally new constraint number allowed transformations exploration search space difficult 
reason smaller number allowed transformations difficult reach configuration feasible region 
configuration workload storage bound mt transformation bound cf size cf cf mt tr delete iv iv cf tr tr iv iv valid iv iv cf tr tr iv valid iv cf select transformation tr smallest penalty cf cf antecedents consequent size cf cf null return cf solution fig 

constrained physical design problem 
shows straightforward mechanism extend algorithm section 
changes additional condition line process feasible configurations cf mt number transformations initial ii final checking line avoid returning unfeasible configuration 
note constrain number applications transformations types transformations 
acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri changes ensure consider feasible configurations resulting algorithm sound 
unfortunately presence space constraints small number transformations situations algorithm fail produce feasible solution specially small values mt 
adding backtracking previous algorithms helps issue search ineffective 
address problem need modify ranking candidate transformations focus search strategy feasible solutions constrained search space 
specifically stratify ranking function discussed bellow 
stratification 
original penalty function uses ratio cost space considering absolute length step 
number allowed transformations small transformation great penalty value minimally decreases configuration size useful extreme remaining transformation transformations useful reduce configuration size storage bound 
handle issue stratify ranking function 
specifically identify subset transformations useful rank useful transformations ahead remaining ones consider remaining transformations penalty values just approximations want erroneously prune search space 
consider configuration cost space obtained applying transformations original configuration 
case need diminish size mt transformations 
case proceed follows sort candidate transformations descending order space 
calculate mt space sum top mt transformations sorted space 
indication maximum amount space able reduce applying current transformation 
note indication configurations transformations change due interactions transformations 
label transformation tr useful value space 
words consider transformations estimated sense opportunity transitioning configuration feasible region bounded number transformations 
dual problem similarly section define dual constrained pdr problem dual 
dual problem try minimize size resulting configuration exceeding certain cost number transformations 
adapting penalty function new scenario complication analogous problem arises 
situation risk obtaining suboptimal configurations bound number allowed transformations 
fact start feasible region see aggressive choosing transformations get closer alternatives 
example suppose single remaining transformation apply 
case choose acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach minimizes cost space simply maximizes space minimizes space feasible ones recall dual problem try minimize configuration size 
words mt large proceed original solution 
get fewer fewer remaining transformations apply give relative weight cost values 
purpose bias definition penalty values transformations follows 
consider configuration cost space obtained applying transformations original 
case need minimize size incurring mc additional cost mt additional transformations 
define penalty transformation mt space mt initially mt close behave original dual pdr problem 
number remaining transformations decreases tends mt value tends zero smoothly transition alternative space 
cost 
physical design scheduling physical design refinement session required implement deploy recommended configuration 
course problem different analogous case regular tuning session takes place 
surprisingly problem addressed literature 
section formalize task show cast search problem goal provide full treatment problem probably require separate article 
current configuration cf desired configuration deploy cf obtained regular tuning session answer pdr problem 
physical schedule consists sequence index creation index drop statements starts configuration ends configuration cf physical design scheduling problem consists finding minimum cost schedule storage max size cf size need size cf space accommodate intermediate results creating indexes cf 
example consider configurations database single table cf naive schedule remove indexes cf create indexes cf drop create create create create index say require sort vertical fragment table view column important note speed creation existing indexes 
specifically index leading column exists database build sorting just scanning acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri index 
schedule better original assuming indexes intermediate step fit storage constraint create drop create create case avoid sorting table saving time 
realize saving need able store simultaneously 
fact efficient schedules create additional intermediate structures outside cf 
consider schedule create drop create create create drop situation create temporary index creating 
need sort built minor sort secondary columns efficient full alternative key sorting required 
schedule efficient previous time requires additional storage intermediate results 
general problem defined follows 
definition physical design scheduling pds problem 
configurations cf space constraint obtain physical schedule pds cf sn cf si drops existing index creates new index closure cf 
size intermediate configuration plus required temporary space corresponding si bounded 
cost implementing sn minimized 
main challenges pds problem explosion search space due ability add elements closure cf ii space constraint invalidates obvious approaches topological orders 
introduce property connects pds problem shortest path algorithm induced graph 
property 
consider instance physical design scheduling problem pds cf induced graph defined follows closure cf size 
directed edge symmetric difference single element 
weight equal cost creating index starting configuration cost dropping index 
label edge corresponding create drop action 
case solution pds cf sequence labels shortest path cf induced graph defined 
property directly lead efficient algorithm induced graph exponential number nodes worst case starting point define search strategies 
instance acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach nilsson algorithm progressively explores search space generating induced graph demand 
details strategies outside scope 

experimental evaluation section report experimental results evaluation techniques introduced 
experimental setting implemented various pdr algorithms sections client application microsoft sql server dbms 
experiments tpc database workloads generated utility www tpc org default asp 
section evaluate original pdr algorithm section 
section analyze impact backtracking extensions section 
section report evaluation constrained pdr problem defined section 
keep presentation short report results original pdr problem omit dual pdr problem similar 
original pdr problem goal section compare pdr algorithm section stateof art physical design tools agrawal regarding quality refined configurations time takes obtain 
purpose proceeded follows 
took workload tuned physical database ool design tool maximum storage obtaining configuration cb second ool refined cb pdr implementation stricter storage constraint inferred workload obtaining configuration third re tuned scratch new storage constraint obtaining ool configuration cb evaluated cost original workload ool ct time took produce alternative configuration 
fraction execution cost base configuration pdr tuning tool new storage constraint gb new storage constraint gb quality resulting configurations 
time obtain configurations 
time obtain new configuration seconds pdr tuning tool fig 

refining configurations vs producing new configurations scratch 
acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri shows results gb tpc database initial storage constraint gb query tpc workload obtained query workload running tool removing queries output 
values ranging gb little refinement gb aggressive refinement 
measure cost configuration fraction cost base configuration contains primary indexes 
see cases refined configuration obtained pdr slightly quality alternative obtained scratch tuning tool 
fact cost difference original workload configurations cases 
additionally shows time takes refine configuration orders magnitude smaller produce new configuration scratch note logarithmic scale 
analyzing configurations take closer look resulting configurations pdr tuning tool 
purpose took query workload defined tuned tpc database tuning tool recommends indexes ool base tables fitting gb denote configuration gb 
ran pdr space bound gb obtaining gb re ran tuning ool tool space bound gb obtaining gb table summarizes cost original workload configurations time took obtain configurations 
configurations gb effective original gb running automatic tool scratch results slight improvement compared pdr confirming results previous section case configurations index base tables 
difference large refined configuration additional benefits 
took seconds obtain refined configuration seconds running tuning tool scratch 
ool ool difficult understand changed gb ct gb short doing manual analysis sets indexes case ool find indexes gb obvious relationship ool 
contrast easily explain changed doing refine gb ment queries affected changes 
specifically steps pdr delete part size partkey type delete orders custkey merge lineitem orderkey partkey suppkey quantity discount lineitem partkey orderkey quantity suppkey discount delete part brand container size partkey shipdate suppkey orderkey discount partkey quantity lineitem shipdate discount quantity suppkey partkey 
better appreciated comparing execution plans queries workload different configurations 
example consider query workload select sum quantity aggregates lineitem shipdate group order acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach configuration fraction cost base conf time obtain configuration ct ool gb secs 
ct ool gb secs 
gb secs 
table fraction cost refining configuration versus creating new scratch 
shows execution plans configurations consid ool eration 
see gb see seek covering index tuples satisfying condition shipdate group plus aggregation hash algorithm 
sort intermediate results hash alternative necessarily output tuples right order 
optimizing gb see see plan covering index replaced merged alternative described 
resulting plan efficient similar ool original plan 
contrast optimizing gb see resulting plan scans covering index key filters fly tuples shipdate predicate 
resulting tuples grouped aggregated sort alternative right order 
ool gb results slightly better performance gb input workload usually takes longer produce results execution plans different original ones desirable 
sort gb aggregates hash seek shipdate ct ool gb sort gb aggregates hash seek shipdate pdr gb gb aggregates sort filter shipdate ordered scan ct ool gb fig 

plans produced query workload different configurations 
varying workloads previous experiments assumed workload initially tune database change workload evaluate resulting refined configurations 
real scenarios workloads tend drift actual queries frequency distribution 
evaluate scenarios conducted experiment 
initially took workload tuned design tool gb storage obtaining initial configuration 
second evaluated acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri slightly different workload dbms 
new workload generated follows changed frequency distribution queries uniform zipfian ii removed queries smallest frequency iii added queries produced initially excluded evaluating refined current configuration workload generating alternatives section stricter storage constraints gb gb 
re tuned scratch new storage constraint evaluated new resulting configurations 
fraction execution cost base configuration tuning tool fig 

new storage constraint gb refining configurations underlying workload drifts 
see inferred workload performs worse information exploits date anymore 
note resulting configurations considerably better base configuration 
profiled workload results improve extract additional information execution new workload assign representative weights queries generated workload 
fully logged workload best alternative results similar 
gap pdr original workload tuning dbms scratch due reasons 
access original workload refinement starts original configuration physical structures tuned specifically queries 
second quick refinement pdr suboptimal compared full tuning physical design tool 
effect backtracking section evaluate effect backtracking quality resulting configurations 
generated new query tpc workload tuned dbms optimal performance physical design tool obtained gb configuration 
initiated pdr session bt storage constraint gb time limit minutes 
shows expected cost current best configuration new configuration evaluated bt 
minute evaluating close configurations bt solution acm transactions database systems vol 

month yy 
execution cost best configuration physical design refinement merge reduce approach number configurations explored execution cost best configuration iteration 
skyline configurations 
fig 

exploiting backtracking obtain better configurations bt 
size mb configurations expected cost units final solution original algorithm 
bt started backtracking process best configuration kept improving units 
shows evaluated configuration cost space skyline 
note configurations skyline belong refinement sequence taken different iterations inner loop bt 
constrained pdr problem section evaluate constrained pdr problem defined section 
purpose generated optimal gb configuration physical tool query workload generated concatenating different executions 
generated instances storage constraint gb different bounds number allowed transformations 
fraction cost base configuration original ranking stratified ranking size mb maximum number transformations expected cost effect stratified ranking function 
configurations explored 
fig 

evaluating constrained physical design problem 
skyline shows fraction cost resulting configuration respect base original penalty function modification section 
see larger number allowed transformations maxt better resulting configurations 
maxt algorithm acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri original penalty function failed obtain solution show corresponding bar 
contrast modified penalty function algorithm able find feasible solutions maxt 
reason effectively biases search strategy feasible configurations constrained space 
complement analysis shows typical sequence configurations explored execution greedy varying values maxt 
related years considerable research automated physical design dbmss 
pieces agrawal chaudhuri narasayya valentin agrawal detail solutions consider different physical structures ideas transferred commercial products agrawal 
line successful fails address common scenarios discussed collectively refer physical design refinement 
contrast previous presents new complementary paradigm considers current physical database design evolves meet new requirements 
previous literature adopted ad hoc approach regarding transformations exploited physical database design 
chaudhuri narasayya introduces concept index merging similar define generalize notion indexes views 
similarly agrawal exploits transformations combine information materialized views giving formal complete framework 
goldstein larson presents overview related view matching shares technical details specifically respect view merging 
believe consider unified approach primitive operations indexes materialized views form basis physical design tools 
ideas inspired bruno chaudhuri presents relaxation approach physical design tuning 
introduces concept relaxation transform optimal configuration obtained intercepting optimization calls fits available storage 
main focus bruno chaudhuri obtain optimal design scratch workload notion transformations secondary importance 
specifically bruno chaudhuri considers transformations indexes materialized views different entities provide unifying framework 
bruno chaudhuri notion merging indexes investigating new directions physical design tuning 
specifically bruno chaudhuri provides quick lower upper bounds expected benefit comprehensive tuning tool considers merging indexes crucial component main algorithm 
hand bruno chaudhuri proposes alternative approach physical design problem 
specifically introduces algorithms acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach continuously modify current physical design reacting changes query workload 
specifically techniques analyze workload maintain benefit penalty values current hypothetical indexes including merged indexes modify current configuration response changes query workload 
extends bruno chaudhuri 
addition expanded treatment items original submission addresses new issues 
identified novel approach profiled workloads knowledge usage database balance accuracy resulting physical configuration required overhead section 
section discussed geometric interpretation pdr problem original solution offers different perspective pdr problem 
interpretation explored new search alternative backtracking original pdr problem section 
introduced alternative problem formulations pdr problem 
specifically section introduced dual pdr problem minimizes space final configuration exceeding bound cost section introduced constrained pdr problem limits number transformations may applied original configuration 
formally defined physical design scheduling problem essential step implementing physical design changes section 
literature query optimization vast addresses problems implicitly merge reduce building blocks described 
instance multi query optimization problem long history see finkelstein park segev sellis roy 
objective exploit common subexpressions queries reduce evaluation cost queries isolation execute sub optimally 
detecting exact matches improvement techniques extend exact matches subsumed expressions 
words pair expressions techniques try obtain specific expression 
main issues revolve matching efficiency greedy techniques incorporate common sub expressions regular query optimization problem statement easily terms view merging reduction 
example ross address problem materialized view maintenance 
shows find efficient plan maintenance set materialized views 
specifically exploit common sub expressions views reach analogous section creating additional materialized views reduce total maintenance cost 
contrast physical design scheduling problem section concerned cost maintaining set materialized views complementary issue transition configuration new 
case ross rephrased context merging reduction operations search conducted closure original set views 
pds problem section similar register allocation problem studied compiler literature chaitin 
register allocation problem consists allocating large number program variables small acm transactions database systems vol 

month yy 
nicolas bruno surajit chaudhuri number cpu registers order keep operands possible registers maximize performance compiled programs 
problems schedule scarce resources disk vs cpu registers minimize execution cost program physical restructuring vs arbitrary compiled code 
significant differences problems 
structures need allocate pds vastly different sizes register allocation problem size registers fixed 
pds allows flexible schedules concerned initial final configuration change order intermediate operations arbitrarily 
pds consider additional temporary structures part initial final configuration maximize performance 
solutions register allocation problem directly applicable pds opportunities research better understanding relationship problems 

introduce study depth variants physical design refinement problem fills important gap functionality known physical design tools 
building new configurations scratch requirements change enable progressive refinement current configuration new satisfies storage update constraints 
exploiting new operators merging reduction balance space efficiency 
configurations obtained physical design refinement easily explained 
believe new functionality important addition repertoire automated physical design tools giving flexibility cope evolving data distributions workloads 
proofs theorem 
pdr problem np hard 
proof provide reduction knapsack 
knapsack problem takes inputs integer capacity set objects oi volume bi 
output subset oi combined volume fits sum values maximized 
consider arbitrary knapsack problem capacity elements 
create pdr instance follows 
associate oi view vi select ti ti single column table contains bi tuples value zero ai tuples value 
define initial configuration vi representative workload vi 
views refer different tables possibility merging views 
additionally index defined single column reduction possible 
pdr problem reduces finding best subset original indexes views 
vi final configuration scan base table ti obtain zero valued tuples answer qi 
base table ti ai bi units size ai units larger view size bi tuples ti satisfy 
assuming scan costs linear value having vi result time save having index ai size bi 
solving pdr acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach iv base iv 
iv iv iv ivm fig 

pruning indexes views pdr search space 
iv view matching problem generate knapsack solution mapping subset views result original objects oi 
property 
configuration iv iv indexes closure ivm iv iv 
ivm closure base iv include iv ivm proof suppose iv ivm belong pdr 
consider indexes inferred queries evaluated ivm call set cm 
index iv cm case ivm matches composed iv reduction iv define set indexes cm corresponding reductions matched ivm iv show consider replacing ivm pdr iv alternative configuration denoted pdr better pdr 
show pdr larger pdr 
purpose note iv obtained merging elements subsumed ivm ivm iv ivm merged ivm incorporate captured ivm 
additionally hypothesis iv ivm reason indexes base iv optimizer better execution plans replacing usages ivm better alternatives iv 
iv closure cm closure base iv equal ivm iv ivm ivm iv ivm consequently iv strictly smaller ivm pdr smaller pdr 
queries inferred indexes cm execute slower pdr supporting indexes 
queries inferred indexes cm execute faster pdr optimizer replace usages ivm execution plans efficient alternatives smaller iv pdr efficient pdr proves property 
property 
configuration iv iv indexes closure ivm iv iv 
size ivm size iv size iv ii ivk closure ivm ivm ivk holds size ivm size iv size iv size ivk pdr 
proof suppose ivm belongs pdr configuration ii hold 
hold replacing ivm iv iv results smaller configuration 
additionally query inferred acm transactions database systems vol 

month yy 
cm iv nicolas bruno surajit chaudhuri dex base iv base iv answered efficiently iv iv ivm query inferred index ivk base iv base iv ivk greatly benefit ivm see 
case iv reduced ivk ivm iv ivm ii hold combined size iv iv ivk smaller ivm replace ivm ivi obtain better configuration 
ivm belong pdr ii hold 
agrawal chaudhuri marathe narasayya 
database tuning advisor microsoft sql server 
proceedings th international conference large databases vldb 
agrawal chaudhuri narasayya 
automated selection materialized views indexes sql databases 
proceedings international conference large databases vldb 
agrawal chu narasayya 
automatic physical design tuning workload sequence 
proceedings acm international conference management data sigmod 
brassard 
fundamental algorithmics 
bruno chaudhuri 
automatic physical database tuning relaxation approach 
proceedings acm international conference management data sig mod 
bruno chaudhuri 
physical design refinement merge reduce approach 
international conference extending database technology edbt 
bruno chaudhuri 
tune tune 
lightweight physical design 
proceedings international conference large databases vldb 
bruno chaudhuri 
online approach physical design tuning 
proceedings international conference data engineering icde 
chaitin auslander chandra cocke hopkins markstein 
register allocation coloring 
computer languages 
chaudhuri gupta narasayya 
compressing sql workloads 
proceedings acm international conference management data sigmod 
chaudhuri narasayya 
efficient cost driven index selection tool microsoft sql server 
proceedings rd international conference large databases vldb 
chaudhuri narasayya 
index merging 
proceedings international conference data engineering icde 
das dias zait 
automatic sql tuning oracle 
proceedings th international conference large databases vldb 
finkelstein 
common subexpression analysis database applications 
proceedings acm international conference management data sigmod 
goldstein larson 

optimizing queries materialized views practical scalable solution 
proceedings acm international conference management data sigmod 
graefe 
cascades framework query optimization 
data engineering bulletin 
nig 
scalable exploration physical database design 
proceedings international conference data engineering icde 
acm transactions database systems vol 

month yy 
physical design refinement merge reduce approach roy sudarshan ramamritham 
materialized view selection maintenance multi query optimization 
proceedings acm international conference management data sigmod 
nilsson 
problem solving methods artificial intelligence 
park segev 
common subexpressions optimize multiple queries 
proceedings international conference data engineering icde 
ross srivastava sudarshan 
materialized view maintenance integrity constraint checking trading space time 
proceedings acm international conference management data sigmod 
roy seshadri sudarshan 
efficient extensible algorithms multi query optimization 
proceedings acm international conference management data sigmod 
selinger 
access path selection relational database management system 
proceedings acm international conference management data 
sellis 
multiple query optimization 
acm transactions database systems tods 
valentin lohman 
db advisor optimizer smart recommend indexes 
proceedings international conference data engineering icde 

db design advisor integrated automatic physical database design 
proceedings th international conference large databases vldb 
ma lohman cochrane pirahesh colby liang valentin 
recommending materialized views indexes ibm db design advisor 
international conference autonomic computing 
acm transactions database systems vol 

month yy 
