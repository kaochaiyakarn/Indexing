revised report syntactic theories sequential control state matthias felleisen department computer science rice university houston tx robert hieb computer science department indiana university bloomington rice university technical report appear theoretical computer science revised report syntactic theories sequential control state matthias felleisen department computer science rice university houston tx robert hieb computer science department indiana university bloomington syntactic theories control state conservative extensions calculus equational reasoning imperative programming facilities higher order languages 
simple calculus extended theories mixtures equivalence relations compatible congruence relations term language significantly complicates reasoning process 
develop fully compatible equational theories imperative higher order programming languages 
new theories subsume original calculi control state satisfy usual church rosser standardization theorems 
new calculi equational reasoning imperative programs simple reasoning functional programs 
syntactic theories control state calculus programming languages provide imperative programming facilities assignment statements exceptions continuations 
typical examples ml scheme common lisp 
additions add expressive power increase efficiency programs appear invalidate simple reduction rules equational reasoning calculus functional programming appealing 
previous papers shown conservative extensions plotkin calculus programming languages possible reason programs extended functional languages equational style 
main difference simple lambda calculi extended versions distinction classes equations equations ordinary expressions equations programs 
reason distinction need arrange effects assignments jumps appropriate order 
example program supported part nsf ccr darpa nsf ccr 
supported part nsf ccr 
equivalent program subexpression replaced context expression occurs may contain able perceive assignment calculi satisfy relatively simple variants church rosser standardization properties 
importantly satisfy plotkin criteria correspondence programming language reduction calculus standard derivations calculi yield value program operational semantics subset calculi equations ordinary expressions operationally sound 
property important programmer relatively simple reduction system determine value imperative higher order program rewriting program value 
second property basis program transformations program correctness proofs 
restriction indicates calculi complicated equational theories equivalences equations usual sense 
distinction unnatural leads problems reasoning equational properties programs 
way simplify equational theories imperative programming language modify programming language 
example showed adding control delimiter facility calculus extended control operators simplify calculus get elegant relationship language calculus 
proposal provides example calculus design influence improve language design alleviate need better techniques reasoning existing languages 
languages scheme ml common lisp grown practical experiences support practical applications need calculi tuned specific needs 
solution problem relax plotkin correspondence criterion 
precisely longer require standard derivation programming language calculi terminate value machine produces value program 
allow standard derivation produce kind term recognizable final answer 
kinds imperative extensions control operators assignments result simple equational calculus imperative higher order programming languages prove set observational equivalences old calculus elegant axiomatic basis 
reasoning new calculi simple reasoning traditional calculus 
section briefly summarize plotkin calculus constitutes basis research 
sections new theories control state respectively 
sections briefly introducing old calculi provide machine independent semantics languages standards measure new theories 
sections introduce new calculi analyze relationships old new calculi 
fifth section describes merger theories 
discuss related implications alternative denotational semantics extended functional languages 
value calculus expression language calculus calculus union set values expression 
set values collection basic constants functional constants variables vars abstractions constants correspond built algebraic language primitives numbers booleans mathematical functions identifiers placeholders values abstractions call value procedures 
expression juxtaposition denotes function application 
binding construct programming language abstraction 
set closed expressions set expressions free variables values set closed values 
adopt barendregt conventions bound variables abstractions bound variables distinct free variables various expressions mathematical definitions claims 
abstractions differ renaming bound variables identified expression result substituting expression free variable expression important parameter language definition set constants interpretation 
plotkin assume behavior constants specified partial function functional basic constants closed values values mid landin illustrated series papers interesting powerful programming language 
importantly showed simple calculator algebraic expressions extended secd machine evaluating complete programs 
programmer perspective secd machine interpreter implements partial function programs answers closed expressions closed values eval secd values programming language operational semantics term language church calculus raises natural question concepts correspond 
plotkin provided answer defining calculus matches evaluation function eval sced providing modified implements calculus correctly sense landin style interpreter 
original secd semantics calculus precisely model callby value parameter passing technique predominant functional subsets programming languages 
easy implement call value provides obvious order evaluation facilitates addition imperative features 
theoretical reason choosing presence control operators assignments 
calculus equational theory 
precisely set equations set term relations 
basic relations notions reduction fa 
equational theory smallest congruence relation generated relations 
formal definition rely concept term context expressions hole place subexpression 
expression stands result putting expression hole context may bind free variables notions reduction definition contexts definition straightforward 
definition 
basic notion reduction step reduction compatible closure expressions context reduction denoted reflexive transitive closure smallest equivalence relation generated ife 
calculus characteristic properties church original calculus 
defining notion reduction church rosser reduction satisfies diamond property 
theorem plotkin exists expression second sequence single reduction steps term canonical sequence steps terms algorithmically 
idea important analysis correspondence calculus machine 
easy see eval secd correct 
abstraction possibly different values reduces eval secd interpreter yield value determine value sequence reductions need canonical reductions algorithm compute 
describe basis algorithm state corresponding theorem need definitions 
evaluation context special kind context 
hole evaluation context position redex inserted hole leftmost outermost redex inside abstraction 
range set evaluation contexts define grammar 
definition evaluation context say standard reduces reduction occurs evaluation context 
words standard reduction function picks leftmost outermost redex outside scope expression 
undefined values 
definition 
standard reduction function standard reduction function maps evaluation context weuse denote transitive closure standard reduction function 
concept standard reduction sequences generalizes idea standard reduction function standard reductions arbitrary term positions 
standard reduction sequence permits incomplete reduction sequences may choose reduce leftmost outermost redex rest sequence 
definition 
standard reduction sequences set standard reduction sequences defined follows 
constant variable standard reduction sequence 

en standard reduction sequence en 

pn qm standard reduction sequences 

en standard reduction sequence en standard reduction sequence 
formalize curry feys style standardization theorem 
theorem plotkin standard reduction sequence church rosser standard reduction theorems show perfect correspondence secd evaluation function standard reduction function 
theorem plotkin closed terms 
eval secd words secd machine terminates returns value program program standard reduces value 
possible define evaluation function standard reduction function ignoring details actual machine eval df iff determining reductions calculus correspond evaluations machine question remains equations calculus mean programmer 
understand relationship recall programmer observe effects entire programs evaluator 
compare expressions black boxes programmer rely equivalences evaluation function validate programs expression occur 
argument naturally leads definition operational equivalence relation 
definition 
operational equivalence terms equivalent indistinguishable program contexts basic constant eval terminates iff eval terminates eval iff eval plotkin showed calculus sound respect operational equivalence 
theorem plotkin inverse direction hold 
theorems basis formal correspondence relation programming languages calculi 
stipulate 
calculus evaluate program way independently operational semantics 
equations calculus imply interchangeability expressions arbitrary contexts 
criteria basis development programming language calculi 
theories control language programming procedural control abstractions extension set applications form ce ee ce 
application applies subexpression abstraction current control context continuation 
application takes place empty control context halt continuation 
continuation class status abstraction invocation discards control context application resumes abstracted control context argument 
notion control abstraction derived treatment continuations programming language scheme 
continuation created application acts just continuation created scheme continuation constructor call cc application differs call cc application aborts current control context leaves current control context intact 
affect allows define abort abstraction abbreviation application subexpression procedure ignores argument df fv 
effect abort program evaluation 
discards current control context returns value subexpression final value program 
abbreviation simplify reduction rules applications 
applications syntax adopted mutatis mutandis 
definition set values retains shape subexpressions extended language similarly specification set evaluation contexts stays denotes set evaluation contexts subexpressions extended language subsection briefly presents original theory control abstractions emphasis set safe equations complete description refer reader earlier report 
second subsection contains development finite axiomatization theory safe equations 
plotkin style correspondence theorem relies proof equivalence calculi idea old calculus acceptable specification semantics final subsection presents interesting extensions equational theory 
syntactic theory control abstractions originally derived syntactic theory control operational semantics landin secd machine 
eliminating non program text components machine shows concept current continuation equivalent notion evaluation context 
machine transition rules abstracting control state naturally lead term relations gradually lift application top evaluation context encoding context abstraction 
expression ce occurs function part application ce immediate continuation application unknown function expression rest continuation continuation entire application 
composing pieces fe yields functional part continuation ce argument continuation abort context invocation wrap expression application 
obtain outer part continuation application xe 
similarly control expression occurs argument part application abstraction control context applies known function unknown argument passing result continuation entire application vx 
assumption left part application value reflects left right evaluation order underlying language 
facilitate formal definition rules introduce notion singular evaluation context 
singular evaluation contexts definition schema suffices specifying reduction relations 
relation lifting applications gives rise extended notion reduction 
notion reduction defines full reduction relation congruence relation usual way 
church rosser curry feys style standard reduction sequences 
symbol denotes standard reduction function respective theorems proofs straightforward adaptations proofs plotkin corresponding theorems 
complete simulation machine reduction insufficient applications get stuck top program 
introduce computation rule maps application top program application subterm halt continuation ax ax 
ct extended reduction computation rule forms computation relation ct computation relation satisfies diamond property ct applies entire programs computation relation satisfy full church rosser property 
similarly standard computation sequences weak forms standard reduction sequences 
computation relation generates equivalence relation programs refer write diamond property computation relation church rosser property reduction easy show theory conservative extension standard computation function generalization notion standard reduction function performs leftmost outermost computation step 
standard reduction function undefined values 
definition 
standard computation function standard computation function maps program program ife standard reduces computes ct standard computation function faithfully simulates evaluation machine define semantics machine complex states eval turn gives rise operational equivalence relation usual manner 
expression operationally equivalent indistinguishable sense definition relative program contexts 
design control calculus follows congruences generated operationally sound due context sensitivity equations computation relation 
theorem 

ii imply fortunately possible factor large subset equations operationally sound safe equations 
definition 
safe equations equation safe holds evaluation contexts operationally terms safe equation control effects 
order enrich set safe equations permit safe equations safeness proof equation 
safe refer equational theory generated safe equations 
safe theory conservative extension importantly reduces reasoning operational equivalence set contexts set evaluation contexts 
theorem safe summary calculus control abstractions ordinary calculus church rosser standardization theorems 
closely corresponds programming language definition need evaluate program standard computation produce correct value proving operationally sound equations theory safe equations 
general interested interesting properties programs characterized safe equations 
unfortunately working theory safe equations easy working calculus simple axiomatic theory finite set axioms axiom schemas theory filtered subset theory introduce simple axiomatic characterization safeness subsection 
axiomatic basis safe equations disturbing element calculus control abstractions rule ct purpose application ce root program application halt continuation 
axiomatic characterization safe equations find way replacing special relation simple notions reduction approximate effect 
partial solution leave applications root program continue evaluation subexpression 
precisely application reaches root program number reductions shape evaluation may continue clearly leads accumulation applications root program 
observing outermost application removes current continuation application continuation halt continuation led rule captures idempotency abort action applications ax 
exception reasoning case program application subexpression abstraction 
need rule transforming arbitrary subexpression application abstraction 
task abstraction receive continuation apply subexpression 
attempt rule 
unfortunately version strong 
example abstraction eventually causes application value reduction stuck evaluation possible 
solution replace kx application continuation initiate program abort 
putting things additional rule 
redex redex ambiguity causes problem imposing appropriate condition standard reduction function see possible emulate deterministic machine 
new relations closely simulate top level rule entire system reduction suffices simulating tim griffin independently simultaneously discovered solution studying connection typed variant control calculus classical logic 
proposes restrict set programs expressions form ke idem replacement ct complete evaluation 
introduce notion reduction 
usual stand respective step reduction transitive closure 
furthermore write characterize relationship standard computation new reduction system lemmas 
clearly new system subsumes standard computations entirely reductions 
lemma ct proof 
suppose ct operational motivation obvious application root program evaluation proceeds 
lemma 
proof 
essentially instance ct inside context computation step old derivation reduction step inside revised calculus 
rest follows transitivity 
evaluation uses top level step equivalent step new reduction system 
lemmas show rest evaluation simulated close relationship respective terms sequences 
lemma ct step may converted replacing occurrences ku arbitrary values proof 
assumption derivation contain step ct ce tag newly created halt continuation track rest computation distinguish occurrence final answer 
lemma part derivation easily simulated new system ce kx 
replacing kx underlined term yields underlined term previous derivation underlined terms satisfy desired relationship 
complete proof suffices show invariant preserved steps top level step 
consider cases 

assume tagged continuation applied value rest computation 
easy see second half derivation transformed derivation lemma follows 
replacing free kx kx kx 
replacement kx kx yields 
assume tagged continuation applied value time reasoning case evaluation context ey value vy kx ey kx ey kx ey vy 
substituting vy kx underlined term yields ey vy underlined term 
corresponding terms derivation sequences satisfy desired invariant 
rest standard computation sequence eliminate evaluation context steps easily mimicked new calculus violating desired relationship 
fa ax revised syntactic theory control summary lemmas show program value eval new calculus reduce program equivalent expression 
essential difference reductions remember computation control operations 
answer new theory may simple value ac application abstracts value application abstracts application continuation variable value 
case answer evaluation function eval produce cases body application may converted expected answer replacing occurrences kv 
importantly proofs lemmas show new calculus basically reduces programs answers standard reduction steps 
precisely evaluation new rules begins standard reduction steps relation yields value evaluation finished 
reaches application case employs single step followed number standard reduction steps possibly intermingled reductions complete program 
yields application form evaluation stops produces answer 
process evaluation function 
definition 
evaluation idem letv vy values vy ax 
program evaluates value eval ce kx idem kx ce kx idem vy kx 
note tag halt continuation definition distinguish occurrences term reduction 
lemmas easy prove evaluation functions eval eval 
theorem eval eval 
proof 
lemmas simulate standard computations 
simple check proofs shows reduction steps new system conform definition 
direction assume eval case obviously true 
ce kx idem kx ce kx idem vy kx appropriate vy 
easy see cases ce vy 
eval desired 
importantly show theory prove safe equations old theory control 
establish claim need lemma direction 
safeness new proof rules established straightforward calculations 
lemma safe 
proof 
safeness evaluation context 
follows simple calculation 
arbitrary ce ce term determined ce ax ax ax 
verification safeness slightly complicated ce ek term determined kx kx kx 
continuation abstraction form ae consequence safe equality kx ae ae equation ae ae follows safeness 
safe equation equation new theory 
lemma safe proof 
proof requires lemmas shape proofs safe equations 
contributes insight old theory proof explained appendix 
preceding lemmas show adding axioms theory provides axiomatic characterization theory safe equations 
theorem safeness iff safe proof 
theorem follows lemmas 
immediate consequence theorem equations revised theory control operationally sound 
words equal expressions indistinguishable eval respect contexts sense definition 
corollary 
classical properties new reduction show church rosser provides alternative proof soundness 
church rosser property shows proceeding theorem safe isa conservative extension theorem consistency notion reduction church rosser 
proof 
proof requires generalizations standard techniques 
define gratefully acknowledge erik crank help proof 
alternative set reduction rules fa lift ax idem kx top refer new set reductions easy show equivalent reduction relations second show steps new system church rosser 
proof lift simple adaptation church rosser proof 
straightforward prove idem top directly satisfy diamond property church rosser 
combine relations hindley method proving church rosser property larger relations 
straightforward union idem top top 
final step requires show reductions idem top commute 
barendregt commutation lemma transitive closure relations apply idem parallel step reduction relation top easy show reductions idem top commute 
union reduction church rosser sub relations church rosser 
equivalent reductions church rosser 
new theory control standard reduction sequences albeit non traditional ones 
allow reductions standard reduction sequences extend set evaluation contexts set evaluation contexts standard reduction steps take place application reaches top entire term 
rest definition conventional 
definition 
standard reduction relation standard reduction sequences set evaluation contexts defined follows 
standard reduction relation maps standard evaluation context forsome adding clause definition standard reduction sequences calculus definition get set standard reduction sequences en standard reduction sequence en 
clearly standard reduction generalizes standard reduction relation function 
reduction theory satisfies standardization theorem conventional calculi 
theorem standardization standard reduction sequence proof 
proof adaptation plotkin corresponding proof 
show evaluation function determined transitive closure standard reduction relation determines relation function statement theorem takes slightly peculiar form 
theorem evaluation eval kv ax proof 
standard reduction relation obviously extends relations idem definition 
theorem explored conventional aspects connection programming languages calculi 
extensions equational theory immediately obvious preceding discussion reduction restricted capturing singular evaluation contexts 
combined effectively captures empty evaluation contexts relations serve capture arbitrary evaluation contexts 
consequently generalization natural unification 
ce rule captures arbitrary evaluation context single step applies subterm application appropriate continuation 
notion reduction ce subsumes sub relations inverse true 
consider term 
uses yield term single application ce produces 
terms normal form impossible prove equivalence modified ce 
short ce adds equational power calculus destroys church rosser property 
second extension theory observation safe theory simulate evaluation perfect manner 
different types answers 
evaluation may simply yield value 
second evaluation may abort part computation produce answer possibly containing basically exceptional answer 
answer may shape kv 
case program discovered answer point evaluation continuation escape rest evaluation 
answer contain captured continuation uninteresting observational perspective program continuation escaping evaluation process 
avoid third kind answer evaluation introducing additional reduction eliminates applications superfluous fv unfortunately church rosser 
counterexample redex redex 
step yields reduction followed step leads 
necessarily value continue reduction necessary 
leave unsolved problem finding extended theory includes ce satisfies classical properties reduction theories 
theories state extension calculus theory procedural abstraction assignment requires new syntactic constructs underlying term language 
need assignable variables called state variables denote different values different times 
distinguish set assignable variables set binding variables simple calculus rename set vars refer vars annotating elements set membership vars vars 
assignable variables denote fixed values values 
second extended language needs construct altering value state assignable variable 
purpose capability new form value 
capability similar abstraction binding variable expression represents right assign variable new value 
invocation globally alters value variable continues evaluation subexpression body 
refer extended language 
notions substitution contexts evaluation contexts adapted appropriately 
definition shape andthe calculus framework denotes subset contexts 
subsection introduce calculus procedural abstraction state 
original calculus control state calculus requires kinds term relations relies extensions language 
show second subsection program level term relations additional language extensions superfluous 
addition new theory state proper extension existing 
syntactic theory state application procedural abstraction argument value equivalent evaluation procedure body occurrences procedure parameter replaced argument 
reasonable expect reduction relation procedures assignable parameters replaces assignable parameter corresponds argument value 
traditional solution maintain additional function maps parameter name value store 
earlier report demonstrated store management incorporated term structure program 
key keep track substituted values unique label attached value substitution 
labeling scheme assignment simulated replacing values tagged label different labeled value 
value assignable variable requires stripping label labeled value 
deallocation garbage collection unusable storage happens automatically 
complicating fact definition extended term language potential circular self referential values 
example expression evaluates recursive function returns application 
achieve canonicity representation values add labeled bullets shape labels convenience add capabilities labeled bullets variable position represent result substituting labeled values free variables 
preliminary remarks define extension syntax ee set labels set assignable variables subscript 
distinction assignable binding variables irrelevant deducible context omit subscripts variables 
indicated substitution free variables terms adapted mutatis mutandis exception 
labeling strategy textual representation store need ensure programs describe consistent stores 
example label attached value labeled bullets indicate self typical terms violate conditions eliminate terms corresponding store configuration impose context sensitive conditions term language resulting language basis calculus labeled bullet occur sub term labeled value variable position capability labeled value contain labeled values labeled bullets bound variable abstraction occur sub term labeled value labeling subexpressions application consistent subterm subterm application identical replacing labeled values labels 
equipped notion labeled terms introduce labeled value substitution replaces labeled values expression resulting expression respects conditions 
may involve replacing labeled labeled bullets turn question simulate execution program reductions terms 
example consider application abstraction assignable parameter value 
model effect substitution parameter labeled value 
label unique reduction application impossible perform reductions parallel different parts term 
coordination effects labeled value substitutions possible ensuring contraction applicable 
unique point term root calculus coordinates imperative effects transition steps splitting set term relations set simple notions reduction computation rules 
reductions lift redex top program computation rules perform appropriate action 
kinds redexes require unique actions 
application procedural abstraction assignable variable value 
application capability value proceed evaluation body replacing occurrences entire program 
labeled value produces value 
reasoning redexes lifted top program just evaluated 
consequently reductions lift redexes evaluation contexts applying appropriate computation rule evaluation continue expression hole original evaluation context 
putting introduce notions reductions meta variables ranges assignable variables labeled values labeled bullets depending context de accord variable assumptions section assume equations variables renamed necessary avoid conflicts 
redexes reach top program appropriate action take place 
simulation term rewriting system define computation rules fv uv dt notice redex reduction relations computation relations assignments bound variables replaced labeled variables time 
define calculus state way calculus control 
basic notion reduction de 
terms equal denote step reduction transitive closure 
computation relation defined dt relation smallest equivalence relation generated computation relation denote equivalences theory syntactic theory state satisfies variants classical properties syntactic theory control 
sub theory relation church rosser computation relation satisfies diamond property 
standard reduction sequences reduction relation standard computation sequences computation relation 
denote standard reduction function importantly subset standard computation mapping defines evaluation function 
definition 
standard computation function standard computation function maps program program ife standard reduces computes dt evaluation function eval defined transitive closure standard computation relation eval mutatis mutandis definition induces operational equivalence relation lines definition 
importantly prove equations terms calculus safe imply operational equivalence 
theorem 
unfortunately theory compatible respect equations terms 
example 
second equation top level steps crucial evaluating assignments longer performed expressions embedded inside abstractions 
solve problem introducing extended theory safe equations old theory control fortunately better solution problem 
revised syntactic theory state crucial insight leads improved theory state originates simple observation context sensitive restrictions language motivation restrictions existence terms unconstrained language represent intermediate consistent store evaluation term 
contextsensitive restrictions eliminate terms 
lemma term term proof 
context sensitive restrictions term labels xn free assignable variables xn values un xi xi xi ui xi xi 
xi 
label xi unique value ui corresponds collection xi labeled values 
condition construct value replacing labeled values labels arbitrary labeled value bullet 
algorithm produces values un 
second obtain replacing occurrences labeled value label 
construction terms un satisfy condition 
take xn xn un proves proposition 
order simplify presentation terms preceding lemma introduce simplified version landin letrec abbreviation application 
application combination finite function assignable variables values represented set xn vn expression expands construction lemma xn un df xn xn un 
set notation justified expansions corresponding linear arrangement set clearly reduce term write assume finite function 
define dom set defined variables xn function 
follows lemma theorem implies existence theorem abadi proposed studied variant calculus incorporates explicit substitutions 
applications correspond closures notation abadi term non recursive 
words applications generalize notion closure common notion scheme ml closures lexical variables may bound recursive values 

holds particular computation rules eliminate 
assuming labeled value gets lost transition reformulation top level relations yields set term relations ux uv transition creates new entry application 
second rule specifies assignable variable corresponds lookup variable application set 
assignment modification pair set 
short set global application acts store translation computation rules appropriate effects finite store 
importantly rules completely independent context occur 
rely uniqueness new variables effect context lookup relative closest part store term 
need coordinating rules may take relations notions reduction 
unfortunately rules quite strong replace computation rules preceding subsection 
assumption transition loose labeled values strong 
example bound assignable variable occur procedure body corresponding instance translate contains assignable variables 
general right hand side new reductions may contain variables store application longer relevant evaluation body 
variables associated values garbage discarded 
garbage collection automatic need introduce explicit garbage collection rule new system dom fv 
gc summarized revised theory state 
rules slightly differ rules developed 
order reduce number reductions merged rules replacements computation rules 
requires new term relation applications effect lifting rules 
basic reduction relation new calculus gc new theory referred 
lemma garbage collection rule show new set rules complete replacement computation rules 
lemma counterparts lemma 
de fa dom fv gc revised syntactic theory state proof 
proof relies facts construction lemma 
algorithm converting alter structure term replacing labeled values labels 
particular values remain values non values remain non values 

labeled values moved store program preserve structure way 
consequence redex inside labeled value redex homologous position specifically redexes redexes dt redexes instances redexes respectively 
similarly inside labeled values redexes inside values store directly contain redex labeled value directly contains subexpression labeled sub value contains subexpression 
preliminaries easy see reduction reduction corresponding redex leads term clearly redexes create new free variables substitution process associated redexes may eliminate labels vacuous substitutions 
hand corresponding redexes eliminate corresponding variables 
construction dom fv 
permits application garbage collection rule gc 
lemma implies new theory extended lifting reductions prove equations old theory prove 
theorem 
de 
ii converse hold 
proof 
diamond property implies term follows lemma de de de 
ii simple proof explained previous subsection resulting theorem provable old theory 
second important consequence lemma reduction theory simulate evaluation programs 
lemma 
eval value counterpart lemma 
proof 
value series standard computation steps subsequences standard reduction steps de followed standard computation steps dt respectively precedes step puts de labeled value original evaluation context 
words standard computations occur clusters church rosser diamond property equivalent cases 


translating kinds sequences new calculus lemma merges steps 


short translation incorporates preliminary lifting reductions simulated toplevel steps 
derivation extended theory longer uses lifting steps lemma define evaluation function reductions 
main idea definition programs maintain textual representation store form application root program 
definition 
evaluation 
ande 
gc composition step followed step 
program evaluates answer eval ife single step evaluation relation proper relation nondeterministic garbage collection 
hand demanding complete garbage collection eval partial function programs 
equivalent old evaluation function 
theorem assume eval eval proof 
simple check lemma shows left right direction built definition arguments invertible 
case control new theory extends old theory prove soundness new theory old 
assert classical properties 
theory church rosser 
theorem consistency notion reduction church rosser 
proof 
classical methods church rosser proofs untyped calculi apply 
second define standard reduction relation set standard reduction sequences 
definition 
standard reduction relation standard reduction sequences definition set standard evaluation contexts standard reduction relation maps standard evaluation context forsome adding clause definition standard reduction sequences calculus definition get set standard reduction sequences en standard reduction sequence en 
third new theory state satisfies usual standardization theorem 
theorem standardization standard reduction sequence proof 
proof adaptation plotkin corresponding proof 
ready prove new theory sound 
steps 
theorem evaluation 
eval 
ii exists eval proof 
relation clearly subset standard reduction relation non steps restricted root program 
ii relation generalizes reductions performed inside program root 
disconnects relation reductions separated 
easy see sequence steps rearranged applications merged top level applications soon occur evaluation context 
clearly rearranged sequences standard reduction sequences importantly sequences steps 
difference answers standard reduction sequence assume garbage eliminated evaluation function insists 
recall expressions operationally equivalent indistinguishable relative program contexts sense definition 
final theorem says new calculus operationally sound sense expressions equivalent calculus operationally equivalent 
theorem proof 
conventional calculus implies contexts assume context eval terminates 
standardization theorem consistency theorem evaluation theorem eval defined 
symmetry terminates terminates 
second condition assume eval eval constants lemma consistency theorem proves summary new theory state reduction essential calculus state 
evaluate programs consistent standard reduction sequences standard reduction relation evaluation mechanism sound 
extends old theory 
note nature variables scheme practical point view new theory contains disturbing element partitioning variable set binding assignable variables 
reason separation desire variables values language assignments variables longer stand value series values 
consequently considered values expressions value 
excluding set variables values distinction variable sets superfluous language scheme revised calculus requires single axiom parameter passing 
loss modified theory longer conservative extension original calculus 
hand revised calculus easily accommodates reduction simplifies calculus 
revised calculus variable said assignable occurs variable position capability 
variable set longer assignable new calculus replace variable recursive value assignable restricted version derived df fy xx xx 
unified theories control state original theories control state completely orthogonal 
sum extended notions reduction yields theory language facilities control state manipulation shape reduction relations pattern matching rules stays 
result larger theory contains theories procedural abstraction control state sub sets 
new framework simple merger insufficient application may block variable assignments 
introduce additional notion reduction move applications outside applications stand merged language ce furthermore stand extension notions reduction 
new theory control state union reductions cs importantly new notion reduction syntactically consistent 
theorem extended notion reduction cs church rosser 
proof 
parts relation satisfy church rosser property 
proof union straightforward generalization hindley method ch 
consequence larger theory contains theories subsets 
evaluation defined larger theory 
program evaluates new theory evaluates value old theory form converted replacing occurrences ku lemma may constructed algorithm lemma 
better understanding imperative languages closely related research reasoning continuations assignments mason talcott 
past years developed equational theories order version lisp destructive cell operations language control higher order imperative version lisp control abstractions 
fragment order destructive lisp arithmetic recursion shown possible obtain complete theory 
mason talcott equational proof systems essentially ad hoc approximations operational equivalences respective languages 
find axioms theories extracting generalizing frequently laws example correctness proofs programs 
high level perspective axioms related notions reduction frameworks strongly differ details 
mason talcott addressed questions theories relate underlying theory procedural abstraction various theories relate 
early effort direction equational theories proving correctness higher order imperative programs due demers donahue 
focus research russell extension higher order typed calculus cells destructive cell operations major result proof system russell dozen axioms quite reductions mason talcott axioms 
equational assertions theory statements expressing purity legality expressions imperative effect 
formal results equational theory relationship original calculus 
mason talcott research demers donahue provides analysis equational theories perspective reduction theory 
theories clearly intended practical particular programming language proof system 
principal motivation better understanding essence imperative extensions higher order programming languages calculus 
new theories rely minimal sets notions reduction provide simple operational semantics respective languages 
calculus core theories various theories conservative extensions respective subtheories 
sense operational semantics modular semantics extended language extension semantics simpler language 
advantage approach results evaluation proof systems automatically lift richer languages disadvantage certain weakness proof systems 
believe moggi computational calculus motivated similar concerns correct starting point developing modular proof systems large powerful languages 
development proof system require development induction principle mathematical tools order strengthen power system 
possible solution underlying operational approximation relation axiomatize 
popular direction relies ideas denotational semantics 
currently denotational semantics provides different models different languages especially realm imperative higher order language family 
consequently difficult relate results language results extensions 
approach operational semantics lead collection denotational models imperative higher order languages model extended language contains model core language projection 
denotational theory provide improved understanding control state programming languages relationship language facilities 
reddy carolyn talcott independently suggested look simpler congruent versions calculi 
tim griffin read early draft proposed clarifications opaque points discussions 
erik crank came large number counter examples church rosser property various extensions control theory pointed flaw early draft proof soundness theorem new state theory 
appreciate referees efforts leading elimination number mistakes greatly improved presentation results 
appendix proof lemma sketch proof lemma need collect facts general shape proofs safe equations 
know definition safeness safe theorem evaluation contexts consequently church rosser standardization theorems standard computation sequences ande 
proof lemma relies fact standard computation sequences certain properties 
definition 
standard computation sequences standard reduction sequences relation defined just standard reduction sequences relation see definition 
extend standard reduction sequences standard computation sequences theory follows 
standard reduction sequences standard computation sequences 

en standard computation sequence en standard computation sequence 
lemmas terminology grabbing continuation mean sequence applications followed top level transition ct creates new abstraction form ax provides access abstraction evaluation context represent continuation 
lemma provides justification notation connecting invocation continuation reduction encoded evaluation context 
label instances order keep track continuations 
lemma au furthermore definition standard computation sequence implies toplevel transitions standard computation sequence part series standard computation steps front sequence 
particular sequence grabs invokes continuation standard mapping points 
lemma standard computation sequence value proof 
obvious get root program computation rules 
definition transitions take place series standard computation steps front term sequence 
preceding lemmas lead crucial property standard computation sequences safe equations 
sequences grab continuation continuation invoked sequences invoke 
lemma ce ce safe equation 
arbitrary evaluation context ce ce standard computation sequences 
values proof 
lemma suffices look front standard computation sequence 
assume invokes continuation 
computation sequences standard form decision invoke invoke continuation depend evaluation context may consider arbitrary context say constant lemma implies second derivation sequence hand may may discard newly created continuation 
contain corresponding new application 
hand throws away continuation longer contain part evaluation context unique constant case second derivation sequence places inconsistent requirements term contradiction proves claim 
second property standard computation sequences safe equations derivation sequences grabs evaluation context common term application continuation invoked 
lemma ce safe equation 
arbitrary evaluation context ce standard computation sequence 
corresponding standard computation sequence 
aq impossible invokes continuation impossible proof 
easy see evaluation context continuation occur second term construct arbitrary contexts consequently derivation eliminate pieces including labeled continuation contain pieces evaluation context 
result second derivation sequence abort entire evaluation context performing top level step 
consequently term shape aq term argument contain tagged abort application know lemmas prove lemma 
lemma safe proof 
proof analysis derivations equations 
discussed standard computation sequences start distinct major cases 
standard computation sequence uses top level rules 
standard computation sequences reductions hold 

sequences grab continuation 
lemma distinguish subcases sequences invoke continuation 
lemmas know holds ku ku 
values rest standard computation sequence provable directly 
get ku ku 
sequence invokes continuation 
analysis case applies exception intermediate terms look respectively 
ku ku 
may case sequence grabs continuation follows lemma shape ar contain tagged continuation invoke continuation 
lemmas occur fv 
know lemma shape ar derive rest simple calculation possible cases know holds particular 
abadi cardelli 
curien 
vy 
explicit substitution 
proc 
th acm symposium principles programming languages 

barendregt lambda calculus syntax semantics 
revised edition 
studies logic foundations mathematics 
north holland amsterdam 

church mathematical logic 
princeton university press princeton new jersey 

demers donahue 
making variables equational theory russell 
proc 
th acm symposium principles programming languages 

felleisen calculi lambda cs conversion syntactic theory control state imperative higher order programming languages 
ph dissertation indiana university 

felleisen theory practice class prompts 
proc 
th acm symposium principles programming languages 

felleisen friedman 
control operators secd machine calculus 
formal description programming concepts iii edited wirsing 
elsevier science publishers 
north holland amsterdam 

felleisen friedman 
syntactic theory sequential state 
theor 
comput 
sci 

preliminary version proc 
th acm symposium principles programming languages 

felleisen friedman kohlbecker duba 
theory sequential control 
theor 
comput 
sci 

preliminary version proc 
symposium logic computer science 

griffin formulae types notion control 
proc 
th acm symposium principles programming languages 

landin programming languages 
commun 
acm 

landin mechanical evaluation expressions 
comput 


mason equivalences order lisp programs 
proc 
symposium logic computer science 

mason talcott 
programming transforming proving function abstractions memories 
proc 
international conference automata languages programming 
springer lecture notes computer science berlin 

mason talcott 
sound complete axiomatization operational equivalence programs memory 
proc 
symposium logic computer science 

milner tofte harper 
definition standard ml 
press cambridge massachusetts london england 

moggi computational lambda calculus monads 
proc 
symposium logic computer science 

plotkin call name call value calculus 
theor 
comput 
sci 


rees clinger eds 
revised report algorithmic language scheme 
sigplan notices 

steele jr common lisp language 
digital press 

sussman steele jr scheme interpreter extended lambda calculus 
memo mit ai lab 

talcott rum intensional theory function control abstractions 
proc 
workshop foundations logic functional programming 
springer lecture notes 

talcott essence rum theory intensional extensional aspects lisp type computation 
ph dissertation stanford university 

