steps artificial intelligence marvin minsky dept mathematics mit research lab 
electronics mit 
member ire received ire october 
author summarized done mit lincoln laboratory center research operated mit lexington mass joint support army navy air force air force contract af res 
lab 
electronics mit cambridge mass supported part army signal corps air force office scientific research onr earlier done author junior fellow society fellows harvard university 
attaining artificial intelligence center considerable computer research design application 
field starting transient characterized varied independent efforts 
marvin minsky requested draw coherent summary supplement appropriate explanatory theoretical information introduce assessment state art 
emphasizes class activities general purpose computer complete library basic programs programmed perform operations leading higher level information processing functions learning problem solving 
informative article real interest general proceedings reader computer specialist 
guest editor 
summary problems heuristic programming making computers solve really difficult problems divided main areas search pattern recognition learning planning induction 
appropriate discussion supported extensive citation literature descriptions successful heuristic problem solving programs constructed date 
adjective heuristic widely literature means related improving problem solving performance noun regard method trick improve efficiency problem solving system 
heuristic program considered successful variety problems may fails 
find worthwhile introduce heuristic method happens cause occasional failures improvement performance 
imperfect methods necessarily heuristic vice versa 
heuristic regarded opposite foolproof caused confusion literature 
visitor planet puzzled role computers technology 
hand read hear wonderful mechanical brains creators intellectual performance 
warned machines restrained lest overwhelm persuasion revelation truths terrible borne 
hand visitor find machines sides literal interpretations innovation initiative short 
visitor remain puzzled set find judge monsters 
find machines general purpose computers programmed moment behave specification doing things claim real intellectual status 
proving mathematical theorems character 
machines playing certain games occasionally defeating designers 
distinguishing hand printed letters 
justify interest deep concern 
believe threshold era strongly influenced quite possibly dominated intelligent problem solving machines 
purpose guess may bring try describe explain steps construction artificial intelligence 
development general purpose computers past years seen increase effort discovery mechanization problem solving processes 
quite number papers appeared describing theories actual computer programs concerned game playing theorem proving pattern recognition domains require intelligence 
literature include general discussion outstanding problems field 
article attempt separate analyze find relations problems 
analysis supported examples literature serve introductory function review article remains relevant described 
highly compressed discuss matters available space 
course generally accepted theory intelligence analysis may controversial 
regret give full personal acknowledgments suffice say discussed matters cited authors 
convenient divide problems main areas search pattern recognition learning planning induction comprise main divisions 
summarize entire argument briefly computer sense told 
know exactly solve certain problem may program machine search large space solution attempts 
unfortunately write straightforward program search usually find resulting process enormously inefficient 
pattern recognition techniques efficiency greatly improved restricting machine methods kind attempts appropriate 
learning efficiency improved directing search accord earlier experiences 
analyzing situation call planning methods machine may obtain fundamental improvement replacing originally search smaller appropriate exploration 
section induction consider global concepts obtain intelligent machine behavior 
problem search summary problem means checking proposed solution solve problem testing possible answers 
takes long practical interest 
device reduce search may value 
detect relative improvement hill climbing section may feasible requires structural knowledge search space 
structure meets certain conditions hill climbing may harm 
note adjective heuristic widely literature means related improving problem solving performance noun regard method trick improve efficiency problem solving system 
heuristic program considered successful variety problems may fails 
find worthwhile introduce heuristic method happens cause occasional failures improvement performance 
imperfect methods necessarily heuristic vice versa 
heuristic regarded opposite foolproof caused confusion literature 
talk problem solving follows usually suppose problems solved initially defined 
mean problem systematic way decide proposed solution acceptable 
experimental discussed concerned defined problems met theorem proving games precise rules play scoring 
sense problems trivial 
exists solution problem solution eventually blind exhaustive process searches possibilities 
usually difficult program search 
problem worthy name search possibilities inefficient practical 
hand systems chess nontrivial parts mathematics complicated complete analysis 
complete analysis remain core search trial error need find techniques results incomplete analysis search efficient 
necessity simply overwhelming 
search paths game checkers involves move choices chess 
organized particles galaxy kind parallel computer operating frequency hard cosmic rays computation take long expect improvements hardware solve problems 
certainly know advance guide trial generator 
able results obtained way 
notes mccarthy discussed enumeration problem recursive function theory point view 
incomplete suggestive proposes things enumeration partial recursive functions give early place compositions functions appeared regard important notion especially light shannon results terminal switching circuits average variable switching function requires contacts 
disaster usually strike construct interesting large machines presumably composition functions useful 
especially ashby excellent discussion search problem 
am convinced usefulness notion little property machine search stops 
relative improvement hill climbing heuristic connections problem hardly come interest background information 
usually basis detecting improvement trials judged successful 
suppose example comparator selects better pair trial outcomes 
comparator serve problem defined 
goal defined 
comparator defined relation trials transitive dominates dominates implies dominates define progress ask machine time limit best 
essential observe comparator give improvement exhaustive search 
comparator gives information partial success sure 
need way information direct pattern search promising directions select new trial points sense similar direction best previous results 
need additional structure search space 
structure need bear resemblance ordinary spatial notion direction distance tie points heuristically related 
call structure heuristic connection 
introduce term informal definition informal 
need 
publications misuse purpose precise mathematical terms metric topological 
term connection variety dictionary meanings just word designate relation commitment exact nature relation 
important simple kind heuristic connection defined space coordinates parameters defined numerical success function reasonably smooth function coordinates 
local optimization hill climbing methods 
hill climbing suppose black box machine inputs 
output 
wish maximize adjusting input values 
mathematical description function differentiation related methods 
obvious approach explore locally point finding direction steepest ascent 
moves certain distance direction repeats process improvement ceases 
hill smooth may done approximately estimating gradient component de dx separately coordinate 
sophisticated approaches may noise added variable correlate output input see general idea 
fundamental technique see background far complex systems 
heuristically great virtue sampling effort determining direction gradient grows sense linearly number parameters 
solve method certain kind problem involving parameters addition parameters kind ought cause inordinate increase difficulty 
particularly interested problem solving methods extended problems difficult 
alas interesting systems involve combinational operations usually grow exponentially difficult add variables 
multiple simultaneous optimizers search local maximum value function parameters 
unit independently parameter randomly adding variation current mean value changes quantities correlated result slowly change filters remove dc components 
technique form coherent detection usually advantage methods dealing separately sequentially parameter 
cf 
discussion informative feedback wiener ff 
great variety hill climbing systems studied names adaptive self optimizing 
troubles hill climbing obviously gradient hill climber trapped reach local peak true satisfactory optimum 
forced try larger steps changes 
supposed false peak problem chief obstacle machine learning method 
certainly troublesome 
really difficult problems usually fundamental problem lies finding significant peak 
unfortunately known functions difficult problems exhibit called mesa phenomenon small change parameter usually leads change performance large change performance 
space composed primarily flat regions tendency trial generator small steps results wandering compensating information gains 
profitable search space requires steps large hill climbing essentially ruled 
problem solver find methods hill climbing feasible different heuristic connection 
certainly human intellectual behavior rarely solve tricky problem steady climb success 
doubt simple mechanism hill climbing provide means build efficient general problem solving machine 
probably intelligent machine require variety different mechanisms 
arranged hierarchies complex recursive structures 
amounts straightforward hill climbing level may appear lower level sudden jumps insight ii 
problem pattern recognition summary order try possibilities machine classify problem situations categories associated domains effectiveness machine different methods 
pattern recognition methods extract heuristically significant features objects question 
simplest methods simply match objects standards prototypes 
powerful property list methods subject object sequence tests detecting property heuristic importance 
properties invariant commonly encountered forms distortion 
important problems arise inventing new useful properties combining properties form recognition system 
complex problems methods augmented facilities subdividing complex objects describing complex relations parts 
powerful heuristic program bound contain variety different methods techniques 
step problem solving process machine decide aspect problem method 
choice usually afford try possibilities 
order deal goal problem choose appropriate method recognize kind thing need choose actions provide machine classification techniques means evolving 
overwhelming importance machine classification techniques realistic 
realistic defined respect environments encountered machine respect methods available 
distinctions exploited worth recognizing 
methods usually worthless classification schemes help decide applicable 
teleological requirements classification useful classifications match goals methods machine 
objects grouped classifications heuristic value common similar useful sense depend relevant essential features 
surprised find inverse teleological expressions define classes 
really want grip class objects transformed result form class objects satisfy goal 
wary familiar teleological language science 
true talking goals contexts may dispose certain kinds explanations need bad thing field problem solving hard see solve problems thoughts purposes 
real difficulty teleological definitions technical philosophical arises just mentioned 
obviously afford classification method requires waiting remote outcome needs classification precisely deciding try method 
practice ideal teleological definitions replaced practical approximations usually risk error definitions heuristically effective economically usable 
great importance 
think heuristic effectiveness contrasted ordinary mathematical notion effectiveness distinguishes definitions realized machine regardless efficiency 
patterns descriptions usually necessary ways assigning names symbolic expressions defined classes 
structure names crucial influence mental world machine determines kinds things conveniently thought 
variety ways assign names 
simplest schemes call conventional proper names arbitrary symbols assigned classes 
want complex descriptions computed names constructed classes processes depend class definitions 
useful reflect structure things designate abstracted manner relevant problem area 
notion description merges smoothly complex notion model think model sort active description 
thing form reflects structure thing represented character working machine 
section iii consider learning systems 
behavior systems change reasonable ways depending happened past 
simple learning systems useful recurrent situations cope significant novelty 
nontrivial performance obtained learning systems supplemented classification pattern recognition methods inductive ability 
variety objects encountered nontrivial search enormous depend recurrence mere accumulation records past experience limited value 
pattern recognition providing heuristic connection links old new learning broadly useful 
pattern 
term mean set objects useful way treated alike 
problem area ask patterns useful machine working problems problems visual pattern recognition received attention years examples area 
prototype derived patterns problem reading printed characters clear cut instance situation classification ultimately fixed set prototypes dies type font 
individual marks printed page may show results distortions 
distortions systematic changes size position orientation 
distortions nature noise blurring grain low contrast noise severe may able manage identification call normalization template matching process 
remove differences related size position normalize input 
may example constructing similar inscribed certain fixed triangle see may transform obtain certain fixed center gravity unit second central moment 
simple normalization technique 
object expanded uniformly rotation touches sides triangle resulting unique pattern recognition proceed concern relative size position 
additional problem rotational equivalence easy avoid ambiguities 
want equate 
matter want equate context dependency involved 
normalized unknown compared templates prototypes may means measure matching choose best fitting template 
matching criterion sensitive particular forms noise distortion normalization procedure 
boxing method may sensitive small moment method especially sensitive smearing thin line figures choice matching criterion depend kinds noise transformations commonly encountered 
problems may get acceptable results straightforward correlation methods 
class equivalence transformations large local stretching distortion difficulty finding uniform normalization method 
may consider process adjusting locally best fit template 
measuring matching jitter locally improvement process repeated slightly different change usually practical possibility applying admissible transformations 
recognize topological equivalence pairs practical kind iterative local improvement hill climbing matching procedure 
recognitions mechanized methods follow lines detect vertices build description form say vertex connection table 
figures topologically equivalent pairs 
lengths distorted arbitrary manner connectivity relations corresponding points preserved 
sherman haller find computer programs deal equivalences 
template matching scheme normalization direct comparison matching criterion just limited conception problems difficult 
transformation set large normalization fitting may impractical especially adequate heuristic connection space transformations 
furthermore defined pattern system prototype 
mind class may simply unable represent essential features concrete examples 
represent single prototype class figures number disconnected parts 
clearly template system negligible descriptive power 
property list system frees limitations 
property lists characters define property valued function divides figures classes said property function value 
number distinction properties define subclasses set intersections patterns combining properties ands ors 
properties rectilinear connected cyclic subclasses patterns defined intersections regions represent possible configurations values properties rectilinear connected containing loop 
region contains representative associated binary character sequence 
properties placed fixed order represent elementary regions vector string digits 
vector assigned called character respect sequence properties question 
term characteristic property restriction values 
square character circle character sequence properties 
problems characters names categories primitive elements define adequate set patterns 
characters conventional names 
rudimentary forms description having form simplest symbolic expression list structure provides information designated classes 
step albeit small template method characters simple instances patterns properties may 
finding set properties major concern heuristic programs 
invariant properties prime requirements property invariant commonly encountered equivalence transformations 
visual pattern recognition usually want object identification independent uniform changes size position 
pioneering pitts mcculloch describe general technique forming invariant properties ones assuming transformation space certain group structure 
idea mathematical argument suppose function figures suppose define 
set figures equivalent set transformations define set 
values figures 
define average 
new property values independent selection equivalence class defined transformations 
sure different representatives chosen class collection case 
case continuous transformation spaces measure equivalent associated set respect operation average defined say integration 
case studied transformation space group uniquely defined haar measure set computed repetitions scanning application transforms invariant property defined integration measure 
result invariant chosen integration compact group 
method proposed neurophysiological model pitch invariant hearing size invariant visual recognition supplemented visual centering mechanisms 
model discussed wiener 
practical application probably limited dimensional groups analog scanning devices 
problem avoided properties invariant transformations 
property count number connected components picture invariant size position 
property may count number vertical lines picture invariant size position rotation 
generating properties problem generating useful properties discussed selfridge shall summarize approach 
machine start basic transformations transforms significant way 
example remove points boundary solid region leave vertex points fill hollow regions arbitrary sequence picture transformations followed numerical valued function property function pictures 
removes points edge solid region 
leaves vertex points arc suddenly changes direction 
function simply counts number points remaining picture 
sequence 
operations forms new transformation available infinite variety 
provide machine terminal operations convert picture number sequence elementary transformations followed terminal operation defines property 
kirsch describe processes programmed digital computer 
start short sequences chosen randomly 
selfridge describes machine learn new useful properties 
feed machine telling machine time letter sequence letters machine builds distribution functions results applying sequences image 
sequences chosen completely randomly may sequences flat distribution functions provide information sequences definition significant 
discard pick 
sooner sequences prove significant distribution functions peak 
machine build new sequences significant ones 
important point 
merely chose sequences random take long find best sequences 
successful sequences partly successful ones guide hope process quicker 
crucial question remains build sequences sequences identical 
think shall merely build sequences transition frequencies significant sequences 
shall build matrix transition frequencies significant ones transition probabilities choose new sequences 
claim method necessarily way choosing sequences better knowledge kinds sequences worked 
crucial point learning 
see 
remarkable failed yield properties useful obtained completely random sequence selection 
generating problem discussed minsky 
newell shaw simon describe deliberate statistical techniques discover sets properties appropriate problem area 
may think selfridge proposal system uses finite state language describe properties 
solomonoff proposes techniques discovering common features set expressions descriptions properties established utility methods applied generate new properties common features 
consider lines attack incomplete greatest importance 
combining properties expect easily find small set properties just right problem area 
usually easier find large set properties provides little useful information 
faced problem finding way combine desired distinctions 
simplest method define class prototypical characteristic vector particular sequence property values matching procedure counting numbers agreements disagreements compare unknown chosen prototypes 
linear weighting scheme described just slight generalization 
methods treat properties independent evidence propositions general procedures little practical information account nonlinear relations properties contain weighting terms joint subsets property values 
bayes nets combining independent properties consider single experiment object placed front property list machine 
property value 
suppose defined set object classes fj want outcome experiment decide classes object belongs 
assume situation probabilistic know probability ij object class fj th property value 
assume properties independent knowledge value tells value different experiment 
strong condition see 
absolute probability object class experiment define particular set 
represents character object 
definition conditional probability pr pr pr fj pr fj pr fj character want guess fj occurred chance wrong called maximum likelihood estimate pr largest 
pr depend calculate pr pr fj pr fj pr fj largest 
independence hypothesis maximize pp ij qij product second complement 
maximum likelihood decisions fig 
simple network device 
net model maximum likelihood decisions linear weightings property values 
input data examined property filter output channels excited input 
outputs weighted corresponding ij shown text 
resulting signals multiplied units collects evidence particular class 
log ij added 
final decision topmost unit merely chooses largest score 
note logarithm coefficient ij ij second expression construed weight evidence favor 
see 
note cost additional network layer may account possible cost jk incurred assign really class case minimum cost decision 
nets resemble general schematic diagrams proposed pandemonium model selfridge fig 
proposed intellectual processes carried hierarchy simultaneously functioning called demons 
unit set detect certain patterns activity output unit announces degree confidence unit sees looking 
units selfridge data demons units cognitive demons collects abstracted data evidence specific proposition 
topmost decision demon responds multitude 
see report 
quite easy add bayes network model mechanism enable learn optimal connection weightings 
imagine event machine told occurred implement sending back signal connections leading unit 
suppose connection ij ij contains terminal device synapse stores number ij joint event fj occurs modify ij replacing ij factor slightly unity 
joint event fj ei occurs decrement ij replacing ij difficult show expected values ij proportional ij fact approach ij 
machine tends learn optimal weighting basis experience 
put similar mechanism estimating fj variance normalized weight approaches ij ij small value means rapid learning associated large variance low reliability 
choosing close unity means slow reliable learning 
really sort memory decay constant choice determined noise stability environment noise requires long averaging times changing environment requires fast adaptation 
requirements course incompatible decision economic compromise 
see random nets bayes decisions nets fig 
orderly structure 
structure necessary 
certainly great properties provided little marginal information missed 
expect results mere sampling possible connection paths 
special situation random connection net 
layer nets resemble perceptron proposal rosenblatt 
additional level connections coming directly randomly selected points retina properties devices visual input data simple functions add inputs subtract detect result exceeds threshold 
equation think illustrates value scheme 
clear nets handle maximum likelihood type analysis output property functions 
nets simple randomly generated connections probably achieve recognition patterns class figures having separated parts achieve effect template recognition size position normalization sample figures previously essentially sizes positions 
chances extremely small finding random methods properties usefully correlated patterns appreciably prototype derived kind 
networks really separate weighting information individual input properties extract information nonadditive form 
perceptron class machines facilities obtaining better chance properties assembling better additive combinations gets random construction recognizing normalized printed hand printed characters single point properties surprisingly amounts just averaging samples 
bledsoe browning claim results point pair properties 
roberts describes series experiments general area 
doyle normalization quite sophisticated properties obtains excellent results properties substantially size position invariant 
general review doyle pattern recognition experiments selfridge neisser 
complex discrimination connected objects property problem serious especially long objects handled kirsch 
kind recursive processing required combinations simple properties certainly fail large nets long training 
leave discussion decision net models noting important limitations 
hypothesis represent independent events strong condition 
hypothesis construct maximumlikelihood nets need additional layer cells represent joint events need know pr fj 
gives general trivial solution requires cells properties completely impractical large systems 
required system computes sampling joint conditional probabilities uses estimate needed 
bears problem proposed experimental devices clearly show avoid exponential growth 
see roberts papert hawkins 
find resembling type analysis rosenblatt 
articulation attention limitations property list method note substantially revised section december clarify simplify notations 
fixed size property list scheme limited complexities relations describe 
machine recognize chair table surely able tell chair table 
extent invent properties relationships embedded formula fixed form represent arbitrary complex relationships 
want describe leftmost rectangle contains disposed horizontally 
part left rectangle contains disposed vertically upper part circle lower triangle 
part right 
description entails ability separate segment scene parts 
note example articulation essentially recursive divided parts part described machinery 
formalize kind description expression language fundamental grammatical form function names relation ordered list objects bear relation 
obtain required flexibility allowing members list contain names elementary figures expressions describe 
leftmost scene may described expression box box cir triangle cir cir cir cir means inside means left means description may regarded expression simple list structure language 
newell shaw simon developed powerful computer techniques manipulating symbolic expressions languages purposes heuristic programming 
see remarks section iv 
members list lists surrounded exterior parentheses accounts accumulation parentheses 
description language may regarded simple kind list structure language 
newell shaw simon developed powerful computer techniques manipulating symbolic expressions languages purposes heuristic programming 
see remarks section iv 
introducing notation relations inside left construct symbolic description 
descriptions formed manipulated machines 
abstracting complex relation parts re formula describe figures expression particular geometric replaced new variables 
left hand represented box box cir tri cir cir cir cir scenes represented different substitutions variables 
programmer decide just level complexity part picture considered primitive 
depend description 
divide drawings vertices lines arcs 
obviously applications relations need metrical information specification lengths angles 
important thing descriptions obtained repeated application fixed set pattern recognition techniques 
obtain arbitrarily complex descriptions fixed complexity classification mechanism 
new element required mechanism capacity manipulate list structures ability articulate attend fully selected part picture bring resources bear part 
efficient problem solving programs usually complete description single operation 
depth detail description control processes 
reach deeper look carefully presently available description inadequate current goal 
author hodes working pattern recognition schemes descriptions 
manipulating formal descriptions deal overlapping incomplete figures problems gestalt type 
machines turned difficult problem areas passive classification systems adequate may turn schemes internally generated hypotheses error controlled lines proposed mackay 
space requires terminate discussion pattern recognition description 
important works reviewed mentioned involve elements description unger holland parallel processing schemes hebb concerned physiological description models gestalt psychologists notably kohler certainly raised solved number important questions 
sherman haller completed programs line tracing operations topological classification 
papers selfridge major influence general area 
see kirsch discussion number interesting computer image processing techniques see stevens reviews reading machine related problems 
examine biological tinbergen see instances discriminations glance complicated explained basis apparently simple properties arranged simple decision trees 
iii 
learning systems summary order solve new problem try methods similar worked similar problems 
implement basic learning heuristic generalize past experience way success reinforced decision models 
learning systems shown averaging devices 
devices learn events associated reinforcement reward build autonomous secondary reinforcement systems 
applying methods complex problems encounters serious difficulty distributing credit success complex strategy decisions involved 
problem managed arranging local reinforcement partial goals hierarchy grading training sequence problems parallel process maturation machine resources 
order solve new problem uses called basic learning heuristic try methods similar worked past similar problems 
want machines benefit past experience 
expect new situations precisely old ones useful learning involve generalization techniques 
notions associated learning justify defining term precisely 
may sure useful learning system records past evidence general propositions entail commitment inductive inference see section 
simplest way generalizing set entities constructing new ideal typical member set usual way smooth away variation sort averaging technique 
find simple learning devices incorporate averaging technique averaging sort product obtaining sort correlation 
shall discuss family devices schemes section reinforcement reinforcement process aspects behavior system caused prominent consequence application reinforcement operator operator required affect aspects behavior instances occurred 
analogy reward extinction punishment animal behavior 
important thing kind process operant term skinner reinforcement operator initiate behavior merely selects trainer likes occurred 
system contain device generates variety behavior say interacting environment trainer critical judgments applying available reinforcement operators 
see fig 
consider simple operant reinforcement model 
response stimulus environment machine possible responses 
remembers decisions choosing response 
shortly trainer sends machine positive negative reinforcement reward signal increases decreases tendency decisions 
note trainer need know solve problems detect success failure relative improvement function selective 
trainer connected observe actual stimulus response activity interesting kind system function state environment 
suppose presentation stimulus animal choice turn left right probability turning right th trial suppose want turn right 
reward applying operator moves fraction way unity 
properly reinforcement functions depend previous reaction 
reward decrease animal just turned left 
notation literature somewhat confusing regard 
dislike apply negative reinforcement moving fraction way 
theory linear learning operators generalized stimuli responses bush mosteller 
show learning result average weighted exponentially decaying time factor th event rewarded extinguished replace correlation coefficient 
obtain induction write 
term regarded product creature responded ii kind reinforcement kind correlation function decay weighting joint behavior quantities 
ordinary uniformly weighted average general form time dependent situation described section ii small value gives fast learning possibility quick adaptation changing environment 
near unity value gives slow learning smoothes away uncertainties due noise 
noted section ii response distribution comes approximate probabilities rewards alternative responses 
importance phenomenon think certainly especially rational strategy 
reasonable alternative computing numbers ij indicated playing trial choice 
presence hostile opponent usually reason play mixed strategy 
question just play strategy different estimated optimum order gain information underlying problem fields 
see 
samuel coefficient optimizing program see section iii uses ingenious compromise exponential uniform averaging methods 
value begins remains 
remains fixed 
nicely prevents violent fluctuations start approaches uniform weighting approaches exponentially weighted correlation manner requires little computation effort 
samuel program outstanding example game playing program matches average human ability success real time attributed wealth heuristics programming 
problem extinction especially critical complex hierarchical learning 
generalization past build 
may come select certain properties important characterization experience storing memories terms 
discovered properties serve better face problem translating abandoning records older system 
may high price pay 
easily give old way looking things better demands effort experience useful 
training sequences machines spend speak chosen insure early abstractions provide foundation difficult problems 
incidentally spite space exposition am convinced incremental statistical learning schemes play central role models 
certainly continue appear components programs think mainly default 
intelligent able learn experience definite reject accept hypothesis change goal 
obvious exception truly statistical environment averaging inescapable 
heart problem solving think combinatorial part gives rise searches usually able regard complexities caused noise mere irritating may 
connection refer discussion memory miller 
major psychology show influence artificial intelligence area programme generally quite sophisticated 
secondary reinforcement expectation models simple reinforcement system limited dependence trainer 
trainer detect solution problem may encounter mesa phenomena limit performance difficult problems 
see section 
way escape machine learn generalize trainer 
difficult problems may able give partial reinforcements way solution relevant subproblems 
machine ability additional device gives machine fig 
ability learn signals environment associated reinforcement 
primary reinforcement signals routed conditioning process described external signals come produce reinforcement signals frequently succeeded past 
signals verbal encouragement 
secondary reinforcement signals allowed turn acquire external associations channel shown machine come able handle chains subproblems 
done stabilize system positive symbolic feedback loop formed path profound difficulty stabilization problem may reflected fact lower animals difficult demonstrate chaining effects 
new unit device learns external stimuli strongly correlated various reinforcement signals responds stimuli reproducing corresponding reinforcement signals 
device reinforcement learning device conditioning device treating signals unconditioned stimuli signals moves replies 
limit number conditioned stimuli 
heuristic idea signal environment past correlated say positive reinforcement indication just happened 
training early problems realistic system eventually able detach trainer autonomous 
permit chaining secondary reinforcers admitting connection shown dotted line scheme quite powerful principle 
obvious pitfalls admitting degree autonomy values system may drift non adaptive condition 
prediction expectation evaluation unit supposed acquire ability tell situation bad 
evaluation applied imaginary situations real ones 
estimate consequences proposed action actual execution evaluate estimated resulting situation 
help reducing effort search effect machine ability look ahead plan 
order need additional device descriptions situation action predict description result 
discuss schemes doing section iv 
device constructed lines reinforcement learning device 
system required reinforcement signals attractive character 
machine reinforce positively actual outcome resembles predicted accurate expectations rewarded 
add premium reinforcement predictions novel aspect expect discern behavior motivated sort curiosity 
reinforcement mechanisms confirmed novel expectations new explanations may find key simulation intellectual motivation 
see discussion bernstein extensive discussion suggestive newell shaw simon overlook pioneering newell samuel discussion process 
samuel program checkers samuel generalization learning program game checkers find novel heuristic technique regarded simple example expectation reinforcement notion 
review briefly situation playing person board games kind 
noted shannon games principle finite best strategy possible continuations goes go backing terminal positions won lost drawn 
practice full exploration resulting move tree question 
doubt exploration necessary games 
tree pruned 
simply put limit depth exploration number moves replies 
limit number alternatives explored position requires heuristics selection plausible moves 
backing technique incomplete move tree substitute absolute win lose draw criterion static way evaluating nonterminal positions 
note problems backing process handled closed analytic form may able methods bellman dynamic programming 
gives examples limited look ahead doesn 
backing static evaluations proposed moves game tree 
vertex left representing position board game branches representing player proposed moves 
countered variety opponent moves 
program finite tree generated 
worth player terminal board position estimated 
see text opponent values choose minimize score player try maximize 
heavy lines show process backs choice determined position 
full tree chess order branches reach man computer 
fundamental heuristic exchange effectiveness evaluation function extent tree 
weak evaluation just compares player values pieces yield devastating game machine explore continuations say levels 
levels roughly range presently largest computers probably give brilliant game exhaustive strategies lines profitable 
simplest scheme weighted sum selected set property functions positions mobility advancement center control 
done samuel program predecessors 
associated multiple simultaneous optimizer method discovering coefficient assignment correlation technique noted section iii 
source reinforcement signals novel 
afford play entire games single learning step 
samuel measures move difference evaluation function yields directly position predicts basis extensive continuation exploration backing 
sign error delta reinforcement system may learn move 
note noted describes successful checker playing program recording retrieving information positions encountered past way exploiting past experience 
samuel notable variety experiments performed various heuristics 
gives unusual opportunity really find different heuristic methods compare 
workers choose things equal problems variations practicable 
see 
credit assignment problem learning systems playing complex game chess checkers writing computer program definite success criterion game won lost 
course play ultimate success failure associated vast number internal decisions 
run successful assign credit success multitude decisions 
newell noted extremely doubtful information win lose draw referred play game permit learning available time scales 
learning take place play game yield information 

achieved breaking problem components 
unit success goal 
goal achieved subgoals reinforced 
inhibited 
reinforced transformation rule provided subgoal 
true kinds structure tactic created provides information success failure tactic search rules opponent action provides information success failure likelihood inferences 
amount information relevant learning increases directly number mechanisms chess playing machine 
complete agreement newell approach problem 
see samuel discussion assigning credit change delta impression workers area self organizing systems random neural nets feel urgency problem 
suppose decisions involved complex task winning chess game 
assign decision element credit completed task 
certain special situations just machines connections reinforced sufficient degree independent 
problem solving ability correspondingly weak 
complex problems decisions hierarchies summed level increments small assure probable convergence running times fantastic 
complex problems define success rich local sense 
difficulty may carefully graded training sequences described section 
friedberg program writing program important example comparative failure credit assignment matter provided program friedberg solve program writing problems 
problem write programs simulated simple digital computer 
simple problem assigned compute bits storage put result assigned location 
generating device produces random instruction program 
program run success failure noted 
success information reinforce individual instructions fixed locations success tends increase chance instructions successful programs appear trials 
lack space details done 
program tries find instructions independently location program memory 
machine learn solve extremely simple problems 
took order times longer pure chance expect 
part failure discussed attributed part called section mesa phenomenon 
changing just instruction time machine taken large steps search program space 
second goes discuss sequence modifications program generator reinforcement operators 
priming starting machine right track useful instructions system came little worse chance 
authors conclude improvements generally superior performance machines success number reinforcement mechanism serve indicate mechanism provide basis constructing learning machine 
disagree 
improvements interpreted serving increase step size search randomness mechanism helps avoid mesa phenomenon approach chance behavior 
certainly show learning mechanism working want see better chance results arguing point 
trouble credit assignment 
credit working program assigned functional groups instructions subroutines operate hierarchies expect individual instruction reinforcement 
see thoughtful discussion plausibility scheme 
surprising recognized doubts raised earlier probably justified 
section see real success obtained breaking problem parts solving sequentially 
successful demonstration division subproblems reinforcement mechanism 
experiments similar nature reported 
conviction scheme learning pattern recognition general utility provisions recursive hierarchical previous results 
expect learning system come handle hard problems preparing reasonably graded sequence problems growing difficulty 
problem solved reasonable time initial resources 
capable solution reasonable time reasonably simple accessible combinations methods developed 
alternatives adequate training sequence advanced resources initially fantastic exploratory processes history organic evolution 
note possible construct learning mechanisms select reasonably training sequences complex environment pre arranging relatively slow development maturation tile system facilities 
done pre arranging sequence goals attempted primary trainer match reasonably stage complexity performance mechanically available pattern recognition parts system 
able simply limiting depth hierarchical activity permitting limited recursive activity 
accept general view darlington emphasizes heuristic aspects genetic systems developed early phenomena crossing quite highly specialized mechanisms providing segregation groupings related solutions subproblems 
effort devoted construction training sequences programming teaching machines 
naturally psychological literature abounds theories complex behavior built simpler 
area solomonoff overly cryptic shows thorough consideration dependency training sequences 
iv 
problem solving planning summary solution machine complex problems require variety administration facilities 
course solving problem involved large assembly interrelated subproblems 
stage chosen investigation 
decision estimates relative difficulties estimates centrality different candidates attention 
subproblem selection heuristic methods proposed choose methods appropriate selected problems 
difficult problems step step heuristics reducing search fail machine resources analyzing problem structure large short planning 
discuss variety schemes planning including models analogous semantic 
certain models call character algebras constructed machine basis experience analysis 
concreteness discussion begins description simple significant system lt encounters problems 
logic theory program newell shaw simon surprising testing grounds early mechanical problem solving usually areas mathematics games rules learned absolute clarity 
logic theory machine called lt attempt prove theorems logic heuristic methods 
program human standards brilliant success surpass designers stands landmark heuristic programming development modern automatic programming 
problem domain discovering proofs russell whitehead system propositional calculus 
system set axioms rules inference specify certain transformations applied produce new theorems old theorems axioms 
lt program centered idea working backwards find am proof 
theorem proved lt searches axioms previously established theorems deduced single application simple methods embody rules inference 
problem solved 
search fail completely 
search may yield problems usually propositions deduced directly 
turn proved theorem main problem solved 
situation slightly complex 
subproblem adjoined subproblem list limited preliminary attempt lt works 
full power lt applied subproblem lt subroutine recursive fashion 
heuristic technique working backwards yields teleological process lt complex systems construct hierarchies goals subgoals 
basic administrative structure program nested set searches lists memory 
shall outline structure mention heuristics attempts improve performance 
take problem problem list 
list empty exit failure 

choose basic methods 
methods go 

choose list axioms previous theorems 
go 
apply current method selected axiom theorem 
problem solved exit complete proof 
result go 
new subproblem arises go 
try special substitution method subproblem 
problem solved exit complete proof 
append subproblem problem list go 
heuristics studied similarity test reduce step includes search theorem list simplicity test select apparently easier problems problem list strong test remove problem list expressions probably false provable 
series experiments learning find earlier theorems useful priority step 
review effects changes detail 
interest balance extra cost administration certain heuristics resultant search reductions balance quite delicate cases computer memory saturated 
system quite sensitive training sequence order problems 
heuristics gave significant improvement affect class solvable problems 
curiously general efficiency lt greatly improved devices 
practical experience reflected design sophisticated gps system described briefly section iv 
hao wang criticized lt project grounds exist shown mechanized proof methods particular run problems considered far machine effort lt advantage ultimately find proof provable proposition 
lt exhaustive decision procedure character fail find proofs theorems 
authors unaware existence moderately efficient exhaustive methods supported arguments comparison particularly inefficient exhaustive procedure 
feel wang criticisms 
recognize authors lt interested proving theorems general problem solving difficult problems 
combinatorial system russell whitehead lt deals far simple elegant system wang 
note emphasis 
wang procedure works backwards regarded generalization method falsification deciding truth functional tautology 
unpublished sequel wang introduces powerful methods solving harder problems 
wang problems logically equivalent formally simpler 
methods include facilities previous results sure degrade rapidly certain level problem complexity lt fundamentally oriented problem 
effectiveness wang method particular set theorems question simply face fundamental heuristic problem decide give line attack 
formidable performance program diverted attention heuristic problems spring real mathematics ultimately encountered 
meant rejection importance wang discussion 
working mechanical mathematics discovered proof procedures efficient suspected 
help inn constructing intelligent machines procedures certainly preferred available unreliable heuristic methods 
wang davis putnam pushing new techniques far challenging domain theorem proving predicate calculus exhaustive decision procedures longer available 
space discuss area see clear program solve real mathematical problems combine mathematical sophistication wang heuristic sophistication newell shaw simon 
efforts directed reduction search effort 
sense heuristic programs 
practically uses heuristic sense opposed algorithmic serious workers avoid pointless argument score 
real problem find methods significantly delay apparently inevitable exponential growth search trees 
heuristics subproblem selection designing problem solving system programmer comes equipped set distinct methods real task find efficient way program decide different methods 
methods dispose problem may transform create new problems subproblems 
course solving problem may involved large assembly interrelated subproblems 
parallel computer conceived time 
parallel machine procedures allocate resources simultaneously apply methods problems 
shall divide administrative problem parts selection subproblem critical attractive immediate section choice method apply selected problem 
basic program lt section iv subproblem selection simple 
new problems examined briefly solved placed linear problem list 
main program proceeds list step attacking problems order generation powerful systems judicious generation selection problems excessive branching restrained 
note simple scheme lt property generated problem eventually get attention created step 
turn full attention problem generated return alternate branches 
complex systems expect consider subproblem aspects apparent centrality solution promote main goal apparent difficulty effort liable consume 
need heuristic methods estimate quantities select accordingly problems allocate reasonable quantity effort 
want see considered problem considered similar 
see discussion 
problem handled generally simply remembering characters problems attacked checking new ones memory methods looking closely match 
little known matters entirely lack space remarks somewhat cryptic 
imagine problems relations arranged form kind directed graph structure 
main problem establish valid path initially distinguished nodes 
generation new problems represented addition new valid paths insertion new nodes old paths 
associate connection quantities describing current validity state solved plausible doubtful current estimated difficulty 
global methods general problem selection methods global step look entire structure 
simple scheme works degenerate interpretation problem graph 
electrical analogy suggested machine designed shannon play variant game marketed hex known mathematicians nash 
shannon describes variety interesting game playing learning machines 
initial board position represented certain network resistors 
game played network equal resistors 
player goal construct short circuit path boundaries opponent tries open circuit 
move consists opening irreversibly remaining resistors 
shannon machine applies potential boundaries selects resistor carries largest current 
roughly speaking resistor critical changing largest effect resistance net goal direction opening circuit 
argument perfect perfect model real combinatorial situation machine play extremely 
example machine begins opening resistor opponent counter resistor largest current 
remaining move pairs players strategy machine wins 
strategy unsound moves certain situations able force game 
note writing find strategy defeats large board versions machine 
global method problem selection requires available difficulty estimates related subproblems arranged combine roughly manner resistance values 
regard machine analog models planning 
see section iv 
variety combinatorial methods matched network analogy opponent program completed silver mit lincoln laboratory 
local hereditary methods prospect having study step problem structure discouraging especially structure usually changes slightly attempt 
naturally looks methods merely update modify small fragment stored record 
variety compromises lie extremes come served problem list method full global survey methods techniques 
attractive call inheritance methods essentially recursive devices 
inheritance method effort assigned subproblem determined immediate ancestry time problem created assigned certain total quantity time effort 
problem split subproblems quantities assigned local process depends relative merits remains centrality problem managed implicitly 
schemes quite easy program especially new programming systems ipl lisp certain hereditary recursive operations 
special cases inheritance method arise get simple condition yields exploratory method called back tracking solomon 
decoding procedure jack important variety inheritance method 
complex exploration process proposed chess newell shaw simon form inheritance method non numerical condition 
subproblems inherit sets goals achieved 
teleological control administered additional goal selection system complicated global reasonably simple rule backing variety section iii 
note identifying move tree limitation problem problem selection 
extensive experimental results available feel scheme deserves careful study planning serious area 
shows complexity sure come development intelligent machines 
discussion question may 
character method machines problem selected decide method try 
depends ability classify characterize problems 
compute character problem pattern recognition technique consult character method table device supposed tell method effective problems character 
information built experience initially programmer deduced advice obtained solution problem suggested gps proposal 
case part machine behavior regarded outside treated sort stimulus response table look activity 
characters descriptions wide variety values serious problem filling character method table 
reduce detail information important properties 
differences gps see section iv describe necessary define single goal priority scheme selects just characterize situation 
gelernter rochester suggest property weighting scheme special case bayes net described section ii 
planning ordinarily solve complicated problem dividing number parts attacked smaller search divided 
successful division reduce search time mere fraction fractional exponent 
graph branches descending node step search involve trials question insertion just lemmas sequential subgoals reduce search trials reason machine exploration 
worth relatively enormous effort find islands solution complex problems 
see section 
note encountered say failures procedures success gained factor trial reduction 
practically ability plan analyze problem profitable problem difficult 
safe say simple unitary notions build intelligent machine fail sharply modest level problem difficulty 
schemes actively pursue analysis obtaining set sequential goals expected extend smoothly increasingly complex problem domains 
straightforward concept planning simplified model problem situation 
suppose available problem problem essentially character detail complexity 
proceed solve simpler problem 
suppose done second set methods simpler correspondence original 
solution simpler problem plan harder 
step expanded detail 
multiple searches add multiply total search time 
situation ideal model mathematically homomorphism original 
perfection model solution valuable guide 
mathematics proof procedures usually run lines assumes integrals limits converge planning stage 
outline completed ill simple minded model mathematics goes back try rigorous steps proof replace chains argument genuine rules inference 
plan fails may possible patch replacing just steps 
aid planning semantic opposed homomorphic model 
may interpretation current problem system necessarily simpler familiar know methods powerful 
connection plan proof theorem want know proposed lemmas islands proof true 
plan surely fail 
easily tell proposition true looking interpretation 
truth proposition plane geometry supposed great reliability actual measurement constructed drawings analytic geometry equivalent 
geometry machine gelernter rochester uses semantic model excellent results follows closely lines proposed 
character algebra model planning aid model greatest value reducing search 
construct machines find models 
believe provide general straightforward way construct certain kinds useful models 
critical requirement able compile character method matrix addition simple character method table section iv 
cm matrix array entries predict reliability happen methods applied problems 
matrix dimensions indexed problem characters method usually transforms problems character problems character matrix entry ij name method list methods 
method corresponding entry null 
suppose entry ij meaning direct way transform problem type type cj 
multiply matrix 
new matrix non null entry sequence methods effects desired transformation 
fails may try higher powers 
note put unity terms reach matrix power just multiplications 
don need define symbolic multiplication operation may arithmetic entries putting unity non null entry zero null entry original matrix 
yields simple connection flow diagram matrix nth power tells set paths length see 
non null entry discovered exist efficient ways find corresponding sequences methods 
problem just finding paths maze method moore quite efficient 
problem converted problem finding chain terminal expressions formal system 
characters taken representations problem expressions character algebra model available pattern recognition facilities 
see 
critical problem character algebra model planning course prediction reliability matrix entries 
expect character result strictly determined character original method 
reliability predictions case deteriorate rapidly matrix power raised 
noted plan better system better exhaustive search quite poor prediction quality 
matrix formulation obviously special case character planning idea 
generally descriptions fixed characters general methods calculate description happen method applied 
characters differences gps general problem solver proposal newell shaw simon find slightly different framework notion difference problems expressions speak character single problem 
views equivalent take problems links connections expressions 
notion difference character pair lend smoothly teleological reasoning 
goal defined problem reduce difference state desired state 
underlying structure gps precisely called character method ma chine kind difference associated table methods known reduce difference 
characterization depends current problem expression desired result reasonable think authors suggest gps means analysis 
illustrate differences shall review example 
problem elementary propositional calculus prove implies deduce program looks expressions recursive matching process branches main connectives 
difference encounters occurs different sides main connective 
looks difference method table heading change position 
discovers method uses theorem obviously useful removing reducing differences position 
gps applies method obtaining implies gps asks difference new expression goal 
time matching procedure gets connectives inside left hand members finds difference connectives implies 
looks table heading change connective discovers appropriate method implies applies method obtaining final cycle difference evaluating procedure discovers need change position inside left member applies method 
completes solution problem 
compare matching process described 
notions character character algebra originate useful describing parts gps system 
contains additional material survey 
essentially gps self applied problem discovering sets differences appropriate problem areas 
notion bootstrapping applying problem solving system task improving methods old ar find specific proposal advance realized 
evidently success means analysis reducing general search depend degree specificity written difference method table basically requirement effective character algebra 
may possible plan differences 
imagine difference algebra predictions form construct accordingly difference factorization algebra discovering longer chains 
corresponding method plans 
note expect planning methods primitive differences 
form character algebras expressions levels descriptive detail matrix powers swiftly degenerate 
degeneracy ultimately limit capacity formal planning device 
may think general planning heuristic embodied recursive process form 
suppose problem form plan problem select step plan 
steps exit success try suggested method success return try step plan 
failure return form new plan change current plan avoid step 
problem judged difficult apply entire procedure sub problem current step 
observe program schema essentially recursive uses subroutine explicitly step way current state stored restored returns control 
violates example restrictions loops programming systems fortran 
convenient techniques programming processes developed newell shaw simon program state variables stored pushdown lists program data stored form list structures 
gelernter extended fortran manage 
mccarthy extended notions lisp permit explicit recursive definitions programs language recursive functions symbolic expressions 
lisp management program state variables fully automatic 
see orchard hays article issue 
chapters miller discuss possible analogies human problem solving heuristic planning schemes 
certain years close association theories human behavior attempts increase intellectual capacities machines 
long run prepared discover profitable lines heuristic programming deliberately imitate human characteristics 
limitations space preclude detailed discussion theories self organizing neural nets models brain analogies 
described cited 
omission serious feel connection subject heuristic programming motivation methods areas different 
time research neural net models concerned mainly attempt show certain simple heuristic processes reinforcement learning property list pattern recognition realized evolved collections simple elements highly organized interconnections 
heuristic programming characterized quite differently search new powerful heuristics solving complex problems little concern hardware neuronal minimally suffice realization 
short nets concerned far get small initial endowment artificial intelligence concerned know build powerful systems 
expectation problem solving power allegedly brain minimal structure systems threaten compete deliberately designed study prove profitable development component elements subsystems construction systematically conceived machines 
induction models intelligence discussion come isolate intelligence 
discussed heuristics shortcuts classification techniques 
missing 
am confident sooner able assemble programs great problem solving ability complex combinations heuristic devices multiple optimizers pattern recognition tricks planning algebras recursive administration procedures 
find seat intelligence 
ask intelligence really 
view question sense technical matter 
intelligence denote little complex performances happen respect understand 
usually question depth mathematics 
proof theorem really understood content trivial 
may remain sense wonder proof discovered 
programmers know heart program 
high level routines program dictate transfer subroutine 
look low level subroutines find loops sequences trivial operations merely carrying dictates superiors 
intelligence system intangible meaning single common word pronounced 
inability discern locus intelligence lead conclude programmed computers think 
may man machine understand structure program feeling mystery self weaken 
see 
find similar views concerning creativity 
view expressed rosenbloom minds brains transcend machines apparently erroneous interpretation meaning unsolvability theorems godel 
problems general agreement mcculloch freedom presumably means distinguish intend plan intervention action 
see mackay analogue devices 
concerning mind brain problem consider arguments hayek 
active leaders modern heuristic programming samuel taken strong position idea machines thinking 
argument fact reliable computers instructed basic flaw follow programmer full knowledge full responsibility credit ensue 
certainly programmer may set evolutionary system limitations unclear possibly incomprehensible 
better mathematician know consequences proposed set axioms 
surely machine order perform 
assign credit programmer operation system comes reveal structures recognizable anticipated programmer 
seen way intelligent activity machines samuel arguments circular presuming machines minds assure 
turing gives knowledgeable discussion matters 
inductive inference pose machines variety problems challenging ordinary game mathematical puzzle 
suppose want ma chine embedded time complex environment universe essay produce description world discover regularities laws nature 
ask predict happen 
ask predict consequences certain action experiment 
ask formulate laws governing class events 
case task equip machine inductive ability methods construct general statements events recorded experience 
system inductive inference possible universes 
universe ensemble universes criterion success epistemological problem machines technical philosophical 
quite literature concerning subject shall discuss approach currently promising call grammatical induction schemes solomonoff partly chomsky miller 
take language mean set expressions formed set primitive symbols expressions repeated application set rules primitive expressions plus rules grammar language 
induction problems framed problems discovery grammars 
suppose instance machine prior experience summarized large collection statements labeled bad critical device 
generate selectively statements 
trick find relatively simple formal language statements grammatical bad ones 
language generate statements presumably tend ones 
heuristic argument find relatively simple way separate sets discovered rule useful immediate experience 
extension fails consistent new data able small changes rules generally may able ordinary problem solving methods task 
problem finding efficient grammar finding efficient encodings programs machines case needs discover important regularities data exploit regularities making abbreviations 
possible importance solomonoff may point way systematic mathematical ways explore discovery problem 
considers class programs general purpose computer produce certain output body data question 
programs allowed continue add body data 
properly weighting programs length obtain corresponding weights different possible continuations basis prediction 
prediction interest necessary show independence computer clear precisely form result take 
models oneself creature answer question hypothetical experiment performing experiment answer obtained inside creature 
output representing correct answer input representing question coded descriptions corresponding external events event classes 
seen pair encoding decoding channels internal acts environment character model 
inductive inference problem may regarded problem constructing model 
extent creature actions affect environment internal model world need include representation creature 
asks creature decide asks answer come internal model 
evidence introspection liable ultimately processes constructing image self 
speculation form model leads amusing prediction intelligent machines may reluctant believe just machines 
argument self models substantially dual character part concerned physical mechanical environment behavior inanimate objects part concerned social psychological matters 
precisely developed satisfactory mechanical theory mental activity keep areas apart 
give division wished find unified model replace 
ask creature sort simply answer directly 
inspect model 
answer saying dual thing appears parts mind body 
robot equipped satisfactory theory artificial intelligence maintain opinion matter 
certain problem infinite regression notion machine having model course nested models lose detail vanish 
argument hayek see fully comprehend unitary order minds ignores power recursive description 
particular overlooks turing demonstration sufficient external writing space general purpose machine answer question description larger machine answer 
attempting combine survey artificial intelligence summary views mention relevant project publication 
important omissions area brain models early belmont farley wesley clark farley duplicated nathaniel rochester peter milner 
jerome related theories 
touch problems logic language information retrieval faced action contents large memories see john mccarthy 
discussed basic results mathematical logic bear question done machines 
entire literatures hardly sampled bold pioneering nicholas workers theories learning saul theory games martin psychology jerome bruner 
know george polya solve problems 
hope transmitted flavor ambitious projects directly concerned getting machines take larger portion problem solving tasks 
discussed concerned self contained problem solving programs 
written see vigorous activity direction constructing usable time sharing multiprogramming computing systems 
systems economical match human beings real time really large machines 
means programming effect thinking aids 
years come expect man machine systems share time dominant advance development artificial intelligence 
bibliography area currently prominent periodicals ibm res 
dev 
information control 
proc 
eastern western joint computer conferences 
ire national convention record 
assoc 
comp 
mach 
jacm 
trans 
assoc 
comp 
mach 
ire transactions information theory informative bibliography author appear shortly ire trans 
human factors electronics 
note bibliography appeared marvin minsky selected descriptor indexed bibliography literature artificial intelligence ire transactions human factors electronics hfe march pp 

reprinted computers thought ed 
feigenbaum feldman pp 
mcgraw hill 
citations published volumes proc 
march 
automata studies shannon mccarthy eds 
princeton univ press princeton 
proc 
symp 
mechanization thought processes office london 
self organizing systems cameron eds pergamon press new york 
proc 
intl 
conf 
information processing unesco house paris proc 
december 
comm 
acm vol 
april 
preprints conf 
symbol manipulation programs 
fourth london symp 
information theory cherry ed 
third london symp 
information theory cherry ed academic press new york 
newman ed world mathematics simon schuster new york 
ire trans 
information theory vol 
september mccarthy inversion functions defined turing machines 
samuel studies machine learning game checkers ibm res 
dev vol 
pp 
july 
shannon programming digital computer playing chess 
shannon synthesis terminal switching networks bell sys 
tech 
vol 
pp 

ashby design brain john wiley sons new york 
ashby design intelligence amplifier 
minsky selfridge learning random nets 
sherman quasi topological method machine recognition line patterns 
minsky aspects heuristic programming artificial intelligence 
pitts mcculloch know universals bull 
math 
biophys vol 
pp 

wiener cybernetics john wiley sons new york selfridge pattern recognition modern computers programming pattern recognition 
minsky heuristic aspects artificial intelligence problem lincoln lab lexington mass group rept 
doc 
december 
hayden library 

newell shaw simon variety intelligent learning general problem solver 
solomonoff mechanization linguistic learning cambridge mass tech 
bull 
second intl congress cybernetics namur belgium september solomonoff new method discovering grammars phrase structure languages 
solomonoff preliminary report general theory inductive inference cambridge mass tech 
bull 
february 
selfridge pandemonium paradigm learning selfridge neisser pattern recognition machine sci 
am vol 
pp 
august 
samuel studies machine learning game checkers ibm res 
dev vol 
pp 
july 
rosenblatt perceptron cornell aeronautical lab 
ithaca rept 
vg january 
see article hawkins issue 
comments character recognition method bledsoe browning correspondence ire trans 
electronic computers vol 
ec june 
bledsoe browning pattern recognition reading machine 
roberts pattern recognition adaptive network ire international convention record pt 
doyle recognition sloppy hand printed characters lincoln lab lexington mass group rept 
december 
kirsch ray cahn urban experiments processing pictorial information digital computer proc 
pp 
december 
conditional probability machines temporal spatial patterns conditional probability machine conditional probability computing nervous system 
information retrieval structured content shannon programming digital computer playing chess 
mccarthy recursive functions symbolic expressions alpha numeric character recognition local operations 
system automatic recognition patterns proc 
iee vol 
pt 
march 
unger pattern detection recognition proc 
ire vol 
pp 
october holland iterative circuit computers constructed components systems proc 
pp 
hebb organization behavior john wiley sons new york kohler gestalt psychology 

haller line tracing character recognition thesis cambridge mass automatic devices recognition visible dimensional patterns survey field naval electronics lab san diego calif tech 
memo 
june stevens survey automatic reading techniques nbs dept commerce washington rept 
august 
tinbergen study instinct oxford university press new york selfridge pattern recognition learning skinner science human behavior macmillan new york 
robert bush frederick mosteller mathematical model simple learning 
ps 
rev 
miller plans structure behavior henry holt new york minsky neural nets brain model problem ph dissertation princeton univ princeton 
university microfilms ann arbor 
bernstein chess playing program ibm pp 
newell shaw simon chess playing programs problem complexity ibm res 
dev 
vol 
ff october newell chess machine 
bellman dynamic programming princeton university press princeton 
topics dynamic programming lincoln lab lexington mass rept 
april 
hayden library 

see especially sec 

friedberg learning machine part ibm res 
dev vol 
pp 
january 
friedberg dunham north learning machine part ii ibm res 
dev vol 
pp 
july solomonoff inductive inference machine ire national convention record pt 
pp 
darlington evolution genetics basic books new york 
newell simon logic theory machine newell shaw simon empirical explorations logic theory machine proc 
pp 
wang mechanical mathematics ibm res 
dev vol 
pp 
january 
newell shaw simon elements theory human problem solving psych 
rev vol 
march davis putnam computing procedure quantification theory acm vol 
pp 
july 
gelernter rochester intelligent behavior problem solving machines ibm res 
dev vol 
ff 
october 
shannon game playing machines franklin inst 
vol 
pp 
december newell ipl comm 
cm vol 
april mathematical theory discrete classification coding way channels computer program solving integration problems calculus phd 
thesis cambridge mass newell shaw simon report general problem solving program 
gelernter realization geometry proving machine mccarthy programs common sense 
moore shortest path maze proc intl 
symp 
theory switching harvard univ turing machine think 
rosenbloom elements mathematical logic dover publications new york rogers review godel proof newman nagel am 
math 
monthly vol 
january 
mcculloch den 
phil 
science vol 

mackay operational aspects intellect nature explanation cambridge univ press 
preface dated 
hayek sensory order routledge kegan paul london physical analogues growth concept chomsky syntactic structures mouton hague chomsky miller finite state languages information control pp 
may rochester tests cell assembly theory action brain large digital computer maturana mcculloch pitts frog eye tells frog brain proc 
ire vol 
pp 
november 
mechanical simulation learning information control vol 
pp 
september 
games decisions industrial organization management science vol 
pp 
july 
bruner austin study thinking john wiley sons new york 
polya solve princeton univ press princeton 
induction analogy mathematics patterns plausible inference vols 
princeton univ press princeton 
theory nets ire trans 
electronic computers vol 
ec pp 
september 
mackay epistemological problem automata weight evidence false target probabilities samuel letter editor science vol 
september 
incorrectly labeled vol 
cover 
farley clark simulation self organizing systems digital computer ire transactions information theory pp 
september 
wang proving theorems pattern recognition 
sumner experiments machine thinking learning 
mathematical biophysics dover publications new york vol 

