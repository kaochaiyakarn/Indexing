journal artificial intelligence research submitted published new inference rules max sat chu min li chu min li fr universit de jules rue st leu cedex france iiia csic es iiia artificial intelligence research institute csic spanish national research council campus uab spain jordi planes es computer science department universitat de ii spain exact max sat solvers compared sat solvers apply little inference node proof tree 
commonly sat inference rules unit propagation produce simplified formula preserves satisfiability unfortunately solving max sat problem simplified formula equivalent solving original formula 
define number original inference rules applied efficiently transform max sat instances equivalent max sat instances easier solve 
soundness rules seen refinements unit resolution adapted max sat proved novel simple way integer programming transformation 
aim finding powerful inference rules practice developed new max sat solver called maxsatz incorporates rules performed experimental investigation 
results provide empirical evidence maxsatz competitive random max sat random max sat max cut graph coloring instances benchmarks max sat evaluation 

years growing interest developing fast exact max sat solvers niedermeier planes de larrosa meseguer schiex li planes xing zhang zhang shen due potential solve constrained nphard problems encoded formalism boolean cnf formulas 
nowadays max sat solvers able solve lot instances reach solvers developed just years ago 
considerable gap difficulty instances solved current sat solvers instances solved best performing max sat solvers 
motivation bridge gap complete sat solvers exact max sat solvers investigating technology previously developed sat goldberg li marques silva sakallah zhang zhang madigan moskewicz malik extended incorporated max ai access foundation 
rights reserved 
li planes sat 
precisely focus attention branch bound max sat solvers davis putnam logemann loveland dpll procedure davis logemann loveland davis putnam 
main differences sat solvers max sat solvers intensive unit propagation node proof tree 
unit propagation highly powerful inference rule transforms sat instance satisfiability equivalent sat instance easier solve 
unfortunately solving max sat problem general equivalent solving number unsatisfied clauses truth assignment 
example apply unit propagation cnf formula obtain equivalent interpretation satisfying clause clauses want compute optimal solution apply unit propagation sat solvers 
proposed previous li unit propagation compute lower bounds branch bound max sat solvers unit propagation simplify cnf formulas 
approach detect disjoint inconsistent subsets clauses unit propagation 
turns number disjoint inconsistent subsets detected underestimation number clauses unsatisfied current partial assignment extended complete assignment 
underestimation plus number clauses unsatisfied current partial assignment provides performing lower bound captures lower bounds inconsistency counts state art max sat solvers implement planes borchers wallace freuder zhang improved lower bounds planes xing zhang 
hand number disjoint inconsistent subsets detected just conservative underestimation lower bound inconsistent subset increases lower bound independently number clauses unsatisfied optimal assignment 
optimal assignment violate clause inconsistent subset 
able improve lower bound counting number disjoint inconsistent subsets clauses 
hand despite fact quality lower bounds prune large parts search space accelerate dramatically search optimal solution lower bound reach best solution far upper bound solver continues exploring search space current node 
search solvers inconsistencies computing lower bound different nodes 
basically problem lower bound computation methods simplify cnf formula way unsatisfied clauses explicit 
lower bounds just pruning technique 
overcome problems define set sound inference rules transform max sat instance max sat instance easier solve 
max sat inference rule sound equivalent 
see example inference rule max sat instance contains clauses form literals replace cnf formula new inference rules max sat 
note rule detects contradiction replaces clauses empty clause 
addition rule adds clause ensure equivalence assignment containing number unsatisfied clauses assignment containing number unsatisfied clauses 
note assignment containing best assignment subset best formula 
adding rule ensures number unsatisfied clauses 
inference rule adds new clause may contribute contradiction detectable unit propagation 
case rule allows increase lower bound 
rule explicit contradiction contradiction need current node 
inference rules defined known literature bansal raman niedermeier original max sat 
new rules inspired different unit resolution refinements applied sat selected applied natural efficient way 
sense summarize telling defined max sat counterpart sat unit propagation 
aim finding powerful inference rules practice designed implemented new max sat solver called maxsatz incorporates rules lower bound defined previous li performed experimental investigation 
results provide empirical evidence maxsatz competitive random max sat random max sat max cut graph coloring instances benchmarks max sat evaluation structure follows 
section give preliminary definitions 
section describe basic branch bound max sat solver 
section define inference rules prove soundness novel simple way integer programming transformation 
give examples illustrate inference rules may produce better quality lower bounds 
section implementation inference rules maxsatz 
section describe main features maxsatz 
section report experimental investigation 
section related 
section 

preliminaries propositional logic variable xi may take values false true 
literal li variable xi negation xi 
clause disjunction literals cnf formula conjunction clauses 
length clause number literals 
size denoted sum length clauses 

www iiia csic es maxsat li planes assignment truth values propositional variables satisfies literal xi xi takes value satisfies literal xi xi takes value satisfies clause satisfies literal clause satisfies cnf formula satisfies clauses formula 
empty clause denoted contains literals satisfied 
assignment cnf formula complete variables occurring assigned partial 
max sat problem cnf formula problem finding assignment values propositional variables minimizes number unsatisfied clauses equivalently maximizes number satisfied clauses 
max sat called clauses literals clause 
represent cnf formula multiset clauses duplicated clauses allowed max sat instance 
cnf formulas equivalent number unsatisfied clauses complete assignment 
basic max sat solver space possible assignments cnf formula represented search tree internal nodes represent partial assignments leaf nodes represent complete assignments 
basic branch bound algorithm max sat explores search tree depth manner 
node algorithm compares number clauses unsatisfied best complete assignment far called upper bound ub number clauses unsatisfied current partial assignment plus underestimation minimum number non empty clauses unsatisfied extend current partial assignment complete assignment underestimation 
sum underestimation lower bound lb minimum number clauses unsatisfied complete assignment extended current partial assignment 
obviously lb ub better solution point search 
case algorithm prunes subtree current node backtracks higher level search tree 
lb ub algorithm tries find possible better solution extending current partial assignment instantiating variable leads creation branches current branch left branch corresponds assigning new variable false right branch corresponds assigning new variable true 
case formula associated left right branch obtained formula current node deleting clauses containing literal removing occurrences literal algorithm applies literal rule 
solution max sat value ub takes exploring entire search tree 
shows pseudo code basic solver max sat 
notations procedure simplifies applying sound inference rules 
function returns number empty clauses 
new inference rules max sat input max sat ub cnf formula upper bound ub contains empty clauses return lb underestimation ub lb ub return ub ub min ub max sat ub return min ub max sat ub output minimal number unsatisfied clauses basic branch bound algorithm max sat lb lower bound minimum number unsatisfied clauses current partial assignment extended complete assignment 
assume initial value 
underestimation ub function returns underestimation minimum number non empty clauses unsatisfied current partial assignment extended complete assignment 
ub upper bound number unsatisfied clauses optimal solution 
assume initial value total number clauses input formula 
function returns variable heuristic 
formula obtained applying literal rule literal 
state art max sat solvers implement basic algorithm augmented powerful inference techniques quality lower bounds clever variable selection heuristics efficient data structures 
defined li lower bound computation method underestimation lower bound number disjoint inconsistent subsets detected unit propagation 
pseudo code shown 
example cnf formula 
approach able establish number disjoint inconsistent subsets clauses 
underestimation lower bound 
steps performed ones li planes input underestimation ub cnf formula upper bound ub underestimation apply literal rule unit clauses unit propagation empty clause derived empty clause derived return underestimation clauses derive empty clause underestimation underestimation underestimation ub return underestimation go output underestimation lower bound computation underestimation unit propagation 
inconsistent subset detected unit propagation underestimation 
second inconsistent subset detected unit propagation underestimation 
third inconsistent subset detected unit propagation underestimation 
empty algorithm stops 

inference rules define set inference rules considered 
inspired different unit resolution refinements applied sat selected applied natural efficient way 
known literature bansal raman niedermeier original max sat 
presenting rules define integer programming transformation cnf formula establish soundness rules 
method proving soundness novel max sat provides clear short proofs 
integer programming transformation cnf formula assume cm cnf formula clauses variables xn 
ci xi xik xik xik note put positive literals ci negative ones 
consider variables ci integer variables values define integer transformation ci ei xi xik xik xik xi xik xik xik new inference rules max sat obviously ei value iff variables xij instantiated variables xis instantiated 
words ei iff ci satisfied 
ei 
literal corresponds integer denoted convenience 
intention correspondence literal satisfied integer unsatisfied integer 
positive literal corresponding integer negative literal 
consequently case 
generically write ci lk integer programming transformation ei lk 
integer programming transformation cnf formula cm variables xn defined xn integer programming transformation huang jin li huang design local search procedure called pseudo boolean formulation hammer 
extend empty clauses ci empty ei 
assignment variables xn value number unsatisfied clauses 
satisfies clauses 
obviously minimum number unsatisfied clauses minimum value cnf formulas integer programming transformations 
clear equivalent complete assignment 
inference rules define inference rules prove soundness previous integer programming transformation 
rest section denote cnf formulas integer programming transformations 
prove equivalent prove 
rule bansal raman lk lk lk equivalent 
proof lk lk lk general case resolution max sat bansal raman 
rule establishes resolution works clauses give strictly shorter resolvent 
ei li planes rule known literature replacement common clauses 
pay special attention case resolvent unit clause case resolvent empty clause 
describe case rule rule niedermeier equivalent 
proof rule known complementary unit clause rule replace complementary unit clauses empty clause 
new empty clause contributes lower bounds search space current node incrementing number unsatisfied clauses incrementing underestimation means contradiction 
practice simple rule gives rise considerable gains 
rule complicated case rule equivalent 
proof rule replaces clauses empty clause adds new binary clause keep equivalence 
pattern considered compute 
shen zhang captured method computing unit propagation li 
larrosa heras mentioned existential directional arc consistency de heras larrosa capture rule 
note underestimation computation methods shen zhang add additional clause approach just detect contradictions 
define rule generalizes rule rule 
presenting rule define lemma needed prove soundness 
lemma equivalent 
proof new inference rules max sat rule lk lk lk lk lk equivalent 
proof prove soundness rule induction applying rule get 
equivalent 
assume rule sound prove sound 
case ln ln ln ln ln applying lemma clauses get ln ln ln ln ln applying induction hypothesis clauses previous cnf formula get ln ln ln ln 
equivalent rule sound 
rule original inference rule 
captures linear unit resolution refutations clauses resolvents exactly 
rule simply adds empty clause eliminates unit clauses binary clauses refutation adds new binary clauses obtained negating literals eliminated binary clauses 
operations involved performed efficiently 
rule rule explicit contradiction need current subtree 
lower bound computation incremental 
binary clauses added rule rule may contribute compute better quality lower bounds acting premises inference rule part inconsistent subset clauses illustrated example 
example 
depending ordering unit clauses propagated unit propagation detects inconsistent subsets clauses 
inconsistent subset detected removed remaining set clauses satisfiable 
applying rule rule lower bound computed underestimation computed unit propagation 
note rule applied inconsistent subset 
rule applied contradiction explicit clauses added 

turns inconsistent set clauses detectable unit propagation 
lower bound computed 
inconsistent subset detected rule applied 
contradiction explicit clause added 

turns inconsistent set clauses detectable unit propagation 
lower bound computed 
li planes similarly inconsistent subset detected rule applied lower bound computed 
observe example rule rule explicit contradiction allow improve lower bound 
unit propagation needs unit clause detect contradiction 
drawback rule rule consume unit clauses deriving just contradiction 
possible situation branching unit clauses allow unit propagation derive disjoint inconsistent subsets clauses show example 
example 
rule replaces empty clause 
selected branching variable assigned unit clause contradiction detected unit propagation 
lower bound situation 
rule applied branching unit clauses branching 
case propagation allows detect inconsistent subset propagation allows detect inconsistent subset 
lower bound computed branching 
hand rule rule add clauses contribute detect additional conflicts 
hand application rule rule consumes unit clauses detect conflicts 
final effect factors empirically analyzed section 
new rules capture unit resolution refutations exactly unit clause consumed ii unit clause twice linear derivation empty clause 
rule equivalent 
proof combine linear derivation rule obtain rule rule lk lk lk lk lk lk lk lk lk lk lk lk lk lk lk lk equivalent 
new inference rules max sat proof prove soundness rule induction lemma get rule get 
equivalent 
assume rule sound prove sound 
case ln ln ln ln ln ln ln ln lemma get ln ln ln ln ln ln ln ln applying induction hypothesis get ln ln ln ln ln ln ln ln 
equivalent rule sound 
similarly rule rule rule rule explicit contradiction need subsequent search 
lower bound computation incremental 
add clauses improve quality lower bound illustrated example 
example 
depending ordering unit clauses propagated unit propagation detect inconsistent subsets rule applicable 
rule applied lower bound computed underestimation function remaining clauses satisfiable inconsistent subset clauses removed 
rule allows add ternary clauses contributing contradiction 
example rule applied adds clauses remaining clauses give second contradiction detectable unit propagation 
lower bound computed rule 
contrast rule rule rule rule consume exactly unit clause deriving empty clause 
unit clause derive conflict unit propagation rule rule limit detection conflicts unit propagation 
li planes 
implementation inference rules section describe implementation inference rules section 
suppose cnf formula loaded literal list clauses containing constructed 
application rule means clauses removed cnf formula new clauses inserted formula lower bound increased 
note inference rules selected approach contains fewer literals fewer clauses new clauses inserted place removed clauses inference rule applied 
need dynamic memory management implementation faster 
rule rule applied matching algorithm see cormen leiserson rivest stein efficient implementation lists clauses 
time complexity number clauses cnf formula 
second time complexity number unit clauses cnf formula 
rules applied node lower bound computation application inference rules 
rule applied times possible derive unit clauses applying rule 
implementation rule rule rule rule entirely unit propagation 
cnf formula unit propagation constructs implication graph see beame kautz applicability inference rules detected 
section describe construction implication graph describe determine applicability rule rule rule rule 
analyze complexity termination completeness application rules 
discuss extension inference rules weighted max sat implementation 
implication graph cnf formula shows unit propagation constructs implication graph nodes literals 
note node corresponds different literal considered different literals 
cnf formula contains copies unit clause algorithm adds just node label 
example 
constructs implication graph add special node highlight contradiction 
acyclic added edge connects new node 
known time complexity unit propagation size see freeman 
associate clause node node added note node incoming edge unit node incoming edge binary 
constructed contains literal unit propagation deduces contradiction easy identify nodes exists path clauses new inference rules max sat input cnf formula containing complementary unit clauses literal initialize empty graph add node labeled literal unit clause repeat nodes clause node add node labeled add directed edge node nodes added literal nodes return output implication graph unit propagation constructing implication graphs example implication graph li planes example implication graph implying 
clauses constitute inconsistent subset 
example clauses imply clauses imply 
clause contribute contradiction 
inconsistent subset 
applicability rule rule rule rule assume unit propagation deduces contradiction implication graph contains literal 
set nodes exists path set nodes exists path clause associated node denote set clauses associated nodes respectively 
lemma lemma detect applicability rule rule rule rule 
lemma rule rule applicable 
resp 
unit clause clauses binary 
nodes resp 
form implication chain starting unit clause resp 

empty 
proof starting node corresponding unit clause resp 
parallel implication chains rule rule writing clause corresponding node 
example cnf formula containing clauses 
unit propagation constructs implication graph shown contains complementary literals 
rule applicable 
easy verify conditions lemma satisfied 
rewritten compared rule 
new inference rules max sat example implication graph application rule rule consists replacing binary clause binary clause obtained negating literal removing unit clauses incrementing 
lemma rule rule applicable 
unit clause clauses binary nodes node corresponding unit clause exactly incoming edge 
non empty contains nodes forming implication chain form node chain 

contains exactly nodes third 
third literal contains implications contains implications proof assume loss generality case symmetric 
implication chain formed nodes corresponds clauses clauses corresponding give rule rule 
example cnf formula containing clauses 
unit propagation constructs implication graph shown contains complementary literals 
sx 
nodes sx obviously form implication chain 
sx sx 
contains 
rule applicable 
application rule rule consists removing unit clause replacing binary clause binary clause obtained negating literals replacing binary clauses ternary clauses incrementing 
li planes complexity termination completeness rule applications branch bound algorithm max sat combine application inference rules computation underestimation lower bound 
cnf formula function underestimation uses unit propagation construct implication graph contains nodes literal analyzed determine inference rule applicable 
rule applicable applied transformed equivalent max sat instance 
clauses contributing contradiction removed underestimation incremented 
procedure repeated unit propagation derive contradictions 
removed clauses removed replaced due inference rule applications reinserted 
underestimation new returned 
known unit propagation implemented time complexity linear size see freeman 
complexity determining applicability inference rules lemma lemma linear size bounded number literals assume graph represented doubly linked lists 
application inference rule obviously linear size time complexity function underestimation inference rule applications number contradictions function underestimation able detect unit propagation 
observe factor needed application rules inserts new clauses place removed clauses 
inference rule application reduces size function underestimation inference rule applications linear space complexity terminates 
recall new clauses added inference rules stored place old ones 
data structures loading statically efficiently maintained 
proved inference rules sound 
example shows application rules necessarily complete implementation sense possible applications inference rules necessarily done 
example 
unit propagation may discover inconsistent subset 
case inference rule applicable underestimation lower bound incremented 
unit propagation detect contradictions function underestimation stops 
value returned unchanged 
note rule applicable subset applied 
function underestimation applies rule unit propagation detects inconsistent subset 
detection inconsistent subset depends ordering unit clauses propagated unit propagation 
example inconsistent subset discovered unit clause propagated 
study needed define orderings unit clauses maximize application inference rules 
observe algorithm deterministic computes lower bound order clauses changed 
new inference rules max sat inference rules weighted max sat inference rules naturally extended weighted max sat 
weighted max sat clause associated weight problem consists finding truth assignment sum weights unsatisfied clauses minimum 
example weighted version rule rule equivalent positive integers representing clause weight min 
mandatory clauses satisfied optimal solution specified weight 
note optimal solution solver backtrack 
clauses weight removed 
observe rewritten weighted inference rule equivalent unweighted version applied times unweighted clauses 
similarly weighted version rule rule lk lk wk lk wk lk lk lk lk wk lk wk equivalent min 
wk 
observe rewritten lk lk lk weighted version rule equivalent unweighted rule applied times unweighted clauses 
current implementation inference rules naturally extended weighted inference rules 
inconsistent subformula detected rule applicable clause weights considered detection inconsistent subformula applicability rule provided clauses weight discarded separated computing minimal weight clauses detected inconsistent subformula rule applied 
derived clauses clauses subsequent reasoning 

maxsatz new max sat solver implemented new max sat solver called maxsatz incorporates lower bound computation method unit propagation defined section applies inference rules defined section 
name maxsatz comes fact implementation algorithm incorporates technology developed sat solver satz li anbulagan 
maxsatz incorporates lower bound unit propagation applies rule rule rule rule rule rule 
addition maxsatz applies techniques pure literal rule literal appears positive polarity negative polarity delete clauses containing literal 
li planes empty unit clause rule neg pos number unit clauses negative positive 
neg ub assign false 
pos ub assign true 
dominating unit clause duc rule niedermeier number clauses literal appears greater neg pos assign false true 
variable selection heuristic neg pos number binary clauses negative positive neg pos number clauses containing literals negative positive 
select variable neg neg neg pos pos pos largest 
fact binary clauses counted times clauses determined empirically 
value selection heuristic selected branching variable 
neg neg neg pos pos pos set true 
set false 
heuristics determined empirically 
order compare inference rules defined simplified versions maxsatz maxsat apply inference rule defined section 
maxsat applies rules rules 
maxsat applies rules rules 
maxsatz corresponds maxsat terminology 
maxsat corresponds improved version solver li special ordering propagating unit clauses unit propagation 
maxsat maintains queues unit propagation 
maxsat starts search inconsistent subformula unit propagation contains unit clauses cnf formula consideration derived unit clauses empty 
unit clauses derived application unit propagation stored unit propagation unit clause empty 
intuitively ordering prefers unit clauses non unit clauses starting application unit propagation 
way derived inconsistent subset contains general unit clauses 
unit clauses consumed contribute detect inconsistent subsets 
experimental results li planes show search tree size maxsat substantially smaller maxsat substantially faster 
maxsat maxsat maxsatz ordering maxsat propagating unit clauses unit propagation 
source code maxsat maxsat maxsat maxsatz web es jair maxsatz solvers zip www fr cli maxsatz tar gz 

experimental results new inference rules max sat report experimental investigation performed unweighted max sat order evaluate inference rules defined section compare maxsatz best performing state art solvers publicly available submitted 
experiments performed linux cluster processors ghz amd opteron gb ram 
structure section follows 
describe solvers benchmarks considered 
experimental evaluation inference rules 
show experimental comparison maxsatz solvers 
solvers benchmarks maxsatz compared max sat solvers bf borchers branch bound max sat solver uses dynamic variable selection heuristic consider computation lower bound 
developed borchers 
agn branch bound max sat solver 
developed niedermeier 
amp branch bound max sat solver bf incorporates lower bound better quality jeroslow wang variable selection heuristic jeroslow wang 
developed planes sat 
toolbar de larrosa heras max sat solver inference inspired soft arc consistency properties implemented weighted csp solvers 
developed de larrosa meseguer schiex cp 
version default parameters 
xing zhang branch bound max sat solver applies number efficient inference rules 
developed xing zhang cp 
second release solver 
lazy branch bound max sat solver lazy data structures static variable selection heuristic 
developed planes sat 

downloaded october edu borchers tar gz 
downloaded october www fs informatik uni tuebingen de 
available web es software html 
downloaded october toulouse fr cgi bin cgi 
downloaded october cic cs wustl edu 
available web es software html li planes li branch bound max sat solver lower bound computation method unit propagation cf 
section 
developed li planes cp 
benchmarks randomly generated max sat instances max sat instances graph coloring instances max cut instances considered unweighted max sat benchmarks submitted max sat evaluation including max cut max ones ramsey numbers random max sat max sat instances 
generated max sat instances max sat instances developed bart selman allows duplicated clauses 
max cut generated random graph edges edge randomly selected set possible edges 
graph connected discarded 
graph connected encoding shen zhang encode max cut instance cnf created edge xi xj exactly binary clauses xi xj xi xj 
collection binary clauses max cut instance cut weight iff max sat instance assignment clauses satisfied 
graph coloring culberson generator generate random graph type iid independent random edge assignment variability vertices fixed edge density 
culberson converter sat standard conversion colors generate max sat instance vertex xi color propositional variable xij defined meaning vertex colored color vertex xi clauses added encode vertex colored exactly color xi xi xi xi xi xi xi xi xi edge xi xj clauses added encode vertex xi vertex xj color xi xj xi xj xi xj 
random max sat max sat instances clauses entirely independent structure 
graph coloring instances max cut instances clauses independent structure 
example max cut instance time clause xi xj clause xi xj satisfaction clauses means corresponding edge cut 
graph coloring instance time ternary clause xi xi xi encoding vertex colored color binary clauses xi xi xi xi xi xi encoding vertex colored colors 
max cut instances contain binary clauses graph coloring instances contain ternary clause vertex graph 
derive optimal cut optimal assignment max sat encoding max cut instance optimal assignment max sat encoding coloring instance may assign color vertices 

available web es software html 
undirected graph 
xn set vertices set edges set colors graph coloring problem problem coloring vertex colors way edge xi xj vertex xi vertex xj color 

undirected graph wx weight associated edge xi xj weighted max cut problem find subset wx maximized set weight wx edges 
new inference rules max sat max cut ramsey numbers instances max sat evaluation contain different structures 
example underlying graphs max cut instances different origins fault diagnosis problems coding theory problems graph clique problems 
max sat max sat instances evaluation contain duplicated clauses 
computed initial upper bound local search solver instance 
provide parameter solver instance solved initial upper bound 
words default values parameters 
instances max sat evaluation solved conditions evaluation initial upper bound provided solvers maximum time allowed solve instance minutes 
evaluation inference rules experiment performed evaluate impact inference rules section solved sets random max sat instances variables number clauses ranged variables variables 
results obtained shown 
horizontal axis number clauses vertical axis mean time left plot seconds needed solve instance set mean number branches proof tree right plot 
notice log scale represent run time branches 
observe rules powerful max sat gain increases number variables number clauses increase 
variables clauses clause variable ratio maxsatz times faster maxsat variables clauses clause variable ratio maxsatz times faster maxsat 
search tree maxsatz substantially smaller maxsat 
rule rule powerful rule rule max sat 
intuitive explanation maxsatz maxsat detect inconsistent subsets clauses containing unit clause subsets containing unit clauses rule rule applied times rule rule maxsatz 
recall hand application rule rule consumes unit clauses produces empty clause limiting unit propagation detecting conflicts subsequent search 
hand rule rule add clauses may contribute detect conflicts 
depending number clauses precisely clause variable ratio formula factors different importance 
relatively clauses unit propagation relatively easily derive contradiction unit clause binary clauses added rule rule relatively important deriving additional conflicts improving lower bound explains search tree maxsat smaller search tree maxsat instances variables clauses 
contrary clauses unit propagation easily derives contradiction unit clause unit clauses consumed rule rule probably allow derive disjoint inconsistent subsets clauses 
addition binary clauses added rule rule relatively important deriving additional conflicts considering li planes large number clauses formula 
case search tree maxsat larger search tree maxsat 
cases maxsat faster maxsat meaning incremental lower bound computation due rule rule effective conflicts avoided rule rule 
time logscale time logscale max sat variables maxsat maxsat maxsat maxsatz number clauses max sat variables maxsat maxsat maxsat maxsatz number clauses branches log scale branches log scale max sat variables maxsat maxsat maxsat maxsatz number clauses max sat variables maxsat maxsat maxsat maxsatz number clauses comparison maxsat maxsat maxsatz random max sat instances 
rule rule limit unit propagation detecting conflicts application produces empty clause consumes just unit clause allows derive conflict case 
added ternary clauses allow improve lower bound search tree maxsatz substantially smaller search tree maxsat 
incremental lower bound computation due rule rule contributes time performance maxsatz 
example search tree maxsatz instances variables clauses times smaller search tree maxsat maxsatz times faster maxsat 
second experiment solved random max sat instances random max sat instances 
solved instances variables number clauses ranged variables variables 
results obtained shown 
time log scale time logscale max sat variables maxsat maxsat maxsat maxsatz number clauses max sat variables maxsat maxsat maxsat maxsatz number clauses new inference rules max sat branches log scale branches log scale max sat variables maxsat maxsat maxsat maxsatz number clauses max sat variables maxsat maxsat maxsat maxsatz number clauses comparison maxsat maxsat maxsatz random max sat instances 
rules involve ternary clauses powerful max sat 
similarly max sat rule rule slightly improve lower bound relatively clauses improve lower bound number clauses increases 
improve time performance incremental lower bound computation allowed 
gain increases number clauses increases 
example problems variables number clauses maxsat faster maxsat number clauses gain 
rule rule improve lower bound time performance maxsatz 
gain increases number clauses increases 
third experiment considered max cut problem graphs vertices number edges ranging 
shows results comparing inference rules max cut instances 
observe rules allow solve instances faster 
similarly random max sat rule rule improve lower bound clauses improve time performance due incremental lower bound computation allowed 
rule rule powerful rule rule instances contain binary clauses structure 
addition reduction tree size due rule rule contributes time performance maxsatz incrementality lower bound computation random max sat 
example search tree maxsatz instances edges times smaller search tree maxsat maxsatz times faster 
time log scale max cut nodes maxsat maxsat maxsat maxsatz number edges li planes branches log scale experimental results max cut max cut nodes maxsat maxsat maxsat maxsatz number edges fourth experiment considered graph coloring instances vertices density edges ranging 
shows results comparing inference rules graph coloring instances 
observe rule rule useful instances tree size maxsat maxsat maxsat slower maxsat 
contrary rules useful instances especially allow reduce search tree size deriving better lower bounds 
time log scale time log scale graph coloring nodes maxsat maxsat maxsat maxsatz edges graph coloring nodes maxsat maxsat maxsat maxsatz edges branches log scale branches log scale graph coloring nodes maxsat maxsat maxsat maxsatz edges graph coloring nodes maxsat maxsat maxsat maxsatz edges experimental results graph coloring new inference rules max sat note rule rule impact rule rule reducing cost solving instances 
probably due fact unit clauses needed detect contradiction rule rule applied times 
note instances vertices easier solve density graph high 
fifth experiment compared different inference rules benchmarks submitted max sat evaluation 
solvers ran conditions evaluation 
table column name benchmark set second column number instances set rest columns display average time seconds needed solver solve instance number solved instances brackets 
maximum time allowed solve instance minutes 
clear maxsat better maxsat maxsat better maxsat maxsatz better maxsat 
example maxsatz solves maxcut johnson instances time limit solvers solve instances 
average time maxsatz solve instances seconds third instance needing time solved instances 
set name instances maxsat maxsat maxsat maxsatz maxcut brock maxcut fat maxcut hamming maxcut johnson maxcut keller maxcut hat maxcut san maxcut maxcut max cut maxcut ramsey max sat vars max sat vars max sat vars max sat discarded max sat vars max sat vars table evaluation rules benchmarks max sat evaluation 
comparison maxsatz solvers experiment performed compare maxsatz state art max sat solvers solved sets random max sat instances variables number clauses ranged variables variables variables 
results solving instances bf agn amp lazy toolbar maxsatz shown 
horizontal axis number clauses vertical axis mean time seconds needed solve instance set 
solver needed time solve instances point stopped corresponding point shown 
variable instances bf point clauses variable instances bf amp li planes point clauses 
version limits number clauses instances solved 
ran instances clauses 
see dramatic differences performance maxsatz rest solvers 
hardest instances maxsatz orders magnitude faster second best performing solvers 
instances maxsatz needs second solve instance solvers toolbar able solve instances seconds 
second experiment solved random max sat instances random max sat instances 
results obtained shown 
consider agn solve max sat instances 
solved instances variables number clauses ranged variables variables variables 
variables amp point clauses bf slow 
variables compared best solvers 
observe dramatic differences performance profile maxsatz rest solvers 
particularly remarkable differences maxsatz toolbar second best performing solver max sat see maxsatz times faster toolbar hardest instances 
third experiment considered max cut problem graphs vertices number edges ranging 
shows results obtained 
bf point edges 
solved instances edges clauses 
observe maxsatz superior rest solvers 
fourth experiment considered coloring problem graphs vertices density edges ranging 
agn considered solve max sat instances 
vertices compared best solvers different version limiting number clauses instance solved 
shows comparative results different solvers 
maxsatz best performing solver substantially better rest solvers 
time log scale max cut nodes bf amp agn lazy toolbar maxsatz number edges experimental results max cut time log scale time log scale time log scale new inference rules max sat max sat variables number clauses max sat variables bf amp agn lazy toolbar maxsatz bf amp agn lazy toolbar maxsatz number clauses max sat variables number clauses bf amp agn lazy toolbar maxsatz experimental results variable variable variable random max sat instances 
time log scale time log scale time log scale li planes max sat variables number clauses max sat variables bf amp lazy toolbar maxsatz amp lazy toolbar maxsatz number clauses max sat variables number clauses toolbar maxsatz experimental results variable variable variable random max sat instances 
time log scale time log scale new inference rules max sat graph coloring nodes bf amp lazy toolbar maxsatz edges graph coloring nodes maxsatz edges experimental results graph coloring fifth experiment compared max sat solvers benchmarks submitted max sat evaluation 
solvers ran conditions evaluation 
table column name benchmark set second column number instances set rest columns display average time seconds needed solver solve instance time limit minutes number instances solved time limit brackets 
dash means corresponding solver solve set instances 
clear maxsatz best performing solver sets 

related simplest method compute lower bound consists just counting number clauses unsatisfied current partial assignment borchers 
step forward incorporate underestimation number clauses unsatisfied current partial assignment extended complete assignment 
basic method defined wallace freuder li planes set name instances bf amp agn toolbar lazy maxsatz maxcut brock maxcut fat maxcut hamming maxcut johnson maxcut keller maxcut dimacs hat maxcut san maxcut maxcut max cut maxcut ramsey ram max sat vars max sat vars max sat vars max sat discarded max sat vars max sat vars table experimental results benchmarks max sat evaluation 
new inference rules max sat lb occurs min ic ic cnf formula associated current partial assignment ic ic inconsistency count number unit clauses contain 
underestimation lower bound improved applying binary clauses directional arc consistency dac count defined wallace max csp 
dac count value variable number variables inconsistent value example contains clauses value inconsistent note value inconsistent inconsistencies disjoint summed 
wallace defined direction inconsistency value counted 
defining direction pair variables sharing constraint computes dac count values checking variables direction defined 
underestimation considering dac count wallace follows occurs min ic ic min dac dac dac dac dac count value wallace statically defined directions dac dac computed preprocessing step need recomputed search 
improved larrosa meseguer schiex introducing reversible dac searches better directions obtain better lower bound node search tree 
improvement dac counts additional incorporation inconsistencies contributed disjoint subsets variables particular variable partitions larrosa meseguer 
inconsistent dac counts deal unit binary clauses 
lower bounds dealing longer clauses include star rule shen zhang li 
star rule underestimation lower bound number disjoint inconsistent subformulas form lk lk 
star rule equivalent inconsistency counts wallace freuder 
subsumes inconsistent count method unit clauses star rule 
effectiveness producing lower bound illustrated example cnf formula containing clauses 
easily detects inconsistent subset clauses variables time linear size formula 
note subset detected lower bounds described variable partition approach larrosa meseguer case variables partition 
mention lower bound computation methods 
called lb defined shen zhang 
similar restricted max sat instances static variable ordering 
linear programming defined xing zhang 

suggested arc consistency unit propagation detect disjoint inconsistent subsets constraints weighted constraint networks 
li planes best knowledge idea incorporated lower bound computation method implemented constraint programming community 
lower bound computation method dramatic impact performance max sat solver 
approach speed max sat solver consists applying inference rules transform max sat instance equivalent simpler max sat instance inference rules proven useful practice include pure literal rule xing zhang li zhang ii dominating unit clause rule proposed niedermeier applied solvers xing zhang li iii common clause rule proposed bansal raman restated rule 
rule extended weighted max sat 
called neighborhood resolution larrosa heras preprocessing technique 
shen zhang li 
iv complementary unit clause rule niedermeier restated rule coefficient determining unit propagation rule xing zhang integer programming 
inference rules simplify max sat formula allow improve lower bound computation transform max sat formula simpler equivalent formula containing empty clauses 
soundness fact transform formula equivalent proved ways including checking possible variable assignments ii integer programming done section iii soft local consistency techniques defined weighted constraint networks max sat defined subcase variables boolean unit costs 
soft local consistency techniques basic equivalence preserving transformations called projection extension schiex cooper schiex :10.1.1.37.2325
max sat instance projection replaces binary clauses unit clause rule 
extension inverse operation projection replaces unit clause binary clauses selected variable projection operation straightforward sat max sat instance extension operation ingenious 
see note rule proved applied extension followed projection lemma proved extension followed projection extension operation unguided way may cancel previous projection 
way guide define ordering variables new inference rules max sat enforce directional arc consistency cooper cooper schiex :10.1.1.37.2325
directional arc consistency allows concentrate weights variables shifting weights earlier variables ones ordering 
example variable ordering extend unit clause extend unit clause allowing unit clauses concentrated variable 
define variable ordering efficiently exploit possible power soft arc consistency techniques lower bound computation remains open problem 
approach inference rules max sat need predefined ordering variables rule applications combining projection extension operations entirely guided unit propagation 
projection extension operations extended constraints involving variables achieve high order consistency cooper 
max sat instance extended projection extension operations stated rule 
formulas rule replacing projection extension 
unit clause variables extension unit clause set variables done follows replacing rule proved applied extending clauses ternary clauses variables applying projection operation obtain 
larrosa 
logical approach independently parallel defined implemented chain resolution rule cycle resolution rule weighted max sat 
rules extensions rules res res independently parallel heras larrosa 
chain resolution stated follows li li ui lk uk li mi mi li li ui mi li li mi lk uk mk mk ui weight corresponding clause mi min ui variables literals different 
weight mandatory clause denoted subtraction extended ui 
chain resolution rule equivalent rule applied unweighted max sat 
main difference chain resolution rule weighted version rule section chain resolution shifts part weight unit clause mk derived weighted version rule create unit clauses li mi mi mk 
cycle resolution rule stated follows li li ui lk uk li planes li mi mi li li ui mi li li mi li li mi lk uk mk mk subset binary clauses cyclic structure cycle resolution rule allows derive unit clause 
note detection cyclic structure appears timeconsuming applied node search tree new ternary clauses inserted 
larrosa apply cycle resolution rule practice case similar rule applied unweighted max sat 
cycle resolution rule applied unweighted max sat replace rule rule maxsatz differences compared rule rule application rule rule entirely inconsistent subformulas detected unit propagation 
detection applicability rule rule easy low overhead inconsistent subformulas detected maxsatz compute lower bound rule rule 
application rule rule allows increment lower bound 
cycle resolution rule needs extra detection cyclic structure allows derive unit clause cyclic structure 
derived unit clause unit propagation possibly allow detect inconsistent subformula increase lower bound 
interesting research topic implement cycle resolution rule maxsat maxsatz rule rule evaluate overhead detecting cyclic structure usefulness unit clauses ternary clauses derived cycle resolution rule compare implemented solver maxsatz 
interesting compare chain resolution rule cycle resolution rule weighted inference rules section 
general max sat resolution rule clausal form defined larrosa heras 
independently bonet 
heras larrosa defined version rule clausal form 
bonet 
proved rule complete max sat 
ans 
shown max sat resolution valued cnf formulas provides logical framework global local consistency properties defined 

main drawbacks state art max sat solvers lack suitable inference techniques allow detect contradictions possible simplify formula node search tree 
existing approaches put emphasis computing quality problem new inference rules max sat contradictions computed 
furthermore turns currently best performing consisting detecting disjoint inconsistent subsets clauses cnf formula unit propagation conservative 
computation lowers incremental improve underestimation defined number original inference rules max sat derived contradictions unit propagation transform max sat instance equivalent max sat instance easier solve 
rules carefully selected account applied efficiently 
rules contradiction detection particularly useful hard max sat instances containing contradictions 
aim finding powerful inference rules practice developed new max sat solver called maxsatz incorporates rules performed experimental investigation 
results comparing maxsatz inference rules maxsatz inference rules provide empirical evidence usefulness rules making lower bound computation incremental improving quality lower bounds 
results comparing maxsatz large selection solvers available time submitting provide empirical evidence maxsatz instances solved faster solvers 
observed gains orders magnitude hardest instances 
interestingly benchmarks second best solver generally different max sat toolbar max sat max cut graph coloring 
maxsatz robust rest solvers 
worth mentioning maxsatz enhanced lower bound failed literal detection li best performing solver unweighted max sat instances max sat evaluation 
second third best performing solvers respectively improved versions toolbar lazy plan study orderings unit clauses unit propagation maximize application inference rules define new inference rules ternary clauses 
extending results weighted max sat suitable modeling problems maximum clique set covering combinatorial auctions constraint satisfaction problems hard instances model rb xu xu li 
adapting results partial max sat solvers developed 
acknowledgments research partially supported projects tin tin funded de ciencia 
author partially supported national program china cb 
second author supported ram 
referees detailed comments suggestions 

see www iiia csic es maxsat details 
note results max sat evaluation compared results obtained cluster conditions 
li planes niedermeier 

faster exact algorithms hard problems parameterized point view 
discrete mathematics 
planes 

improved branch bound algorithms max sat weighted max sat 
proceedings conference artificial intelligence spain vol 
frontiers artificial intelligence applications pp 

ios press 
planes 

improved branch bound algorithms max sat 
proceedings th international conference theory applications satisfiability testing sat italy pp 

planes 

max sat solver lazy data structures 
proceedings th american conference artificial intelligence lncs pp 

springer 
planes 

improved exact solver weighted max sat 
proceedings th international conference theory applications satisfiability testing sat st andrews scotland lncs pp 

springer 
ans bonet levy 

inference rules high order consistency weighted csp 
proceedings nd national conference artificial intelligence aaai vancouver canada pp 

aaai press 
ans bonet levy 

logic weighted csp 
proceedings th international joint conference artificial intelligence ijcai india pp 

aaai press 


solving constrained problems sat technology 
proceedings th international conference theory applications satisfiability testing sat st andrews scotland lncs pp 

springer 


exact max sat solvers constrained problems 
journal heuristics 


partial max sat solvers clause learning 
proceedings th international conference theory applications satisfiability testing sat lisbon portugal lncs pp 

springer 
bansal raman 

upper bounds maxsat improved 
proceedings th international symposium algorithms computation isaac india lncs pp 

springer 
beame kautz 

understanding power clause learning 
proceedings th international joint conference artificial intelligence ijcai acapulco pp 

morgan kaufman 
bonet levy 

complete calculus max sat 
proceedings th international conference theory applications satisfiability testing sat seattle usa lncs pp 

springer 
new inference rules max sat bonet levy 

resolution max sat 
artificial intelligence 
borchers 

phase exact algorithm max sat weighted max sat problems 
journal combinatorial optimization 
hammer 

pseudo boolean optimization 
discrete applied mathematics 
cooper 

reduction operations fuzzy valued constraint satisfaction 
fuzzy sets systems 
cooper 

high order consistency valued constraint satisfaction 
constraints 
cooper schiex 

arc consistency soft constraints 
artificial intelligence 
cormen leiserson rivest stein 

algorithms second edition 
mit press 
davis logemann loveland 

machine program theorem proving 
communications acm 
davis putnam 

computing procedure quantification theory 
journal acm 
de larrosa meseguer schiex 

solving max sat weighted csp 
proceedings th international conference principles practice constraint programming cp ireland lncs pp 

springer 
de heras larrosa 

existential arc consistency getting closer full arc consistency weighted csps 
proceedings th international joint conference artificial intelligence ijcai edinburgh scotland pp 

freeman 

improvements propositional satisfiability search algorithms 
ph thesis department computer information science university pennsylvania pa usa 
goldberg 

fast robust sat solver 
proceedings design automation test europe date paris france pp 

ieee computer society 
heras larrosa 

new inference rules efficient max sat solving 
proceedings st national conference artificial intelligence aaai boston usa 
aaai press 
huang jin 

solar learning human algorithm solving sat 
science china series 
jeroslow wang 

solving propositional satisfiability problems 
annals mathematics artificial intelligence 
li planes larrosa heras 

resolution max sat relation local consistency weighted csps 
proceedings th international joint conference artificial intelligence ijcai edinburgh scotland pp 

morgan kaufmann 
larrosa heras de 

logical approach efficient max sat solving 
artificial intelligence press 
larrosa meseguer 

partition lower bound max csp 
constraints 
larrosa meseguer schiex 

maintaining reversible dac max csp 
artificial intelligence 
li 

constraint approach narrow search trees satisfiability 
information processing letters 
li anbulagan 
heuristics unit propagation satisfiability problems 
proceedings th international joint conference artificial intelligence ijcai nagoya japan pp 

morgan kaufmann 
li anbulagan 
look ahead versus look back satisfiability problems 
proceedings rd international conference principles constraint programming cp linz austria lncs pp 

springer 
li huang 

diversification determinism local search satisfiability 
proceedings th international conference theory applications satisfiability testing sat st andrews scotland lncs pp 

springer 
li planes 

exploiting unit propagation compute lower bounds branch bound max sat solvers 
proceedings th international conference principles practice constraint programming cp spain lncs pp 

springer 
li planes 

detecting disjoint inconsistent subformulas computing lower bounds max sat 
proceedings st national conference artificial intelligence aaai boston usa pp 

aaai press 
marques silva sakallah 

grasp search algorithm propositional satisfiability 
ieee transactions computers 
niedermeier 

new upper bounds maximum satisfiability 
journal algorithms 
gin petit bessi re puget 

new lower bounds constraint violations constrained problems 
th international conference principles practice constraint programming cp cyprus lncs pp 

springer 
schiex 

arc consistency soft constraints 
proceedings th international conference principles constraint programming cp singapore lncs pp 

springer 
new inference rules max sat shen zhang 

study lower bound functions max sat 
proceedings national conference artificial intelligence aaai san jose usa pp 

aaai press 
shen zhang 

improving exact algorithms max sat 
annals mathematics artificial intelligence 
wallace 

directed arc consistency preprocessing 
constraint processing selected papers lncs pp 

springer 
wallace freuder 

comparative studies constraint satisfaction davis putnam algorithms maximum satisfiability problems 
johnson trick 
eds cliques coloring satisfiability vol 
pp 

american mathematical society 
xing zhang 

efficient strategies weighted maximum satisfiability 
proceedings th international conference principles practice constraint programming cp toronto canada lncs pp 

springer 
xing zhang 

efficient exact algorithm weighted maximum satisfiability 
artificial intelligence 
xu 

simple model generate hard satisfiable instances 
proceedings th international joint conference artificial intelligence ijcai edinburgh scotland pp 

xu li 

hard examples exact phase transitions 
theoretical computer science 
zhang 

sato efficient propositional prover 
proceedings conference automated deduction cade pp 

zhang shen 

exact algorithms max sat 
electronic notes theoretical computer science 
zhang madigan moskewicz malik 

efficient conflict driven learning boolean satisfiability solver 
international conference computer aided design iccad san jose usa pp 


