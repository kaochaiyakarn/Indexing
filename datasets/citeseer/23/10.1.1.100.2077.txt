knowledge compilation theory approximation henry kautz bart selman ai principles research department bell laboratories murray hill nj selman kautz research att com computational efficiency central concern design knowledge representation systems 
order obtain efficient systems suggested limit form statements knowledge base incomplete inference mechanism 
approach restrictive practical applications leads uncertainty exactly inferred knowledge base 
third alternative knowledge general representation language translated compiled tractable form allowing efficient subsequent query answering 
show propositional logical theories compiled horn theories approximate original information 
approximations bound original theory terms logical strength 
procedures extended tractable languages example binary clauses order case 
demonstrate generality approach compiling concept descriptions general language tractable form 
journal acm 
study computational properties knowledge representation systems revealed direct trade tractability expressiveness levesque brachman 
general order obtain computationally efficient representation system restricts expressive power knowledge representation language uses incomplete inference mechanism 
approach representation language limited practical applications doyle patil 
second approach involves reasoning non traditional semantics 
reasoning inference limited bounding number inference steps performed inference procedure 
difficult characterize exactly inferred approach lacks real semantics simply mimic proof theory 
information provided proof time bound 
see horvitz example probabilistic inference confidence results increases amount computation 
accounts limited inference non traditional semantics levesque frisch patel schneider provide weak kind inference 
example valued semantics approach levesque statements infer presents third alternative obtaining efficient representation systems limits expressive power representation language gives completeness inference procedure 
new approach user enters statements general unrestricted representation language system compiles restricted language allows efficient inference 
exact translation tractable form impossible system searches best approximation original information 
describe approximation speed inference 
refer approach knowledge compilation 
illustrate method studying approximation propositional logic theories horn theories 
applications propositional inference arise areas artificial intelligence computer science general 
examples include qualitative reasoning physical systems reiter de kleer circuit diagnosis expert systems dean learning theory valiant 
addition reasoning tasks directly mapped propositional inference problems finite domain constraint satisfaction problems csp dechter certain classes planning problems kautz selman 
note order domain theories artificial intelligence involve finite domains 
theories essentially propositional 
example reiter mackworth discuss order domain theory visual interpretation restated propositional form 
considering propositional formulation show methods relational databases answer queries efficiently general order theorem prover original domain theory 
example propositional formulation planning cited 
general propositional reasoning prototypical np complete task 
inference horn approximations fast linear time 
formal definition horn approximation algorithms generating approximations 
algorithms property interrupted time produce useful intermediate result 
empirical evaluation approach demonstrate substantial computational savings computationally challenging propositional theories 
concludes discussion extensions order theories various generalizations horn approximations description logics 
preliminary discussion ideas appeared selman kautz kautz selman 
propositional horn approximations section introduce idea knowledge compilation concrete example 
show propositional theory compiled tractable form consisting set horn clauses 
definitions assume standard propositional language denote propositional letters denote literals literal propositional letter called positive literal negation called negative literal 
clause disjunction literals represented set literals contains 
clause horn contains positive literal set clauses called horn theory 
formulas conjunctive normal form cnf conjunction disjuncts represented set clauses 
cnf notation clausal notation interchangeably 
example may write vice versa 
sets models bound original set models original theory 
models represented dots 
bounds represented set horn clauses 
general determining cnf formula query follows set formulas knowledge base intractable cook 
knowledge base contains horn clauses problem solved time linear length knowledge base combined query dowling gallier 
useful kind knowledge compilation set arbitrary clauses compute logically equivalent set horn clauses base subsequent inference set 
unfortunately exist logically equivalent horn theory 
example horn theory equivalent theory propose approximate original set clauses set horn clauses 
basic idea bound set models satisfying truth assignments original theory horn theories 
fig 
illustrates basic idea 
definition ments theory denotes set satisfying truth assign definition horn lower bound horn upper bound set clauses 
sets horn clauses respectively horn lower bound horn upper bound iff equivalently note bounds defined terms models lower bounds fewer models original theory upper bound models 
reader cautioned associate lower logically weaker fact lower bound fewer models logically stronger implies original theory 
similarly upper bound models logically weaker implied original theory 
simply pair bounds characterize initial theory wish best possible ones greatest horn lower bound horn upper bound 
definition greatest horn lower bound glb set clauses 
set horn clauses greatest horn lowerbound iff set horn clauses definition horn upper bound lub set clauses 
set horn clauses horn upperbound iff set horn clauses call bounds horn approximations original theory defi nition horn upper bound implies conjunction bounds possibly smaller upper bound 
follows theory unique term horn approximation refer horn upper lower bound necessarily lub glb 
lub logical equivalence 
hand theory different glbs 
example consider non horn theory horn theory example horn lower bound glbs example horn upper bound lub 
reader verify bounds noting horn theory logically distinct similar properties hold glb lub 
approximations fast inference discuss compute horn approximations consider approximations improve efficiency knowledge representation system 
suppose knowledge base kb contains set clauses want determine formula implied kb 
assume cnf determine linear time propositional cnf formula follows horn theory 
note query need horn 
system proceed shown fig 

tries obtain answer quickly horn approximations 
returns returns far procedure takes time linear length approximations case answer obtained system simply return don know decide spend time general inference procedure determine answer directly original theory 
general inference procedure approximations prune search space 
system answer certain queries linear time resulting improvement response time 
exactly queries handled directly horn approximations depends bounds characterize original theory 
return issue section 
note give soundness completeness fall back original theory 
system opts returning don know performing general inference original theory example trading accuracy assume lengths horn approximations roughly original theory 
return issue 
fast querying theory approximation 
original theory approximations query 
speed 
approach may quite useful real time systems fall back mechanism dealing don know answers 
example expensive answer query inference robot may try determine answer sensing 
concentrates compiling knowledge base queries 
greiner greiner schuurmans extend framework providing compilation algorithms interleave compilation query answering 
interesting direction research allow updates knowledge base queries 
computing horn approximations turn problem generating horn approximations 
exist polynomial time procedure generating approximations provided np 
consequence theorem 
theorem set clauses 
glb consistent iff tent 
similarly lub consistent iff consistent 
consis proof inconsistent horn theory glb lub consistent satisfying truth assignment definition satisfying assignment horn upper bound 
theory satisfying truth assignment better larger horn lower bound unsatisfiable inconsistent horn theory 
lub glb consistent satisfying truth assignment 
length horn approximations bounded polynomial function length task finding np hard checking consistency general set clauses np complete checking consistency horn clauses takes linear time 
hand certain approximations exponential length certainly takes exponential time generate 
case problem intractable 
course approximations polynomial time computable approximations example inconsistency go undetected query time save polynomial amount time exponentially hard problem 
computing horn approximations viewed compilation process 
computational cost amortized total set subsequent queries kb 
cases approximations may needed query answering compilation process finishes 
waiting best horn bounds desirable employ procedures output lower upper bounds intermediate results generating better better bounds time 
approximation algorithms anytime procedures boddy dean 
algorithms property 
discuss method generating glb 
notion central approach definition horn strengthening horn clause horn strengthening clause iff horn clause horn strengthening set clauses set clauses horn strengthening non horn clause formed removing positive literal 
example consider clause clauses horn strengthenings lemmas state useful properties horn strengthenings 
lemma shows horn theory entails clause entails horn strengthening clause 
lemma horn theory clause tautology 
clause horn strengthening generally horn theory entails set clauses entails horn strengthening set 
proof subsumption theorem lee clause follows horn horn 
horn strengthening resolution subsumes resolvent horn clauses generalization sets clauses follows immediately 
lemma shows glb theory equivalent theory 
generate glb input set clauses output greatest horn lower bound lexicographically horn strengthening loop lexicographically horn strengthening exists exit loop loop remove subsumed clauses return algorithm generating greatest horn lower bound 
lemma glb theory set clauses horn lemma exists proof definition glb horn strengthening greatest lower bound case difficult see horn strengthening horn lower bound necessarily greatest lower bound 
leads generate glb algorithm fig 

algorithm systematically searches various possible horn strengthenings clauses original theory looking general 
th horn strengthening clause horn strengthenings generated lexicographic order theorem set clauses generate glb fig 
computes greatest horn lower bound length equal example consider theory horn strengthening algorithm tries set algorithm proceeds 
horn strengthenings improve bound algorithm returns answer redundant clause algorithm 
removed step proof theorem ignoring step removes subsumed clauses obvious generate glb returns logically weakest horn strengthening prove algorithm correct need show logically weakest horn strengthening glb note horn lb 
suppose greatest lb 
set horn clauses lemma horn strengthening means cases logically equivalent 
means logically equivalent contradiction 
logically distinct 
logically weakest horn strengthening contradiction 
proves theorem 
generate glb anytime algorithm represents lower bound algorithm interrupted 
note total running time algorithm exponential length non horn part original theory strengthening horn clause clause 
querying algorithm shown fig 
uses single glb theory 
extend algorithm lower bounds necessarily certain theories exponentially distinct glbs 
simple interesting relationship theory set glbs 
follows fact model theory corresponds lower bound theory conjunction literals assigned true model 
obtain theorem theorem set clauses 
logically equivalent disjunction greatest horn lower bounds turn attention generation lub 
notion prime implicate theory strongest clause implied theory 
theorem reveals basic strategy 
theorem set clauses 
lub set horn prime implicates logically equivalent proof set horn prime implicates implied horn upper bound 
furthermore lub clauses subsumes implies clause horn upper bound 
principle resolution generate prime implicates simply collect horn ones order generate horn upper bound 
method prove expensive original theory contains horn clauses exponentially horn resolvents example see selman 
clearly resolvents add best approximation original horn theory horn upper bound theory 
fortunately improve procedure generating prime implicates resolving clauses non horn 
intuition improvement resolution proof tree ends horn clause rewritten resolutions pairs horn clauses appear bottom tree 
compilation phase essentially generates top part tree horn part generated query answering time 
full inductive proof method complete provided del val generate glb algorithm anytime improves time 
theorem set clauses horn upper bound generate lub algorithm fig 
com follows directly lub complete respect horn queries 
horn clause input set clauses generate lub set horn clauses set non horn clauses 
output horn upper bound loop try choose clause resolve subsumed clause choice possible exit loop delete clauses subsumed horn loop return algorithm generating horn upper bound 
example consider theory lub algorithm resolves third clause obtaining clause loop exited returned 
computational savings section described bounds answer queries claimed doing lead computational savings 
wonder case queries answered bounds easy answer original theory 
central aspect approach 
obvious counterexample inconsistent theory 
compilation yields inconsistent upper bound 
query bound quickly return see fig 

evaluating query original theory general involve proving theory inconsistent np complete 
course interesting knowledge bases consistent 
consider consistent theory equivalent horn theory horn form 
clearly queries answered efficiently bounds 
case theorem prover answer queries efficiently original theory 
shown result valiant vazirani show propositional theory single model trivially equivalent horn theory finding model intractable np rp 
exist theorem prover efficiently handles special case prover find unique model non horn theory repeatedly testing literal followed theory 
fact bounds obtained method answer queries efficiently intractable test original theory key feature distinguishes related reasoning approximations related discussed section 
natural application framework domains fast response queries highest importance 
direct practical evidence de kleer qualitative physics 
de kleer uses assumption truth maintenance system atms kind propositional theorem prover reason logical theories qualitative physics 
main form inference atms called boolean constraint propagation bcp 
bcp sound complete horn clauses incomplete general theories 
order bcp useful system preprocesses theory limited form resolution 
example clauses add resolvent additional clause allow bcp derive additional information 
bcp effect ignores non horn clauses process viewed computing form horn upper bound approximation original theory 
de kleer approach concrete example practical usefulness limited form knowledge compilation 
order gain insight practical usefulness knowledge compilation consider compilation hard randomly generated propositional theories 
mitchell selman levesque show randomly generated theories easy reason 
theories tend constrained constrained case experiments show answering queries easy standard davis putnam procedure davis putnam 
mitchell described randomly generate computationally challenging theories 
key generate formulas particular ratio clauses variables 
random cnf formulas ratio 
consider hard random cnf theories containing variables 
order simplify analysis computed bounds consisted conjunctions unit clauses 
note unit clauses restricted case horn clauses 
bounds tight full horn bounds 
show bounds useful answering high percentage queries 
full horn bounds tighter answer higher percentage queries 
considering unit clause bounds able provide simple exact analysis 
began generating set random cnf theories variables 
computed unit lub unit de kleer discusses possibility replacing entire theory set prime implicates 
may useful abductive reasoning reiter de kleer selman levesque necessary deductive reasoning horn clauses allow efficient inference 
note generating prime implicates may require exponential space 
theory constrained generally unsatisfiable queries trivially follow 
constrained cnf query contains short disjunctions query certainly follow 
theory constrained cnf query contains long disjunctions query certainly follow easily shown adding negation query theory davis putnam procedure unit propagation show inconsistency 
vars clauses size unit size unit percent queries answered lub glb unit binary ternary table size bounds percentage random queries answered unit bounds hard random cnf theories 
size unit lub unit glb determined empirically 
table gives median values random theories size 
percentage random queries answered bounds computed probabilistically described text 
glb 
table gives average size literals lub glb size theory 
computed unit upper bound version generate lub algorithm restricted output unit clauses 
generate glb similar adapted unit bounds particular strengthening theory taken satisfying model theory fast randomized satisfiability procedure selman 
computation time unit lubs ranged minutes variable theories hour variable theories mhz sgi challenge 
computation unit glbs ranged minute minutes 
percentage queries answered bounds computed basic probability theory 
assume dealing single clause queries drawn uniform fixed clause length distribution 
case unit clause queries 
unit clause queries answered unit lub bound complete queries 
column size theory 
consider interesting case binary queries 
random binary clause distinct complements 
wish compute probability bounds answer query unit lub size unit glb size variables theory 
wish compute equals possibilities disjoint 
disjunction entailed set literals disjuncts entailed 
note able step considering unit bounds full horn bounds 
quantity equal second terms equal odds picking random literal lub third term equal number ways choosing distinct literals lub divided number ways choosing distinct non complementary literals consider probability binary query answered glb 
final term calculated argument lub yield combining probability lub answers query probability glb answers query results expression value expression complete binary column table 
vars clauses bounds tableau tableau binary ternary binary ternary table time seconds answer random queries bounds program tableau version davis putnam algorithm versus tableau 
experiments run mz sgi challenge workstation 
probability bounds answer random ternary query similarly derived complete final column table 
noted similar analysis performed horn bounds complicated probability horn theory entails disjunction probability entails disjuncts 
see table percentage queries handled simple unit clause bounds quite high 
note queries handled bounds answered linear time 
davis putnam procedure scales exponentially queries considered table follows experiments mitchell 
suggests knowledge compilation randomly generated theories clear payoff 
verified computational savings suggested preceding analysis implementing fast querying algorithm shown fig 
testing random binary random ternary queries test theories 
case bounds failed answer query tested original theory efficient implementation davis putnam procedure called tableau 
table lists average time run batch queries bounds tableau versus tableau 
cases queries answered 
see knowledge compilation reduced davis putnam procedure currently fastest known complete procedure propositional satisfiability testing theorem proving class formulas considered buro ning dubois 
tableau crawford auton fastest implementations algorithm 
time orders magnitude largest theories 
eliminates remote possibility bounds answering easy queries 
earlier invoked complexity theory argue general bounds limited easy queries experiments verify bounds answer hard queries computationally interesting distribution random theories 
aside observe take account time required compile theories obtain time savings 
example variable theories computing bounds takes hour minutes total time compute bounds answer binary queries seconds versus seconds bounds 
note difference time increase consider example queries 
case gone stated goal shifting computational effort line line reduced total amount required 
positive results random theories quite surprising expect apparent lack structure hard approximate simpler theories 
understanding costs benefits knowledge compilation approach come application techniques various real world problems 
note practice may satisfied upper lower bounds necessarily optimal cheaper compute 
greiner gives compilation algorithms answering queries non optimal bounds gradually improve run time depending particular query distribution 
size approximations size approximations clearly important issue 
ideally approximations roughly size original theory 
approximations larger may lose potential computational advantage 
example bound exponentially larger original theory evaluating query linear time bound expensive original theory 
generate glb algorithm follows immediately size generated bound equal original theory 
system cadoli building original knowledge compilation selman kautz shown computing glb complexity class 
problems safely bound approximation provide answer particular query linear amount time terms length original theory wasted lub behaved 
show theories exponentially long upper bounds 
bounds shrunk size original theory introducing new letters vocabulary 
new letters viewed useful abbreviations repeated structure theory 
prove unfortunately shrink lub introducing new letters 
cases system limit length approximation weaker bound 
discuss kinds weaker bounds section see greiner schuurmans example 
explosion lub theory lub exponentially clauses 
clauses theory interpreted rules deciding cognitive scientist 
clauses numbered ease 
phil psych cogsci cogsci phil cogsci psych cogsci clause states sufficient condition cognitive scientist computer scientist philosopher psychologist 
remaining clauses deduce person profession reading habits 
clause states person reads papers written mccarthy person computer scientist cognitive scientist possibly 
similarly reader dennett philosopher cognitive scientist reader kosslyn psychologist cognitive scientist 
reasoning theory quite complicated 
example reasoning cases prove computer scientist reads dennett solved polynomial time deterministic turing machine access np oracle 
see garey johnson johnson 
means computing glb slightly harder answering single query best known algorithms problems singly exponential johnson 
note positive result feared worst case doubly exponential amount needed compute bound potentially handle exponential number queries efficiently 
kosslyn cognitive scientist 
general non horn form theories finding proof take time exponential length theory provided np 
clause resolved subsets clauses yield different horn clauses phil cogsci fact lub theory equivalent set psych cogsci cogsci phil psych horn clauses furthermore prove smaller set clauses equivalent 
note stronger condition simply saying redundant clauses asserting way represent information space clausal form 
example generalized increasing number propositions appear left hand side clause adding clause general form new proposition 
size lub grows exponentially 
general theorem 
theorem exist clausal theories size smallest clausal representation lub size proof appears appendix 
tell clause follows lub time linear size lub explosion size lub example savings 
course commonsense theories exponential blowup occur 
shrinking lub syntactic form theory modified changing basic meaning 
example theory represented set clauses containing literals cnf form introducing new propositional letters 
old new theories equivalent new uses expanded vocabulary essentially entail entail formula contain new letters 
wonder large lub represented small set horn clauses basically meaning actual logical equivalence 
case cnf formulas technique depends new propositional letters 
modify definition lub add new letters source theory 
take meaning letter concept see method reduces definition new concepts generalize concepts original theory 
example modify theory clauses introducing new concepts computer science buff philosophy buff psychology buff 
generalizes concepts computer scientist reader papers mccarthy 
similarly second generalizes philosopher reader dennett third generalizes psychologist reader kosslyn 
concept definition requires clauses assert general concept divided subconcepts assert subconcepts part concept 
added clauses phil phil psych psych lub augmented theory containing clauses represented just horn clauses new concept definitions single clause cogsci total size lub counting occurrences literals half size lub unmodified theory 
generalize example adding new propositions size lub grows opposed furthermore added clauses increase size source theory linear amount 
returning example concerning computer scientist reads dennett kosslyn infer quickly person computer science buff philosophy buff psychology buff cognitive scientist 
note inference computed time linear size new lub linear size original theory 
teaching system new concept definitions size new source theory grows slightly lub shrinks approximately size source theory 
kautz selman discuss strategy automatically deriving learning new concept letters shrink original bound 
call theory compaction 
flavor approach similar additional letters extended resolution tseitin 
see muggleton buntine related approach learning new generalizations inverting resolution proofs 
compact representation lub exist 
far shown naive representation theory lub require exponential amount space cases clever representation new propositional letters requires polynomial amount space 
question general results 
possible produce compact tractable representation lub 
unfortunately theorem shows 
theorem np non uniform case horn upper bound propositional clausal theory represented data structure allows queries form answered time single horn clause 
note despite fact allow arbitrary amount performed computing data structure represent proof theorem appears appendix 
notion non uniform comes circuit complexity boppana sipser 
problem non uniform called poly iff integer exists circuit complexity size polynomial solves instances size adjective non uniform refers fact different circuits may required different values problem solved algorithm runs time circuit complexity talk polynomial time algorithms polynomial size circuits 
class non uniform considerably larger 
example non uniform contains non computable functions function returns inputs length iff turing number machine halts inputs 
circuit simply fixed return 
possible fact implicitly proof theorem polynomial time hierarchy collapse karp lipton 
shown appendix theorem strengthened say claim exists efficient form lub answering horn clausal queries equivalent claim np non uniform proof efficient representations exist major result complexity finite functions 
immediate corollary theorem polynomial hierarchy collapses manner compaction defining new propositions incomplete method shrinking lub 
np np non uniform considered 
consequence corollary np non uniform case compaction number new variables horn upper bound theory size polynomial follows theorem determine horn clause follows compaction horn time linear length compaction plus length query 
summarize theories horn lub represented short tractable form 
cases knowledge compilation rely shorter weaker upper bound 
way simply generating bounds point straightforward anytime nature compilation algorithms 
alternative generate called horn approximations horn theories literals clause dechter pearl 
limitation clause lengths theories polynomial size number variables 
discuss horn alternatives horn approximations section 
general framework central knowledge compilation proposal definition approximations terms subsets supersets set models original theory 
illustrated fig 

model theoretic definition leaves freedom terms choice representation language original theory approximations queries 
additional requirement queries evaluated efficiently respect approximations 
note view computation approximations line compilation process cost amortized set queries 
allowing substantial computational resources spend compilation approximations real practical significance shown section 
formally knowledge compilation system tuple containing components formal language 
identify language set sentences 
examples study usual meaning logical entailment framework allows represent relationships subsumption 
consequence relation sets sentences source sublanguage edge base 
express general knowl target sublanguage express approximations general knowledge base 
easier sense analytically empirically determine query consequence set sentences set sentences query sublanguage function models particular anytime lower bound algorithm mapping source theory time bound best lower bound computed steps 
formally definition glb similar upper bound function lub suppose knowledge compilation system query performing compilation steps source theory system described earlier system answers answers unknown 
definite answer agrees answer question lower upper bound greatest bound 
case knowledge compilation propositional horn clauses fits framework follows general propositional clausal languages restricted horn clauses propositional entailment 
case query language strictly expressive 
note answer general query consisting set clauses determine efficiently clauses implied horn approximation linear time algorithm testing satisfiability horn clauses 
functions model generate glb generate lub algorithms 
instances knowledge compilation restricted propositional clausal forms broad class propositional knowledge compilation systems realized generalizing algorithms horn case 
idea horn strengthening generalized follows definition strengthening particular class propositional clauses 
clause class called clause set clauses called theory 
clause strengthening clause iff clause knowledge compilation system created letting source language set general clauses target language restricted class clauses suppose closed resolution resolvent clauses clause clause strengthening 
see proof lemma generalizes horn clauses clauses theory entails clause entail strengthening furthermore greatest lower bound terms clauses theory equivalent logically weakest strengthening theory 
find glb searching space strengthenings 
theorem class propositional clauses resolvent clauses ii clause subsumed clause set clauses generate glb fig 
computes greatest lower bound length equal substituted horn algorithm 
consider problem generating upper bound clausal theory 
recall naive algorithm finding horn lub theory simply compute resolvents theory collect horn prime implicates set 
due resolution completeness theorem fact propositional horn clauses closed subsumption horn clause subsumed horn clause 
condition place general target language closed subsumption 
example class violates condition set definite horn clauses 
clauses contain exactly positive literal 
resolvent definite horn clauses definite horn clause 
definite horn clause example subsumed non definite horn clause example 
summarize observations generating lub theorem subsumes theorem class propositional clauses set clauses generate lub fig 
computes upper bound substituted horn algorithm selected 
useful clausal target languages meet conditions theorems 
include horn reverse horn clauses containing negative literal 
theorem due del val strengthens proposition kautz selman appeared earlier drafts 
binary clauses containing fewer literals 
satisfiability entailment determined linear time class 
note unit clauses empty clause included class 
unit clauses bounds consist conjunctions literals 
class specialization horn binary 
clauses containing set propositional letters 
class may better worst case complexity unrestricted language may empirically desirable compile away certain irrelevant propositions 
example clauses containing glb lub interesting tractable clausal target languages require significant modifications compilation algorithms 
important ones include horn fixed horn clauses containing fewer literals 
note reasoning horn theories takes linear time furthermore size horn approximations polynomial number variables 
way compute horn glb simply generate set horn clauses length initial inconsistent lower bound minimizing set striking clauses longer entails source theory 
similar brute force algorithm compute horn lub start set length clauses entailed source theory repeatedly shrink removing clauses entailed conjunction remaining clauses 
renamable horn class theories horn uniformly replacing subset variables negation 
class particular interest linear time unit propagation bcp complete wos lewis 
additional clausal target languages concentrated consider tractable non clausal target languages 
example subramanian genesereth formal system inferring certain propositions irrelevant computation class queries 
sense irrelevant knowledge compilation way simplify theory 
mcallester discuss logical language structure natural language identify fragment inference performed polynomial time 
interesting see ordinary order theories approximately compiled tractable fragment modeltheoretic notion approximation 
order theories consider application knowledge compilation order languages 
give brief description extend knowledge compilation techniques languages quantification details appear kautz selman forthcoming 
propositional case glbs lubs pair source target language exist finite number logically distinct theories constructed 
general order case best approximations may defined 
simple example order logic single predicate infinite set constant terms consist ground non quantified clauses 
theory infinite series better better ground clause lower bounds greatest lower bound 
notion glb defined order generalizations clausal languages considered 
fact clausal representations widely order languages 
order literal constructed usual way optionally negated predicate symbol applied sequence terms constructed function symbols constants variables 
order clause sentence prenex form containing universal quantifiers matrix disjunction literals 
order horn clause order clause matrix contains positive literal horn strengthening order clause corresponds horn strengthening matrix 
note order case clause finite number horn strengthenings 
reader may verify lemmas hold change order case 
supply generate glb fig 
oracle test clear set order clauses algorithm search finite set horn strengthenings return logically weakest argument proof theorem glb 
shows order horn glbs exist small 
difficulty generalizing notion glb restricted clausal target languages order case 
strengthening order clause generated eliminating literals clause matrix 
theorem goes 
straightforward apply notion lub order theories 
construct finite order clausal theories finite horn lub function symbols variables 
order horn lubs finitely representable 
aspects compiling order theories dealt 
particular investigating decidable possibly tractable approximations theories undecidable languages description logics section consider description logics family frame knowledge representation languages studied levesque brachman 
see donini 
levesque brachman consider language describe structured concepts terms concepts complex primitive 
example wished describe concept person male friends doctors specialty expression person restr friend male doctor specialty contains constructs capitalized terms language 
levesque brachman consider complexity determining con interesting connections may drawn research analysis prolog programs example optimization program specification 
example heintze jaffar describes construct recursive decidable approximation potentially non recursive logic program 
method computes lower bound logic program viewed logical theory general greatest lower bound 
cept subsumes 
example concept person friends doctors written person friend doctor subsumes 
central technical result deter mining subsumption intractable removing construct leads polynomial time computable subsumption 
restricted language called efficient subsumption language language may sufficiently expressive practical applications 
knowledge compilation provides alternative 
case idea take concept description language approximate concept descriptions best lower bound general specific concept best upper bound specific general subsuming concept example consider concept 
difficult see person friend doctor specialty examples respectively upper bound lower bound 
best bounds case 
knowledge representation system store bounds original concept description try determine quickly newly concept subsumes subsumed 
note application compute pair bounds concept single pair bounds entire knowledge base 
bounds subsumption queries kb updating kb adding new concept definitions 
cases system bounds determining appropriate place new concept hierarchy 
related upper bound approximation logically weaker original theory viewed generalization abstraction theory 
lowerbound approximation specialization logical strengthening original theory 
borgida etherington propose background knowledge captures hierarchical relationship predicates order replace disjunctions general concepts 
suppose background knowledge kb generate new kb contains simply horn upper bound original kb background knowledge 
note idea lub general borgida etherington approach applied arbitrary propositional horn theories just concept hierarchies positive disjunctions 
related borgida etherington imielinski proposes notion abstraction grouping individuals equivalence classes 
horn lower bound corresponds specific theory original 
generalizes counterexample prune search space inference procedures 
best known example counterexamples artificial intelligence early gelernter proving theorems geometry 
gelernter single model diagram original theory answer certain queries negatively fact query horn lower bound similar manner generally involve set models better characterization original theory 
particular may avoid accidental truths hold single model diagram 
horn lower bounds generalization levesque notion vivid representations levesque etherington 
allow fast inference vivid representation contains complete information reasoning cases 
levesque proposes replace knowledge base containing incomplete information complete vivid representation information 
representation generated abstractions filling details 
propositional case proposal comes replacing propositional theory models presumably prototypical models original theory 
queries evaluated directly respect model 
horn lower bound viewed relaxation completeness constraint picking single model collection models represented set horn clauses 
maintain computational advantage inference efficient horn bound 
artificial intelligence planning theorem proving abstraction plaisted maps theory smaller simpler theory generates proofs smaller theory uses proofs guide generation proofs original theory 
various mechanisms suggested creating abstractions eliminating operator preconditions sacerdoti finding symmetries search space employing explanation learning previously generated plans knoblock 
abstractions similar notion upper bound 
approaches differ introduce solution correspond concrete solution 
knoblock discuss various kinds abstractions preserve solution consistency properties 
crucial difference planning knowledge compilation framework concentrates solving single problem instances shifting computational effort line line 
restricted forms planning np hard gupta nau bylander erol 
best known planning algorithms run exponential time 
planning abstraction attempts lower exponent 
contrast aim knowledge compilation framework preprocess compile theory manner queries problem instances solved polynomial time 
motivation knowledge compilation approach similar universal plans schoppers form reactive planning agre chapman 
universal plan program logical circuit efficiently determines step plan leading initial state pre defined goal state 
step taken universal plan determines new state goal reached 
universal plans viewed attempt efficiently represent potentially exponential set plans just knowledge compilation aims creating representation efficiently answer potentially exponential set queries 
universal plans generally tries capture exactly original domain theory 
interesting explore question horn approximations domain knowledge create approximate universal plans ones may specify state 
cadoli schaerf generalize levesque implicit explicit belief levesque 
approximate inference process allowing sequence powerful inference relations 
time system evaluate query powerful inference relation 
allowing unrestricted amount time leads standard deductive reasoning 
important difference approach notion directly processing original theory obtain approximation 
means practice limited amount done query order obtain answer 
done query saved answering query 
framework cost run time querying shifted time compilation 
cost compilation process amortized potentially large set queries result compilation processing query 
dalal etherington provide general framework different forms approximations captured 
notion upper bound corresponds notion direct theory 
notion strengthening theory quite different roughly corresponds disjunction lower bounds theory 
introduce approximations queries theories framework need approximate queries saw earlier possible test arbitrary cnf queries horn theories linear time 
dalal etherington develop notion shifting computation effort query answering time line compilation phase algorithms compiling specific languages 
emphasis developing general framework describing mappings different vocabularies dealing specific issues computational complexity 
dechter pearl investigate horn approximations obtain efficient representations empirical data 
consider case original theory directly set models satisfying truth assign ments 
introduce weaker notion horn approximations called horn approximations horn clause contains literals 
see kautz discussion 
greiner schuurmans greiner adapted com algorithms ones search bounds optimal respect query distribution 
generation bounds interleaved query answering queries optimize bounds 
show done efficiently takes polynomial time 
introduced notion knowledge compilation 
basic idea compile knowledge intractable tractable form 
exact translation possible introduced approximate translations consisting bounds delimit original theory 
knowledge compilation provides alternative approaches force user state knowledge restricted tractable language 
representation system incorporating knowledge compilation procedure allow user enter information general unrestricted language system compiles tractable form 
illustrate approach showed knowledge represented propositional theory approximated horn theories called horn approximations greatest horn lower bound horn upper bound 
answering query original knowledge base intractable horn approximations certain queries answered time linear length approximations 
gave algorithms generating horn approximations 
algorithms operate incrementally generating better better approximations time 
incremental nature approximation algorithms key feature approach practical applications unacceptable wait system computed best bounds answering queries 
summary main features knowledge compilation approach guaranteed fast response queries answered directly approximations 
incremental line compilation process provides continuous improvement response time system 
empirical evaluation approach demonstrated substantial computational savings hard propositional theories 
showed procedures compiling propositional theories horn theories generalized apply tractable classes clauses 
classes characterized various closure conditions 
classes containing reverse horn clauses clauses fewer literals clauses containing certain set irrelevant letters examples classes satisfy closure conditions 
discussed compilation concept descriptions terminological representation language 
example showed knowledge compilation approach appears suited dealing variety knowledge representation languages traditional logics 
daniel bobrow getting think issue practical restricted tractable representation languages ray reiter pointing prime implicates 
hector levesque yoav shoham anonymous referees useful comments 
appendix proofs proof theorem consider theory form arbitrary 
see set horn clauses total length contains literals size lub prove set properties clauses resolve irredundant subset implies 
prove minimum size 
note minimum size stronger condition irredundant 
proof irredundant suppose clause clauses resolve completeness resolution subsumes impossible clauses equiva length 
prove smaller set clauses lent suppose clauses resolve means exists subsumes clause subsumed clause suppose clause subsumed different clause contradiction 
proper subset clause subsumed clause impossible saw irredundant 
smaller set clauses equivalent shorter proof theorem suppose representation lub existed 
show sat variables determined time 
choice arbitrary sat np complete problem mean np non uniform variables set main variables set auxiliary variables set literals constructed main variables variables negations 
source theory conjunction clauses note length idea construction sat clause variables constructed selecting subset clauses eliminating auxiliary variables 
suppose able compute representation horn lub property test horn queries polynomial time 
noted horn formula follows lub follows source theory 
suppose arbitrary cnf formula variables wish test satisfiability 
construct horn clause containing auxiliary variables including negative auxiliary variable corresponds clause example corresponding horn clause claim horn clause implied lub satisfiable 
suppose query implied lub 
follows clauses auxiliary variables query correspond equivalently unsatisfiable 
unsatisfiable 
note clause containing auxiliary variable eliminated clause satisfied model auxiliary variable assigned false instance variable appears formula 
case unsatisfiable 
auxiliary variables appear exactly negatively positively resolved away 
unsatisfiable 
note step previous section reversed go assumption unsatisfiable horn follows lub implies assumed test lub implies performed time length source theory plus length query 
source theory query polynomial length follows satisfiability determined time polynomial length choice arbitrary sat np complete problem means np non uniform proof strengthened theorem strengthen theorem equivalence showing np nonuniform implies small tractable representations lub exist 
suppose source theory containing length variables 
assuming np non uniform exists circuit determines satisfiability formulas length complexity polynomial circuit construct program test queries form follows check tautology eliminate duplicated literals 
resulting query length pad query exactly length duplicating literals 
negation query formula exactly length circuit determine formula unsatisfiable equivalently follows horn condition equivalent saying circuit size polynomial execute time polynomial time polynomial agre chapman agre chapman 
pengi implementation theory activity 
proceedings aaai pages seattle wa 
saul 
representations problems reasoning actions 
michie editor machine intelligence pages 
edinburgh university press 
tarjan 
linear time algorithm testing truth certain quantified boolean formulae 
information processing letters 
boddy dean mark boddy thomas dean 
solving time dependent planning problems 
technical report department computer science brown university 
boppana sipser boppana sipser 
complexity finite functions 
leeuwen editor handbook theoretical computer science volume algorithms pages 
elsevier amsterdam mit press cambridge 
borgida etherington alex borgida david etherington 
hierarchical knowledge bases efficient disjunctive reasoning 
proceedings international conference principles knowledge representation reasoning pages toronto ontario 
morgan kaufmann publishers buro ning buro ning 
report sat competition 
technical memorandum mathematik informatik universit paderborn november 
bylander bylander 
complexity results planning 
proceedings ijcai pages sidney australia 
cadoli schaerf marco cadoli marco schaerf 
approximation concept description languages 
proceedings third international conference principles knowledge representation reasoning kr pages cambridge ma 
cadoli marco cadoli 
semantical computational aspects horn approximations 
proceedings ijcai pages chambery france 
cook cook 
complexity theorem proving procedures 
proceedings rd annual acm symposium theory computing pages 
crawford auton crawford auton 
experimental results crossover point satisfiability problems 
proceedings aaai pages washington dc 
dalal etherington dalal david etherington 
tractable approximate deduction limited vocabularies 
proceedings ninth canadian conference artificial intelligence ai pages vancouver british columbia 
davis putnam davis putnam 
computing procedure quantification theory 
journal association computing machinery 
de kleer johan de kleer 
exploiting locality tms 
proceedings aaai pages anaheim ca 
dean tom dean 
artificial intelligence theory practice 
benjamin cummings redwood city ca 
dechter pearl rina dechter judea pearl 
structure identification relational data 
artificial intelligence 
dechter rina dechter 
constraint networks 
encyclopedia artificial intelligence pages 
john wiley sons new york 
del val del val 
analysis approximate knowledge compilation 
proceedings ijcai montreal canada 
donini francesco donini maurizio lenzerini daniele nardi werner nutt 
complexity concept languages 
proceedings second international conference principles knowledge representation reasoning kr pages cambridge ma 
dowling gallier william dowling jean gallier 
linear time algorithms testing satisfiability propositional horn formula 
journal logic programming 
doyle patil doyle patil 
theses knowledge representation language restrictions taxonomic classification utility representation services 
artificial intelligence 
dubois dubois andre carlier 
sat versus unsat 
david johnson michael trick editors cliques coloring satisfiability second dimacs implementation challenge dimacs series discrete mathematics theoretical computer science 
ams press providence ri 
thomas 
abstraction approximate symmetry 
proceedings ijcai volume pages chambery france 
erol erol nau subrahmanian 
complexity domain independent planning 
proceedings aaai pages san jose ca 
etherington david etherington alex borgida ronald brachman henry kautz 
vivid knowledge tractable reasoning preliminary report 
proceedings ijcai pages detroit mi 
frisch alan frisch 
model theory specify ai programs 
proceedings ijcai pages los angeles ca 
garey johnson michael garey david johnson 
computers intractability guide theory np completeness 
freeman san francisco 
gelernter gelernter 
realization geometry theorem proving machine 
proceedings international conference information processing pages paris 
unesco house 
reprinted computers thought feigenbaum feldman eds mcgraw hill ny pages 
greiner schuurmans russ greiner dale schuurmans 
learning useful horn approximations 
proceedings third international conference principles knowledge representation reasoning kr pages cambridge ma 
greiner russell greiner 
learning near optimal horn approximations 
preprints aaai spring symposium knowledge assimilation 
stanford university stanford ca march 
gupta nau gupta dana nau 
complexity results blocks world planning 
proceedings aaai pages anaheim ca 
heintze jaffar nevin heintze jaffar 
finite presentation theorem approximating logic programs 
proceedings popl pages 
wos wos 
unit refutations horn sets 
journal acm 
horvitz eric horvitz gregory cooper david heckerman 
reflection action scarce resources theoretical principles empirical study 
proceedings ijcai pages detroit mi may 
imielinski imielinski 
domain abstraction limited reasoning 
proceedings ijcai volume pages 
johnson johnson 
catalog complexity classes 
van leeuwen editor handbook theoretical computer science volume chapter 
elsevier science publishers north holland 
johnson johnson 
personal communication 
karp lipton karp lipton 
turing machines take advice 

math 
kautz selman henry kautz bart selman 
general framework knowledge compilation 
proceedings international workshop processing declarative knowledge kaiserslautern germany july 
kautz selman henry kautz bart selman 
forming concepts fast inference 
proceedings aaai pages san jose ca 
kautz selman henry kautz bart selman 
planning satisfiability 
bernd neumann editor proceedings th european conference artificial intelligence ecai pages vienna austria 
kautz selman forthcoming henry kautz bart selman 
efficient approximations quantified formulas 
preparation forthcoming 
kautz henry kautz michael kearns bart selman 
horn approximations empirical data 
artificial intelligence 
knoblock craig knoblock steven minton oren etzioni 
integrating abstraction explanation learning prodigy 
proceedings aaai pages anaheim ca 
knoblock craig knoblock josh tenenberg qiang yang 
characterizing abstraction hierarchies planning 
proceedings aaai pages anaheim ca 

test pattern generation boolean satisfiability 
ieee transactions computer aided design january 
lee lee 
completeness theorem computer program finding theorems derivable axioms 
phd thesis university california berkeley berkeley ca 
levesque brachman levesque brachman 
fundamental tradeoff knowledge representation reasoning revised version 
brachman levesque editors readings knowledge representation pages 
morgan kaufmann los altos ca 
levesque hector levesque 
logic implicit explicit belief 
proceedings aaai pages austin tx 
levesque hector levesque 
making believers computers 
artificial intelligence october 
lewis lewis 
renaming set clauses horn set 
jacm 
mcallester givan david mcallester robert givan 
natural language syntax order inference 
artificial intelligence 
mitchell mitchell selman levesque 
hard easy distribution sat problems 
proceedings aaai san jose ca 
muggleton buntine stephen muggleton wray buntine 
machine invention order predicates inverting resolution 
laird editor proceedings fifth international conference machine learning pages 
patel schneider peter patel schneider 
valued semantics frame description languages 
proceedings aaai pages philadelphia pa 
plaisted plaisted 
theorem proving abstraction 
artificial intelligence 
reiter de kleer raymond reiter johan de kleer 
foundations assumption truth systems preliminary report 
proceedings aaai pages seattle wa 
reiter mackworth reiter mackworth 
logical framework depiction image interpretation 
artificial intelligence 
sacerdoti earl sacerdoti 
planning hierarchy abstraction spaces 
artificial intelligence 
schoppers schoppers 
universal plans reactive robots unpredictable environments 
proceedings aaai volume pages 
selman kautz bart selman henry kautz 
knowledge compilation horn approximations 
proceedings aaai pages anaheim ca 
selman levesque bart selman hector levesque 
abductive default reasoning computational core 
proceedings aaai pages boston ma 
selman selman levesque mitchell 
new method solving hard satisfiability problems 
proceedings aaai pages san jose ca 
selman bart selman 
tractable default reasoning 
ph thesis department computer science university toronto toronto ontario 
subramanian genesereth subramanian michael genesereth 
relevance irrelevance 
proceedings ijcai volume pages milan italy 
tseitin tseitin 
complexity derivation propositional calculus 
editor studies constructive mathematics mathematical logic part ii 

valiant valiant vazirani np easy detecting unique solutions 
theoretical computer science 
valiant leslie valiant 
theory learnable 
communications acm 

