software engineering tools environments roadmap william harrison harold ossher peri tarr key research pointers authors development methodologies formalisms tool environment support separation extraction integration concerns 
linguistic tool support morphogenic software software malleable life sufficiently adaptable allow context mismatch overcome acceptable effort repeatedly new unanticipated contexts arise 
development new methodologies formalisms processes address non traditional software tool environment support facilitate 
development new methodologies formalisms processes tool environment support address engineering software new challenging domains pervasive computing commerce 
adoption adaptation xml enterprise java beans sophisticated message brokering integration tools commercial applications 
bill harrison ibm system development divisions initial designers os time sharing option tso 
associated ibm thomas watson research laboratory 
career ibm included periods different research focus design implementation operating systems design programming languages compilers program analysis optimization design software development environments exploiting mixed text graphic styles improve human interaction full life cycle process industrial software development 
worked technology design development component software including authoring subject oriented programming approach developing suites related applications application components message oriented programming reducing fragility object oriented software removing objects clients view method call project aims provide technology base assisting component integration automatically creating interface conversion glue needed software components mismatching definitions messages interchange 
bill received degree electrical engineering mit cambridge mass degree syracuse university syracuse ph 
master philosophy computer science degree syracuse university syracuse 
author dozen journal conference papers presentations active influencing computer software standards including ans iso iso draft adopted omg specifications 
holds japanese patent technology human interface design ieee distinguished lecturer software environments years 
harold ossher joined ibm thomas watson research center research staff member 
currently manages group conducts research technology transfer multi dimensional separation concerns matching reconciliation information models 
worked research associate stanford university specification integrated circuit fabrication processes 
holds sc 

sc 
degrees computer science rhodes university south africa ph degree stanford university 
interests include advanced approaches modularization separation concerns extensions object oriented paradigm software tools environments 
major contributor framework building integrated extensible environments originators subject oriented programming hyperspace approach multi dimensional separation concerns 
peri tarr joined ibm thomas watson research center research staff member completing thesis object management complex applications 
currently leads research tool environment development efforts multi dimensional separation concerns hyperspaces approach 
holds bs zoology ms ph computer science university massachusetts 
research interests software engineering environments software consistency inconsistency management integration multi dimensional separation concerns software lifecycle 
inventors hyperspaces 
software engineering tools environments roadmap william harrison harold ossher peri tarr tools environments aid developers producing software existed form early days computer programming 
increasingly crucial demand software increases time market decreases diversity complexity grow imagined decades ago 
briefly review history tools environments software engineering discuss key challenges believe field faces decade 
keywords tools programming support environments software engi neering environments process centered software engineer ing environments integration separation concerns 

software engineers tools done days assemblers 
people stand tools integrated collections tools called environments 
time number va tools grown tremendously 
range traditional tools editors compilers debuggers tools aid requirements gathering design building guis generating queries defining messages architecting systems connecting components testing version con trol configuration management administering data bases reengineering reverse engineering analysis program visualization metrics gathering full scale process permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sofware engineering limerick ireland copyright acm ibm thomas watson research center box yorktown heights ny usa ossher tarr watson ibm com centered software engineering environments cover entire lifecycle significant portions 
modern software engineering accomplished reasonable tool support 
role computers power variety increasing dramatic pace 
competition keen computer industry time market deter mines success 
mounting pressure produce software quickly reasonable cost 
usu ally involves mix writing new software finding adapting integrating existing software 
tool envi ronment support dramatic effect quickly done cost qual ity result 
determine done realistic economic constraints safety reliability 
software engineering tools environments increasingly important enablers demands software complexity grow imagined inception field just dec ago 
attempt survey vast field full predict myriad paths evolution 
stead presents personal view key issues themes believe especially important 
rest organized follows 
section reviews history tools environments software engineering identifies key recurring themes influenced field past continue 
section describe critical issues believe software engineering domain currently faces indicate re solutions 
section presents solution approaches problems raised section identi fies current technologies believe may serve en approaches 
section describes challenges new application domains indi cates domains constrain solutions 
fi nally section presents 

brief history tools environments existed form aid developers producing software com editors standard offerings operating systems 
earliest environments little small collections stand tools loosely coordinated fashion help accomplish software engineering goals 
unix example environment 
provides tools editors compilers de utilities awk sed grep find inputs outputs interconnected loosely developer discretion pipes redirection 
interconnection possible tools accept generate data simple standardized formats 
early environments quite useful provide real means integrating tools coordinating exe automating common tasks simply pro vided tools required developers employ appro priate usage conventions permit developers coordinate tools 
earliest vehicles automating flow control tools suited batch style operation 
provide ability developers describe tools data relate tools process changed data 
example allows develop ers indicate change particular set source code files result recompilation 
compiler may trigger execution test suite 
addition tool integration mechanisms signifi cantly enhanced usability collections stand tools resulting environments loose fed erations tools suffered usual prob lems associated loose integration 
significant efforts producing tightly integrated development environments area pro gramming support environments 
name suggests collections tools support coding activities 
earlier pan gandalf cornell synthesizer generator typically provided compilers language sensitive editors syn tax directed editors debuggers tools testing documentation utilities 
tools integrated tightly activities tool reflected appropriately tools 
example changes editor reflected immediately compiler debugger 
generally included support task automation 
example developer asked run program debugger pse determine compiled mod ules date recompile accordingly 
early introduced inter tool events coordinate operation remove batch control tools process data 
provided mes sage server tools register interest particular events tools sent server 
receiving event notification server identify tools expressed interest event forward tools 
field event view control integration allowed example compiler coordinate separately run ning editors debuggers sending events location syntax errors 
editors debuggers having registered interest events notified errors highlight 
comprised tightly integrated collections tools able overcome problems associated earlier loosely integrated environments 
continue extremely useful tools majority developers today 
major limitation support software engineering activity artifact imple mentation code respectively exclude major activities artifacts requirements engineering specification design testing analysis 
earliest software lifecycle models water fall model noted course software engi neering activities interconnected artifacts produced activities 
activity may affect changes artifact may necessitate changes related artifacts ensure artifacts remain mutually consistent 
early environ ments provided tools promoted development artifacts code tools integrated tools relationships arti facts tools represented automate tasks change propagation 
essentially situation existed earliest environments contained collections stand tools developers choose coordinated fashion provide assistance doing 
identification need integrated support software engineering activities software lifecycle represents genesis software engineering environments see 
sees pse antecedents integrated collections tools facilitate software engineering activities 
sees extend programming support tools supporting software engineering software lifecycle 
example prototype inte grating activities design testing emphasized natural human interface promote develop ment elaboration permitting different perspectives taken underlying web design development information 
arcadia see included tools re specification high low level design analy sis testing 
tools facilitated development analysis different software artifacts 
arcadia environment supported traceability arti facts permitting description interrelationships different pieces different artifacts exam ple developers indicate design modules ad dressed particular requirements code units im plemented particular design modules 
kind trace ability greatly facilitates comprehension change identi fication crucial improvement tra ditional 
area environments tools sees represent significant area research past decade full software engi neering lifecycle coding 
earlier see related research development fo predominantly production tools aid ac stages software lifecycle coding included hooks enable connection tools artifacts 
interactive design environment known move emphasizing design re taining connection realization code 
dominant theme early see research integration tools software lifecycle broadening domain tools 
program code generally expressed program ming language text pse rely widely accepted standards data shared 
broadening scope development concerns forced attention paid support data integration sharing data integrating tools respect data share 
common theme repository integration integration model posited common model shared infor mation provided support storage manage ment concurrent secure access 
pcte known exemplar approach 
unfortunately mod els existing time reconcile need commonly available view need rapid changes view individual tools 
fact rapid development dominated tool scene coupled hope distributed objects solve data integration problem hampered progress sees 
important lines research emerged see domain decade addresses major theme great current importance software engi neering 
multi view software environments facilitate development artifacts different devel may different views artifacts de processes develop ing 
example viewpoints system developers collaborating requirements speci fication may see different models requirements represented different formalisms may dif ferent process models 
environment uses descriptions intra inter artifact consistency maintain consis tency different representations manage inconsistency arises 
example statemate rational rose single developer may able multiple views piece software example control flow representation data flow representation class view object collaboration view simultaneously able update view updated automatically :10.1.1.20.5933:10.1.1.20.5933
multi view environ ments facilitate definition integration tion different simultaneous views software artifacts 
second major line see research initiated osterweil landmark posited need semi automated support software process addition tool support artifact development 
weil hypothesized software engineering process treated piece software undergoes similar lifecycle including requirements speci fication design implementation testing analysis hypothesis profound effect see research 
gave rise process centered software engineering envi ronments integrate tool support software artifact development support modeling execution software engineering processes pro duce artifacts 
explicit representation proc products interactions tion modern integrated development environ ments rational environment built 
providing powerful ways describing implementing soft ware engineering processes provided powerful means integrating processes tools partially automating tasks 
important examples research include adele alf arcadia epos marvel merlin oz pcte spade 

key challenges common themes apparent history software engineering tools environments research 
surprisingly ubiquitous theme integration 
seen need integration tools processes artifacts views driving force major changes direction new lines research 
integration accomplished plethora approaches ascii text shared repository standardized representations interfaces transformation adaptation event integration frameworks tools platforms facilitate 
integration themes soft ware process support multi view environments vast collection tools prototyped marketed cov tremendous range software engineering ties mentioned section 
de veloped context integrated environments cooperate loosely 
unfortunately state practice software engi neering advanced nearly impressive set tools integration mechanisms imply 

key reason tool environment highly specific context 
require software manipulates written particular language represented particular kind intermediate form program database 
run particular hardware particular operating system particular compiler environment integration platform 
require presence variety tools infra structure components developer wish 
contain hooks needed en able properly software developer 
concepts embodied tools applicable contexts tools 
developers frequently see tools capabilities environments discover context packaging mismatch precludes greatly complicates tools 
tool de constantly plagued problem making tools available multiple contexts achieve wider able devote efforts tion 
major challenge tools environments commu nity find ways build integrate tools capabilities easily adapted new contexts 
contexts sufficiently standardized enable plug play history demonstrates standardization relied complete solution reasons new domains identified needing standards developers group built software 
adaptation integration key capabilities 
tools play critical role enabling flexible adaptation integration comes double challenge tools community developing tool architectures ap proaches facilitate adaptation integration 
building tools assist adaptation inte process 
permanently malleable software problem separate islands context specific soft ware exists software world 
software pervasive life expectancy increased subject greater pressures integrate interact pieces software evolve adapt uses manner new unanticipated contexts technological new hardware operating systems software configurations standards sociological new domains business practices processes regulations users 
unfortunately ongoing software crisis attests software tally meet challenges 
evolution adaptation integration costly difficult formed 
result people software fails want things want integrate hardware software business processes brittle unreliable time 
essentially software square peg forced round triangular kinds changing rapidly changing holes readily fit 
problem arises impossible predict careful analysis business practices business processes people technology evolve time 
people software businesses domains available technologies change find dif ferent uses software impose new require ments 
rapidly changing technology fields little wonder impossible anticipate uses piece software put con texts 
technology available aid software integration evolution depends fundamentally ability anticipate pre plan change design ers anticipate evolution scenarios variations build open points straightforward ac techniques frameworks design patterns 
significant changes arise anticipated reengineering usually needed 
de spite reengineering tools remains exceedingly costly error prone process 
reliance pre planning change problematic reasons 
noted impossible needs changes anticipated remain difficult impossible accomplish 
second current pressures front plan ning 
traditional models software development notably spiral waterfall models involve careful requirements analysis design prior implementation 
may appropriate traditional contexts development large high quality systems significant period time engineering safety critical software areas business research today great pressure market publish cost reduced quality 
products appear capture market higher quality alternatives released late 
puts great pressure developers shorten software lifecycle favor quick release product capture interest significant share market 
initial development fast focused spending time planning changes probably couldn adequately anyway 
changes come difficult requiring amount reengineering introduce needed open points 
clearly state art approach evolution careful pre planning satisfy current evolving needs 
nutshell software currently clay needs gold 
clay soft malleable initially 
bumps added changed reshaped breakage 
attempts force hardened clay peg hole different shape lead breakage 
gold hand re mains malleable life 
reshaped needed assume shape hole 
introduce term morphogenic software refer software malleable life sufficiently adaptable allow context mismatch overcome acceptable effort repeatedly new unanticipated contexts arise 
words reshaped fit new holes needed 
morphogenic software extends goals integration discussed section 
traditional integration solutions say effect integration achieved building software particular integration approach event mechanism repository process specification approach 
means writing software anticipate specific software integrate commit particu lar context choice integration approach 
adaptation contexts difficult impossible 
morphogenic software goes step requiring commitment integration particular approach 
words challenge find ways write soft ware tools manipulate software facilitate rapid initial development adaptation new contexts front knowledge contexts 
combines extends key challenges past including integration term morphogenic derived morphogenesis biology refers process shape formation responsible producing complex shapes adults simple ball cells derives division egg line medical dictionary 
parallels changes organism undergoes develop ment subject constantly environmental evolutionary pressures piece software undergoes course development striking 
adaptability reuse portability retargetable systems context modern software development milieu 
separation integration concerns major barrier portable software morphogenic software inadequate separation concerns 
software implementing desired capability may depend deeply software highly specific particular context 
worse parts software artifacts em body capability may tangled coupled context specific parts parts pertaining ties identify module collection modules devoted solely capability 
evolution adaptation reuse capability diffi cult impossible 
separation concerns guiding principle software engineering decades 
difficulties remain 
believe primary reason problem termed tyranny dominant de composition 
software started represented linear media despite advances fields graphics visualization hypertext linked structures databases treated 
programs typically linear sequences characters modules collections contiguous characters 
lin ear structure implies body software decom posed way just typical document divided sections subsections way time 
decomposition dominant ex cludes form decomposition 
example functional programs decomposed function object oriented programs class 
traditional application separation concerns involves examination different separation criteria functional versus data decomposition choosing 
words best 
answer different better different situations 
dif ferent concerns important different development activities different stages software lifecycle different people playing different roles software process 
result different decompositions simultaneously seen multi view sees appropriate different times 
research focus shifted eliminating part allowing separation kind concern time 
realize benefits separation concerns fully possible achieve separation arbi kinds concerns 
include means limited function data type class feature aspect distribution persistence role variant viewpoint unit change 
concerns identified early lifecycle guide initial develop ment apparent lifecycle 
concerns span multiple software artifacts multiple phases lifecycle 
full support separation concerns liberated tyranny dominant decomposition allow developer engaged development activity focus concerns kinds appropriate par ticular activity irrespective particular concerns decompose software written 
appealing think concerns inde pendent orthogonal rarely case prac tice 
persistence distribution common example orthogonal capabilities exist separately implementations usually inter act details depends presence ab 
essential able achieve useful separation overlapping interacting concerns identi fying points interaction maintaining appro priate relationships concerns evolve 
separation concerns clearly limited con separated integrated jackson notes having divided conquer reunite rule 
approach separation concerns corresponding integration approach permit synthesis software deals multiple concerns 
functional languages example nesting function call means building software separate func tions 
integration mechanisms sees seen light individual tools concerns integrated integration support grow sophistication means separating concerns 
term multi dimensional separation concerns refer separation concerns properties noted :10.1.1.29.3807
believe just traditional separation concerns key software engineering past multi dimensional separation concerns key software engineering enabling critical ties understanding evolution adaptation reuse mor 
challenge create mechanisms meth tools environments support lever age 

meeting challenges believe addressing challenges noted section key thrusts software engineering decade 
section outline approaches specific requirements foresee area tools environments 
tool turn usually consists subsidiary concerns functions classes integrated programming language mechanisms 
deployment commercial technologies developments commercial software development provide technologies address integration challenges discussed 
advances allow basic functional characteristics software expressed fixing decisions depend context 
refer software structure embodies flexibility allow grown differently shaped deriva tives fit different environmental concerns stem software limited kind morphogenic software 
characteristic increasingly widespread acceptance commercial technologies dation 
focused effort put enhancing applying suitably expected grow complete solutions 
data integration xml adoption xml extensible markup language software development tools may break inhibits data sharing software tools solutions data integration issues characterized unidirectional omnidirectional sharing solutions 
sharing feeds data tool unix pipes omnidirectional sharing feeds infor mation back forth tools 
data sharing tools hampered famine approach interchange standards 
ex low level standards fail encode structure files ascii text 
extremely high level cdif models particular domains 
disadvantage cover narrow domains deal information domain tools assist construction 
major class exceptions fore software tool prototype development ignored issues 
xml promises provide mid level standard enable creation flexibly deployed reusable software tools 
achieved software community carefully picks xml claims find reality solutions 
article volume discusses importance xml software engineering internet 
programming languages provide major class exceptions 
need interchange programs tools humans dictated agreed high level structural interchange format language syntax 
need convert back forth internal formats interchange format forced existence tool suite parsing un parsing simplifies adaptation interchange mat 
expecting xml solve data integration prob lems enabling new generation high level standards look fact adoption xml files ascii files interchange format allows content model mismatches dealt transformation tools 
tools examine definitions different xml models dtds xml schemas user assistance detect related elements reconcile differences generate trans formers xsl 
transformers reshape xml produced tool consumption 
xml common substrate significant advantage separates technological issue reshaping content details specific tools burden adapting wide variety basic representations time 
commercial adoption xml provided tools parse transform xml representations 
availability parsing unparsing tools reduces cost adoption point new tools deal way information flows input output course communication users user interfaces xml format 
brings tools closer stem software derivative forms opportunity reshaping xml needed different environments 
technologies solving problems reshaping enable occasional application xml tional sharing situations 
short repository approaches discussed section omnidirectional sharing accomplished way sharing mechanisms keeping tools inputs outputs stored documents created tools 
documents constitute form coarse grained repository tools common data model 
repository augmented transforma tion tools notification mechanisms allow re shape information fit tools needs awaken demand 
considerations xml important approach unidirectional sharing facilitate model omnidirectional sharing 
sharing reshaping notification coor advanced system available commercially today 
adapting unidirectional technologies omnidirectional requires careful xml common need preserve identity round 
example program element identified developer name generally ways identified related xml elements unique identifier name changed ing seen tools 
data integration enterprise java beans xml appropriate coarse grained integration characterized loose coupling low bandwidth 
tighter coupling requirements higher bandwidth requires shared repository 
traditional designs repositories required par tools common data model 
remove constraint morphogenic software needs contain tion layer insulate tool model repository model 
date software tool developers morphogenic software favor rapid develop ment 
confronted need faced see designers deploy software different internal models common repository information commercial soft ware community promoted adopted enterprise java beans tm ejb technology 
enterprise java beans provide style java programs separates concerns object algorithms business logic data storage access concerns 
software written stem form subject maturing process called deployment 
deployment provides implementations operations stem uses access data points calls objects may intercepted 
implementations support tailored choices regarding data storage verify authority access participate concurrency transaction management protocols 
implementations may created developers directly tools support deployment 
case xml current state ejb technology suffers fact developed regard performance issues interest tool support relies underlying presumption information lo cated untyped keys typed pointers 
hope advocate new tools deal omnidirectional information flows sistent storage writing ejb requires availability free lightweight deployment tool sim ple situations development extensions sup port pointer keys 
control java messaging services event message delivery heart con trol flow integration fact af commercial software infrastructures soft ware development infrastructures 
capitalizing java success messaging model called java messaging services jms put forward 
jms severe limitations inhibit promoter morphogenic software 
morphogenic software emphasizes separation stem software unrelated concerns 
jms re quires sender message cognizant elements contents determine receive 
sender explicitly include properties message spite fact contained message 
addition sender receiver message concerned categorization messages topics describe flow messages 
concerns clearly separate functional concerns sending receiving objects 
characteristics argue stronger deliv ery model message brokering 
control integration message brokering message broker model generalized delivery model supporting routing messages sender receivers 
delivery criteria treated separate concern processing concerns 
message broker extracts properties message uses properties light delivery rules determine recipients 
ejb technology process characterized deployment software development stem form 
ing internal tool process matching receivers senders consumers providers performed software placed software elements ing dispatch delivery rules may depend message contents 
jms commercial message brokers emphasize event messaging model suit able software 
bulk software written programming languages java tm cobol ex response request service method sub routine call sufficiently forthcoming provision need delay transaction boundary crossing 
reason model separating delivery concerns processing concerns applied normal request response idiom 
making application careful soft ware elements necessary tions way mature deployment 
example function consumers senders callers insist delivery single servers servers interested fact request 
respect area integration new tools interface components call call open delivery mechanisms 
open deliv ery mechanisms separates delivery specification delivery look class par ticular parameter tools 
allows delivery components ones tool builder envisaged 
ideal language implementation allows brokering calls java interpreter compiler open respect dispatch semantics 
light existing technologies interpreters written 
advantage allow tool builders code calls components manner calls internal functions 
control integration composition engines separate specification deployment characteristics stem characteristics requires languages conceptual models specifications 
software composition engines genvoca subject oriented programming employ directives composing components separate components treating software components software 
raise consciousness need investigation tools describe rules messages flow software combined needs matched provisions performed 
software capable morphogenesis issues left province individual programming languages treated concerns separate individual pieces software 
management concerns support full multi dimensional separation concerns variants subsets allow separation criterion time requires tool environment support suggests need new methodologies environments best leverage 
tools begun appear needed research appropriate methodologies processes required truly effective environment support provided :10.1.1.29.3807
growing awareness problem tyranny dominant decomposition interest providing mechanisms break expect real progress tools decade 
separation concerns predominantly early lifecycle activity occurs requirements engineering design coding 
chosen concern structure relatively fixed changes require system refactoring 
actuality new concerns relevant software lifecycle 
tool environment support needed facilitate separation concerns activity occurs ongoing basis new concerns identified relevant 
separation concerns really process involves activities identification encapsulation integration concerns require tool support 
key challenges areas described 
identification concerns identification concerns process determining set relevant concerns units software address interrelation ships 
identification occur front retro spect 
developers identify concerns front explicitly design software artifacts encode concern structure software structure 
example requirements engineer may concerned features software organize re feature concerns similarly java tm pro grammer concerned classes separates implementation set class concerns 
types interrelationships concerns common typically defined part front design concerns 
new concerns may important software life cycle progresses 
developers may wish identify new concerns retrospect indicating fragments existing software artifacts address new concerns new concerns relate exist ing concerns 
example java tm programmer may need talk requirements engineer doing able discuss system features 
identify features new concerns implementation code developer identify classes methods member variables address part features example methods part print feature 
tool support identification concerns permit front retrospect identification 
identification may done extensionally intentionally finding convenient effective ways identify concerns par intentionally important research challenge area 
ability identify concerns span multiple artifacts important 
example developer concern print feature may care artifact fragments associated feature re specification design elements imple mentation code test cases ability identify cross lifecycle concerns promotes traceability round continue crucial 
identification concerns interrelationships done consistently way ensure stated semantic properties maintained 
simple example method eet member vari able display class designated addressing print feature object class concern display part print feature 
general ensuring concerns consistent satisfy specifications important issue particularly presence overlap ping non orthogonal concerns 
visualization software terms different kinds con identified critical capability 
identification concerns result reduced complexity possible developers focus certain specific concerns ignoring 
possible developers see understand concerns relate interact assess control impact change fa extraction 
significant research needed deter mine best structure multi dimensional concern structures promote comprehension developers need navigate visualize 
encapsulation concerns identification concerns indicates concerns impact software ensure concerns encapsulated 
modularization mechanisms needed enforce concerns 
mechanisms may part formalism classes object oriented formal may case particular concern modularized formalism con cern spans multiple formalisms particular kind concern modularized formalism features encapsulated java tm extra formalism modularization mechanisms required 
additional re search required define new formal better support identification encapsulation multiple dimensions concerns extra formalism modularization mechanisms achieve additional decompositions dimensions 
integration concerns separation concerns mechanism include powerful integration mechanisms permit selective integration separate concerns 
integration key theme history software engineering requires tool environment support 
requires definition weaver tools combine understanding underlying arti fact formalisms semantic sophistication synthesize integrated concerns satisfy stated specifications interrelationships 
need perform matching reconciliation examining interfaces con integrated interacting developer match corresponding elements reconcile differences 
summary fully achieving goal multi dimensional separation concerns require new research synthesis existing research variety software engineering areas 
include software archi tecture refactoring reengineering component software engineering software analysis software specification methodologies programming languages hci visualization 
environments morphogenic software morphogenic software extremely ambitious goal realized incrementally 
involves re search evolutionary pressures facing people software people software respond pressures unit 
inherently multi disciplinary area research software engineering tools environments playing key role 
support separation integration concerns critical achieving goal morphogenic software 
particu lar ability identify portions software realize concern extract class component integrate new context fundamental requirements morphogenesis 
section explores kinds tool environment support needed facilitate engineering morphogenic software 
managing dependencies interactions 
accepted long time key reasons software rigid readily adaptable con tains hidden assumptions dependencies interac tions 
understood original devel usually specified docu mented understood long 
small changes unexpected effects difficult detect correct 
long hoped tools help significantly problems sufficient advances realistic 
tools encourage isolation natural way discussed section 
ease capture useful information time initial development evolution challenge minimum immediate market pressures render unacceptable 
discover useful information ret demand 
involve analysis static dynamic detect dependencies interactions assumptions 
tions software manifest help developers understand assumptions dependencies interactions 
adaptation 
software successfully sepa rated extracted context operates usually new contexts 
adapted new needs integrated software new context 
traditional adaptation mechanisms inadequate task extent adap tation done done largely hand packaging mismatch address issues 
comprehensive tool support needed 
details differ widely depending base software visible modifiable 
black box ap proach requires base software interfaces including details data produced consumed left 
tool support needed compare actual desired interfaces reconcile differences produce adapters allowing actual interfaces new context 
white box approach allows modification base software 
tool support needed help determine modification necessary iso late modifications base software tion concerns techniques section 
correctness consistency management 
assuming adapted portion software integrated new context confident result correct consistent 
tool support needed perform checking various sorts testing 
checking tools need specification intended full specification properties checked done model checking 
require characterizations soft ware components manner adapted integrated 
assumptions initial software development expect detailed characterizations software provided tools needed construct demand probably combination program analysis developer interaction 
key challenge making way benefits outweigh costs 
summary 
discussed key needed support morphogenic software 
tools help locate software adaptation reuse techniques concept extraction data mining sophisticated search 
vision morphogenic software provide focus research wide variety tools mate goal environment development evolution morphogenic software 
long goal reached expect significant benefit individual tools deal partially problems discussed 
seen ready begun appear 

new domains prior section discussed key issues applying important research directions software engineering general decade 
section consider emerging new domains believe require non traditional software engineering methodologies tools environments 
new domains impose ex challenging requirements constraints solutions addition discussed earlier expect tools technologies address mains expand frontiers modern software engi neering 
pervasive computing long standard computers sufficiently powerful software engineers part stopped worrying saving bytes cycles advent expansion pervasive computing re introduced need software engineering constrained devices 
doing introduced new challenges cluding mobility far greater heterogeneity devices constant flux set devices available desire applications multiple devices need software integration devices 
date constrained devices area embedded systems 
tools running standard computers support development software specific devices 
developers tools develop applications specifically particular device operating system 
retargeting application new device field dates new updated applications installed existing embedded devices sizeable jobs 
pervasive computing world different 
case bringing common services multiplicity devices developing custom applications spe cific devices 
strong economic pressure serv ice provider support wide variety devices rewriting service devices come go sufficient custom coding usually viable 
devices significantly different char services customized 
creates tension need software engineering approaches tools assist addressing 
biggest problem constrained devices tion computing resources imposed constraints power 
second biggest problem usability 
user inter action impoverished details differ signifi cantly device device 
supporting service large number devices common capa bilities viable essential exploit particular strengths device get usability acceptable 
leads need transcoding tools support 
transcoding process adapting content tation interaction different constrained environ ments 
involve adaptation legacy content databases techniques data mining web page presentation 
better effects achieved con tent structured transcoding mind struc ture additional information tions transcoding process 
tool support vital users content device models allow specify easily transcoding done 
variants support needed develop ment environment device allow user tailoring 
obviously tool running de vice different running devel opment environment address issue usability constrained setting 
clearly cross development environments critical domain case embedded systems compilers debuggers profiling performance tuning tools testing tools 
new twist provided fact support multiple targets critical applications de veloped deployed customization major kinds devices 
de vices differ just hardware operating sys tems application models 
applications typically portable application models significant change context requiring excellent separation con morphogenesis 
commerce burgeoning commerce domain sufficiently differ ent traditional software domains software engineering issues 
far greater emphasis cots software black box reuse versus writing evolving large software sys tems owned single 
components reused data machines owns controls 
global view control largely independent systems interact 
evolve central con trol evolution involves interfaces just internal details 
evolution occurs dynamically commerce continue despite 
growing de mands continuous availability face usage observed order magnitude larger normal usage 
exchange money sensitive information secu reliability critical 
issues new commerce arisen distributed systems agent systems highly reliable systems software process modeling execution commerce domain brings context major growing importance con text unprecedented scale 
commerce software developed rapidly domains early market important benefit large body appropriate software engineering research results experience 
significant chal software engineering research community come architectures models methodologies ap proaches processes tools environments embody order facilitate software engineering improve software quality domain 
area tools needed man agement scale 
presentation visualization manage ment complexity long important theme tool development met limited suc cess 
commerce arena numbers go way tools dealt der people internet agents running behalf single auction system running mil lion auctions simultaneously 
interact course interactions unpredictable common currently catastrophic 
design testing approaches tools needed software properties 
commerce applications great vari ability requirements reliability availability secu different parts system 
properties cal parts system high throughput important 
example users quite tolerant minor errors sional disconnects browsing catalogue long usually quickly conveniently transferring money purchase items demand ity security 
approaches tool support nec essary build systems different tradeoffs exist ensuring barriers properly maintained 
commerce applications integration lying business rules user experience involves graphical multi media presentation critical acceptance application 
tools help devel create user experience achieve inte effectively especially face evolution aspects 
goes considerably traditional user interfaces separation underlying func tionality 
software evolution large scale uncontrolled domain especially challenging 
noted interactions agents systems components able interacting parties evolve independently 
morphogenic software especially consistency inconsistency management parts important role sense context con changing software adapt consistent manner 
domain adaptation ing dynamic disrupt ongoing commerce 
commerce systems interaction software con trol installed ma chines detection adaptation interface changes particularly important 
engineer software possible providing tool support doing accomplishing needed adaptation challenging areas research 
past software engineering community fo cussed primarily development evolution large complex expensive centrally owned systems 
important problem relatively small number large companies 
tremendous opportunity focus software engineering challenges commerce helping ensure software quality ca meet demanding needs domain 

history tools environments soft ware engineering seen important issues trends emerge 
include separation concerns inte coordination plug play support multiple views 
seen numerous attempts address issues manifested different contexts imposing unique requirements constraints solutions 
attempts shaped history field 
key challenges see software engineering tools environments pertain common themes 
modem software development milieu renders broader deeper complex requirements con straints solutions 
addressing adequately ne pushing frontiers state art areas reexamining redefining assumptions methodologies technologies field currently rests 
expect see major trends emerge new methodologies formalisms processes ad dress non traditional software tool environment support facilitate 
sig economic business research pressures market publish especially new domains pervasive computing commerce fewer individuals able expend resources traditional spiral lifecycle knowing losing result cutting corners 
rapid development rapidly changing requirements plat forms extremely fast moving volatile field questionable new domains benefit costly traditional soft ware lifecycle simply takes long 
current methodologies tools generally non traditional contexts de grade gracefully 
developing methodologies models contexts tool en vironment support critical challenge upcoming decade 
greater focus methodology formalism tool environment support separation concerns morphogenic software 
problem separate islands useful functionality seldom usable contexts needed acute 
time advances separation concerns research integration re search standards provide glimmer hope functionality context separated inte effectively leading context inde greater adaptability 
adoption adaptation xml enterprise java beans sophisticated message brokering inte tools commercial applications 
believe similar technologies chance successful adoption prior standards failed standards different level 
mandate specific models require specific implementations specific sets services integration platforms past 
provide function points agreement standardization way procedure call programming language world 
saw great deal process centered software engineering environments development kinds tools facilitate different software engi neering activities 
expect need effective diverse tools increase particularly variety challenging software domains software engi neering models traditional non traditional increase 
hope research areas occur improvements adaptability integration new tools environments iso lated islands integral parts growing 
stu feldman michael helpful discussions valuable insights commerce computing respectively stan sutton helpful comments drafts parikh assistance literature search 
aksit bergmans 
object oriented language database integration model composition filters approach 
proceedings ecoop 

software process enactment 
proceedings fourth acm sigsoft symposium practical software development environments december 
andersen 
system design composing structures interacting objects 
pro ceedings european conference object oriented programming ecoop 
robert balance susan graham michael van 
pan language editing system integrated development environments 
proceedings sigsoft fourth symposium software development environments december 
sergio alfonso fuggetta carlo ghezzi luigi 
spade environment soft ware process analysis design enactment 
software process modelling technology finkelstein kramer editors john wiley sons 
elisa gail murphy 
conceptual module querying software reengineering 
proceedings international conference soft ware engineering icse april 
don batory singhal thomas 
genvoca model soft ware system generators 
ieee software september 
jacky estublier melo 
adele tempo environment support process modeling enaction 
software process modelling technology finkelstein kramer editors john wiley sons 
israel ben gail kaiser 
paradigm decentralized process modeling realization oz environment 
proceedings th interna tional conference software engineering 
barry boehm 
spiral model software devel opment enhancement 
ieee computer vol 
may 
ll luca paolo ciancarini fabio 
software engineering internet roadmap 
volume 
gerard gallo regis ian thomas 
overview pcte pcte 
proceedings sigsoft third symposium software development environments november 
canals jean claude der 
alf framework building process centred software en environments 
software process model ling technology finkelstein kramer editors john wiley sons 
edmund clarke david long lan 
compositional model checking 
proceedings fourth annual ieee symposium logic com puter science 
geoffrey leon osterweil 
mecha nism environment integration 
acm transac tions programming languages systems vol 
pp 
january 
conradi liu 
ini tial software process management epos 
soft ware engineering journal special issue software process support vol 
september 
wolfgang volker 
managing soft ware processes environment 
pro ceedings fourth symposium software devel opment environments december 
robert deline 
avoiding packaging mismatch flexible packaging 
proc 
international conf 
software engineering 
wolfgang emmerich petr wilhelm sch 
object oriented database management systems construction case environments 
proceedings conference database expert systems ap plications dexa 
michael ernst jake cockrell william griswold david notkin 
dynamically discovering program invariants support program evolution 
proc 
international conf 
software engineering 
stuart feldman 
program maintain ing computer programs 
software practice experience vol 
pp 
april 
alfonso 
software process roadmap 
volume 
erich gamma richard helm ralph johnson john vlissides 
design patterns elements reusable object oriented software 
addison wesley 
david garlan robert allen john 
architectural mismatch hard build systems existing parts 
proc 
international conf 
software engineering 
david garlan gail kaiser david notkin 
ing tool abstraction compose systems 
ieee computer pages june 
david garlan mary shaw 
software architecture perspectives emerging discipline 
prentice hall april 
william griswold kato jimmy yuan 
aspect browser tool support managing dis aspects 
position oopsla shop multi dimensional separation concerns object oriented systems www cs ubc ca murphy workshop oopsla 
nico habermann david notkin 
gandalf software development environments 
ieee transactions software engineering vol 
se pp 
december 
david harel amnon naamad amir pnueli michal rivi sherman mark trakhtenbrot :10.1.1.20.5933
statemate working environment development com plex reactive systems 
transactions software engineering vol 
pp 
april 
william harrison harold ossher 
subject oriented programming critique pure objects 
proceedings conference object oriented programming systems languages applications oopsla september 
hori ono goh san deep singhal 
authoring tool web content 
proc 
markup technologies graphic communications association alexandria va december 
jackson 
complexities computer systems implications system development 
proceedings international conference computer systems software engineering pages 
java tm message service documentation sun micro systems 
java sun com products jms docs html sch wolf 
merlin supporting cooperation software de velopment knowledge environ ment 
software process modelling technology finkelstein kramer editors john wiley sons 
gail kaiser peter feiler steven 
intelligent assistance software development maintenance 
eee software may 
kernighan 
unix pro gramming environment 
ieee computer vol 
pp 
april 
gregor kiczales john lamping anurag mendhekar chris maeda cristina lopes jean marc lo john irwin 
aspect oriented programming 
proceedings european conference object oriented programming ecoop finland 
springer verlag lncs 
june 
nancy leveson peter harvey 
analyzing software safety 
ieee transactions software engineering vol 
september 
mira mezini karl lieberherr adaptive plug play components evolutionary software develop ment 
proceedings conference object oriented programming systems languages ap plications oopsla october 
jens jahnke dennis smith margaret anne storey scott tilley kenny wong 
reverse engineering roadmap 
vol ume 
nuseibeh jeff kramer anthony finkel stein 
framework expressing relationships multiple views requirements specifica tions 
transactions software engineering vol 
pp 
october 
william opdyke ralph johnson 
refactor ing aid designing application frameworks evolving object oriented systems 
confer ence proceedings acm press september 
harold ossher william harrison 
support change 
proceedings fourth acm sigsoft symposium software development envi ronments december 
harold ossher matthew kaplan alexander katz william harrison vincent kruskal 
specifying subject oriented composition 
theory prac tice object systems vol 
pp 
harold ossher peri tarr :10.1.1.29.3807
multi dimensional separation concerns hyperspace ap proach 
proceedings symposium software architectures component technology state art software development 
kluwer 
appear 
leon osterweil 
software processes software 
proceedings th international conference software engineering march 
david parnas 
criteria de composing systems modules 
communications vol 
december 
terry grady booch 
visual modeling rational rose uml 
addison wesley 
steven reiss 
connecting tools message passing field environment 
ieee soft ware vol 
july 
roman amy murphy gian pietro picco 
software engineering mobility roadmap 
volume 
royce 
managing development large software systems 
proceedings ieee august 
reprinted proceedings ninth inter national conference software engineering 
peri tarr harold ossher william harrison stan ley sutton jr degrees separation multi dimensional separation concerns 
proceedings st international conference software engi neering may 
richard taylor frank belz lori clarke leon osterweil richard selby jack wileden alexander wolf michal young 
foundations arcadia environment architecture 
proceed ings sigsoft third symposium software development environments november 
teitelbaum reps cornell program synthesizer syntax directed programming envi ronment 
communications acm vol 
pp 
september 
anne thomas 
enterprise javabeans tm technology server component model 
december 
prepared sun microsystems ava sun com products ejb white html turner fuggetta wolf 
feature engineering 
proceedings th inter national workshop software specification de sign april 
robert walker elisa gall murphy 
initial assessment aspect oriented programming 
proceedings international conference software engineering icse may 
wasserman kersten 
developing interactive information systems user software engineering method ology 
ieee transactions software engineer ing vol 
se pp 
february 
rebecca wirfs brock ralph johnson 
current research object oriented design 
communica tions pp 
september 
extensible markup language xml rec february document rec xml publications www org tr rec html 
