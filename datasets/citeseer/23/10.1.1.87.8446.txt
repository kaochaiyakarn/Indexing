visual modelling validation distributed systems habilitation der fakult iv und informatik der universit berlin dr gabriele taentzer informatik er des 
november der 
juli prof dr prof dr ehrig prof dr engels paderborn prof dr prof dr mahr prof dr ehrig prof dr engels paderborn prof dr essen prof dr parisi presicce rom berlin visual modelling validation distributed systems survey habilitation thesis gabriele taentzer technische universit berlin fakult iv und informatik institut und theoretische informatik mail cs tu berlin de september distributed system technologies fast developing complexity networked systems increases 
reason precise design distributed systems necessary comprising key aspects 
employment formal methods restricted aspects performance correctness distributed algorithms investigation consistency issues arise data shared different sites challenge 
approaches visual modelling validation distributed systems considered focussing unified modeling language uml visual modelling language graph transformation formal validation domain 
meet main requirements distributed system modelling uml extended number profiles heavy weight language extensions 
visual reasoning certain key aspects distributed systems formal calculus distributed graph transformation developed 
calculus supports formal validation distributed systems especially concerning concurrency consistency issues 
precisely defining syntax semantics visual modelling language uml graphs play central role suited store multi dimensional structures visual representations 
consequence graph grammars shown promising technique define visual languages 
theoretical results graph transformation advantageously speed visual parsing show functional behaviour model translations 
compared approaches visual language definition graph grammars allow fully visual approach handles structural aspects visually 
approach builds basis precise syntax semantics definition visual modelling languages distributed systems 
die entwicklung von verteilte systeme ist und hat zu einer von dieser art gef hrt 
ist ein pr entwurf von verteilten systemen der die 
die verwendung von methoden ist auf wie und von verteilten algorithmen 
wie sie beispielsweise bei der durch verschiedene prozesse sind noch nicht untersucht worden 
diese arbeit sich mit und verteilte systeme wir uns auf die unified modeling language uml als sowie als 
um die das von verteilten systemen zu erf wurden eine reihe von der uml hrt 
zur validation von verteilten wurde der formale kalk der verteilten entwickelt 
dieser kalk unterst im den von und nebenl 
eine wenn es um die pr definition der syntax und semantik von sie sich zum von repr 
sind eine technik zur definition von sprachen 
theoretische nnen werden um den von zu und um das funktionale verhalten von zu 
im zu anderen ans zur definition von sprachen eine vollst definition die alle 
der der arbeit ansatz stellt eine die pr syntax und von verteilte systeme dar 
contents requirements distributed system modelling main aspects distributed systems 
challenges 
examples distributed systems 
summary requirements 
visual modelling languages uml 
visual language definition parsing 
model validation validation issues 
validation techniques uml 
model translation graph transformation 
graph transformation validation domain structured graphs graph transformation 
distributed graph transformation semantic domain 
validation support graph transformation 
summary papers submitted habilitation thesis visual modelling framework distributed object computing consistency checking visualization ocl constraints 
application graph transformation visual languages 
combined model view approach system specification 
distributed graphs graph transformation 
distributed graph transformation application visual design distributed systems 
agg approach language environment 
distributed systems technologies developed fast decades 
especially web internet applications services great interest 
range useful languages tools environments provided supporting development distributed applications 
due increasing complexity distributed system hardly designed modelling key aspects system 
resource sharing primary aim development distributed systems 
proven concept redundancy resources improves performance fault tolerance system 
redundancy expensive increases complexity distributed systems validation methods available design time highly desirable 
far main reasons develop formal models distributed systems performance issues correctness distributed algorithms 
consistency issues interest 
today resource sharing taken granted effective data sharing challenge 
example data sharing plays important role considering distributed shared memory dsm systems 
dsm systems data shared logically computers share physical memory 
main point dsm systems appear high level developer usual message passing systems developers care distribution issues shared data marshalling data 
acceptance dsm systems dependent efficiency implemented 
concurrent conflicting updates may arise depends heavily underlying consistency model dsm system acceptable performance 
occurring consistency issues investigated literature 
typical formal modelling techniques statecharts petri nets automata process modelling support attractive integration process information modelling complete formal basis 
focussing information modelling unified modeling language uml evolved standard visual modelling language object oriented systems 
flexible adaptability domains uml supports standard extension mechanism defining profiles 
exists strong interest researchers companies complete uml profiles universal modelling language kind system 
comprehensive profile enterprise distributed object computing edoc developed providing lot new concepts model important aspects distributed systems 
aspects missing uml concepts application specific views adequate visual constraint language 
definition visual modelling language uml semi formal syntax semantics partially defined precise manner 
compared textual languages exist standard formalism backus naur form bnf attribute grammars define syntax semantics visual language vl 
vl separate formalisms precise language definition parsing translation semantic domain 
uml constraint approach called metamodel provides class diagrams define types model elements relations constraints object constraint language ocl restrict allowed structures 
visual languages specification description language sdl defined grammar approaches 
constraint grammar approaches textual notions large extent multi dimensional structure diagrams graphics difficult understand reason 
semantics uml specified standard object management group omg informal 
described natural language 
large variety semantic domains exist uml map uml models partly completely semantic models focussing certain system aspects 
especially behaviour part uml models considered mapped sort process model 
precise semantic model investigating consistency issues distributed systems focussed literature 
outline habilitation thesis habilitation thesis consists survey research papers author contributions relevant research visual modelling validation distributed systems 
outline refers directly achieved papers 
survey embeds achievements larger context large variety related account 
central framework habilitation thesis outlined 
clarifying main requirements distributed system modelling uml discussed visual modelling language distributed systems 
offering precise intuitive approach key aspects distributed systems formal calculus distributed graph transformation developed 
distributed graph transformation combines process information modelling serve semantic model domain visual model main aspects distributed systems considered 
distributed graph transformation offers validation support concerning issues seldom considered distributed system models conflicts dependencies actions consistency issues 
choosing semantic domain uml models offers possibility reason consistency shared object structures conflicting dependent updates 
furthermore process issues event structure semantics worthwhile investigated 
validation process supported agg tool offering environment allows develop test analyze graph transformation systems 
uml serves visual modelling language distributed systems especially exist various extensions adapt different problem domains 
concerning distributed system modelling interesting concepts captured extension 
main extension ocl constraint language formulate system invariants pre post conditions guards 
unfortunately ocl textual integrated uml 
basing ocl collaborations done paves ground closer integration uml 
surely graphical notation increase attractiveness ocl 
uml distributed systems vl definition model translation graph transformation semantic domain main topics interrelations thesis addition concept application specific views developed useful support distributed specifications 
having considered language concepts adequately extended uml precisely defined investigations 
uml metamodel provides definition symbols relations form visual alphabet syntax 
formedness rules form textual ocl constraints restrict set possible models syntactically meaningful ones 
approach graphs natural means describe inherent structure diagrams 
ocl textual formalism language description graph grammars better suited define syntax visual language 
similarly bnf rule manipulation syntactical forms performed graph derivations 
adding attributes store representational data semantical information graph grammar approach suited define concrete syntax translate semantic domain 
precisely defined translations concrete syntax semantic domain formally investigated functional behaviour translations proven 
performing definition uml sublanguages shows clear precise vl defined graph grammar approach 
examples show graph transformation great potential bnf visual languages 
sketches main topics thesis interrelations 
organization survey article gives overview research activities concerning visual modelling distributed systems validation support led number published papers 
requirements distributed system modelling discussed section 
section uml adequate visual modelling language distributed systems precise definition parsing visual languages considered 
section contains discussion main validation issues discusses validation techniques uml shows models syntax translated semantic domain graph transformation 
graph transformation semantic domain section presents concepts structured graph transformation needed define mapping main aspects distributed systems semantic domain 
available validation techniques discussed tool support 
presentation style survey informal formal definitions details cited papers especially papers referred bold letters 
article summary papers submitted habilitation thesis 
special go supervisor hartmut ehrig martin gro rhode gave valuable hints especially concerning presentation 
furthermore claudia julia padberg ingo proof reading thesis 
requirements distributed system modelling distributed system modelling evolving discipline mainly coped performance issues quality service 
aspects distributed systems carefully think 
introduce distributed systems discuss main design challenges general 
examples distributed systems special challenges mobile computing distributed shared memory systems web applications 
section requirements distributed system modelling summarized 
main aspects distributed systems distributed system consists number hardware software components located networked computers 
components usually proceed concurrently communicate interact achieve productive system 
communication performed message passing logically shared memory distributed physically 
distributed process clock exist global clock 
distributed processes usually asynchronously run synchronization protocols get actions executed simultaneously 
fail partially component stops running 
means component system detect components failed possible find 
failure happened running components react appropriately 
typically computer networks organized layers basic layers concerned network middleware layers provide common programming platform upper layers distributed applications reside 
known examples distributed systems internet intranets mobile computing 
distributed applications web services distributed systems consist software components belonging application layer 
comprehensive presentation distributed systems concepts design principles 
reasons developing distributed system inherent distribution components computers internet sharing resources 
resource notion system part 
ranges hardware components processors disks printers software defined entities files databases kind data object 
challenges discuss main challenges designer distributed systems usually meets take account carefully developing system 
heterogeneity 
developing distributed application especially internet confronts designer different sorts computers networks 
developer deal different hardware operating systems heterogeneous programming languages 
larger applications developers engaged different encoding styles 
main concept mask heterogeneity network layers middleware provides programming abstraction distributed applications part heterogeneity 
openness 
openness distributed system determines degree far system modified extended new components 
achieve openness key interfaces published 
usually done programming level standards common object request broker architecture corba idl simple object access protocol soap xml 
open systems provide uniform communication mechanism published interfaces access shared resources 
way open systems constructed heterogeneous hardware software conformance component published standard carefully tested verified sure system works correctly 
scalability 
distributed systems different scales ranging processor machines internet 
system called scalable remain effective number resources clients significantly increases 
design scalable distributed systems challenges possible add server computers avoid performance bottlenecks arise single server handle requests 
considering services heavily rely data sets size proportional number users resources system main algorithms carefully designed 
example hierarchical net structures scale better linear ones 
system scalable maximum performance loss worse hierarchical systems 
software resources internet addresses run 
goal difficult meet especially networking software supposed run long time designers predict developments years 
general algorithms decentralized avoid bottlenecks 
usually replication mechanisms improve performance resources heavily certain web pages 
handle possible scalability problems early possible developer supported configuration management provided techniques early performance tests 
concurrency 
distributed applications services usually include high amount concurrency lead complex control flow difficult overlook programming difficult test distributed debugging 
resources shared clients lead simultaneous attempts access shared resource 
process manages shared resource take client request time 
approach limits throughput services usually allow multiple client requests processed concurrently 
programmer take care shared resources ensure operations access synchronized way data remains consistent 
partial failures 
distributed applications may happen component fails continue function partial failures occur 
due fact handling failures particularly difficult distributed systems 
usual techniques handle partial failures failure detection checksums detect corrupt data messages files masking failures 
example messages retransmitted fail arrive 
techniques tolerating failures informing user web browser contact web server leave proceeding user 
technique recovery failures meaning bring server data consistent state failure occurred 
redundancy hardware components popular technique systems fault tolerant 
developer aware kinds failures occur distributed system choose best practice kind failure 
security 
security issues considerable importance distributed systems 
security information resources aspects protection unauthorized access alteration corruption interference means access resources 
typical example occurs electronic commerce users send credit card numbers internet 
resource protection main security issue 
important security mechanism digital signatures certificates trust certain information 
system designer choose adequate security policy meeting security requirements keeping process management costs minimum 
transparency 
due intrinsic complexity important design issue distributed system transparency hiding certain aspects users 
degree transparency dependent design distributed system 
scope transparency broad access remote resources transparent local remote resources accessed identical operations server location remote resources known typing address certain web page 
furthermore user aware concurrent processes replication resources partial failures movements resources places performance specific reconfigurations 
availability fault tolerance 
data replication key providing high availability fault tolerance distributed systems 
caching data clients servers familiar means performance enhancement 
furthermore data replicated transparently servers domain 
general requirement replicated data consistency 
dependent application different forms consistencies considerable developer choose adequate 
having clarified main aspects distributed systems general challenges constructing discuss examples distributed systems look closer specific challenges 
examples distributed systems examples distributed systems belonging different system layers 
mobile computing mainly concerned platform distributed applications examples belong application layer describing distributed shared memory systems web applications 
examples introduced main challenges discussed results requirements adequate modelling 
subsection draw sample cases summary main requirements distributed system modelling 
mobile computing 
mobile computing concerned performance computing tasks user move changing environment 
portable devices mobile phones laptops handhelds ability connect conveniently networks different places wireless mobile computing possible 
mobile computing raises important system issues imposing new requirements system modelling 
mobile device easily local network 
adaptation mobile device current environment done transparently user type name address local services achieve connectivity 
available services current environment discovered devices user special configurations nowadays dhcp servers installed networks automatically assign ip addresses new devices allow convenient access internet 
connected network local services discovered nearest local printer accessible device requesting printer service 
purpose discovery services accept store details services available network respond queries client 
means discovery service offers registration service records details available services lookup service accepts queries concerning available services 
jini java system designed mobile networking 
provides facilities service discovery 
discovery related components jini system lookup services jini services jini clients 
crucial point bootstrapping connectivity 
jini client service enters network lookup service 
locate lookup service 
jini uses multicast known ip multicast address known instances jini software 
mobile environments query processing designed meet best typical restrictions bandwidth energy 
different types queries distinguished concerning broadcasted fast changing data 
broadcasted data addresses large number clients 
best organization broadcasted data energy spent client side minimized 
information broadcasted provided demand 
contiguous query keep track value query changing environment time evaluated broadcasted data 
kind queries concerns fast changing update intensive data 
location management viewed establishing locations individual mobile users special case problem 
precise tracking may impossible simply unnecessary 
may store incompletely defined information 
consequence queries answered approximate way 
scale important factor dealing categories queries 
benefit data broadcasting proportional number users serviced cost broadcasting depend number users 
broadcasting method particularly suitable large number clients having query 
location management scalability solutions extremely important may users local area network may thousands users wide area network informing location server user move scale large networks 
security privacy important issues mobile computing largely neglected presently 
concentrate software issues discuss important difficult problem security physical level 
systems track moves users active badge technology may threaten user privacy 
protect privacy necessary enable enforce specification personal profiles users 
profiles users able determine authorization reach due energy restrictions may want restrict list users allowed wake mobile unit send message 
profile created managed 
profiles stored 
profile migrate user 
solution cope adequate authentication policy data access 
mobile terminals disconnected static part network transactions processed locally cached data 
degree connectivity mobile devices fixed part network vary widely 
mobile users check data long periods time 
new methods cache synchronization reflecting different degrees connectivity necessary 
especially mobile hosts carry shared data lock commit protocols redefined meet new requirements 
integrity constraints involve data residing number mobile fixed hosts efficiently maintained 
main question partition data static mobile hosts constraint maintained having contact mobile hosts time 
distributed shared memory systems distributed shared memory dsm systems kind distributed systems components share physical memory communicate logically sharing data 
components access dsm reads updates data appears local fact distributed network 
underlying infrastructure sure shared data consistent sites 
updates site replayed sites 
main advantage dsm software developer concern message passing communication 
dsm usually appropriate client server systems clients normally request server held resources 
servers provide dsm shared clients 
example kind dsm system distributed version management systems number revision archives distributed different sites share large parts software project documents 
revision archive cares version control site clients store access revisions documents 
example chat systems clients register server 
server provides clients registered new chat contributions 
notable examples dsm application apollo domain file system files shared different processes 
originally dsm systems considered connection shared memory multiprocessors 
critical issues dsm systems efficiency implementation degree consistency shared data reached 
message passing systems remote data accesses explicit developer aware expense communication 
dsm particular data access may may involve communication costs 
data update example may cause immediate updates replications 
possibility lazy update performed data read 
update policies dsm systems highly dependent particular applications facilities underlying infrastructures 
performance implementation depends directly degree consistency guaranteed 
strict consistency means written values instantaneously available sites usually expensive 
temporal inconsistencies allow delay propagating updates peers result considerably faster realizations 
issue closely related structure dsm granularity sharing 
considering shared file system clearly wasteful transmit entire file system answer read update request 
adequate unit sharing certainly single file directory 
directories unit sharing may components try access directory different files directory accessed 
phenomenon known false sharing caused choosing large units 
effect occur files taken unit sharing 
case access directories cause considerable overhead communication costs 
determination adequate unit sizes important factor developing efficiently working dsm systems 
development dsm applications middleware linda javaspaces support sharing memory way 
javaspaces realizes tuple spaces java objects 
main access operations write read take create new object read object delete object tuple space exists 
object register notified specified object written tuple space 
javaspaces realized top offers possibility invoke methods remote objects 
web applications 
world wide web www created berners lee cern evolving system publishing accessing documents services internet 
commonly available web browsers users web retrieve view documents kind interact unlimited set services 
web application software application accessible web browser user agent 
hyper text transfer protocol defines exactly browser format send request web server 
web hypermedia system resources system linked 
especially idea link led term web 
structure links arbitrarily complex set resources added unlimited web links world wide 
web open system extended new components disturbing existing functionality 
communication web browsers web servers standardized 
second web open respect types resources published shared 
simplest resource web page kind content storable file text postscript pdf format images audio streams web pages usually written html hyper text markup language standardized tag language express content visual formatting web page 
web pages contain parts accept user input called web forms 
nowadays web moved simple web pages encompasses applications line banking line registration kind commerce 
web applications include application server enables system manage business logic 
application server consults updates database processing request 
cgi common gateway interface programs standard way allow web users run applications server 
developers web ap cern european center nuclear research 
plications require application related code run inside browser 
purpose script language javascript quite limited functionality 
going applets downloaded run client 
applets java applications restricted functionality due security issues described called sand box model 
web services special kind web application 
self contained components published located invoked web 
web services perform functions simple requests complicated business processes 
web services services available business web server web users web connected programs 
accelerating creation availability services major web trend 
basic platform web services xml 
top simple object request protocol soap provides protocol specification defines uniform way passing xml encoded data 
dynamically finding web services universal description discovery integration service uddi introduced 
comprises registry discovery facilities web services 
web service definition language wsdl provides way service providers describe basic format web service requests different protocols encodings 
wsdl describe web service resides invoke 
web phenomenal success problems designing web applications 
problems concerning web structure 
hypertext model gets easily dangling links target resources moved deleted 
links resources remain causes frustration users resources anymore 
furthermore information web semi structured users follow confusingly links get lost hyperspace 
meta information web resources helpful support users finding looking 
problem common challenges web applications managing client state server 
due communication client server connectionless communication takes place establishing connection 
server easy job keep track state client service 
relevant information stored client side form called cookies short strings characters 
cookies persistent lifetime browser execution 
mechanism simple totally secure cookies risky service gets access cookies contain personal data identification information 
web applications requires input various user data lot interdependencies line registration conference comprises input personal data conference specific selections accommodation data paying information 
data highly interdependent conference fee dependent user profession selected events date registration 
submitting input data server previous validation means data checked server 
case inconsistencies missing data error message produced user resubmit revised data 
causes high communication traffic distract user service 
better solution validate user input data client side 
web applications usually control user interfaces java applets downloaded application developers aware data interdependencies provide poor user interfaces guiding user validating input completely 
web problems scalability easily occur 
popular server pages may hits second result response users slow 
practice caching browsers proxy servers reduce communication traffic typical web client efficient means keep users date latest versions pages 
users reload pages explicitly check local copy resource valid 
especially longer sessions caching problematic 
caching page expensive intelligent caching needed keeps track important information 
searching web services efficiently wsdl developed 
provides meta structure describe interface signatures support semantical description services form certain kinds constraints 
designing web applications major activities different designing non distributed systems object partitioning clients servers defining web page user interfaces 
usually objects input field validation specialized user interface widgets reside client main business objects exist server 
general objects reside easiest access data collaborations require 
summary requirements distributed applications seldom backed model capturing main design decisions concerning architecture data structure interaction 
modelling technique distributed object computing able cope variety design aspects flexible intuitive way support validation essential properties 
state modelling requirements follow challenges described 
intuitive method 
method support intuitive appealing representation important system aspects 
example natural represent computer networks web page structures visually kind graph structure 
modelling concepts easy learn understand model easily communicated developers customers 
technique provide different views separate system concerns 
views support convenient approach modelled system different stake holders developers customers quality managers 
abstraction levels 
adequate model offer different abstraction levels concentrating main aspects details account 
may ask main entities system interact 
characteristics behaviour 
model help explicit relevant assumptions system modelled discuss possible generalizations designing structures algorithms assumptions 
despite possible heterogeneity key design independent 
concrete systems languages protocols relevant detailed design level 
components 
distributed computing model support component approach 
components clear interaction interfaces main feature handle complex distributed systems 
clearly basis facilitate open systems web consist heterogeneous parts 
add new system part interfaces existing components needed 
component approach supports distributed development system different teams 
altogether components means flexible distributed system architectures essential modelling technique distributed computing 
interaction modelling 
reasoning concurrent execution processes main purposes developing distributed computing model 
modelling technique support natural description concurrent control flow pre post conditions distributed operations 
comprehensive distributed algorithms considering key problems concurrent distributed processes mutual exclusion consensus problems 
furthermore caching replication mechanisms adequately describable 
considering kinds failures occur distributed computing model give possibility express support modelling techniques deal failures high availability system guaranteed 
possibility model reason security strategies protection unauthorized users manipulation corruption resources accessibility resources 
formal semantics 
concurrent process execution easily complex follow main requirements distributed computing model clear formal background reasoning interesting process properties deadlocks progress termination 
distributed computing model offer means describe precisely interesting forms consistency occur distributed shared memory offer means validate modelled system concerning chosen consistency constraints 
considering web applications noticed input data validation important leads kind domain specific consistency constraints 
precise constraint modelling validation support highly desirable improve design decisions adequate consistency model unit sharing dsm 
reconfiguration facilities 
distributed computing model offer possibility model increase resources clients reconfiguration facilities 
testing scalability performance system scales supported 
achieve transparency views definable supporting aspect component oriented selection information 
special modelling requirement comes mobile computing due continuously changing environments concepts modelling system evolution network data structures provided 
standardized technique 
specify document open interfaces high level needed web services distributed computing models help clear understanding 
purpose proven technique standardized 
visual modelling languages nowadays visual languages visual environments emerge increasing frequency 
development driven expectation achieve considerable productivity improvement visual languages tools 
visual languages developed different tasks 
successful system modelling building graphical user interfaces 
visual programming languages visual database query languages developed user acceptance 
subsection consider visual modelling language se unified modeling language uml quasi standard language modelling software systems 
focus especially modelling distributed systems extensions uml chosen presentation concern distributed system issues 
main basis long living open heterogeneous systems suited component concept 
uml offers main approaches components compared 
extensions concerning failures security evolution 
web applications special kind distributed systems web application extension available 
certain aspects missing application specific view concept visual constraint language 
clear concept application specific views needed especially large systems developed engineers different skills background specify system parts distributed manner 
previous discussions requirements distributed system modelling manifested powerful constraint language needed state system invariants expressing consistency constraints express pre postconditions operations services web services build consistent user interfaces input validating web forms 
ocl designed constraint language uml seldom textual quite complicated 
visualization ocl attractive users 
visualization ocl relies uml collaborations 
way integrates better uml textual ocl 
uml visual modelling language mention visual languages distributed system modelling especially model reactive systems 
specification description language sdl developed modelling telecommunication systems petri nets advantageously visualize concurrent control flow especially useful reason distributed algorithms 
concentrate uml comprehensive promising visual modelling language distributed systems 
uml unified modeling language visual modelling software systems object oriented design methodology 
uml accepted standard object management group omg 
uml extensions profile enterprise distributed object computing edoc architecture modelling component diagrams describe logical system structure deployment diagrams handle mapping underlying hardware resources 
edoc profile defines process components ports connections roles kind statecharts chosen model behaviour component 
statecharts contexts behaviour description concurrent processes 
uml defines number diagram types describe static dynamic management aspects system 
twelve kinds diagrams defined uml standard grouped classes 
static structure diagrams 
class diagram graph classifier elements connected various static relationships 
classifier static system constructs classes interfaces packages relationships object diagram instance class diagram indicating static relationships object instances frozen time 
component diagrams meant document structure system 
deployment diagrams show configurations real processing systems 
elements contained deployment diagrams include computers network nodes processes objects connections 
behaviour diagrams 
case diagram shows relationship actors active entities including software elements human users cases usage scenarios system 
formulate requirements 
statechart diagram shows sequences states object goes life cycle response stimuli 
documents object responses actions 
activity diagram variation state machine states activities representing execution operations 
completion operation transitions may triggered 
sequence diagram represents object interaction messages exchanged set objects effect desired result 
collaboration diagram shows interaction objects additionally object relationships 
sequence diagram time visualized collaboration diagram sequence messages concurrency indicated sequence numbers 

model management diagrams 
model management diagrams include packages subsystems models 
uml provides number general mechanisms annotating extending system specifications 
light weight constructs provided stereotypes constraints tagged values 
stereotype new class model element introduced modelling time specializing existing model elements 
generally stereotype indicates usage semantic extension 
constraint semantic relationship model elements specifies invariant conditions propositions 
value attached model element attributes associations tagged values property 
tagged value keyword value pair attached model element 
tagged values permit arbitrary annotation models model elements 
annotation considered extension tagged values precisely defined 
constructs light weight extensions uml contrast change uml metamodel considered heavy weight extension 
extensions elaborated adapt uml requirements distributed system modelling stated subsection important distributed system modelling suited component concept 
main proposals discussed compared 
extensions concerning web applications failures security evolution application specific views 
visualization ocl collaborations 
extension concerns certain system aspect orthogonal meet requirements extensions integrated 
components 
main aspect developing distributed systems design component structure small interfaces possible reduce communication essentials 
basis architecture supporting open heterogeneous systems evolve life time suited component concept 
approach modelling component systems uml specification 
component diagrams proposed purpose 
uml components considered concrete software pieces realize interfaces 
component diagram meant show dependency structure components 
dependencies components usually defined interfaces 
uml component diagrams show classical relation components provided functionality interfaces 
possible state required functionality relation components stating imported 
client navigable replication navigable replication file server modified component diagram required provided ports visual modeling framework distributed object computing gabriele taentzer ports introduced distinguished kinds required provided ports 
consider fig 
shows extended form component diagram required provided ports 
required ports white provided ports black 
relation required provided means provided port meets requirements component 
similarly component collaboration architecture described ports stereotypes classes reside certain components 
component diagram show logical structure components principal 
occurred type form instance form 
newest version uml version type instance level explicitly distinguished components 
important step sufficient component description uml done 
instance form deployment diagram possibly degenerated nodes system distributed 
actual distribution component instances described nodes deployment diagrams 
principle component multiple instantiations particular type interface 
remains unclear valid uml components 
furthermore especially considering open distributed systems reconfiguration architecture runtime important issue 
uml deployment diagrams deal component instances able capture dynamics explicitly 
execution constraints defined instances describe life time 
constraints described tags new destroyed transient advantageously notation reconfiguration 
fig 
simple reconfigurations shown creating new client fileserver instance resp 
migration instance expressed relationship instance old place new place 
connectors components described rudimentary component diagrams 
components dependency relation contain 
detailed description relationships left 
uml profile enterprise distributed object computing edoc specified contains approach component modelling 
profile uses model open distributed processing rm odp conceptual basis 
rm odp follows separation concern principle provides viewpoints system specification enterprise new client client new new fileserver file server new navigable new new replication navigable replication file server file server simple architecture reconfigurations visual modeling framework distributed object computing gabriele taentzer viewpoint contains business model computational viewpoint describes system objects communications information viewpoint specifies information structures processing engineering viewpoint describes distribution relevant design decisions technology viewpoint describing concrete technology hardware software 
uml profile edoc structured component collaboration architecture cca profiles events entities relationships processes 
cca events entities process profiles enterprise computational specification 
information specification uses entities relationships profiles 
cca component model incorporates concepts adapted object oriented role analysis method real time object oriented modeling room 
notion components basis uml components 
cca relies processing components provide composition operation 
components implement arbitrary number protocols needed specify collaboration components messages 
protocols provided ports connection points components 
compositions define components 
build composed components components 
stereotypes classifiers component usages considered templates instances classifier roles 
choice quite natural perfect component instance define additional structure specified type 
uml object instance classifier role include parts classifier define 
port stereotyped class linked owner component 
solution allows ports store kind state possible ports stereotyped interfaces 
longer clear semantic distinction ports components 
connections components stereotyped association roles 
components stereotyped classifiers approach straight forward suited basically describe relationship components 
associations connections supposed modelled independently classifiers storing additional information concerning states roles 
compositions describe component systems stereotyped collaborations 
component usages classifier roles connections association roles choice looks natural semantic mismatch 
collaborations describe representative interaction objects architectural configuration meant capture complete description level abstraction 
summarizing main approaches uml component concept exist uml component diagrams component collaboration architecture 
garlan compare approaches component modelling uml capturing predecessors approaches discussed 
bit date article useful understand precisely characteristics approach uml component diagrams natural approach capturing main aspects components cca approach comprehensive contains semantic mismatches 
due decision provide profile avoid heavy weight extension uml 
combination approaches concepts cca allowing adequate extension uml metamodel promising 
way semantic mismatches avoided relevant component concepts considered 
web application extension 
light weight extension defines set stereotypes tagged values constraints enable model web applications uml 
mirrors approach model web pages classes components different types web pages expressed various stereotypes basic model elements 
principal model element specific web applications web page 
stereotype component contains pages server page client page form frameset stereotypes class 
furthermore special relationships pages defined link frame content submit stereotypes association 
new stereotypes attribute defined input element input text web form 
new stereotypes class component come new graphical notations facilitate reading web models 
failures security 
model failures security issues profiles developed uml 
uml profile models assesses reliability 
failures invented stereotypes events report faults 
faults classified concerning name origin persistence cause error states system 
uml extensions model security issues mainly role control access mechanism 
users roles permissions sessions constraints introduced new stereotypes model access mechanism users get permissions access certain resources dependent roles 
structure behaviour modelled uml new stereotypes 
evolution 
uml extensions evolution rely profiles 
new stereotypes dependency relationships introduced expressing evolving structures 
inference diagrams introduced show trans ownedelement namespace core modelelement core supplier client dependency core view renaming owner extension views related extension uml metamodel formations system structures class diagrams interaction diagram 
evolution contracts added new model elements defined name spaces stereotyped primitive contracts addition connection removal disconnection complex contracts 
application specific views 
views uml aspect oriented manifest variety diagram types 
way views completely independent applications modelled uml 
example team application engineers different skills backgrounds splitted subgroups specify aspect system seen certain type user application specific views definable 
integrating different views name conflicts name different concepts different names concept arise 
views overlap behaviour specification synchronized 
detailed motivation semantic concepts view concepts 
concentrate discussion syntax views form uml metamodel extension 
chapter take view discussion combine view component concepts semantically 
adequately handle application specific views extension uml metamodel proposed views introduced new model elements 
uml metamodel view supposed stereotype namespace contain kind model element 
kinds relationships basically views renamings extensions 
stereotypes dependency proposed renaming extension meaning view renames extends view resp 
see views related extension uml metamodel 
views supposed graphical notation 
influence graphical representation uml model tool tree form notations 
visualization ocl 
negotiation component interfaces crucial issue open distributed systems 
stating signature aspect oriented views occur explicitly uml metamodel 
ocl constraint birth date comes date moving apartment 
loose additional constraints form invariants pre postconditions methods operations help fixing important properties fulfilled interface 
originally constraint language uml 
lack realized ocl object constraint language proposed purpose 
unfortunately ocl textual language look attractive software developers 
fit uml better integrated relying collaborations 
visualize ocl basis collaborations integrate uml ocl metamodel larger extent current ocl specification 
visualization ocl departs uml collaborations 
visualization navigation paths object structures uses classifier association roles collaboration diagrams 
visualization navigation paths helps developer maintain overview forcing reformulation visually object structure completely different syntax done ocl textual notation 
visualization adapts notation uml core elements 
alternative proposal visualize ocl constraint diagrams evolution spider diagrams collaborations extend venn diagrams euler circles 
approach graphical elements uml core 
example show sample constraint taken project berlin germany 
project objective replace software residents registration offices berlin new exploiting internet technologies 
citizens authorities shall possibility perform typical business processes registration inhabitants web forms 
especially kind applications correctness inputs plays important role 
visual constraint language meant help software developers easily formulate input constraints unambiguously 
shows visualized ocl constraint object properties 
constraint stated natural language textual ocl 
context inv self birth self address number visual shortcuts introduced pre defined operations support compact notation ocl constraints 
ocl built types primitive integer boolean strings collections sequences sets bags 
typeexp type type classifier collected type base collaboration interaction message action datatype modelelement ownedelement source constraint sender receiver ownedelement 
metamodel ocl collaborations textual ocl metamodel developed building metamodel uml 
ocl metamodel adapted visual ocl 
visual textual notations ocl parallel 
visualization collaborations shows metamodels uml ocl integrated property operation expressions described collaborations 
contains main model elements ocl metamodel collaborations 
addition new proposed 
express non existence certain collaboration parts 
semantics 
due status quasi standard modelling language software systems enormous number extensions elaborated uml suited system modelling 
article focus promising extensions distributed system modelling 
seen main aspects distributed systems modelled 
validation uml provide formal basis 
uml metamodel offers semi formal approach concentrates definition syntax uml 
hundreds researchers proposed formal semantics relying various formalisms restricted parts uml 
kernel researchers organized precise uml group 
main aim group define standard semantics uml precise 
section discuss distributed graph transformation serve precise semantic domain uml focussing distributed system issues 
visual language definition parsing syntax uml defined metamodel class diagram describes model elements relationships available principle 
ocl formulate formedness rules syntax structure restrict allowed structures meaningful ones 
consequently syntax concrete uml model instance metamodel diagram containing model element instances 
concrete syntax uml document called uml notation describing concepts natural language showing diagrammatic representations 
interrelation concrete syntax left vague 
visual languages uml considered rigor visual language vl theory 
number questions problems arise visual languages answered textual languages 
visual languages different tasks clear define term visual language 
surely visual languages possess multi dimensional representation language elements 
diagrams graphics called visual sentences consist set visual symbols graphic primitives icons pictures set relations inside 
textual visual notions syntax visual sentences 
textual notations multi dimensional representations coded dimensional strings convenient 
visual notation uml metamodel instances sort graph looks natural 
information concerning concrete representation added attributes 
visual languages formally defined grammar approach picture layout grammars constraint multiset grammars positional grammars kind constraints logics 
uml metamodel belongs constraint approaches 
standard formalism backus naur form textual languages missing define vl syntax semantics 
theory visual languages especially concerning language hierarchy parsing algorithms oriented pendant textual languages 
main subclass context free distinguished allows efficient parsing 
constraint formalisms provide declarative approach vl definition grammars constructive closer implementation 
special case ocl constraints translated certain graph grammar approach support constructive constraint checking 
due appealing visual form graph grammars directly high level visual meta modelling mechanism 
considering visual sentences graphs graph grammar defines language grammar 
graph language determines visual language 
comprehensively application graph transformation visual language definition parsing 
consider graph transformation approach vl definition closely discuss main properties 
short graph transformation general 
graph transformation 
graph transformation computational paradigm combines potentials advantages graphs rules 
graphs known means represent kind structure system states object structures computer networks entity relationship diagrams flow charts rules clear concept describe structure changes general 
computations logic functional programming language definitions term rewriting concurrent processes prominent example rules 
graph transformation combines concepts graphs rules providing rule manipulation graphs 
gives overview main approaches graph transformation 
formalized basis set theory algebra logics category theory 
articles comprehensive collection graph transformation applications particularly concurrent distributed system specification 
graph transformation independently particular graph transformation approach independently certain kind graphs rules specific way rule application 
article particularly interesting readers want know graph transformation works applied principle 
concept transformation units introduced article 
offers structuring principle building large graph transformation specifications smaller ones 
transformation units encapsulate mainly rules control conditions 
semantically application rules transformation unit may interleaved transformation units 
article graph transformation occur serve different purposes 
especially meta modelling paradigm graph transformation promising 
visual language definition parsing translating visual language semantic domain enable model validation described section 
semantic domain graph transformation suited compare section 
defining syntax visual languages graph grammars 
sentences visual languages may regarded assemblies pictorial objects spatial relationships structures kind graph 
distinguish spatial relationship graphs srg describe structure visual sentence seen picture graph called syntax graph asg 
asg provides information syntax visual sentence succinct form 
oriented interpretation compilation regarded sentence 
distinction introduced inspired model view controller concept smalltalk traditional distinction concrete syntax textual languages 
graphs graph grammars natural means vl concept graph grammars uml metamodel visual sentence concrete syntax srg visual sentence syntax asg metamodel instance interrelation concrete graph translation vl definition graph grammar uml metamodel table comparison graph grammar uml metamodel concepts defining concrete syntax visual languages 
contrast approaches vl definition graph grammar approaches nodes edges describe objects kind interrelationships 
additional attributes describe information layout visual objects relations semantics 
different approaches vl definition diagen relying hypergraph grammars genged attributed graph transformation 
approaches graphs describe graphic structures concrete layout specified graphical constraints graph algorithms 
graph grammars define translation srg asg low level parsing high level parsing asg solving membership problem 
concrete parsing approach graph transformation 
approach possible formally define concrete syntax vl interrelation graph translation 
table comparison graph grammar uml metamodel concepts vl definition 
happens structures similar class diagrams 
case convenient graph structure differ sets attributes concrete syntax definition 
parts uml defined diagen genged class diagrams statecharts showing graph grammar approach promising follow 
graph grammar approach vl definition diagen genged corresponding tools comprise general parsing algorithms check membership problem concrete vl sentence 
changing vl graph grammar automatically adjusts parsing process changed vl 
theoretical results concerning independence graph rule applications profitably applied efficiently parsing context free restricted languages 
model validation general requirement modelling technique distributed systems clear formal background possibility reason interesting properties 
example fault tolerance trace properties deadlocks termination play important role distributed systems 
interesting validation issue distributed systems performance main motivations build distributed systems sharing resources 
today resource sharing taken granted performance analysers developed 
data sharing challenge leads new kinds problems 
possibility concurrent updates easily lead inconsistencies 
hand important data replicated guarantee fast access 
data replication leads problems inconsistency solved adequately 
consistency issues investigated literature 
adequate techniques guarantee consistency central part author contributions concerning model validation 
syntactic consistency checks uml considered section semantic consistency discussed section 
uml semi formal modelling language uml metamodel defines syntax uml providing class diagram containing model elements interrelations formedness rules restrict set allowed models 
consistencies aspect oriented views consistency conditions mainly captured formedness rules 
distribution domain specific consistencies formulated ocl uml standard describes semantics quite vaguely natural language 
various approaches define precise semantics uml sublanguages 
general semantic domain chosen depends heavily validation issues taken account 
natural semantics concentrating validation specific properties 
means particular semantic domain changed property analysed 
section selected validation techniques uml mentioned putting main emphasis distribution issues 
pointed increasing need model translation semantic domains 
literature number approaches grammar logic approach 
promising approach automatic model translation graph transformation 
syntax graphs translated semantic graphs expressions applying graph transformation rules 
contrast approaches translation rules completely visually developed 
author partly concerned development translation concepts approach closely section 
validation issues performance quality service 
performance analysis primary interests modelling distributed systems 
performance issues arise limited processing communication capacities computers networks 
comprise responsiveness throughput balancing computational loads 
remote service fast consistent response required 
response time dependent factors load performance server needed network delay caused software component 
especially considering web services fast responses better achieved intelligent caching mechanisms 
traditional measure performance computer systems put rate computational done 
distributed systems throughput measured processing speeds clients servers data transfer rates 
discovering throughput differs heavily different users tasks hosts computational loads balanced 
load balancing exploits available resources better enables better service 
heavily web service search engine hosted computers provide acceptable service 
notion quality service qos formed refer ability system meet time limits especially transmitting real time multimedia data 
qos comprises reliability security performance 
adaptability added meaning ability meet changing environments recognized important aspect service quality 
mobile computing load balancing mechanisms flexible traditional intranets meet fast changing requirements 
consistency 
distributed systems modelled different views uml extensions application specific views 
view concentrates subset system aspects 
especially distributed teams developing system views inconsistencies different views inter viewpoint inconsistencies easily occur 
inside view called viewpoint inconsistencies taken account 
data consistency mainly application specific distribution specific issues 
typical technique performance enhancement replication hardware software resource including data replication 
consistent data replication key aspect considering distributed shared memory model 
degree consistency varies widely depends heavily data replication 
authentication data consistent achieve high security level especially area web applications commerce applications 
data change immediately propagated replication servers subsequent actions performed 
hand mobile computing changes location data supposed handled promptly discovery services allowed respond suboptimal restrict communication traffic 
notions consistency formed compare linearizable processes replicated data meet correctness criteria real times executions corresponding processes non replicated data 
distributed systems synchronize clocks accuracy linearizable processes difficult meet 
weaker correctness condition sequential consistency captures requirement order action processing appealing real time 
sequentially consistent data structures costly implement weaker forms consistency developed 
coherence means processes agree order data manipulations part data necessarily agree order data manipulations different data parts 
weakest form weak consistency data possible knowledge synchronization exploited 
model relaxes consistency temporarily appearing user implement sequential consistency 
data locked inconsistent long lock exists user access 
replications locked data part consistent lock released 
typically distributed systems distributed data structures accessed concurrently 
shared data usually accessed distributed transactions implementing weak consistency 
trace properties fault tolerance 
basic trace properties concerned action conflicts dependencies 
actions conflict execution action prohibits execution 
hand action dependent executed executed 
general trace properties described sets action sequences distinguished safety liveness properties 
safety property asserts bad happens execution process reaches bad state 
liveness property asserts eventually happen process eventually reaches state 
sequential processes important safety property correctness process final state correct whilst important liveness property termination process eventually terminates 
distributed systems dealing systems may partially fail may supposed terminate 
safety liveness properties interest 
additional important examples safety properties mutual exclusion absence deadlocks livelocks 
mutual exclusion great interest resources shared 
matter resource printer data changed process accessing resource time 
coordinating mutual exclusion activities process executions may come deadlock meaning processes continue execution livelock processes continue executions really getting done 
additional important kind liveness properties progress properties 
allow assert matter state system case specified action eventually occur 
progress properties essential considering mutual exclusion processes coordinated process accesses shared resource 
trace properties interesting process communication failures occur 
process communication failed system supposed continue correctly 
case called fault tolerant 
validation techniques uml introducing validation properties play important role distributed system validation discuss selected validation techniques developed uml 
exist various approaches validate uml models literature 
selected approaches promising support validation distributed system properties 
syntax checks 
consistency problems fold syntactic consistency ensures uml model correct wrt 
metamodel semantic consistency presumes model translation semantic domain 
consistency condition formulated domain checkable 
semantic consistency considered paragraph 
syntactic language specific consistencies formulated formedness rules ocl constraints metamodel instances 
constraint context defined specific model element 
showed language specific constraints constructively checked translating graph rules graph transformation units see section resp 
language consistency uml model checked testing applicability resulting rules transformation units syntax graph showing instance uml metamodel 
rules transformation units applicable instances context model elements uml model consistent 
model element instance specific rule transformation unit non applicable reported inconsistent corresponding ocl constraint 
approach formal semantics ocl 
relies algebraic specifications discussion define standard semantics ocl 
comes nice tool tool supporting constraint checking uml models 
unfortunately ocl metamodel proposed loosely coupled uml metamodel better integrated collaborations see 
promising approach distributed graph transformation formulate inter viewpoint consistency checks 
consistency checking performed applying graph rules syntax graphs 
view modelled separately inter viewpoint checks result synchronized graph transformations interrelated syntax graphs 
approach consistency distributed specifications checked automatically xml technologies 
semantic models 
hundreds approaches exist give uml formal semantics 
hand gain insight precise meaning uml notations diagrams 
hand formal semantics necessary prerequisite check important properties uml model 
especially algebraic specification techniques chosen build formal model uml 
declared aim precise uml group come precise standard semantics language uml verification purposes 
various approaches formalize certain aspect uml formal technique precision formal reasoning 
especially behaviour diagrams considered translated process algebras state machines labelled transition systems umlaut vuml model checking purposes 
uml behaviour diagrams translate stochastic timed petri nets processes showing quality service 
provided formalizations comprise subset model aspects show specific properties 
formal semantics stated rigorous translation syntax semantic domain missing 
case said correctness translation 
considering automatic translation reason functional behaviour 
subsection argue graph transformation suited serve purpose 
model translation graph transformation model translation graph transformation natural popular approach done number researchers :10.1.1.18.3061
graph transformation applied meta level syntax graph input producing semantic domain model output 
translation approaches vary input output formats dependent visual language semantic domain chosen 
different approaches graph transformation dependent concepts theoretical results needed personal preferences researchers 
translation approaches referred illustrated proven concrete translation scenarios 
approach examined kinds diagrams structured analysis iec function block diagrams subset uml control nets lemma language medical model analysis 
semantic domain diagram types high level timed petri nets 
lara report translation non deterministic finite automata deterministic ones statecharts sort petri nets 
presents translation message sequence charts partial order events refers translation uml statecharts extended hierarchical automata 
algebraic graph transformation approach chosen 
illustrated subset uml state diagrams translated csp 
consider approach closely 
related approaches formal definition graph transformation define translation rules exploits theory 
informal semi formal language translated formal domain giving formal semantics language way 
useless reason correctness vl translation sense model equivalence 
sense ask functional behaviour model translation show confluence termination translations case 
repeated model translation lead different results model translation give result terminating 
consider critical pair analysis show confluence attributed graph transformation systems apply translation uml statecharts csp 
critical pair analysis computes minimal conflicting situations minimal case tool graph transformation back translation validation tool model translation validation purposes sense unnecessary context 
show critical pairs joined rule applications lead common result graph graph transformation system confluent 
model translation useful mainly reasons validation models code generation 
considering model translation validation purposes model created case tool 
certain point model developer ask important model properties going pure syntax checks 
starting point translating model semantic domain dependent properties examined 
translation separate validation tool started gets translated model input 
validation result produced translated back useful developer 
general procedure depicted 
code generation similar procedure easier perform back translation necessary 
support wide range model translations common exchange formats case tools graph transformation engines validation tools needed 
case tools especially uml case tools xml format xmi xml metadata interchange quasi standard 
graph transformation engines graph tools initiative started develop common exchange format graphs called gxl xml 
validation tools common exchange format taken consideration eti initiative electronic tool integration platform www eti service org 
common exchange formats graph tools 
graphs general data structure various fields computer science variety graph tools exist 
increase interoperability gxl common exchange format graphs developed basis xml 
gxl allows store logical structure nearly kinds graphs typed attributed graphs hyperedges hierarchical graphs 
layout graphs stored svg xml format scalable vector graphics 
discussing tool support model transformation graph transformation gxl play key role 
considered central format translating model 
assuming case tool producing xmi output xml stylesheet xsl transformation produce gxl input model translator 
xsl transformation kind xml format gxl straight forward underlying structure tree 
sense tags interpreted nodes translated nodes connected corresponding parent node 
interpreting tag edges leads proper graph structure 
considering formats xmi case tool validation tool xmi model xsl xsl gxl model formal model graph transformation engine refined model translation xml verbose transformed simple way 
stylesheet additionally compress information adequately 
model translation formal model input format corresponding validation tool produced compute actual validation 
validation result back translated input format case tool 
back translation looks dependent kind result 
tool chain illustrated 
top gxl core exchange format graph transformation systems developed interchange graph transformation systems 
discussing graph transformation semantic model domain section supposed target format model translations input format graph transformation tools performing validations 
graph transformation validation domain hand graphs general means formalize kind system structures hand clear visualization suited intuitively system structures 
graph transformation describe system model graphs usually taken describe static system structures component object structures deployments 
system behaviour expressed state changes modelled rule graph manipulations graph transformation 
rules describe pre postconditions single transformation steps 
order steps describes temporal causal dependency actions 
graph transformation paradigm formal intuitive time attractive framework reason system properties 
section additional structuring concepts discussed graph transformation yielding comprehensive formalism designed define important system concepts properties see section 
validation techniques developed graph transformation applied formal semantic model show conflicts dependencies actions structural consistencies section 
structured graphs graph transformation modelling complex systems distributed systems usually variety structuring principles developed graph transformation paradigm 
parallel distributed graph transformation structure rule applications temporal spatial dimensions 
distributed graphs contain additional structure graphs 
top basic structuring concepts rules graphs component concepts define partitioning graph transformation systems subsystems 
views helpful structure system different aspects localities 
parallelism distribution 
excellent dpo approach graph transformation worthwhile get comprehensive overview important results concerning approach 
introducing basic concepts graphs rule transformation graphs graph transformation systems defined tuples type graph start graph set rules 
basic form graph transformation rule applied sequentially 
considering parallel transformation different approaches 
stick sequential execution parallel transformations modelled interleaving arbitrarily atomic actions 
interleaving leads result atomic actions independent 
simultaneous execution actions modelled parallel rule composed actions 
atomic actions independent synchronize common subaction composed socalled amalgamated rule models concurrent execution atomic actions subaction executed 
amalgamated transformations generalize parallel transformations additional synchronization mechanism 
parallel graph transformation steps restricted rule applications parallel 
author extended theory arbitrary number parallel rule applications showed amalgamated rule application leading back basic graph transformation step 
distributed graph transformation discussed simple approach 
graphs allowed split local graphs local transformations local graphs joined global graph 
theory extended author directions splitting graphs common interface graph considered 
general topologies allowed kinds network structures possible 
network graph part distributed graph structured graph levels 
network node refined local graph network edge refined local graph morphism 
formally distributed graph diagram category graph 
second splitting joining graphs needed change distribution structure 
network transformations usual graph transformations network level arbitrary network changes 
third complex synchronizations arbitrary number local graphs described fourth local transformations parallel transformations 
parallel graph transformation special case distributed graph amalgamation parallel graph transformation graph transformation special case special case join special case join amalgamation distributed graph transformation interrelation graph transformation concepts transformation host graph non distributed 
way round distributed host graph joined graph leading parallel transformation 
additionally distributed rule match amalgamated rule match simple graph transformation step 
want keep distribution structure distributed graph considered simple graph network graph refinement flattened simple graph parts special types 
similarly distributed graph rules flattened usual graph rules 
kind reducing distributed graph transformation non distributed graph transformation interesting applying validation techniques graph transformation directly available distributed case 
vice versa obvious simple graph transformation special case distributed transformation graphs rules 
graph transformation interrelations summarized 
theory distributed graph transformation extended attributes nodes edges application conditions distributed rules 
extensions necessary provide sound formal basis reasoning distributed systems 
components 
years variety structuring concepts graph transformation systems developed 
overview classification concepts 
structuring concepts graph transformation systems differ heavily features notions 
called modules packages components support kind information hiding 
export interface declared provides structural behavioural information body hides remaining parts 
connections entities realized export interface entities implement import interface 
component concept graph transformation systems discussed follows distributed semantics components 
semantically components active processes semantics restricted new interconnection components 
component concept origin diego approach relies directly distributed graph transformation 
graph transformation system gts component consists body gts set import gts ii set export gts ej embedding morphism embedding morphisms relate type start graphs rules 
note body rules correspondence import export gts 
composition gts components embedding morphisms added import export gts leading import export relation 
embedding morphism usual gts morphism 
import form import composed gts export export interfaces 
component rules related embedding morphisms applied simultaneously 
composition details described gts components connections component interfaces define local views 
views 
view concepts developed graph transformation type oriented instance oriented approach 
type oriented approach followed describe system different aspects 
approach typed graph transformation allows describe set graphs type graph 
types view specifies partially system states behaviour 
may happen action performed view concurrently coupled actions views ensure consistent state manipulation 
view specifies happen system state semantics loose 
actions views may needed complete system behaviour 
views developed independently inconsistencies concerning names occur solved view integrated 
automatic integration algorithm applied presuming common model underlies views specifies correspondences model elements different views 
prerequisites needed automatic view integration possible rename views different names concepts different views 
furthermore extension views defined componentwise types actions type sets extended subaction relation established 
instance oriented approach views considered different local systems distinguished 
local system described gts component defines local view 
body import export interfaces remote interfaces connected comprised local view 
local views overlap interfaces interrelations 
local view shows system part described component 
considering local action actions components needed model synchronized system behaviour 
synchronization done amalgamating local view rules common interface rules 
synchronization local view rules synchronized possible resulting amalgamated rule unbound interface rules 
lifetime system new local views show old local views vanish corresponding components created deleted 
local views directly rely distributed gts components formal semantics distributed graph transformation 
kinds views orthogonal easily combined considering aspect oriented views distributed systems 
case component component aspect aspect aspect aspect aspect aspect aspect aspect aspect aspect aspect aspect local view local view schematic example combined view concepts aspect oriented view concepts distributed graph transformation defines straight forward extension 
way part local view body import export interfaces aspect oriented 
schematic example view combination see 
distributed graph transformation semantic domain discuss key concepts distributed object systems show mapped corresponding graph transformation concepts 
draw connections corresponding model elements uml 
discussion shows graph transformation distributed graph transformation expressive adequate formal framework visual modelling distributed object systems powerful give semantics key aspects adequate abstraction 
yields concise basis comparison semantic models 
priority complete precise mapping vl syntax uml metamodel semantic domain dependent validation techniques available domain 
section consider validation techniques graph transformation need partial model translations 
intuitive formal semantics 
graph transformation precise formalisms come intuitive appealing graphical representation structures 
states state changes visualized provide easy access semantics discussion 
type instance oriented view concepts available graph transformation allow concentrate certain system parts concerns time 
abstraction levels 
abstraction levels offered distributed graph transformation concentrate system architecture refine object level 
system architecture reconfiguration described network level 
network nodes distinguished component interface nodes containing refinement corresponding system part 
refinement belonging object level models kind object structures manipulation 
abstraction hierarchy clearly structure oriented suits uml 
complemented behaviour refinement defined transformation units 
combination transformation units distributed graph transformation discussed 
advantageously formalize uml cases main interdependencies case relations 
discuss refinement cases activity diagrams formalization graph rules 
components reconfiguration 
gts components developed central concept describe subsystems distributed systems 
gts component consists body gts sets interface define views body gts 
considering cca part uml profile edoc see subsection processing components modelled gts components interface provide connection points components play role ports 
mapping ports interface allows ports semantic state 
simple connections components mapped embedding morphisms import export 
complex connections defining protocols different roles mapped separate gts components semantically 
cca distinguishes components type instance level 
component instances called component usages mapped template distributed graphs called component graphs semantically describing component usage certain state 
compositions considered template distributed graphs glued single component graphs overlap interfaces state 
component reconfigurations uml described collaborations translated network rules 
restricting simple collaborations containing action translation done follows left hand rule side contains parts reconfiguration annotated new right hand side annotated destroyed 
partial graph morphism left right hand side relates part destroyed new 
complex reconfigurations modelled network rules applied certain order control 
rules reconfiguration concurrency issues addressed conflicts dependencies naturally expressed 
special form reconfiguration scaling modelled applying creating network rules 
way new basis performance tests laid graph transformation paradigm 
case real time constraints time attributes added certain node types done 
views 
kinds view concepts distinguished graph transformation systems type oriented views concentrate certain aspects instance oriented views local views components 
type oriented views common visual languages 
usually expressed different kinds diagrams uml twelve kinds diagrams model software systems different perspectives 
additionally application specific views section semantically mapped type oriented views 
uml model different views integrated model gluing common model element instances 
instance oriented views play important role approaching system implementation 
concrete instances components packages classes objects distributed certain network nodes interconnected 
uml offers deployment diagrams model kind distribution 
classes objects 
syntax class diagram considered graph structure 
describes types objects links occurring object system 
map class diagrams type graphs 
classes mapped nodes associations association classes mapped edges type graph 
association class represented node arcs class nodes association relates hyperedge class nodes 
generalization directly mapped inheritance hierarchy flattened associations parent class features prolonged child classes 
class nodes may attributed attribute specified type name possible default value 
multiplicities associations constraints result additional graph constraints checked instance graph type graph compatible 
object structures expressed templates instance graphs representing object structure certain state 
object structure consistent class structure corresponding instance graphs type compatible corresponding type graph satisfy additional graph constraints 
object interaction 
various kinds behaviour models distributed systems 
uml types diagrams describe different aspects behaviour 
uml certain subset common behaviour concepts distinguished forms basis reason behaviour 
behaviour considered instance level objects links 
correspondingly instance graphs semantically 
graph transformation paradigm concept express dynamics rules formulate preconditions effects action 
dependent certain events considered triggers rule application state transitions performed graph transformations 
object collaborations formalized similarly component reconfigurations 
collaborations restricted action mapped rule left hand side rule contains parts collaboration annotated new target relation 
righthand side contains annotated destroyed source relation 
partial graph morphism left right hand side relates copies part destroyed new object nodes related relation 
complex collaborations mapped rules control flow specified 
parallel actions modelled collaboration mapped parallel rules 
graph transformation explicitly model failures 
purpose special rule triggers failure events considered cause application certain error actions actions 
action changes state local system way action performed 
furthermore security issues resulting set new stereotypes uml semantically graph transformation leading new types objects dependencies 
known role security mechanism specified graph transformation 
altogether rule concept graph transformation provides clear concept define system behaviour 
especially modelling intrinsic concurrency actions graph rules adequate means explicate structural interdependencies 
additional control flow rule application defined control conditions transformation units support nice visualization control flow structures far 
constraints 
constraints occur different places system models 
simple ones translated graph constraints complex ones translated rules transformation units 
graph constraints originally 
consider constraints class diagrams describe object structures allowed 
furthermore occur kind invariant pre postcondition operations guards state transitions collaborations ocl defined extension uml providing constraint language object systems 
explanations formulated translation ocl please note basic ideas approach independent concrete language ocl apply constraint language 
showed ocl constraints translated graph rules transformation units 
constraint defined concerning certain model element specified context 
invariants pre post conditions special kinds constraints specify translated constraint checked corresponding rules transformation units tried applied certain instance graph 
means invariant corresponding graph rules transformation units applicable instances nodes context model element corresponding constraint semantically consistent inconsistency 
approach base ocl heavily collaborations suits semantic interpretation 
described collaborations semantically explained rules transformation units 
pre defined types operations collections operations forall select exist mapped special object types pre defined transformation units 
evolution 
model evolution viewed process transformations applied successively system model 
semantically describe distributed system distributed graph transformation system 
model evolution means transformation 
transformation defined component wise contain simple transformation concepts complex ones 
evolution static structures classes structures easily describe 
called inference diagrams class diagrams directly interpreted graph transformations 
evolution behaviour difficult formalize graph transformation domain 
follow ideas transforming graph grammars means applying rules rules particular 
approach describe behaviour evolution promising worthwhile elaborated 
automatic model translation 
far discussed semantic mapping distributed object computing model uml metamodel instance particular distributed graph transformation 
previous section proposed graph transformation formulate automatic model translation 
course approach followed semantic domain distributed graph transformation 
point pay attention formulation translation rules functions target structure distributed graph transformation system considered graph 
big problem kind structure considered graph 
subsection consider validation techniques offered graph transformation advantageously distributed system validation 
way get clear view partial model translations worthwhile elaborated supplying translating graph transformation system 
validation support graph transformation consider validation techniques available graph transformation 
techniques elaborated non distributed graph transformation distributed graph transformation slightly restricted way 
distributed graphs joined distributed rules amalgamated resulting graph transformation systems validation 
positive statements consistency independencies valid original distributed graph transformation system 
inconsistencies conflicts sequential dependencies transferred distribution structure flattened validation 
conflicts dependencies 
validation technique notion independence graph transformations captures idea situation transformations conflict causally dependent 
distinguish parallel independence absence conflicts sequential independence absence causal dependencies 
notions exists weak asymmetric strong symmetric version see survey 
transformations mutually independent applied order yielding result 
case speak parallel independence 
alternative transformations independent second second disable 
case steps conflict 
lay focus static analysis potential conflicts dependencies run time analysis 
notions lifted level rules 
computation potential conflicts dependencies idea critical pair analysis known term rewriting 
usually technique check rewriting system functional behaviour especially locally confluent 
critical pairs generalized graph rewriting extended attributed graph transformation 
formalize idea minimal example conflicting situation 
set critical pairs extract objects links cause conflicts dependencies 
critical pair analysis detect conflicting functional requirements case driven approach 
graph transformation ideal framework reason concurrent computations 
graph processes defined containing partial order rule applications results causal dependency analysis 
event structure semantics proposed restricted graph transformation abstracting concrete transformations 
just models collection events relations causal dependency conflict 
kind graph transformation considered restricted way reactive behaviour pro active modelled 
considering example distributed version control ensure configurations documents checked synchronized way 
purpose lock created prohibiting application rules check started 
means applications rules start check conflict 
performing rule applications prohibits long lock released 
critical pair analysis finds conflicts analysed system designer 
mutual exclusion resources intended corresponding critical pairs desired show conflicts 
critical pairs give information conflicting situations desired conflicts check rules 
structural consistency checking 
graph constraints describe basic consistency conditions graphs existence non existence uniqueness certain graph parts 
example multiplicity constraints occur uml class diagrams translated graph constraints compare 
graph transformation system consistent wrt 
set graph constraints start graph satisfies constraints rules preserve 
algorithm developed checks rule preserves constraints 
constraint preserved new preconditions generated rule restricting applicability consistency ensured 
procedure extended attributed graph transformation 
complex consistency conditions existence paths cycles arbitrary length typical graph properties formulated set transformation units encode constructive approach consistency 
transformation units allow definition initial graph class advantageously formulate consistency checking triggered 
example consistency checking useful new instance certain node edge type created existence bound number conditions 
considering application specific consistency distribution issues irrelevant consistency checking amalgamated distributed graph transformation system provide simple satisfactory procedure kind consistency 
consistency condition uniqueness document names revision archive type 
formulated simple graph constraint allowing graphs document nodes having name 
distribution specific consistency deals directly replication sharing issues 
example postulate document configurations replicated completely revision archives 
furthermore sure document replicated times archive 
reason distribution specific consistency translate model completely domain distributed graph transformation translate replication structures modifications 
application specific attributes needed kind validation 
distributed graph transformation implicitly supports coherence compare section due rule character behaviour specification 
rules operating different graph parts disturb independent applied order 
stronger forms consistency sequential consistency realized additional graph structure enforcing deterministic order rule applications 
weak consistency occurs distributed transactions modelled distributed graph transformation 
tool support agg 
agg general tool environment algebraic graph transformation supports visual editing simulation graph transformation systems validation 
special power comes flexible attribution concept 
agg graphs allowed attributed kind java objects 
graph transformations equipped arbitrary computations java objects described java expressions 
agg environment consists graphical user interface comprising visual editors interpreter set validation tools 
critical pair analyser graph parser consistency checker graph constraints 
implementation agg follows known model view control concept kernel flexibly graphical user interface api agg incorporated graph transformation application 
kernel concepts agg comprehensively described 
extended validation techniques described 
agg mainly validation tool xml interface important connect agg case tool pointed section 
current version agg tfs cs tu berlin de agg 
summary papers submitted habilitation thesis survey state art visual modeling validation distributed systems focussing uml visual language graph transformation semantic domain validation 
description main challenges developing distributed system resulting requirements distributed system modelling presentation uml variety extensions description validation issues techniques graph transformation semantic domain drawn wide picture research activities field 
section gives summary author achievements relevant research visual modelling validation distributed systems 
subsections summarizes papers submitted habilitation thesis 
papers cover relevant contributions author concerning visual modelling validation distributed systems 
visual modelling framework distributed object computing author outlines central framework habilitation thesis 
stating main requirements distributed system modelling fragment slightly extended uml focussing architecture interaction modelling 
distributed graph transformation introduced semantic domain semantics architecture object interaction models network graphs transformations object graphs transformations 
graph transformation system components introduced describe distributed components interaction 
related automata simple formal models reasoning distributed algorithms 
sense theory automata applicable restricted graph transformation systems useful reason concurrency issues distributed systems 
consistency checking visualization ocl constraints constraint language ocl important extension uml formulate invariants pre post conditions guards 
unfortunately textual quite unintuitive form precise semantics 
taentzer developed main concepts visualize ocl basis collaborations discussed authors 
suggested closer integration uml ocl metamodels possible relying collaborations 
visualization elaborated captures main concepts ocl 
authors consider consistency checking ocl constraints translating ocl constraints graph rules transformation units 
check consistency uml model applicability resulting graph rules transformation units syntax graph model tested 
rules transformation units applicable instances constrained model elements uml model consistent 
inconsistency reported 
application graph transformation visual languages show graph transformation applied visual languages metamodel level graph transformation define visual languages 
graphs suited describe multi dimensional structure visual sentences diagrams graphics 
similarly textual languages grammar defines visual language terms graph language 
general concept visual language definition distinguishes spatial relations graphs describes structure visual sentence seen picture syntax graphs 
graph grammars define translation srg asg low level parsing highlevel parsing asg solving membership problem 
considering genged approach visual language definition developed guidance taentzer generalized form graphs graph structures describe visual sentences 
graphical layout visual sentences described graph attributes graphical constraints 
genged environment supports visual definition visual language generates corresponding visual editor visual simulator 
editor offers syntax directed editing mode free hand editing parsing facilities 
genged graph transformation engine agg developed leadership author 
genged approach advantageously define visual ocl concepts described 
way visual editor consistency checker generated 
hand graph transformation languages provide visual modelling high level programming language underlying data model graph 
graph rules sophisticated control structures rule application describe data manipulation 
general purpose languages progres agg sch rr taentzer 
furthermore languages visual language definition diagen genged minas 
languages discussed compared authors 
combined model view approach system specification graph transformation specification technique combines view approach 
formal notion views view relations developed behaviour views described loose semantics 
integration views common model considered heckel taentzer 
view integration dependencies views model determined 
model extended model manager 
views common model consistent actual view integration performed automatically 
addition extensions basic integration scenario discussed 
heckel taentzer illustrated concepts running example banking system 
application specific views uml defined section 
semantically views defined graph transformation systems compare section 
distributed graphs graph transformation author presents formal framework distributed graphs graph transformation 
defines structured graph transformation abstraction levels network local level 
network level contains description topological structure system 
local level covers description states transitions 
way state distributed system represented number distributed states partly dependent 
state transitions local distributed synchronized common 
modelling distributed systems way offers clear appealing description due visual form number concepts allow describe main concepts distributed systems complex distributed data structures dynamic networks distributed actions communication synchronization 
formalization category theory category distr graph distributed graphs graph morphisms 
distributed graph transformation step characterized double pushout category constructed component wise local graph reflect distributed computations best 
component wise transformations exist certain conditions called distributed gluing conditions satisfied lead unique result 
distributed graph transformation application visual design distributed systems having formal framework distributed graph transformation hand visually describe key design distributed system 
support precise modelling network data interaction issues basic formalism extended attributes application conditions rules 
done koch guidance taentzer 
approach network graphs attributed labelled network morphisms injective rules occurrences facilitate component wise rule application 
resulting framework informally introduced illustrated examples taentzer show main aspects distributed systems expressed distributed graph transformation 
uml notation employed examples software developers familiar objectoriented modelling techniques easily understand distributed graph transformation visually model distributed systems 
fischer developed larger application guidance taentzer 
application distributed version management system revision archives distributed network build distributed shared memory system 
revision archive contains documents relevant site 
provides service versioning local workspaces supports replication sites 
system designed open system number connections revision archives may evolve 
agg approach language environment agg considered visual modelling high level programming language modelling kernel data structures software systems graphs 
agg graphs attributed arbitrary java objects attribution concept extremely flexible 
allows graphs different abstraction levels control graphs coordinating processes high level graphs data model low level application 
application behaviour described graph rules contain java expressions describe attribute computations 
development agg environment java started taentzer 
comprises visual editors interpreter debugger graph parser validation tools 
kernel concepts agg language environment described taentzer 
worked case example solving shortest path problem agg 
agg environment implementation issues described rudolf mirror agg version year 
agg updated extended directions guidance taentzer having implemented graph transformation engine validation techniques developed attributed graph transformation shall gradually implemented agg 
graph parser critical pair analysis constraint checker realized 
furthermore controlling rule applications rule layers attribute conditions concept type graphs added 
component concept graph transformation described section realized prototypical full realization agg 
agg developed standard environments graph transformation community 
current version documentation available tfs cs tu berlin de agg 
survey describes visual modelling validation distributed systems focussing visual modelling language uml graph transformation formal validation domain 
uml extended various directions meets main requirements distributed system modelling 
precise definition syntax semantics visual modelling language uml graph transformation shown promising technique 
allows visual language definition handles structural aspects visually 
visual reasoning key aspects distributed systems formal calculus distributed graph transformation developed serves formal semantic domain distributed system models 
main advantage calculus support formal validation consistency issues rarely investigated distributed system models far 
summarizing main contributions achieved concerning subjects conceptual framework visual modelling distributed systems distributed graph transformation semantic domain 
application specific view concept uml visualization concepts ocl 
definition visual languages graph transformation 
tool support concerning validation visual language definition agg 
main parts developed project called application graph transformation visual design distributed systems supported deutsche forschungsgemeinschaft dfg 
project author regard realization project activities 
main ideas concerning distributed graph transformation semantic domain distributed systems considerable tool support agg genged approach visual language definition developed project 
continued project application graph transformation visual modelling languages concentrates usage graph transformation syntax semantic definition visual modelling languages 
elaborated concepts applied concrete languages uml extensions petri net languages domain specific languages 
research visual modeling techniques europe wide new european research training network syntactic semantic integration visual modeling techniques started october 
laying basis precise syntax semantics definition visual modelling languages distributed systems activities planned integrate uml graph transformation techniques techniques modelling validation come adequate domain specific solutions 
furthermore developments years produced increasing number attractive modelling validation tools especially uml 
time mature graph graph transformation tools play important role draw attention practitioners concepts solutions thesis 
enlarge acceptance new kinds tools integration established solutions pushed 
development common exchange formats gxl graphs graph transformation systems important step direction 
formats facilitate usage graph tools various concrete solutions yields wide spread numerous concepts results graphs graph transformation different application fields software engineering visual languages distributed systems 
publications submitted part thesis taentzer 
visual modeling framework distributed object computing 
jacobs rensink editors proc 
formal methods open object distributed systems 
kluwer academic publishers 
bottoni koch parisi presicce taentzer 
consistency checking visualization ocl constraints 
evans kent editors uml unified modeling language volume lncs 
springer 
minas sch rr taentzer 
application graph transformation visual languages 
ehrig engels 
kreowski rozenberg editors handbook graph grammars computing graph transformation volume applications languages tools 
world scientific 
engels ehrig heckel taentzer 
combined model view approach system specification 
int 
journal software knowledge engineering 
taentzer 
distributed graphs graph transformation 
applied categorical structures december 
fischer koch taentzer 
distributed graph transformation application visual design distributed systems 
ehrig 
kreowski montanari rozenberg editors handbook graph grammars computing graph transformation volume concurrency parallelism distribution pages 
world scientific 
rudolf taentzer 
agg approach language tool environment 
ehrig engels 
kreowski rozenberg editors handbook graph grammars computing graph transformation volume applications languages tools pages 
world scientific 
available tfs cs tu berlin de agg 
javascript language specification wp 
netscape 
com eng javascript javaspaces homepage java 
sun 
com products javaspaces java remote method invocation java 
sun 
com products jdk rmi hyper text markup language specification www 

org tr html 
hyper text transfer protocol www 

org protocols 
specification description language sdl 
itu recommendation 
web service definition language www 

org tr wsdl 
simple object access protocol soap www 

org tr soap 
extensible stylesheet language xsl www 

org style xsl 
corba iiop specification www 
omg 
org technology documents formal corba iiop 
htm 
dynamic host configuration protocol www 
dhcp 
org 
jini tm network technology 
sun 
com software jini 
ocl cgi 
omg 
org cgi bin doc 
ad 
omg 
scalable vector graphics www 

org tr svg 
precise uml group www 
cs 
york 
ac 
uk 
universal description discovery integration business web www 
uddi 
org 
xml metadata interchange www 
omg 
org technology documents formal xmi 
htm 
david 
model translation uml specification technique active implementation approach 
phd thesis university kent dept computer science 
andries engels habel hoffmann 
kreowski plump sch rr taentzer 
graph transformation specification programming 
science computer programming 

genged visual definition visual languages algebraic graph transformation 
verlag dr 
phd thesis technical university berlin dept computer science 

visual environment visual languages 
science computer programming scp 
taentzer 
visual language parsing genged 
electronic notes theoretical computer science june 

toolbox automating visual software engineering 

weber editors fundamental approaches software engineering fase volume lncs pages 
springer 
bottoni koch parisi presicce taentzer 
visualization ocl collaborations 
uml unified modeling language lncs pages 
springer 
bottoni parisi presicce taentzer 
constraint distributed diagram transformation software evolution 
heckel mens editors workshop software evolution transformations volume 
electronic notes theoretical computer science 
appear 
bottoni sch rr taentzer 
efficient parsing visual languages critical pair analysis contextual layered graph transformation 
techn 
report 
si university rome 
carriero gelernter 
linda context 
communications acm 
daniels 
uml components simple process specifying component software 
addison wesley october 

building web applications uml 
addison wesley 
corradini ehrig montanari rossi 
event structure semantics graph grammars parallel productions 
cuny ehrig engels rozenberg editors graph grammars application computer science volume lncs pages 
springer 
corradini montanari rossi 
graph processes 
special issue fundamenta informaticae 
corradini montanari rossi ehrig heckel 
algebraic approaches graph transformation basic concepts double pushout approach 
rozenberg editor handbook graph grammars computing graph transformation volume foundations chapter 
world scientific 
de lucia 
automatic generation visual programming environments 
ieee computer 
kindberg 
distributed systems concepts design 
addison wesley 
de lara 
atom tool multi formalism modelling meta modelling 
weber editors proc 
fundamental approaches software engineering fase grenoble april pages 
springer lncs 
de lara 
computer aided multi paradigm modelling process petri nets statecharts 
corradini ehrig kreowski rozenberg 
editors proc 
st int 
conference graph transformation lncs springer verlag pages 
uml profile enterprise distributed object computing specification 
available cgi omg org docs ptc pdf 
ehrig engels 
kreowski rozenberg editors 
handbook graph grammars computing graph transformation volume applications languages tools 
world scientific 
ehrig 
kreowski montanari rozenberg editors 
handbook graph grammars computing graph transformation volume concurrency parallelism distribution 
world scientific 
ehrig reisig rozenberg weber editors 
advances petri nets petri net technologies modeling communication systems 
lncs 
springer 
appear 
engels heckel ster 
rule specification behavioral consistency uml meta model 
gogolla editors uml unified modeling language 
modeling languages concepts tools th international conference toronto canada october proceedings volume lncs pages 
springer 
finkelstein gabbay hunter kramer nuseibeh 
inconsistency handling multi perspective specifications 
ieee software engineering 

fischer koch taentzer 
local views distributed systems communications 
ehrig engels kreowski rozenberg editors theory application graph transformations pages 
lncs springer 
formal systems europe 
failures divergence refinement fdr user manual 
france 
multi view software evolution uml framework evolving object oriented software 
proc 
int 
conf 
software maintenance 
ieee computer society 
garlan 
reconciling needs architectural description object modeling notations 
evans kent selic editors uml unified modeling language volume pages 
springer lncs 
meyer taentzer 
viewpoint oriented software development distributed graph transformation basis living inconsistencies 
proc 
th ieee int 
symposium requirements engineering re june university limerick ireland 
ieee computer society 
isbn 
grosse rhode 
semantic integration heterogenous software models 
habilitation thesis technical university berlin dep 
comp 
sci 
gurevich 
evolving algebras guide 
rger editor specification validation methods 
oxford university press 
heckel 
graph transformation time causality logical clocks 
proceedings st international conference graph transformation 
lncs springer pages 
heckel taentzer 
detection conflicting functional requirements case driven approach 
proc 
int 
conference software engineering orlando usa ieee society 
heckel ster taentzer 
confluence typed attributed graph transformation constraints 
corradini ehrig 
kreowski rozenberg 
editors proc 
st int 
conference graph transformation 
lncs springer verlag pages 
heckel ster taentzer 
automatic translation uml models semantic domains 

kreowski editor proc 
workshop applied graph transformation agt pages 
heckel wagner 
ensuring consistency conditional graph grammars constructive approach 
proc 
graph rewriting computation electronic notes tcs 
www elsevier nl locate entcs volume html 
heckel hartmut ehrig gregor engels gabriele taentzer 
classification comparison modularity concepts graph transformation systems 
ehrig engels 
kreowski rozenberg editors handbook graph grammars computing graph transformation volume applications languages tools pages 
world scientific 
ho 
umlaut extendible uml transformation framework 
proc 
automated software engineering ase florida 
ieee computer society 
ho plouzeau 
umlaut framework weaving uml aspect oriented designs 
technology objectoriented languages systems tools europe pages 
ieee computer society 
molina taylor kent gil 
spider diagrams diagrammatic reasoning system 
journal visual languages computing 
kent 
constraint diagrams visualising invariants object oriented models 
proceedings oopsla 
acm press 
koch 
verteilte und ihre anwendung auf verteilte 
technical report technical university berlin dep 
comp 
sci 
koch mancini parisi presicce 
graph formalism rbac 
acm transactions information system security 
leach levine aq hamilton nelson 
architecture integrated local network 
ieee selected areas communications sac 
lilius 
vuml tool verifying uml models 
proc 
automated software engineering ase florida 
ieee computer society 

performance modelling deterministic stochastic petri nets 
wiley sons 
th 
performance analysis time enhanced uml diagrams stochastic processes 
proc 
rd int 
workshop software performance wosp rome italy pages 
er rosenblum 
uml component diagrams software architecture experiences wren project 
proc 
describing software architecture uml workshop rd int 
conf 
software engineering toronto canada 
lynch 
distributed algorithms 
morgan kaufmann 
marriott meyer 
visual language theory 
springer 

und implementierung eines 
master thesis tu berlin 
mens hondt 
automating support software evolution uml 
automated software engineering 
minas 
concepts realization diagram editor generator hypergraph transformation 
science computer programming 
emmerich finkelstein 
static consistency checking distributed specifications 
int 
conference automated software engineering bay ca 
iso iec international standard itu recommendation model open distributed processing parts 
parisi presicce 
transformation graph grammars 
th int 
workshop graph grammars application computer science williamsburg lncs 
petri 
kommunikation mit 
phd thesis des institutes mathematik bonn 
detlef plump 
hypergraph rewriting critical pairs undecidability confluence 
sleep plasmeijer van eekelen editors term graph rewriting pages 
wiley 
reisig 
petri nets volume eatcs monographs theoretical computer science 
springer verlag 
wolfgang reisig 
elements distributed algorithms modelling analysis petri nets 
springer verlag 
rekers sch rr 
graph framework implementation visual environments 
proc 
ieee symposium visual languages vl pages los alamitos ca 
ieee computer society press 
richters 
precise approach validating uml models ocl constraints 
monographs bremen institute safe systems 
university bremen 
phd thesis university bremen 
rozenberg editor 
handbook graph grammars computing graph transformations volume foundations 
world scientific 
selic ward 
real time object oriented modeling 
wiley sons 
steffen margaria braun 
electronic tool integration platform concepts design software tools technology transfer vol 

springer 
taentzer 
parallel high level replacement systems 
tcs november 
taentzer 
common exchange formats graphs graph transformation systems 
padberg editor proc 
uniform approaches graphical process specification techniques volume electronic notes theoretical computer science entcs 
taentzer sch rr 
diego step module concept graph transformation systems 
proc 
graph rewriting computation electronic notes tcs 
www elsevier nl locate entcs volume html 
ehrig 
consistency analysis uml class sequence diagrams attributed graph 
ehrig taentzer editors proc 
joint workshop graph transformation systems pages 
technische universit berlin march 
unified modeling language version 
available www 
omg org technology documents formal uml htm 

automated program generation model transformation systems 

kreowski editors applied graph transformation agt pages 
satellite workshop european joint conferences theory practice software 
want hopper falcao gibbons 
active badge location system 
acm transactions information systems 
warmer kleppe 
object constraint language precise modeling uml 
addison wesley 
winter 
exchanging graphs gxl 
editor graph drawing th symposium gd vienna september mathematics 
springer 

uml modeling software reliability 
proc 
methods techniques software architecture review assessment workshop rd int 
conf 
software engineering orlando usa 
zhang shin 
uml representation role access control 
proceedings th ieee international workshop enterprise security nist md 

