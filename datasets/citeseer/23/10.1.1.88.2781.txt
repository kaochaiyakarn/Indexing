comparing approaches semantic service description matchmaking sven arnd michael lutz florian probst werner kuhn university institute robert koch str 
germany lutz probst kuhn uni de de uni de 
matching descriptions user requirements descriptions service capabilities crucial discovery appropriate services task 
improve precision approaches consider syntactical aspects matchmaking uddi approaches semantic matchmaking proposed 
compare approaches respect potentials matchmaking semantic descriptions services 
state approach uses web ontology language rule markup language describe inputs outputs preconditions effects 
algebraic approach data types specified capture domain knowledge 
specific data types service model referred shared concepts 
order specifications executable enable matchmaking functional programming language haskell approach 
scenario domain disaster management approaches tested specific type match 
services web perform specific task providing wind measurements certain location 
combining services composite service complex tasks solved creating gas dispersion map accident 
order create composite service user requirements specified suitable services meeting requirements discovered 
discovery process contains matchmaking descriptions user requirements service capabilities 
matchmaking approaches syntactic service descriptions universal description discovery integration registries uddi web service description language documents wsdl describe signature seman supported european commission ace gis project number ist german federal ministry education research part program number 
referenced publication 

tics service functionality 
matchmaking approaches semantic descriptions proposed 
ontologies identified core technique semantic aspects descriptions 
approaches compared respect potentials matchmaking semantic descriptions services state approach description input output preconditions effects service description logics dl case owl dl combination rule markup language ruleml algebraic approach algebraic specification describing functional languages case haskell 
approaches implement matchmaking user requirements service capabilities specialisation type match discovered service specific required directly service composition 
remainder structured follows 
section introduces motivating example 
state approach introduced section algebraic approach explained section 
approaches applied motivating example section 
point specialisation type match generally defined approach performing type match 
section approaches compared regarding description functionality matchmaking 
closes outline 
motivating example example domain emergency management illustrate possible problems service discovery addressed discussed approaches 
scenario composite web service called service composed calculate display dispersion toxic gas plume accident chemical plant 
case emergency fire officer creating evacuation plan coordinating rescue teams service 
forecast gas plume dispersion essential part task 
forecast number heterogeneous information sources accessed processed information current wind speed direction emission rate gas leak 
presents part possible implementation service 
service returns airport code identifies airport closest accident location 
service provides information current wind speed wind direction airport identified airport scenario taken ace gis adaptable composable commerce geographic information services project 
information see www net 
service represented service 
service accessed live com index html corresponding wsdl file available live com wsdl wsdl 
code 
returns report containing wind speed direction measured airport 
output input service calculating dispersion gas plume 
search suitable service illustrating example rest 
service needs interoperate service service 
fig 

considered part composite service semantics service described semantic network 
semiformal description serving starting point implementations approaches described section 
ideas taken 
observation defined event returning value describes phenomenon 
observation involves procedure determine value sensor simulation 
observation contains functionality static concept 
simulation real world measurement 
fig 

semiformal semantic description concepts operations relations domain motivating example contains observed phenomena 
subjects observation returns values 
value called regardless value due instrumental observation method estimation 
result simulation measurement 
state approach state approach characterised combination ideas currently discussed semantic web community 
web ontology language owl rule languages rule markup language ruleml creating semantic service descriptions 
approach semantics services captured semantic descriptions inputs outputs preconditions effects 
input output parameters related certain data type wsdl concept described ontology 
preconditions effects capture changing states parameters execution service 
constraints define preconditions effects 
precondition defined constraint true operation invoked 
postcondition effect constraint true completion operation 
constraints defined rule languages ruleml semantic web rule language swrl inside owl definitions 
owl widely discussed formalism capturing semantics services 
current release owl specification suffers deficiencies see 
overcome disadvantages called web service semantic profile enriches syntactic wsdl descriptions semantic descriptions proposed pragmatic solution 
input output parameter described corresponding wsdl file referred concept ontology constraint rule file 
description tool called web service matchmaker enhances conventional service discovery methods semantic annotations 
uses wsdl files publish web services uddi registry syntactic search file registered semantic search 
search algorithms derived larks 
levels matching implemented series independent filters 
exact match results descriptions requirement capability equivalent 
relaxed match weakest semantic interpretation namespace text domain filters indicate degree similarity advertisement request 
interesting match research plug match identifies service practically ideal service requester find 
plug match exists 
concepts output parameters registered service restricted specific requested service number outputs registered service greater equal number outputs requested service 
concepts input parameters registered service restricted general requested number web service matchmaker available www agent net com 
inputs registered service smaller equal number inputs requested service 
illustrates plug match composite service motivating example 
service needed fits adjacent services 
output preceding service icao special kind airport code required service able code input parameter 
subsequent service composition needs wind information calculate dispersion gas plume required service offer appropriate output parameter 
assume expects wind reports containing observed values input 
case plug match service offers wind report containing measured values result ontology concept output parameter desired service subclass 
fig 

general input concepts specific output concepts result plug match algebraic approach main characteristics algebraic approach utilization executable programming language describe ontologies similarities method algebraic specification applied specify software functionality long time 
years functional language haskell specifying concepts domain geospatial information 
idea subset constructs available haskell semantic description services introduced section 
order reader familiar concepts functional languages syntax haskell application referencing shared semantics short complete code resulting examples haskell source code resulting available uni de matchmaking 
algebraic specification functional languages algebraic specification method formalizing behaviour system subsystem data types 
relates mathematical notion algebra data type considered set signatures constraining axioms 
algebraic specification defines behaviour operator axioms formalise operator effect terms operators data type 
basic concepts mathematical domain algebras support understanding application algebraic approach ontology descriptions theory model 
theory data type behaviour model concrete data type gives structure representation abstractly specified behaviour 
words formal algebraic theory serves shared ontology various application models 
functional programming language create specifications results executable code 
consequently deviations desired behaviour detected executability 
format specification enables automatic checking correctly syntax completeness consistency 
applying haskell section main features haskell relevant building ontologies defining models referencing understanding resulting matchmaking possibilities outlined 
main features clarification terms 
prominent feature functional programming languages function name 
mathematical functions defined equations expressions consequently axioms algebraic specifications written equational logic 
collections definitions called scripts 
considering haskell strong type system ensures expression associated certain data type 
type system static compiler checks consistency data types inside script executes 
compiled haskell script contains mismatched data types 
haskell type system enables polymorphic types introducing parameter variables data types 
way behaviour polymorphic types implemented concrete data types representation structures 
data types inherit defined behaviour binding variable 
furthermore haskell allows restricting data types able bind parameter variable possibility define called qualified types unique ability haskell 
structuring large scripts haskell features module concept 
parts scripts specifying complex systems built compiled separately frequently domain upper level ontologies reused combined 
necessary haskell constructs 
haskell constructs needed describe systems semantically 
type classes contexts type dependencies specify theory ontology 
data type synonyms data type constructors enable model building instances refer application models theory 
constructs introduced nutshell type classes specify behaviour shared data types 
operators capture behaviour 
operator signature defined inside type class 
parameter variables applied avoid concrete representation structures data types 
subsequently variables bound data types application model instantiation 
line listing type class called unit defined 
parameter variable named unit characteristic behaviour unit certain base captured operator line 
contexts assert constraints parameter variables type class 
constrained type class instantiated concrete model required constraints met 
regarding type class line listing parameter variable called unit constrained type class unit 
data types instantiating unit bound variable 
ensures operator inside specification type class line 
type dependencies express data type assigned parameter variable inside type class depends data type bound second variable type class 
line listing example data type unit depends data type description 
means specific data type representing metric description uses data type indicating unit 
listing 
subset theory metric descriptions class unit unit unit double class unit unit description unit description unit unit description unit description double description double unit ways introduce new data types considered defining application models 
type synonyms define new data type giving previously defined data type new name icao defined synonym string listing line 
user defined data types introduce name new data type constructor functions define internal representation 
line listing data type called introduced 
constructor function name needs argument data type double 
details see 
instances refer application model shared behaviour theory 
data type inherits class behaviour 
instantiation axioms define interpretation rules type class operator relating concrete representation structure data type 
example newly defined data type single element represents value description unit data type meter listing 
listing 
subset application model instantiations type icao string data meter meter data double instance unit meter instance meter unit meter haskell interpreter tool example haskell applied semantic descriptions haskell interpreter matchmaking 
tests conduct query models underlying offered services 
individual service instance certain application model behaviour individuals explored calling operators defined theory 
description required operator combination call unit operator returns individual model units returns convert factor unit model meters 
factor model fits requirement result query listing true 
listing 
testing convert factor unit belonging description test unit implementation section approaches applied describe services semantically 
services service introduced section services syntax take airport code string input return wind report string output 
differ functionality parts implementation available uni de matchmaking 
service 
wind information returned service simulation 
service 
wind information returned service real world measurement 
matchmaking requirements implemented 
correct invocation 
service needs offer suitable input data service see requires wind speed information described knots 

correct functionality 
addition requirements provided information required measured opposed simulated value 
specialisation type match enable comparison approaches definition specialisation type match 
case service capability registered service specialisation user requirement requested service 
definition 
functionality registered service safely substitutes functionality requested service 
considering requirement service observing wind speed requested wind information interest matter wind measured simulated 
observes wind speed measures wind speed fulfil requirements 
considering requirement service measuring wind speed required 
fulfilled 
implementation state approach subsection state approach describe services 
shown semiformal concepts section implemented ontologies 
definition type match 
web service matchmaker match services requirements introduced 
wind observation domain ontology 
semiformal semantic description implemented ontologies owl dl ontology language 
meaning usage basic owl dl elements classes properties explained 
owl special element represent operations classes 
means operations observations formally equivalent static concepts 
defining specialization type match 
definition safe substitution function subtyping operation fx fx dx cx indicate function accepting argument type dx yielding result type cx 
replaced substitute operation fy dy cy intention fy behave fx 
condition fy safely substituted place fx domain argument type dy larger domain dx codomain result type cy smaller domain cx function type dy cy subtype function type dx cx 
state approach larger domain equivalent general concept superclass owl smaller domain specific concept owl subclass 
general definition corresponds plug match web service matchmaker section 
matchmaking 
specialisation type match demonstrated web service matchmaker 
input output parameters defined service wsdl file annotated concepts ontology constraints defined rules resulting file registered 
assumed unconstrained input concept icao airport code focus output parameter 
output parameter referred concept referred concept 
demonstrated concept related explicit subclassof property concept identified specialisation case applying plug match 
fig 

application domain ontologies search service user define number input output parameters corresponding ontology concepts define constraints required service 
procedure registration service wsdl file parsed file created 
procedure describing service requirements way service capabilities advertisements query borrows 
order fulfil matchmaking requirement subset semiformal ontology implemented classes 
requirement 
class requirement superclass 
specialisation type match 
plug match test type match 
note taxonomic relations requirement classes explicitly defined inferred range restrictions non taxonomic relation 
challenge detect hidden hierarchy 
able identify implicit discovered suitable matches requirement 
requirement 
requirement corresponds refers way application ontology 
subclass expected actual result requirement service implementation algebraic approach shown semiformal concepts section implemented application models referenced 
haskell module concept structuring reusable ontologies 
approach dependent definition specialisation type match 
services introduced section registered queried hugs interpreter 
upper level domain ontologies 
domain independent concepts introduced auxiliary upper level ontology 
services example characterised operator returning web address service 
domain independent concepts specified descriptions physical quantity described concept allows describing speed 
base unit velocity defined meters second related operator called second 
domain dependent ontology relates observations measurements specifies concepts describing phenomenon wind 
formalize wind observation ontology necessary describe services relating example introduced section 
relevant type classes performing queries specifying output observation contain descriptions observed phenomena 
descriptions extracted complete report operator 
observation generator obtain description phenomenon 
offer operator observe takes location input returns 
operator captures functionality 
measurement special kinds generators called sensors 
sensors specific location space return descriptions phenomena measured location 
important operator related measurements called measure 
corresponding concepts example formalised wind observation ontology 
restrict type classes introduced concerning wind speed 
operators related type classes wind called speed 
application models services 
simplification representation structures underlying example services relevant matching requirements outlined model includes specific unit structure representing model generators acquire wind speed observations elements representing structure services 
part model introduced section extended descriptions velocity knots 
needed models kept simple introducing new data types containing elements representing timestamp observation taken location third observed description 
fig 

core instantiations service models model underlying called contains data type generator 
model instantiates type classes service observation simulation related operators implemented axioms 
model quite similar features data type collection sensors single generator 
icao data type represents location sensor 
application model relating instantiates type classes measurements wind ones related simulations 
important instantiations application models 
defining specialization type match 
services referring application models instances certain type class considered implementing functionality described type class 
application model specific required instantiates type classes constrained describing desired behaviour 
requirement example model instantiating required 
instantiates wind 
case fits requirement specialisation case refers measurement constrained 
matchmaking 
example services introduced section registered individuals data types defining application models listing 
exemplary input parameter defined services provided line 
input queries 
listing 
registering individual individual url simulation html simulator url simulator url html sensor icao fra sensor 
sensor sensor 
url icao requirement 
service individual required refers model implementing operator 
furthermore output operator knots unit measure 
script listing contains necessary operator calls query service example 
variable bound result operator call 
call executable identified service performing 
queries contain needed operator calls testing output offers desired unit 
operator applied extract part represents description 
query uses combination operators extract convert factor base unit description stored compares result expected convert factor knot equal km 
service complete script executable answer query stored variable true 
identified matching requirement 
similar queries formulated test remaining service replacing occurrences listing 
queries executable service performing 
identified match 
listing 
querying fulfilling requirement unit requirement specialization requirement focusing functionality measurement 
queries adapted replacing operator 
applying query registered services query testing fails operator implemented 
result true service identified match requirement 
discussion comparison section analyses specialization type match realized 
discusses potential approaches general employed tools compares way describing functionality resulting matchmaking possibilities 
description service functionality aim approaches describe functionality service semantically 
approaches vary respect implementation concepts relations concepts identified section differ 
state approach 
functionality description state approach description input output parameters service operation seen black box 
functionality captured describing parameters execution service operation 
parameter refers concept owl dl ontology typically called input output constrained rule fact example stated ruleml called preconditions effects 
direct way capture semantics operation 
concerning example measurements meaning actual functionality offered service implemented static concept stands dynamic behaviour 
example output parameter related concept part relation 
concept turn related concept measurement bind relation 
example illustrates services functionality measuring measurement class directly service parameters 
limitation expressiveness lack describing part relations 
possible define property labelled part define characteristics property transitivity inverse characteristics relations antisymmetry expressed 
algebraic approach 
functionality described operators relating data types 
semantics operators defined axioms serve interpretation rules offered functionality 
way dynamic behaviour data type formally specified 
inputs outputs operator belong direct functionality description 
implementation type class capture functionality measuring wind speed 
offers operator speed specified take locations input returning wind 
operator implemented instantiation application model instances 
example operator takes input icao representing returns 
possibility assessing operator directly facilitates semantic description service dynamic aspect 
limitation expressiveness approach definition disjoint concepts 
algebraic specifications data types ensured disjoint defining conflicting axioms 
functional languages impossible conflicting axioms recognised compiler 
matchmaking matchmaking possibilities analysed focusing specialisation type match defined section 
state approach 
functionality service described parameters matchmaking performed comparison parameter concepts constraints 
specialisation type match input concept general output concept specific 
owl offers subsumption relationships classes possible perform specialization type match state approach 
web service matchmaker able identify specialisation type match requirement 
due fact able reveal implicit subclass relations requirement 
despite disadvantage shows user able discover services ontology browser rule editor 
order integrate detection implicit taxonomic relations reasoning engines racer 
racer implemented ontology reveal implicit taxonomic relations 
dependency concepts characterised non taxonomic relations currently available dl reasoning engines detect relation 
searching wind speed description output service offering complete weather report containing wind speed information part discovered 
algebraic approach 
matchmaking performed directly searching functionality 
operators introduced type class level capture functionality service operators querying 
specialisation type match sufficient test available service individuals implementing operator specifying required general behaviour 
service measuring wind speed needs instantiate able instantiate 
way general operators realized services relate specific models successfully tested implementing operators 
interpreter employed functional language identify specialization type match evaluate application models implement certain type class operators 
adequate tool exploring general potentials algebraic approach interpreter lacks basic functionality 
sophisticated matchmaker face incomplete instantiations type classes needs identify overwriting axioms 
instantiations incomplete model instantiating type classes need implement operators offered type class 
consequently inferred service captures aspects specified operators certain type class 
axioms defined type class level redefined instantiations 
situation semantics defined domain level modified domain knowledge violated 
compared approaches capturing semantics services special focus dynamic aspects 
state approach describes aspects indirectly formalising constraints inputs outputs offered operations kept black box 
furthermore service operations directly related concept describing dynamic behaviour 
contrast algebraic approach allows services operations directly related operators 
interpretation rules operators axioms 
example implementations revealed state algebraic approach able express relationships concepts unambiguous way 
suites formalising static concepts mainly related taxonomically serves formalising dynamic behaviour features kinds relations 
algebraic approach part arithmetic relations addressed additionally approach fails specifying disjointness concepts state approach 
general set mature tools available state approach validation consistency checking ontologies 
web service matchmaker chosen representative matchmaking tool approach meet expected results specialisation type match 
concerning algebraic approach haskell compiler check consistency domain ontologies violations type system result error messages 
haskell interpreter hugs investigate requirements tools supporting matchmaking algebraic approach 
identify type match investigated 
state approach suitable long static concepts focused data concepts described 
soon dynamic aspects important kind data acquisition needs formalised algebraic approach noteworthy alternative 
rules contained state approach provide possibility query dynamic behaviour reasoning tools 
final step integrating concept constraint queries needs realised 
kinds matches investigated addition specialisation type focusing containment desired functionality facing part relations 
prerequisite framework defines various types matches built 
algebraic approach offer possibilities state approach types matches mandatory 
aspect investigated user acceptance approaches 

uddi uddi technical white 
available www uddi org pubs iru uddi technical white pdf 
web services description language wsdl 
available www org tr wsdl 
sycara interoperability heterogeneous software agents internet 
robotics institute cmu cmu ri tr pittsburgh usa 
owl web ontology language overview 
web ontology working group 
available www org tr owl features 
boley wagner design rational ruleml markup language semantic web rules 
proc 
semantic web working symposium swws 
liskov guttag abstraction specification program development 
mit press cambridge massachusetts 
bird wadler functional programming 
prentice hall 
hudak haskell school expression learning functional programming multimedia 
cambridge university press 
peyton jones haskell language libraries revised report 
cambridge university press cambridge 
observation measurement 
open gis consortium interoperability program report 
horrocks patel schneider boley grosof dean swrl semantic web rule language combining owl ruleml 
martin paolucci mcilraith burstein mcdermott mcguinness parsia payne sabou srinivasan sycara bringing semantics web services owl approach 
proc 
international workshop semantic web services web process composition 
li horrocks software framework matchmaking semantic web technology 
proc 
twelfth international world wide web conference www 
kawamura hasegawa paolucci sycara preliminary report public experiment semantic service matchmaker uddi business registry 
proc 
international conference service oriented computing 
sycara klusch lu larks dynamic matchmaking heterogeneous software agents cyberspace 
autonomous agents multi agent systems 
ehrich mahr fundamentals algebraic specification equation initial semantics 
springer 
frank executable axiomatic specification functional language case study spatio temporal database 

frank kuhn specification language interoperable gis 
goodchild egenhofer eds interoperating geographic information systems 
kluwer 
kuhn modelling semantics geographic categories conceptual integration 
proc 
second international conference geographic information science 
ehrich gogolla 
teubner stuttgart 
frank kuhn specifying open gis functional languages 
proc 
advances spatial databases th internat 
symposium large spatial databases ssd 
kuhn implementing semantic systems 
proc 
th agile conference geographic information science 
simons perspectives type compatibility 
journal object technology 
paolucci kawamura payne sycara semantic matching web service capabilities 
proc 
st international semantic web conference iswc 
haarslev ller racer user guide manual version 
manual 
