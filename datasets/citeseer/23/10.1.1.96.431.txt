mirrors design principles meta level facilities object oriented programming languages gilad bracha sun microsystems network circle santa clara ca gilad bracha sun com identify design principles reflection metaprogramming facilities object oriented programming languages 
encapsulation meta level facilities encapsulate implementation 
stratification meta level facilities separated base level functionality 
ontological correspondence ontology meta level facilities correspond ontology language manipulate 
traditional mainstream reflective architectures follow precepts 
contrast reflective apis built concept mirrors characterized adherence principles 
consequently mirror architectures significant advantages respect distribution deployment general purpose metaprogramming 
categories subject descriptors language classifications object oriented languages 
general terms design languages 
keywords reflection metaprogramming mirrors java self smalltalk 

object oriented languages traditionally support meta level operations reflection reifying program elements classes objects support reflective operations get superclass 
typical object oriented language reflection java smalltalk clos query instance class indicated pseudo code class car 
car mycar new car int mycar class mycar getclass permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla oct vancouver british columbia canada 
copyright acm 
david ungar sun microsystems casey ave mtv xxx mountain view ca david ungar sun com car newinstance class looking apis system expect see class object class getclass class class class methods apis support reflection core system 
object reflective method ties class entire reflective system 
base meta level operations coexist side side 
class object contains constructors static attributes responds queries name superclass members 
object exhibits behavior problem domain exhibits behavior member class getclass 
argues meta level functionality implemented separately base level functionality objects known mirrors 
api look class object reflective methods class class reflective methods interface mirror string name class reflection public static reflect object 
interface extends mirror getclass interface extends mirror 
mirror system write example reflection reflect mycar getclass glance change difference 
changed api effect interface meta level operations particular implementation pulling meta level operations separable subsystem 
properties manifests important design principle 
embodies principle encapsulation meta level facilities encapsulate implementation 
corresponds principle stratification meta level facilities separated base level functionality 
principle structural correspondence structure meta level facilities correspond structure language manipulate 
meta level language architecture respects principles definition mirror system 
addition advocate principle temporal correspondence meta level apis layered distinguish static dynamic properties language manipulate 
principles coalesced broader principle ontological correspondence ontology metalevel facilities correspond ontology language manipulate 
show adherence aforementioned design principles yields significant advantages respect distributed development application deployment 
argue designed mirror reflective api serve general purpose metaprogramming api 
illustrates traditional reflective design mirror 
traditional api classes straddle boundary base level meta level 
mirror design moves base level meta levels means reflect operation 
levels clearly separated 
fact presence classes base level strictly necessary 
principle encapsulation basic rule software engineering show cases applied design reflective architectures built major programming languages 
principle stratification known reflection community maes consistently adhered programming languages 
structural correspondence elucidated substantially respected highlight violations implications mainstream languages 
temporal correspondence related known distinction compile time load time run time reflection 
phases applicable language run time reflection usually supported language 
systematic discussion design principles mirror systems concomitant advantages 
advantages mirrors include ability write metaprogramming applications independent specific metaprogramming implementation reflection 
care metaprogramming clients interact metadata sources local remote change client 
furthermore client interact multiple sources metadata run time fact interact metaobjects different implementations simultaneously 
ability obtain metadata systems executing platforms include full reflective implementation 
examples small memory constrained devices embedded systems deployed applications concerns footprint security bandwidth discouraged precluded deployment built reflection support 
ability dynamically add remove reflection support running computation 
ability deploy non reflective applications written reflective languages platforms reflective implementation reducing footprint saving communication time 
terminology 
reflective language architectures may characterized terms support 
introspection 
ability program examine structure 

self modification 
ability program change structure 

execution dynamically generated code 
ability execute program fragments statically known 
special case 

ability modify semantics underlying programming language language term broader sense parts literature adopt narrower definition 
table summarizes support features reflective systems mentioned 
base level getclass traditional reflection class object term reflection refers situations program manipulates 
general term metaprogramming describe situations program manipulates possibly different program 
word program describe distinct notions description programming language executing computational process 
shall refer code computation 
sections focuses principles identified 
section show concrete problems stem violations principle discussed solved mirrors 
section discusses principle encapsulation implications distributed execution 
leads need stratification discussed section alongside issues deployment 
section deals principle correspondence problems arise neglected 
section gives discussion issues arise design mirror systems 
discuss related 

encapsulation meta level java core reflection base level class object introspection basic principle software engineering module rely particulars module implementation 
unfortunately clients classical reflective apis dependent implementation details reflective system 
demonstrate point case study followed general analysis 
table reflect self modification smalltalk limited clos jdi limited strongtalk meta level self limited class mirror getclass reflect mirror reflection case study distribution object mirror consider scenario 
programmer writes class browser reflection 
time necessary browse classes remote machines 
reuse browser code possible little adaptation possible 
goal may controversial readers note arguing transparent distribution 
controversy far outside scope 
argue mirrors approach design reflective api distribution aware 
claim mirror distribution aware reflective api designed serves case 
scenario mind contrast apis programming language virtual machine java core reflection java debugger interface jdi 
overview java core reflection 
java core reflection reflective api provided part se ee platforms 
traditional reflective api mirror 
ll see core reflection deals scenario described 
followed brief jdi mirror api designed support debugging java programs 
return example show jdi facilitates satisfactory solution 
java core reflection java programming language reflective capabilities centered class java lang class class short extended core reflection package java lang reflect 
classes including class instances class 
addition class classes support reflection defined java lang reflect method java lang reflect field java lang reflect constructor 
reflective api defined classes interfaces 
significance discussed section 
classes methods support introspection 
query class superclass superinterfaces fields methods constructors member classes 
possible alter structure code existing class facilities support self modification 
applying core reflection class browser problem quite easy write browser name class allow examine class structure core reflection 
try code remote classes encounter serious difficulties 
java core reflection directly support distribution browser need alternate implementation 
avoid need complete rewrite browser 
possibility design distributed metaprogramming api class method structure core reflection 
browser application switch local distributed apis changing single import statement import java lang reflect say import com distributed metaprogramming approach problematic 
maintain slightly different copies source code 
sets binaries distribute load 
consequently runtime browser code twice memory footprint hard loaded versions interoperate 
furthermore browser interacts class loader api need class class hiding import possible 
may wish browser observe source code outside running virtual machine 
problems mentioned exacerbated versions source sets binaries import statements fail address problem decouple modules couple localized fashion 
set difficulties specific distributed programming 
application able deal network failures latency affect logic application 
need specify display network locations classes browsing 
altogether core reflection api unsuited purpose 
jdi java debug interface jdi uppermost layer java platform debugger architecture jpda 
designed support remote debugging supports introspection capabilities java core reflection 
jdi supports limited forms self modification 
jdi defines interfaces describe program entities interest debugger 
include classes interfaces objects stack frames 
interfaces subtypes interface com sun jdi mirror 
focus mirror interfaces important involve unique issues seen languages systems 
mirror associated particular virtual machine entity mirrored exists 
interface com sun jdi describes mirror virtual machine vm 
obtain set loaded classes interfaces vm mirrored set threads vm information regarding capabilities vm mirrors specific classes values vm objects mirrored objects implementing interface com sun jdi equivalent object mirror interface shown 
possible read write mirrored object fields invoke methods get class 
remote mirrors objects raise issues distributed garbage collection 
default mirrored object may collected mirrored vm 
words object mirrors maintain weak mirrored object 
possible override default determine object collected 
threads mirrored objects implementing interface com sun jdi specialization threads objects jvm 
operations threads include suspension resumption operations thread call stack 
scenario revisited jdi jdi straightforward write class browser examine classes separate processes remote machines virtual machine 
jdi designed distributed mind 
debugging virtual machine jdi recommended debugging entails stopping threads virtual machine debugged 
jdi running vm substantial risk deadlock 
structural introspection usually require threads paused 
furthermore usual jdi implementation behaved alternate implementation derived wrapping core reflection objects implement jdi interfaces needed support structural introspection 
concretely construct different implementations interface mirroring particular vm support reflection current local process remote processes 
class browser query instance loaded classes represented list mirror interface classes 
browser code oblivious difference different implementations mirror interfaces 
established jdi non distributed reflection shown convenient java core reflection 
main difficulty need deal potential exceptions arise distributed 
difficulty ignored argue outweighed benefits having learn single api 
furthermore discussed section experience self mirror apis indicates possible employ api local distributed reflection excessive penalty 
analysis case study shows java core reflection support distributed development tools jdi 
partly jdi deals certain distribution specific issues network failure distributed memory management core reflection 
issues addressed alternate implementation core reflection communicated remote jvms proxies 
event network failure unacceptable latency operations fail throwing exception 
key point alternate implementation possible core reflection api classes interfaces 
core reflection deliberately violates principle encapsulation making clients dependent specific implementation types classes 
dependency enforced type system prevents clients alternate implementations core reflection api 
course dynamically language write proxy emulating reflective api concern quirks type system 
dynamically typed object oriented languages implementation object may subtly exposed discussed 
encapsulating class identity object oriented languages getclass method equivalent exposes information implementation clients 
applications may come depend information making difficult replace object equivalent functionality instance different class 
simple example getclass car class 
bad practice uncommon 
code fail instance alternate implementation car 
consider example language classes application specific state code smalltalk clos 
class car method 
return number cars manufactured year typically follows getclass proxy remote car object standard implementation getclass return proxy causing code fail 
clear want getclass return proxy remote car class 
doing poses problem reflective code going get hold real class class proxy 
define method merely original problem exposing class identity 
functionality provided getclass defeats reuse motivation object oriented programming 
solution factor reflective functionality getclass api ordinary objects 
exactly mirrors 
factoring implies functional decomposition classic object oriented 
mirror implementation decides mirror objects kind leaving decision implementation objects 
scenarios class browser example quite natural 
browser knows looking classes locally remotely database choose suitable mirror factory 
cases debugger local process encounters proxy object isn immediately clear mirror choose 
may configuration preference set user 
follows mirror factories may dispatch type object 
access identity class denied recommend 
answer basic local reflection inherently respect encapsulation objects reflective applications including mirror factories identify classes choose 
define public mirror factory allow classes registered indicating mirror implementation reflecting instances 
usually means getclass identity instance class may detected 
common example constructs instanceof checked casts conjunction class types constructs interface types harmless 
usage reliance class identity avoided application code 
separation mirrors meta level classes base level necessary fully support encapsulation 
separation manifestation principle stratification discussed section 

stratification desirable engineering property feature impose costs 
adherence principle stratification supports desideratum making easy eliminate problem may important objectoriented programming modelling abilities paramount admit comes subject non scandinavian perspective 
may stratification propose separation concepts phenomena 
reflection needed 
important benefits context deployment discussed 
case study deployment deploying application desirable deploy reflective facilities available language 
application may require reflective capabilities may require infrequently 
cases may advantageous reduce application footprint avoiding delaying deployment reflective facilities 
especially true small platforms mobile phones pdas smart cards embedded systems 
goal avoid deploying reflection needed application 
review smalltalk reflective api contrast strongtalk mirror smalltalk system give analysis different architectures affect deployment problem 
smalltalk smalltalk differs languages program defined declaratively 
computation defined set objects 
classes capture shared structure objects objects declarations 
way create new classes add code classes invoke methods 
smalltalk classes inherently support self modification reflection sole mechanism available constructing modifying 
method class defined objects obtain class instance 
object implements inspect method opens inspector object 
smalltalk classes exclusively meta objects 
classes typically include application specific methods state 
common class methods instance creation 
special syntax instantiating class notion constructor smalltalk 
class methods create new instances 
smalltalk classes play application specific metalevel roles program generally difficult remove reflection support smalltalk application 
discuss topic section 
strongtalk strongtalk differs traditional smalltalk systems number respects 
relevant differences purposes discussion adopts mirrors traditional reflective architecture 
optional static type system exclusively interfaces supporting principle encapsulation 
mixin system 
strongtalk mirror system supports introspection self modification 
class mirror subclasses support reflection mixins classes types methods global variables objects call stack individual stack frames activation records 
invoking mirror object returns appropriate mirror object 
mixins serve basic unit self modification strongtalk mirror api 
mixins suited task stateless smalltalk classes copied freely 
modifications copy mixin effect ongoing computation 
modifications complete modified version installed atomic operation 
modified mixins installed simultaneously 
batching modifications improves performance important advantage 
series modifications may consistent done piecemeal may create inconsistent intermediate versions code possibly leading program failure 
problem avoided batching modifications 
see details 
usual reflective functionality associated class available 
similarly specialized mirror classes exist mixins protocols rough equivalent interfaces java global variable declarations 
ordinary smalltalk system ask class remove methods strongtalk obtain mirror class mirror interact mirror dictated principle stratification 
inspect ordinary instance inspect method 
invokes method inspector object 
crucial decoupling gui rest system 
determine class object reflective purposes invoke class method invokes method reflection object 
example deserves discussion 
smalltalk obtaining object class routine non reflective operation 
class methods construct new instances application purposes 
application specific purposes class method 
traditional method overridden strongtalk 
allows objects hide implementation details including class 
example proxy object hide fact instance proxy class 
see section additional analysis 
analysis mirrors easier eliminate reflective infrastructure application 
see consider issues dynamically statically typed languages 
dynamically typed languages mirrors difficult separate reflective facilities development environment application 
example ability add new methods requires access source code compiler 
capability placed class class difficult weed application applications rely class class 
similarly smalltalk object inspect tends bind object inspectors ui framework application 
general reflective capabilities part class uses reflection hard safely remove reflective capabilities system 
sure application reflection needs resort sophisticated costly type inference techniques 
mirrors eliminate problem clearly separating reflective functionality moving places ordinary applications access 
straightforward establish application require functionality reflective subsystem development environment 
application entry point associated reflection classes mirror reflection strongtalk com sun jdi mirror interface jdi reflect method self reflection support removed statically typed languages employ nominal type system eliminating reflective functionality application prior deployment considerably easier dynamically typed languages 
mirrors wishes avoid deploying reflective subsystem unnecessarily statically determine reflection application 
reflection deployed initially possible modify existing representations classes methods support need self modification capabilities 
real liability presence dynamic loading 
mirrors add remove reflective capacities run time special support dynamic class loading unloading 
ability dynamically enable disable reflection support useful security perspective 
course reflection deployed dynamically degree support underlying implementation 
capacity reflect computation contain reflective api demonstrated klein self vm developed second author 
klein support reflective api 
klein debugged self gui running standard self vm separate process 
gui communicates klein vm mirrors communicate sockets 
changes self mirror api new implementation needed 
experience supports contention section single mirror api serve distributed local cases 
conclude mirrors facilitate deployment 
advantages pronounced dynamically typed languages mirrors advantageous static type system 

ontological correspondence temporal correspondence reflection traditionally defined computation 
naturally underlying assumption reflective apis reflected entities exist executing context 
apis support operations instantiating class querying instances 
reflective applications profilers debuggers manipulate computation compilers class hierarchy browsers pretty printers manipulate structure program code 
desirable run applications category code embedded computation 
class browser view source database example 
conversely tools may assume availability source information may unavailable run time 
example javadoc expects comments available 
case study browsing source database vs browsing reflection writes class browser java core reflection easily retarget application browse classes described source database 
situation similar encountered section 
create alternate implementation api produces instances class java lang reflect method simply reading source code compiling loading classes running jvm 
example importance principle encapsulation additional issues involved 
alternate implementation core reflection possible face difficulties 
reflection api allows methods invoked classes instantiated operations sense browser examining source database 
fare better jdi designed primarily debugging 
assumes running vm containing threads may obtain stack frames objects classes 
see adhering encapsulation principle necessary insufficient condition solve problem 
note jdi subset concerned structural reflection classes just applicable classes structure extracted source code binary class files 
elements jdi depend presence computation factored separate api implementation operated source database straightforward 
leads observation mirroring code mirroring computation separable modules mirror api 
manifestation principle temporal correspondence 
distinction language code compile time computation run time manifest metaprogramming apis 
notion code useful restarting programs fresh state proving program properties especially transporting programs processes discussed 
distinguishing code computation self interchange programs data self system strives harness people intuitions real world help program computers 
real world distinguish code computation compile run switch world self attempts unify program computation 
self program just set objects mirrors reflect world view 
argue principle temporal correspondence irrelevant self 
self features transporter system designed move programs sets slots containing data code self world objects 
building transporter second author forced see need program described moved world provide new functionality 
objects added system represent programs annotations modules meta level objects truck code computation 
despite best intentions came time share programs principle applied 
structural correspondence structural correspondence implies language construct mirrored 
principle long recognized reflection community 
practice violated 
discuss issues arise 
reifying code computation meta object protocols ideally introduce meta object object computation 
languages important notions modules import export statements metadata types comments exist compile time 
constructs liable excluded mop reifies elements actual computation 
similarly compile time mops deal compile time constructs mop run time reify entities exist run time see section discussion compile time mops 
mirroring method bodies languages constructs method level statements expressions corresponding metaobjects 
case mirror systems discussed 
vm level byte codes available mapped back source code 
strategy typically tools debuggers 
true structural correspondence imply higher level representation method bodies available 
useful tools manipulate source code compilers standardized representation 
source code byte code may available implementors away providing facilities 
possible provide functionality conditionally available demand 
example jdi clients query kinds operations supports 
enables jdi define api access method byte code allows implementations retain byte code 
language reflect 
programming languages support reflection implemented top virtual machine java jvm clr 
confuse metaprogramming api language underlying virtual machine high level language hll running top 
designing metaprogramming api important clear base level language true regardless api question mirror 
reflection supported vm basic level reflective api 
high level languages implemented top virtual machine ideally include reflection api 
maintaining distinct reflective api hll valuable number reasons 
reflective api may maintain invariants hll introducing potential security correctness problems 
risk discrepancies hll 
discrepancies arise implementing high level constructs directly supported vm 
prominent example nested classes java programming language 
implementing nested classes requires generation synthetic classes interfaces methods fields original source code 
cases constructors may require additional parameters 
features hidden hll programs expose details specific translation scheme hll 
translation scheme implementation detail hll programs rely 
particular details leak reflective api 
counter example consider java lang class returns methods declared class 
methods declared vm level returned regardless synthetic 
exposes translation strategy java compiler clients reflection 
multiple source languages implemented virtual machine risk discrepancies virtual machine language various source languages increases 
common example method overloading typically supported hll compiler underlying vm 
languages different overload resolution schemes single reflective api support correctly 
hll complete agreement discrepancies arise time new hll features added implemented hll front vm support 
nested classes generics java programming language examples 
avoid difficulties strongtalk mirror api subdivided high level mirrors low level mirrors 
high level mirrors reflect smalltalk low level mirrors reflect underlying structures virtual machine 
distinction reflective api aware 
high level mirrors defined mirror class hierarchy 
high level mirrors support smalltalk level semantics 
low level mirrors defined class subclasses 
vm mirrors manifest representational differences different kinds objects integers arrays classes mixins regular objects hidden language level 
ask physical size instances size header example 
low level mirror api inherently sensitive design underlying virtual machine language implementation 
conclude distinct reflective apis language system particular underlying virtual machine language high level language running top virtual machine 
instance principle structural correspondence 

issues design mirror systems classes vs prototypes self mirrors introduced self programming language 
self uses prototypes classes actors unifies access state behavior 
lacking direct methods self language support traditional integrated reflective operations 
self omission direct method stems unification method invocation variable access assignment shown 
consequently way self refer method opposed result execution 
designers self felt method object oriented method thing invoked message sent object object gets decide 
came time build programming environment clear way needed refer methods 
solution mirror named originally pun reflection suggest smoke mirrors original notion mirror object appear dictionary entries named slot names original object entries contained mirrors contents slots satisfying principle stratification 
slot objects introduced 
asked dictionary entry slot mirror returns object represents slot 
contains slot name attributes parent slot mirror contents slot 
self mirrors support introspection self modification 
examples reflect anobject size returns number slots object reflect anobject prints slots object line reflect anobject put reflect adds slot containing object reflect anobject fred true turns slot named fred parent slot self randall smith observed side mirrors decrease uniformity clear self objects slots sending object returns sending returns product rho cos theta 
way base self language obtain method 
mirror object 
sending size message returns sending returns mirror sending returns mirror method slot 
new method accept mirror base object argument 
worse functionality printing cleanly fall base meta levels 
designers self quite pleased stratified mirror design worked 
argue mainstream class languages benefit model metaprogramming follows principles 
accepts premise realize fundamental problem class languages know 
single class language know displays problems associated instanceof class identity tests described 
believe class mindset drags implication class object reasonable thing client code know 
knowledge inhibits reuse 
hand existing prototype languages self allow sufficient latitude programmer express intentions linguistic level 
consequently agree ole lehrmann madsen view important bring classes prototypes 
words know characteristics lack concrete example 
role types distinguish 
structural type systems 

nominal type systems exclusively interfaces 

optional type systems 

dynamically typed systems 
approaches support principle encapsulation mandatory version reliably help identify reflective api supporting goals deployment 
mandatory nominal type system avoids implementation types shield designers design errors affect current mainstream reflective architectures 
believe system choice languages seek employ mandatory typechecking 
considerations impact design language type system discussing scope 
fortunately careful mirror design means need rely type system separate reflective api 
benefits mirror api independently course may problems prototype languages know 
type system 
key constraint type system avoid relying exclusively implementation types 
designing languages tandem reflection definition reflective api reifies ontology programming language 
principle structural correspondence demands construct language map interface api 
examining jdi see large framework reify complex language ontology primitive types classes interfaces access control packages methods constructors initializers 
language complexity manifest reflective api size api directly related size language 
adds attraction simple languages small number general constructs opposed complex languages large number highly specialized constructs 
reflection necessity modern applications plausible suggest languages designed tandem reflective apis 
reflective api large complex language designers take indication language large complex 
metadata idea language support user defined metadata garnered attention 
support added java programming language 
metadata context consists user specified data attached elements program source class method declarations 
design metadata facilities raises issues discussed specifically ability examine metadata distributed settings source loaded 
self mirrors provide home metadata 
originally self user specifiable metadata 
project gained capability user level code associate arbitrary object called annotation object slot 
self virtual machine implemented facility extra space maps exposed annotations mirrors 
self level methods mirrors implemented annotation functionality get set annotations objects slots 
providing class place meta level operations designer chooses mirrors prepares expansion reflective capabilities 
disadvantages mirrors mirror architectures reify distinction base meta level operations 
distinction awkward ambiguous mirrors just get way 
instance consider user interface object allows programmer inspect slots object 
mirrors expect prototype anobject 
system mirrors faced awkward choice message takes object argument slot examiner proxy object 
message takes mirror argument invocation method suffer verbosity mirror creation operation 
non uniform system option drawbacks 
issue protocol object inspector may moot true believer reflection inspector reflecting send mirror hang verbosity cost line base meta level blur far distinction left 
consider operation printing object 
consider reasonable printed representation respect separation base meta 
example list object print list containing car truck part string uses name class object meta level part uses list iteration code base level 
mirror architecture adds complexity printing code introducing explicit level shifts code 
distinction base meta level fails model problem solved mirrors nuisance help 
ultimate mirror system reflection metaprogramming api supports introspection self modification code computation 
includes distinct layers mirroring virtual machine language high level language 
clearly separable underlying base language allowing applications reflection meta programming api deployed independently 
assume particular implementation transparently allows local remote demonstrably allows multiple implementations 
system support ide remotely manipulating small footprint vm include full implementation reflection pda mobile phone 
reflective systems constructed date fully meets goal see table highlights lack support self modification table summarizes key properties mirror systems discussed 
strongtalk api designed goals mind compile time metaprogramming mirroring method level 
development strongtalk ceased mirror api fully mature 
result distributed implementation constructed validate 
contrast jdi successfully implements distributed metaprogramming production assumes operating runtime representation separation virtual machine high level languages 
jdi interface designed fully support self modification actual implementations restrictive support completely absent 
self lacks complete support vm level language reflection facilities fully support fine grain reflection method level mirror 
appears satisfy criteria 
question support mirror set ting intriguing 
speculate leave research 

related pluggable reflection closest lorenz vlissides address deficiencies mainstream reflective systems 
main focus violation encapsulation principle 
consider alternate designs reflection languages concentrate pragmatic methodology tools ameliorate problem users existing systems 
patterns component techniques reducing coupling reflection clients 
note problem temporal correspondence terminology differs offering solution 
directly address design principles discussed 
declarative metaprogramming declarative metaprogramming declarative languages metaprogramming 
particular logic metaprogramming uses logic programming language define metaprograms 
language manipulated metaprogram need declarative language 
metaprogramming occurs languages principle stratification naturally obeyed 
declarative language avoids subtle problems class identity mentioned section 
possible construct declarative metaprogramming system obeys principles encapsulation correspondence property taken granted 
lisp historically reflection pioneered lisp standard semantics reflection done context lisp 
object oriented lisp systems exemplified clos germane 
reflection clos supported meta object protocol mop part language definition 
mop declarative model language ontology 
mop focused support reflection including introspection self modification notably rich notion 
table compile time run time hll strongtalk self jdi mixed mixed apt clos meta objects include classes 
smalltalk classes application purposes creating new instances method instance maintaining shared state class variables may application specific methods 
contradicts principle stratification 
mop largely structural correspondence reifies entities run time semantics 
compile time mops compile time mops key properties 
deal code define meta objects reify entities exist compile time 

allow code access mop code compiled 
lets code influence compiled compile time computation supporting form 
code manipulate structure mop supporting generative programming 
item implies meta objects provided compile time mop necessary sufficient support principle correspondence 
hand ability metaobjects compile time computation required design principles discussed 
discussion scope 
apt apt annotation processing tool compile time metaprogramming api designed support processing metadata 
api mirror uses interfaces exclusively supports encapsulation stratification 
apt explicitly deals compile time properties source language java line principle correspondence 
api provide access constructs method level 
unfortunately apt integrated run time reflection api 
net reflects method lvl reflection api supports introspection dynamic creation evaluation programs self modification 
api classes 
allows alternate implementations derived subclassing 
principle encapsulation uniformly adhered 
particular part api supports dynamic construction programs classes interfaces 
appears classes fully fix certain properties especially representations implementations 
despite flaws appears considerable scope alternate implementations introspection 
clear cut separation base level meta level 
classes directly support reflective operations gettype operation embedded root type hierarchy object overridden 
class types exposed checked casts typeof operator equivalent java instanceof hardwired notions type identity 
api primarily reflects net virtual machine language support constructs enumerations appear domain high level languages 
distinct layer api dedicated high level language 
appear separation code computation 
example methods support invoke operation supported examining classes source code database 
beta beta metaprogramming system automatically produces class hierarchies syntax grammar close correspondence principle structural correspondence 
generated hierarchies associated tools support metaprogramming reflection 
provides support run time reflection including 
distinction line principle temporal correspondence unfortunately apis unrelated 
oberon reflective architecture oberon factors reflection separate module mirror systems 
reflective information accessed riders iterator objects support traversal reified program 
riders introspection program declarations call stack dynamic execution 
system support self modification 
mirrors riders correspond directly individual entities program 
represent sequences similar entities 
riders correspond directly language ontology appear support stratification 
firewall allen wirfs brock discuss properties declarative model smalltalk programs 
object model propose appears mirror system smalltalk implemented firewall prototype parcplace smalltalk 
discuss advantages distributed development deployment 
discussion smalltalk specific relies critically general notion declarative program model smalltalk 
discuss separation high level mirrors low level ones interactions static typing multithreading relation prototypes 
wirfs brock implies declarative language definition basis clean mirror system 
key part definition language syntax 
aspect oriented programming aspect oriented programming aop roots reflection meta object protocols particular 
view aop identifies subset reflective operations frequently useful application development seeks represent subset base level dedicated constructs 
aop deeply concerned distinction meta level base level operations 
aop relates peripherally chief concern design meta level apis 

design principles meta level facilities object oriented programming languages 
encapsulation 
meta level facilities encapsulate implementation 

stratification 
meta level facilities separated base level functionality 
ontological correspondence 
ontology metalevel facilities correspond ontology language manipulate 
mirror systems substantially embody principles 
isolate object oriented programming language reflective capabilities separate intermediary objects called mirrors directly correspond language structures reflective code independent particular implementation 
result mirrors remote distributed development easier 
mirrors deployment easier reflection easily taken added dynamically 
design principles mirrors may obvious principles widely applied reflective apis object oriented programming languages 
mirrors implemented different programming languages 
include class languages dynamically statically typed prototype language self originally conceived 
mirrors successfully demonstrated practice rich ides built mirror reflection production quality debuggers 
full power mirror systems realized 
systems fully support metaprogramming code computation virtual machine high level language levels demonstrated 
potential clear 
believe advantages mirror systems greatly outweigh disadvantages mirror metaprogramming apis norm object oriented languages 

acknowledgments possible teams built mirror systems described 
self team ole agesen lars bak craig chambers bay wei chang urs lzle lee john maloney randy smith david ungar mario wolczko 
strongtalk team lars bak gilad bracha steffen robert david griswold urs lzle 
jdi team robert field gordon hirsch james mcilroy 
apt team joseph scott seligman 
authors grateful christian hansen kenneth russell productive discussions issues wuyts stephane ducasse mads sophia slurp group imperial college anonymous referees helpful comments earlier drafts 

ole agesen stephen freund john mitchell 
adding type parameterization java language 
proceedings acm conference object oriented programming systems languages applications october 
ole agesen jens palsberg michael schwartzbach 
type inference self analysis objects dynamic multiple inheritance 
software practice experience september 
gul agha 
actors model concurrent computing distributed systems 
mit press cambridge massachusetts 
annotation processing tool home page java sun com se docs guide apt lars bak gilad bracha steffen robert david griswold urs lzle 
mixins strongtalk 
ecoop workshop inheritance june 
gilad bracha 
strongtalk type system smalltalk september 
oopsla workshop extending smalltalk language 
gilad bracha william cook 
mixin inheritance 
proceedings joint acm conference object oriented programming systems languages applications european conference object oriented programming october 
gilad bracha david griswold 
strongtalk typechecking smalltalk production environment 
proceedings acm conference object oriented programming systems languages applications september 
gilad bracha david griswold 
extending smalltalk mixins september 
oopsla workshop extending smalltalk language 
brandt rene schmidt 
dynamic reflection statically typed language 
technical report pb 
department computer science aarhus university june brian smith jim de rivieres 
reflection semantics lisp 
proceedings th acm sigact sig plan symposium principles programming languages 
shigeru chiba 
metaobject protocol 
proceedings acm conference object oriented programming systems languages applications october 
shigeru chiba 
macro processing object oriented languages 
proc 
technology object oriented languages systems tools pacific australia november ieee press 
krzysztof czarnecki ulrich eisenecker 
generative programming 
addison wesley reading massachusetts 
adele goldberg david robson 
smalltalk language implementation 
addison wesley reading massachusetts 
james gosling bill joy guy steele gilad bracha 
java language specification third edition 
addison wesley reading massachusetts 
javadoc tool home page 
java sun com se javadoc 
gregor kiczales jim des rivieres daniel bobrow 
art metaobject protocol 
mit press cambridge massachusetts 
sheng liang gilad bracha 
dynamic class loading java virtual machine 
proceedings acm conference object oriented programming systems languages applications october 
david 
lorenz john vlissides 
pluggable reflection decoupling meta interface implementation 
proceedings international conference software engineering may ole lehrmann madsen 
keynote address 
oopsla november 
ole lehrmann madsen moller pedersen nygaard 
object oriented programming beta programming language 
addison wesley reading massachusetts 
pattie maes 
concepts experiments computational reflection 
proceedings acm conference object oriented programming systems languages applications october 
informatics 
system metaprogramming system 
available www com system en php hans peter ck christoph 
oberon reflection model applications 
proceedings second international conference metalevel architectures reflection july 
michael richmond james noble 
reflections remote reflection 
proceedings th australasian conference computer science 
gold coast queensland australia pp 
self programming language homepage 
research sun com research self tim sheard simon peyton jones 
template meta programming haskell 
haskell 
october 
sigplan notices pp 

sun microsystems 
java platform debugger architecture 
java sun com products jpda 
sun microsystems 
metadata facility java tm programming language 
www jcp org review jsr shigeru chiba marc olivier 
openjava class macro system java 
reflection software engineering lncs springer verlag pp 
david ungar 
annotating objects transport worlds 
proceedings acm conference object oriented programming systems languages applications october 
david ungar randall smith 
self power simplicity 
proceedings acm conference object oriented programming systems languages applications october 
allen wirfs brock ewing harold williams brian wilkerson 
declarative model defining smalltalk programs october 
invited talk oopsla available www com index htm 
wuyts 
declarative reasoning structure object oriented systems proceedings tools usa august 
wuyts logic meta programming approach support evolution object oriented design implementation ph thesis vrije universiteit brussel 
wuyts st phane ducasse symbiotic reflection object oriented logic programming language ecoop international workshop multiparadigm programming object oriented languages 
