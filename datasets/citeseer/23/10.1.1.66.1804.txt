coherent distributed file cache directory write timothy mann andrew birrell andy hisgen charles garret swart june systems research center lytton avenue palo alto california systems research center charter src advance state knowledge state art computer systems 
establishment performed basic applied research support digital business objectives 
current includes exploring distributed personal computing multiple platforms networking programming technology system modelling management techniques selected applications 
strategy test technical practical value ideas building hardware software prototypes daily tools 
interesting systems complex evaluated solely extended allows investigate properties depth 
experience useful short term refining designs invaluable long term advancing knowledge 
major advances information systems come strategy including personal computing distributed systems internet 
perform complementary mathematical flavor 
established fields theoretical computer science analysis algorithms computational geometry logics programming 
explores new ground motivated problems arise systems research 
strong commitment communicating results exposing testing ideas research development communities leads improved understanding 
research report series supplements publication professional journals conferences 
seek users prototype systems common interests encourage collaboration university researchers 
robert taylor director coherent distributed file cache directory write timothy mann andrew birrell andy hisgen charles garret swart june digital equipment may copied reproduced part commercial purpose 
permission copy part payment fee granted nonprofit educational research purposes provided partial copies include notice copying permission systems research center digital equipment palo alto california acknowledgment authors individual contributors applicable portions copyright notice 
copying reproducing republishing purpose shall require license payment fee systems research center 
rights reserved 
extensive caching key feature echo distributed file system 
echo client machines maintain coherent caches file directory data properties write delayed write back cached information 
echo specifies ordering constraints write enabling applications store maintain consistent data structures file system crashes network faults prevent writes completed 
describe echo cache coherence ordering semantics show improve performance consistency applications explain implemented 
discuss general problem reliably notifying applications users write lost addressed problem part echo design find fully satisfactory solution 
contents design motivation coherence ordering semantics ordering constraints reporting lost write semantics performance implementation coherence fault tolerance security resource reservations ordering constraints reporting lost write advisory lock tokens related echo distributed file system incorporates replication caching global naming distributed security 
gives block diagram echo system 
replication 
echo replicates servers availability disks data integrity allowing wide range configurations tolerating server crashes network faults 
interconnections disks servers client machines replicated 
caching 
echo client machines keep coherent write back caches data properties files directories volatile memory reducing latency seen applications file system operations reducing read load peak write load servers 
caches ordered updates buffered cache automatically flushed time delay written server disks defined partial order limiting damage occur client machine crashes volatile memory erased 
term clerk module client operating system performs functions 
global naming 
echo supports globally scalable hierarchical name space 
upper levels hierarchy implemented replicated name service achieves high availability loose consistency semantics lower levels implemented file system tight consistency somewhat lower availability 
distributed security 
echo adopted security model servers trust client machines client machines cryptographic protocol authenticate acting behalf users logged 
concentrates echo client cache 
separate papers give complete overview echo discuss various aspects detail 
section discuss motivation echo cache design section cache coherence ordering semantics facilities reporting lost write 
show semantics useful echo longer development avoid awkwardness speak tense 
applications os echo clerk echo server primary applications os echo server secondary echo clerk block diagram echo system 
client machines network server machines disks applications section directory write improve performance applications section 
section give details cache implementation 
section compares echo cache related section summarizes 
design motivation section discuss goals motivated echo cache design explain shaped resulting system 
wanted echo distributed file system meet exceed standards set single machine file systems performance semantics fault tolerance security 
echo performance goal provide service comparable better single machine file system similar hardware 
high throughput low latency individual operations 
wanted maximize number client machines handled server 
ambitious goal led aggressive cache design 
workstations dedicate megabytes main memory cache 
echo clerks cache files directories users see performance reading file data opening files listing directories 
clerks write files directories users see low latency writing files creating deleting renaming changing access permissions files directories 
write opens opportunity reduce load servers increasing capacity optimizing sequences operations cancel reach server example writing file page repeatedly creating deleting temporary file gone far implementing optimizations 
echo semantic goal single system view applications 
far possible distributed file system interface semantics application program single machine file system 
application distributed machines see consistent file system slightly inconsistent ones 
goal led implement file cache strict coherence replication scheme strict consistency copies 
chose explore alternative approach locus coda file systems replicas cached copies files allowed diverge periods network fully connected 
forbid write write conflicts clients different changes copies file read write conflicts client changes copy file client continues read old version 
desire single system image led emulate unix file system carefully distributed file systems done 
example nfs echo keeps file unlinked name space existence long application program open 
nfs echo clerk allows applications write data cache knows disk space available server hold data cache flushed 
echo fault tolerance goal mask faults system components feasible fail cleanly possible faults occur masked 
fault tolerance increasingly important distributed systems unix trademark unix systems laboratories built individual machines fail independently 
visible fault tolerance feature echo replication servers disks discuss fault tolerance considerations affected cache design 
token directory needed maintain cache coherence replicated main memory different servers failure server invalidate client caches force write discarded 
server loses touch clerk server revoke clerk tokens agreed timeout lease expired 
applications read different caches time see inconsistent data running machine partitioned away rest network 
provide clean failure semantics guarantee write reach disk partial order known applications allow applications add constraints partial order 
discard write give application may read written discarded data error return reads writes attempts halting progress observe anomaly 
echo security goal protect privacy integrity stored information requiring machines distributed system trust compromising system performance 
goal led place trust boundary servers clerks 
servers trust operating systems client machines provide proper security 
clerks authenticate servers acting behalf particular users cryptographic protocol 
authenticated clerk privileges user acting touch data user permitted access corrupt data structures file system implementation 
access checks expensive led develop form access check caching echo server needs access checking clerk requests cache coherence token read write 
security machinery easy add system design phase hard retrofit chosen omit security initial design 
coherence ordering semantics echo single copy equivalent moment file system data single defined state 
operation changes state called write 
operation returns information state changing called read 
operation logically performed carried distinct point real time reading changing state exists moment 
take view operation logically performed different time want times define total order operations 
application issues system call requesting operation time call returns time operation logically performed time 
absence faults echo caching transparent network faults machine crashes occur write operation changes file system state 
faults occur echo remains single copy equivalent caching longer fully transparent 
fault change state file system data causing updates written discarded reach disk 
writes logically undone unique point real time moving file system data new state reflected reads writes performed point 
semantics single machine file system write differ nfs caches incoherent 
nfs process machine see old data reading file process machine file open writing see old data directory process machine modified directory 
echo cache remains single network faults cause machines partitioned away rest system 
partition server crash prevents clerk accessing file system current state perform application read write request clerk blocks waiting state accessible returns error indication 
options similar respectively hard soft options mounting nfs volume 
environment practical clerks block operations limited time minutes give return error indication problem remains 
policy works echo echo faulttolerance features correct problems automatically minutes 
problem minutes kind needs fixed manually may take long time 
best unblock applications give error returns point 
ordering constraints crashes network faults cause write discarded order writes reach disk important 
echo allowed writes reach disk arbitrary order applications store mutable data files find data inconsistent crash write lost 
echo specifies partial order writes guarantees actual order writes reach disk consistent partial order 
echo provides primitive lets applications augment partial order additional constraints 
knowledge echo ordering guarantees carefully coded application assure data structures stores file system remain consistent write lost crash 
section gives examples remainder section describes constraints 
section includes brief comparison approach fault tolerance alternative providing atomic transactions file system interface 
say write stable reached disk say write discarded logically undone reach disk 
writes eventually stable discarded 
call write unstable logically performed stable discarded 
stated informally echo guarantees follows write requested client machine results observed write stable 
writes object stable order logically performed unbroken sequence overwrites requested single client may reordered 
overwrite write operation file change length 
writes stable forced disk fsync 
state echo stability ordering constraints formally define relations 
intuitively relation expresses data dependency operations related affected result second 
relation partial order writes guaranteed reach disk 
viewed set ordered pairs relation subset 
formal definitions follows 
operations file system say 
write operation 
operand common unix system call fsync returns writes file returned fsync called guaranteed disk 
echo allows fsync directories ordinary files 
return successfully logically performed discarded logically performed 


relation transitive 



say 
write operations overwrites data writes file change length 

relation transitive 

ando discarded discarded 

ando requested applications running different client machines logically performed stable 
corresponds informal guarantee 

stable stable 
informal guarantee 

write operation fsync returns successfully stable 
informal guarantee 
echo read write operations include usual unix file system operations plus new operation adding constraints described 
read operations include getting properties file directory unix stat system call opening file reading file data listing directory looking pathname component directory forth 
system calls involve looking pathname viewed formally operations logically performed sequence consisting component lookup directory path followed operation final object 
read operations just operand 
write operations include writing file data creating file directory renaming fsync forth 
view fsync write operation role plays constraining order operations stable successfully returns control caller indicating error 
write queued operation may fail 
overwrite data overwrite data append data overwrite data overwrite data overwrite data overwrite data relation writes single file 
writing 
file data write overwrites existing data appends new data viewed formally operations pure overwrite logically followed append 
file data overwrite guaranteed failure atomic modifies bytes block file block size parameter set echo implementation currently bytes 
overwrite meet criterion may implemented arbitrary sequence shorter overwrite operations shorter overwrites failure atomic sequence failure atomic ordered 
write operations failure atomic 
write operations may multiple operands example rename file file named exists operation modifies old parent new parent file renamed old file displaced total operands 
echo adds write operation usual set called 
fsync operation modify operands follow stability rename rename rename rename relation renames 
rules write operations 
fsync returns immediately waiting operations ordered stable 
operation useful adding constraints order writes stable delaying caller fsync give examples section 
figures illustrate ordering constraints 
series write operations applied single file operations ordered joined arrows ordered 
different records file overwritten writes ordered 
new record appended write ordered overwrites 
overwrites occur ordered append 
call followed overwrite 
change file way causes final overwrite ordered earlier ones 
files renamed 
renames ordered affect different files different directories operands common 
third rename follows affect directory fourth rename follows affects directories echo limits scope ordering constraints requiring operands operation volume 
echo volume roughly similar unix file system subtree global hierarchical name space stored single possibly replicated set disks managed single possibly replicated server 
echo volumes tied junctions differ unix mount points stored stably joined volumes global clients file system established individually differently client machine run time 
unix echo permit files renamed hard linked volume 
permit operations operands volume 
restriction greatly simplifies echo implementation echo interfaces reporting discarded write discussed section requires applications keep file data structures single volume take extra care cross volume dependencies arise 
reporting lost write section said carefully coded application take advantage echo ordering guarantees ensure file data structures remain consistent write lost crash suggesting applications deal lost write restarting invoking crash recovery 
lost write echo caused crashes 
network fault cuts communication clerk server server revokes clerk cache coherence tokens order allow clerks proceed 
forces clerk discard write order maintain cache coherence halt programs running clerk machine 
write discarded double server crash causes entire token directory lost 
contrast nfs single machine unix discard write machine holding write crashes course halts applications running machine 
echo applications additional problem deal finding writes depend discarded appropriate action 
echo provides facilities help describe 
discussion precise say application process depends issued write done read write operation 
cases directly observed effect file system state 
expect processes changing part file system internal state inconsistent file system 
continues running discarded reads file system may observe inconsistency confused writes may write data inconsistent new file system state 
deal problem echo normally halts progress process depends discarded write volume giving error return operations process tries invoke volume 
process receives error return immediately abort error message processes may observed effect example may told system detect 
general safe process communicate information file system state outside information stable 
effectively converting error crash considered sending affected processes asynchronous unix signal processes access file system infrequently halt quickly idea find time try 
processes notified lost write way standard recovery mode discuss alternative modes 
process self recovery mode write depends lost open files affected volume marked new operations attempted give error return 
process working directory marked way affected volume new operations specify relative pathnames give error return 
operations specify absolute pathnames including changing working directory allowed restriction 
vision process mode making file initialization open files relative pathnames received error return reporting lost write 
point process run recovery code reopen files working directory absolute pathnames 
self recovery mode turned useful practice 
existing programs distinction usage absolute relative pathnames generally behave reasonably mode absolute pathnames unfortunate places fail notice lost write relative pathnames fail recover 
application maintains state file system wants recover lost write errors easily structured processes child process real halts lost write detected plus parent process restarts child halt 
child runs recovery code regardless restarted due lost write due machine crash reboot 
self recovery mode useful newly written programs 
different recovery mode call null recovery mode useful interactive shells 
mode write process self recovery mode ugly largely attempt fit new concept existing unix file system interface 
free change interface adopted cleaner approach self recovery explicit failure handles 
approach read write operation accepts failure handle additional parameter 
semantics lost reporting changed replace process failure handle concept dependency writes issued failure handle operation issued andw depends 
write discarded subsequent operations issued failure handle depends write give error return 
standard recovery mode special case process chooses new failure handle access volume uses subsequent accesses 
depends lost process open files affected volume marked new operations attempted give error return 
new files opened name restriction working directory remains valid 
mode useful interactive unix shells keep files open long remember file system state 
unmodified unix shell simply prints message continues receives error return reporting lost write nicely null recovery mode 
unfortunately implement null recovery mode echo ran shells self recovery mode 
fact historical reasons ran programs self recovery mode clearly mistake 
users results confused lost write caused shell forget working directory 
running shells standard recovery mode worse users quite unhappy shells crashed lost access file system write lost 
echo file system interface allows applications obtain locks files 
echo provides berkeley style advisory locks uses form internal lock implement unix feature keeps file deleted long process open removed name space 
implementation locks obtained cached way file data 
locks discarded write client machine crashes cache coherence tokens revoked server due network fault 
client machine crashes locks released allowing machines obtain progress 
locking operations participate 
relations lock acquisitions count file accesses purpose lost write reporting 
process depends lost volume receives error returns attempts acquire new locks volume 
conversely lock open file discarded attempts read write receive error returns timing window lock released processes read write file 
write discarded notifying affected processes idea notify user directly 
programs specially coded deal possibility lost write may handle cleanly 
example process writes file system usually exit calling fsync changes stable changes discarded process left notify error 
cases process ought abort problem considered changing semantics process exit include calling fsync files directories process modified judged additional safety worth performance penalty 
existing programs prepared handle error return attempt exit 
write lost may print message continue may simply ignore error returns 
unfortunately hard notify users discarded write way sense 
echo prints console message happens users find messages cryptic entirely console window 
worse way notifying user write lost machine crashed 
single machine unix nfs problem 
really ideas improving situation inherently accept write store client machine memory violate simple abstraction stable disk file system programs users expect see 
ameliorate problems causes providing ordering guarantees notification discarded write eliminate 
semantics section describe ways applications echo caching ordering semantics 
important file system coherent caching easier writing distributed application incoherent caching 
example suppose build distributed parallel tool speeds recompilation large programs farming compilation individual source files different machines linking results machine 
coherent distributed file system tool ordinary compilation steps simply write results file system link step simply read knowing get correct data 
system nfs incoherent caches things simple 
implementations nfs give close open coherence meaning file closed readers open get correct data nfs provide coherence directories 
example linker tries open files compilers written may find cached copy directory 
example sounds contrived aware real world instances phenomenon 
colleagues hector lexicography project tried nfs maintain shared file dictionary definitions read updated multiple lexicographers 
running intractable bugs caused nfs incoherent caching forced rewrite code get data centralized server going directly file system 
original design worked fine echo 
echo guarantees data written machine read data stable 
consequence rules pertaining 
relation 
distributed application component processes communicate file system sure echo clerk write lost processes running clerk machine affected 
lost data propagated processes machines 
effect affected machine crashed 
making echo ordering semantics difficult making cache coherence effort worthwhile applications store data structures file system want sure structures corrupt write lost 
way semantics follows 
carefully order application file system write calls crash halts application point data structures written consistent worst automatically restarted 
step produces application robust crashes run file system 
second check echo ordering constraints forbid reorderings writes leave data structures inconsistent state 
add calls application forbid unwanted reorderings 
worst case done adding calls forbid reordering 
examples follow 
gives simple example writing file replacing atomically new version 
arrows show operations related omitting arrows inferred transitivity 
example echo built ordering constraints provide exactly needed calls 
write data 
create file new intended new version write new data 
rename new replace rename write operation new file changing name old file deleting ordered operations 
assured write lost new file replace old intended contents reached disk 
ordinary unix file system provide guarantee 
unix systems directory operations write file data write chances excellent new renamed contents reached disk 
crash contents reach disk reboot providing guarantee certain cost applications communicate machines file system disk speed network speed 
note nfs effectively provides guarantee cost 
create append data create new append new data rename new replacing file new version 
name point garbage file name old referent destroyed 
gives example replacing directory new version 
left hand column shows initial attempt coding procedure 
create new directory new write files new new 
rename old version old rename new version remove old contents shown 
procedure interrupted crash small amount recovery restart renaming old back exist removing new old exist 
initial attempt write reordered recovery complete copy old version new version reordering introduces problem 
final rename operation new files new operands relation order data writes files rename 
file creations ordered new operand data writes 
rename reaches disk guarantee file data disk crash network fault leave directory full garbage files 
problem easily fixed inserting call shown gray right hand column 
call establishes synchronization barrier operations new new new logically performed ordered operations new create new append new data create new append new data rename old rename new new new new replacing directory new version 
operands logically performed 
particular ordering arrows shown gray ensure contents files reach disk final rename operation 
applications complex changes data structures stored file system may write ahead logging 
application appends intentions record log file proceeds changes order 
application restarted crash reads log file changes recorded log 
time time application reclaims log space speeds crash recovery trimming prefix log making sure changes point reached disk 
shows echo ordering constraints improve performance write ahead logging 
conventional unix file system way sure log record reaches disk changes describes call fsync log file writing record making changes 
doing slows update introducing additional wait disk 
append logfile intentions logfile update 
update 
update 
write ahead logging 
application write ahead logging generally need force log disk certain commit points points application reports user updates requested stable typically writes log commit points want force log log write 
echo place fsync eliminating need wait 
writing log record issue operands log file files directories updated 
ensures updates reach disk log record 
application need force log commit point simply calls fsync log file 
example incomplete 
elaborate include means trimming log trim log forcing updates disk 
possible complex go details 
echo ordering constraints fsync useful ensure previously written data stable previously read data stable 
illustrates 
application writes data second application read returns data 
suppose second application wants sure data stable printing results aborting data discarded 
calling fsync onf point read aborting call gives error return 

read returned written data read ordered write shown broken arrow 
application process depends write sense defined write data read fsync checking data read stable 
section echo lost write reporting rules guarantee write discarded fsync logically performed fsync call give error return 
fsync call returns error write discarded time fsync performed echo ordering rules fsync ordered write shown solid arrow write stable 
echo advisory locks provide convenient building block implementing replicated services top echo replicated file system 
technique store service data echo volume provide access pair servers 
normal operation server acts primary holds exclusive advisory lock agreed file volume 
second server acts backup blocked waiting acquire exclusive lock file 
primary server crashes partitioned away file system echo revokes lock 
result backup server acquires lock begins running new primary start new backup desired 
echo lost write reporting removes old primary ability access shared volume time revokes lock new primary certain old longer modifying shared data takes 
conversely existing primary sure new primary taken long able access shared data 
number techniques echo ordering constraints just described real applications 
particular vesta software configuration management system developed colleagues research center uses variants file directory replacement techniques 
vesta uses techniques atomically create new files directories full files replace existing ones 
vesta write ahead logging technique unfortunately vesta procedures need logging involve updates echo volume 
performance mean time range relative runs time full write sec directory write sec write back close sec table elapsed time compile line programs 
section show echo directory write improve performance applications giving benchmark measurements 
benchmarks include compiling line programs running phase andrew benchmark creating new version software package vesta system simple loops creating deleting files directories 
benchmarks run considerably faster echo directory write enabled disabled 
benchmark shows echo write providing better performance directory operations production quality unix system echo slower write 
benchmarks measure kind file system performance ordinary application observes 
applications write data files unix concern data reaches disk quite satisfied report success exit soon system data buffered memory write 
specifically stated running times measured benchmarks include time flush writes disk sync fsync 
benchmarks discussed echo clerk benchmark programs running processor firefly processor mips microvax chip 
echo servers running processor dec ra disks 
client server machines connected mbit sec network 
unix benchmark run processor vax mips microvax chip dec ra disks 
table shows results simple compilation benchmark 
source files containing single line function compiled control unix program 
run tested existence object files created processes running compiler 
compiler instance read source file wrote object file 
table gives mean time range relative runs time full write sec directory write sec write back close sec table elapsed time phase andrew benchmark 
average elapsed time different versions benchmark 
line table shows time run benchmark echo normal configuration write files directories 
second line shows running time echo clerk modified write changes directories continue write changes file data 
benchmark file creation operation involving directory change 
benchmark took longer run case 
third line shows running time clerk forced write directory changes write back changes file data file closed 
case benchmark took longer run 
table shows results similar benchmark realistic workload 
phase phase known andrew file system benchmark cmu run echo configurations 
phase involves compiling seventeen source files creating libraries linking application program 
table indicates benchmark runs took longer directory write longer directory write file write back close 
results mean 
benchmarks directory write gave clearly measurable improvement running time 
file write back close gave clearly measurable penalty 
clear benefits directory depend time application spends modifying directories 
benchmark files compiled short spent running compiler 
speeding file creation gave large improvement 
second benchmark compiled larger files spent time running linker library builder benefit speeding file creation 
real applications see benefits closer andrew think directory write file data write base case comparison single machine unix file systems provide newer distributed file access protocols emerging successors nfs see section 
mean time range relative runs time full write sec directory write sec write back close sec table elapsed time vesta benchmark 
benchmark simple compilation benchmark 
important note benchmarks run relatively slow machines today standards 
processors get faster disk speeds lag applications see benefit directory write 
table shows results benchmark run vesta software configuration management system 
benchmark developed vesta research group evaluate performance vesta code repository 
simulates storing new version software package repository case source files package changed previous version user compiled linked sources produce new set derived object files 
new set files copied repository little done 
test source files comprising kbytes data derived object files comprising kbytes 
table shows benchmark took times long directory turned times long file write back close 
result may strange 
directory write slow benchmark files written 
explain recalling vesta implementation heavy echo write ordering guarantees ensure data structures remain consistent despite crashes discussed section 
particular vesta sure file completely written appears repository permanent name files directory tree completely written tree appears permanent name 
benchmark rename operation ordered file written 
renames written files written making benchmark run slowly files written written back close 
benchmark interesting point file system design unix echo echo write echo local disk write plus sync write create files delete files create directories delete directories table elapsed times operations seconds 
mean runs 
choices 
designing echo decided directory decided give ordering guarantees write 
said operation reordering lost write problems conventional unix systems file data written 
consider adding ordering guarantees systems directory write 
unfortunately benchmark shows directory write ordering guarantees bad combination reduce performance file writes point write 
final benchmark absolute speed tests version unix running local disks hardware similar echo table displays cases echo showed advantage creating empty files deleting files creating directories deleting directories 
case operations performed single program executing system calls 
comparing columns table unix system fast deleting files case echo considerably faster unix 
fact cases echo faster timing included time flush write sync system call shown table third column 
cases echo slower unix write turned fourth column 
additional information internals unix echo helps explain numbers table 
measured operations write disk unix implementation numbers unix local disk column include time disk write cases 
appears file deletion requires synchronous disk write unix system measured seconds roughly time required ra disk drive rotate times 
numbers echo column primarily reflect time needed update clerk memory data structures disk writes required 
numbers column echo write sum time required clerk update memory structures time remote procedure calls time server process calls time disk writes 
tests reported third column echo write plus sync involved amount fourth column measured times smaller pipelining server disk drive working parallel 
addition group commit log come play server reducing total number disk writes 
evident measurements echo clerk server required considerably cpu time comparable operations unix counterparts 
server particular heavily cpu bound 
believe performance problems caused fundamental flaw echo approach algorithms merely artifact prototype implementation 
draw benchmarks section 
seen speedup application gets directory write depends strongly amount computation directory writes 
final benchmark see echo prototype benefits directory write file systems echo servers relatively slow 
factors difficult tell just worthwhile add directory write production file system 
undoubtedly benefits 
implementations echo clerk server relatively slow directory write operations faster echo unix 
reasonable expect adding directory write fast file system implementation faster 
fast file server slow loaded requests clients 
measure effect clear write give clients faster responses requests underlying server slowed heavy load 
implementation section discuss significant features echo caching implementation 
coherence tokens mechanism echo uses keep caches coherent 
basic token algorithm simple 
echo clerk hold data cache obtain appropriate token echo server stores data 
holding read token data item permits clerk read data server cache modify 
holding write token data item permits clerk modify data cache write changes back server 
reading writing token permitted 
server keeps track clerks tokens prevents conflicts cause cache incoherence 
particular clerk holds write token data item clerk permitted hold read write token data 
caches single copy equivalent write tokens outstanding data item case server copy cached copies item identical exactly clerk write token case clerk copy item accessible 
clerk needs token remote procedure call server 
conflicting tokens server new token immediately 
conflicting tokens server calls clerk holds asking give token back 
clerk asked give read token immediately 
asked give write token clerk immediately writes back changes data token covers gives back token 
case clerk discards cached copy data 
implementation data item covered token file directory 
clerks read write cache individual file blocks directory entries 
token granularity convenient choice artificially poor performance applications different machines concurrently accessing different parts file directory writing 
case object token continually moving back forth machines writes continually flushed disk real communication going applications 
behavior problem files environment users echo unix workload shared mutable random access files rare 
environments files accessed way vms example change echo token mechanism byte ranges files technique burrows describes thesis 
problems widely shared mutable directories able 
example shared software installation kept packages stored subdirectories moment ignore fact echo servers may replicated impact replication token mechanism discussed section 
proj packages 
directory proj topaz bin contains symbolic links executable programs stored packages 
user proj topaz bin shell search path programs frequently 
result machine needs read token proj packages time 
tool ships new versions packages proj packages works creating new directory new contents rename operations replace old version new example section 
rename operations course require write token proj packages 
echo put users noticed delay service package shipped clerks waited reacquire read tokens proj packages 
puzzled delay soon discovered cause 
final rename calls package installation forced write token proj packages acquired file creations writes ordered renames renames performed token released completed 
take long time time client needed read token proj packages wait 
fortunately modifying package tool call fsync just final rename operations proved satisfactory 
change write token proj packages needs held long renames 
package tool runs bit slowly users see better performance tradeoff worthwhile 
encountered instances problem fixed general way extending token mechanism directory tokens cover individual entries alphabetical ranges 
write operations echo modify file directory require token care needed avoid possibility deadlock livelock 
example deadlock occur different clerks needed write tokens clerk clerk release token acquiring 
hand livelock occur clerk willing release token acquiring tokens bounce back forth indefinitely clerk able get 
solved problems defining fixed order tokens acquired held 
unfortunately tree structure files directories define natural total order matches order operations find operands operations tree operate unrelated directories choose arbitrary order 
chose sort operands unique numeric identifiers 
write operation operands rename proceeds phases 
phase clerk finds operands may involve reading number directories acquiring number tokens 
phase clerk willing immediately release tokens acquired 
second phase clerk holding tokens needs lost phase proceeding defined order deadlock avoidance 
token second phase clerk marks object covers dirty incrementing counter associated object 
operation completed written back server dirty counter decremented 
clerk write object object dirty counter greater zero 
server asks clerk give back token object dirty counter greater zero clerk driving counter zero sending object buffered write operations server 
operations phase clerk course finishes processing locally sending server 
clerk finds reacquire token second phase checks see object token covers modified phase clerk aborts doing decrements dirty counters incremented retries operation 
abort retry necessary ensure current operation operation modified object serialized 
token schemes flexible 
basic token scheme designed easy extend handle details unix file system interface 
addition open token 
unix file system file deleted name space processes open 
occurs file continues exist nameless longer open 
implement behavior echo machine clerk acquires holds open token file open machine 
read write tokens open tokens called back server conflict type token 
echo clerk uses heuristics reduce overhead acquiring releasing open tokens 
clerk release open token just process machine file open 
file repeatedly opened closed token acquired 
second application opens file reading clerk requests read token open token call server reduces overhead file read happen soon 
clerk takes similar action file opened writing 
heuristics needed releasing open tokens deleted files kept existence open 
application deletes file name space process machine file open clerk releases open token call server deletes file 
server calls back token permits deleting file special kind write token see section application machine file open clerk gives open token response call 
additions set tokens discussed section 
fault tolerance fault tolerance echo clerk implemented leases sessions token replication 
echo uses leases allow servers reclaim tokens clerks crashed time ensuring caches remain single copy equivalent network faults cut communication servers clerks 
lease agreement server clerk clerk token remain valid period time 
clerk renew lease token lease expires server free revoke token network faults prevent server communicating clerk 
lease expires server allowed revoke token unilaterally ask clerk release token wait response 
leases safe way server reclaim tokens held clerk communicate 
clerk machine may crashed may remain communication server long time certainly want server take tokens back clerks ask access files cover 
server unilaterally revokes tokens clerk machine holds running single copy equivalence may violated machine touch server may read write values local cache disagree values seen machines touch 
leases clerk maintain single copy equivalence simply checking time reads writes cached data lease token covers data force 
effect real time communication channel letting know tokens definitely valid server may revoked network connecting clerk server broken 
application clerk server clocks synchronized sufficient run term lease gray compare system section 
rate known error bound fortunate way synchronize clocks machines communicate 
echo uses sessions reduce amount network traffic needed keep leases date 
clerk wants caching data new server calls server establish session 
individual tokens leases token associated particular session lease session 
technique dramatically reduces number lease renewal messages sent reduces bookkeeping burden clerks servers 
echo provides fast way system recover server crashes replicating token directory server backup server 
approach natural echo mentioned section echo uses replicated servers high availability 
server replication echo uses primary backup scheme moment server primary set disks requests clerks directed 
backup server takes primary crashes 
backup path replica data function primary 
token replication easy add top base 
clerk asks primary token primary nested remote procedure call backup records token copy directory call returns primary return token clerk 
primary backup keep token directories main memory disk fast access 
alternative scheme primary server record token directory possibly replicated disk 
main advantage alternative token database lost servers crash 
find advantage compelling slower write tokens disk record memory servers 
apparent advantage writing tokens disk require servers works servers replicated 
token replication require backup server dedicated machine access disk little cost configuring backup server token machinery 
alternative server crashes recover tokens clerks reboots done sprite file system 
scheme backup server takes primary 
scheme normal operation slightly faster primary call backup token acquisition 
failure recovery slower clerks contacted substantial number tokens recovered minutes typical time process sprite clerks server may wait additional timeout period discover 
due echo model implementation security discussed section recovering server check clerks token lists consistency legality file access control lists slowing recovery 
lists legal consistent way determine clerk false claim worst case faulty clerk cause nonfaulty lose cache tokens associated write 
weighing advantages disadvantages prefer token replication line defense server crashes 
encountered double server crashes echo convince token recovery useful second line defense 
considerably reduced disruption users cases 
security mentioned section echo servers trust echo clerks 
operation clerk requests server clerk authenticate acting behalf user authorized perform operation 
example read part file cache clerk authenticate acting behalf user clerk check file acl access control list see user read access file 
clerk able authenticate particular user user logged clerk machine 
authentication login protocols echo uses developed part separate security architecture project described detail 
kinds caching access control decisions fast 
caching authentication protocol implementation remote procedure calls authenticated extra packets cryptographic overhead 
authentication caching scope 
second extended echo token mechanism provide caching acl checks 
extended set tokens separate token kind access permission clerk may file directory 
server needs acl checking token acquisition requests 
actual read write requests server checks clerk appropriate tokens considerably faster sprite research group reached similar sprite modified replicate tokens segment server memory usually preserved reboots recovering tokens clients memory lost 
user logs machine obviously trust clerk clerk able request operation behalf user 
clerk part machine operating system reasonable require kind trust 
server anyway trust clerk 
extended set tokens read token described section replaced tokens 
holding object allows clerk read cache record information object corresponding returned stat system call unix 
access control restrictions obtaining 
holding directory allows looking individual names directory caching results reading entire directory 
holding allows reading file data reading directory entirety 
clerk obtain acting behalf user corresponding access permission 
token corresponding execute file access way server enforce distinction reading executing 
user execute program clerk machine able read clerk able read program way server keep clerk letting user read 
clerk allowed obtain acting behalf user execute access 
write token replaced tokens 
holding file allows writing data changing file length directory allows modifications creating deleting renaming objects named directory 
holding object allows changing object acl 
obtain tokens clerk acting behalf user corresponding access permission write access ownership 
clerk hold object rename delete 
access control restrictions obtaining 
special property clerk holds token object blanket permission acquire tokens object asks acl check 
property needed clerk may written change acl legal obtain tokens asking server copy acl says 
security hole 
clerk acting behalf user change acl server allow clerk change acl asks gained forcing clerk write back change take advantage changed permissions 
table summarizes compatibility rules types cache coherence tokens 
appears intersection row column table permitted different clerks hold tokens named head row column object time open info search read write change change access parent open info search read write table compatibility matrix cache coherence tokens 
appears permitted 
applies files directories table entry intersection 
security implementation departs single machine unix semantics detail 
unix file acl checked file opened 
process file open writing continue write file indefinitely file acl changed remove process write access similarly reading 
emulated feature splitting property holding token allows clerk obtain corresponding acl check 
chose complicated feel unix feature idea fault tolerant 
single machine unix system force processes close open files rebooting 
corresponding rebooting echo way ensure process holding file open acl changed remove access 
unfortunately turns applications wanted run depend unix semantics adopted compromise echo servers allow owner file get read write token file acl give owner corresponding access 
feature allows owner owner continue accessing open file permissions taken away 
allow file owner open file having access permission echo clerk allow 
special rule security hole file owner permission change acl give access 
restricting feature owner problem unix application tried 
nfs essentially feature reason restricts file owner 
resource reservations creating enlarging file directory requires resources file server chiefly disk space 
echo allows clerks reserve resources advance clerk buffers operation write user assured necessary resources available write performed 
disk space reservations fairly simple 
write operation clerk sends server uses clerk reserved disk space 
clerk linked library routine provided server tells space operation requires 
complex operations require varying amounts space routine computes simple conservative estimate 
application asks clerk write clerk checks necessary space reserved asks server 
clerk specifies numbers request minimum amount desired amount 
minimum amount needed complete current application request 
server minimum clerk returns disk full error application 
desired amount amount clerk reserve ahead reduce number reservation requests 
clerk disk space reservation associated session session lease runs server reclaim reserved space 
tokens replicate space reservations lazy form recovery 
chose write requests frequent token acquisitions want slow adding extra remote procedure call backup 
primary server crashes backup takes clerk reservation recovered time clerk sends write request server 
server responds write request asking clerk send current reservation value retry request 
minor security hole mechanism 
malicious clerk lie reservation claiming reserved space really 
cause server disk space clerks able get back legitimate reservations 
decided worry problem arise practice think solution short replicating reservations 
unique identifiers files directories resource clerks reserve 
echo servers trust clerks correctly generate identifiers malicious clerk give identifier different files corrupting file system tree structure 
file directory creation write clerks allowed reserve stock identifiers ahead time 
clerk reserved identifiers associated session server reclaim space needed keep track session lease expires 
clerk automatically granted coherence tokens object creates reserved identifier avoids extra call server object creation 
ordering constraints echo clerk implementation ordering constraints falls naturally way write 
cached object locally modified clerk keeps representation object current state modified portion plus write queue list operations written back server order logically performed 
operation operand write queue operand 
sequence file overwrites unbroken write operation appears single element file write queue 
operation appears write queue operands treated op reaches head queue 
queue data structure corresponds precisely relation write ordering defined section 
clerk sends write operation server checks operation head write queue operands 
clerk sends operation predecessors recursively checking head write queue operands 
improve performance pipeline send write requests clerk server 
write request remote procedure call calls may issued parallel separate threads 
call carries sequence number server knows order physically carried 
load clerk able send continuous stream requests server wait request complete reply arrive network sends 
reporting lost write identify processes depend discarded write echo clerk uses simple conservative technique 
process accesses volume time clerk current session volume recorded part process state 
process accesses volume accessed saved session identifier compared current session identifier volume identifiers differ process may depend write discarded receives error return 
shared exclusive shared exclusive table compatibility matrix advisory lock tokens 
technique conservative necessary 
may write lost old session 
second write lost processes accessed volume may affected loss 
easy fix problem small amount added bookkeeping clerk fixing second require substantial extra bookkeeping 
fixing problems worthwhile depends occur turn depends network faults occur write buffered occur 
designing echo believed token revocation due network faults rare extra bookkeeping worthwhile unfortunately turned case 
fixing problem substantial payoff echo workstations installation lightly loaded moment workstation usually write buffered 
clearly property easily change echo users started doing computing running different mix applications 
advisory lock tokens echo clerk implements advisory locks set tokens file directory 
process machine holds shared advisory lock object machine clerk object 
process holds exclusive lock clerk 
table gives compatibility matrix advisory lock tokens 
cache coherence tokens clerk may hold advisory lock token process machine needs 
advisory locks object repeatedly acquired released applications running machine communication server necessary 
echo clerk schedules write flushed server seconds time logically performed blocks write calls volume write waiting reach disk seconds 
echo workstation active typically write buffered 
clerk requests advisory lock token conflicts held second clerk server calls back clerk holding conflicting token 
conflicting token process second clerk machine holding advisory lock needs second clerk returns immediately 
token callback blocks token longer 
blockage propagates back server clerk ultimately causes application called clerk requesting conflicting lock block lock released 
threads server clerks continue run 
problem implementation conflicting locks result remote procedure calls remain outstanding long time 
rpc implementation calls consume excessive resources rpc runtime library 
know ways fix problem changing rpc system changing way time implement 
clerk advisory lock tokens associated session 
session lease expires server reclaim tokens clerk 
error returns due discarded locks generated mechanism due lost write 
implementation gives desired semantics advisory locks described section 
related section parts echo terminology discuss related systems papers describing systems different terminology 
particular systems different terms call volumes clerks tokens 
echo sprite file system uses tokens maintain coherence distributed file cache 
sprite caching differs respects echo 
sprite clerks cache files directories 
sprite application process asks open file local clerk sends request server machine stores file pathname lookup done 
sprite clerks prefix caching requests sent directly correct server need broadcast consult name server 
prefix cache full fledged directory cache simply maps prefixes absolute pathnames servers store files names prefixes 
example directory subtree rooted usr stored single volume file server fred clerk prefix cache contain mapping usr clerk information usr information longer pathnames usr include 
sprite clerk required hold read token file open reading write token open writing 
differs echo scheme read write tokens needed clerk caching file data 
sprite clerks want hold file open conflicting modes server detects conflict turns caching file requiring reads writes go server 
doing idea machines really communicating data file machine writing reading caching pointless overhead moving tokens back forth machines wasted 
hand machines accessing different parts random access file turning caching best solution better idea give machine token just range bytes file 
designing echo looked way avoid useless caching token passing overhead applications actively communicating file system find solution satisfied 
certainly adopted scheme sprite caching file turned applications different machines open conflicting modes 
scheme may turn caching cases beneficial catch cases files shared sequentially process opens file writes closes process opens reads closes pattern repeats 
unclear extend scheme directories 
files turn caching directory processes different machines actively communicating modifying 
processes announce start access directory opening closing heuristic decide turn directory caching 
heuristic detect sequentially shared files 
research needed area baker compared performance sprite echo schemes handling write shared files choice little difference workload traces able gather 
sprite replicate token directory 
sprite file server reboots crash reconstructs token directory contacting clients asking tokens hold 
pros cons approach discussed section 
sprite leases 
server loses touch clerk invalidates clerk tokens immediately 
reasons discussed section sprite provide strict single copy equivalence 
andrew file system caches files directories client machines 
directory updates afs write write 
afs caches files entirety block block delays writing changes file back server file closed 
file cache kept coherent scheme similar echo afs terms callback equivalent echo token 
afs just cited explain happens different client machines attempt hold file open writing time attempts hold open reading writing 
sprite afs leases provide strict single copy equivalence 
burrows implemented file caching service called mfs similar echo respects 
mfs caches files directories coherence implemented token scheme similar echo sprite afs mfs leases fails provide strict single copy equivalence 
mfs provide guarantees order updates written back file server particular updates directory reordered arbitrarily long reordered update sequence absence faults leave directory state original logical sequence 
example user creates file crash causes write lost file may exist created 
user writes data file renames causes write lost file may renamed data having written 
mfs excellent job saving server cancelling sequences operations net result leave clerk write buffer 
example application creates temporary file writes reads deletes short time mfs avoids sending operations server 
sequence changes modified time directory file created mfs tell server change apparently done 
original plans echo called kind optimization find time implement 
mfs lack ordering guarantees easier implement optimizations echo 
burrows introduced concept byte range tokens mfs 
logically byte mfs file token tokens different bytes file conflict 
changing length file requires holding write tokens bytes implemented echo collapses multiple overwrites file bytes ordered cancelling optimizations 
added deleted 
file properties owner modified time covered token 
data structures interfaces sets tokens file represented ranges representation compact pathological cases 
mentioned believe byte range tokens useful addition echo token scheme workloads shared mutable random access files common 
gray coined term lease file caching server 
developed lease concept simultaneously independently gray chose adopt terminology learned 
gray system write needs kind token 
clerk token file may cache clean copy long lease remains valid 
clerk wants write file sends write request directly file server recalls tokens file performing write 
alternatively server delay write leases expired refusing honor lease renewal requests come waiting period 
gray system sessions cached file independent lease 
quicksilver provides transactional interface file system 
operations multiple files directories grouped transaction committed aborted unit 
chose explore transactional file semantics echo view area interest pleased see research succeed producing practical system 
transactional programming model cleaner seemingly easier echo model ordered allowing write transactions committed 
quicksilver transactions include operations files non file objects cover files different volumes managed different servers 
drawback quicksilver approach requires considerably machinery implement giving rise concern may perform compared conventional approaches 
applications file system need modified properly quicksilver 
default file system action taken quicksilver program part single atomic transaction commits program exits behavior appropriate programs example long running text editors 
extensive bibliography file systems caching client machines see burrows thesis 
course applications echo semantics requires modifying applications adding calls 
modifications optional omitted problem application tolerate lost write problem just bad application run single machine unix system write 
echo distributed file system studied collection useful techniques improving performance semantics distributed file caches demonstrated feasibility 
believe file systems benefit adopting techniques 
particular echo provides fully coherent file directory caching clients ordered write updates files directories 
coherent caching greatly simplifies task writing distributed applications file system 
echo location transparent global naming coherent caching distributed nature file system invisible applications providing better performance uncached file system 
bookkeeping cost maintaining cache coherence worth benefits 
coherent caching write underlying network availability medium store system token directory reliable 
network broken clients unable file system files need cached unable communicate server unable sure caches coherent 
echo system uses network achieves high availability redundancy ethernet non redundant local area networks high availability purpose 
networks unavailable file systems allow controlled forms incoherence locus coda may practical 
system token directory lost client machines lose write disrupting users 
token directory replicated recoverable clients server crash 
prefer token replication line defense faster recovery cost updating replicas token acquisition 
worthwhile implement token recovery second line defense replicas token directory lost 
write important building block file systems distributed 
nearly file system aware write kind file data 
write certainly reduces latency eliminating need applications wait disk write 
improve throughput smoothing load peaks enabling sequences operations net result cancelled leave write buffer 
echo write directory modifications including file directory creation deletion shown improve performance applications 
example speeds compilation programs small modules typical large programs libraries 
speedup large may grow disparity cpu disk speeds increases 
directory write adds complexity file cache implementation implemented successfully problems code place 
major drawback write write fail long process requested gone things exited 
directory write problem worse fundamental way echo designers users conscious problem 
tried provide facilities allowing tolerate lost write cleanly considerable progress area lost remains ugly problem 
fundamentally write provide correct implementation natural semantics programs expect get file system interface write file want bits stored stably time time 
ultimate solution problem eliminate write non volatile ram file server shield clients latency synchronous disk writes 
echo took pronged approach dealing lost write 
easy application writer ensure crash halts application causes write lost data structures stores file system remain consistent 
second easy ensure write lost affected applications halted notified recover cleanly continuing run incorrect notion disk 
echo 
provides better semantics commonly provided non distributed file systems conventional unix 
echo ordering constraints right thing automatically simple applications provide power complex ones giving better performance fsync available 
ordering constraints easy implement part doing directory write 
side ordering constraints appear difficult application writers transactions 
successful second 
current design making directly affected processes halt halts processes really care lost write causing confusion users 
processes indirectly depend lost write detected example distributed multi process application processes access file system access may learn lost write 
solution problem application write lost exited 
cases escape pronged approach entirely 
jim gettys mark manasse mike schroeder contributed ideas early echo clerk design phase 
mike burrows mike schroeder helped selection material provided useful comments presentation 
mary baker satoshi etienne john ousterhout margo seltzer 
non volatile memory fast reliable file systems 
proc 
th intl 
conf 
architectural support programming languages operating systems pages 
acm october 
mary baker mark sullivan 
recovery box fast recovery provide high availability unix environment 
proc 
summer usenix conference pages 
usenix association june 
mary baker john hartman michael kupfer ken shirriff john ousterhout 
measurements distributed file system 
proc 
th symp 
operating systems principles pages 
acm october 
andrew birrell andy hisgen charles timothy mann garret swart 
echo distributed file system 
research report systems research center digital equipment 
preparation 
michael burrows 
efficient data sharing 
phd thesis university cambridge september 
sheng yang chiu roy levin 
vesta repository file system extension software development 
research report systems research center digital equipment 
glassman dennis cynthia hibbard guarino reid mary claire van 
hector connecting words definitions 
research report systems research center digital equipment october 
cary gray david cheriton 
leases efficient fault tolerant mechanism distributed file cache consistency 
proc 
th symp 
operating systems principles pages 
acm december 
andy hisgen andrew birrell charles timothy mann garret swart 
consequences excess load echo replicated file system 
proc 
nd workshop management replicated data pages 
ieee november 
andy hisgen andrew birrell charles timothy mann garret swart 
new value logging echo replicated file system 
research report systems research center digital equipment 
preparation 
andy hisgen andrew birrell chuck timothy mann michael schroeder garret swart 
granularity semantic level replication echo distributed file system 
proc 
workshop management replicated data pages 
ieee november 
andy hisgen andrew birrell timothy mann michael schroeder garret swart 
availability consistency tradeoffs echo distributed file system 
proc 
nd workshop workstation operating systems pages 
ieee september 
john howard michael kazar menees david nichols robert sidebotham michael west 
scale performance distributed file system 
acm transactions computer systems february 
michael kazar 
synchronization caching issues andrew file system 
proc 
winter usenix conference pages 
usenix association february 
james kistler 
disconnected operation coda file system 
proc 
th symp 
operating systems principles pages 
acm october 
butler lampson mart abadi michael burrows edward wobber 
authentication distributed systems theory practice 
proc 
th symp 
operating systems principles pages 
acm october 
roy levin paul mcjones 
vesta approach precise configuration large software systems 
research report systems research center digital equipment 
timothy mann andy hisgen garret swart 
algorithm data replication 
research report systems research center digital equipment june 
michael nelson brent welch john ousterhout 
caching sprite network file system 
acm transactions computer systems february 
popek walker chow edwards kline thiel 
locus network transparent high reliability distributed system 
proc 
th symp 
operating systems principles pages 
acm december 
russel sandberg david goldberg steve kleiman dan walsh bob lyon 
design implementation sun network filesystem 
proc 
summer usenix conference pages 
usenix association june 
frank schmuck jim wyllie 
experience transactions quicksilver 
proc 
th symp 
operating systems principles pages 
acm october 
michael schroeder andrew birrell michael burrows hal murray roger needham thomas edwin satterthwaite charles thacker 
autonet high speed self configuring local area network point point links 
research report systems research center digital equipment april 
sun microsystems nfs network file system protocol specification 
rfc network information center sri international march 
garret swart andrew birrell andy hisgen charles timothy mann 
availability echo file system 
research report systems research center digital equipment 
preparation 
charles thacker lawrence stewart edwin satterthwaite jr firefly multiprocessor workstation 
research report systems research center digital equipment december 
walker popek english kline thiel 
locus distributed operating system 
proc 
th symp 
operating systems principles pages 
acm october 
brent welch john ousterhout 
prefix tables simple mechanism locating files distributed filesystem 
proc 
th intl 
conf 
distributed computing systems pages 
ieee may 

