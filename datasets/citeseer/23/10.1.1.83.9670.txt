hybrid types invariants refinements imperative objects cormac flanagan department computer science university california santa cruz control complexity large object oriented systems objects communicate precisely specified interfaces 
static type checking catches interface violations early development cycle decidability limitations preclude checking desired properties statically 
contrast dynamic checking supports expressive specifications may errors execution paths tested 
hybrid approach checking precise object specifications reasons statically possible dynamically necessary 
hybrid approach supports rich specification language features object invariants refinement types 

construction validation large software systems extremely challenging 
control complexity systems ideally constructed collection objects cooperate precisely specified interfaces 
interface specifications enable individual objects change evolve need understand entire system 
key challenge construction objectoriented system precisely specify object interfaces verify degree possible object implementations respect interfaces 
types naturally describe aspects object interfaces 
advantage type specifications static type checking catch errors compile time cheaper fix 
static type checking possible certain kinds specifications extending type language support expressive specifications arbitrary method preconditions postconditions results type system statically decidable 
traditional object type systems express useful interface specifications method returns positive number 
field object valid index array field object contains sorted list 
method draw expects point object specified rectangle 
static checkers suffer similar limitations 
example esc java may reject valid programs due incompleteness theorem prover 
fool wood workshop january 
stephen freund department computer science williams college aaron department computer science university california santa cruz contrast precise object specifications straightforward check dynamically assert statements specialized contract languages 
dynamic checking imposes certain performance overhead 
seriously dynamic checking detects errors code paths data values actual executions 
dynamic checking may catch errors late development cycle possibly significantly expensive fix 
summary decidable static type checkers provide complete checking limited specifications dynamic approaches provide limited coverage expressive specifications 
explore hybrid approach checking expressive object specifications combines advantages prior purely static purely dynamic approaches 
nutshell hybrid type checking involves 
embracing expressive type languages document precise object interfaces statically undecidable 
leveraging static type checking detect errors possible compile time 
leveraging dynamic checking check remaining statically verified correctness properties run time 
specification language extends abadi type system refinement types object invariants 
refinement type defines subset refinement existing type :10.1.1.41.548
example refinement type int denotes set positive integers 
expressiveness type system requires refinement predicates pure refinement predicates arbitrary program expressions access mutable data 
object type associated predicate called object invariant hold objects type 
formalize semantics expressive specification language type system sound necessarily undecidable 
enable useful checking hybrid type checking algorithm desirable features 
hybrid type checker statically rejects programs possible 

due decidability limitations hybrid type checker may statically accept subtly ill typed programs insert sufficient dynamic casts guarantee specifications violated 
attempted specification violation caught statically possible dynamic checks necessary 

output hybrid type checker welltyped program example type directed optimizations applicable 
previous explored hybrid strategy simpler context pure functional lambda calculus 
help verify large object oriented systems extends earlier ideas interesting imperative language supports objects final mutable methods imperative method update expressive object specifications object subtyping refinement types object invariants 
initial studies hybrid type checking context idealized object language hope serve foundation exploring complex object languages type systems 
long term goal apply hybrid type checking realistic objectoriented programming languages java objective caml 
presentation results proceeds follows 
section informally describes object language type system 
section applies type language document precise specifications 
section formally describe operational semantics undecidable type system language 
section presents hybrid type checking algorithm section states key correctness properties type system compilation algorithm 
section discusses related section concludes 

hoop language approach hybrid checking expressive object specifications terms hoop idealized hybrid object oriented programming language calculi abadi cardelli 
syntax language shown 
types overview type language contains number features unusual object type systems dependent types refinement types object invariants 
base type bool int unit 
base types fairly coarse example express integer subranges introduce refinement types int denotes set positive integers 
generally refinement type denotes set values type satisfy boolean predicate term evaluates true 
base type abbreviation refinement type true 
refinement types inspired prior decidable refinement type systems expressive causes type checking undecidable :10.1.1.41.548
particular subtyping refinement types reduces checking implication corresponding arbitrary refinement predicates clearly undecidable 
decidability difficulties circumvented hybrid type checking algorithm 
object type language form li fi pi ti type denotes object containing methods distinct names 
usual fields encoded syntax terms variable object value select update cast binding objects li ti object values constant object address view object view types base refinement type li fi pi mi object type method types method type ti unit bool int base types final mutable final modifiers pure impure purity modifiers methods 
method li dependent type ti meaning takes argument type ti returns result type formal parameter may occur free abbreviate ti ti occur free type system contains dependent types may refer variables object type includes binding self variable called may mentioned method types 
method li method qualifiers fi pi 
method qualifier fi final mutable indicates corresponding method updated 
object subtyping invariant mutable methods covariant immutable final methods 
method qualifier pi pure impure indicates method li pure 
specifically expression pure evaluation accesses invokes updates mutable method 
purity qualifiers ordered pure impure safe consider pure method impure 
object type includes object invariant boolean predicate self variable object invariant guaranteed hold object type evaluate false 
ensure guarantee holds presence method updates require object invariant pure 
similarly refinement predicates pure 
terms hoop source terms include variables constants objects method invocation update casts expressions 
object form li ti consists collection methods corresponding method bodies provide bindings self variable formal parameter respectively 
object annotated explicit type constants hoop include boolean integer constants operations 
examples infix notation primitive operations hoop internally represents primitive operations method invocations 
cast dynamically converts possible value produced type fails 
technical reasons bindings include explicit type annotation 
hoop includes object addresses object views view 
constructs formalize operational semantics language appear source programs 

examples section illustrate type language hybrid type checking informal examples 
readability omit final pure modifiers assume methods immutable pure specified 
refinement types introduce useful refinements int pos int nat int expected subtype relation pos nat holds 
similarly true nat int 
subtyping refinement types undecidable general type checking 
example consider method update provide bindings self variable formal parameter respectively 
suppose mutable method type int nat term type int 
check method update typed compiler needs decide subtype relation int nat turn reduces deciding validity implication compiler prove implication type nat subsumption method update welltyped 
conversely compiler refute implication type nat compiler reject program ill typed 
case implication valid refuted 
due expressiveness hoop type language compiler may encounter situations algorithms prove refute implications compiler decide expressions welltyped 
key design question compiler handle situations 
optimistically accepting programs means type specifications trusted may violated run time clearly undesirable 
pessimistically rejecting programs cause compiler reject typed programs brittle practice difficult predict programs compiler accept 
hybrid type checking handles situations provisionally accepting program inserting cast dynamically enforces specification yielding compiled code nat compiled code typed dynamically ensures specification violated method returns natural numbers 
example illustrates hybrid type checking enforces precise specifications int nat specifications verified statically 
comparison static type checker may able enforce weaker specifications int int 
pairs define object pair containing integers method computes sum 
assign pair conventional type pair pair sum pair pair int int sum unit int true hoop directly support fields may encode field type method type unit abbreviate field type simply readability 
sum parameter name value method body 
indicate alternatively refinement types specify second component pair int int true sum unit int type specifies method terminates return integer greater note predicate pure 
type system ensures pure expressions access mutable data 
restriction program subtyping hide field break predicate modifying permit covariant subtyping immutable fields meaning pair alternative definition uses object invariant express ordering relation int int sum unit int object type object invariant return false return true may diverge 
particular method calls diverge violating object invariant 
allowing object invariants diverge avoids complexity reasoning termination type system require invariant subtype imply invariant supertype 
example implication true holds pair check invariant implication context know precise type self variable 
type predicate evaluates false conclude true subtyping allows move information method specifications object invariant 
interesting difference object invariants precise method specifications specify behavior mutable methods 
example type allows method updated integer int mutable impure int true sum impure unit int geometric objects final example consider types points rectangles squares point int int true rectangle point nat nat true square point nat nat clearly square rectangle 
subtype point allows describe points lie rectangle int int 
specify type mutable points subtype mutable points stay rectangle mutable impure int true mutable impure int mut 
imp 
int true mut 
imp 
int compiler ensure updates object type specified bounds static reasoning possible implicit dynamic checks necessary 
specify general relationships type points occurring particular shape shape subtypes rectangle circle implement contains method shape contains point bool true rectangle contains point bool true circle contains point bool true type characterizes points lie particular shape int int contains 
hoop operational semantics formalize run time behavior hoop programs small step operational semantics shown 
evaluation performed inside evaluation contexts defined grammar store maps object addresses objects denote empty store 
state pair store term 
relation performs single evaluation step relation transitive closure 
evaluation rules fairly straightforward 
rule obj adds new object store fresh address 
rule sel obj method invocation lj extracts method body tj object address replaces self variable formal parameter object address argument respectively 
rule upd method update lj replaces method lj object address renaming implicitly match self parameter variables original new methods 
rule simply replaces constants include basic constants true primitive operations 
primitive operations objects apply method provides required functionality 
prefix infix syntax primitive operations shown earlier examples desugared invocations apply methods follows true apply true apply int int desugaring uses notations creating objects representing pair values fst snd true fst snd rule const evaluates method invocation primitive operation relies meaning function define behavior primitive operations 
specifically returns result invoking method primitive operation argument store 
example contains pair int int apply true false apply apply true apply undefined rule casts constant refinement type checking predicate holds evaluates true 
returns false diverges cast said fail 
casts object types complicated need check method resulting casted object returns value appropriate type possible argument values 
check performed lazy manner evaluation rules evaluation rules assume li ti li fi qi si li fi pi ti li fi pi ti true dom lj tj li ti lj li ti lj unit true qi pi view true view sj view view lj lj tj view view lj lj view obj sel obj upd obj const cast base cast obj sel view upd view cast view object views 
object view view wrapper ensures object behaves specification type views introduced rule cast obj evaluates cast view view 
addition rule checks object methods mentioned compatible modifiers object invariant holds 
define special evaluation rules method invocation update views 
rules lazily enforce typing restrictions method parameters results performing appropriate checks method invocations updates 
rule sel view view invocation view lj retrieves type may quite different view type li fi qi si li fi pi ti rule reduces view invocation view lj method invocation contains additional casts ensure type safety view lj sj cast sj transforms argument type tj value expected argument type sj self variable replaced object address cast view 
transforms method result expected type self variable formal parameter replaced original view view original argument respectively 
casts ensure method invocations object views preserve type safety 
illustrate guarantee suppose fact 
fact fact fact nat nat true fact int nat true consider term fact attempts view circumvent fact specification object 
term evaluates nat fact nat point cast nat fails 
casts inserted sel view enforce specification fact method states fact applied natural numbers 
rule upd view reduces view update normal method update view lj lj modified version additional casts tj view formal parameter replaced tj guaranteed appropriate type tj may 
similarly self variable replaced view view expected type may 
result cast type return type expected non view invocations lj 
rule cast view evaluates view original view discarded cast different view 
summary casts allow program claim value type safely considered type operational semantics performs sufficient runtime checking detect claim violated 
alternative substituting require redundant re evaluation object invariant 
ability perform dynamic casts crucial enabling hybrid type checking algorithm convert particularly difficult static checks dynamic checks necessary 

hoop type system undecidable type system hoop language collection type judgments rules shown figures 
type environments sequence variable type bindings assume variables bound environment distinct 
judgment states term type purity environment judgment defined rules rule var states variable accesses pure variables immutable 
rule obj deals object creation checks method appropriate result type purity 
addition mutable method considered impure call method impure 
objects trivial invariant true 
stronger invariant added subtyping casting 
rule requires type formed environment order prevent escaping scope 
rule sel method invocation lj checks method lj type tj argument type tj 
type method call self variable formal parameter replaced object actual parameter respectively 
terms may appear resulting type terms pure 
note terms say pure method call lj refactored lj provided explicit result type mention rule upd method update checks updated method mutable new method body appropriate type purity 
rule const assigns type ty constant basic constants precise refinement types true bool false bool int primitive operations assigned object types precisely characterize behavior 
example type states method apply takes integer arguments passed fst snd fields pair object method result integer equal fst snd 
int int apply true int fst snd bool bool apply true bool fst snd bool apply true bool int int apply true bool fst snd type rules type rules terms pure li fi pi ti true fi mutable pi impure ti si pi li si pure pure li fi pi ti tj pure lj pj li fi pi ti fj mutable tj pj lj unit impure ty pure var obj sel upd const cast sub type rules types bool pure li fi pi ti sk li fi pi ti true sj tj sn bool pure sj tj base apparent circularity type defined terms cause technical difficulties development meaning refinement predicate defined terms operational semantics terms meaning function 
rule cast allows term inferred type cast formed type note cast may fail run time 
subtyping subtyping li fi qi mi li fi pi ni qi pi fi final mi ni fi mutable mi ni base obj method subtyping ti si ti si ti sub method equality equal implication 
false false imp consistent substitutions pure yi ti yi ti sub empty sub ext formed environments empty ext rule sub allows inferred type term weakened super type judgment checks type formed environment rule base states refinement predicates type bool pure 
rule states object invariants type bool pure method type refer methods declared earlier object 
interesting part type system concerns rules define subtyping judgment 
subtyping judgment complicated expressiveness refinement predicates object invariants defined terms implication judgment essentially implication judgment holds term evaluates false term evaluate false 
formally define substitution variables terms consistent environment maps variables terms manner consistent type bindings implication judgment holds substitutions consistent evaluates false follows evaluates false 
subtyping refinement types reduces implication judgment refinement predicates rule base 
subtyping object types covariant immutable methods invariant mutable methods 
subtyping involves checking implication object invariants 
note implication check performed environment variable type binding allows subtyping refactor type information method types object invariant 
example suppose int true int clearly variable type object invariant returns true diverges 
true subtyping judgment effect refactoring information method method type object invariant 

hybrid type checking type checking undecidable decidable compilation strategy hoop programs 
compilation strategy ensures inserting dynamic checks necessary specifications violated run time statically rejects clearly ill typed programs 
compilation strategy relies algorithm conservatively approximate logical implication judgment result algorithm denoted alg mode indicates algorithm successful verifying refuting implication 
particular alg means algorithm successfully determines alg means algorithm determines implication hold alg means algorithm fails prove disprove require algorithm complete 
example trivial algorithm returns satisfies requirements precludes performing interesting reasoning compiler 
algorithmic subtyping algorithmic subtyping alg alg alg li fi qi mi li fi pi ni qi pi fi final alg mi ni fi mutable ai alg mi ni alg 
am alg base obj algorithmic method subtyping alg alg ti si alg ti alg si ti am sub algorithmic method equality alg alg alg alg am equal defines algorithmic subtyping algorithmic type equality terms implication algorithm 
rules closely match corresponding rules type system 
example algorithmic subtyping base types directly reduces algorithmic implication test base 
subtyping object types rule obj uses rules am sub am equal ensure appropriate relationship corresponding method types uses implication algorithm check implication object invariants 
algorithmic implication algorithmic subtyping may yield definitive answer 
sub tests succeed sub test fails algorithm conclude certainty subtyping hold 
situations result test uncertain 
valued conjunction operator compute result subtype test results define hybrid compilation judgment compiles term term type purity compilation rules type check program insert additional type casts compensate indefinite answers returned subtyping algorithm yielding compiled program successful compilation guarantee source program typed 
compilation rules compilation terms pure li fi pi ti true fi mutable pi impure ti si ti pi li si li ti pure pure li fi pi ti tj pure lj lj pj li fi pi ti fj mutable ti pj lj lj unit impure ty pure var obj sel upd const cast compilation types bool pure li fi pi si uk li fi pi ti true li fi pi ti uj sj tj uj tj un bool pure base compilation checking alg alg cc ok cc chk typed dynamic casts inserted succeed 
typed execution may potentially halt due failure compiler inserted cast 
extend compilation types contain terms 
full set compilation rules shown 
rules straightforward 
variable constants need additional casts evidenced rules var const 
compile object li si rule obj compiles object type type li fi pi ti true compiles method body si ti type ti compilation checking judgment compile ensure type purity 
rules defining judgment exhibit key ideas hybrid type checking objects 
compiling term type subtyping algorithm alg check subtype subtyping algorithm succeeds alg casts needed see cc ok 
subtyping algorithm subtyping requirement alg program fails compile compilation rule applicable 
subtyping algorithm prove refute subtyping requirement alg dynamic cast inserted rule cc chk 
ideally subtyping algorithm sufficiently complete handle cases definitively casts inserted rarely 
crucial ability add casts permits compiler support unusually expressive object specification language 
compiler compiles types source program cast obj ensure types mentioned compiled program formed environments constructed compilation formed 

correctness section establish important correctness properties hoop type system hybrid compilation algorithm 
correctness type system extend type system run time states contain object store object addresses object views 
particular extend typing judgment include object store resulting extended judgment forms extended type rules identical original rules pass additional store argument antecedents 
exception rule imp uses store evaluating implication predicates 
false false imp introduce new rules checking object addresses object views 
pure li ti li fi qi mi li fi pi ni li fi pi ni true qi pi view true view pure add rules typing stores states dom 
ai 
si ai si pure obj ref obj view store state assume type primitive operation consistent operational behavior 
assumption types primitives 
extended type system satisfies preservation subject reduction property 
type system satisfies progress property evaluation welltyped programs halt prematurely caveat type casts may fail 
state failed cast reduced rules cast base cast obj cast view 
theorems follow induction typing derivations 
theorem preservation 
theorem progress 
closed typed normal forms values contain failed cast 
correctness hybrid type system describe correctness properties hybrid type system 
assume implication algorithm sound approximation implication judgment assumption soundness alg 
suppose 
alg 
alg assumption subtyping algorithm sound lemma soundness alg 
suppose 
alg 
alg proof induction algorithmic subtyping derivations 
compilation algorithm inserts sufficient dynamic type casts compensate inherent imprecisions subtyping algorithm ensures compiled programs typed 
theorem compiled programs typed 
suppose 


proof induction compilation derivations 
immediate consequence lemma combined theorem progress compiled programs halt prematurely due failed casts 
casts may explicit original program implicitly inserted compiler 
subtle specification violations hybrid type checking may catch errors cast failures run time 
argue precise hybrid approach may superior coarser type language express subtle specifications 

related prior focused dynamic checking expressive specifications contracts 
entire design philosophy contract oriented design dynamically checked specifications 
hybrid type checking extends prior purely dynamic approaches verifying detecting violations expressive specifications statically possible 
programming language eiffel supports notion hybrid specifications providing statically checked types dynamically checked contracts 
having separate static dynamic specification languages awkward requires programmer factor specification static dynamic components 
furthermore specification may need manually refactored exploit improvements static checking technology 
shares similar motivations partly inspired advanced type systems including refinement types practical dependent types 
requirement full static decidability limits expressiveness prior systems 
hybrid type checking side steps decidability difficulties willing check correctness properties dynamically necessary 
static checking tool esc java supports expressive jml specifications leverages powerful automatic theorem proving techniques 
esc java underlying theorem prover simplify distinguish failing prove theorem finding counterexample refutes theorem 
consequently esc java may produce error messages caused limitations theorem prover 
contrast hybrid type checking produces error messages programs prove ill typed 
abadi leino developed proved soundness hoare style logic reasoning pre post conditions imperative object language 
esc java logic reduces program correctness theorem proving undecidable 
explored various semantic models extensions abadi leino system 
extending support imperative object language require studying number additional verification issues frame conditions aliasing ownership arise imperative setting 
number projects focused refinement specifications subtyping 
include liskov wing leavens lano 
notion subtyping simpler studies example include data abstraction 
interesting avenue explore richer notions subtyping abstraction context hybrid type checking 
limitations purely static purely dynamic approaches motivated hybrid analyses 
example ccured hybrid analysis preventing array bounds violations 
proposed approach detect errors statically static analysis optimize run time analysis 
specialized hybrid analyses proposed problems race condition checking 
ou system leveraging dependent types run time checks system include objects 
contrast hoop type system decidable leverages dynamic checks reduce need precise type annotations explicitly labeled regions programs 
interaction static typing dynamic checks previously studied context flexible type systems types type dynamic converted types 
quasi static typing automatically inserts necessary coercions manner similar soft typing 
intended support looser type specifications 
contrast uses similar automatically inserted casts support precise type specifications 
interesting avenue exploration combination approaches support large range specifications dynamic static type information extreme precise hybrid checked specifications 

presents hybrid type system permits programmers specify object interfaces precisely object invariants type refinements delegate hybrid compiler decisions regarding parts specifications checked statically checked dynamically 
number issues remain including experimental validation 
desire static decidability constrained traditional object type systems 
believe hybrid type checking may facilitate design programming languages expressive type systems balance safety flexibility undecidability need limit practicality 
acknowledgments supported national science foundation ccr ccr 
mart abadi helpful comments 
abadi cardelli 
theory objects 
springer verlag 
abadi cardelli pierce plotkin 
dynamic typing statically typed language 
proceedings acm symposium principles programming languages pages 
abadi leino 
logic object oriented programs 
verification theory practice pages 
agarwal stoller 
type inference parameterized race free java 
proceedings conference verification model checking interpretation pages 
aiken wimmers lakshman 
soft typing conditional types 
proceedings acm symposium principles programming languages pages 
borgida mylopoulos reiter 
frame problem procedure specifications 
ieee trans 
software eng 
boyland noble 
capabilities sharing generalisation uniqueness read 
proceedings european conference object oriented programming pages 
davies pfenning 
intersection types computational effects 
proceedings acm international conference functional programming pages 
detlefs nelson saxe 
simplify theorem prover program checking 
acm 
ecma 
standard ecma language specification rd edition 
available web www ecma international org publications files ecma st ecma pdf 
findler felleisen 
contracts higher order functions 
proceedings international conference functional programming pages 
flanagan 
hybrid type checking 
proceedings acm symposium principles programming languages 
flanagan flatt krishnamurthi weirich felleisen 
finding bugs web program invariants 
proceedings acm conference programming language design implementation pages 
flanagan leino lillibridge nelson saxe stata 
extended static checking java 
proceedings acm conference programming language design implementation pages 
freeman pfenning 
refinement types ml 
proceedings acm conference programming language design implementation pages 
gomes stoutamire 
language manual sather 
gosling joy steele bracha 
java language specification rd edition 
addison wesley 
knowles freund flanagan 
sage practical hybrid checking expressive types specifications extended report 
www soe ucsc edu cormac papers sage full ps appear 
hofmann tang 
implementing program logic objects higher order logic theorem prover 
proceedings conference theorem proving higher order logics pages 
holt cordy 
turing programming language 
communications acm 
lling rosenberg 
blue language specification version 
lano 
reasoning refinement object oriented specification languages 
proceedings european conference object oriented programming pages 
leavens 
reasoning object oriented programs subtypes 
phd thesis massachusetts institute technology 
leavens cheon 
design contract jml 
www cs iastate edu leavens jml 
liskov wing 
behavioral notion subtyping 
acm transactions programming languages systems 
luckham 
programming specifications 
texts monographs computer science 
fagan 
soft typing 
phd thesis rice university 
walker harper 
effective theory type refinements 
proceedings international conference functional programming pages 
meyer 
object oriented software construction 
prentice hall 
necula weimer 
ccured typesafe retrofitting legacy code 
proceedings acm symposium principles programming languages pages 
noble vitek potter 
flexible alias protection 
proceedings european conference object oriented programming pages 
callahan 
choi 
hybrid dynamic data race detection 
acm symposium principles practice parallel programming pages 
ou tan walker 
dynamic typing dependent types 
ifip international conference theoretical computer science pages 
parnas 
technique software module specification examples 
communications acm 
vouillon 
objective ml effective objectoriented extension ml 
theory practice object systems 
reus 
denotational semantics abadi leino logic objects 
proceedings european symposium programming pages 
rosenblum 
practical approach programming assertions 
ieee transactions software engineering 
thatte 
quasi static typing 
proceedings acm symposium principles programming languages pages 
von praun gross 
object race detection 
proceedings acm conference object oriented programming systems languages applications pages 
wright cartwright 
practical soft type system scheme 
proceedings acm conference lisp functional programming pages 
wright felleisen 
syntactic approach type soundness 
info 
comput 
xi 
imperative programming dependent types 
proceedings ieee symposium logic computer science pages 
xi pfenning 
dependent types practical programming 
proceedings acm symposium principles programming languages pages 
