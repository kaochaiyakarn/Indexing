dmtracker finding bugs large scale parallel programs detecting anomaly data movements qi gao feng qin panda software reliability large scale systems increasingly important debugging large scale parallel systems remains daunting task 
proposes innovative technique find hard detect software bugs cause severe problems data corruptions deadlocks parallel programs automatically detecting abnormal behaviors data movements 
observation data movements parallel programs typically follow certain patterns idea extract data movement dm invariants program runtime check violations invariants 
violations indicate potential bugs data races memory corruption bugs manifest data movements 
built tool called dmtracker idea automatically extract dm invariants detect violations 
experiments real world bug cases popular mpi library shown dmtracker effectively detect report abnormal data movements help programmers quickly diagnose root causes bugs 
addition dmtracker incurs low runtime overhead experiments high performance linpack hpl nas parallel benchmarks npb indicates dmtracker deployed production runs 
categories subject descriptors operating systems reliability software engineering testing debugging debugging aids distributed debugging general terms reliability design experimentation keywords bug detection parallel programs data movements anomaly detection permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sc november reno nevada usa copyright acm 
department computer science engineering ohio state university columbus oh qin panda cse ohio state edu 
software bugs greatly affect reliability high performance systems 
study different high performance computer systems los alamos national laboratory shown software bugs account failures 
furthermore software bugs may silently corrupt application data remain unnoticed termination task leads incorrect results significantly affects productivity 
scale core architectures mainstream high performance computing hpc systems predictable software complex software bugs may cause frequent severe system problems 
unfortunately finding software bugs high performance systems daunting task due systems inherent nature non determinism large scale 
bugs data races manifested execution may triggered execution various nondeterministic events process execution orders thread interleaving signal delivery timing events non determinism difficult reproduce bugs renders significant challenge detecting locating software bug 
furthermore problem complicated due increasing scale high performance systems 
example software bugs triggered large scale systems 
cause huge resource waste developers occupy large scale system inefficient manual debugging 
imperative low overhead tools deployed production runs help automatically locate software bugs 
previous detecting bugs execution time classified categories programming rule approach statistics rule approach 
methods categories check certain rules program execution focus different types rules 
approaches detect violations rules imposed specific languages specific interfaces message passing interface mpi 
example bounds message buffer exceed allocated bounds members process group execute collective operations communicator order rules mpi check respectively 
research conducted category purify valgrind marmot mpi check effective detecting types software bugs runtime rules general able detect semantics related bugs highly dependent domain specific expertise human efforts 
statistics rule methods extract rules statistically program runtime check violations extracted rules 
statistical rules dynamic invariants properties hold certain point points program :10.1.1.137.4260:10.1.1.164.9197
extract invariants runtime single run multiple runs 
works demonstrated statistics rule approaches promising due effectiveness detecting bugs violate programming rules :10.1.1.137.4260:10.1.1.164.9197
daikon extract value invariants possible values variable certain range runtime detect bugs generate abnormal values 
similarly captures runtime program counter invariants variable typically accessed instructions detect memory related bugs 
statistical rules extracted program execution related program semantics usually accurately documented programmers difficult infer code 
parallel distributed programs common type applications running hpc systems especially suitable applying statistics rule methods 
addition temporal dimension explored previous works invariants program behaviors multiple runs multiple phases single run explore spatial dimension invariants behaviors multiple concurrently running processes parallel systems :10.1.1.137.4260:10.1.1.164.9197
example scientific parallel applications usually similar identical tasks performed multiple iterations temporal dimension multiple processes spatial dimension 
similarly commercial hpc systems web server farms group processes concurrently handle tasks way achieving high throughput 
conducted initial study statistics rule approach diagnose software problems large scale systems 
approach extracts invariant function time distribution control flow identify abnormal process large number parallel processes 
shown invariant effective locating problematic processes functions 
approach limitations detecting software bugs 
detect bugs cause abnormal function time distribution multiple processes 
example data corruption may cause wrong results affecting function time distribution 
similarly bugs manifest processes resulting distorted function time distribution processes approach detect bugs 
second function time distribution invariant easily interfered system level noises process scheduling signal delivery network congestion reflect semantics programs accurately 
example processes performing identical tasks different nodes show different function time distribution network traffic load unbalanced nodes 
contributions 
propose novel statistics rule technique called data movement dm invariants find hard detect software bugs cause severe problems data corruptions deadlocks large scale parallel programs 
idea observation data movement parallel programs typically follow certain patterns 
extract invariants runtime possible detect abnormal data movements caused potential software bugs 
idea inspired fact data movements parallel programs pervasive bug inducing 
different sequential programs parallel programs require multiple processes coordinate perform large tasks 
processes parallel programs usually communicate frequently 
unfortunately programmers easily mistakes various situations performing data movements 
application level parallel algorithms require data exchanged non trivial ways due subtle boundary condition handling 
addition parallel programming models mpi provide variety communication interfaces different semantics point point send receive collective calls difficult application programmers precisely understand subtle semantic differences choose correct interface 
furthermore achieve better performance applications libraries may introduce aggressive error prone optimizations may correctly time affecting correctness corner cases 
bugs easily introduced manifested pervasive data movements parallel programs 
specifically propose types dm invariants frequent chain fc invariants frequently occurring data movement chains chain distribution cd invariants clusters data movement chain distributions multiple processes 
fc invariants cd invariants focus temporal spatial similarity data movements parallel programs respectively 
violations abnormal data movement chains fc invariants outlier data movement chain distribution process may indicate potential software bugs data corruptions livelocks deadlocks note types invariants data movement chains formed linking individual data movements destination data movement source subsequent data movement 
reason doing data movement chains reflect better semantic information individual data movements 
ideas built tool called dm tracker extract fc invariants cd invariants runtime check violations 
experiments real world bug cases popular mpi library shown dmtracker effectively detect report abnormal data movements help programmers quickly diagnose root causes bugs 
complementary existing programming rule statistics rule tools dmtracker unique advantages unavailable tools 
best knowledge dmtracker automatic tool utilizes statistical rules data movements dm invariants detecting hard detect software bugs cause severe problems data corruptions deadlocks parallel programs 
find software bugs focuses key aspect parallel programs data movements 
dm invariants dmtracker detect various types severe bugs data corruptions deadlocks manifest data movements help programmers diagnose root causes 
dmtracker detect deterministic nondeterministic software bugs manifest processes processes 
extracts invariants exploring temporal spatial similarities data movements 
experiments shown dmtracker effective detecting deterministic bug non deterministic bugs 
contrast previous handle software bugs manifested processes demonstrated bug case 
dmtracker detect software bugs violate function time distribution dm invariants capture data move data move experiments second bug case shown problematic function time distribution easily overshadowed functions system level noises hard identified previous 
dmtracker incurs low overhead due system design usage low overhead dynamic instrumentation tool called pin 
experimental results show runtime overhead dmtracker 
possible directly apply dmtracker production runs 
rest organized follows section discuss background statistics rule bug detection 
section introduce dm invariants section design dmtracker discuss key design issues 
describe evaluation results section discuss related section conclude section 
background statistical rule bug detection statistics rule bug detection methods extract statistic rules dynamic invariants program runtime check violations extracted invariants indicate potential software bugs 
approaches motivated observation hard detect bugs usually lurking corner case rarely happens 
program behaves correctly cases bugs corner cases difficult manifested testing cause problems production runs 
due hidden nature bugs take time detect fix 
years research efforts direction :10.1.1.137.4260:10.1.1.164.9197
introduced types dynamic invariants detect bugs manifest different ways 
daikon focus value ranges variables invariants detect abnormal values variables 
acc mon focuses program counter pc invariants detect abnormal instructions accessing certain memory location 
access interleaving ai invariants detect violation atomicity execution multi thread programs 
works focus sequential programs proposed invariants mainly capture temporal similarity programs behavior 
anomaly detection method proposed function time invariants diagnosing problems large distributed computing environments 
focuses identifying abnormal process parallel application capturing spatial similarity parallel programs 
focus key aspects parallel programs data movements propose data movement invariants capture temporal similarity spatial similarity parallel programs 

data movement invariants data movement movement chunk memory data source buffer destination buffer 
example copying chunk memory data buffer buffer corresponds data movement typically capture data movements parallel programs different levels application level regarding communication calls mpi library calls data movement library level analyzing primitive operation memory copy network send receive data movement 
bug detection purposes choose library level provides comprehensive information finding bugs applications communication libraries decoupled particular programming models communication interfaces 
individual data movement reveals little information program semantics 
difficult extract invariants 
address issue link series data movements form data movement dm chain way destination previous data movement source subsequent data movement 
illustrates simple dm chain processes 
chain caused pair communication calls mpi send mpi recv application level 
basis proposed types invariants described subsections 
simple dm chain frequent chain invariants fc invariants frequently occurring dm chains 
observation processes parallel programs exhibit temporal similarity performing similar identical tasks multiple iterations 
result similar dm chains occur times program execution 
observation group similar type information call sites data movements memory buffers 
large sized groups frequently happening fc invariants 
int send void buf int len 
send operation bottom fill void comm buf bottom get comm buf bottom void data buf comm buf bottom len memcpy data buf buf len need piggyback rare case piggyback pb piggyback data buf sizeof piggyback bug missing parentheses 
fill piggy back structure return low level send void pb len sizeof piggyback common case return low level send data buf len abstracted bug case reflected abnormal data movement chain fc invariants possible detect abnormal data movements similar fc invariant slight difference 
abnormal data movements potentially caused software bugs deserve programmers attention 
typically abnormal data movements caused buffer misuse lead data corruptions errors crash deadlock 
shows simplified bug case extracted communication library data corruption caused pointer misuse 
code path common case goes line bug line code path deal rare case data need piggybacked packet notify peer event resource 
programmer tends think bytes data objects programming network protocols sizeof calculate offset 
unfortunately parentheses type cast happens higher precedence address subtracted unit sizeof actual address change sizeof sizeof causes pointer point buffer 
bug easily slip normal software tests deals uncommon cases rare event occurs 
furthermore difficult detect bug production runs may manifest silently sending incorrect data remote receiver 
shows data movements related send routine including common cases uncommon cases 
clearly tells bug manifests abnormal data movement 
normal program execution related send routine bug occurs dm chain changes similar fc invariant common case link broken 
obviously violates fc invariant 
fc invariants extracted run multiple runs 
dmtracker require data distinguish abnormal chains normal 
cases incorrect dm chains common cases specific run bug happens 
effective detecting bugs cases dmtracker allows users provide training set number traces known reflect correct behaviors extract patterns traces 
dmtracker effective locating incorrect behaviors traces problematic runs 
chain distribution invariants cd invariants clusters chain distributions chain distribution process fit 
observation processes parallel programs exhibit spatial similarity performing similar identical tasks symmetric communication patterns multiple processes 
result distribution various groups dm chains grouping method fc invariants similar multiple processes 
chain distributions clusters cd invariants 
demonstrates chain distributions processes high performance linpack hpl benchmark sp mg nas parallel benchmarks npb 
benchmarks npb show similar trends omit due lack space 
axis indicates process id process parallel programs column graph shows chain distribution process 
clear normal execution processes tested benchmarks share similar chain distributions 
cd invariants possible capture bugs happen small number processes 
dmtracker compares chain distributions processes automatically locates manifesting process large number peers search space bug greatly narrowed 
typically abnormal chain distribution caused algorithm protocol error parallel programs manifest infinite loop livelock deadlock addition chain distributions run comparing chain distributions certain time period effective detecting bugs cases 
example diagnose deadlock bug chain distributions processes phase execution especially useful 
deadlock situation processes usually proceed executions communicating distorted chain distribution shows phase potentially overshadowed chain distribution earlier phases 
cases processes parallel application designed perform different tasks master worker model chain distributions processes rank different correct runs 
cases cd invariants valid groups processes perform similar identical tasks 
dmtracker configured analyze chain distributions specific subset processes processes parallel program 

design dmtracker dmtracker consists major components online tracking component offline analysis component shown 
online tracking component section collects data movement dm traces runtime leveraging lightweight binary instrumentation 
collected dm traces offline analysis component forms dm chains section extracts fc invariants respectively section detects anomalies violate extracted invariants sections 
lightweight data movement tracking online data movement tracking component records data movement related information traces called instrumenting binary code parallel programs 
dynamic instrumentation tool called pin current implementation 
traditional bug detection tools purify track memory accesses dmtracker instruments function calls related memory management allocation deallocation data movements memory copy network operations 
incurs low overhead 
furthermore directly instrumenting binary code dmtracker requires recompilation source code avoid inconvenience usage 
capture data movement semantics dmtracker records information instrumented function calls key arguments return values call sites contain stack context call thread ids multi threaded processes local timestamps call 
specifically memory allocation calls malloc calloc dmtracker records request size memory object address memory copy calls records source destination addresses copy length network operations records buffer length information identify network endpoint 
call sites useful analyzing traces providing diagnosis information programmers 
timestamp order local operations 
note programs customized memory management module additional instrumentation needs done regarding customized interfaces 
dm trace grows moderately dmtracker records data movement related functions 
growth rate largely depends communication patterns parallel applications 
experiments typically mb disk space store traces minutes parallel benchmarks hpl npb usually big problem storing traces local disks 
addition leverage existing techniques trace compression streaming processing reduce storage overhead big concern 
preprocessing dm chain formation collected dm traces dmtracker forms parsing data movement operations dm operations linking related data movements 
scalability dm distribution chains processes tracker processes individual traces forms dm chains parallel processing traces central node 
parsing dm operations 
dmtracker parses information function call recorded dm traces correlates dm operation source destination buffers allocation information 
example memory copy correlates allocation information malloc ca cb 
correlation information provides contexts linking data movements grouping chains discussed detail 
parallel programs data movements data pack unpack may contain multiple memory copies 
cases data multiple small non contiguous buffers packed larger contiguous buffer data large buffer unpacked multiple smaller non contiguous buffers 
memory copy usually requires source destination contiguous operations require multiple memory copies 
dmtracker aggregates multiple memory copies pack unpack operation parses single better reflect semantics data movements 
network operations step dmtracker correlate partial allocation information source buffer send destination buffer receive data movement process 
order link data movements network dmtracker keeps connection point information temporarily 
movement concatenation 
parsed dmtracker forms chains linking related data movements destination buffer previous source buffer subsequent dm operation 
form complete chain dmtracker performs steps intra process linking inter process linking 
linking link dm operations process 
example links memory copies related memory copies network operations 
efficiently match source buffer dm operation destination buffer previous dm operation dmtracker maintains active chain table existing dm chains potentially successive dm operations 
matching happens dmtracker extends matched dm chain updates table correspondingly 
inserts new dm chain table 
inter process linking link chains different processes matching send operations receive operations 
achieve dmtracker maintains information network connections file descriptors sockets queue pairs 
fifo communication channel tcp rc send receive matched simply order 
channels guarantee fifo needs done track sequence numbers packets 
send matches receive chain starting receive linked chain send 
way dm chain reflects process data movement multiple processes formed 
invariants generation generate fc invariants cd invariants dmtracker groups type chains information data movements chain chain groups provide better data movement semantics 
precisely dmtracker regards chains type puts group corresponding individual data movements chains call sites dm operations allocation call sites source destination buffers 
example chain chain type belong chain group data movement ai ai call site bi bi aj allocation call site bj 
call site information grouping chains due reasons data movements different program locations usually handle different cases capturing program semantics communication memory allocation site usually allocates type data capturing characteristics memory buffers 
generating fc invariants frequent chain pattern selection dmtracker extracts fc invariants formed chain groups criteria 
obviously chains group happen frequently number chains chain group relatively large 
naive way set absolute number threshold require fc invariants chain number larger threshold 
difficult practice threshold highly dependent number chains trace 
dmtracker uses relative number percentage total number chains threshold 
criteria chain type chain dmtracker design overview group preserve unique characteristics easily determine chain matches matches 
chain type contains data movement point select invariant compare chains chains match match violations interested similar difference invariant chain type 
uniqueness chain type determined length chain uniqueness individual data movement forms chain 
define uniqueness value chain type uniqueness sum uniqueness values dm operations uniqueness uniqueness oi uniqueness values different types data movements assigned different ways reflect different semantics 
normalize single memory copy define uniqueness dm operation oi uniqueness oi follows uniqueness oi oi single memory copy oi network operation min oi data pack unpack 
equation represents number segments data pack unpack tunable parameters 
network operation involves processes experiments 
uniqueness data pack unpack designed way reflect number segments overwhelm movements 
experiments 
thresholds select fc invariants partially depend target program 
experiments set uniqueness threshold require number chains chain group fc invariants account total number chains chain groups uniqueness value threshold 
generating cd invariants chain distribution clustering dmtracker extracts cd invariants clusters chain distributions chain distribution individual processes fit chain distributions 
define chain distribution trace process vector cd 
element vector represents percentage chains chain group accounts 
fi count cd count count fl count cm count count total number distinct chain groups processes count ci represents number chains th chain group ci trace count represents total number chains occurred cases chain goes multiple processes analyze distribution consider chain belong certain process chain starts process 
way calculate chain multiple times symmetric measurement 
cluster chain distributions dmtracker uses manhattan distance th nearest neighbor metric previous 
manhattan distance traces ti tj distance ti tj sum absolute differences element chain distribution vector defined equation 
distance distance th nearest neighbor equation reflects chain distribution fits cluster multiple peers 
lower value distance means chain distribution fits better cluster 
dmtracker uses measure similar chain distribution process compared peers 
dmtracker uses certain range distance ti 
similar experiments values parameters set total number processes 
distance ti tj count ti count ti count tj count tj 
count cm ti count cm tj count ti count tj distance ti distance ti tj distance ti tj distance ti tj jl fc invariants anomaly detection extracted fc invariants dmtracker detect abnormal chain groups potentially caused software bugs validate reported bug checking chain instance abnormal groups context 
abnormal chain group detection dmtracker detects abnormal chain groups comparing chain group extracted fc invariants 
considers chain group abnormal case similar relatively rare compared hand needs similar determine abnormal case similar abnormal case identical example matches consider rest unmatched part abnormal 
matches just infrequent type chains abnormal case measure similarity chain group fc invariant dmtracker uses metrics derived jaccard coefficient widely metric measure similarity capture matched part unmatched part equation shows formal definition similarity 
find largest matching part symbolize dm operations chain convert problem longest common substring problem 
longest common substring problem solved time help generalized suffix tree lengths strings 
similarity uniqueness uniqueness uniqueness uniqueness uniqueness uniqueness hand needs relatively rare compared frequent frequent pattern abnormal case measure dmtracker compares frequency frequency 
point compare larger 
define looking abnormal chain groups high similarity meaning chain group similar high meaning chain group relatively rare compared fc invariants 
choose harmonic mean combine similarity commonly way prefers high scores dimensions 
metric abnormality defined follows abnormality similarity pattern pi dmtracker detects list chain groups noted ci ci abnormality ci pi ci pi ci pi 
call pair ci pi violation 
dmtracker combines lists violations patterns ranks abnormality score 
experiments dmtracker reports violations abnormality score chain instance checking dm chains abnormal chain groups necessarily caused bugs dmtracker needs check chain instance context chain trace validation providing detailed diagnosis information programmer 
step dmtracker goes chain instance abnormal chain groups examines dm opera tions happened immediately chain instance see match previously unmatched part abnormal chain matching fc invariant 
instance assume chain group dm operations matches third fifth fc invariant chain instance dm operations closely chain trace match dm operations strongly suggests broken chain 
dmtracker highlight marking context match furthermore dmtracker provide detailed information abnormal instance report rank anomalies context match high abnormality score top 
reported information includes buffer address buffer allocation call sites data movement call sites abnormal chains contexts data movements chains happened 
helpful diagnosing problem 
cd invariants anomaly detection cd invariants reflected certain range distance scores relatively straightforward detect outliers 
different number outliers users dmtracker uses criterion find traces similar peers 
trace significantly larger value distance average times larger dmtracker report abnormal trace 
experiments value parameter fewer false positives 
chain group contributes distance ti tj equation included diagnosis information bug reports 
cases interesting part chain distribution phase execution 
instance parallel program deadlocks want find process causes problem chains happen earlier run may dilute difference 
deal case binary search method 
outliers users want depth diagnosis dmtracker perform multiple rounds detection chains halved time range 
issues discussions additional inter process communication channels 
communication libraries addition common network send receive approaches perform inter process communication shared memory region host remote direct memory access rdma directly access memory remote host 
data movements shared memory dm tracker tracks data movements non shared memory 
current prototype supported shared memory region construction memory mapping common file 
dmtracker link chains crossing processes communicated shared memory regions 
may affect accuracy cases major problem experiments separate chains analyzed process 
plan track construction shared memory regions 
rdma advanced feature provided modern networks quadrics lows sided communication 
current prototype link chains rdma channels process active side dm operation 
address issue need modify device drivers firmware network interface cards expose rdma operation user level process passive side 
online analysis fly detection 
computing power provided multi core systems dm tracker process analyze traces dedicated cores node 
processing cores directly access traces memory expensive file os achieve high performance 
addition storage overhead alleviated smaller intermediate results needed analysis preliminary local processing 
enable extend dmtracker performing fly detection 

evaluation case studies experiments described section conducted processor cluster nodes 
node ghz mb cache cpus gb memory 
nodes connected pci ex ddr adapters gbps peak unidirectional bandwidth 
operating system linux kernel version 
evaluate dmtracker functionality popular high performance open source mpi library real world bug cases data corruption bug causing incorrect results deadlock bug causing program hang 
packages large lines code source files 
evaluate runtime overhead incurred online tracking component dmtracker compare performance difference high performance linpack hpl benchmark nas parallel benchmarks npb dmtracker 
case data corruption communication data corruption bug version triggered deterministically executing communication library linear algebra called basic linear algebra communication subprograms 
test program package called reports invalid element error processes executing broadcast send broadcast recv test cases 
data corruption bug happens silently hang system failures shown stage result verification 
applied scenario dmtracker reports abnormal chain groups violate extracted fc invariants 
reported abnormal cases top ranked anomalies indicate real bug 
cases fc invariant times violated similar chains times 
shows frequently happening chain fc invariant left side rare cases broken chain caused data corruption bug right side 
instance context checking confirms chain instances caused data corruption bug 
dmtracker detects bug provides useful diagnostic information programmers quickly locating bug 
detailed information ab case broken chain case distance processes normal chain groups root cause problem optimization called header caching rdma operations fails handle corner case communication protocols easily identified 
demonstrates tools dmtracker helpful detecting rarely happening bugs locating root causes require human effort 
furthermore case study shows dmtracker detect software bugs manifest processes similar way 
dmtracker exploits temporal similarity process spatial similarity different processes 
data corruption bug triggered processes similar way indicating extremely hard impossible previous detect diagnose exploring spatial similarity different processes 
case deadlock connection setup deadlock bug triggered running ft benchmark testing internal version processes 
program hang non deterministically small chance execution 
applied dmtracker detects anomaly violates extracted cd invariant 
shown process high distance score significantly higher average score 
strongly indicates chain distribution process outlier cluster chain distributions 
dmtracker detects non deterministic bug exploiting spatial similarity different processes 
dmtracker detects bug reports useful diagnostic information programmers identifying root cause 
reports chain group network send operation function cm post ud packet file cm major contributor high distance score 
information quickly narrows root cause specific function 
function accessing variable forgotten defined volatile causes intended benign data race harmful small chance 
time spent function cm post ud packet bug cases longer normal cases easily detected function time distribution method due noises caused functions 
achieve better performance communication libraries built current main stream high performance networks including polling progressing mechanism 
mechanism waiting event process busy waiting multiple polling functions 
difference time spent abnormal functions easily overshadowed time spent polling functions 
experiments measured total time spent abnormal function outlier process total time progressing functions reflected visible difference function time distribution 
filter effect polling functions nontrivial required respect library determine functions count 
runtime overhead set experiments evaluated performance impact dmtracker online tracking component hpl benchmark different problem sizes npb benchmark class ran benchmarks version natively tracking nodes processes node 
table lists relative performance degradation hpl applying dmtracker compared native 
general runtime overhead low 
low overhead dmtracker tracks small set functions related data movements 
addition observe overhead decreases problem size hpl benchmark increases 
problem size larger data movements processes tends larger chunks resulting frequent data movements lower overhead 
long running applications operating large data sets overhead incurred dmtracker expected low 
table runtime overhead hpl problem size relative degradation observe applications different communication characteristics show different runtime overheads tracked dmtracker 
shown table overhead varies largely different npb benchmarks 
ones frequent communications cg lu show slightly higher overhead bt ft mg sp show negligible overhead 
results expected overhead caused tracking data communications applications 
demonstrated hpl npb dmtracker incurs low runtime overhead indicates dmtracker deployed production runs 
table runtime overhead npb benchmarks bt cg ft relative degradation benchmarks lu mg sp relative degradation currently trace processing analysis components dmtracker performed offline 
section discusses runtime overhead incurred online tracking component 
plan extend dmtracker detect software bugs fly leveraging stream processing algorithms multi core architectures 
sensitivity study false positives conducted set experiments study parameter sensitivity dmtracker 
tools parameters threshold values affect balance effectiveness false positives dm tracker 
lower thresholds dmtracker report potential bugs false positives higher thresholds reduce number false positives risk missing real bug false negative 
fc invariants tried options lower thresholds parameters case uniqueness requirements chain group fc invariant minimum meaningful value frequency thresholds chain group fc invariant low value abnormality threshold violation report 
experimental results sensitive parameters extent statistical invariants violations reported real bug cases ranked top highlighted context match 
false positives fc invariants encountered experiments case npb hpl summarized follows 
infrequently communication protocol 
flow control algorithm mpi library may choose different protocols network resource usage cases fall back protocol may 
data movements infrequently protocol cause small group chains similar different fc invariants reported violation dmtracker 
type contributes half false positives 
prune sophisticated checking steps incorporating semantic information 
buffer reuse control message 
mpi library control messages passed protocol small data messages communication buffers control messages immediately reused copied application buffers 
data movements control messages may result slightly different usually longer chain fc invariant considered violation 
cd invariants tried different values parameter number processes 
result case affected different values 
applying hpl npb false alarms lu cg indicating abnormal processes different data movement statistics 
false alarms pruned checking data movement statistics previous known runs 
note correct suboptimal parameter settings users need rerun analysis component offline generally cheaper rerunning large scale parallel program 

related builds previous studies software reliability 
due lack space provide brief survey related categories bug detection parallel programs problem diagnosis large scale systems general software bug detection technologies 
research efforts help detect bugs parallel programs including parallel debuggers technologies support interactive parallel debugging automatic bug detection tools 
focus helping interactive debugging automated information collection aggregation technologies visualization technologies 
follow programming rule approaches study uses statistical rule method detecting anomaly function time distribution 
complementary works statistical rulebased method detect anomaly data movements 
problem diagnosis large scale systems studied years 
works mainly study analyze locate root causes system failures performance problems 
root causes hardware failures configuration problems software bugs operator mistakes different works focus capturing problems programs semantics monitoring environments configurations purpose study detecting analyzing software bugs parallel programs 
studies technologies detect software bugs general systems 
static bug detection technologies include implementation level model checking compiler technologies data mining technologies 
dynamic bug detection technologies include pure software approaches hardware supported approaches 
works solely focus data movements parallel programs propose invariants capture special semantics 

proposed innovative approach automatically find hard detect bugs cause severe problems data corruptions deadlocks large scale parallel programs 
approach extracts data movement program invariants runtime detects anomaly extracted invariants 
idea built dm tracker help programmers locate root causes software bugs 
evaluation real world bug cases shows dmtracker effective detecting providing useful diagnosis information 
addition dmtracker incurs low runtime overhead measured hpl benchmark nas parallel benchmarks possible deployed production runs 
current dmtracker initial step direction 
plan conduct case studies types programs 
plan study intelligent algorithms data movement analysis models chain model data movements detecting bugs effectively 
addition extend dmtracker detect abnormal behaviors parallel programs fly 

anonymous reviewers useful feedback 
dr li discussions analysis algorithms wei huang discussions bug cases 
research supported part doe de fc er de fc er nsf cns ccf intel cisco systems linux sun microsystems equipment donations intel amd apple appro dell ibm sun microsystems 

basic linear algebra communication subprograms 
www netlib org 
whaley dongarra cleary 
high performance linpack 
www netlib org benchmark hpl 
aguilera mogul wiener reynolds muthitacharoen 
performance debugging distributed systems black boxes 
acm symposium operating systems principles sosp 
arnold ahn de lee miller schulz 
stack trace analysis large scale applications 
ieee int parallel distributed processing symposium ipdps 
babcock babu datar motwani widom 
models issues data stream systems 
acm symposium principles database systems pods june 
brett 
chen linden 
extending traditional debugger debug massively parallel applications 
parallel distrib 
comput 
barham donnelly isaacs 
magpie request extraction workload modelling 
symposium operating systems design implementation osdi 
beckman 
operating system issues systems 
acm operating systems review 
chen fox brewer 
pinpoint problem determination large dynamic internet services 
ieee ifip intl 
conf 
dependable systems networks dsn 

choi miller netzer 
techniques debugging parallel programs analysis 
acm trans 
programming languages systems 
condit harren necula weimer 
ccured real world 
acm sigplan conf 
programming language design implementation pldi 
desouza kuhn de 
automated scalable debugging mpi programs intel message checker 
workshop software engineering high performance computing system applications se 
dickinson leon podgurski 
finding failures cluster analysis execution profiles 
intl conf 
software engineering icse 
dor rodeh sagiv 
cssv realistic tool statically detecting buffer overflows acm sigplan conf 
programming language design implementation pldi 
engler chelf chou hallem 
checking system rules system specific programmer written compiler extensions 
symposium operating systems design implementation osdi 
engler chen hallem chou chelf 
bugs deviant behavior general approach inferring errors systems code 
acm symposium operating systems principles sosp 
engler 
model checking large network protocol implementations 
symposium network system design implementation nsdi 
ernst cockrell griswold notkin 
dynamically discovering program invariants support program evolution 
ieee trans 
software engineering 
llc 

www com 
evans guttag horning tan 
lclint tool specifications check code 
acm sigsoft symposium foundations software engineering fse 
liu bridges skjellum 
detecting anomalies high performance parallel programs 
information technology coding computing 
gupta zhang gupta 
locating faulty code failure inducing chops 
ieee acm intl conference automated software engineering ase 
gusfield 
algorithms strings trees sequences computer science computational biology 
cambridge university press 
lam 
tracking software bugs automatic anomaly detection 
acm intl conf 
software engineering icse new york ny usa 
acm press 
hastings joyce 
purify fast detection memory leaks access errors 
winter usenix conference 
hood 
project building portable distributed debugger 
sigmetrics symposium parallel distributed tools 
hood kennedy mellor crummey 
parallel program debugging fly anomaly detection 
acm ieee conf 
supercomputing sc 
hood matthews 
efficient tracing fly space time displays debugger message passing programs 
intl 
symposium cluster computing grid ccgrid 
trade association 
www 
org 
miller 
improving online performance diagnosis historical performance data 
acm ieee conf 
supercomputing sc 
mller 
marmot mpi analysis checking tool 
parallel computing 
krause 
geometry adventure non euclidean geometry 
dover publications 
li lu zhou 
cp miner tool finding copy paste related bugs operating system code 
symposium operating systems design implementation osdi 
li zhou 
pr miner automatically extracting implicit programming rules detecting violations large software code 
acm sigsoft symposium foundations software engineering fse 
aiken zheng jordan 
bug isolation remote program sampling 
acm sigplan conf 
programming language design implementation pldi 
zheng aiken jordan 
scalable statistical bug isolation 
acm sigplan conf 
programming language design implementation pldi 
lu qin zhou 
detecting atomicity violations access interleaving invariants 
acm intl conf 
architectural support programming languages operating systems asplos 
chen coyle zou 
mpi check tool checking fortran mpi programs 
concurrency computation practice experience 

luk cohn muth patil lowney wallace 
pin building customized program analysis tools dynamic instrumentation 
acm sigplan conf 
programming language design implementation pldi 
culler 
parallel debugger 
sigmetrics symposium parallel distributed tools 
maruyama miller 
problem diagnosis large scale computing environments 
acm ieee conf 
supercomputing sc 
nethercote seward 
valgrind framework heavyweight dynamic binary instrumentation 
acm sigplan conf 
programming language design implementation pldi san diego california usa 
network computing laboratory 
mpi 
cse ohio state edu 
mueller schulz de 
scalable compression replay communication traces massively parallel environments 
ieee int parallel distributed processing symposium ipdps 
calder 
bugnet continuously recording program execution deterministic replay debugging 
international symposium computer architecture isca 
qin lu zhou 
exploiting ecc memory detecting memory leaks memory corruption production runs 
ieee intl symposium high performance computer architecture hpca 
quadrics 
www quadrics com 
ramaswamy rastogi shim 
efficient algorithms mining outliers large data sets 
acm sigmod intl conf 
management data sigmod 
roth arnold miller 
software multicast reduction network scalable tools 
acm ieee conf 
supercomputing sc 
roth miller 
line automated performance diagnosis thousands processes 
acm sigplan symposium principles practice parallel programming ppopp 
savage burrows nelson sobalvarro anderson 
eraser dynamic data race detector multithreaded programs 
acm trans 
comput 
syst 
schroeder gibson 
large scale study failures high performance computing systems 
ieee ifip intl 
conf 
dependable systems networks dsn washington dc 
sullivan chillarege 
comparison software defects database management systems operating systems 
intl symposium fault tolerant computing ftcs 

tan steinbach kumar 
data mining 
addison wesley 
vetter de 
dynamic software testing mpi applications 
acm ieee conf 
supercomputing sc 
wong martin arpaci dusseau culler 
architectural requirements scalability nas parallel benchmarks 
acm ieee conf 
supercomputing sc 
xu bodik hill 
flight data recorder enabling full system multiprocessor deterministic replay 
international symposium computer architecture isca 
yang engler 
model checking find serious file system errors 
symposium operating systems design implementation osdi 
yuan lao 
wen li zhang 
wang 
ma 
automated known problem diagnosis event traces 
sigops oper 
syst 
rev 
zhou liu long lu qin zhou midkiff torrellas 
automatically detecting memory related bugs program counter invariants 
ieee acm intl symposium micro architecture micro 
zhou qin liu zhou torrellas 
efficient architectural support software debugging 
international symposium computer architecture isca 
