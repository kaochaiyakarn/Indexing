negotiation self interested computationally limited agents dissertation tuomas sandholm submitted graduate school university massachusetts amherst partial fulfillment requirements degree doctor philosophy september department computer science cfl copyright tuomas sandholm rights reserved negotiation self interested computationally limited agents dissertation tuomas sandholm approved style content victor lesser chair james kurose member shlomo zilberstein member herbert member mark fox member david stemple department chair computer science markus christina 
acknowledgments advisor professor victor lesser countless stimulating discussions faith letting pursue new directions 
graduate school years appreciated warm personality care taken financially friend 
am indebted support remarkable range matters include available daily basis intellectual mundane matters putting close contact multiagent systems research community facilitating university regulations allow completion dissertation shorter time normally mandated 
dynamism flexibility experience inspired encouraged taught number important ways 
hope advising graduate students half victor 
professor neil immerman backward pass idea algorithm professor herbert economics department game theoretic comments 
dissertation committee members professor shlomo zilberstein professor jim kurose professor mark fox helpful insightful comments 
accommodating schedule theirs 
distributed ai community interesting discussions number anonymous referees important comments 
particularly professors jeffrey rosenschein sandip sen michael wellman support shown 
umass computer science graduate student extremely supportive socially practical issues 
owe 
friedman numerous favors just friend 
neil berkman intellectually rigorous collaboration machine learning research part dissertation times 
frank dan proof reading papers mine favors pleasant get 
depth discussions algorithm 
claire cardie alan garvey supplying template files 
set people volunteered time listen practice talks give valuable comments 
gratefully sources provided funding different stages dissertation research content necessarily reflect position policy official endorsement inferred arpa contract national science foundation iri university massachusetts amherst graduate school fellowship technical research centre finland finnish culture foundation finnish science academy leo regina foundation antti foundation foundation george foundation finnish information technology research foundation transportation economic society foundation 
early development phases traconet system carried finland funded technology development centre finland industrial parties top project 
real world data experiments 
parents brother moral support continuously provided remotely finland years graduate school 
providing supportive free stable environment grow 
especially efforts 
certainly partner christina fong help support graduate school years 
christina time rounded meaningful fun 
proof read papers anybody 
importantly repeatedly acted vi task overflow buffer schedule turned tight 
receiving 

vii negotiation self interested computationally limited agents september tuomas sandholm industrial engineering management science helsinki university technology computer science university massachusetts amherst ph computer science university massachusetts amherst directed professor victor lesser multiagent systems computational agents find contracts real world parties represent 
significance systems increase due developing communication infrastructure electronic commerce industrial trend outsourcing 
dissertation analyzes negotiations agents try maximize payoff concern global 
accordingly interaction protocols need designed desired local strategies best agents agents desirable social outcomes follow 
dissertation extends game theory settings computational limitations preclude enumerating evaluating possible outcomes 
contributes interlinked areas negotiation contracting coalition formation contract execution 
automated contracting contract net framework extended computationally limited agents 
augmented formal model making bidding awarding decisions marginal cost calculations 
viii intractable approximations properties discussed 
proven leveled commitment contracting protocol enables contracts impossible classical full commitment contracts 
leveled commitment increases efficiency full commitment contracts possible 
analysis incorporates decommitting 
iterative scheme anytime task reallocation 
necessary sufficient contract types devised reaching globally optimal task allocation finite number contracts 
contracting implications limited computation issues distributed asynchronous implementation discussed 
coalition formation normative theory self interested computationally limited agents developed 
states agents form coalitions coalition structures stable 
analytical prescriptions depend performance profiles agents algorithms 
contract execution method carrying exchanges enforcement devised splitting exchange chunks agents alternate delivering 
algorithms devised chunking chunk sequencing 
optimal exchange strategies derived 
possibility scaling shown experimentally complete distributed vehicle routing problem large scale real world data 
techniques setting classical game theoretic techniques intractable 
ix table contents acknowledgments viii list tables xiv list figures xv chapters 
motivation example application domains distributed vehicle routing dispatch centers production planning scheduling multi enterprise manufacturing meeting scheduling criteria mechanism evaluation social welfare pareto efficiency individual rationality stability symmetry computational efficiency distribution communication efficiency overview contributions 
related research coalition formation coalition formation settings solution concepts coalition games core stable sets bargaining set kernel equal share analysis equal excess theory shapley value nash equilibrium strong nash equilibrium coalition proof nash equilibrium computational coalition formation mechanism design auction theory auction settings auction protocols revenue equivalence non equivalence bidder collusion lying auctioneer lying non private value auctions undesirable private information revelation social choice mechanisms principal agent problems agent task revelation allocation bargaining theory axiomatic bargaining theory strategic bargaining theory market mechanisms non economic approaches dai resource bounded reasoning 
automated contracting contracting marginal costs announcing tasks bidding awarding receiving awards scaling levels commitment uncertainty agent outside offer deterministic offer prevails dop certain offer void uncertainty agents outside offers sequential decommitting simultaneous decommitting pay decommit pays decommit xi practical prescriptions system builders stages commitment richer negotiation protocol contract types task allocation negotiation clustering contracts swap contracts multiagent contracts necessity sufficiency contracting implications limited computation local deliberation scheduling engaging multiple simultaneous negotiations enlarging bidding awarding context distributed asynchronous implementation avoiding message congestion saturation terminating iterative refinement negotiations replies vs timeouts chapter summary 
coalition formation computation unit cost algorithm rationality limits social welfare maximizing coalition structure stability coalition structure experimental results distributed vehicle routing domain solution interactions coalitions different performance profiles agents chapter summary 
contract execution unenforced exchange goods payments countable goods uncountable goods non isolated exchange role time role time isolated exchange role time non isolated exchange deadlines lateness penalty schedules delivery sequencing sequencing independent deliveries sequencing interdependent deliveries renegotiation avoidance chapter summary xii 
research appendix proofs intuition xiii list tables week real vehicle delivery data experiments 
example payoff matrix person prisoner dilemma game 
rosenschein zlotkin results lying task revelation 
experimental results automated contracting vehicle routing realworld data 
symbols section 
conditions existence brc agent grand coalition game 
xiv list figures small example problem instance distributed vehicle routing 
deterministic offer prevails dop game 
certain offer void game 
sequential decommitting game 
decommitment penalties satisfy agents ir constraints example game 
simultaneous decommit pay decommit game 
nash equilibrium decommitment thresholds lambda lambda example game different values decommitment penalties ir regions decommitting game 
nash equilibrium decommitment thresholds lambda lambda example game different values decommitment penalties qualitatively different regions contracts ir agents allow equilibrium decommitting game 
contracting messages single negotiation 
state transition diagram single negotiation 
clustering contract 
swap contract 
multiagent contract 
safe vs risky bidding awarding example runs 
example experiment vehicle routing domain agents 
venn diagram negotiation domains 
xv optimal coalition structure cs lambda bounded rational subadditivity function ccomp 
architecture self interested agents special emphasis exchange manager modules 
examples unenforced exchange 
exchanging uncountable goods reaching point 
exchanging uncountable goods departing point 
defection penalties non isolated exchange give leeway safe moves 
performance profiles value functions counterexample 
xvi motivation central theme dissertation negotiation self motivated agents rationality limited computational complexity 
developed methods targeted inherently distributed combinatorial problems resource task allocation multiagent planning scheduling situations agents may different goals agent trying maximize concern global 
building computer support negotiations independent businesses individuals issue self interest naturally arises 
importance automated negotiation systems self interested agents increase result developments 
growth standardized communication infrastructure edi nii kqml finin telescript general magic java separately designed agents belonging different organizations interact open environment real time safely carry transactions kristol low kristol sandholm lesser 
second advent small transaction commerce internet purchasing goods information communication bandwidth whinston office technology 
third industrial trend virtual enterprises dynamic alliances small agile enterprises take advantage economies scale available suffer scale respond diverse orders individually 
automated negotiation methods best suit domains contract small operative level decision 
domains low monetary stakes contract automatic negotiation systems relied authority practise 
individual contract minor negotiation process usually nontrivial 
cumulative stakes multiple negotiations may high 
general speedup communication links reasons distributing computational tasks reasoning communication bandwidth limitations growing relatively important distribution may warranted due distributed processing units 
true domains agent information compact symbolic form planning scheduling domains 
settings communication input data central location usually feasible 
hand interpretation domains node contains large amounts low level numeric data distributed processing warranted due bandwidth limitations lesser erman lesser erman lesser corkill lesser lesser corkill durfee lesser durfee lesser 
bandwidth limitation warrants distributed processing special domains autonomous communicate low bandwidth acoustic link turner eaton 
setting dissertation reason distributed reasoning planning scheduling domains self motivation agents bandwidth limitation 
joint problem solving process want solution beneficial possible 
similarly agent may want hide information agents possibly problem solving proprietary customer information 
distributed problem solving warranted problem inherently distributed opposed needing distributed due computational communication reasons 
settings trend increasing bandwidth enables negotiation applications infeasible negotiation message traffic viable 
cooperative distributed problem solving durfee system designer imposes interaction protocol strategy mapping state history actions way protocol agent 
approach usually descriptive protocol agents imposed strategies certain social outcomes follow 
hand multiagent systems sandholm lesser sandholm lesser sandholm lesser sandholm lesser rosenschein zlotkin durfee kraus wellman agents provided interaction protocol agent choose strategy 
self interested agent choose best strategy explicitly imposed outside 
protocols need designed desired local strategies best agents agents certain social outcomes follow 
allows agents constructed separate designers represent different real world parties 
interactions self motivated agents widely studied microeconomics especially subfield game theory fudenberg tirole kreps rasmusen 
results assume perfect rationality agents cook levi howard 
perfect rationality assumptions show ways example assumptions deduction optimal reasoning contingencies recursive modeling agents 
perfect rationality assumes agents compute marginal costs tasks exactly immediately untrue practical situations 
lately concentrated issue bounded rationality cognitive limitations interacting humans brought discussion simon heiner heiner 
economists study interactions humans protocol mean low level communication protocol negotiation protocol 
example protocol auction agents bid take responsibility task awarded lowest price bidder 
analog negotiation protocol called mechanism game theory fudenberg tirole kreps 
models bounded rationality descriptive 
positively example simulations critique earlier results achieved game theory perfect rationality assumption 
humans variable rationality person level rationality hard characterize formally 
may descriptive characterizations best achieve 
hand rationality computational agents limited precise sense 
algorithm execution architecture problem instance distribution statistically analyzed agent able solve problems 
shown dissertation formal character rationality limitations allows formulation normative prescriptive theories interactions self motivated computationally limited agents 
example application domains motivate research practical perspective sections describe example application domains methods developed dissertation needed 
main criteria agents self interested underlying intractable combinatorial problem limits agents rationality problem solved optimally practice 
distributed vehicle routing dispatch centers distributed vehicle routing problem study structured terms number geographically dispersed dispatch centers different companies 
center responsible certain deliveries certain number vehicles take care 
agent representing dispatch center vehicles delivery tasks 
local problem agent heterogeneous fleet multi depot routing problem constraints 
ffl vehicle tour depot center pickup drop locations orders need depot 
ffl vehicle maximum load weight constraint 
differ vehicles 
ffl vehicle maximum load volume constraint 
differ vehicles 
ffl vehicle maximum route length prescribed law 
ffl delivery included route vehicle 
objective minimize transportation costs domain cost sum route lengths vehicles solution reached 

small example problem instance distributed vehicle routing 
instance dispatch centers represented computer operators get delivery orders route vehicles 
parcel numbered dispatch center responsible delivering 
solution problem certain dispatch center individually specification routes vehicles manner center parcels get delivered routes dispatch center driving distance minimized 
routing solution 
problem hard delta tsp trivially reduced 
cost feasibility solution easily checked polynomial time 
problem complete 
problem instances experiments large smallest ones hard solve optimally 
geographical main operation areas centers overlap considerably 
provides potential multiple centers able handle delivery 
cost handling delivery may vary agents delivery integrated adjacent routes remote ones honoring weight volume route length constraints 
incorporated lowest cost routing solution center happens adjacent routes 
asymmetric costs agents handling delivery beneficial reallocate delivery tasks agents 
allows considerable cost savings negotiation coordination agents 
distributed vehicle routing real world problem problem instances experiments dissertation collected real dispatch centers 
represent week delivery order vehicle data 
owned centers owned 
dispatch centers owned practise acted self fiscal goals 
centers located finland 
collected data characterized table 
centers located near far centers 
centers transported heavy low volume items transported light voluminous items 
general adjacent centers potential savings cooperation 
secondly heavy light items beneficially combined load violating maximum load weight maximum load volume constraint 
table 
week real vehicle delivery data experiments 
dispatch number number average center deliveries vehicles delivery length km km km km km km explored distributed vehicle routing problem extensively sandholm sandholm sandholm lesser sandholm lesser sandholm sandholm sandholm lesser lately researchers studied identical distributed vehicle routing problem randomly generated instances non normative approach fischer 
production planning scheduling multi enterprise manufacturing experiments dissertation distributed vehicle routing problem real world application domains require techniques developed dissertation 
important ones production planning scheduling multi enterprise manufacturing 
production planning scheduling problem agent set tasks manufacturing operations setup operations set resources machines people storage areas guided carts 
problem involves planning assignments tasks resources assigning times scheduling execution tasks resources 
different objective functions cost functions problems example minimizing tardiness jobs job ordered set operations minimizing process inventory philosophy just time manufacturing minimizing completion time operation objective functions constraints operation order constraints resource capacity limitations restrictions operations assigned resources defines constrained optimization problem 
complete job shop scheduling problem special case real world manufacturing problems usually hard 
solution cost feasibility complete solution usually checked polynomial time manufacturing problems usually follows usually complete 
multi enterprise manufacturing different enterprises handle operation 
cost feasibility handling operation may vary enterprises represented computational agents 
beneficial reassign operations agent 
provides potential savings achievable negotiation coordination agents 
main types distributed manufacturing environments types agents constitute system 
call agent types cooperative self interested si hostile 
cooperative agents attempt maximize social welfare sum agents utilities 
willing take individual losses service society agents 
example different production cells enterprise act cooperative agents 
attempt minimize production costs maximize revenues accepting local losses order facilitate production cells multi enterprise agile manufacturing individual companies join form called virtual enterprise take care production tasks usually real world manufacturing scheduling problems differ basic job shop scheduling problem example having sequence dependent setup times alternative resources different characteristics operation 
cells involve humans individual cells need incentives motivate perform efficiently locally 
incentives usually implemented local evaluation introduce disparity cell local goals goals 
economically companies operating individually 
virtual enterprise individual usually self interested agent wants maximize profit caring companies profits virtual enterprise 
cases agent willing accommodate agents tasks monetary compensation 
third type agent relationship occurs distributed manufacturing hostile 
example consider companies compete market 
setting agents viewed maximizing utility increases gains companies losses 
agent self interested strategic level may interest act hostile manner operative level distributed production scheduling attempt drive competitors business 
working coordinated distributed scheduling fruitful feasible hostile setting 
situations distributed manufacturing environment comprises agents classes 
example setting companies self interested cell wise distribution simultaneously cooperative 
date automated distributed production planning scheduling systems exclusively developed operate cooperative agents sycara neiman burke prosser sen sen 
reasons distributing systems 
bandwidth argument information sustained local level saves communication costs 
detailed information regarding tasks resources dynamic state usually transmitted agents abstractions meta information load profiles resource class agent sent sycara neiman 
bandwidth argument originates cooperative distributed problem solving lesser 
see lesser erman done interpretation domain 
domain large amounts low level information arrive sensors may really infeasible transmit information central location processed 
hand planning scheduling domains problem schedulers large databases example prior operation statistics relatively succinctly described transmitted real complexity mainly stems inherent combinatorics 
problem line argument search efficiency usually reduced information global problem precise 
negotiation communication required distributed search may exceed amount communication occur information just gathered central problem solver distributed problem solving messages sent multiple times due backtracking task set previously contracted 
distribution argued claiming parallelization increases problem solving efficiency 
holds nearly decomposable hierarchical systems tightly coupled domains including scheduling domains necessarily easily decomposable independent subproblems facilitate efficient parallelization 
real world natural distribution scheduling problem seldom equals distribution computationally efficient 
furthermore parallel asynchronous search agents involves giving desirable algorithm properties completeness sycara 
issue supporting distribution cooperative settings reactivity agents locally react local changes faster centralized system 
domains communication time central site negligible compared rate change physical domain 
distribution cooperative domains advocated decision autonomy argument agents prefer maintain possibility local decisions submit centrally ones 
problem argument cooperative agents goals indifferent regarding question decisions 
distributed systems argued pointing robust failure single point centralized systems 
distributed systems implemented agent autonomy claim holds 
arguments date favor distributing cooperative scheduling systems hold cooperative scheduling settings cases problem solved efficiently keeping centralized problem solver date distributed events having planning scheduling 
hand self interested agents self interest introduces inherent distribution domain 
agents want maintain local decision autonomy private goals 
necessarily pass information truthfully agent lies benefits doing 
agent may reveal tasks resources reveal tasks resources exist 
rosenschein zlotkin formally analyzed issue task revelation rosenschein zlotkin 
unfortunately analysis task oriented domains apply scheduling domains assumes agent sufficient resources potentially handle tasks agents agents symmetric costs handling tasks 
furthermore rosenschein zlotkin shows negative result simple agent non capacity constrained symmetric cost contracting truthful task revelation usually achieved 
simple problems special cases real world problems negative results apply real world problems 
forms behavior agent lie cost willing pay agent care tasks cost requires order accept agents tasks 
ephrati ephrati initial approach solving problem agents clarke tax voting mechanism meeting scheduling domain 
unresolved issues remain concerning problem example applicability proposed mechanism sequence decisions dynamic domains different expectations changing tasks resources 
forms lying exist agent declare false load profiles resources lie dynamic status 
cases system designer certain efficiency negotiation network obvious self interested agents behave 
synergy savings joint problem solving available scheduling agents virtual enterprises reality self interested agents inherently distributed support mechanisms distributed planning scheduling self interested agents clearly called 
developing inter enterprise communication infrastructure provides part appropriate technology push distributed planning scheduling applications 
automated systems take account issues arise self interest agent take action payment agent may lie 
techniques developed cooperative distributed scheduling inappropriate self interested setting 
multi enterprise manufacturing planning scheduling problems provide promising application domain techniques dissertation agents self interested underlying combinatorial problem limits rationality agents 
example agent unable exactly compute cost associated accepting tasks agents savings having agents take care agent tasks 
meeting scheduling potential application techniques developed dissertation distributed meeting scheduling ephrati sen sen 
problems involve assignment times locations meetings 
constraints involve example capacity limitations locations usually meeting person time 
objective example maximize sum attendees meetings maximize sum utilities agents assign schedule different agents may different time place preferences 
setting consists self interested agents representing people underlying combinatorial problem limits agents 
embedding automated negotiation techniques solving problem personal digital assistants pdas clearly useful 
criteria mechanism evaluation negotiation protocols mechanisms evaluated types criteria 
include social welfare pareto efficiency individual rationality stability symmetry computational efficiency distribution communication efficiency 
discussed shortly sections 
social welfare social welfare fudenberg tirole kreps rasmusen rosenschein zlotkin sum agents payoffs utilities solution 
measures global agents 
criterion comparing alternative mechanisms comparing solutions mechanisms lead 
measured terms utilities criterion somewhat arbitrary requires interagent utility comparisons really agent utility function specified affine transformations 
pareto efficiency pareto efficiency fudenberg tirole kreps rasmusen rosenschein zlotkin solution evaluation criterion takes global perspective 
alternative mechanisms evaluated pareto efficiency comparing solutions mechanisms lead 
solution pareto efficient pareto optimal solution agent better agent worse pareto efficiency measures global require questionable interagent utility comparisons 
social welfare maximizing solutions subset pareto efficient ones 
sum payoffs maximized agent payoff increase agent payoff decreases 
individual rationality participation negotiation individually rational agent agent payoff negotiated solution payoff agent get participating negotiation 
mechanism individually rational participation individually rational agents 
individually rational mechanisms viable negotiated solution individually rational agent self interested agent participate negotiation 
stability self interested agents mechanism designed stable motivate agent behave desired manner 
self interested agent better behaving manner desired 
possible design mechanisms dominant strategies 
means agent best specific strategy matter strategies agents 
agent best strategy depends strategies agents choose 
settings dominant strategy mechanisms impossible implement 
settings stability criteria needed 
basic nash equilibrium nash fudenberg tirole kreps rasmusen luce raiffa binmore friedman 
strategy profile lambda hs lambda lambda lambda agents equilibrium agent lambda agent best strategy best response agents choose strategies lambda gamma hs lambda lambda lambda gamma lambda lambda 
words nash equilibrium agent chooses strategy best response agents strategies 
main problems applying nash equilibrium 
games exist strategies form equilibrium fudenberg tirole kreps rasmusen 
second games multiple nash equilibria obvious agents play kreps 
limitations regarding nash equilibrium guarantees exists unique 
sequential games guarantees stability game 
stage subgame strategies need equilibrium 
refined solution concept called subgame perfect nash equilibrium defined nash equilibrium remains nash equilibrium subgame subgames actual path play reached selten fudenberg tirole kreps 
solution concept suffers existence uniqueness problems 
second nash equilibrium guarantees agent better switching strategy 
agents collude coalition may better jointly changing strategies agents coalition 
coalition proof refinements nash equilibrium solution concepts coalitions section 
efficiency goals stability goals conflict 
simple example person prisoner dilemma game fudenberg tirole kreps rasmusen unique welfare maximizing pareto efficient strategy profile agents cooperate table 
hand dominant strategy equilibrium nash equilibrium agents defect 
table 
example payoff matrix person prisoner dilemma game 
payoffs row player listed 
column player cooperate defect row cooperate player defect symmetry desirable mechanism symmetric 
means mechanism handle agent priori preferred dissimilar manner 
secondly means agents act exactly alike receive payoffs 
computational efficiency obviously mechanisms designed agents little computation needed possible 
classically mechanisms designed lead domain solutions satisfy evaluation criteria 
mechanisms ones lowest computational overhead preferred 
dissertation explicitly deals resource limited rationality slightly different detailed approach taken 
chapter cost computation explicitly factored agents payoffs solution concepts directly applied combination domain actions computation actions 
view computational efficiency additional orthogonal evaluation criterion 
incorporated solution concepts 
allows computation strategies fulfill desirable criteria social welfare maximization pareto efficiency individual rationality different forms stability symmetry 
distribution communication efficiency want mechanisms truly distributed order avoid single point failure reasons 
simultaneously minimize amount communication required converge desirable global solution 
cases goals conflict 
far desirable properties negotiation mechanisms outlined 
mechanisms fulfill properties desiderata conflicting 
section contributions dissertation overviewed 
overview contributions dissertation analyzes automated negotiation self interested computationally limited agents 
extends game theory traditionally assumed perfect rationality 
combinatorially complex domains unrealistic assume perfect rationality deliberation costs traded advantages bring 
non game theoretic dai looked computational issues heuristically dissertation takes normative view interaction protocol best strategies agents strategies self motivated agents global outcomes 
domain independent methods negotiation agents 
approach dissertation issues analyzed formally verified empirically appropriate 
dissertation contributes interdependent subareas automated negotiation automated contracting coalition formation contract execution 
contributions automated contracting include 
ffl contracting marginal costs 
original contract net protocol agents cooperative executed tasks free 
dissertation extends protocol self interested agents having agents pay handling tasks 
formal model making bidding awarding decisions agents accept individually rational contracts local marginal cost calculation 
approximation schemes marginal cost calculation allow agents operate combinatorial domains 
resulting negotiation scheme anytime task reallocation algorithm terminated time guaranteed feasible solution agent worse agent initial solution participation individually rational 
experimentally shown truly distributed asynchronous implementation technology scales large scale problem instances 
ffl leveled commitment contracting protocol 
protocol developed practical advantages contingency contracts discussed 
formally proven new protocol increases pareto efficiency full commitment contracts enables contracts full commitment protocols allow individual rationality 
analysis carried formally number contracting settings 
effects agents biased information discussed 
practical implications leveled commitment contracts system builders discussed 
ffl choosing stage commitment dynamically contracting protocol 
new feature introduced contracting protocols sense stage commitment allowed decided dynamically negotiation environment negotiation item basis negotiation 
strict generalization classical contracting commitment takes place bidding phase 
varying stage commitment allows efficient search beneficial contracts 
ffl richer negotiation protocol 
protocol allows ad infinitum 
allows efficient search beneficial contracts self interested agents classical metainformation passing feasible 
protocol allows setting specific parameters decommitment penalties deadlines negotiation issue basis 
ffl necessary sufficient contract types 
proven contracts issue task time general lead global optimum task allocation space matter task reallocation hill climbing contract iterations allowed 
alleviate problem new contract types introduced clustering contracts swap contracts multiagent contracts 
shown suffice pairs applied separately 
combined new contract type csm contract 
proven contract type sufficient guarantee globally optimal task allocation reached hill climbing algorithm finite number steps 
ffl analysis contracting implications limited computation 
necessity local deliberation scheduling substantiated 
deliberation controller decide tasks sets allocate computation order 
dissertation presents previously unidentified tradeoffs regarding limited computation contracting setting 
agent trade complexity marginal cost calculation monetary risk 
occurs agent bid award previous bids pending 
issue formalized different marginal cost approximation schemes 
shown schemes agent local cost guaranteed decrease monotonically 
second agent tradeoff getting precise marginal cost estimates save computation vs able participate multiple negotiations simultaneously 
analyzed formally experimentally 
alternatives guarantee monotonic decrease local cost 
third agent tradeoffs regarding sending messages early vs enlarging bidding awarding context waiting incoming offers 
ffl discussion distributed asynchronous implementation automated contracting 
message congestion agent saturation discussed 
classical approaches solving problem viable self interested agents 
protocol related methods local strategy related methods solving problem 
sufficient solve practice 
concert agent self interest 
second method terminating iterative refinement negotiations guarantees termination local optimum desired type reached 
third comparative advantages reply protocols timeout ones discussed 
second main subarea dissertation studies coalition formation computationally limited agents 
normative domain independent theory coalitions combinatorial domains rationality agents bounded computational complexity 
computation limits quantitatively modeled unit cost computation performance profiles agents problem solving algorithms 
agents best trading solution quality computation cost 
discussed contracting agents iteratively reallocate tasks reach globally desirable solution 
hand coalition formation part dissertation agents form coalitions task allocation domain problem solving pooled occur centrally coalition 
different coalitions solve problems independently distributed manner 
contributions coalition formation include 
ffl domain classification computationally bounded bounded rational br agents 
venn diagram analysis carried relating domain classes br agents rational ones 
different rational agent domain classifications included comparison game theory rosenschein zlotkin multiagent research community 
domain classification carries information optimal coalition structure stability 
ffl formal analysis social welfare maximizing coalition structure br agents 
formal model allows determine optimal coalition structure performance profiles computation unit cost known 
addition general theorems proven analytically state types performance profiles cause best coalition structure grand coalition irrespective computation unit cost execution platform 
similar theorems proven coalition structure agents separately 
shown optimal coalition structure br agents depends heavily computational limitations differs significantly rational agents 
ffl formal analysis stability coalition structure consisting br agents 
formal model allows determine coalition structure stable br agents 
stability requires agent subgroup group agents motivated switch coalition structure 
criteria correspond core solution concept sec 

games stable coalition structures rational br agents 
general theorems relate shape algorithms performance profiles stability coalition structure 
ffl experimental results distributed vehicle routing 
real world week vehicle order data dispatch centers see problem real problem instances fall domain classification 
grand coalition best rational agents social welfare maximizing coalition structure varied widely br agents 
similarly stability coalition structure varied br agents 
experiments suggest superlinear iterative refinement steps low computation unit costs promote large coalitions high computation unit costs suggests smaller ones 
plausible explanation phenomenon 
interesting observation normative theory prescribes bounded rational agents choose coalition structures agree closely human agents select domain specific considerations 
coalition structures differ significantly rational agents choose 
third main subarea dissertation contributions contract execution 
specifically enforcement free method exchange developed 
methods particularly important computational agents vanish easily connection agent real world party represents hard detect 
developed method splitting exchange partial exchanges point exchange remaining benefits completing exchange outweigh benefits defecting agents 
formal equilibrium analysis carried proving viability developed method 
analysis includes parts 
ffl analysis exchanging countable goods 
strategies form equilibrium complete exchange minimal number steps 
maximum size delivery supplier safely point exchange shown maximum amount demander safely pay 
necessary sufficient conditions applicability method formally stated 
inherent problem regarding completion exchange 
ffl analysis exchanging uncountable goods 
strategies form equilibrium complete exchange minimal number steps 
necessary sufficient conditions applicability method formally stated 
completion problem severe uncountable goods countable ones 
ffl analysis non isolated exchange 
extension includes studying settings defection exchange adversely affect agent 
step minimizing equilibrium strategies formally derived countable uncountable goods 
non isolated nature exchange solves completion problem 
ffl incorporating real time discount functions 
second extension basic method presents sufficient conditions unenforced exchange possible agents discount payments value goods time 
step minimizing equilibrium strategies 
analysis carried countable uncountable goods 
theoretically established certain conditions exchange take infinite time complete 
problem solved unenforced deadlines lateness penalty schedules practice 
ffl delivery chunking chunk sequencing 
third extension includes analysis settings order delivery exchange varied 
settings questions answered 
chunks entire delivery split 
allow unenforced exchange 
top bottom method chunking relative advantages compared 
second order chunks delivered 
non obvious greedy quadratic algorithm independent chunks guarantees finding safe sequence exists 
proven general sequencing problem solved polynomial time number chunks chunks interdependent 
ffl dissertation discusses unenforced exchange method helps avoid unfair renegotiation 
rest dissertation structured follows 
chapter discusses related research 
chapter presents automated contracting 
chapter discusses coalition formation 
chapter presents unenforced contract execution chapter concludes presents research directions 
related research chapter reviews relevant research done related areas 
sections discuss coalition formation research 
mechanism design reviewed including auctions social choice principal agent problems task revelation 
bargaining theory market mechanisms non economic approaches dai overviewed 
resource bounded reasoning addressed 
coalition formation main areas multiagent systems dissertation contributes coalition formation 
part chapter assumes knowledge classical coalition formation concepts section core solution concept section 
solution concepts coalition formation comparison sections 
coalition formation settings domains self interested real world parties companies save costs coordinating activities parties 
negotiations agents question coordination arises coalitions agents form stable costs divided agents coalition 
coalition formation includes activities 
coalition structure generation formation coalitions agents agents coalition coordinate activities agents coordinate coalitions 
precisely means partitioning set agents exhaustive disjoint coalitions 
partition called coalition structure cs 
second solving optimization problem coalition 
task allocation problems involves deciding distribute tasks coalition member agents solving optimization problem agent resources tasks distributed 
coalition objective maximize monetary value money received outside system accomplishing tasks minus cost resources third agents coalition agree divide value generated solution 
activities interact 
example coalition agent wants join depends portion value agent allocated potential coalition 
coalition formation widely studied kahan rapoport van der linden verbeek raiffa kraus zlotkin rosenschein ketchpel knowledge rational agents 
call entire set agents say lowest cost achievable agents working agents crs minimum cost handle tasks agents resources agents coalition game characteristic function form characteristic function game cfg defined characteristic function defines value coalition gamma crs superscript emphasizes mean rational value coalition maximum value reachable coalition optimization problem 
rational agent solve combinatorial problem optimally deliberation costs cpu time costs time delay costs 
cfgs value coalition depends members 
value affected actions nonmembers 
games nonmembers actions affect value coalition discussed starting section 
problems tasks handled 
incorporated associating cost omitted task 
problem solving involves selection tasks handle 
game theory games agents binding deals regarding going coordinate called cooperative games 
mean agents cooperative self interested 
term antonym noncooperative games agents binding deals 
cooperative games proper subset noncooperative ones 
binding deals thought enlarging strategy spaces agents noncooperative game 
deals binding agents coordinate activities regarding deals going 
outcome game analyzed respect social welfare defined sum agents payoffs 
payoff agent gets denoted xi 
sum agents xi equal sum values coalitions coalition structure cs formed wealth generated wealth disappears 
setting dissertation agents side payments 
game superadditive value coalition plus value coalition value coalitions joined coalition fig 
definition game superadditive computation cost ignored case worst agents composite coalition solutions separate coalitions 
game non superadditive collusion process involves cost anti trust penalties 
superadditive games grand coalition games agents best social welfare viewpoint forming grand coalition csr lambda fag 
non superadditive games subadditive fig 
definition game subadditive subadditive games agents best operating csr lambda ffa fa 
games superadditive subadditive characteristic function fulfills condition superadditivity coalitions condition subadditivity 
cases social welfare maximizing coalition structure varies 
solution concepts coalition games 
targeted guaranteeing form stability 
satisfy efficiency criteria 
sections describe important solution concepts detail 
solution concepts cfgs discussed ones non cfgs 
solution concepts coalition games core current coalition structure social welfare maximizing ones group rationality 
social distributed agents agent motivated stay social welfare maximizing coalition structure csr lambda individual rationality 
furthermore distributed subgroup agents better csr lambda forming coalition coalition rationality 
core solution concept satisfies conditions kahan rapoport van der linden verbeek raiffa 
core game set payoff configurations csr lambda vector payoffs agents manner subgroup individual agents group agents subgroups motivated depart csr lambda payoffs value subgroup equal sum payoffs agents subgroup get csr lambda obviously css maximize welfare stable sense core cs group agents prefer switch csr lambda formally definition core csr lambda ae pi xi pi xi csr lambda core strongest classical solution concepts coalition formation 
strong cases empty social divided individual coalition rationality conditions satisfied kahan rapoport van der linden verbeek raiffa zlotkin rosenschein 
games non empty cores called weak fig 

games core empty solution prone deviation subgroup agents 
new solution acquired deviation prone deviation 
infinite sequence steps solution solution 
avoid explicit mechanisms limits negotiation rounds contract costs social norms need place negotiation setting 
lesser problem core may include multiple payoff vectors agents agree 
solution pick intuitively speaking center core kahan rapoport van der linden verbeek raiffa 
discussed section 
strong ffl core ffl solution concept related core constraints pi xi weakened pi xi gamma ffl 
provides solution concept games choosing sufficiently large positive ffl 
interpreted fixed cost ffl coalition complain solution 
solution concept called weak ffl core ffl cost assumed directly proportional number agents coalition 
conditions pi xi gamma jsj delta ffl 
clearly ae ae ffl positive ffl 
ffl cores decide payoff distribution vector games core includes vectors 
done choosing sufficiently small negative ffl ffl core point 
ffl cores solutions nonexistence core satisfy coalition rationality core empty 
furthermore motivated dynamics negotiation process 
problem core ffl cores constraints definitions numerous number agents increases 
due subset operator definitions 
core solution concept chapter dissertation 
alternative solution concepts discussed sections 
stable sets solution concept cfgs attempts remedy nonexistence problem core stable sets von neumann kahan rapoport 
solution concept keeps individual group rationality constraints relaxes requirement coalition rationality 
say solution cs dominates cs exists coalition xi pi xi 
binary relation dominance transitive 
defined stable set iff ffl cs cs dominates ffl cs cs dominates cs 
may stable sets game instance 
core non empty subset stable set 
number stable sets number constraints characterizing stable sets increases rapidly number agents 
problem solution concept games stable sets empty 
motivation stable sets follows solution concept satisfy coalition rationality 
bargaining set bargaining set solution concept cfgs attempts remedy nonexistence problem core computational complexity stable sets 
assumes individual rationality relaxes coalition group rationality 
bargaining set threat analysis 
individually rational payoff configuration cs considered stable bargaining set threat deviate cs answered kahan rapoport 
say agents members coalition sj cs 
agent launch objection sj pointing better coalition payoff distribution ffl sj ffl pi yi vry ffl yk xk yi xi 
hand agent launch pointing better coalition payoff distribution ffl ffl pi zi ffl zi xi zi yi 
objection called justified possible 
bargaining set defined set individually rational payoff configurations cs agent justified objection agent coalition 
bargaining set nonempty potential solution concept cfg 
furthermore games core nonempty core subset bargaining set core justified objections exist objections exist 
unfortunately bargaining set coalition structure solution concept coalition structure generation decide coalition structures negotiation viewed occurring payoff distribution cs 
furthermore bargaining set unique point coalition structure 
multiple extensions bargaining set concept order restrict space outcomes solution concept kahan rapoport 
extension considers payoff configurations rational subgroups coalition coalition structure individually rational payoff configurations 
second extension allows objections subgroups subgroups current coalitions subgroups 
furthermore second extension combined 
extended solution concepts unfortunately guarantee 
competitive bargaining set extension bargaining set launch multiple alternative objections simultaneously satisfy agents objections single 
obviously competitive bargaining set subset bargaining set 
unfortunately competitive bargaining set empty games 
ffl bargaining set extension inequalities objection difference ffl 
corresponds bargaining cost switching coalition structure 
bargaining set subset set 
psychological extensions bargaining set include modified bargaining set power bargaining set kahan rapoport 
kernel previous solution concepts considered stability different types threats kernel notion fairly distributing kahan rapoport 
define excess coalition cs payoff configuration cs definition excess gamma pi xi 
kernel balancing coalition 
maximum surplus player player cs definition maximum surplus se 
players said certain type equilibrium ffl ffl xl ffl xk 
kernel set payoff configurations players coalition type equilibrium 
formally definition kernel cs cs 
cfg kernel nonempty coalition structure 
furthermore subset bargaining set 
kernel fulfills desirable characteristics giving symmetric players equal payoff desirable players payoff desirable ones 
kernel solution concept models bargaining process 
viewed criterion fairness arbitration scheme 
solution concept cfgs notion fairness kahan rapoport lundgren 
pairwise comparisons agents considers jaj possible coalitions coalition structure cs payoff vector defined set payoff configurations cs jaj lexicographically minimal sorted nonincreasing order cs 
nonempty unique coalition structure characteristic function game 
subset kernel core nonempty 
inherits desirable properties symmetry desirability kernel satisfies individual coalition group rationality core nonempty 
equal share analysis solution concept cfgs fairness considerations stability equal share analysis kahan rapoport 
payoff configuration solution concept conditions hold 
coalitions coalition structure better joining 
second coalition divide value equally member gets current payoff vector 
third stronger members receive payoffs equal weaker members 
cfg nonempty set payoff configurations satisfying solution concept coalition structures 
unfortunately solution cfgs may empty pareto efficient coalition structures 
equal excess theory equal excess theory presents iterative scheme cfgs arriving payoff configuration 
scheme prescribed agents guarantee self interested agent best particular scheme 
agents start equal division payoff update expectations get payoff round 
round agents coalition view coalition best alternative coalition forms round 
games examined date scheme converged convergence proof kahan rapoport 
equal excess theory addresses coalition structure formation problem payoff division problem 
shapley value shapley value solution concept cfgs axiomatic approach kahan rapoport raiffa zlotkin rosenschein 
desirable properties axioms solution concept postulated shown shapley value solution concept satisfies 
solution concept model stability bargaining process 
basis fairness arbitration scheme 
axiom states agent payoff depends characteristic function coalition structure 
second axiom says agent labeling characteristic function affect payoff 
third axiom states sum agents payoffs coalition equals value coalition 
fourth axiom states agent participation change value coalition agent payoff zero 
fifth final axiom states player payoff composite game sum payoffs component games composite game 
axioms define unique payoff vector coalition structure 
element vector agent shapley value 
shapley value interpreted coalition accumulation argument 
agent contribution coalition depends agents joined ones join 
agent shapley value agent contribution coalition averaged possible joining orders 
shapley value payoff vector unique existing coalition structure cfg 
guaranteed satisfy individual rationality superadditive games 
necessarily satisfy coalition rationality need member core nonempty 
solution concept satisfies desirable property symmetry agents gives desirable agents higher payoff desirable ones 
nash equilibrium general value coalition may depend actions agents due positive negative interactions agents solutions 
settings modeled normal form games fig 

coalition formation solution concepts far section applicable characteristic function games cfgs value coalition characteristic function function actions nonmembers 
cfgs strict subset 
superadditivity subadditivity core solution concepts undefined non cfgs different solution concepts necessary 
alternative nash equilibrium nash kreps discussed section 
guarantees stability sense agent motivated deviate solution changing strategy game deviate 
note nash equilibrium solution concept space strategies solution concepts introduced sections space payoff configurations 
nash equilibrium concept comes noncooperative game theory come cooperative game theory 
strong nash equilibrium nash equilibrium solution concept weak subgroups agents deviate coordinated manner 
strong nash equilibrium aumann solution concept guarantees stability 
requires subgroup deviate changing strategies jointly manner increases payoff members nonmembers deviate original solution 
strong nash equilibrium strong solution concept games equilibria exist 
coalition proof nash equilibrium coalition proof nash equilibrium whinston solution concept suggested partial remedy nonexistence problem strong nash equilibrium 
solution concept requires subgroup mutually beneficial deviation keeping strategies nonmembers fixed way deviation stable criterion 
conceptual problem solution concept deviation may stable deviating group solution concept ignores possibility agents deviated may prefer deviate agents originally deviate 
furthermore kinds solutions exist 
clearly room research coalition formation solution concepts agents computationally limited 
hand computational limitations significantly change terrain 
existing computational coalition formation methods discussed section 
chapter dissertation new normative results coalition formation costly computation 
computational coalition formation far static solution concepts coalition formation 
address question divide payoffs agents 
address question coalition structure form 
static nature address dynamics coalition formation process 
section discuss addressed dynamics 
friend friend kahan rapoport developed program simulates agent coalition formation situation agents offers acceptances rejections regarding coalitions payoffs 
model offer regarding agent active time 
new offer old offers regarding agent void 
players consider current proposals lookahead memory 
negotiations terminate agents reach dyad third 
specifically termination criterion local threat examination agent necessarily accept new better offer introduces risk totally excluded step 
model purely descriptive 
guarantee self interested agent best specified local strategies 
transfer schemes dynamic approach coalition formation kahan rapoport 
agents stay coalition structure exchange payments coalition demands computed prespecified manner 
transfer schemes address payoff distribution problem coalition structure generation 
transfer scheme provably converges payoff configuration bargaining set initial payoff configuration cfg developed 
iteration agent faced justified objection agent pay minimal amount required objection unjustified 
agent faced multiple objections caters largest iteration 
bargaining set point exact final payoff configuration depends starting point 
transfer scheme kernel developed 
agents coalition exchange payments iteration diminish difference mutual maximum 
furthermore transfer scheme core developed 
scheme alternates operators 
agent payoff incremented coalition excess divided number agents coalition 
second agent payoff decremented equally just keep total payoff vector feasible 
method implemented largest excess fashion round robin fashion agents 
schemes converge core nonempty 
transfer schemes assume agents know values characteristic function 
zlotkin rosenschein zlotkin rosenschein analyze coalition formation rational agents side payments agents 
analysis limited subadditive task oriented domains strict subset cfgs fig 

solution concept agent handles tasks 
optimal exhibit scale 
assume agent take care agents tasks 
assume agents capabilities symmetric cost functions task sets 
method guarantees agent expected value equals shapley value kahan rapoport raiffa 
shapley value motivates individual agents stay coalition structure individual rationality group agents stay group rationality 
core shapley value general motivate subgroup agents stay coalition structure coalition rationality 
subset concave task oriented domains fig 
shapley value satisfies coalition rationality vector shapley value payoffs core 
naive method guarantees expected value equal shapley value exponential complexity number agents zlotkin rosenschein novel cryptographic method achieving linear complexity number agents 
linearly problems involving agents tasks needs solved optimally 
combinatorial problems vehicle routing problem dissertation domain zlotkin rosenschein matter clearly intractable problem instances large 
ketchpel ketchpel presents coalition formation method rational agents different expectations coalition values 
computational origin expectations addressed 
assumption imperfect information differs setting agents perfect information perfectly deduce 
method differs methods far addresses coalition structure generation payoff distribution 
activities handled simultaneously 
ketchpel coalition formation algorithm runs cubic time number agents guarantee stability 
protocol mutual offers 
practice hard prevent protocol offers multiagent offers 
agent auction manipulable computationally inefficient 
closely related contracting protocol mine sandholm traconet agents construct global solution contracting small number tasks time payments regarding contract new contracts take place 
agent updates approximate solution task transfer 
contributions contracting schemes discussed detail chapter 
general equilibrium market mechanisms section walras wellman non manipulative agents iterate allocation resources tasks payments final solution reached 
kraus kraus analyze coalition formation rational agents perfect information domains necessarily superadditive 
protocol guarantees agents follow certain stability criterion stability met 
requires solution exponential number optimization problems 
protocol guarantees weaker form stability polynomial stability requires solution polynomial number optimization problems 
unfortunately may intractable 
algorithm switches coalition structure guaranteeing improvements step coalition structure formation anytime algorithm domain problem solved optimally 
hand approach dissertation domain problem solved approximation design time algorithm 
variant computational coalition formation scheme database domain klusch 
kraus kraus algorithm coalition structure generation cooperative social welfare maximizing self interested agents 
agents payoff distribution non issue addressed 
distributed algorithm forms disjoint coalitions definition handle task allocates tasks coalitions 
complexity problem reduced restricting possibly compromising optimality number agents coalition 
greedy algorithm guarantees solution ratio bound best solution possible restriction number agents 
assumes domain problem coalition solved optimally cost case combinatorial problems dissertation 
second dissertation coalition handle task 
mechanism design section solution concepts dynamic schemes coalition formation discussed 
area game theory called mechanism design explores interaction mechanisms agents 
goal generate protocols agents stability solution concept dominant strategies muller fudenberg tirole kreps rasmusen section nash equilibrium refinements fudenberg tirole kreps rasmusen myerson fudenberg tirole kreps rasmusen desirable social outcomes follow 
approach normative 
local strategies externally chosen agents agent uses strategy best 
revelation principle important result mechanism design 
nash equilibrium implementation states outcomes achieved nash equilibrium mechanism representable finite game tree possibly moves nature achieved nash equilibrium direct revelation mechanism kreps 
direct revelation mechanism mechanism agents simultaneously reveal types private information 
potential problems include difficulty modeling free form negotiation situations game tree players difficulty computing nash equilibrium complex mechanism leading non nash play computationally limited agents human agents practice nash equilibrium kreps 
revelation principle dominant strategy mechanisms states outcome dominant strategy mechanism achieved direct revelation mechanism participation dominant strategies kreps muller 
subsections mechanism design discussed specific settings 
auction theory auction theory analyzes protocols agents strategies auctions 
auction consists auctioneer potential bidders 
auctions usually discussed situations auctioneer wants sell item get highest possible payment bidders want acquire item lowest possible price 
discussion section pertain classical setting contracting setting dissertation auctioneer wants subcontract tasks lowest possible price bidders handle tasks want receive highest possible payment doing 
mechanisms setting totally analogous mechanisms 
auction settings qualitatively different auction settings depending agent value monetary equivalent utility item formed 
private value auctions value depends agent preferences 
example auctioning cake winning bidder eat 
key winning bidder item case value depend agents valuations valuation monetary equivalent expected utility 
agent assumed know value exactly 
hand common value auctions agent value item depends entirely agents values identical agent symmetry criterion 
example auctioning treasury bills fulfills criterion 
inherently prefers having bills value bill comes entirely possibilities 
correlated value auctions agent value depends partly preferences partly values 
example negotiation contracting setting dissertation fulfills criterion 
agent may handle task case agent local concerns define cost handling task 
hand agent task case cost depends solely agents valuations 
section discusses different auction protocols 
auction protocols english price open cry auction bidder free raise bid 
bidder willing raise anymore auction ends highest bidder wins item price bid 
agent strategy series bids function private value prior estimates bidder valuations past bids 
private value english auctions agent dominant strategy bid small amount current highest bid private value price reached 
correlated value auctions rules varied auctioneer increase price constant rate rate thinks appropriate 
secondly open exit bidder openly declare exiting re entering possibility 
provides bidders information regarding agent valuation 
price sealed bid auction bidder submits bid knowing bids 
highest bidder wins item pays amount bid 
agent strategy bid function private value prior beliefs valuations 
general dominant strategy acting auction 
common knowledge assumptions regarding probability distributions agents values possible determine nash equilibrium strategies agents rasmusen 
dutch descending auction seller continuously lowers price bidders takes item current price 
dutch auction strategically equivalent price sealed bid auction games agent bid matters highest relevant information revealed auction process 
vickrey second price sealed bid auction bidder submits bid knowing bids 
highest bidder wins price second highest bid vickrey milgrom rasmusen 
agent strategy bid function private value prior beliefs valuations 
dominant strategy private value vickrey auctions bid true valuation 
agent bids increment difference winning loss wins 
bids smaller chance winning winning price unaffected 
dominant strategy result vickrey auctions means agent best bidding truthfully matter bidders capabilities operating environments bidding plans desirable sides 
agents reveal preferences truthfully allows globally efficient decisions 
second agents need waste effort agents matter making bidding decision 
vickrey auctions widely advocated adopted computational multiagent systems sun microsystems edelman huberman clearwater waldspurger drexler miller mackie mason varian mackie mason varian smart market rosenschein zlotkin 
example versions vickrey auction allocate computation resources operating systems waldspurger drexler miller allocate bandwidth computer networks sun microsystems mackie mason varian mackie mason varian smart market computationally control building environments huberman clearwater 
hand vickrey auctions widely adopted auctions humans rothkopf rothkopf protocol laid years ago vickrey 
limitations vickrey auction protocol especially computational multiagent systems discussed sandholm sandholm 
pay auctions family auction protocols 
mechanisms participating bidders pay auctioneer 
schemes computational multiagent systems tool reallocation private value auctions vickrey auction strategically equivalent english auction 
produce allocation prices 
hand correlated value auction agents bids english auction provide information agent valuation 
english vickrey auctions strategically equivalent general may lead different results 

methods susceptible infinite escalations bids raiffa discussed dissertation 
revenue equivalence non equivalence considering auction isolation auction protocols english dutch price sealed bid vickrey allocates auctioned item pareto efficiently bidder values 
imagine price auctions give higher expected revenue auctioneer second price auctions auctioneer gets second price 
case price auctions bidders motivated lie biasing bids downward 
revenue equivalence theorem vickrey milgrom rasmusen states auction protocols produce expected revenue auctioneer private value auctions values independently distributed 
pareto efficient allocation ones dominant strategies vickrey auction english auction efficient sense effort needs wasted bidders 
auctions pure private value auctions discussed earlier 
correlated value auctions bidders open exit english auction leads higher revenue vickrey auction 
reason bidders willing go high price causes bidder valuation auctioned item 
type auctions english vickrey auction protocols produce greater revenue auctioneer price sealed bid auction equivalent dutch auction 
bidder collusion problem auction mechanisms english auction dutch auction price sealed bid auction vickrey auction collusion proof 
bidders coordinate bid prices bids stay artificially low 
manner bidders get item lower price colluding 
english auction vickrey auction self enforce collusion agreements 
perspective collusion price sealed bid dutch auctions preferable 
example rasmusen shows 
bidder smith value bidder value auctioned item 
say bidders collude deciding smith bid bid 
english auction self enforcing agents exceeds smith observe willing go way cheater gain breaking coalition agreement 
vickrey auction collusion agreement just smith bids smith get item anyway 
bidding removes incentive bidder break coalition agreement bidding bid win auction 
hand price sealed bid auction smith bids agents incentive bid higher smith bid win contract 
holds dutch auction 
collusion occur vickrey auction price auction dutch auction bidders need identify submission bids non member coalition win contract 
hand english auction necessary bidders identify bids 
auctioneer organize computerized english auction bidding process reveal identities bidders 
lying auctioneer auctioneer may problem vickrey auction 
auctioneer may second highest bid highest bidder bidder verify 
second offer give bidder higher bill receive contractor truthful 
words theory classically assumes truthful auctioneer 
alternatively cryptographic electronic signatures bidders auctioneer second best bid winning bidder able alter 
auction protocols english dutch price sealed bid suffer lying auctioneer highest bidder gets item price stated bid 
cheating auctioneer suggested main reasons vickrey auction protocol widely adopted auctions humans rothkopf 
formal models cheating auctioneer discussed rothkopf 
model game theoretic 
analyses situation auctioneer choose sealed bid protocol vickrey protocol 
bidders equilibrium behavior creates positive incentives auctioneers type prone cheat choose standard price sealed bid auctions 
second model assumes simple rational bidders 
bid honestly long auctioneer caught cheating catching cheating auctioneer bidders bid auctioneer cheats 
result seller probabilistic opportunities cheat finite abilities resist cheating cheat caught finite time reason conduct vickrey auctions 
lying non private value auctions auctions pure private value auctions agent valuation depends part agents valuations 
example contracting settings bidder evaluation task affected prices agent subcontract task parts agents 
type commonly allowed automated versions contract net protocol sandholm smith 
common value correlated value auctions suffer winner curse 
agent bids valuation wins auction know valuation high agents bid 
winning auction amounts monetary loss 
knowing advance agents bid valuations milgrom rasmusen 
best strategy type vickrey auctions 
vickrey auction promotes truthful bidding private value auctions agent valuation totally determined locally fails induce truthful bidding auctions 
undesirable private information revelation vickrey auction truthful bidding dominant strategy private value auctions agents bid truthfully 
leads bidders revealing true valuations 
information sensitive bidders prefer reveal 
example winning contract low bid production cost low making larger profits thought 
observed auction results revealed want deals get higher payoff rothkopf 
suggested problem lying auctioneer main reasons vickrey auction protocol widely adopted auctions humans rothkopf 
price auction protocols expose bidder valuation clearly bid subject strategic lying 
auction types may desirable vickrey auction valuations sensitive 
social choice mechanisms auction pay auction mechanism usually leads binding contract agents auctioneer winning bidder 
hand social choice theory studies settings agents give input mechanism outcome mechanism chooses inputs solution agents 
settings outcome enforced agents abide solution prescribed mechanisms 
example social choice rule majority voting 
classic goal derive social choice rule ranks feasible social outcomes individuals rankings outcomes 
set agents set feasible social outcomes 
furthermore agent asymmetric negatively transitive strict preference relation social choice rule takes input agents preference relations jaj produces output social preferences denoted relation lambda intuitively properties social choice rule desirable 
ffl social preference ordering lambda exist asymmetric negatively transitive individual preferences 
ffl outcome pareto efficient sense lambda 
ffl scheme independent irrelevant alternatives 
specifically arrays consumer rankings satisfy iff social ranking situations 
ffl agent dictator sense implies lambda preferences agents 
arrow impossibility theorem states social choice rule satisfies properties arrow kreps 
design social choice rules desiderata relaxed 
commonly property relaxed sense domain combinations individual preferences rule works restricted 
third desideratum relaxed done majority voting rule 
due impossibility designing desirable social choice rules existing social choice rules lead paradoxical results combinations individuals preferences 
majority rule pairwise compare alternative social outcomes winner goes challenge alternative outcomes loser eliminated agenda order pairings totally change socially chosen outcome 
specifically games outcome feasible social outcomes pareto dominated preferred alternative agents 
irrelevant alternatives changes outcome 
number alternative outcomes large type repeated voting slow alternative method 
borda count assigns alternative joj points highest agent preference list joj gamma second 
alternative maximum points social choice 
borda count lead paradoxical results 
example removing lowest ranked alternative set possible social outcomes lead second worst outcome turning best best outcome turning worst new borda count 
far assumed executing social choice method agents preferences known 
reality seldom case 
agents need reveal declare preferences 
assuming knowledge preferences equivalent assuming agents reveal preferences truthfully 
agent benefit declaring preferences 
complicates design social choice mechanisms 
specifically satterthwaite impossibility theorem states domain social choice function social choice rule figures highest ranked social outcome preference ordering space combinations individuals preferences joj social choice function implemented dominant strategy mechanism function satterthwaite kreps 
design social choice functions impossible may light impossibility theorems 
settings individual preferences restricted invalidating conditions impossibility theorems 
example agent preferences linear payoff agent care payoffs agents receive 
type settings possible design non social choice mechanisms 
example groves mechanisms groves ledyard levy tax voters 
voter alters outcome vote higher tax 
taxation mechanism setup way preferences dominant strategy 
agents need waste effort preference declarations 
outcome chosen mechanism maximizes social welfare pareto efficiency 
furthermore participation mechanism increase agent utility mechanism individually rational 
mechanism set total tax revenue positive kreps negative raiffa rasmusen unfortunately equal zero 
means society projects need funded outside collected tax revenue destroyed 
redistributed society agents 
external mechanism pareto efficient social welfare maximizing 
groves mechanism minimizes surplus tax revenue called clarke tax mechanism clarke 
pareto efficient groves mechanisms coalition proof 
traditionally clarke tax mechanism solve single isolated social choice problem 
ai planning multiple agents mean voting possible multiagent plans 
clearly intractable 
reduce complexity ephrati variant method agents repeatedly clarke tax mechanism planning step time ephrati rosenschein ephrati rosenschein ephrati ephrati 
dominant strategy isolated clarke tax mechanism knowledge proven step repeated clarke tax mechanism dominant 
ephrati addressed distributing mechanism partial solutions redistributing tax waste partial solutions collusion problem 
principal agent problems field mechanism design principal agent problems types actors principals agents rasmusen kreps 
may kraus 
agents precise knowledge principals 
game theoretic terms principal coarser partition information sets 
basic idea games agent tries maximize utility finer information principal trying maximize payoff indirect methods extract agent hidden information 
game theory rarely multiagent systems kraus contracting refers contracts principal uses principal agent problems get agent information 
differs significantly common word contracting distributed artificial intelligence usually refers process finding making mutually beneficial contracts contract net protocol 
issues lying asymmetric information usually involved studies 
dissertation word contracting sense common dai 
completeness different types principal agent problems summarized 
usually game types bargaining issues split profits principal agent avoided assuming agent principal faces perfect competition 
games moral hazard hidden action actors start symmetric information contract 
agent takes action observed principal 
principal condition contract action 
conditioned events correlated action 
example employer principal pay worker agent amount goods produced agent hard agent works exactly measured 
moral hazard hidden information actors start symmetric information contract 
event occurs observed agent principal 
agent takes action reporting outcome event 
return related issue section 
adverse selection problems agent type knows principal 
principal tries tailor menu contracts agent self select contract non participation way desirable principal 
example principal employer offer flat rate salary incentive contract low ability worker agents choose high ability workers pick 
special case adverse selection called signaling agent type knows principal 
contract agent take actions observed principal give indications agent type principal 
example potential employee agent go school prove hard worker 
screening games signaling games agent takes observed actions contract 
education example works agent knows contracts functions education level offered chooses education acquire 
ephrati rosenschein ephrati rosenschein ephrati discussed computational multiagent planning situation agent wants follow principals plan 
setting agent precise information principal physically communicate information back principal 
agent decide adapt plan precise situation attempt maximize principals utility 
specifically metrics discussed measure intended plan actual plan deviate 
agent task revelation allocation rosenschein zlotkin applied game theoretic mechanism design concepts computational multiagent systems rosenschein zlotkin 
address problem making self interested agents reveal private information goals states 
contracting protocols dissertation contain series negotiation iterations mechanisms assume negotiation takes place single shot isolated manner 
assume agents optimally solve exponentially complete problems computation costs 
intractable problem instances small 
hand dissertation limitations agents computation capabilities addressed key issue 
furthermore agents dissertation allowed side payments rosenschein zlotkin 
negotiation specific agents setting dissertation applies number agents 
rosenschein zlotkin assume agents symmetric capabilities equal costs handling tasks moving world state 
dissertation assumptions assumptions hold application domains discussed 
point discussed detail dissertation 
methods constructed rosenschein zlotkin satisfy criteria individual rationality stability symmetry pareto efficiency independence irrelevant alternatives invariant regarding units utility measured 
properties stem deals maximize product agents utilities 
point discussed conjunction nash bargaining solution section 
rosenschein zlotkin domain classification included 
general class games worth oriented domains encompasses games agents different numeric preferences different states world agents capabilities costs moving world state rosenschein zlotkin zlotkin rosenschein 
subset state oriented domains includes games agents worth functions states binary agents goal states states partially satisfy agents rosenschein zlotkin zlotkin rosenschein 
mechanisms attempt agents declare different states attempt agents declare states goals 
subset task oriented domains tods agents tasks handle try redistribute tasks get handled inexpensively rosenschein zlotkin zlotkin rosenschein 
assumed symmetric monotonic cost function agents assigns real value subset tasks 
cost single agent incurs handling tasks 
dissertation assume costs capabilities agents symmetric 
assumption assigning real number implies agent capable handling tasks agents 
dissertation questionable assumption 
research focus tods truthfully agents reveal tasks agent knows tasks 
domain class tods includes subclasses different properties regarding task revelation 
subclass subadditive tods defined tods cost handling disjoint subsets tasks exceeds sum costs handling subsets separately 
subclass subadditive tods concave tods defined tods cost adding arbitrary set tasks agents original tasks exceeds cost adding arbitrary set subset original tasks 
subclass concave tods modular tods defined tods cost handling disjoint subsets tasks equals sum costs handling separately 
alternative types deals analyzed 
pure deals agents deterministically allocated exhaustive disjoint task sets 
hand mixed deals specify probability distribution partitions 
deals mixed deals alternatives include partitions agent handles tasks agents 
rosenschein zlotkin discuss forms lying task revelation 
agent may hide tasks revealing 
secondly may declare phantom tasks exist generated agent wants see 
may announce decoy tasks really exist generated demand 
forms lying possible different domain classes different deal types summarized table 
seen general tods different lying methods profitable 
follows tods subclass lying beneficial 
table 
rosenschein zlotkin results lying task revelation 
hid stands hiding tasks pha declaring phantom tasks dec decoy lies 
indicates lying specified type profitable problem instances domain class deal type 
general tods deals negotiation set set individually rational pareto efficient deals may empty 
general tod subadditive tod concave tod modular tod hid pha dec hid pha dec hid pha dec hid pha dec pure deals mixed deals deals bargaining theory bargaining setting agents mutually beneficial agreement conflict interest agreement 
furthermore subfields game theory outcome may imposed agent approval 
bargaining theory classically divided approach taken axiomatic strategic 
axiomatic bargaining theory competitive game theory axiomatic bargaining theory idea solution concept agents strategies form type equilibrium 
desirable properties solution called axioms bargaining solution postulated solution concept satisfies axioms sought osborne rubinstein kalai rasmusen osborne rubinstein 
nash bargaining solution historically early solution concept uses approach nash 
nash analyzed agent setting agents decide outcome get fallbacks agreement reached 
assumed space feasible utility vectors element vector agent compact convex 
occurs example possible lotteries pure deals domain allowed 
deals individually rational pay fallback agents may nash equilibria 
example agents bargaining split dollar splits give agent zero equilibrium 
agent strategy offer ae agent best response take offer opposed fallback zero 
best response offer ae 
nash equilibrium exists ae defines contract individually rational agents feasible ae 
due equilibrium stronger axiomatic solution concept nash bargaining solution needed prescribe unique solution 
axiom nash bargaining solution view agents numeric utility functions really represent ordinal preferences outcomes actual cardinalities utilities matter 
utility functions transformed affinely resulting game equivalent original game 
second axiom requires symmetry agents symmetric bargaining positions outcome utilities equal 
third independence irrelevant alternatives required 
fourth axiom requires pareto efficiency 
turns unique solution satisfies axioms 
nash bargaining solution selects utility pair maximizes product players gains utility fallback utilities 
nash bargaining solution extended agents kalai 
bargaining solutions exist 
postulate different desiderata axioms arrive different utility combination outcome kalai 
strategic bargaining theory axiomatic bargaining theory strategic bargaining theory postulate desiderata axioms solution concept 
bargaining situation modeled game solution concept analysis players strategies equilibrium 
follows games solution unique 
hand strategic bargaining theory explains behavior rational utility maximizing agents better axiomatic approaches 
agents choose strategies rely agents pertaining axiomatic notions fairness 
strategic bargaining theory usually analyses sequential bargaining agents alternate making offers prespecified order osborne rubinstein rasmusen osborne rubinstein kreps 
example think deciding split dollar 
finite number offers time discount get agent indifferent accepting zero offer getting zero fallback payoff 
time discount finite game solved starting 
agent offer gets payoff approaches ffi number negotiation rounds approaches infinity 
term ffi discount factor 
protocol non discounted setting allows infinite number bargaining rounds solution concept split dollar supported subgame perfect nash equilibrium 
hand discounted infinite round setting subgame perfect nash equilibrium unique 
specifically gets gamma ffi gamma ffi ffi discount factor ffi player ffi rasmusen 
agreement reached front 
model sequential bargaining discounts assumes fixed bargaining cost negotiation round 
agents symmetric bargaining costs solution concept split dollar supported subgame perfect nash equilibrium 
hand bargaining cost smaller agent agent gets entire dollar 
agent bargaining cost greater second agent agent receives payoff equals second agent bargaining cost 
second agent receives minus 
agreement reached round 
classical microeconomics assumptions monopoly perfect competition 
monopolist gets gains agent facing perfect competition profit 
real world settings usually consist finite number competing agents monopoly perfect competition assumptions strictly apply 
osborne rubinstein analyzed close classical assumptions come solutions bargaining theory explicitly considers interactions agents osborne rubinstein 
multiagent systems research community kraus extended sequential bargaining kraus 
addition going previous results contribute new theorems case outside options 
analyze case agent gains loses time 
discusses negotiation time agents know types 
dissertation models discussed assume perfect rationality agents 
computation required finding mutually beneficial contract 
space deals assumed fully comprehended agents value potential contract known 
market mechanisms market mechanisms microeconomic approach adapted computational multiagent systems 
game theoretic approaches normative market mechanisms usually descriptive 
determine kinds social outcomes follow agents certain specified strategies 
usually analysis strategy agent best response agent better deviating strategy 
extensively studied market framework general equilibrium theory varian kreps 
market types agents producers consumers 
finite number commodities 
amount commodity unrestricted commodity arbitrarily divisible 
different elements commodity distinguishable elements different commodities 
consumer utility function encodes agent preferences different consumption bundles vectors 
element vector describes commodity agent consumes 
consumer initial endowment different commodities 
producers commodities produce 
production vector producer describes commodity agent produces 
net usage commodity denoted negative number 
producer capabilities turning inputs outputs characterized production possibilities set set feasible production vectors 
producer profits divided consumers predetermined proportions need equal 
market mechanism sets global vector prices units commodity 
general equilibrium market ffl producer uses feasible production vector maximizes profits prices 
ffl consumer consumes bundle commodities agent afford bundle higher utility initial endowments current prices profits receives producers 
ffl markets clear commodity production equals consumption 
equilibrium pareto efficient 
production possibilities sets convex consumers preferences continuous non decreasing locally equilibrium exists 
sufficient condition uniqueness equilibrium demand nondecreasing prices goods 
general equilibrium related coalition formation market games 
specifically general equilibrium core 
point core removed core simply increasing number agents maintaining proportions types agents 
general equilibria exist markets producers 
pure exchange markets consumers just reallocate initial endowments varian kreps 
reach general equilibrium tatonnement process usually 
iterative mechanism trades production consumption assumed occur process terminated 
iteration auctioneer sets vector prices 
agents declare vector willing buy sell commodity current prices 
information auctioneer updates price vector iteration 
certain technical conditions process guaranteed converge general equilibrium 
computational multiagent systems wellman developed general equilibrium software system called walras 
example domains walras flow routing network wellman configuration design wellman 
wellman discusses application fails meet assumptions existence general equilibrium 
example design parameters discrete production possibilities sets convex 
wellman mullen applied walras distributed information network example mullen wellman 
iterative market process walras differs tatonnement 
specifically walras uses asynchronous declarations agents agents bid demand functions price opposed just quantities 
process converges general equilibrium cheng wellman 
tatonnement trades walras occur market process terminated 
usually market mechanisms studied date agents assumed act truthfully declaring amounts willing buy sell prices specific iteration 
proven revelation strategies equilibrium sense competitive game theory 
case agent better iteration 
example general equilibrium approaches desirable equilibrium agent reached 
truthful declaration reasonable assumed market large impact single agent totally negligible 
words agent price taker amount manipulation behalf going change final global price vector 
agents assumed reveal truthfully agents declarations 
problem domains dissertation fall scope general equilibrium theory 
tasks usually countable infinitely divisible violates assumptions existence general equilibrium 
secondly tasks commodities unique opposed tasks type usually item commodity 
third approach dissertation normative opposed descriptive studies general equilibrium processes 
dissertation agent limited rationality precludes exact computation production possibilities set 
traditional market models account externalities 
consumption externalities agent consumption affects agent utility 
production externalities agent production possibilities set directly affected agent actions 
glance hogg examples computational ecologies general equilibrium theory externalities dominant adding resources system operate efficiently glance hogg 
hogg shown externality problems common computational ecosystems hogg 
evolutionary aspects systems discussed miller drexler behaviors incomplete delayed information analyzed huberman hogg 
mechanisms attack externality problems include taxes viewing externality issues commodities varian 
price market mechanisms exist general equilibrium approaches 
example kuwabara studied computational societies agents buyers sellers 
approach sellers set prices buyers decide commodity purchase kuwabara ishida kuwabara 
huberman clearwater applied price market mechanism controlling building heating huberman clearwater 
mechanism exchanges occur iteration 
agents submit buy sell bids auctioneer sets price iteration supply equal demand 
buyers pay bids 
money repeatedly agents continue bidding 
system works practice formal properties proven 
spawn system allocating independent computation jobs heterogeneous processors network works basis waldspurger 
time processor idle runs second price sealed bid auction computation jobs bid right execute duration specified bid 
agents prespecified strategies approach normative 
formal properties spawn unproven experimental results suggest spawn achieves efficient usage processors net low coordination overhead achieves relatively fairness jobs 
spawn virtual money continuously jobs mechanism forging currency agents 
ferguson ferguson studied similar market mechanism allocating jobs processors repeated auctions focus fairness global efficiency 
miller drexler discussed computational price market mechanisms basis software publishing distribution miller drexler mechanism implementing processor scheduling garbage collection computer systems drexler miller 
addition price market mechanisms resource mechanisms exist 
example kurose simha developed market mechanism applied file allocation iteration agents compute marginal resources kurose simha 
resources reallocated iteration 
differs equilibrium approaches trades occur iterations completed 
resource approach solution gets better iteration guaranteed converge optimum 
contract net protocol cnp smith smith smith davis smith davis smith smith davis decentralized task allocation important market paradigms developed distributed artificial intelligence 
significance lies computational negotiation process involving mutual selection contractors 
cnp mechanism resembles directed government contracting scheme involved party allowed bid announcement receives bids parties revealed 
negotiations directed sense announcement sent agents van dyke parunak 
cnp initially applied task allocation simulated distributed sensor network acoustic interpretation 
applied job dispatching machines manufacturing plant van dyke parunak 
enterprise malone malone system allocating computation jobs processors network cnp mechanism 
choice processor expected completion time 
sen studied application cnp principles distributed meeting scheduling sen sen 
studied efficiency global system different local contracting strategies different meeting times decommitting previously scheduled meetings 
cnp includes restricted quantitative analysis gu ishida 
application agents totally cooperative selection contractee suitability example adjacency processing capability current agent load 
formal model discussed making task announcing bidding awarding decisions 
announcements bids awards real microeconomic principles prices quantitative demands 
dissertation presents formal model agents locally calculate marginal costs performing sets tasks 
choice contractee solely costs 
dissertation address previously unaddressed questions regarding cnp 
evidenced research traditional cnp shelf mature technology applied different domains protocol really includes enormous numbers design alternatives 
discussed dissertation chapter prescriptions regarding choices alternatives 
example previous cnp addressed risk attitude agent committed activities may able honor honoring may turn 
additionally previous cnp implementations tasks negotiated time 
sufficient effort carrying task depends carrying tasks 
framework extended handle task interactions methods clustering tasks sets negotiated atomic bargaining items 
practical problem announcement message congestion solved issues regarding real asynchronous implementation addressed 
question local deliberation scheduling negotiations discussed earlier key focus dissertation 
hypothesis distributed contracting developed efficient terms results computation complexity interaction mechanisms self interested agents rationality bounded limited computation resources 
non economic approaches dai historically field distributed artificial intelligence dai bond gasser huhns gasser huhns split branches classically called cooperative distributed problem solving cdps durfee decker lesser erman multiagent systems mas rosenschein genesereth genesereth 
distinction fuzzy main difference cdps agents cooperative designed centrally mas agents self interested agents designed separate parties 
focus mas mainly solve problems related self interest research cdps tackled computational questions 
seen term mas clearly capture difference 
lately field dai called mas cdps viewed subfield 
corresponds terms historical progression 
field cdps began late preceded field mas began mid 
far document reviewed mas microeconomic research relevant 
section review cdps related topics 
cdps began hearsay ii speech understanding system blackboard architecture structure computations lesser erman lesser erman 
different knowledge sources worked solve interpretation problem posting partial results common data structure called blackboard 
aim cdps agents maximize global agents 
goal usually approached heuristically 
important questions include scheduling knowledge source executions adequate overwhelming distribution partial results control knowledge 
blackboard systems originally single agent setting agent knowledge sources lately blackboard systems simulate cooperative problem solving systems consisting multiple agents knowledge sources lesser corkill lesser lesser corkill durfee lesser durfee lesser neiman 
hearsay ii research focus early cdps research switched distributed vehicle monitoring testbed lesser corkill blackboard centralized simulation geographically distributed acoustic sensor agents coordinate activities form interpretation vehicle movements area 
initial paradigm accurate cooperative fa agents lesser corkill lesser 
agents equipped ability form negotiate partial global plans pgp performing interpretation actions durfee lesser durfee lesser 
latest line research studied general coordination relationships statistically analyzed different coordination algorithms perform task decker lesser decker lesser decker lesser 
discussed section distributed manufacturing scheduling falls category cooperative distributed problem solving 
cdps approach applied problems 
multi stage negotiation protocol solve distributed constraint satisfaction problems agents global view due communication bandwidth limitations 
algorithm allows identification local decision disadvantageous global perspective incorporates goal relaxation 
example method applied circuit restoration network 
simulation cdps coordinate fire fighting 
distributed search structured small number levels satisfaction 
search proceeded worse level solution previous better level 
team simulation cdps applied distributed design problem configuring small number components desirable steam lander lesser 
non economic approach dai social laws tennenholtz moses moses tennenholtz shoham tennenholtz binding conventions agents designed line 
idea increase efficiency agent society conventions reduce need line coordination 
body non economic dai focuses constructing logic characterizations rational behavior cohen levesque cohen levesque grosz kraus rao georgeff rao georgeff morgenstern fagin 
idea formalisms automated agent act rationally 
characterizations called beliefs desires intentions bdi models 
line research grown single agent logic approaches subject study individual agent agent society 
study example agent commit plan commitments kept 
research focuses explicitly commitments multiagent plans 
recursive modeling method rmm non economic utility theoretic approach multiagent systems gmytrasiewicz durfee durfee gmytrasiewicz durfee 
agents priori interaction protocol model recursively 
enables evaluate utility actions domain actions communication actions 
cases leads emergence interaction protocols 
problem method clear way decide recursion bottom 
lately vidal durfee approach extending recursion expected provide gains cost deliberation vidal durfee 
resource bounded reasoning cdps focused computational issues multiagent systems consisting self interested agents ignored computational complexity assumed agents local reasoning rosenschein zlotkin zlotkin rosenschein zlotkin rosenschein zlotkin rosenschein ephrati rosenschein ephrati kraus 
computational limitations render traditional mechanisms inapplicable problem instances extremely small 
section reviews different approaches controlling single agent reasoning computational limitations 
computational bounded rationality multiagent contexts reviewed 
dissertation ideas normative deliberation control single agent settings extends multiagent systems 
traditional ai systems line 
input complete problem description output acquired unknown long time delay complete answer 
problem solving systems scale longer execution times common problem solving tasks real time garvey lesser considerable changes real world take place agent deliberation 
value agent action real world may decrease time necessitating tradeoff find action performing action early 
answer real time requirements ai research focused reactive systems brooks provide needed responsiveness unable solve complex problems adequately 
alternative extremes agent dynamically trade solution quality computation time 
done reasoning reasoning meta reasoning 
example agent choose deliberate longer answer needed soon provide crude answers quickly required environment 
qualitative tradeoff time quality intuitive operationalization challenging 
approaches ad hoc meta level control policies grounded probability theory utility theory choice base level actions 
approach called decision theoretic deliberation control 
questions answered control single agent reasoning deliberation tasks execute order time allocate 
research divided main criteria number reasoning tasks 
design time algorithms ambrosio garvey lesser meta reasoner implicitly sets run time expected result quality setting reasoning algorithm parameters execution 
time algorithms guaranteed answer available interrupted planned time simplest case computational task 
garvey lesser garvey lesser study combination computational tasks results composite design algorithm 
anytime algorithms called flexible computations examples interruptible processing 
result quality usually increases time answer available time 
newton iteration root finding example anytime algorithm computational task 
horvitz horvitz horvitz addresses choice single anytime algorithm number steps run medical diagnosis domain 
dean boddy boddy dean dean boddy boddy dean study sequential time allocation multiple anytime algorithms order create deliberation schedule maximizes sum qualities responses multiple events known ahead time 
combination method optimal deterministically known events anytime algorithms event performance profiles increasing convex algorithms independent results 
zilberstein russell zilberstein russell zilberstein russell zilberstein analyze time allocation multiple anytime algorithms form composite design time algorithm method type design time algorithm interruptible executing algorithm repeatedly doubling time allocations 
best case method uses twice amount computation optimal case oracle available reveal actual time interrupt 
worst case method uses times amount 
russell wefald russell wefald russell wefald study agent repeatedly choose deliberation actions currently highest ranked real world action 
viewed multitask anytime algorithm control problem time allocated deliberation actions chunks deliberation actions real world actions non interruptible 
method adversary search single agent search 
sandholm lesser optimal method terminating anytime decision algorithm performance profile conditioned execution far sandholm lesser 
progress monitoring similar conditioning studied optimization problems optimality sacrificed making simplifying assumptions hansen zilberstein 
specifically remaining performance profile conditioned quality solution far path quality solution taken 
decision theoretic control architectures need information value estimates 
russell wefald russell wefald russell wefald estimate value possible computation difference change intrinsic utility time cost 
compute change intrinsic utility change utility agent gets executing real world action perceived best computation executing action perceived best action assumed occur computation 
horvitz horvitz computes comprehensive value computation product non time dependent object related value time dependent discount factor 
mentioned papers separation information value function parts time account aspects possible practice 
general information value function answer quality time 
factors reasonably separated independent 
problem finding exact form time dependent part crucial algorithm choice optimal time allocation sensitive horvitz 
sandholm lesser method computing time dependent value probabilistic information sandholm lesser 
method takes account object related time related part simultaneously 
lesser lesser identify general ways reduce solution quality approximate processing 
focused interpretation domains ways apply planning domains zilberstein russell zilberstein russell zilberstein 
way ignore solution aspects 
analogously ignore details solution optimization problem 
second way reduce solution quality compromise precision 
analogous relaxing optimality optimization problems 
type approximation widely studied complete optimization problems 
fast algorithm exists guarantees solution error bound optimum 
solve troublesome problem reduce polynomial time complete problem approximation scheme type known 
complication 
general reductions preserve type approximation fact new reduced problem solved approximately certain error bound guarantee acquired solution approximate solution reasonable error bound original problem 
search approximation preserving reductions called reductions active field research theoretical computer science papadimitriou yannakakis 
third way reducing solution quality approximate processing decrease certainty 
dissertation focuses second type approximation relaxing optimality 
done added component trades solution quality deliberation time 
focused resource bounded reasoning multiagent systems single agent settings 
economics realized models assume perfect rationality behalf actors accurately predict interaction outcomes humans 
concept bounded rationality discussed cognitive limitations interacting humans considered simon 
associated humans hard quantify theories qualitative 
secondly descriptive exemplify human rationality limited prescribe deliberation control methods humans ought adopt 
hand dissertation focuses constructing normative quantitative theories multiagent systems involving bounded rationality agents try maximize utility limited reasoning capability 
heiner steps quantifying original descriptive models bounded rationality heiner heiner 
constructs agent action repertoire characteristics environment agent resides 
presents reliability condition states action added agent action repertoire reliability selecting action exceeds minimum required reliability necessary improve performance turn depends common correct environmental conditions new action agent gains correctly choosing new action agent looses incorrectly choosing 
words bound rationality fact agent distinguish action correct choose situation 
choose action repertoire agent greedily adds actions starting empty action set greedily removes actions starting set possible actions 
problem approach reality gain choosing new action right situation loss choosing wrong situation depend alternative actions exist repertoire 
probability choosing right action decrease probability choosing wrong action increase number actions repertoire increases 
greedy algorithm sufficient generating optimal action repertoire 
internal deliberation process perceiving environment choosing action described cost associated deliberation action repertoire chosen 
bounded rationality multiagent context rigorously studied repeated games rubinstein abreu rubinstein neyman papadimitriou yannakakis kalai stanford gilboa samet 
agents meet repeatedly structurally simple game prisoner dilemma table 
agent represented deterministic finite automaton dfa bound agent rationality stems limit number states dfa 
rationality restricted terms histories agent remember terms able solve combinatorial problems 
results counterintuitive cases rational agent better gilboa samet 
secondly model explain cooperation occurs finitely repeated prisoner dilemma game rational agents defect iteration neyman papadimitriou yannakakis 
model real computerized agent dfa unrealistically weak 
computing device usually model capabilities computational agent turing machine 
real digital computer analog computer finite resolution finite storage capacity turing machine theoretically computer modeled dfa 
computer bits megabyte memory virtual included need dfa states model 
results dfas playing repeated games hinge assumption player identify opponent dfa 
clearly infeasible small example computer require repetitions game 
mor rosenschein showed time enable cooperation finitely repeated prisoner dilemma bounded rational agents mor rosenschein 
idea agent uses time checks memory number iteration occurring 
delays response agent observe delay 
fact allows cooperative equilibria agent time check iteration number fear punishment opponent finitely repeated game equivalent infinite agents know iteration occur 
dissertation uses different model bounded rationality 
bound rationality stems agent limited capability solve combinatorial problems 
chapter explicit model agent solve combinatorial problems iterative refinement domain cost solution decreases allocated computation time 
rationality bound quantitatively character ized algorithm performance profile 
allows optimal trading solution quality computation time 
normative model resource bounded reasoning enables construction normative theories interactions coalition formation computationally limited agents 
chapters discuss contributions dissertation 
chapter analyzes automated contracting chapter discusses coalition formation chapter presents methods unenforced contract execution 
automated contracting chapter presents extensions contract net protocol cnp section allow operate self interested computationally limited agents 
automated contracting agents deals iteratively reallocate tasks order able handle tasks efficiently original distribution tasks agents 
cast negotiations framework 
agent possibly empty set tasks possibly empty set resources handle tasks 
sets change due domain events new tasks arriving resources breaking 
agents subcontract tasks agents paying compensation 
process involve breaking task number subtasks handled different agents clustering number tasks supertask 
task transfer profitable global perspective contractee handle task contractor contractor handle contractee 
problem levels global task allocation problem agent local combinatorial optimization problem defined agent current tasks resources 
goal agent maximize payoff defined income minus costs 
income received handling tasks costs incurred resources handle tasks 
model allows resources idling costs agent local cost positive tasks 
case vehicle routing problem 
restrict domains feasibility cost handling task depend agents resources control resource shared divide tasks depend tasks agent case distributed vehicle routing problem usually scheduling 
global solution evaluated social welfare viewpoint sum agents payoffs 
dissertation concentrates negotiation hard multiagent domains task increase decrease marginal cost task agent 
corresponds having economies scale domain 
economies scale task allocation problem trivial social welfare perspective optimal solution agent handles agents tasks rosenschein zlotkin zlotkin rosenschein 
hand setting realistically allows scale distribution tasks agents trivial done centrally totally cooperative truthful agents 
best solution may partition tasks agents 
optimal task allocation hard combinatorial problem 
solving agent local optimization problem task set currently allocated agent hard combinatorial problem 
opposed bulk game theory formal computational multiagent systems assumed agents exact view marginal costs tasks 
marginal costs involved computations usually carried optimally due computational resource bounds time constraints 
secondly assumed agents similar capabilities marginal cost task may vary agents due example static resources dynamic state resources 
marginal cost task agent cost agent solution task minus cost agent solution 
calculate exact marginal cost different combinatorial problems agent need solved optimally 
sections detail contributions dissertation automated contracting 
contracting marginal costs previous contract net protocol cnp implementations section assumed totally cooperative agents mutual selection contractors heuristically suitability example adjacency processing capability current agent load 
formal model discussed making task announcing bidding awarding decisions 
hand transportation cooperation net traconet system developed initial part thesis research introduced formal model automated contracting sandholm sandholm sandholm sandholm 
model agents locally calculate marginal costs performing sets tasks 
choice contractors solely costs 
pricing mechanism generalizes cnp cooperative competitive agents 
traconet system operates market assumptions game theoretic 
example agents truthfully reveal marginal costs gains divided half parties contract 
agents contracting process 
hand sections chapter chapters dissertation fully game theoretic analysis 
traconet running implementation automated contracting distributed vehicle routing domain 
traconet computational agent represents dispatch center 
original cnp implementation centralized simulation traconet truly distributed system 
agent implemented unix process pass negotiation messages asynchronously network system implemented object oriented manner language window system 
solving vehicle routing problem agent solves local routing problem 
agent potentially negotiate dispatch agents take deliveries take deliveries dynamically constructed charge 
negotiations agents exchange sets deliveries profitable contractor able carry task set costs manager agent 
negotiations viewed iterative way enhancing global routing solution traversing sequence task allocations agents 
step iteration agent keeps feasible local routing solution tasks allocated 
feasible means agent take care deliveries vehicles 
iterative task reallocation scheme global solution closer global optimum reached global optimization run performed 
negotiation real time contract exchange tasks payments immediately 
iteration agents equilibrium reached general equilibrium market approaches section 
scheme works dynamic domains individual negotiations delivery orders may dispatched new orders may arrived available vehicles may changed 
iterative task allocation scheme anytime algorithm stopped time feasible solution 
solution guaranteed worse initial solution agents operated individually agents profitable task transfers 
agent act manager contractor delivery sets take roles required negotiate agents 
agent reallocate deliveries received agents 
announcing agent tries buy agent transportation services price maximum specifies announcement 
bidding agent tries sell services price minimum specifies bid 
awarding means buying services center award means selling services 
announcing tasks announcing agent chooses set deliveries deliveries center announces centers order get bids announcing methods differ example delivery set announced 
leads better results tasks reallocated profitably reallocated profitably contracts taken place changed existing task allocations 
hand negotiations longer negotiations 
serious problem assume actual deliveries done negotiations done immediately 
announcing set tasks agent includes number maximum bidder may require agent pay having tasks handled 
allows expensive bidders waste negotiation resources system computation communication 
agent call willing individually rational contract announces marginal cost removing task set announce routing solution incorporates agent tasks ti ci ti gamma ci ti announce ci cost optimal routing solution sum route lengths tasks vehicles agent vehicle routing problem complete implementation announcements focus deliveries geographical main operation areas potential contractors deliveries lead contracts 
efficiency improving heuristic necessary contracting approach 
computing ci intractable 
approximation scheme computing directly 
note negotiation methods domain independent approximation algorithm domain specific rewritten contracting software transported problem domains 
value approximation low agents bid beneficial 
hand estimate high agent may receive bids 
actual value crucial awarding phase announcements binding traconet bids awards 
incorrect approximation lead contracting 
bidding bidding agent reads announcements sent agents 
maximum price mentioned announcement higher price deliveries cost done agent bid sent price bid sent specified announcement 
formally bidder bids marginal cost adding task set announce routing solution incorporates agent tasks tj cj tj announce gamma cj tj cj cost optimal routing solution tasks vehicles agent vehicle routing problem complete computing cj intractable 
approximation scheme computing directly 
value approximation lower true value agent may accept contract 
holds defined respect optimal solutions 
agents compute optimal solutions approximated marginal cost relevant criterion long approximation algorithm algorithm generates new solution tasks awarded bidder 
case approximated marginal cost really cost bidder incurs handling announced delivery tasks 
similarly value approximation high agent may contracts beneficial solve combinatorial problems optimally beneficial uses approximation scheme incorporate tasks routing solution 
awarding awarding tasks agent reads bids agents 
handling bids concerning certain announcement checks fixed time passed sending announcement potential time bid 
point agent contract beneficial 
obvious contracting activities domain events may changed tasks 
current set tasks need equal set ti time announcing 
awarding price marginal cost removing task set announce routing solution incorporates agent tasks ci gamma ci announce ci cost optimal routing solution tasks vehicles agent computing ci intractable 
approximation algorithm estimating directly similar considerations regarding estimation announcing bidding stages 
greater lowest bid agent sends award message agent expensive bid 
convention contract takes place price ae bid pays bidder 
removes set deliveries announce routing solution 
receiving awards agent gets awarded task set accept bids binding traconet 
new marginal cost calculation needed 
agent just incorporates awarded tasks routing solution 
done algorithm marginal cost approximation bidding phase 
contracts may bidding certain set tasks corresponding award 
contracts altered routing solution award longer profitable agent 
bids binding center committed award anyway 
making bids non binding solve problem contractee receiving award inform contractor taken award take 
require contractor keep delivery set routing solution award confirmed changes may routing solution problem 
scaling marginal cost task reallocation negotiation works efficiently large scale instances combinatorial problems 
example ran traconet system real world data section 
purpose experiment validate approach reducing total transportation costs autonomous dispatch centers 
agents executed hp workstation 
minutes agent goes announce bid award loop times 
table presents results example run 
savings measured compared initial routing solutions agent operates individually 
local solutions acquired polynomial heuristic algorithm 
acted solutions agents local solutions negotiations began 
seen negotiations led considerable transportation cost savings reasonable time large problem instance 
results taken quantitative indication large savings depends problem problem instances quality heuristic algorithm generates initial solutions order contracts happen occur asynchronous implementation 
results interpreted proof concept automated contracting implemented operate large 
furthermore guaranteed solution acquired amount negotiation time worse agent initial solution participation negotiations individually rational agent 
table 
experimental results automated contracting vehicle routing real world data 
dispatch cost savings cost savings agent minutes minutes negotiation negotiation total addition proof concept traconet system served introduce previously unaddressed questions automated contracting 
analyzed detail 
issues addressed sections 
levels commitment traditional multiagent negotiation protocols self interested agents contract binding party back rosenschein zlotkin sandholm ephrati rosenschein kraus 
agent agrees contract follow matter events unravel 
contract may profitable agent viewed ex ante need profitable viewed events occurred ex post 
similarly contract may low expected payoff ex ante realizations events contract may desirable viewed ex post 
normal full commitment contracts unable efficiently take advantage possibilities probabilistically known events provide 
hand multiagent systems consisting cooperative agents incorporate form decommitment possibility order allow agents accommodate new events 
example original contract net protocol smith agent contracted task send termination message cancel contract contractee partially fulfilled contract 
possible agents self interested contractee mind losing part effort monetary compensation 
similarly role decommitment possibilities cooperative agents studied meeting scheduling contracting approach sen sen cooperative coordination protocols decker lesser 
agents require monetary compensation efforts agent agreed cancel contract merely fact agent wanted decommit 
research descriptive happen agents certain externally specified strategies 
descriptive approach viable cooperative agents systems consisting self interested agents require consider case agents follow externally specified strategies choose strategies 
interaction protocols need considered normative perspective protocol best strategy self interested viewpoint agent choose social outcomes follow 
normative research game theory focused utilizing potential provided probabilistically known events contingency contracts self interested agents raiffa 
obligations contract contingent events 
games method provides expected payoff increase parties contract compared full commitment contract 
deals enabled contingency contracts sense full commitment contract agents prefer fallback positions contingency contract agent prefers fallback 
problems regarding contingency contracts automated negotiation self interested agents 
useful anticipating small number key events contingency contracts get cumbersome number relevant events monitor increases 
limit domain events changes domain problem new tasks arriving resources breaking negotiation events contracts negotiations affect value obligations original contract conditioned 
furthermore events may affect value original contract independently value original contract may depend combinations events sandholm lesser sandholm rosenschein zlotkin 
potential combinatorial explosion events conditioned 
second feasible cumbersome contingency contracts computerized agents impossible enumerate possible relevant events advance 
third problem verifying unraveling events 
event observable agents 
agent may incentive lie party contract event case event associated contingency directly observing agent 
viable contingency contracts require event verification mechanism manipulable prohibitively complicated 
propose method advantage possibilities provided probabilistically known events 
conditioning contract events mechanism built contract allows unilateral decommitting point time 
achieved specifying contract decommitment penalties agent 
agent wants decommit freed obligations contract simply paying decommitment penalty party 
call contracts leveled commitment contracts decommitment penalties choose level commitment 
method requires explicit conditioning events agent conditioning dynamically 
event verification mechanism required 
section dissertation presents formal justifications adding decommitment feature contracting protocol 
principles assessing decommitment penalties studied economics law posner purpose assess penalty agent contract breach occurred 
similarly penalty clauses partial failure meeting deadline commonly contracts purpose usually motivate agents follow contract 
knowledge possibility explicitly allowing decommitment contract predetermined price studied active method utilizing potential provided uncertain 
somewhat turns mere existence decommitment possibility contract increase agent expected payoff 
intuitively speaking goal leveled commitment contracting protocol allow flexibility negotiation case commitment guaranteeing agents level security total commitment case 
commitment breaking cost increase time decrease function acceptance time offer conditioned events negotiations environment 
suggested message types level commitment dynamically negotiated contract task set basis 
qualitative reasons multiple levels commitment desirable approach ffl allows agents profitably accommodate new domain events new tasks arriving resources breaking allowing agent back old contracts new events 
ffl allows agents profitably accommodate new negotiation events new offers acceptance messages 
events old contracts agent agent decommit old contracts 
ffl allows controlled profitable risk 
terms search means moving low commitment search focus global task allocation space decommitting unreasonably expensive space explored self interested agents avoid risky commitments 
example agent accept task set try contract tasks set separately 
full commitment agent needs standing offers agents contract tasks able handle 
leveled commitment protocol agent accept task set sure chances getting handled worst case decommit 
ffl enhances negotiations computationally 
example agent low commitment offer offers overlap task sets multiple agents 
case accepts agent pay penalty speedup able address multiple agents committal mode may outweigh risk 
ffl allows flexibility agent local deliberation control marginal cost calculation contract go contract agreed 
contract turns extended deliberation agent decommit 
ffl allows profitable construction composite contracts basic contracts 
section types composite operators desirable contracting clustering swaps multiagent contracts 
involve contracting task time atomically 
hand leveled commitment protocol allows composite contracts constructed sequence basic contracts 
example say profitable contract agent gives task agent agent gives task agent unprofitable contract anticipation contract combination profitable 
agree contract agent back contract ffl allows agents lesser risk aversion carry greater portion risk 
risk averse agent trade paying higher price contractee get paid lower price contractee allowed lower decommitting penalty 
increases social welfare 
ffl allows beneficial contingency contracts conditioning payments commitment functions negotiation events domain events 
enlarge set mutually beneficial contracts agents different expectations events different risk attitudes raiffa 
rest section substantiate advantages leveled commitment contracts formally 
analyze contracting situations perspective agents contractor pays get task done contractee gets paid handling task 
handling task mean types constraints method specific classical task allocation domains 
contractor tries minimize contract price ae pay 
contractee tries maximize payoff ae receives contractor 
outside offers third parties explicitly discussed 
contracting setting consists games 
contracting game involves agents choosing contract contract null deal events 
secondly decommitting game involves agents deciding decommit carry obligations contract events 
decommitment game subgame contracting game expected outcomes decommitting game affect agents preferences contracts contracting game 
decommitting game analyzed nash equilibrium dominant strategy concepts 
contracting game analyzed respect individual rationality ir contract better agent null deal 
contract ir agents contracts 
ir contracts choose infinitely nash equilibria contracting game 
contractor strategy offer contract price ae contract ir agents contractee best response take offer opposed null deal 
contractor best response offer ae 
nash equilibrium exists ae defines contract ir agents 
axiomatic bargaining theory nash osborne rubinstein studies question choosing ir contracts asserting desirable properties chosen contract fulfill compared contracts 
sections analyze advantage leveled commitment contracting protocol compared full commitment different contracting settings 
sections subsections ordered simpler settings precede complex ones 
section describes settings agent involves uncertainty section describes settings agents futures involve uncertainty 
symbols upcoming sections summarized table 
section practical prescriptions builders automated negotiation systems 
table 
symbols section 
restrict analysis contracts rule contracts specify decommitting agent receives payment victim decommitment 
ae contract price 
contractor decommitment penalty 
contractee decommitment penalty 
price contractor best full commitment outside offer 
price contractee best full commitment outside offer 
ex ante probability density function ex ante probability density function pa probability contractor decommits 
pb probability contractee decommits contractee fallback payoff gets contract 
big positive number 
uncertainty agent outside offer section presents games agent outside offer fixed known agents contract time uncertainty prevails price agent outside offer 
contractee deterministically known outside offer contractor best outside offer known probabilistically agents probability density function 
case contractor receives outside offer best outstanding outside offers fallback payoff 
case contractor outside offer deterministically known contractee outside offer probabilistically known analogous 
contract contractee outside offer known contractor 
hand decommitting game takes place contractor value assume point contractee know contractor outside offer realistic automated contracting systems 
cases depending contractee outside offer stays valid point contractor finds outside offer contractor decides decommitting obligations contract 
deterministic offer prevails dop case contractee outside offer stays valid point contractor finds outside offer 
contractor decides decommit contractee accept outside offer 
call situation dop game 
sequential decommitting dop game contractee reveals decommitment contractee gains information contracting game decommitting game find decommitting beneficial original contract beneficial better outside offer agreed 
contract null contract full commitment contract contract rf contractor decommit decommitting game ae doesnot decommit ae contractee doesnot decommit decommit 
deterministic offer prevails dop game 
contractor decommits contractee accept outside offer 
contractor payoff listed contractee 
bold solid lines show choices may occur subgame 
bold dashed line represents contractee information set know decommitting game 
thin dashed lines represent alternative situation agents reveal decommitment simultaneously deciding decommitting contractor observed contractee 
holds game agents reveal decommitting simultaneously opposed contractee game depicted information sets denoted thin dashed lines 
sequential decommitting game contractor moves contractee want decommit 
contractor decommits contractee save decommitment penalty declaring decommitment contract void anyway 
discuss branches contractor decommit 
branches contractee payoff independent contractor outside offer branches equivalent 
contractee better decommitting branch contractor know 
contractor decommit matter outside offer turns 
decommitting game played contractor decommitting contractee decommitting 
clearly kind contracting game ir contractee 
contractee decommits 
protocol specifies agent pay decommitment penalty decommit payoffs parentheses contractee wants decommit cases 
agent possibly move decommitting game contractor 
settings contractor reason contractee decommit 
cases equivalent 
holds protocol specifies pay decommit protocol specifies pay decommit 
contractor cost ae decommit 
words contractor payoff gamma ae gamma gamma contractor decommit ae 
probability contractor decommit pa ae gamma gamma contractee individual rationality ir constraint states contract higher expected payoff fixed outside offer gamma pa ae pa contractor choose ex post wants decommit stay contract 
contractor ex ante ir constraint idea gamma max gamma gamma gamma ae gamma gamma ae gamma gamma gamma gamma ae gamma gamma ae game specified advantages leveled commitment contract analyzed 
obviously game full commitment contracts subset leveled commitment ones leveled commitment contract emulate full commitment choosing high decommitment penalty motivates contractor surely decommit assuming bounded 
full commitment contract exists leveled commitment contract worse payoff agent 
furthermore theorems state strict superiority leveled commitment contracts full commitment ones game 
theorem states dop games agents beneficial contract full commitment protocol leveled commitment 
theorem enabling dop games dop games defined full commitment contract satisfies ir constraints leveled commitment contract satisfies ir constraints 
proofs intuition enhancing theorems postponed appendix dissertation 
theorem states protocols allow beneficial contract leveled commitment protocol may allow higher expected payoffs agents full commitment protocol 
holds long chance contractor outside offer lower contractee 
theorem pareto efficiency improvement dop games arbitrary full commitment contract satisfies ir constraints aef 
bounded gamma 
exists leveled commitment contract increases contractor payoff contractee payoff satisfies ir constraints 
follows conditions theorem full commitment contract pareto efficient 
theorem shows desirable property agent hurt negotiation partner biased beliefs dop game 
specific contract agent precise information expected payoff thinks independent agent reasoning process information sources 
agent need negotiation partner beliefs 
theorem fa contractor belief fb contractee belief 
theorem payoff unaffected opponent beliefs dop games say agent information unbiased fa fb 
agent expected payoffs contracts unaffected possible biases agent information 
agent preference ordering contracts unaffected 
certain offer void section discusses setting contractee fixed outside offer offer accepted contractor finds price best outside offer case contractor receives outside offer fallback payoff 
offer void 
agree contract contractee higher expected payoff passing offer agreeing risky contract accepting offer 
contract decommitment occurs contractor outside offer valid known contractor contractee contractee anymore 
case contractee gets fallback payoff plus contractor decommitment penalty payment fallback interpreted example contractee second best outside offer best available case outside offers outstanding contractee payoff contracts 
call setting game 
sequential decommitting game contractee reveals decommitment contractee gains information contract null contract full commitment contract contract rf rf contractor decommit decommitting game ae contractee doesnot decommit ae contractee doesnot decommit decommit 
certain offer void game 
contractee outside offer accepted contractor outside offer known 
bold solid lines show choices may occur subgame 
bold dashed line represents contractee information set know decommitting game 
thin dashed lines represent alternative situation agents reveal decommitment simultaneously deciding decommitting contractor observed contractee 
contracting game decommitting game find decommitting beneficial original contract beneficial better outside offer agreed 
holds game agents reveal decommitting simultaneously opposed contractee game depicted information sets denoted thin dashed lines 
sequential decommitting game contractor moves contractee want decommit 
contractor decommits contractee save decommitment penalty declaring decommitment contract void anyway 
discuss branches contractor decommit 
branches contractee payoff independent contractor outside offer branches equivalent 
contractee better decommitting branch contractor know 
contractor decommit matter outside offer turns 
decommitting game played contractor decommitting contractee decommitting 
clearly kind contracting game ir contractee 
contractee decommits 
protocol specifies agent pay decommitment penalty decommit payoffs parentheses contractee wants decommit cases 
agent possibly move decommitting game contractor 
settings contractor reason contractee decommit 
cases equivalent 
holds protocol specifies pay decommit protocol specifies pay decommit 
contractor cost ae decommit 
contractor decommit ae 
pa ae gamma gamma contractee ir constraint gamma pa ae pa contractee fallback position payoff gets get outside offer contract contractor 
note situation reduces dop game section dop results favor leveled commitment hold 
naturally hold risky leveled commitment contract desirable contractee affecting desirability contractor 
contractor ir constraint idea ex post contractor choose wants decommit stay contract 
ex post contractor finds contract individually rational gamma max gamma gamma gamma ae ae 
ex ante ir constraint gamma gamma ae gamma gamma gamma gamma ae gamma gamma ae full commitment contracts subset leveled commitment ones contractor decommitment penalty chosen high contractor surely decommit assuming bounded 
discussed earlier contractee decommit 
class leveled commitment contracts worse class full commitment ones 
games leveled commitment contract pareto superior full commitment contract contractee fallback sufficiently high game reduces dop game theorems show contractee fallback low leveled commitment contracts helpful games 
theorem enabling low fallbacks games restrict games ae gamma gamma ad ar ae gamma gamma game defined full commitment contract satisfies ir constraints leveled commitment contract satisfies 
constraint ae gamma gamma ad ar ae gamma gamma satisfied example 
means contractor outside offer require nonnegative payment contractor task contractee nonpositive fallback 
requirement restrictive 
suggests theorems negative results may limited scope 
theorem pareto improvement low fallbacks games restrict games ae gamma gamma ad ar ae gamma gamma arbitrary full commitment contract satisfies ir constraints aef 
exists leveled commitment contract increases agent expected payoff decreasing agent expected payoff 
discuss games agents beliefs differ 
specifically fa contractor belief fb contractee belief common knowledge 
contractee perceived individual rationality pir constraint gamma ae gamma gamma fb ae ae gamma gamma fb similarly contractor pir constraint gamma fa gamma ae gamma gamma fa gamma gamma ae gamma fa gamma ae theorem shows contract beneficial agents full commitment contract beneficial agents may perceive leveled commitment contract beneficial 
theorem perceived enabling games games defined fa fb full commitment contract satisfies ir constraints leveled commitment contract satisfies ir constraints full commitment contract satisfies pir constraints leveled commitment contract satisfies pir constraints 
agents perceive leveled commitment contract satisfies individual rationality constraints 
due fact agent estimate distribution contractor outside offer biased 
hand contractee fallback payoff sufficiently low agents know theorem contract really ir 
agent going incur loss agents agree contract perceived ir 
positive result states agent unbiased beliefs expected payoff thinks independent agents beliefs stemming reasoning process information sources 
unbiased agent enter unprofitable non ir contract due agent biases 
means agents need negotiation partner beliefs 
theorem payoff unaffected opponent beliefs games say agent information unbiased fa fb 
agent expected payoffs contracts unaffected possible biases agent information 
agent preference ordering contracts null deal unaffected 
corollary perceived ir ir unbiased agent games say agent information biased fa fb 
say contract perceived ir agent fx 
contract really ir agent 
follows contract perceived ir agents really contract really ir agent unbiased beliefs agent biased beliefs 
uncertainty agents outside offers section discusses contracting setting agents involves uncertainty 
specifically agents contractor contractee receive outside offers 
contractor best outside offer probabilistically known ex ante agents characterized probability density function 
contractor receive outside offer corresponds best outstanding outside offer fallback payoff payoff receives contract 
contractee best outside offer probabilistically known ex ante characterized probability density function 
contractee receive outside offer corresponds best outstanding outside offer fallback payoff 
variables assumed statistically independent 
contractor options contract contractee wait similarly contractee options contract contractor wait agents mutual contracts choose 
leveled commitment contract specified contract price ae contractor decommitment penalty contractee decommitment penalty agents possibility full commitment contract 
contractor decide decommitting knows outside offer know contractee outside offer similarly contractee decide decommitting knows outside offer know contractor outside offer realistic practical automated contracting perspective 
dop game discussed section special case type games 
dop game probability mass value dop game special case game described section hand games subset type games games opportunity outside offer may missed due waiting unraveling new outside offers 
assume agents decommit truthfully 
example agent may decommit outside offer better contract agent believes high probability opponent decommit 
save agent decommitment penalty fact agent receive decommitment penalty opponent 
games type differ significantly agents decommit sequentially simultaneously 
sections detail cases 
sequential decommitting sequential decommitting game agent declare decommitment agent 
study case contractee decommit 
case contractor decommit analogous 
game tree 
alternative types leveled commitment contracts differ happens agents decommit 
agents pay decommitment penalties decommit 
second agent pay decommit 
analyze decommitting game dominance subgames solution concept 
specifically start reasoning agents actions leaves game tree proceed backwards game 
subgame contractee contractor best move decommit gamma gamma gamma 
holds contract agent pay decommitment penalty decommit gamma gamma fig 
parenthesized payoffs 
subgame contractee contractor best move decommit gamma gamma gamma ae 
happens probability ae gamma gamma put contractee gets gamma decommits contractor ae decommits 
contractee decommits gamma ae gamma gamma ae gamma ae ae gamma equivalent gamma false nonnegative 
words contractee surely decommits contractor 
hand equivalent ae ae gamma gamma ae gamma def lambda ae ae gamma contract null contract full commitment contract contract rf rf decommit decommitting game ae contractee doesnot decommit ae ae decommit 
sequential decommitting game 
game tree represents alternative protocols different games 
agents pay decommitment penalties decommit 
second agent pay decommit 
payoffs protocol parentheses differ 
dotted lines show information sets contractor know contractee outside offer vice versa 
contractor payoffs usually negative pay having task handled 
contractee ir constraint states expected payoff contract expected payoff outside offer ssb lambda ae gamma lambda ae gamma ae gamma gamma ae gamma aed gamma bd similarly contractor ir constraint states expected payoff contract outside offer ssa lambda ae gamma gamma ad lambda ae gamma ae gamma gamma gamma gamma ae gamma gamma ae gamma gamma gamma games exist full commitment contract possible leveled commitment contract contractor want decommit gamma gamma gamma ae decommitment penalty chosen high surely decommit assuming bounded 
case contractee decommit ae gamma bounded contractee decommitment penalty chosen high surely decommit 
full commitment contracts subset leveled commitment ones 
reasoning holds contracts agents pay penalties decommit contracts agent pay penalty decommit 
full commitment contracts subset leveled commitment contracts better sense pareto efficiency social welfare 
follows exists ir full commitment contract exist ir leveled commitment contracts 
addition leveled commitment contracts worse full commitment ones games enable deal impossible full commitment contracts theorem enabling games games defined full commitment contract satisfies ir constraints leveled commitment contract 
proof theorem constructive uses example game 
game ir constraints satisfied wide range leveled commitment contracts full commitment contract 
leveled commitment contracts defined ae satisfy ir constraints 
values ae exist constraints satisfied 
proof theorem analyze contracts ae example 
values satisfy ir constraints 
qualitatively different cases 
case 
chance agent going decommit 
case ae chance contractor decommit may happen gamma gamma ae 
lambda ae ae ae gamma gamma ae gamma ae ae gamma gamma ae gamma 
lambda ae maximum possible chance contractee decommit 
occurs ae programmed model ir constraints equations case 
algebra tractable constant versions ir constraint equations assumed ae lambda loss generality 
corresponding decommitment penalties satisfy ir constraints plotted left 
furthermore boundaries programmed model need checked 
boundaries ae lambda plotted left 
constraint lambda satisfied case plotted 
summarize gray area left contracts ir agents agents decommit optimally self interest necessarily truthfully 
case contractor surely decommit 
ae contractor surely decommit best possible outside offer 
note arbitrarily high 
corresponding lambda ae ae ae gamma gamma ae gamma ae contractee decommits truthfully 
contractor ir constraint eq 
ae gamma ad ae gamma ae ad gamma rrr ir constraints satisfied contractee surely decommit ir constraints satisfied contractor surely constraints satisfied agent sir constraints contractor sir constraints contractee ir constraints contractor sir constraints contractee sir constraints contractor sir constraints 
decommitment penalties satisfy agents ir constraints example game 
right case agent decommit ae lambda ae 
middle case contractor decommit contractee ae lambda ae 
left case ae contractor surely decommit contractee 
ae equivalent gamma ae gamma false 
ae equivalent gamma ae delta gamma ae delta gamma ae gamma gamma delta gamma delta gamma gamma quadratic equation solution formula 
similarly contractee ir constraint eq 
ae gamma ad ae ae ad ae equivalent ae false 
ae equivalent ae gamma ad ae ae ad gamma gamma ae gamma ae delta ae ae delta approximately approximately quadratic equation solution formula 
violates ae 
put open region ae type contracts ir agents agents decommit optimally necessarily truthfully 
region colored gray right 
case contractee surely decommit 
high lambda ae contractee surely decommit 
contractor decommit gamma gamma gamma ae ae gamma words decommitting threshold lambda ae gamma contractor ir constraint lambda ae gamma ae gamma gamma gamma gamma ae gamma gamma ae gamma ae gamma gamma gamma ae gamma gamma ae gamma ae gamma gamma gamma ae gamma gamma ae gamma ae equivalent gamma ae gamma false 
ae equivalent ae gamma gamma gamma ae gamma gamma ae gamma gamma ae gamma ae gamma gamma gamma ae gamma delta gamma ae gamma approximately approximately quadratic equation solution formula 
violates ae 
similarly contractee ir constraint lambda ae gamma ae gamma gamma ae gamma ae ae gamma ae ae gamma ae gamma ae ae gamma ae gamma ae ae gamma ae equivalent ae false 
ae equivalent ae gamma ae gamma ae gamma quadratic equation solution formula 
open region lambda type contracts ir agents agents decommit optimally necessarily truthfully 
region colored gray middle 
addition enabling deals impossible full commitment contracts leveled commitment contracts increase efficiency deal full commitment contract possible reverse occur leveled commitment contracts subsume full commitment ones 
occurs chance contractor outside offer lower contractee expected outside offer chance contractee outside offer higher contractor expected outside offer 
theorem pareto efficiency improvement games game ir full commitment contract 
bounded bounded gamma 
bounded bounded game leveled commitment contract increases contractor expected payoff contractee expected payoff full commitment contract 
leveled commitment contract pareto superior ir 
follows conditions theorem full commitment contract pareto efficient 
dop games sections games agent expected payoff contract may depend agent possibly biased beliefs 
example contractee decision decommit depends belief fb contractor upcoming outside offer lambda ae ae ae gamma gamma fb ae gamma fb decommitting decision affects contractor expected payoff really contractor perceive differently ssa lambda ae gamma gamma ad lambda ae gamma ae gamma gamma gamma gamma ae gamma gamma ae simultaneous decommitting simultaneous decommitting games agents declare decommitment simultaneously 
decommitting time contractor knows outside offer contractee outside offer similarly contractee knows outside offer contractor outside offer alternative types leveled commitment contracts differ happens agents decommit 
agents pay decommitment penalties decommit 
second agent pay decommit 
presents games induced contract types 
game types discussed separately 
pay decommit section discusses simultaneous decommitting games protocol agents pay decommitting penalties decommit 
settings called games 
pb probability decommit contract null contract full commitment contract contract rf rf decommit decommitting game ae pb pb contractor contractee doesnot decommit contractor ae ae 
simultaneous decommit pay decommit game 
parenthesized payoffs represent simultaneous decommit pays decommit game 
dashed lines represent agents information sets 
decommitting contractor know contractee outside offer vice versa 
furthermore contractor decide decommitting observed contractee decommitting decision vice versa 
contractee decommits 
value variable depends ae contractor decommit pb delta gamma gamma gamma pb gamma gamma pb delta gamma gamma pb gamma ae pb equivalent 
ruled type contracts agents gets paid decommitting 
hand inequality equivalent ae gamma gamma def lambda ae lambda characterized decommitting threshold lambda contractor 
contractor outside offer lambda contractor best decommitting 
contractee decommits ifz lambda ae lambda gamma lambda ae lambda gamma gamma lambda ae lambda ae lambda ae lambda gamma lambda ae lambda equivalent 
ruled type contracts agents gets paid decommitting 
hand inequality equivalent ae br lambda def lambda ae lambda lambda ae lambda characterized decommitting threshold lambda contractee 
contractee outside offer lambda contractee best decommitting 
probability contractee decommit pb lambda ae lambda condition states contractor best response defined lambda contractee strategy defined lambda condition states contractee best response lambda contractor strategy defined lambda condition uses variable pb defined equation 
equations define nash equilibria decommitting game 
contractor ir constraint lambda ae lambda lambda ae lambda gamma gamma gamma lambda ae lambda gamma lambda ae lambda gamma lambda ae lambda gamma gamma gamma lambda ae lambda gamma ae gamma row corresponds contractee decommitting second corresponds contractee decommitting 
second integral row corresponds contractor decommitting third integral corresponds contractor decommitting 
logic contractee ir constraint lambda ae lambda lambda ae lambda gamma gamma lambda ae lambda gamma lambda ae lambda gamma lambda ae lambda gamma lambda ae lambda ae bounded contractor decommitment penalty chosen high contractor decommitment threshold lambda ae lambda lower case contractor surely decommit 
similarly bounded contractee decommitment penalty chosen high contractee decommitment threshold lambda ae lambda greater case contractee surely decommit 
full commitment contracts subset leveled commitment ones 
better sense pareto efficiency social welfare 
addition leveled commitment contracts worse full commitment ones theorem states positive result games enable increased efficiency deal impossible full commitment contracts 
theorem enabling games games defined full commitment contract satisfies ir constraints leveled commitment contract 
proof 
full commitment contract satisfies ir constraints require aef impossible 
analyze leveled commitment contract ae 
qualitatively different cases 
case 
chance agent going decommit 
lambda lambda nonzero probability agent decommit 
unique nash equilibrium plotted different values 
nash equilibrium decommitment thresholds lambda lambda differ truthful nash curve curve curve truthful decommitting curve nash 
nash equilibrium decommitment thresholds lambda lambda example game different values decommitment penalties nash equilibrium deviates truthful decommitting 
lambda lambda chance agent decommit 
ones 
exist nash equilibria proper range lambda lambda guaranteed nash equilibria satisfy agents ir constraints 
programmed model equations ir constraints 
algebra tractable constant versions equations assumed lambda lambda loss generality 
task check boundaries validity model 
boundaries lambda lambda plotted 
boundary lambda turns line 
exists boundary lambda lambda greater zero 
plotting validity boundaries model curves ir constraints held equality plotted fig 

agent ir constraint induced curves bound ir region 
third just root ir constraint sides curve ir constraint contractee ir contractee ir contractee ir contractor ir contractor ir surely decommit contractor decommit 
ir regions decommitting game 
gray areas qualitatively different regions contracts ir agents allow equilibrium decommitting game 
dark gray area agent decommit light gray areas agent decommit 
curves represent ir constraints validity constraints programmed model requires lambda lambda 
agents curve ir constraint just root constraint satisfied sides 
satisfied 
dark gray area represents values decommitment penalties validity constraints programmed model ir constraints satisfied 
words exists decommitment thresholds lambda lambda form nash equilibrium nonzero probability agent decommit agent higher expected payoff contract 
numeric example pick contract ae 
nash equilibrium decommitment thresholds lambda ss lambda ss 
contractor expected payoff approximately gamma gamma gamma contractee approximately 
agents expected payoffs higher contract contract ir agents 
suffices prove theorem 
types equilibria occur 
case contractor surely decommit 
lambda contractor surely decommit 
lambda ae lambda ae br lambda ae contractee decommits truthfully 
contractor ir constraint exactly case example game eq 

constraint proven equivalent 
similarly contractee ir constraint exactly game eq 

proven equivalent approximately 
open region lambda type contracts ir agents equilibrium 
region colored light gray 
case contractee surely decommit 
lambda contractee surely decommit pb 
lambda ae lambda ae gamma gamma pb ae gamma contractor decommits truthfully 
contractor ir constraint exactly case example game eq 

constraint proven equivalent approximately 
similarly contractee ir constraint game eq 

proven equivalent 
open region lambda type contracts ir agents equilibrium 
region colored light gray 
case trivial case 
contract agent surely decommit lambda lambda ir 
contract ir decommitting agent decommitment penalty zero 
decommitting agent gets payoff contract 
similarly agent gets payoff get contract 
contract ir agents barely increase agent payoff equivalent contract decommitment occurs payment transferred 
addition enabling deals impossible full commitment contracts leveled commitment contracts increase efficiency deal full commitment contract possible reverse occur leveled commitment contracts emulate full commitment ones 
occurs chance contractor outside offer lower contractee expected outside offer chance contractee outside offer higher contractor expected outside offer 
theorem pareto efficiency improvement games game ir full commitment contract 
bounded bounded gamma 
bounded bounded game leveled commitment contract increases contractor expected payoff contractee expected payoff full commitment contract 
leveled commitment contract pareto superior ir 
follows conditions theorem full commitment contract pareto efficient 
games games dop games agent expected payoff contract may depend agent possibly biased beliefs 
example contractee decision decommit depends belief fb contractor upcoming outside offer 
example contractee receives outside offer decommit acted truthfully 
contractee believes fb contractor get outside offer decommit contractee save decommitment penalty decommitting 
hand contractee decommitting decision affects contractor expected payoff case contractee decommits contractor payoff gamma gamma gamma case contractee decommit contractor payoff gamma ae gamma gamma dependencies agent preference order potential contracts may depend agent beliefs 
games asymmetric biased information agent may need agent beliefs order determine preference order contracts 
pays decommit section discusses simultaneous decommitting games protocol agent pay decommitting penalty agents decommit 
game contractor decommit pb delta gamma gamma pb gamma gamma pb delta gamma gamma pb gamma ae pb equivalent ruled type contracts agents gets paid decommitting 
hand inequality equivalent ae gamma gamma gamma def lambda ae lambda contractee decommits ifz lambda ae lambda gamma lambda ae lambda gamma lambda ae lambda ae lambda ae lambda gamma lambda ae lambda equivalent ruled type contracts agents gets paid decommitting 
hand inequality equivalent ae gamma lambda ae lambda gamma ar lambda ae lambda def lambda ae lambda lambda ae lambda probability contractee decommit pb lambda ae lambda condition states contractor best response defined lambda contractee strategy defined lambda condition states contractee best response lambda contractor strategy defined lambda condition uses variable pb defined equation 
equations define nash equilibria decommitting game 
contractor ir constraint lambda ae lambda lambda ae lambda gamma gamma lambda ae lambda gamma lambda ae lambda gamma lambda ae lambda gamma gamma gamma lambda ae lambda gamma ae gamma row corresponds contractee decommitting second corresponds contractee decommitting 
second integral row corresponds contractor decommitting third integral corresponds contractor decommitting 
logic contractee ir constraint lambda ae lambda lambda ae lambda gamma lambda ae lambda gamma lambda ae lambda gamma lambda ae lambda gamma lambda ae lambda ae full commitment contract efficient leveled commitment contract game 
bounded chosen high contractor surely decommit high contractee 
full commitment contracts subset leveled commitment ones 
enable deal 
addition leveled commitment contracts enable increased efficiency deal impossible full commitment contracts theorem enabling games exist games defined full commitment contract satisfies ir constraints leveled commitment contract 
proof 
full commitment contract satisfies ir constraints require aef impossible 
analyze leveled commitment contract ae 
qualitatively different cases 
case 
chance agent going decommit 
lambda lambda nonzero probability agent decommit 
unique nash equilibrium plotted different values 
note nash equilibrium decommitment thresholds lambda lambda really differ nash curve curve curve truthful decommitting curve nash 
nash equilibrium decommitment thresholds lambda lambda example game different values decommitment penalties nash equilibrium deviates truthful decommitting 
lambda lambda chance agent decommit 
truthful ones 
differ closer truthful ones protocol agents pay decommit 
shapes curves protocols differ significantly 
exist nash equilibria proper range lambda lambda nash equilibria necessarily satisfy agents ir constraints 
programmed model equations ir constraints 
algebra tractable constant versions equations assumed lambda lambda loss generality 
task check validity boundaries model 
boundaries lambda lambda lambda lambda plotted bold lines 
surely decommit surely decommit 
qualitatively different regions contracts ir agents allow equilibrium decommitting game 
bold lines validity constraints programmed model requires lambda lambda 
validity constraints slices may decommit region constraint satisfied sides line 
solid lines represent contractor ir constraint programmed model dashed lines represent contractee ir constraint 
agents curve constraint just root constraint satisfied sides 
curves ir constraints held equality plotted 
note agent ir constraint induced curves bound ir region 
third just root ir constraint sides curve ir constraint satisfied 
dark gray area represents values decommitment penalties validity constraints programmed model ir constraints satisfied 
words exist decommitment thresholds lambda lambda form nash equilibrium nonzero probability agent decommit agent higher expected payoff contract 
numeric example pick contract ae 
nash equilibrium decommitment thresholds lambda ss lambda ss 
contractor expected payoff approximately gamma gamma gamma contractee approximately 
agents expected payoffs higher contract contract ir agents 
suffices prove theorem 
types equilibria occur 
case contractor surely decommit 
lambda contractor surely decommit 
lambda ae lambda ae gamma lambda ae lambda gamma ar lambda ae lambda ae contractee decommits truthfully 
contractor contractee ir constraints exactly case example eq 
case example 
follows open region lambda type contracts ir agents equilibrium 
region colored light gray 
case contractee surely decommit 
lambda contractee surely decommit pb 
lambda ae lambda ae gamma gamma gamma pb ae gamma contractor decommits truthfully 
contractor contractee ir constraints exactly case example eq 
case example 
follows open region lambda type contracts ir agents equilibrium 
region colored light gray 
case trivial case 
case example 
addition enabling deals impossible games full commitment contracts leveled commitment contracts increase efficiency deal full commitment contract possible reverse occur theorem pareto efficiency improvement games game ir full commitment contract 
bounded bounded gamma 
bounded bounded game leveled commitment contract increases contractor expected payoff contractee expected payoff full commitment contract 
leveled commitment contract pareto superior ir 
follows conditions theorem full commitment contract pareto efficient 
games games dop games agent expected payoff contract may depend agent possibly biased beliefs 
example contractee decision decommit depends belief fb contractor upcoming outside offer 
example contractee receives outside offer decommit acted truthfully 
contractee believes fb contractor get outside offer decommit contractee save decommitment penalty decommitting 
hand contractee decommitting decision affects contractor expected payoff case contractee decommits contractor payoff gamma gamma case contractee decommit contractor payoff gamma ae gamma gamma dependencies agent preference order potential contracts may depend agent beliefs 
games biased asymmetric information agent may need agent beliefs order determine preference order contracts 
practical prescriptions system builders results canonical games suggest worthwhile contract enabling contract pareto improving perspective incorporate decommitment mechanism automated contracting protocols 
decommitment penalties best chosen agents dynamically contract time opposed statically protocol 
allows tuning penalties specific negotiation situations environmental uncertainties specific belief structures agents 
proposed decommitment mechanism allows agent decommit local reasoning negotiation necessary decommitment time 
contracts mechanism simpler traditional contingency contracts require worst case specification contract alternative obligations alternative worlds induced alternative realizations combinations events 
furthermore proposed decommitment method require event verification mechanism contingency contracts 
instance simultaneous decommitting game nash equilibrium decommitting strategies usually closer truthful ones protocol pays decommit fig 
protocol pay decommit fig 

agent opponent decommitment penalty approaches zero agent truthful protocol starts increasingly bias decommitment decisions 
suggests protocol practical systems 
minimizes number payment transfers require transfer decommit 
web multiple mutual contracts agents classical full commitment contracts induce negotiation focus consisting obligations contracts 
proposed leveled commitment protocol multiple foci agent involved contract swap focus decommitting contract paying decommitment penalty 
may happen swap beneficial agent decommit contract 
avoid loops decommitting practice disabled 
implemented choosing protocol specifies contract offer accepted agent decommits original offer void opposed staying valid original deadline may reached time decommitment 
agents explicitly contract hard specify monitor protocol contract identical content 
gives rise possibility equivalent useless decommit loops 
loops avoided mechanism decommitment penalties increase real time number domain events negotiation events 
allows low commitment negotiation focus moved joint search space making contracts meaningful level commitment 
increasing level commitment causes agents backtrack deeply negotiations save computation 
initially low commitment contracts mechanism facilitate linking deals 
contract single item beneficial combination contracts agents sandholm sandholm lesser 
explicit clustering issues contracts sandholm sandholm lesser agent agree initially low commitment contract anticipation contracts agent contract beneficial sandholm lesser 
contracts appear agent decommit 
similar way initially low commitment contracts mechanism facilitate contracts agents 
explicit multiagent contract protocols sandholm lesser multiagent contracts implemented agent agreeing initially low commitment contract anticipation contracts third parties contract beneficial sandholm lesser 
contracts appear agent decommit 
practical automated contracting settings agents bounded rational limited computation resources bound capability solve combinatorial problems sandholm lesser sandholm lesser sandholm lesser sandholm 
fact agent computation bounded induces uncertainty 
example value contract may probabilistically known agent contract time 
leveled commitment contracting protocol allows agent continue deliberation regarding value contract contract 
value turns lower expected agent decommit 
hand leveled commitment contracting protocol decommitment penalties increase quickly time may appropriate computationally limited agents agents need consider combinatorial number possible worlds alternative combinations occurred sandholm lesser 
marginal cost particular task may different alternative worlds tasks interact 
stages commitment mutual negotiations commitment offer means agent binds potential contract waiting agent accept reject offer 
party accepts parties bound contract 
accepting second party certain contract party commit sure 
commitment take place stage protocol contracts take place choice stage varied 
traconet system designed commitment took place bidding phase usual real world task awarded bidder take care price mentioned bid 
stage commitment take place 
conceptually announcement committal 
sent potential bidder time include deadline 
bidder doesn bid task set deadline announcer announce task set agent 
protocol bids awards committal 
theory arbitrary long protocols devised commitment take place point protocol 
choice commitment stage static protocol design decision agents decide dynamically 
example focused addressing scheme cnp implemented low utilization situations contractors announced tasks high utilization mode potential signaled availability bid receiving announcements smith van dyke parunak 
choice protocol characteristics environment 
alternatively choice negotiation separately negotiation begins 
advocate refined alternative agents dynamically choose stage commitment certain negotiation negotiation 
allows alternatives stage commitment negotiation strategy decision protocol design decision 
offered commitments specified contractor messages contractee messages fig 

richer negotiation protocol addition leveled commitment contracts commitment different stages advocate new features contracting protocols 
section discusses example protocol incorporates features 
specific protocol negotiation multiple agents contract negotiations leads agents 
contractor message 
negotiation identifier 
message identifier 
response message id 
sender 
receiver 
terminate negotiation 
alternative 
time valid 
bind partner decommit 
offer submission fee 
required response submission fee 
task set minimum specification tasks promised payment fn 
contractee contractor promised commitment fn 
contractee required commitment fn 

task set 
task set 
alternative alternative contractee message payment decommit message 
negotiation identifier 
negotiation id 
message identifier 
message id 
response message id 
accepted offer id 
sender 
acceptance message id 
receiver 
sender 
terminate negotiation 
receiver 
alternative 
message type 
time valid payment decommit 
bind partner decommit 
money transfer 
offer submission fee 
required response submission fee 
task set maximum specification tasks required payment fn 
contractee contractor required commitment fn 
contractee promised commitment fn 

task set 
task set 
alternative alternative 
contracting messages single negotiation 
describes message formats proposed new contracting protocol 
negotiation start contractor contractee message fig 

contractor message specifies exclusive alternative contracts contractor willing commit 
alternative tasks split disjoint contractor contractee contractor misses alternative contractee offer contractor accepts contractee accepts contractor decommits bind partner decommit field set contractee latest proposal new negotiation issues agents possible contractor decommits bind partner decommit field contractee latest proposal contractee decommits bind partner decommit field contractor latest proposal contractee proposes contractor proposes contractee terminates contractee misses alternative contractor offer contractor terminates contractee decommits bind partner decommit field set contractor latest proposal real world request outside negotiation protocol contractee tasks contract contractor payment sending message usual usual 
state transition diagram single negotiation 
task sets sender message order fields specific task set necessarily set tasks 
alternative semantics 
contractee agrees handle task sets manner satisfying minimum required task descriptions specify tasks constraints latest earliest handling time minimum handling quality contractee agrees commit task set level specified field contractor automatically committed paying amounts fields cancel deal task set paying contractee secure money transfer implemented cryptographically electronic credit cards electronic cash whinston kristol low low 
penalty 
contractor alternatives suggested 
contractee accept alternatives contractor 
fields functions time negotiation events domain events times events observable verifiable contractor contractee 
contractee accept alternatives contractor message sending contractee message task specifications meet minimal requirements payment functions meet required payment functions commitment functions contractee meet required commitment functions commitment functions contractor exceed contractor promised commitment 
contractor message accept alternatives contractee message analogously 
agent entirely terminate negotiation sending message negotiation identifier field terminate flag field set 
alternatively contractee send contractee message accepts contractor message satisfy requirements terminates negotiation 
message contractor accept terminate negotiation ad infinitum 
original cnp allow agent bid announcement decide bid 
contractor option award award tasks bids 
cooperative agents studied example sen sen 
bind partner decommit flag describes offer alternative stay valid original deadline field case contract agreed partner paying decommitment penalty 
protocol offers stay valid original specification deadline matter partner accepts rejects 
protocols due see section growing number pending commitments 
agent just counter proposed dotted lines fig 

allows add new offers share response field pending ones allow retraction old offers 
retraction problematic distributed system negotiation partner acceptance message may way agent sends retraction 
mechanism way overcoming problem lacking truthful abstractions global search space defined task sets resource sets agents negotiation systems consisting self interested agents 
messages protocol announcements declare tasks messages commitment specification sender 
early messages negotiation commitment specifications low partner accept occurs 
level stage commitment dynamically negotiated negotiation care tasks 
contract types task allocation negotiation terms search global task allocation space contracts viewed iterative refinement operators move single search focus task allocation 
assuming agent willing accept individually rational contract time contract operators enhance social welfare possible task allocation 
words task reallocation contracting type example traconet viewed hill climbing task allocation space height metric hill social welfare 
social welfare defined having absolute value global cost opposite sign 
section discusses new contract types contract operators global task allocation space task allocation negotiation clustering contracts section swap contracts section multiagent contracts section 
section shows combined contract type necessary sufficient reaching global task allocation optimum hill climbing algorithm sequence individually rational contracts finite number steps backtracking 
clustering contracts early cnp implementations tasks negotiated time 
insufficient general cost feasibility carrying task depends carrying tasks 
may local optima transfer single task agents enhances global solution transferring larger set tasks simultaneously 
shown small example just tasks agents say current task allocation agent tasks ta ft task tb 
say task handling costs follows ca ca ft ca ft ca ft cb cb ft cb ft cb ft 
current global cost 
moving increase global cost 
moving hand moving decrease global cost 
clustering contract profitable contract game fig 

agent tasks agent tasks 
clustering contract 
need larger transfers known centralized iterative refinement optimization lin kernighan waters generally ignored automated negotiation 
non automated allocation settings need clusters realized 
example federal communications commission auctions bandwidth restricted geographical areas bidders valuations auctioned items depend items awarded mcafee mcmillan 
example bidders want receive cluster awards allows establish nationwide coverage 
fcc auctions explicit clustering agents construct clusters individually auctioned items 
simultaneous ascending auction agent sees agents bids 
agents see clusters get bid accordingly 
auction carried stages stage quantitative activity rule 
disables bidder staying bidding moment knows bids 
possible agents want bid front 
auction terminated agent wanted raise bids 
auction designers supported profitable clustering allowing agents withdraw bid agent get cluster 
withdrawing allowed withdrawing agent guaranteed bid price 
specifically item opened new highest bid lower old withdrawing agent pay difference 
traconet extended cnp handle task interactions having announcer cluster tasks sets negotiated atomically 
alternatively bidder done clustering 
protocol generalizes allowing party clustering fig 
stage protocol 
general cluster encompass number tasks 
solution task allocation called optimal beneficial clustering contract tasks agents 
necessary sufficient condition global optimality 
say loss generality 
optimality imply optimality 
surprisingly optimality imply optimality 
traconet clustering tasks announcement 
interesting question choose clusters 
traconet supports policies doing 
task clusters optimality reached task clusters optimality task clusters optimality task clusters optimality 
continues optimality reached 
task clusters optimality 
process repeats 
stops optimality reached 
process stopped part way 
schedules 
second way choose clustering interleave task task task contracts choice domain independent heuristics 
example traconet cluster tasks announcement marginal cost smaller constant times sum marginal costs separately 
similar domain independent heuristics implemented task contracts 
domain specific clustering heuristics implemented clustering occurred deliveries geographically close 
expected clustering contracts proved useful small artificially generated problem instances sense better global solution reached pure task contracts 
swap contracts task set size transferring set agent enhances global solution 
may beneficial swap tasks agent task second second task agent 
need swap contracts demonstrated small example just tasks agents say current task allocation agent tasks ta ft task tb ft 
say task handling costs follows ca ca ft ca ft ca ft cb cb ft cb ft cb ft 
current global cost 
moving increase global cost 
moving hand moving simultaneously decrease global cost 
swap contract profitable contract game fig 

agent tasks agent tasks 
swap contract 
interaction protocols needed benevolent cooperative agents needed self interested agents differ significantly 
cooperative agents assumed take care tasks compensation beneficial society agents 
self interested agents need compensation take care agent task 
compensation organized barter trade agent takes care agent tasks agent takes care agent tasks 
barter trades benefit agents exist profitable community agents move task agent 
secondly identification beneficial barter exchanges nontrivial especially distributed setting 
finer resolution cooperation self motivated agents achieved monetary compensation mechanism agent pays agent take care tasks 
need swaps shows payment exchanges replace barter exchanges 
needed monetary exchange method allows infinitely divisible side payments linking mechanism allows swapping tasks atomically agents 
swaps explicitly implemented negotiation protocol allowing task sets alternative fig 
specify tasks contract specify tasks contract 
task sets added implement swaps minimum field changed maximum vice versa 
field promised payment fn 
contractee changed required payment fn 
contractee required payment fn 
contractee changed promised payment fn 
contractee 
multiagent contracts negotiations may reached local optimum respect mutual contract operators cluster contracts swap contracts size solution enhancements possible tasks transferred agents 
decentralized multiagent contracts implemented example circulating contract message parties agreeing contract valid agent signs 
need multiagent contracts demonstrated small example just tasks agents say current task allocation agent tasks ta ft task tb ft tasks tc ft 
say task handling costs agent follows ca ca ft ca ft ca ft fox studied role grouping buy sell bids cascades may involve multiple agents fox 
setting simpler dissertation value contract agent depend ones agent bids get accepted 
hand settings dissertation agent valuation contract depends significantly ones agent bids get accepted 
algorithms fox differ dissertation allow contract 
search perspective means allow backtracking 
heuristic algorithms choosing order execute possible contracts 
order important contract preclude involve allocation resource 
backtracking contract undone allow contract beneficial 
heuristics focus handling constrained requests 
guarantee globally optimal solution reached 
algorithms distributed involve centralized processing regarding global situation 
ca ft ca ft ca ft ca ft agent cb cb ft cb ft cb ft cb ft cb ft cb ft cb ft 
say costs agent cc cc ft cc ft cc ft cc ft cc ft cc ft cc ft 
current global cost 
cluster contracts task impossible agent task 
possible task cluster contracts increase global cost 
possible swaps increase global cost 
cluster contract swap contract profitable 
moving decrease global cost 
multiagent contract profitable contract game fig 

agent tasks agent tasks agent tasks 
multiagent contract 
necessity sufficiency applied contract types sufficient reaching global optimum 
example section shows clustering contracts sufficient example section shows swap contracts sufficient 
example section shows multiagent contracts task agent sufficient 
similarly contract types sufficient pairs 
example section shows swaps multiagent contracts sufficient 
example section shows clustering contracts swaps sufficient 
example section shows clustering contracts multiagent contracts mutual swap agents sufficient 
applied operator time contract operators form sufficient set reaching global task allocation optimum 
shown counterexample profitable contract agents swap tasks 
contract need combine clustering swaps 
examples exist combinations contract types 
define new contract type clustering swap multiagent contract combines characteristics previously introduced contract types contract type 
csm contract lists possible pair agents simultaneously ffl tasks transferred agent ffl tasks transferred agent ffl payment transferred agents 
theorem states csm contracts sufficient reaching global task allocation optimum finite number contracts 
result holds sequence individually rational csm contracts hill climbing algorithm uses csm contracts iterative refinement search operators task allocation space 
means perspectives social welfare maximization individual rationality necessarily perspective local payoff maximization agents accept individually rational contracts offered 
need wait profitable ones need worry current contract may profitable contract unprofitable 
need accept contracts individually rational anticipation contracts combination beneficial 
furthermore hill climbing algorithms need backtrack 
theorem finite number agents tasks 
agents pick csm contracts hill climbing algorithm finds global task allocation optimum finite number steps backtracking 
theorem gives powerful tool small problem instances number possible task allocations relatively small 
hand large problem instances number contracts globally optimal task allocation reached may impractically large albeit finite 
settings anytime character contracting scheme important 
attempt reach global optimum compute long time solution ready 
iterative refinement contracting methods guarantee furthermore guarantee solution agent worse initial solution agent worked individually tasks 
example large scale real world distributed vehicle routing problem instance traconet reached local optimum just basic task contracts multiple hours negotiation time unix machines 
equivalent complex contract clustering swap multiagent contract csm contract accomplished sequence basic task contracts agents willing take risks 
task contract individually beneficial agents sequentially small contracts sum large beneficial 
early sequence global solution degrades contracts enhance 
making early commitments agents risk permanent loss case agent agree contracts needed sequence contracts profitable 
leveled commitment protocol decreases risks preferred allowing agents break commitments paying penalty 
contracts sequence happen agent decommit earlier ones 
decommitment penalty function explicitly conditioned acceptance contracts may specify low commitment short time agent expects remaining contracts sequence 
contracting implications limited computation interactions self interested agents widely studied microeconomics kreps varian raiffa dai rosenschein zlotkin ephrati rosenschein kraus durfee perfect rationality agents usually assumed deduction optimal reasoning contingencies recursive modeling agents 
perfect rationality implies agents compute marginal costs tasks exactly immediately untrue practical situations 
agent bounded rational computation resources costly bounded environment keeps changing new tasks arrive bounded amount time part solution garvey lesser sandholm lesser zilberstein simon 
contracting agents additional real time pressures ffl acceptance message sent deadline field negotiation terminates fig 

negotiation terminates agent new negotiation issues agent commitment 
ffl sending outgoing offer late may cause receiving agent contract tasks agent negotiated earlier disabling contract offer meets deadline 
case deadline offer acceptance message opposed partner pay decommitment penalty declared 
ffl fields functions response time fig 

agent may get paid handling tasks pay having tasks handled required commit strongly receive weaker commitment negotiation partner response postponed 
ffl agent cost breaking commitments contract may increase time 
local deliberation scheduling problem setup leads host local deliberation scheduling issues 
agent decide computation allocate refine marginal cost estimate certain task set 
bounded cpu time allocated agent may win contract reply sent time remains refining marginal costs task sets 
little time allocated agent may contract concerning task set 
multiple negotiations allowed simultaneously agent decide sets tasks offered potentially offered bounded computation focused 
may want ignore contracting possibilities order focus deliberation time compute marginal costs task sets selected potential contracts 
tradeoff getting exact marginal cost estimates able engage larger number negotiations 
agent decide sequence allocates deliberation different task sets 
basic intuition sequence chosen urgent task sets considered 
greedy heuristic adequate sequencing problem hard combinatorial problem 
engaging multiple simultaneous negotiations original cnp consider agent risk attitude committed activities may able honor honoring may turn 
protocol agent take risk making offers acceptance earlier committal offers pending 
contracting pending commitments speeds negotiations agent wait results earlier commitments carrying negotiations 
discuss formalize risk question 
look award contracting protocol bids awards full commitment announcements commitment traconet 
discuss risk bidding 
denote arbitrary bid set tasks bid set unsettled bids sent agent previously 
define set possible bids awarded agent awarded set divided possibly overlapping subsets idea agent sent announcements overlap tasks award tasks announcements 
specifically denote set maximally sized possible sets bids get awarded agent formally tj bidder current set tasks 
mentioned section agent bids marginal cost computed follows cj tj gamma cj tj cj cost optimal routing solution tasks vehicles agent marginal cost calculation assumes agent currently pending bids get accepted 
hand sure current bid beneficial alternative worlds induced different combinations acceptances pending bids bidder compute marginal cost follows max cj tj gamma cj tj expensive compute number alternative worlds induced different combinations acceptances pending bids exponential pending bids 
trade computational complexity monetary risk bidder approximate marginal cost 
incurs risk 
combination acceptances pending bids current bid may bidder may accept contract loss 
way trade computational complexity monetary risk approximate marginal cost assuming pending bids get accepted happen argument announcements overlap tasks cj tj gamma cj tj note may greater vehicle routing problem economies scale scale 
hand domain definition 
faster compute constant pending bids requires computing union tasks pending bids avoiding duplicates 
log total number tasks mentioned bids 
gives better approximation marginal cost bids seldom awarded agent 
usually case network agents 
risk seeking approach assume best combination pending bids gets accepted 
corresponds changing max operator min operator 
traconet computational complexity traded risk concept marginal cost estimation choice static advanced agents risk strategy negotiation risk dynamically explicitly traded added computation 
addition approximating marginal cost feasibility check done vein sure bidder feasible necessarily profitable solution pending bids get accepted domains feasibility check restricts bidding bidder choose profitable combination possible combinations beneficial bids send 
original cnp agent multiple bids concerning different contracts pending concurrently order speed operation system 
followed approach reason negotiations contract time allow precise marginal cost calculation bidding 
bid allowed pending agent time 
words trading computational complexity monetary risk necessary 
similar risk considerations apply agent considering awarding task set bidder 
awarding phase manager chance check awarding beneficial accept bid 
deciding awarding beneficial agent consider unsettled bids sent 
awarding bid beneficial bid price lower current marginal cost task set marginal cost cost removing tasks agent local routing solution 
bidding phase chance agent pending cj intractable compute approximated directly simulating addition task set current non optimal routing solution 
vehicle routing problem addition tasks local solution infeasible removal tasks 
bids include tasks agent currently awarding 
bidding situation set divided possibly overlapping subsets idea agent sent announcements overlap tasks award tasks announcements 
specifically denote set maximally sized possible sets bids get awarded agent formally current set tasks 
mentioned section agent bids marginal cost computed follows bjt ci gamma ci ci cost optimal routing solution tasks vehicles agent marginal cost calculation assumes agent currently pending bids get accepted 
hand sure current award beneficial alternative worlds induced different combinations acceptances pending bids compute marginal cost follows bjt min ci gamma ci expensive compute number alternative worlds induced different combinations acceptances pending bids exponential pending bids 
trade computational complexity monetary risk approximate marginal cost bjt 
incurs risk 
combination acceptances pending bids current award may turn 
way trade computational complexity monetary risk approximate marginal cost assuming pending bids get risk seeking approach assume best combination pending bids gets accepted 
corresponds changing min operator max operator 
accepted happen argument announcements overlap tasks bjt ci gamma ci note bjt bjt may greater vehicle routing problem economies scale scale 
hand bjt bjt domain 
faster compute bjt bjt constant pending bids requires computing union tasks pending bids avoiding duplicates 
log total number tasks mentioned bids 
gives better approximation marginal cost bids seldom awarded agent 
usually case network agents 
traconet computational complexity traded risk bjt concept marginal cost estimation choice static advanced agents risk strategy negotiation risk dynamically explicitly traded added computation 
sending bid sending award agent need feasibility check 
removal awarded tasks local routing solution task combination infeasible feasible sending award 
basic check profitability may order awarding important seldom case domain practice 
awarding task set may disable beneficial awarding 
usually number received bids local announce bid award cycle small try combinations possible awards carry profitable 
cj intractable compute bjt approximated directly removal task set current non optimal routing solution 
agent sends awards bids pending bjt bjt bjt 
words trading computational complexity monetary risk necessary 
compares results allowing bidding awarding bids pend versus bidding awarding bids pend 
case left column agents participate negotiations local announce bid award loop case right column 
hand case local award loop takes time due lower computational complexity local loops fit hours real time experiment case 
furthermore case cost decrease guaranteed monotonic case agent may take occasional awards due risk bjt approximate marginal cost 
enlarging bidding awarding context agent know bidders show bids 
profitable bid corresponds swap iterative refinement algorithm global task allocation search space 
waiting bids corresponds best swap algorithm global search space 
undoing swap better swap possible leveled commitment protocol 
general tradeoff accepting counter proposing early waiting ffl better offer may received 
ffl waiting simultaneously valid offers enables agent identify accept ones having options available decision point enables agent informed decisions 
driven kilometers cost award risks pending bids risks pending bids agent agent agent agent agent agent agent agent agent agent 
safe vs risky bidding awarding example runs 
hour runs left column right column unix machines real data dispatch centers shown 
category axis shows number local announce bid award cycles agent 
gray curve shows total length agent truck routes 
black curve shows local cost agent takes account payments contractor contractee carrying tasks 
ffl accepting early simplifies costly marginal cost computations fewer options consider 
option corresponds item power set offers agent accept 
ffl waiting agent may opportunities due making related contracts 
distributed asynchronous implementation automated contracting research done carried centralized simulations distributed problem solving smith smith smith davis smith davis smith smith davis sen sen 
approaches ignored important problems relating concurrency asynchronous message passing arise truly distributed implementations automated contracting systems 
fact traconet system truly distributed uses asynchronous message passing helped uncover previously unaddressed implementation questions automated contracting 
sections discuss problems potential solutions 
avoiding message congestion saturation message congestion major problem automated contracting sandholm smith van dyke parunak 
agent takes long time process large number received messages messages time arrive high risk agent saturated 
means spend deliberation time messages time agent able answer outdated lead contracts 
may happen agents bid awarded contract earlier agent awarded contract deadline announcement passed 
previous attempts solve problem include focused addressing smith audience restrictions van dyke parunak sandholm 
focused addressing means highly constrained situations agents free resources announce availability constrained situations agents tasks announce tasks 
avoids announcing tasks highly constrained situations announcements seldom lead results 
constrained environments resources plentiful compared tasks announcing tasks focuses negotiations fewer messages 
audience restrictions mean agent announce subset agents supposedly potential 
focused addressing audience restrictions imposed agent central designer agent society 
necessarily viable open systems self interested agents 
agent send message beneficial saturate agents 
flat rate media internet agent prefers sending non zero probability accepting 
society agents better communication restricted sending agent sends long expected utility message exceeds decrease utility agent caused effect message 
defines tragedy commons player prisoners dilemma turner hardin 
tragedy occurs mainly low commitment messages usually early negotiation having multiple high commitment offers simultaneously increases agent negotiation risk sec 
computation costs sec 
self interested agent avoid 
way resolve tragedy communication charge 
changes incentive structure self interested agent send fewer messages 
way mutual monitoring agent monitor certain agent sends low commitment messages eager senders punished 
mutual monitoring audience restrictions implemented agent receives announcement appropriate audience directly identify sender 
problem mutual monitoring mechanisms required motivate agents monitor punish 
third way proposed contracting protocol section allows agent determine offer field processing fee accepting agent submit response field response processed 
implements self selecting dynamic audience restriction viable self interested agents 
addition potential remedies changing contracting protocol traconet experiments led development practical methods incorporated agent local strategy order reduce message congestion 
methods concert agent self interest help agent avoid saturation locally 
example announcer bidder structured separate components agent software architecture local program control loops order 
triggered reads appropriate messages bidder reads announcements reads bids arrived far 
read messages arrive execution 
prevents agent getting stuck infinite period time particular stage large numbers messages arriving 
type local computation scheduling agents got saturated announcements experimental runs agents receiving announcements faster pace process 
problem occurred announcements domain number far exceeds number messages 
reason congested agents keep pace time handle announcement increased number previously sent unsettled bids mainly feasibility check discussed section 
announcements agent received bids able slowed bidding process announcements received 
congestion problem completely solved setting making bidder consider announcements newer certain time limit 
sensible bids older announcements probably get negotiations concerning announcements 
bidder linear pass received announcements ignores ones older certain time limit 
theoretically chance linear pass takes long responses late vain 
practice happened system 
terminating iterative refinement negotiations knowing terminate distributed search difficult durfee lesser durfee lesser especially distributed iterative refinement algorithms sandholm systematic slow backtracking scheme 
traconet termination heuristic distributed iterative refinement agent stops negotiating contracts certain fixed number negotiation iterations 
developed exact termination protocol iterative refinement negotiations 
cooperative exactly computing agents guarantees negotiations exactly local cost minimum task allocation space reached respect clustering contracts agent potential local refinement operators 
protocol reach local optimality respect desired set cluster contracts optimality optimality optimality assume agents knowledge tasks 
idea agents inform situations tried possible local search operators announced possible respect possible restriction number tasks announcement task sets success 
agent sent status information agents gets award tasks allocated contracting domain event new task environment resource status change breakdown retracts status sending message agents 
agent status worth continue announcing bidding agents may task allocation may change 
may allow agent accept proposed contract accepted earlier 
agents simultaneously local optimum reached negotiations terminated new domain events occur new agents log negotiation net 
termination protocol appropriate domains relatively little domain volatility new tasks changes resource status 
high domain volatility local optimum reached negotiations take long time comparison domain changes general domain change redefines set local optima 
method extended swap contracts multiagent contracts combinatorially explosive number agents 
agent posting status subgroup globally post status stating possible contracts desired type tried subgroup success subgroups status optimum desired type reached 
computationally limited cooperative agents basic termination method clustering contracts may terminate negotiations local optimum reached 
example agent may omit reacting announcement order allocate time process messages 
announcing agent think receiver announcement bid possibility beneficial contract 
may lead termination negotiations agents erroneously believe local optimum reached 
termination protocol fails guarantee local optimum terminate rational self interested agents 
agent may bid due strategic manipulation order know operators tried subgroup level joint knowledge subgroup tasks need formed 
marginal cost calculations 
agent infer required amount information agent decision bid 
secondly cost associated sending status message agent self interest 
replies vs timeouts field describes long offer alternative valid 
negotiation partner answered time sender message gets alternative 
alternative strict deadlines send messages field function time response similarly fields 
allows contractor describe payment decreases acceptance contractor message postponed 
similarly allows contractee specify required payments increase acceptance contractee message postponed 
motivates negotiation partner respond quickly force strict deadline inefficiently constrain agent local deliberation scheduling 
strict deadline mechanism time dependent payment scheme require sending time message verified parties 
alternative automatic decommitment deadline negotiation partner send negative reply negotiation termination message deadline 
forced response messages viable self interested agents agent decided accept necessarily reason send reply 
sending reply messages negative cases allows offering agent decommit validity time offer ends 
frees agent considering effects possible acceptance offer marginal costs task sets agent negotiating 
saved computation negotiate faster contracts 
agent considering sending negative reply may want send cases offering agent negotiating agent cases offering agent agent competing negotiations 
avoid speculation focus time protocols discussed opposed ones require replies 
chapter summary chapter automated contracting extensions contract net protocol allow self interested computationally limited agents 
setting agents reallocate tasks dynamically constructed charges 
scheme profitable global task allocation reached initial executing centralized task allocation algorithm 
setting analysis general realistic task allocation settings analyzed multiagent systems literature economies scale 
original contract net scheme enhanced introducing formal model making bidding awarding decisions 
decisions entirely agent local marginal cost calculations 
combinatorial problems vehicle routing calculations intractable approximation algorithms 
contract measured respect actual non optimal routing solution implemented optimal routing solution intractable compute 
truly distributed implementation ideas agent runs unix process communicate asynchronously network 
previous contract net implementations centralized simulations 
scheme leads distributed anytime task allocation algorithm terminated time guaranteed feasible solution ready worse agent initial routing solution 
shown distributed vehicle routing domain real vehicle delivery order data dispatch centers technology possibility scale large scale real world instances combinatorial problems 
section decommitment mechanism automated contracting protocols allows agents accommodate events profitably traditional full commitment contracts 
contract specifies decommitment penalty agents involved 
decommit agent just pays penalty agent 
mechanism better suited complex computerized contracting settings contingency contracts potentially combinatorial hard anticipate contingencies need considered conditioned event verification mechanism necessary decommitting decided local ex post deliberation 
method analyzed normative approach protocol strategy self interested payoff maximizing agent best choosing social outcomes follow 
game theoretic analysis decommitting games handled possibility agents decommit agent tries avoid decommitment penalty case believes high probability freed contract obligations due agent decommitting 
analysis serves normative tool agents decide contracts accept individual rationality 
games leveled commitment contracts superset full commitment ones 
emulated setting decommitment penalties sufficiently high 
full commitment protocols better leveled commitment ones sense pareto efficiency social welfare 
enable deal impossible individual rationality leveled commitment contract 
game types opportunities outstanding outside offers void contracting decommitting time game types dop instances new protocol enables contracts impossible individually rational agents full commitment contracts 
game types leveled commitment contracts improve agent expected payoff full commitment contract long chance contractor outside offer lower expected value contractee chance contractee outside offer higher expected value contractor 
obviously construct game instances null deal profitable agents contract leveled commitment individually rational agents 
game agent loses opportunity outstanding outside offer agreeing contract leveled commitment contract enable deal pareto improve deal full commitment contract agent fallback payoff sufficiently high 
dop games agent outside offer involves uncertainty agent certain outside offer prefers decommit contract originally individually rational 
agent may want decommit 
games agent payoff contract unaffected agent beliefs 
preference order contracts unaffected agent possibly biased beliefs 
follows agent need negotiation partner beliefs agent incur loss due agent erroneous beliefs 
hand games agents outside offers involve uncertainty agent payoff contract may depend negotiation partner possibly biased beliefs affect partner decommitting decision 
section different stages commitment discussed 
shown commitment occur stage stage negotiated item 
need fixed protocol 
section example protocol allows addition allowing types flexibility alternative offers section showed classical contracts task time insufficient reach globally optimal task allocation local optima assuming agents individually rational contracts 
new contract types overcome problem clustering swaps multiagent contracts 
insufficient applied pairs separately 
hand types combined new atomic contract type csm contract 
theorem showed agents pick csm contracts hill climbing algorithm finds global task allocation optimum finite number steps backtracking 
means perspectives social welfare maximization individual rationality necessarily perspective local payoff maximization agents accept individually rational contracts offered 
need wait profitable ones need worry current contract may profitable contract unprofitable 
need accept contracts individually rational anticipation contracts combination beneficial 
result powerful small problem instances large instances number contracts globally optimal task allocation reached may great carried practice albeit finite 
larger problem instances guaranteed anytime property important 
section discussed implications agents computational limitations contracting 
agent computation bounded real negotiation environment dynamic agents computation costly agent explicitly trade computation quality cost stems computation 
real time pressures identified specific contracting settings 
argued agent needs decide task sets focus deliberation order 
issue engaging multiple negotiations simultaneously discussed 
agent bids awards older bids pending current bid award may turn world materializes combination acceptances pending bids 
marginal cost calculations formalized pessimistically assume worst combination gets accepted 
type calculation agent local cost guaranteed decrease monotonically 
opportunistic approximation assumes pending bids get accepted feasibility check ensure feasible solution reached locally pending bids get accepted 
approximation faster compute exponentially alternative worlds need considered agent may occasionally contracts 
tradeoff computational complexity monetary risk 
marginal cost approximation formalized assumes pending bids get accepted 
complexity methods 
alternatively agent refuse bid award previous bids pending 
case marginal cost calculated risk free considering alternative worlds 
hand agent participate simultaneous negotiations may lose opportunities 
hand types agents negotiation take time local deliberation faster 
distributed vehicle routing experiments showed bidding awarding previous bids pend opportunistic pricing leads contracts practice 
hand experiments confirm bidding awarding previous bids pend leads monotonic decrease local cost 
methods best terms decreasing local cost depends problem problem instances set duration valid bidding window interleaving asynchronous messages happens occur 
experiments inconclusive regarding question 
section concluded discussion contracting implications limited computation presenting tradeoffs agent faces deciding bid award early wait 
section discussed distributed asynchronous implementation automated contracting 
message congestion agent saturation addressed 
classical solution approaches focused addressing audience restrictions viable self interested agents inherent tragedy commons agent self interested care saturation 
protocol related solutions discussed communication charges mutual monitoring processing fees 
problem solved incorporating certain policies agent local strategy 
policies concert agent self interest need externally imposed 
local strategies completely solved congestion saturation problems experiments included reading incoming messages batches ignoring announcements older time limit 
section negotiation termination method iterative task reallocation contracting 
termination problem considered difficult previous 
method terminates negotiations local optimum reached respect possibly restricted set clustering contracts 
assume common knowledge tasks 
method extended swaps multiagent contracts 
hand method guaranteed agents cooperative agents exactly compute marginal costs 
section discussed role feasibility replies timeouts implementing automated contracting 
coalition formation self interested real world parties save costs coordinating activities parties 
view situation agents coordinating actions computational real world coalition coalitions 
motivation coalition formation agents related research thoroughly discussed section repeated 
chapter discusses new contributions 
treatment assumes familiarity concepts sections 
coalition formation includes activities discussed section coalition structure generation solving optimization problem coalition dividing value cost coalition member agents 
contracting setting chapter activities intermixed conceptually temporally 
agents contract agent sense agents large coalition 
second solution joint task allocation problem done iteratively agent maintains local solution 
third payoff distribution occurs iteration task allocation agents 
hand chapter analyzes activities conceptually separate 
state art coalition formation extended incorporating explicit quantitative normative model computational limitations 
computation unit cost algorithm rationality limits problem hard instance large unrealistic assume solved deliberation costs 
chapter dissertation adopts model bounded rationality agent pay computational resources cpu cycles uses deliberation 
fixed computation cost ccomp cpu time unit assumed domain cost associated coalition denoted cs rs depends decreases allocated computation resources rs fig 

example vehicle routing problem domain cost sum lengths vehicles routes 
functions cs rs viewed performance profiles problem solving algorithm 
decide cpu time allocate computation 
model bounded rationality value coalition bounded rational br agents defined 
coalition minimizes sum solution cost domain cost computation cost vs ccomp gamma minr cs rs ccomp delta rs coalition value decreases cpu time unit cost ccomp increases fig 

model incorporates second form bounded rationality base algorithm may incomplete find optimal solution 
complete br value coalition ccomp equals rational value vs 
bounded rational value coalition determined factors ffl domain problem tasks resources agents 
rational agents determining factor 
ffl execution architecture problem solving algorithm run 
specifically architecture determines unit cost computation ccomp 
practice cpu time bought supercomputers 
similarly developing infrastructure remotely executing agents provides equivalent setting 
example telescript general magic remotely executing agents pay cpu time owner host machine 
dissertation market cpu time assumed large demand agents studying impact price cpu time unit 
assumed price common agents corresponds open cpu cycle market 
chapter coalition formation min operators due familiarity strictly speaking value min operator may undefined cs rs need continuous 
precise inf operators 
ffl problem solving algorithm 
restrictive assumptions effectively algorithm uses execution architecture 
realistic practise hard construct algorithms optimally sense architecture 
rs cs rs vs ccomp ccomp 
example experiment vehicle routing domain agents 
left performance profiles solution cost function allocated computation resources 
curves flat algorithm reached local optimum 
right br coalition value function computation unit cost 
value coalition negative cost positive 
curves flat ccomp high worthwhile take iterative refinement steps initial solutions computation requirements assumed negligible 
conceptually agents design time algorithms garvey lesser zilberstein garvey lesser agent decided cpu time rs allocate computation design algorithm find solution cost cs rs 
design time framework anytime framework sandholm lesser dean boddy boddy dean horvitz zilberstein devise theory self interested agents possibility design algorithms time accounted 
deterministic performance profiles desired computation time allocation solution quality design time algorithm constructed performs worse interruptible anytime algorithm 
assume performance profiles exactly predict solution cost attained cpu time allocation 
relaxed assumption base level algorithm optimal complete costless assume meta level deliberation controller optimal exact costless 
assuming optimality meta level realistic assuming optimality base level match reality exactly 
practice uncertainty performance profile meta level exact secondly performance profile depends features problem instance computing mapping instance performance profile sandholm lesser may take considerable time making meta level costly 
limit base algorithm run meta level determine achieve time setting 
assuming optimal meta level enables analyzing bounded rationality base level isolation uncertainty performance profiles 
allows sidestep problem having meta meta level controlling meta level meta meta meta level controlling meta meta level ad infinitum 
coalition formation chapter dissertation assume problem instances tasks resources agents common knowledge 
somewhat unrealistic open environments large number agents 
practice necessary learn agents characteristics previous encounters 
alternatively agents explicitly declare tasks resources may lie order gain 
rosenschein zlotkin rosenschein performance profiles probabilistically known anytime algorithms may desirable due flexibility respect termination time 
general optimal meta reasoning remaining part probabilistic performance profile conditioned algorithm performance problem instance previous cpu time steps sandholm lesser zilberstein 
zlotkin analyze rational agents motivated declare truthfully 
unfortunately assumes agents optimally solve exponentially complete problems computation costs 
assumptions cases truth telling achieved see section 
effect bounded rationality truthful revelation unknown 
relaxed section assume agents solve combinatorial optimization problems equally common knowledge 
coalition problem setting cpu time cost solution potentially generated agent 
agents need generate solutions quality 
shared deterministic performance profiles agent knows value vs ccomp potential coalition front 
coalition formation take place computation 
collusion coalition computes solution optimal amount cpu time rs defined equation 
model rationality bounded cpu time cost costs agent nt cpu time units costs agents units 
best coalition optimization problem solved single agent 
trivially true agent simulate distributed problem solving agents time local algorithm nt 
conversely possible due redundancy agents solving problem time reach solution quality agent nt reach 
computing agent arbitrarily chosen coalition coalition pays agent true cost computing 
cost domain solution cost contribute vs ccomp divided agents coalition 
social welfare maximizing coalition structure outcome game analyzed respect social welfare defined sum agents payoffs section 
payoff agent gets called xi 
sum agents xi equal sum values coalitions coalition structure cs formed wealth generated wealth disappears 
bounded rational br agents coalition values incorporate computation costs 
concepts superadditivity subadditivity discussed section implications social welfare maximizing coalition structure 
new concept br agents analogous superadditivity rational agents 
game bounded rational superadditive brsup best value coalition reach computation cost plus best value coalition reach computation cost greater best value coalition reach composite coalition computation cost definition game bounded rational superadditive brsup computation unit cost ccomp vs ccomp vs ccomp vt ccomp brsup game bounded rational grand coalition game fig 

games br agents best social welfare viewpoint working forming grand coalition cs lambda fag 
exist br grand coalition games brsup grand coalition may optimal coalition structure local beneficial 
br superadditivity coincide superadditivity 
general ccomp game superadditive brsup fig 

non brsup games br subadditive fig 
definition game bounded rational subadditive brsub computation unit cost ccomp vs ccomp vs ccomp vt ccomp 
game br subadditive agents best colluding cs lambda ffa fa 
games brsup brsub normal form game state oriented domain characteristic function game cfg superadditive subadditive task oriented domain tod subadditive tod concave tod modular ae br weak brc ae br subadditive br superadditive lh worth oriented domain lh br game grand coalition game csr br grand cs lg lg 
venn diagram negotiation domains 
normal lines show classification rational agents 
bold lines show new classification br agents 
dotted lines show rational agent classification rosenschein zlotkin section 
subadditive mean agent cost handling tasks subadditive tasks 
subadditive refer coalition value functions subadditive agents 
reflect fact allow side payments 
optimal coalition structure varies coalition structures may equally respect social welfare 
denote best coalition structures cs lambda rest section analyzes relationship shape performance profiles class game 
specifically question types performance profiles game brsup brsub computation unit costs 
agents types performance profiles know optimal coalition structure irrespective execution platform running 
br superadditivity depends performance profiles unit cost computation 
theorem states natural condition performance profiles 
condition holds game brsup ccomp 
theorem brsup sufficient condition 
rs rt cs rs rt cs rs ct rt game brsup ccomp 
condition states domain cost coalition allocating certain amount rs computation plus domain cost coalition allocating certain amount rt computation domain cost coalitions combined allocating rs rt achievable theory worst case algorithm allocate rs problem problem rt separately 
large coalition difficult intelligently guess efficient decomposition type 
sure br superadditivity algorithm need solve agent problem separately ensuring superadditivity trivially additivity 
usually algorithm composite problem apply type problem decomposition 
real desideratum necessarily generate algorithms guarantee br superadditivity superiority grand coalition coalition structures algorithms provide highest social welfare best coalition structure need grand coalition 
goals conflicting 
algorithm performance profiles satisfy conditions br superadditivity decomposition method depends problem specific instances study algorithm 
general game brsup ccomp condition hold performance profiles theorem rs rt cs rs rt cs rs ct rt game brsup ccomp 
reasonable assume performance profile cs decreasing agent inexpensively store best solution arrived far 
furthermore cs convex greater savings achieved early stages computation savings time unit decrease problem solving proceeds 
conjecture performance profiles design time algorithms convex 
hand performance profiles anytime algorithms typically convex points base algorithm switches approach 
example completing iterative refinement algorithm running exhaustive complete algorithm refinement phase 
example switching refinement operator swap tsp lin kernighan sandholm refinement operator swap tsp 
furthermore refinements decrease solution cost step wise manner rendering performance profiles locally nonconvex experiments fig 
left 
algorithm stochastic step related reduced performance profile averaged multiple runs 
performance profiles experiments exhibited convex nature true local design time algorithms constructed anytime algorithms tailored time setting separately sec 

convexity significant convex performance profiles domain brsup computation unit costs condition theorem performance profiles holds theorem brsup necessary sufficient condition 
restrict performance profiles cu decreasing convex rs rt cs rs rt cs rs ct rt game brsup ccomp 
analogous theorem easy sufficient condition performance profiles guarantees game br subadditive computation unit costs theorem brsub sufficient condition 
rs rt cs rs rt cs rs ct rt game brsub ccomp 
stability coalition structure previous section conditions performance profiles describe coalition structure agents best forming social welfare viewpoint 
section analyze stability coalition structure 
social distributed agents agent motivated stay social welfare maximizing coalition structure individual rationality 
furthermore distributed subgroup agents motivated stay coalition rationality 
discussed section core solution concept satisfies conditions 
introduce analog core br agents 
definition bounded rational core brc computation unit cost ccomp brc ccomp cs lambda ae pi xi vs ccomp pi xi pj cs lambda ccomp brc empty br agents divide social way subgroup motivated break away cs lambda brc empty coincide core empty 
games brc core exist games exists separately games empty fig 

agents best working separately coalition structure separate agents stable fig 
theorem brc brsub games necessary sufficient condition 
game brsub ccomp brc ccomp 
domains br subadditive brc empty 
condition converted necessary sufficient conditions games grand coalition maximizes social welfare shapley charnes 
convert condition brc ccomp conditions vs ccomp analogously 
bp distinct nonempty proper subsets set fb bpg called balanced positive coefficients 
minimal balanced set includes balanced sets 
theorem brc grand coalition games necessary sufficient condition 
games cs lambda fag ccomp brc ccomp iff minimal balanced set fb bpg ccomp va ccomp 
example 
agent game cs lambda fag ccomp brc ccomp iff vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp 
inequality implied fact cs lambda fag 
example 
agent game cs lambda fag ccomp brc ccomp iff inequalities table hold 
constraints correspond partitions 
implied fact cs lambda fag 
brsup games subset inequalities suffices 
call minimal balanced set proper elements disjoint 
theorem brc brsup games necessary sufficient condition 
game brsup ccomp brc ccomp iff proper minimal balanced set fb bpg ccomp va ccomp 
furthermore set inequalities minimal smaller set sufficient 
example 
agent game brsup ccomp brc ccomp iff ccomp ccomp ccomp ccomp 
table 
conditions existence brc agent grand coalition game 
column shows number constraints generated constraint permuting agents including permutation 
id constraint vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp vf ccomp example 
agent game brsup ccomp brc ccomp iff conditions acquired table constraints satisfied 
conditions performance profiles sufficient guarantee brc exists 
theorem conditions performance profiles guarantee br subadditivity theorem form set conditions 
set suffices games cs lambda fag theorem brc grand coalition games sufficient condition 
games cs lambda fag ccomp minimal balanced set fb bpg rb cbj ca brc ccomp 
cs lambda fag ccomp conditions guarantee existence brc ccomp ccomp 
mean coalition stability execution platform 
brsup games fewer conditions suffice theorem brc brsup games sufficient condition 
game brsup ccomp proper minimal balanced set fb bpg rb cbj ca brc ccomp 
game brsup ccomp conditions guarantee existence brc ccomp ccomp 
example 
agent game brsup ccomp rf rf rf cf rf cf rf cf rf cf rf rf rf ccomp brc ccomp 
experimental results distributed vehicle routing theoretical arguments known problems problem instances generated populate region venn diagram coalition games 
mean real world problems problem instances uniformly populate space 
role experiments section analyze particular real world problem instances fall space coalition games 
quite surprising results appeared 
coalition formation bounded rational agents tested vehicle routing problem week real world vehicle order data geographically distributed dispatch centers 
problem large instances described section shown problem complete 
domain cost cs rs coalition sum route lengths vehicles coalition handling orders solution reached computation rs 
rational value coalition defined tasks delivery orders resources vehicles depots agents coalition 
problem instances example large smallest ones hard solve optimally 
rational coalition formation algorithms vehicle routing problems lundgren unusable case 
problem outside domain classification rosenschein zlotkin rosenschein zlotkin fig 
agents symmetric capabilities due heterogeneous 
definition extended allow asymmetric capabilities domain sod tod 
domain tod agent necessarily able individually handle tasks agents 
dropped maximum route length constraint experiment restricted domains center sufficient vehicle satisfy weight volume constraints order center true data domain tod 
simple example shows subadditive tod depots geographically distributed 
look game just agents delivery tasks identical vehicles agent 
say pickup site drop site close depot pickup drop close depot 
say depots far 
sum route lengths manages manages lower agent individually manages tasks 
analyze game ran algorithm vehicle routing problem subgroup agents separately acquired performance profile potential coalition 
algorithm generates initial solution giving vehicle long delivery order giving vehicle delivery added route cost violating constraints 
second phase algorithm iterative refinement 
step delivery chosen randomly ordered circular list removed routing solution inserted back solution expensive place violating constraints 
drop location delivery inserted pickup location vehicle route necessarily leg 
ran refinement algorithm remove insert operation enhanced solution local optimum reached 
performance profiles ignored time construct initial solution viewed solution cost decreased cpu seconds iterative refinement fig 
left 
refinement algorithm anytime algorithm performance profiles exact explained precomputed experimental purposes running base algorithm agents gain information execution instance far 
algorithm equivalent design time algorithm purposes 
analyzed agent games acquired choosing dispatch centers 
subgroups agents coalition structures ff gg ff gg ff gg ff gg ff gg 
shows performance profiles agents 
games superadditive rational agents worst composite coalition solutions separate coalitions 
general game non superadditive collusion process involves cost anti trust penalties 
rational agents best forming grand coalition 
surprisingly games brsup ccomp fig 

ccomp mid range agent games brsub point fig 
low high ranges point lh fig 
brsup brsub 
mixed games low ccomp grand coalition best coalition structure point lg fig 

existence core rational agents unknown games points lh lg really lh lg 
brc non empty agent games values ccomp 
summarize rational agents best forming possibly unstable grand coalition br agents form varying coalition structures grand coalition low values ccomp stable 
reran experiments maximum route length restriction results prevailed fig 

ccomp brsub brsub brsub agent games route length restriction agent games route length restriction brsub brsub brsub brsub brsub brsub brsub brsub brsub brsub brsub brsub brsub brsub brsub agent games route length restriction agent games route length restriction agent game route length restriction agent game route length restriction brsub brsub brsub bounded rational subadditive 
optimal coalition structure cs lambda bounded rational subadditivity function ccomp 
tested evaluating possible coalition structures super subadditivity varying points ccomp chosen grid ccomp incremented 
centers located near far centers 
centers transported heavy low volume items transported light voluminous items 
centers deliveries vehicles respectively 
route length restriction best mutually colluding ccomp 
deliveries considerable areal overlap due adjacency light voluminous items heavy low volume items profitably joined weight volume constrained vehicles 
centers collude vehicles tighter volume constraints hindering transport goods 
centers best agent coalition independent third agent game 
relaxing route length constraint increased collusion distant collusion adjacent 
analyzed agent games agent game route length restriction 
game existence brc ccomp varied times function ccomp existed largest values ccomp 
game brsup ccomp games brsub values medium range fig 

grand coalition best coalition structure twelve games agents 
happened low ccomp game agents route length restriction 
occurred brc ccomp happened non empty point lg lg fig 

agent games brc ccomp nonempty best coalition structure grand coalition 
depending ccomp games points lh lg lh lg 
best coalition structure varied despite fact rational agents best forming grand coalition due superadditivity 
agents participated best mutually colluding computation unit costs 
games agents 
put main surprising result rational agents form grand coalition obvious bounded rational agents 
vehicle routing games experiments real data reasonable iterative refinement algorithm exhibited br superadditivity 
observed br subadditivity games implies non empty brc best coalition structure games stable 
br subadditivity hold brc non empty especially large ccomp 
interesting observation normative theory prescribes bounded rational agents choose coalition structures agree closely human agents select 
best br coalition structures agreed intuitions coalitions form strategic domain specific considerations adjacency dispatch centers loads 
hand coalition structures differ significantly rational agents choose 
uniformly true higher computation unit costs promote smaller coalitions lower computation unit costs 
possible intuitive explanation 
step refinement algorithm takes theta vd time number vehicles number deliveries 
superlinear deliveries larger coalition fewer refinement steps time agents partitions coalition 
compensate refinement step larger coalition need reduce solution cost refinement step smaller coalition 
size saving averaged refinement steps optimal time allocation 
ccomp low time allocated small coalitions run profitable refinements 
ccomp high time allocated coalitions profitable refinements larger coalition time fewer 
surprising games grand coalition optimal optimal small computation unit costs 
surprisingly agents colluding better agents working separately large computation unit costs 
result higher computation unit costs promote smaller coalitions somewhat choice including initial solution construction phase performance profiles 
shifting performance profiles right time initial solution finished zero shift performance profiles small coalitions performance profiles large coalitions initial solution construction superlinear tasks vehicles 
small coalitions gain advantage significant large ccomp 
time initial solution generation discarded best coalition structure highest computation unit costs depends quality initial solutions different coalitions refinement steps beneficial 
example coalitions achieved better initial solution cost sum initial solution costs agents separately fig 

domain solution interactions coalitions different performance profiles agents common practice far chapter studied coalition formation characteristic function games cfgs 
games rational value coalition characteristic function function actions nonmembers 
general value coalition may depend actions nonmembers due positive negative interactions agents solutions 
settings modeled normal form games fig 

cfgs strict subset negative interactions coalition nonmembers caused shared resources finite capacity 
nonmembers resource certain extent resource available agents coalition carry planned solution minimum cost 
negative interactions caused conflicting goals 
satisfying goals nonmembers may move world coalition goal state rosenschein zlotkin 
positive interactions caused partially overlapping goals 
satisfying goals nonmembers may move world closer coalition goal equivalent constant sum games unrestricted side payments perfect communication 
games characteristic function value coalition minimax value normal form game van der linden verbeek 
state coalition reach goals actions nonmembers 
introduce new domain class bounded rational characteristic function game fig 

value coalition defined bounded rational value vs ccomp 
far chapter studied 
interactions domain solutions different coalitions may exclude problems class 
general rational value coalition may depend actions agents due positive negative interactions agents domain solutions discussed 
games cfgs 
reason value br coalition domain solution computed br agent may depend actions nonmembers characterized vs ccomp 
games class 
reason game may 
far games agent performance profile coalition 
general domains agents different performance profiles due different algorithms value coalition depends computational actions nonmembers 
value coalition depend outside agent willing compute solution coalition payment algorithm better algorithms agents coalition 
games agents different unit costs ccomp computation due different execution architectures general 
games analogous games global ccomp agents different performance profiles 
game agents different computation unit costs modeled game uniform computation unit cost ccomp axis vs ccomp function appropriately rescaled real ccomp corresponding coalition exist cfgs 
due fact construct games domain cost actual solution coalition attained algorithm br agent may independent actions nonmembers domain cost best solution attained rational agent depends actions nonmembers 
example domains possible restrict oneself algorithms consider solutions value affected nonmembers 
exist cfgs 
example agents may different performance profiles bounded rational value coalition may depend nonmembers willing computation coalition 
reason cfgs 
algorithms agents may produce solutions values depend actions nonmembers value optimal solution 
distributed vehicle routing problem dissertation positive negative domain solution interactions coalitions 
shared resources resources vehicles depots exclusively exhaustively distributed agents coalitions 
secondly agent coalition goal delivering parcels lowest possible cost 
coalition handling deliveries unaffected agents handle deliveries 
vehicle routing problem cfg 
reason domain solution interactions preclude problem belonging class 
agents performance profiles assumed earlier distributed vehicle routing games agents different performance profiles computation unit costs games necessarily 
distributed scheduling domain domain interactions occur agents share resources 
hand toy problems blocks world positive negative interactions occur 
non cfgs superadditivity subadditivity core undefined see section 
solution concepts necessary 
reasonable alternatives include nash equilibrium section strong nash equilibrium section coalition proof nash equilibrium section 
analogous problems arise br agents 
non br superadditivity br subadditivity brc undefined 
solution concepts necessary nash equilibrium mentioned refinements 
chapter summary chapter studied settings agents coordinate computational actions real world actions coalition coalitions 
normative domain independent theory coalitions combinatorial domains rationality self interested agents bounded computational complexity 
extension game theory classically assumes perfect rationality algorithms find optimal solution zero computation unit cost 
hand chapter computational limitations quantitatively modeled unit cost computation performance profiles agents problem solving algorithms 
domain classification bounded rational agents 
related existing domain classifications fully rational agents traditional classification game theory classification rosenschein zlotkin 
algorithms agents significantly impact coalition structure form stability 
model bounded rationality chapter optimal coalition structure computed stability determined 
addition general theorems proven analytically state types performance profiles cause best coalition structure grand coalition irrespective computation unit cost execution platform 
similar theorems proven coalition structure agents separately 
general theorems relate performance profiles non emptiness bounded rational core determines stability coalition structure 
domains superadditive bounded rational superadditivity surprisingly obvious practice 
vehicle routing games experiments real data reasonable iterative refinement algorithm exhibited bounded rational superadditivity 
optimal coalition structure bounded rational agents varied rational agents form grand coalition 
section developed conditions performance profiles guarantee bounded rational superadditivity 
discussed separate solving approach problem decomposition step guarantees base algorithm fulfills conditions 
reasonable deterministic iterative refinement algorithm conditions somewhat surprisingly met 
real desideratum necessarily generate algorithms guarantee bounded rational superadditivity superiority grand coalition coalition structures algorithms provide highest social welfare best coalition structure need grand coalition 
goals conflicting 
observed bounded rational subadditivity games implies non empty bounded rational core best coalition structure games stable 
bounded rational subadditivity hold bounded rational core non empty especially large computation unit costs 
theoretical model shows games coalition structure stable rational agents bounded rational ones games reverse holds games coalition structure stable games stable 
experiments suggest superlinear iterative refinement steps low computation unit costs promote large coalitions high computation unit costs suggests smaller ones 
plausible explanation phenomenon 
interesting observation normative theory prescribes bounded rational agents choose coalition structures agree closely human agents select 
best coalition structures bounded rational agents agreed intuitions coalitions form strategic domain specific considerations adjacency dispatch centers loads 
hand coalition structures differ significantly rational agents choose 
contract execution multiagent systems sandholm lesser sandholm lesser sandholm lesser sandholm lesser rosenschein zlotkin durfee kraus agents provided interaction protocol agent may choose strategy 
allows agents constructed separate designers represent different real world parties 
agents systems act self interest protocols constructed accordingly 
example interaction protocol auction agents bid take responsibility task awarded lowest price bidder 
bids binding agent bid task awarded take responsibility task price 
real world agents protocol enforced law 
enforced protocols problematic computational agents 
may lack laws interactions computational agents agents may governed different laws different countries 
may case laws strictly enforced enforcing impractically expensive 
agents interactions properly independent fluctuations enforcement 
secondly computational agent may vanish point time killing process 
laws enforced terminated agent represented real world party connection agent real world party traced 
example telescript technology general magic follows approach strictly tying agent real world party 
contrary analyze exchanges autonomous agents study possibility exchange enforcement unknown real world parties possibility 
cases type exchange possible clearly preferable strictly enforced mode exchange due savings enforcement costs lack enforcement uncertainty assuming cost breaking deliveries smaller units practical expensive 
fulfillment mutual contract viewed agent delivering agent paying 
propose method carrying exchange enforcement 
exchange managed agents supplier demander point exchange gains carrying rest exchange cooperating contract larger gains defecting 
defection means terminating exchange prematurely vanishing 
example defection may beneficial demander agent supplier agent delivered demander paid 
intelligently splitting exchange smaller portions agents avoid situations motivated defect 
call sequence deliveries payments safe agent motivated defect point exchange 
basic idea enhancing cooperation making important compared suggested example axelrod 
analyzed safe exchanges goods payments setting similar chapter 
differs chapter respects 
analyzes sequence exchanges repeated game sequence known probabilistically 
analysis microeconomic character game theoretic solution concepts explicitly 
hand chapter invokes specific game theoretic solution concepts 
agents defect complete exchanges sequence evaluate option exchange 
explicitly relate safe transactions agents value functions uses models defection cost relates continuation cost justifying models 
explicitly address role time chapter 
analyzes sequence order sizes individual exchanges fixed computationally plausible algorithms splitting exchange parts sound complete algorithm sequencing parts 
propose exchange manager module added agent architecture fig 

module potentially different agent 
role schedule exchange manager module negotiating module models agents exact bounds probabilistic value functions discount functions defection penalties reputation related self interested agent exchange partitioning chunking algorithm chunk exchange executor progress monitor safe chunking sequence exists contract finished exchange manager module negotiating module models agents exact bounds probabilistic value functions discount functions defection penalties reputation related self interested agent exchange partitioning chunking algorithm chunk exchange executor progress monitor contract finished agreements deliveries payments safe chunking sequence exists 
architecture self interested agents special emphasis exchange manager modules 
negotiation system may agents 
exchange manager module gives negotiation module feedback proposed contract carried safely equilibrium 
exchange manager executes exchange actual contract 
dashed lines show information exchange manager uses update models agents 
agent deliveries payments way opponent motivated defect point exchange 
agent self interest 
exchange manager provides agent negotiator module information certain proposed contract carried safely 
protocol enforcement guaranteed negotiator agree contracts executed opponent motivated defect point exchange 
automated negotiation studied respect ex ante rationality contracts desirable agents stable equilibrium sense agents want deviate contract agents deviate contract carried sandholm lesser sandholm lesser sandholm lesser sandholm lesser sandholm rosenschein zlotkin kraus wellman durfee tennenholtz moses 
suggest contracts fulfill condition ex post rationality contract desirable agents step carrying contract 
ex post conditions studied multiagent planning side payments 
unenforced exchange goods payments model analyzes exchanging goods information computation services types payments 
exchange proceeds axes portion goods contract delivered exchange step called xn cumulative payment far pn pcontr 
quantity pcontr total payment specified contract 
agents simultaneous moves observe agent moves far 
value goods nondecreasing functions equivalent units payment supplier value function vs describes cost supplier incurs generating delivering demander value function vd describes goods worth demander 
trivially vs vd 
point xn pn exchange supplier choose xn xn 
mapping sequence xn pn xn called supplier exchange strategy call 
similarly demander exchange strategy mapping xn pn pn pn induce path play game starting model incorporates possibility step xq xq limm xm pq pq limm pm cumulative delivery payment increased certain step exchange 
may due completion exchange due premature breach 
supplier payoff starting subgame xn pn ss xn pn gamma pq gamma vs xq gamma vs xq limm pm gamma pn gamma vs xm gamma vs xn demander payoff starting subgame xn pn ss xn pn xq gamma vd xq gamma pq gamma pq limm vd xm gamma vd xn gamma pm gamma pn defecting exiting exchange corresponds choosing limm xm supplier limm pm pcontr demander 
roughly speaking payoff maximizing supplier agent cooperate rest exchange arbitrary point compensation great cost pcontr gamma vs gamma vs 
assumes demander increase cumulative payment pcontr 
equilibrium analysis respect issue shortly 
facilitate analysis allow strategies general form show chapter desirable properties obtained markov strategies agent move function current state xn pn entire history 
physical transaction cost delivering paying assumed negligible compared cost producing goods value payments 
incorporated model 
follows agents payoffs depend number parts exchange broken 
equality holds agent indifferent cooperating defecting 
chapter assume indifferent agents cooperate 
note chapter analyze remaining payoffs total payoffs incurred payoffs constant respect remaining game 
pmax defined intuition maximum cumulative payment demander pay cumulative delivery inducing supplier defect pmax def pcontr gamma vs vs see left 
roughly speaking rational demander agent cooperate rest exchange arbitrary point compensation pay smaller equal added value pcontr gamma vd gamma vd 
assumes supplier increase total delivery shown equilibrium shortly 
pmin defined minimum cumulative payment cumulative delivery demander induced defect pmin def pcontr gamma vd vd clearly pmax pmin nondecreasing supplier agreed contract pcontr vs hold 
follows pmax 
similarly demander agreed contract pcontr vd 
follows pmin 
agents know value functions bounds know 
supplier safe upper bound pmin lower bound vd upper bound vd 
demander safe lower bound pmax 
agents safe bounds possible exchanges disabled bounds far 
sections equilibrium study safe exchange occur 
analysis slightly different countable uncountable goods 
countable goods countable goods goods inherently split atomic chunks 
conceptually finite infinite number chunks 
chunks vs vd pmax pmin defects demander defects pmax pmin pcontr pmin pmin pmax pmax pmin pmin 
pcontr 
examples unenforced exchange 
left safe exchange uncountable goods 
middle safe exchange countable goods possible 
right safe exchange countable goods possible 
cases pmin pmax pcontr 
agents simultaneous moves try stay inside safe region supplier want deliver demander want pay step 
split arbitrarily divisible 
section assume delivery order chunks fixed 
example traconet transportation cooperation net multiagent system sandholm agents representing dispatch centers negotiated vehicles transport parcels 
care parcel atomic chunk task split 
contract agents involved multiple tasks order avoid local optima distributed task allocation sandholm total exchange split smaller parts 
example demander pay part contract price 
supplier deliver parcel 
demander pay supplier deliver parcel exchange strategies formally supplier demander 
intuitively supplier strategy deliver making sure demander benefit cooperating rest exchange vanishing point 
demander strategy pay making sure supplier benefit cooperating rest exchange exiting 
strategies desired properties certain conditions lead completion exchange minimal number steps equilibrium agent better switching strategy agent switch 
required conditions minimal sense hold strategies lead completion exchange equilibrium 
properties formally stated theorems follow definitions strategies 
definition supplier strategy ss countable goods point xn pn exchange pmin xn pn pmax xn deliver amount cumulative delivery xn maxfx xjpmin png 
exit 
definition demander strategy sd point xn pn exchange pmin xn pn pmax xn pay amount cumulative payment pn pmax xn 
exit 
theorems regarding strategies concepts game theory 
nash equilibrium nash kreps fudenberg tirole means agent motivated adhere specified strategy agent adheres specified strategy 
subgame perfection selten kreps fudenberg tirole means equilibrium nash equilibrium point xn pn exchange 
means equilibrium remains equilibrium agents partially carried exchange 
furthermore equilibrium points exchange reached agents exchange process 
reasons subgame perfection precludes incredible threats promises provides robustness external perturbances 
theorem finite number countable goods discrete ae nondecreasing pmin pmax strategies ss sd form subgame perfect nash equilibrium consecutive amounts cumulative delivery pmax pmin exchange completed finite number steps 
furthermore subgame perfect nash equilibrium leads completion fewer steps 
see fig 
middle 
theorem finite number countable goods discrete ae nondecreasing pmin pmax subgame perfect nash equilibrium leading completion exchange consecutive amounts cumulative delivery pmax pmin 
see fig 
right 
condition pmax pmin fact pmin nondecreasing see hold safe exchange pmax pmin 
terms agents value functions written vd gamma vs vd gamma vs 
means agents joint profit higher equal 
agents better making contract smaller amount goods isolated safe exchange impossible 
furthermore gives vs vd intuitive condition contract place 
specifically vs pcontr vd fig 
left agent incurs loss contract 
fulfillment condition pmax pmin facilitated pmax high pmin low 
means safe exchange enhanced supplier incurs cost early portion exchange possibility demander acquires value early parts hinders safe exchange 
luckily practise supplier usually setup costs demander acquires value completion exchange 
equilibria theorems unique 
example strategies specify demander pays supplier delivers point exchange form subgame perfect nash equilibrium 
consecutive amounts amounts differ just chunk 
consideration independent agents strategies 
step exchange supplier deliver chunk number chunks 
xn xn 
theorems state stringent conditions met enable unenforced isolated exchange finite number countable goods 
substituting definitions pmax pmin gives pmax pmin pcontr 
theorems safe exchange possible pmax pmin consecutive 
call size delivery delta safe exchange hold pmax gamma delta pmin pmax 
increasing function pmax constant step fig 
middle 
means supplier value function vs constant 
isolated safe exchange possible supplier incur cost generating delivering chunk 
occurs example supplier acquire number deliverables atomically 
cost acquiring deliverables entirely attributed deliver items separately increasing vs assuming negligible costs physically delivering 
may occur practise fig 
right 
intuitively benefit gained exchanging agents better defecting current move 
problem occurs isolated exchange finite number countable goods entire exchange 
move supplier want increase delivery demander defect 
similarly demander want increase cumulative payment pmax gamma delta supplier defect 
agents know part exchange take place due 
analyze exchange part 
second part problem supplier deliver part cost agent wants initiate part 
agents know 
backward induction carried exchange 
agent move exchange take place 
theoretically infinite number countable goods 
cases exchange spoiling backward induction argument apply point agent say move 
backward induction inapplicable uncountable goods 
facilitates safe unenforced exchange uncountable goods discussed section 
countable uncountable goods problem requiring supplier deliver part costs overcome considering related interactions agent sec 

uncountable goods section analyzes exchange uncountable goods goods split fixed chunks split arbitrarily gasoline coffee monetary currency rounding 
simple condition safe exchange 
intuitively says demander paid pmax supplier safely supply ffl total payment falling pmin ffl 
condition safe unenforced exchange uncountable goods ffl lambda gamma ffl pmax lambda pmin lambda ffl 
condition fully equivalent detailed conditions interested reader 
intuitively ffl reachability states conditions safe exchange proceed amount cumulative delivery 
second ffl states conditions safe exchange proceed amount cumulative delivery 
condition ffl reachability ffl lambda 
pmax lambda pmin lambda pmax constant closed left ffl neighborhood lambda 
pmax lambda pmin lambda lambda gamma pmax pmin lambda pmax lambda gamma ffl pmin lambda 
pmax lambda pmin lambda lambda gamma pmax pmin lambda pmax constant closed left ffl neighborhood lambda pmax pmin pmax pmin pmax pmax pmin pmax pmin 


exchanging uncountable goods reaching point ffl reachability 
condition ffl ffl lambda 
pmax lambda pmin lambda pmin constant closed right ffl neighborhood lambda 
pmax lambda pmin lambda lambda pmin pmax lambda pmax lambda pmin lambda ffl 
pmax lambda pmin lambda lambda pmin pmax lambda pmin constant closed right ffl neighborhood lambda follows theorems regarding conditions stated 
stated terms condition 
supplier strategy needs defined uncountable goods ss necessarily defined settings pmax pmin pmin pmax pmax pmin pmax pmin 

pmin 
exchanging uncountable goods departing point ffl 
example 
result max operator undefined 
say pmin ss specifies maxfx xjpmin 
quantity undefined 
pmin pmin 
reason number 
number number fulfills condition pmin 
define new strategy supplier definition supplier strategy uncountable goods point xn pn exchange pmin xn pn pmax xn deliver amount cumulative delivery xn maxfx xjpmin png defined xn max xn xjpmin png gamma ffl 
ffl fixed ffl ffl ffl condition 
exit pn pmax xn pn pmin xn 
subtraction ffl supremum done order maintain invariant pmin xn pn 
note defined maxfx xjpmin png equal xjpmin png 
example prescribes xjpmin gamma ffl xjpmin gamma ffl gamma ffl 
demander strategy sd need redefined defined uncountable goods 
theorem uncountable goods nondecreasing pmin pmax strategies sd form subgame perfect nash equilibrium ffl lambda gamma ffl pmax lambda pmin lambda ffl condition holds 
exchange completed finite number steps 
furthermore ffl lambda ffl ffl ffl lambda exchange minimal number steps subgame perfect nash equilibrium exchanges leading completion 
theorem uncountable goods nondecreasing pmin pmax subgame perfect nash equilibrium leading completion exchange finite number steps ffl lambda gamma ffl pmax lambda pmin lambda ffl condition hold 
theorems state isolated unenforced exchange uncountable goods safe initial delivery intermediate amount delivery reached departed final amount delivery reached exceeding pmax moving pmin 
theorems assume continuity pmax equivalently vs pmin equivalently vd 
assume pmax pmin strictly increasing 
follows theorems continuous pmax pmin exchange carried subgame perfect nash equilibrium finite number steps ffl pmax pmin pmax pmin pmax constant left neighborhood pmin constant right neighborhood 
addition continuity pmax pmin strictly increasing exchange safely pmax pmin 
isolated safe exchange problematic case uncountable goods 
substituting definitions pmax pmin see pmax pcontr pmin 
case condition see full delivery reached pmax constant left neighborhood 
value function supplier vs constant exchange exchange completed 
case finitely countable goods isolated safe exchange possible supplier incur cost generating delivering portion goods 
problem severe case finitely countable goods 
example case pmin pmax continuous pmin pmax left neighborhood pmin pmax pcontr exchange approach completion original strategies ss sd 
resulting equilibrium path size deliveries decreases approaches zero making number deliveries infinite fig 
left 
allows agents reach cumulative delivery arbitrarily close backward induction argument disabled entire exchange case finite number countable goods hold 
particular exchange step agents reason move 
section describes entire exchange carried accounting fact defecting exchange adversely affect agent 
non isolated exchange agent interacts agents 
interaction may affect agent interactions 
example agent defects current exchange counterpart may want take contracts agent 
counterpart notify agents agent 
agent interactions third parties may hindered defecting current exchange 
hindering impact defection thought extra cost 
cost may motivate agents cooperate current exchange rational defect considered isolation 
methods calculating defection impacts scope dissertation 
assume agents know opponent defection costs 
denote supplier defection cost demander defection costs incorporated model redefining pmax pmin fig 
pmax def pcontr gamma vs pmin def pcontr gamma vd gamma def max min pcontr supplier defects demander defects cdef region non isolated exchange safe region safe isolated exchange supplier defection penalty demander defection penalty min max 
defection penalties non isolated exchange give leeway safe moves 
isolated exchange substituting definitions pmax pmin gave pmin pcontr pmax 
led problem exchange carried completion pmax constant exchange 
non isolated exchange substituting gives pmin pcontr gamma cdef pmax pcontr cdef defection penalties give leeway exchange possibly enabling safe exchange completed pmax constant 
contract price pcontr exceeded due leeway 
avoid demander strategy modified point exchange demander increases cumulative payment min pcontr pmax pmax 
hinder exchange condition takes effect full contract price paid 
non isolated exchange fruitful isolated exchange facilitates safe completion 
theorems possibilities subgame perfect nash equilibrium exchange apply directly case non isolated exchange new definitions pmax pmin substituted place pmax pmin minor modification demander strategy 
uncountable goods smallest reputation related defection penalties suffice allow safe completion exchange supplier deliver portion cost 
hand countable goods defection penalties need larger smallest possible atomic chunks large supplier safely deliver chunk demander safely pay portion 
agent know defection cost opponent lower bound cost 
way agent safe bound far possible exchanges disabled 
role time section addresses real time exchange exchange take place immediately infinitely postponed 
nonincreasing discount functions tn assumed tn 
subscripts distinguish supplier demander superscripts characterize discount applies payment value goods 
example discount function value vd means time worth half worth exchange demander 
example constant interest rate compounded interest discount function tn gamma rtn rasmusen 
real time incorporated protocol allowing agents postpone moves 
exchange conceptually proceeds steps agent move step determines time step 
note protocol specify agent move step simultaneous moves legal 
example say exchange reached delivery xn payment pn agents currently postponing 
point supplier bind variable tn representing time action increasing cumulative delivery xn xn 
alternatively demander bind tn increasing cumulative payment pn pn 
agent new move determines tn happen due simultaneous moves agents determine value tn 
role time isolated exchange subsection analyzes role time exchanges agent defection impact contracting possibilities 
subsection discuss time non isolated exchanges 
subgame xn pn tn supplier remaining payoff ss xn pn tn tq pq gamma pq gamma tq vs xq gamma vs xq demander payoff starting subgame xn pn tn ss xn pn tn tq vd xq gamma vd xq gamma tq pq gamma pq specific real time incorporating strategies introduced players 
analogous original strategies ss sd agents moves immediately 
definition supplier strategy countable goods point xn pn tn exchange pmin xn pn pmax xn immediately deliver amount cumulative delivery xn maxfx xjpmin png tn tn 
exit pn pmax xn pn pmin xn 
definition demander strategy point xn pn tn exchange pmin xn pn pmax xn immediately pay amount cumulative payment pn pmax xn tn tn 
exit pn pmin xn pn pmax xn 
theorem states agent motivated unilaterally deviate immediate exchange certain conditions hold discount factors 
result obvious conceivably agent deliveries payments better postponing remainder exchange important due discounts 
proof theorem quite tedious 
theorem finite number countable goods discrete ae nondecreasing pmin pmax strategies form nash equilibrium consecutive amounts cumulative delivery pmax pmin ps vs pd vd 
equilibrium nash equilibrium subgame reached 
exchange completed immediately finite number steps 
furthermore nash equilibria remain nash equilibria subgame reached lead immediate completion equilibrium guarantees minimal number steps completion 
isolated unenforced exchange feasible supplier discounts payments sharply equally production costs demander discounts value goods sharply equally payment 
condition supplier discount functions natural 
example stable environment supplier current value producing item remain constant obviously payment discounted 
condition demander discount functions stringent 
realistic case demander needs goods urgently 
agent need know opponent exact discount functions 
sufficient know fulfill conditions 
equilibrium concept theorem slightly weaker subgame perfection guarantees equilibrium nash equilibrium subgames reached subgames 
practise means unknown reason exchange delayed guaranteed agents motivated proceed immediately theorem nash equilibrium theorem subgame perfect 
clearly theorem immediate exchange countable goods impossible equilibrium condition consecutive hold 
similarly theorem immediate exchange possible uncountable goods condition hold 
hold immediate exchange possible uncountable case 
show define strategy supplier uncountable goods possibility result max operator undefined 
definition supplier strategy uncountable goods point xn pn tn exchange pmin xn pn pmax xn immediately deliver amount cumulative delivery xn maxfx xjpmin png defined xn max xn xjpmin png gamma ffl 
ffl fixed ffl ffl ffl condition 
exit pn pmax xn pn pmin xn 
theorem uncountable goods nondecreasing pmin pmax strategies form nash equilibrium ffl lambda gamma ffl pmax lambda pmin lambda ffl condition holds ps vs pd vd 
furthermore equilibrium nash equilibrium subgame reached 
exchange completed immediately finite number steps 
furthermore ffl lambda ffl ffl ffl lambda exchange minimal number steps nash equilibrium exchanges remain equilibria subgames reached lead immediate completion 
theorem nash equilibrium theorem subgame perfect 
countable uncountable goods trivial method strategies earlier subgame perfect 
done defining strategies specifying current tn agents exit 
obviously supplier best delivering demander pays vice versa 
strategies best responses subgames tn 
earlier shown original strategies formed equilibrium subgame path play starting 
new strategies form subgame perfect equilibrium 
problem new subgame perfect equilibrium lead completion exchange point tn 
conditions discount functions theorem hold outcomes vary 
supplier wants carry exchange time ps high vs low 
demander prefers exchange pd low vd high 
times may coincide 
exact forms discount functions define exchange carried equilibrium immediately slightly postponing different moves exchange may postponed different amounts postponing infinitely 
role time non isolated exchange shown time discounts reduce advantages non isolated exchange cases 
assume current value agent defection cost change realistic 
agent discounts payments means absolute value defection cost increases time 
theorem states certain types discount functions exchange proceed outside region isolated exchange fig 
delayed 
result discount factors payments need reach zero usually means delay infinitely long 
settings advantage defection penalties non isolated exchange moving region fig 
facilitate safe exchange usually infeasible 
intuitively agent wants postpone negative net benefit heavily discounted 
theorem recall section definitions pmax pmin take defection penalties account 
theorem limt vs subgame pmax xn pn pmax tn ps vs nash equilibrium remains equilibrium subgame reached results completing exchange supplier delays caused vs ps 
similarly limt pd subgame pmin pn pmin xn tn vd nash equilibrium remains equilibrium subgame reached results completing exchange demander delays caused pd vd 
conditions limt pd ps vs true practise 
condition pd vd true demander needs goods urgently 
supplier discount function goods need approach 
cost producing goods discounted may decrease production date 
may allow demander facilitate exchange safely paying moving upper region conditions negative result theorem fulfilled 
deadlines lateness penalty schedules negative result theorem stems considering infinite postponing violation contract 
changed specifying deadlines lateness penalty schedules agents contract 
note externally enforced 
contract deadlines honored lateness penalties paid defecting agent suffer defection penalty due defection affect contracts degraded reputation 
strictly speaking contract matters non isolated exchange forcing timely exchange deadlines lateness penalties possible cases 
highlights value theorems isolated exchange guarantee immediate exchange equilibrium need forced 
non isolated exchange deadlines lateness penalties meaningful long deadline paying lateness penalty expensive suffering defection penalty 
lateness penalty schedules preferable strict deadlines risky agent potentially subject agent tailor lateness penalty schedule motivate move immediately 
example 
enabling exchange unenforced deadline 
vs vd vs vd ps pd analyze contract specifies pcontr unenforced deadline 
supplier prefers execute exchange early possible vs gamma ps strictly increases time 
demander exchanges late possible pd gamma vd strictly decreases time 
knowing supplier loses postponing 
exchange takes place right deadline 
turns strategies ss sd time form nash equilibrium leads completion exchange remains equilibrium subgame reached just substituting equations pmax pmin place pmax pmin correspondingly strategies 
earlier intuitive condition supplier cooperate ps pcontr gamma vs vs gamma vs gamma get pmax ps pcontr gamma vs vs vs vs ps pcontr gamma vs gamma vs gamma similarly intuitive condition demander cooperate vd vd gamma vd pd pcontr gamma gamma get pmin pcontr gamma vd vd vd vd gamma def pd pcontr gamma vd gamma vd gamma equilibrium path 
supplier payoff exchange ps pcontr gamma vs vs delta gamma delta ss demander payoff vd vd gamma pd pcontr delta gamma delta ss 
note exchange possible equilibrium pmax constant exchange 
delivery sequencing far discussed exchanges delivering order goods fixed section analyze exchange partial deliveries analogous situation occurs order delivery matter goods equivalent 
individual countable goods atomic chunks countable uncountable goods delivered order long get delivered 
problem differs significantly chunks sequence independent 
cases analyzed sections respectively 
sequencing independent deliveries chunk sequencing algorithm integral part exchange manager module self interested agent fig 

assumed relaxed section demander added value chunk depend chunks delivered far supplier cost delivering chunk depend chunks delivered earlier 
enables associate chunk values delta delta fully characterize maximum minimum cumulative payments change delivered 
example agent contract carry number matrix multiplications 
multiplying matrices facilitates hinders multiplying chunks independent respect supplier 
chunks truly independent independent respect demander uses multiplication results 
call delivery sequence safe min pmax pcontr pmin consecutive 
provide fast greedy algorithm finds safe ordering exists 
algorithm takes inputs set chunks vector delta values vector delta values contract price pcontr defection penalties case isolated exchange 
algorithm seq chunks delta pmax delta pmin pcontr 
pcontr pcontr gamma 
sets bounds gamma delta gamma delta 
return solution 

divide sets os os fc cj delta gamma delta fc cj delta gamma delta 

pmax pmin np jp nn jn 

np fc delta 
return solution 
lambda arg maxc delta gamma delta chunk lambda pmax pmax delta lambda pmin pmin delta lambda os os gamma fc lambda 
pmax pcontr pmin pcontr gamma 
nn np np fc pmax gamma delta return solution 
lambda arg maxc delta gamma delta chunk lambda pmax pmax gamma delta lambda pmin pmin gamma delta lambda gamma fc lambda 
return ordered vector chunk 
chunk delivered chunk 
step algorithm sequences chunks positive delta gamma delta forward passing greedy manner try increase pmax possible increasing pmin little possible 
intuitively algorithm tries maximize range possible safe prices step just computes pmax pmin sequence chunks 
step greedy backward pass 
tries allocate chunks negative delta gamma delta little possible beneficial difference delta gamma delta sequence 
intuitively difference saved middle sequence time affect chunks lying sequence 
solve sequencing problem tried greedy algorithms starting intuitive ones 
guarantee safe sequence exists 
example algorithms greedily pass forward maximize delta gamma delta minimize delta defeated counterexamples just chunks exist simple problem instances algorithms find safe sequence exists 
hand algorithm sound complete theorem algorithm finds safe ordering exists returns solution 
terminates jcj time 
division exchange chunks externally fixed decided agents contract time 
reason exchange partitioning chunking algorithm added architecture exchange manager module self interested agent fig 

exchange chunking done top generating chunking testing safety running algorithm 
safe chunking refined splitting chunks 
splitting monotonic sense split safe exchange unsafe 
splitting algorithm need backtrack 
top method uncountable goods 
minus side approach need guess splits 
guessed badly possibly chunks generated necessary enable safe exchange 
bottom approach chunking sequence smallest possible atomic chunks algorithm 
agents may able deliver multiple atomic chunks step exchange strategies ss sd changing order chunks 
bottom chunking requires guessing splits computationally complex number smallest possible chunks large 
applied uncountable goods number smallest possible chunks infinite 
sequencing interdependent deliveries partial deliveries interdependent 
value chunk may depend chunks delivered 
example manufacturing products thought costly subsequent ones fixed costs rent acquired equipment associated earlier products 
operational level grinding machine thought producing output items setup cost type items spread items 
similarly data retrieval agent may incur large costs searching certain information 
information subsequent searches related information expensive 
demander may value chunk differently depending chunks delivered far 
traconet system sandholm chunks transport tasks interdependent supplier demander 
transporting parcel affects marginal cost transporting 
example vehicle may able carry parcels adjacent locations reducing marginal cost tasks 
conversely parcel may fill vehicle task handled costly vehicle 
contracts involved multiple tasks 
safe exchange mechanisms dissertation sequencing interdependent chunks required 
general interdependent goods sequenced polynomial time number chunks required safe solution exists 
just representing problem requires theta jcj space set chunks power set chunks pmax pmin represented worst case information compressed 
number chunks contract small traconet exponential search sequences chunks viable 
cases advantages safe unenforced exchange outweigh extra computational load 
furthermore special cases problem may solvable polynomial time case independent chunks discussed earlier 
renegotiation avoidance irrevocable delivery payment agent gained may want contract 
example partial delivery demander may want contract lower price 
demander knows original contract price safe supplier supplier lost delivery supplier willing carry rest exchange lower price 
hand contract execution method chapter supplier knows point exchange safe demander 
supplier commit demander motivated follow original contract vanish 
renegotiation unsafe exchange lax raiffa 
example international initiates mining venture developing country invest capital front 
unsafe move motivates developing country conditions mining venture profit division 
due risk avoid renegotiation 
chapter summary chapter method carrying mutual exchanges agents third party enforcement 
larger exchanges split smaller parts point agent motivated defect equilibrium 
maximum size delivery supplier safely point exchange shown maximum amount demander safely pay 
possibility safe exchange depends demander agent supplier agent value functions goods contract 
safe exchange enhanced supplier incurs cost early portion exchange possibility demander acquires value early parts hinders safe exchange 
luckily practise supplier usually setup costs demander acquires value completion exchange 
isolated safe exchange carried entirely supplier deliver part cost 
uncountable goods carried arbitrarily close completion case 
considering defection adverse effect negotiations enables completing exchange 
conditions discount functions agents motivated carry isolated exchanges immediately 
time discounts reduce viability advantage non isolated exchange 
cases immediate moves stimulated deadlines lateness penalties need enforced 
domains allow goods delivered different chunks batches chunks delivered different sequences 
top bottom chunking algorithm relative merits discussed 
non trivial quadratic algorithm sequencing independent chunks 
proven find safe sequence exists 
general problem solved polynomial time number chunks chunks interdependent 
research include designing polynomial algorithms special cases problem case independent chunks 
showed safe exchange helps prevent unfair renegotiation 
dissertation studied interactions self interested agents rationality bounded limited computation 
developed methods mainly targeted inherently distributed combinatorial problems resource task allocation multiagent planning scheduling situations agents may different goals agent trying maximize concern global 
agents solve underlying combinatorial problems optimally enumerate evaluate alternatives advance commonly assumed game theory 
agents trade solution quality amount computation 
developed methods enable open negotiation systems operate separately designed self interested agents combinatorial real world domains distributed vehicle routing multi enterprise manufacturing planning scheduling meeting scheduling 
approach quantitative 
issues theoretically analyzed experiments carried agent complete distributed vehicle routing problem appropriate 
experiments run large scale problem instances real week vehicle delivery order data collected dispatch centers 
normative approach borrows solution concepts game theory 
allows agents choose strategies best terms self interest agents unrealistically assumed abide centrally imposed strategies 
contributes broad areas multiagent systems research automated contracting coalition formation contract execution 
automated contracting setting agents iteratively reallocate tasks improving task allocation contract 
previous contract net implementations assumed agents handle tasks free section extended model self interested agents handle agents tasks paid 
previous contract net domain specific heuristic methods making bidding awarding decisions 
introduced domain independent formal model making decisions bidding awarding entirely local marginal cost calculations 
allows contracts guaranteed individually rational parties provably enhance social welfare 
vehicle routing domain combinatorial domains marginal cost calculation requires solving complete problems intractable 
approximation algorithms calculating marginal costs 
consequences underestimating discussed shown profitability really defined respect computed solutions optimal solutions unobtainable 
resulting negotiation scheme anytime task reallocation algorithm terminated time guaranteed feasible solution agent worse agent initial solution participation individually rational 
experimentally shown truly distributed asynchronous implementation technology possibility scale large scale problem instances 
part contracting market assumption agents accept individual rational contracts 
differs game theoretic assumptions agents lie tasks marginal costs look ahead contracting process 
hand parts contracting chapter chapters agents assumed act 
act strategically self interest vein game theory 
section decommitment mechanism automated contracting protocols allows agents accommodate events profitably traditional full commitment contracts 
contract specifies decommitment penalty agents involved 
penalties negotiated contract basis differ contract parties 
decommit agent just pays penalty agent 
reasons protocol better suited computerized contracting settings contingency contracts 
game theoretic analysis decommitting games handled possibility agents decommit agent tries avoid decommitment penalty case believes high probability freed contract obligations due agent decommitting 
analysis serves normative tool agents decide contracts accept individual rationality 
bargaining associated choosing ex ante individually rational contracts addressed 
games leveled commitment contracts superset full commitment ones emulated setting decommitment penalties sufficiently high 
full commitment protocols better leveled commitment ones sense pareto efficiency social welfare 
enable deal impossible individual rationality leveled commitment contract 
games outside offers void contracting decommitting time game types dop instances new protocol enables contracts impossible individually rational agents full commitment contracts theorems 
game types leveled commitment contracts improve agent expected payoff full commitment contract long chance contractor outside offer lower expected value contractee chance contractee outside offer higher expected value contractor theorems 
obviously construct game instances agents outside offers profitable contract leveled commitment individually rational agents 
game agent loses outstanding outside offer agreeing contract leveled commitment contract enable deal pareto improve deal full commitment contract agent fallback payoff sufficiently high theorems 
games dop agent outside offer involves uncertainty agent certain outside offer prefers decommit 
games agent payoff contract unaffected agent beliefs theorems 
follows agent need negotiation partner beliefs agent incur loss due agent erroneous beliefs hand games agents outside offers involve uncertainty agent payoff contract may depend negotiation partner possibly biased beliefs affect partner decommitting decision 
section different stages commitment discussed 
shown commitment occur stage stage negotiated item need fixed protocol 
section example protocol allows addition allowing types flexibility alternative offers section showed classical contracts task time insufficient reaching globally optimal task allocation local optima assuming agents individually rational contracts 
new contract types overcome problem clustering swaps multiagent contracts 
shown counterexamples insufficient applied agents may perceive contract individually rational really theorem 
error hurt agent unbiased beliefs corollary 
pairs separately 
combined new atomic contract type csm contract 
theorem showed agents pick csm contracts hill climbing algorithm finds global task allocation optimum finite number steps backtracking 
means perspectives social welfare maximization individual rationality necessarily perspective local payoff maximization agents accept individually rational contracts offered 
need wait profitable ones need worry current contract may profitable contract unprofitable 
need accept contracts individually rational anticipation contracts combination beneficial 
result powerful small problem instances large instances number contracts globally optimal task allocation reached may great carried practice albeit finite 
larger problem instances guaranteed anytime property important negotiations terminated time agent feasible solution worse initial solution 
section discussed contracting implications agents computational limitations 
real time pressures identified specific contracting settings 
argued agent needs decide task sets focus deliberation order 
issue engaging multiple simultaneous negotiations discussed 
agent bids awards older bids pending current bid award may turn world materializes combination acceptances pending bids 
marginal cost calculations formalized pessimistically assume worst combination gets accepted 
type calculation agent local cost guaranteed decrease monotonically 
opportunistic approximation assumes pending bids get accepted feasibility check ensure feasible solution reached locally pending bids get accepted 
approximation faster compute exponentially alternative worlds need considered agent may occasionally contracts 
general tradeoff computational complexity monetary risk 
alternatively agent refuse bid award previous bids pending 
case marginal cost calculated risk free added complexity alternative worlds need considered 
hand agent participate simultaneous negotiations may lose opportunities 
hand types agents negotiation take time local deliberation faster 
distributed vehicle routing experiments showed bidding awarding previous bids pend opportunistic pricing leads contracts practice 
experiments confirm result bidding awarding previous bids pend leads monotonic decrease local cost 
methods best terms decreasing local cost depends problem problem instances chosen duration valid bidding window interleaving asynchronous messages happens occur 
experiments inconclusive regarding question 
section concluded discussion contracting implications limited computation presenting tradeoffs agent faces deciding bid award early wait 
section discussed distributed asynchronous implementation automated contracting 
message congestion agent saturation addressed 
classical solution approaches focused addressing audience restrictions viable self interested agents inherent tragedy commons agents care saturation 
protocol related solutions discussed communication charges mutual monitoring processing fees 
problem solved incorporating certain policies agent local strategy 
policies concert agent self interest need externally imposed 
local strategies completely solved congestion saturation problems experiments included reading incoming messages batches ignoring announcements older time limit 
second general issue distributed implementation section negotiation termination method iterative task reallocation contracting 
method terminates negotiations local optimum reached respect possibly restricted set clustering contracts 
assume common knowledge tasks 
method extended swaps multiagent contracts 
hand method guaranteed agents cooperative agents exactly compute marginal costs 
third general issue distributed implementation section compared reply timeout contracting protocols 
easier implement asynchronous manner viable self interested agents 
chapter analyzed coalition formation bounded rational agents 
agents coordinate computational real world actions coalition coalitions 
computation centralized coalition distributed coalitions 
analyzed collusion bounded rational agents quantitative model agents algorithms performance profiles computation unit cost 
formal model social welfare maximizing coalition structure determined performance profiles computation unit cost known 
example agents sent execute remote host computation unit cost necessarily known advance 
attack problem sufficient condition theorem performance profiles guarantees coalitions best merging computation unit cost execution platform 
follows best coalition structure grand coalition 
shown condition necessary condition general theorem performance profiles exhibit diminishing returns added computations theorem 
case design time algorithms anytime algorithms exhibit general character 
sufficient condition performance profiles guarantees agents best operating individually computation unit cost theorem 
stability coalition structure analyzed terms core solution concept 
structure considered stable agent subgroup group agents increase payoff breaking coalition structure forming new coalition 
formal model computational limitations stability coalition structure determined 
games stable coalition structures rational br agents 
theorems relating shapes performance profiles computation unit cost stability 
computation limitations agents best operating individually coalition structure stable theorem 
second necessary sufficient conditions coalition bounded rational values guarantee stability mentioned beneficial merging property bounded rational superadditivity holds theorem generally best coalition structure grand coalition theorem 
sufficient conditions performance profiles guarantee stability beneficial merging property holds theorem generally best coalition structure grand coalition theorem 
domain classification bounded rational agents 
related existing domain classifications fully rational agents traditional game theory rosenschein zlotkin 
domain classification carries information optimal coalition structure stability 
incorporates domain classes value coalition affected actions nonmembers 
games occur agents different optimization algorithms domain solution interactions vehicle routing problem real world problems 
games require different solution concept discussed section 
coalitions experimentally analyzed real world data distributed vehicle routing problem 
local routing algorithm iterative refinement 
experiments show computational limitations agents significantly impact coalition structure form stability 
beneficial merging property holds rational agents domains surprisingly obvious practice bounded rational agents 
vehicle routing games experiments exhibited property bounded rational agents 
optimal coalition structure bounded rational agents varied rational agents form grand coalition 
section developed conditions performance profiles guarantee beneficial merging property holds bounded rational agents 
discussed separate solving approach problem decomposition step guarantees base algorithm fulfills conditions 
reasonable deterministic iterative refinement algorithm conditions somewhat surprisingly met 
real desideratum necessarily generate algorithms guarantee beneficial merging superiority grand coalition coalition structures algorithms provide highest social welfare best coalition structure need grand coalition 
goals conflict 
experimental games agents best separately coalition structures stable theory predicts 
games subgroups necessarily best splitting coalition structures stable especially large computation unit costs 
experiments suggest superlinear iterative refinement steps low computation unit costs promote large coalitions high computation unit costs suggests smaller ones 
plausible explanation phenomenon 
interesting observation normative theory prescribes bounded rational agents choose coalition structures agree closely human agents select 
best coalition structures bounded rational agents agreed intuitions coalitions form strategic domain specific considerations adjacency dispatch centers loads 
hand coalition structures differ significantly rational agents choose 
chapter dissertation method carrying exchanges external enforcement 
exchanges split parts point agent motivated defect 
maximum size delivery supplier safely point exchange shown maximum amount demander safely pay 
possibility safe exchange depends demander agent supplier agent value functions goods contract 
safe exchange enhanced supplier incurs cost early portion exchange possibility demander acquires value early parts hinders safe exchange 
luckily practise supplier usually setup costs demander acquires value completion exchange 
isolated safe exchange carried entirely supplier deliver part cost 
isolated safe exchange possible strategies handle subgame perfect nash equilibrium minimal number steps theorems 
uncountable goods safe exchange carried arbitrarily close completion part delivered cost 
exchange possible strategies handle subgame perfect nash equilibrium minimal number steps theorems 
considering defection adverse effect negotiations enables completing exchange section 
conditions discount functions agents provably motivated carry isolated exchanges immediately 
strategies exchanges take place nash equilibrium minimal number steps theorems subgame perfect 
time discounts reduce viability advantage non isolated exchange theorem 
cases immediate moves stimulated deadlines lateness penalties need enforced section 
domains allow goods delivered different chunks batches chunks delivered different sequences 
top bottom chunking algorithm relative merits discussed 
non trivial quadratic algorithm algorithm sequencing independent chunks 
proven find safe sequence exists theorem 
general problem solved polynomial time number chunks chunks interdependent 
showed safe exchange helps prevent unfair renegotiation 
research research automated contracting includes extending marginal cost implementation game theoretic setting agents may lie marginal costs look ahead contracting process 
include normative methods local deliberation scheduling 
explicit strategies striking optimal tradeoffs marginal cost deliberation monetary risk devised case agent engages multiple negotiations simultaneously case 
contracting implementation set csm contracts scheduling policies applying contracts desirable 
useful implement negotiation termination protocol clustering contracts extend swaps multiagent contracts 
termination protocols guaranteed self interested computationally limited agents devised 
desirable develop implementation contracting purely deadlines reply messages 
interesting apply technologies developed dissertation negotiation domains 
host interesting open research issues leveled commitment contracts 
study closely best pace increase decommitment penalties time occurring events 
normative theory relating performance profiles algorithms bounded rational agents issue leveled commitment desirable 
interesting study leveled commitment contracts perspective society agents agents making contract 
finding optimal decommitment penalties perspectives desirable bargaining process choosing individually rational contracts addressed 
relationship leveled commitment contracting explicit csm contracts studied detail 
model bounded rationality coalition formation costly computation resources 
includes analyzing model agent fixed free cpu cpu time bought 
domain cost increases real time due dynamic environment agents bounded computational capabilities best distributing computation 
costly computation model coalition formation chapter dissertation best allocate coalition computation single agent 
models equivalent domain cost increases linearly real time distribution speed computation 
extensions coalition formation include generalizing methods agents different performance profiles probabilistic performance profiles anytime algorithms performance profiles conditioned execution far sandholm lesser zilberstein 
agents probabilistic performance profiles may want coalition value original coalition lower expected sunk computation cost incurred 
research includes studying agents refine solutions generated development interaction protocols efficiently guide self interested agents optimal stable possible coalition structures determined theory developed dissertation 
area contract execution looked totally safe exchanges agent knew opponent value function discount functions defection penalty cost making reputation worse 
explained agents bounds exactly known 
bounds far possible exchanges disabled 
case agents estimate distribution strict bounds available bounds far allow unenforced exchange 
distributions agents take calculated risk making moves unsafe certain probability 
approach distributions useful agent trying model possibility changes opponent value function discount functions defection penalty happen exchange due opponent interacting environment getting offers contracts receiving domain events alter value function 
approach try bound losses making partial exchanges small opponent defects loss bound 
probabilistic risk method loss bounding method tradeoff making exchange safer small partial exchanges minimizing partitioning costs physical part delivery costs large ones 
research include studying unenforced exchange transaction costs explicitly modeled 
probabilistic approach loss bounding approach address risk opponent accidentally defecting losing contact due technical fault 
research include designing polynomial algorithms special cases chunk sequencing problem case independent chunks 
appendix proofs intuition proof 
theorem 
example 
exists full commitment contract satisfies ir constraints require aef impossible 
analyze leveled commitment contract ae 
contractor ir constraint satisfied gamma gamma ae gamma gamma gamma gamma ae gamma gamma ae gamma gamma gamma gamma gamma gamma gamma gamma gamma pa ae gamma gamma gamma 
contractee ir constraint satisfied gamma pa ae pa gamma completes proof 
proof 
theorem 
contractor payoff gamma aef contractee aef construct leveled commitment contract defined ae aef gamma 
choose ae aef aef gamma ffl 
contractor decommits gamma gamma gamma ae ae gamma gamma ffl 
nonzero probability bounded gamma imply ffl gamma ffl gamma 
contractee expected payoff increased aef contractor decommit aef ffl aef contractor nonzero probability 
contractor expected payoff increased gamma aef ae gamma gamma gamma gamma ae gamma gamma ae ae gamma gamma gamma gamma aef implied gamma ffl gamma 
bounded probability mass single point ae gamma gamma ffl 
proof 
theorem 
say contractor information unbiased fa 
contractor expected payoff accepting contract gamma fa gamma contractor payoff full commitment contract gamma aef expected payoff leveled commitment contract ae gamma gamma fa gamma gamma ae gamma fa gamma ae depend contractee information 
say contractee information unbiased fb 
contractee payoff accepting contract payoff full commitment contract aef expected payoff leveled commitment contract gamma pa ae pa gamma ae gamma gamma fb ae ae gamma gamma fb 
depend contractor information 
proof 
theorem 
full commitment contract aef 
exists iff 
say assume contradiction leveled commitment contract defined ae satisfies ir constraints 
gamma ae gamma gamma ae ae gamma gamma ae gamma gamma ae gamma aed ae gamma gamma ae gamma gamma ae gamma gamma ae gamma gamma ad ae gamma gamma ad ar ae gamma gamma contradiction 
contract satisfies ir constraints 
proof 
theorem 
contractor payoff gamma aef contractee aef assume contradiction exists leveled commitment contract defined ae increases payoffs decreasing ae gamma gamma gamma gamma ae gamma gamma ae gamma aef gamma ae gamma gamma ae ae gamma gamma aef inequalities strict 
ae gamma gamma ae gamma aed gamma ae gamma gamma ae ae gamma gamma ae gamma gamma ad 
ae gamma gamma ae gamma gamma ad ar ae gamma gamma contradiction 
exists 
proof 
theorem 
full commitment contract satisfy ir constraints iff gamma fa ad say fa full commitment contract satisfies ir constraints 

follows theorem leveled commitment contract satisfies ir constraints 
full commitment contract satisfies pir constraint require aef ea 
show leveled commitment contract satisfies pir constraints 
fb contractee pir constraint gamma ae gamma gamma fb ae ae gamma gamma fb substituting ae gives gamma gamma gamma fb gamma gamma fb contractor pir constraint gamma ae gamma gamma fa gamma gamma ae gamma fa gamma ae substituting ae gives gamma gamma gamma fa gamma gamma gamma fa gamma gamma gamma gamma leveled commitment contract ae satisfies pir constraints 
proof 
theorem 
contractor expected payoff accepting contract gamma gamma contractor payoff full commitment contract gamma aef expected payoff leveled commitment contract ae gamma gamma gamma gamma ae gamma gamma ae depend contractee information 
contractee payoff accepting contract payoff full commitment contract aef expected payoff leveled commitment contract gamma ae gamma gamma ae ae gamma gamma 
depend contractor information 
proof 
corollary 
definition contract ir contractor preferred null deal 
theorem preference ordering unaffected contractee information 
similarly definition contract ir contractee preferred null deal 
theorem preference ordering affected contractor information 
proof 
theorem 

full commitment contract satisfy ir constraints require aef impossible 
choose leveled commitment contract ae 
lambda ae ae ae gamma gamma ae gamma delta ss 
contractor ir constraint lambda ae gamma gamma ad lambda ae gamma ae gamma gamma gamma gamma ae gamma gamma ae gamma gamma lambda ae gamma ad lambda ae gamma gamma gamma gamma gamma gamma lambda ae gamma delta lambda ae gamma gamma delta gamma delta gamma gamma lambda ae lambda ae gamma gamma substituting lambda ae gives approximately gamma gamma gamma inequality 
contractor ir constraint satisfied 
contractee ir constraint lambda ae gamma lambda ae gamma ae gamma gamma ae gamma aed gamma bd lambda ae gamma lambda ae gamma gamma lambda ae gamma lambda ae lambda ae gamma lambda ae bd substituting lambda ae gives approximately inequality 
contractee ir constraint satisfied 
proof 
theorem 
prove condition 
proof analogous 
contractor payoff gamma aef contractee aef construct leveled commitment contract contractee surely decommit penalty chosen high bounded 
choose ae aef aef gamma ffl 
contractor decommits gamma gamma gamma ae ae gamma gamma ffl 
nonzero probability bounded gamma imply ffl gamma ffl gamma 
contractee expected payoff increased aef contractor decommit aef ffl aef contractor 
contractor expected payoff increased gamma aef ae gamma gamma gamma gamma ae gamma gamma ae ae gamma gamma gamma gamma aef implied gamma ffl gamma bounded probability mass single point ae gamma gamma ffl 
proof 
theorem 
proof theorem leveled commitment contract constructed agent sure decommit 
agent known decommit games equivalent games 
proof theorem applies 
proof 
theorem 
proof theorem leveled commitment contract constructed agent sure decommit 
agent known decommit games equivalent games 
proof theorem applies 
proof 
theorem 
csm contract move iterative refinement search focus task allocation single step single contract 
optimal task allocation reached task allocation local optima 
hill climbing algorithm need backtrack order reach global optimum 
agents individually rational contracts contract improvement social welfare 
task allocation visited 
finite number tasks agents finite number task allocations 
follows global optimum reached finite number steps 
proof 
theorem 
analyze arbitrary potential coalitions 
conditions theorem state rs rt cs rs rt cs rs ct rt obviously cs ccomp delta ct ccomp delta minr cs ccomp delta minr ct ccomp delta follows cs ccomp delta minr cs ccomp delta minr ct ccomp delta cs ccomp delta minr cs ccomp delta minr ct ccomp delta minr cs ccomp delta minr cs ccomp delta minr ct ccomp delta vs ccomp vs ccomp vt ccomp completes proof 
proof 
theorem 
counterexample 
analyze agent game 
performance profiles algorithms cf cf gamma cf gamma see ccomp ccomp ccomp ccomp ccomp 
performance profiles value functions counterexample 
vf ccomp vf ccomp gamma minr cf ccomp delta gamma ccomp ccomp gamma ccomp vf ccomp gamma minr cf ccomp delta gamma ccomp ccomp gamma comp ccomp vf ccomp gamma ccomp gamma ccomp gamma ccomp vf ccomp vf ccomp ccomp vf ccomp gamma gamma gamma vf ccomp vf ccomp ccomp vs ccomp vs ccomp vt ccomp game brsup ccomp 
cf cf cf 
proof theorem relies lemma lemma decreasing convex function 
lambda minx cx lambda cx lambda proof 
lemma 
define cx 
assume contradiction lambda minx cx lambda cx lambda cx lambda cx lambda convex lambda lambda gamma ffi lambda ffi lambda gamma lambda gamma ffi ffi lambda ffi gamma lambda ffi defined chosen follows lambda gamma lambda gamma ffi ffi gamma lambda ffi gamma lambda ffi cases case lambda lambda argmin cx lambda argmin cx delta cx lambda cx lambda cx lambda cx lambda lambda gamma ffl delta lambda gamma ffl lambda cx lambda lambda gamma lambda gamma ffl gamma cffl lambda gamma lambda gamma ffl ffl gamma lambda gamma lambda gamma ffl ffl lambda gamma lambda gamma ffi ffi violates convexity 
contradiction 
case lambda lambda argmin cx lambda argmin cx delta cx lambda cx lambda cx lambda cx lambda lambda ffl delta lambda ffl lambda cx lambda lambda ffl gamma lambda ffl gamma lambda ffl gamma lambda ffl lambda ffi gamma lambda ffi violates convexity 
contradiction 
cases lead contradiction original assumption false 
proof 
theorem 
part proven theorem 
part proven 
game brsup ccomp ccomp vs ccomp vs ccomp vt ccomp ccomp minr cs ccomp delta minr cs ccomp delta minr ct ccomp delta ccomp rs rt minr cs ccomp delta cs rs ccomp delta rs ct rt ccomp delta rt lemma rs rt ccomp minr cs ccomp delta cs rs rt ccomp delta rs rt 
rs rt ccomp cs rs rt ccomp delta rs rt cs rs ccomp delta rs ct rt ccomp delta rt rs rt ccomp cs rs rt cs rs ct rt rs rt cs rs rt cs rs ct rt completes proof 
proof 
theorem 
rs rt cs rs rt cs rs ct rt rs rs cs rs cs rs ct rs gamma rs ccomp rs rs cs rs ccomp delta rs cs rs ccomp delta rs ct rs gamma rs ccomp delta rs gamma rs ccomp rs rs minr cs ccomp delta cs rs ccomp delta rs ct rs gamma rs ccomp delta rs gamma rs minr cs ccomp delta minr ct ccomp delta ccomp vs ccomp vs ccomp vt ccomp game bounded rational subadditive ccomp completes proof 
proof 
theorem 
analyze game bounded rational subadditive ccomp 
vs ccomp vs ccomp vt ccomp 
study coalition structure cs lambda ff 
choose xi ccomp 
xi ccomp cs lambda ccomp ae xi ccomp vs ccomp brc ccomp implies brc ccomp 
proof 
theorem 
shapley shapley proved fact theorem rational agents 
games csr lambda fag iff minimal balanced set fb bpg 
theorem follows analogy 
proof 
theorem 
shapley shapley proved fact theorem rational agents 
superadditive game iff proper minimal balanced set fb bpg charnes charnes proved set inequalities minimal 
theorem follows analogy 
proof 
theorem 
analyze arbitrary minimal balanced set fb bpg 
rb px ca px ccomp rb ra px cbj ccomp delta gamma ra px ca ra ccomp rb ra px cbj ccomp delta px ca ra ccomp delta ra ccomp rb px cbj ccomp delta px minr ca ccomp delta ccomp rb px cbj ccomp delta minr ca ccomp delta ccomp px minr bj bj bj ccomp delta bj minr ca ccomp delta ccomp px ccomp va ccomp holds arbitrary minimal balanced set hold minimal balanced set 
theorem brc ccomp 
proof 
theorem 
analogous proof theorem arbitrary proper minimal balanced set considered 
furthermore theorem changed theorem 
proof 
theorem 
proven exchange completed starting subgame xn pn xn pmin xn pn pmax xn 
inequalities pn preserved ss sd remaining example path starting xn pn fig 
middle 
point xn pn agents strategies prescribe xn pn maxfx xjpmin png pmax xn reached 
denote size smallest possible due finite number countable goods delivery xn delta cases 
case demander pn pmin xn delta xn pn xn pmax xn 
result pn pmax xn pmin xn delta conditions second case fulfilled indexes incremented 
second case supplier pn pmin xn delta xn pn maxfx xjpmin png pmax xn 
case xn xn delta xn pn pmin xn delta 
point xn pn pmin xn pn pmax xn exchange proceed axis delta steps depending case reached 
finite number countable goods finite number delta potentially different sizes finite number steps reached 
strategies preserved pmin xn pn pmax xn 
follows fact pmin pmax pcontr point pcontr reached finite number steps 
show ss best response sd 
subgame pmin xn pn pn pmax xn sd specifies demander going pay 
supplier best response obviously deliver exit 
analyze subgames pmin xn pn pmax xn 
defecting gives supplier remaining benefit pmax xn gamma pn supplier deliver demander pays step increasing total payment pmax xn sd 
cooperating rest exchange ss gives supplier remaining benefit pcontr gamma pn gamma vs vs xn exchange completed shown earlier 
definition pmax xn pcontr gamma vs vs xn benefit exiting pmax xn gamma pn equals benefit cooperating rest exchange pcontr gamma pn gamma vs vs xn 
starting point pmin xn pn pmax xn strategies ss sd agents preserve property pmin xk pk pmax xk step shown subgame supplier motivated exit cooperating rest exchange supplier best response sd starting subgame pmin xn pn pmax xn 
put ss supplier best response demander strategy sd subgame 
show sd best response ss 
subgame pmin xn pn pn pmax xn ss specifies supplier going deliver 
demander best response obviously pay exit 
analyze subgames pmin xn pn pmax xn 
defecting gives demander remaining benefit vd maxfx xjpmin png gamma vd xn demander pay supplier delivers ss step 
definition pmin benefit rewritten vd maxfx gamma vd vd png gamma vd xn pn gamma pcontr vd gamma vd xn 
cooperating rest exchange sd gives demander remaining benefit vd gamma vd xn gamma pcontr pn exchange completed shown earlier 
demander benefit exiting greater benefit cooperating rest exchange 
starting point pmin xn pn pmax xn strategies ss sd agents preserve property pmin xk pk pmax xk step shown subgame demander motivated exit cooperating rest exchange demander best response ss starting subgame pmin xn pn pmax xn 
put sd demander best response supplier strategy ss subgame 
show subgame perfect nash equilibrium leading completion fewer steps 
supplier strategy specifies xn maxfx xjpmin png maxfx gamma vd vd png demander payoff defecting keeping total payment pn vd xn gamma vd xn pn gamma pcontr vd gamma vd xn 
demander payoff cooperating exchange vd gamma vd xn gamma pcontr pn demander defect 
subgame perfect nash equilibrium point supplier deliver specified ss 
likewise demander strategy specifies pn pmax xn supplier payoff defecting keeping total delivery xn pn gamma pn pmax xn gamma pn pcontr gamma vs vs xn gamma pn 
supplier payoff cooperating exchange pcontr gamma vs vs xn gamma pn supplier defect 
subgame perfect nash equilibrium point demander pay prescribed sd 
exchange begins 
induction step assume point xq pq reached xq ss sd pq ss sd xq maxfx xjpmin maxfx xjpmin ss sd ss sd similarly pq pmax xq pmax 
proves subgame perfect nash equilibrium path leads completion fewer steps induced ss sd 
proof 
theorem 
consecutive amounts cumulative delivery pmax pmin 
point pmax exchange proceed completion pcontr supplier remaining payoff cooperating completion pcontr gamma gamma vs vs pcontr gamma pmax gamma vs vs remaining payoff defecting 
point pmin exchange proceed completion pcontr demander remaining payoff cooperating completion vd gamma vd gamma pcontr vd gamma vd gamma pcontr pmin remaining payoff defecting 
analyze arbitrary point pmax 
point move supplier increases cumulative delivery leads point pmax pmin region demander motivated complete exchange 
demander knows best response strategy prescribe simultaneous move pay region reached 
similarly move demander increases cumulative payment pmax leads point pmax region supplier motivated complete exchange 
supplier knows best response strategy prescribe simultaneous move deliver region reached 
agent move pmax causing agent defect 
exchange completed 
proof 
theorem 
proven exchange completed finite number steps starts subgame xn pn xn pmin xn pn pmax xn 
obviously inequalities preserved remaining strategies sd exchange 
point xn pn agents strategies prescribe point xn pn 
cases depending maxfx xjpmin png defined subcases max defined case passes current move case xn maxfx xjpmin png pn pmax xn 
xn pn xn delta pmax xn delta 
point xn pn reached xn xjpmin pn gamma ffl xjpmin pmax xn gamma ffl min xn ffl gamma ffl 
amount ffl gamma ffl delivered steps exchange reached 
max defined case supplier passes current move case xn maxfx xjpmin png pn pmax xn 
xn pn xn pmax xn 
point xn pn reached pn pn pmax xn xn xjpmin pmax xn gamma ffl min xn ffl gamma ffl 
amount ffl gamma ffl delivered steps exchange reached 
max defined case demander passes current move case pn pmax xn xn maxfx xjpmin png 
point xn pn xn pn reached xn xjpmin pmax xn gamma ffl min xn ffl gamma ffl 
amount ffl gamma ffl delivered step exchange reached 
note point xn pcontr pmax xn pcontr xn maxfx xjpmin png exchange completed 
max defined case completion case pn pmax xn xn maxfx xjpmin png 
xn pn pcontr exchange completed 
max undefined case passes current move case xn xjpmin png gamma ffl pn pmax xn 
xn pn xn delta pmax xn delta 
point xn pn reached xn xjpmin pn gamma ffl xjpmin pmax xn gamma ffl min xn ffl gamma ffl 
amount ffl gamma ffl delivered steps exchange reached 
max undefined case supplier passes current move case xn xjpmin png gamma ffl pn pmax xn 
note pmin xn pn holds xn xjpmin png 
xn pn xn pmax xn 
point xn pn reached pn pn pmax xn xn xjpmin pmax xn gamma ffl min xn ffl gamma ffl 
amount ffl gamma ffl delivered steps exchange reached 
max undefined case demander passes current move case pn pmax xn xn xjpmin png gamma ffl 
point xn pn xn pn reached xn xjpmin pmax xn gamma ffl min xn ffl gamma ffl 
amount ffl gamma ffl delivered step exchange reached 
case extends cumulative delivery fixed amount ffl gamma ffl steps reached finite number steps 
strategies preserved pmin xn pn pmax xn 
follows fact pmin pmax pcontr point pcontr reached exchange completed finite number steps 
proven exchange completed finite number steps arguments proof theorem suffice prove best response sd subgame 
show sd best response subgame pmin xn pn pn pmax xn specifies supplier going deliver 
demander best response obviously pay exit 
analyze subgames pmin xn pn pmax xn 
demander defects pays supplier delivers step 
demander remaining payoff vd maxfx xjpmin png gamma vd xn vd maxfx gamma vd vd png gamma vd xn pn gamma pcontr vd gamma vd xn result max operator defined 
demander payoff vd max xn xjpmin png gamma ffl gamma vd xn vd max xn gamma vd vd png gamma ffl gamma vd xn pn gamma pcontr vd gamma vd xn 
case demander payoff defecting greater pn gamma pcontr vd gamma vd xn 
cooperating rest exchange sd gives demander remaining benefit vd gamma vd xn gamma pcontr pn exchange completed shown earlier 
demander benefit exiting greater benefit cooperating rest exchange 
starting point pmin xn pn pmax xn strategies sd agents preserve property pmin xk pk pmax xk step shown subgame demander motivated exit cooperating rest exchange demander best response starting subgame pmin xn pn pmax xn 
put sd demander best response supplier strategy subgame 
show ffl lambda ffl ffl ffl lambda exchange minimal number steps subgame perfect nash equilibrium exchanges 
strategies lead subgame perfect completion exchange minimal number steps 
minimum exists number steps bounded zero 
supplier strategy specifies xn maxfx xjpmin png maxfx gamma vd vd png demander payoff defecting keeping total payment pn vd xn gamma vd xn pn gamma pcontr vd gamma vd xn 
supplier strategy specifies max undefined xn xjpmin png gamma vd vd png demander payoff defecting keeping total payment pn vd xn gamma vd xn pn gamma pcontr vd gamma vd xn inequality strict max undefined 
demander payoff cooperating exchange vd gamma vd xn gamma pcontr pn demander defect 
subgame perfect nash equilibrium point supplier deliver specified parameterized arbitrarily small ffl 
likewise demander strategy specifies pn pmax xn supplier payoff defecting keeping total delivery xn pn gamma pn pmax xn gamma pn pcontr gamma vs vs xn gamma pn 
supplier payoff cooperating exchange pcontr gamma vs vs xn gamma pn supplier defect 
subgame perfect nash equilibrium point demander pay prescribed sd 
exchange begins 
induction step assume point reached sd sd pmax pmax sd sd similarly maxfx xjpmin maxfx xjpmin sd sd max defined 
max undefined xjpmin xjpmin gamma ffi xjpmin sd gamma ffi ffl chosen equal ffi follows sd path play induced sd finite number steps path play induced minimal just finite number steps 
finite number ffi 
choose ffl lambda equal smallest ffi 
choosing ffl ffl lambda step induction follows step exchange point exchange sd ss un sd induce path minimal steps 
remains proven choosing ffl ffl lambda increase number steps exchange 
denote sun ffl ffl lambda sun ffl ffl lambda exchange begins 
induction step assume point un sun reached sun un sd un un sd un pmax sun pmax un sd un sd similarly un maxfx xjpmin sun maxfx xjpmin un sd un sd max defined 
max undefined un xjpmin sun gamma ffl lambda un completes proof 
proof 
theorem 
subgame perfect nash equilibrium leading completion exchange finite number steps ffl supplier smallest move equilibrium path 
pmax lambda pmin lambda ffl proof theorem substituting lambda lambda ffl show subgame perfect nash equilibrium leading completion 
theorem lambda ffl 
proof 
theorem 
proof theorem suffices show exchange completed minimal finite number steps strategies strategies identical ss sd strategies explicitly specify immediate moves 
due prescription exchange completed immediately tn 
shown best response vice versa subgame xn pn tn xn pmin xn pn pmax xn tn 
strategies subgames type reached 
equilibrium remain equilibrium subgame reached 
proven supplier best response subgame pmin xn pn pmax xn tn strategy remaining payoff ss xn pn pcontr gamma pn gamma vs vs xn pcontr gamma pmax xn gamma gamma vs vs xn pcontr gamma pcontr gamma vs vs xn gamma gamma vs vs xn vs xn gamma vs xn gamma exchange completed immediately 
avoid handling exchange special case define vs gamma pmax gamma 
vs gamma vs gamma pcontr 
analyze remaining payoff arbitrarily chosen strategy supplier 
path play induced defined xn xn tn tn fn xk xk tk tk 
model incorporates possibility xq xq limm xm tq tq limm tm deliveries finite step exchange possibly finite time 
note demander move pk pmax xk immediately supplier move time tk 
ss xn pn ps tk pk gamma pk gamma vs tk vs xk gamma vs xk ps tk vs xk gamma vs xk gamma gamma vs tk vs xk gamma vs xk ps tk vs xk gamma vs xk gamma gamma ps tk vs xk gamma vs xk limm mx ps tk vs xk gamma vs xk gamma gamma ps tk vs xk gamma vs xk limm ps tn delta gamma vs xn gamma ps tm vs xm ps tn vs xn gamma ps tm vs xm gamma ps tk gamma ps tk vs xk ps tk gamma ps tk vs xk limm ps tn delta gamma vs xn gamma ps tm vs xm ps tn vs xn gamma ps tm vs xm ps tn gamma ps tn vs xn ps tm gamma ps tm vs xm limm ps tn vs xn gamma vs xn gamma ps tm vs xm gamma vs xm ps tn vs xn gamma vs xn gamma vs xn gamma vs xn gamma ss xn pn remaining payoff arbitrary strategy better remaining payoff best response shown demander best response subgame pmin xn pn pmax xn tn strategy remaining payoff ss xn pn vd gamma vd xn gamma pcontr gamma pn exchange completed immediately 
analyze remaining payoff arbitrarily chosen strategy demander 
path play induced defined pn pn tn tn fn pk pk tk tk 
model incorporates possibility pq pq limm pm tq tq limm tm payments finite step exchange possibly finite time 
note supplier moves xk immediately demander moved pk time tk 
ss xn pn vd tk vd xk gamma vd xk gamma pd tk pk gamma pk pd tk vd xk gamma vd xk gamma pd tk pk gamma pk limm mx pd tk vd xk gamma vd xk gamma pd tk pk gamma pk limm gamma pd tn vd xn pd tm vd xm pd tn pn gamma pd tm pm gamma pd tk gamma pd tk vd xk gamma pd tk gamma pd tk pk fact vd xk vd maxfx xjpmin pkg vd maxfx gamma vd vd pkg pk gamma pcontr vd 
limm gamma pd tn vd xn pd tm vd xm pd tn pn gamma pd tm pm gamma pd tk gamma pd tk pk gamma pcontr vd gamma pd tk gamma pd tk pk limm gamma pd tn vd xn pd tm vd xm pd tn pn gamma pd tm pm gamma pd tk gamma pd tk vd gamma pcontr gamma pd tk gamma pd tk pk gamma pd tk gamma pd tk pk limm gamma pd tn vd xn pd tm vd xm pd tn pn gamma pd tm pm pd tn gamma pd tm vd gamma pcontr pd tn gamma pd tn pn gamma pd tm gamma pd tm pm limm gamma pd tn vd xn pd tm pm gamma pcontr vd pd tn pn gamma pd tm pm pd tn gamma pd tm vd gamma pcontr pd tn gamma pd tn pn gamma pd tm gamma pd tm pm limm pd tn gamma vd xn gamma pcontr vd pn pd tm pm gamma pm pd tn gamma vd xn gamma pcontr vd pn gamma vd xn gamma pcontr vd pn ss xn pn remaining payoff arbitrary strategy better remaining payoff best response proof 
theorem 
example subgame xn pn tn tn ps tn vs tn vs xn vs pmin xn pn pmax xn pcontr supplier motivated proceed immediately payment demander compensate cost incurred supplier delivering ps tn 
supplier best strategy subgame 
proof 
theorem 
proof theorem suffices show exchange completed minimal finite number steps strategies strategies identical sd strategies explicitly specify immediate moves 
due prescription exchange completed immediately tn 
proof theorem shown best response subgame xn pn tn xn pmin xn pn pmax xn tn 
proof show fact just replacing place strategies subgames type reached 
equilibrium remain equilibrium subgame reached 
remains shown demander best response subgame xn pn tn xn pmin xn pn pmax xn tn 
subgame mentioned type remaining payoff ss xn pn vd gamma vd xn gamma pcontr gamma pn exchange completed immediately 
analyze remaining payoff arbitrarily chosen strategy demander 
path play induced defined pn pn tn tn fn gamma pk pk tk tk 
model allows possibility pq pq limm pm tq tq limm tm payments finite step exchange possibly finite time 
note supplier moves xk immediately demander moved pk time tk 
ss xn pn vd tk vd xk gamma vd xk gamma pd tk pk gamma pk pd tk vd xk gamma vd xk gamma pd tk pk gamma pk limm mx pd tk vd xk gamma vd xk gamma pd tk pk gamma pk limm gamma pd tn vd xn pd tm vd xm pd tn pn gamma pd tm pm gamma pd tk gamma pd tk vd xk gamma pd tk gamma pd tk pk knowledge prescribes vd xk 
max operator defined value vd xk vd maxfx xjpmin pkg vd maxfx gamma vd vd pkg pk gamma pcontr vd 
max operator undefined value vd xk vd max xk xjpmin pkg gamma ffl vd max xk gamma vd vd pkg gamma ffl pk gamma pcontr vd 
case vd xk pk gamma pcontr vd 
substitute limm gamma pd tn vd xn pd tm vd xm pd tn pn gamma pd tm pm gamma pd tk gamma pd tk pk gamma pcontr vd gamma pd tk gamma pd tk pk limm gamma pd tn vd xn pd tm vd xm pd tn pn gamma pd tm pm gamma pd tk gamma pd tk vd gamma pcontr gamma pd tk gamma pd tk pk gamma pd tk gamma pd tk pk limm gamma pd tn vd xn pd tm vd xm pd tn pn gamma pd tm pm pd tn gamma pd tm vd gamma pcontr pd tn gamma pd tn pn gamma pd tm gamma pd tm pm limm gamma pd tn vd xn pd tm pm gamma pcontr vd pd tn pn gamma pd tm pm pd tn gamma pd tm vd gamma pcontr pd tn gamma pd tn pn gamma pd tm gamma pd tm pm limm pd tn gamma vd xn gamma pcontr vd pn pd tm pm gamma pm pd tn gamma vd xn gamma pcontr vd pn gamma vd xn gamma pcontr vd pn ss xn pn remaining payoff arbitrary strategy better remaining payoff best response proof 
theorem 
counterexample proof theorem applies 
proof 
theorem 
case supplier delays proven 
assume contradiction subgame xn pn tn pmax xn pn pmax nash equilibrium arbitrary strategies remains equilibrium subgame reached results reaching pcontr ps limm ps tm 
equilibrium path defined xn xn pn pn tn tn limm tm finite limm ps tm limm vs tm limm xm limm pm pcontr 
define shorthand notation ss xq pq tq ps tk pk gamma pk gamma vs tk vs xk gamma vs xk pq pq gamma tq gamma vs tq vs xq gamma vs xq ps tq ps tq pq gamma vs xq gamma vs xq gamma tq applying recursively infinity gives pn limm pm mx gamma xq gamma vs xq mx gamma ps tq limm pm gamma vs xm vs xn mx gamma ps tq limm pcontr gamma vs vs xn gamma tn ps tm mx ps tq gamma ps tq hand postponing infinitely supplier incur costs delivering limt vs 
ss xq pq tq ps tq pq gamma pq equilibrium remain equilibrium subgame reached hold subgames worse postponing infinitely ss xq pq tq ss xq pq tq fact pn limm pcontr gamma vs vs xn gamma tn tm mx ps tq gamma ps tq pcontr gamma vs vs xn limm tm pcontr gamma vs vs xn limm tm pcontr gamma vs vs xn limm ps tk pk gamma pk gamma vs tk vs xk gamma vs xk ps tm pcontr gamma vs vs xn limm pk gamma pk ps tm pcontr gamma vs vs xn limm limn pn gamma pmf tm pcontr gamma vs vs xn contr gamma pcontr limm ps tm pcontr gamma vs vs xn pmax xn contradicts assumption pmax xn pn 
equilibrium exists 
analyze case demander 
assume contradiction subgame xn pn tn pmin pn pmin xn nash equilibrium arbitrary strategies remains equilibrium subgame reached results reaching pcontr vd limm vd tm 
equilibrium path defined xn xn pn pn tn tn limm tm finite limm vd tm limm pd tm limm xm limm pm pcontr 
define shorthand ss xq pq tq vd tk vd xk gamma vd xk gamma pd tk pk gamma pk pq pq tq gamma vd tq vd xq gamma vd xq pd tq gamma pd tq pq gamma vd xq gamma vd xq gamma tq applying recursively infinity gives pn limm pm mx gamma xq gamma vd xq mx gamma pd tq limm pm gamma vd xm vd xn mx gamma pd tq limm pcontr gamma vd vd xn tn gamma pd tm mx pd tq gamma pd tq hand postponing infinitely demander incur costs paying limt pd 
ss xq pq tq pd tq vd xq gamma vd xq equilibrium remain equilibrium subgame reached hold subgames worse postponing infinitely ss xq pq tq ss xq pq tq fact pn limm pcontr gamma vd vd xn tn gamma tm mx pd tq gamma pd tq pcontr gamma vd vd xn gamma limm tm pcontr gamma vd vd xn gamma limm tm pcontr gamma vd vd xn limm vd tk vd xk gamma vd xk gamma tk pk gamma pk ps tm pcontr gamma vd vd xn limm pk gamma pk ps tm pcontr gamma vd vd xn limm limn pm gamma pn tm pcontr gamma vd vd xn contr gamma pcontr limm ps tm pcontr gamma vd vd xn pmin xn contradicts assumption pmin xn pn 
equilibrium exists 
proof 
theorem 
steps take time 
steps take jcj time 
steps take jcj time 
entire algorithm terminates jcj time 
remains proven algorithm finds safe sequence exists 
check step violate property agents strategies ss sd specify agents exit point safe exchange impossible 
show algorithm finds sequence min pmax pcontr pmin consecutive sequence exists suffices show pmax pmin consecutive 
hold pcontr pmin safe sequence exist 
call sequence goods algorithm suggests case algorithm terminated saying solution partial sequence 
assume contradiction safe sequence acceptable 
fulfills requirement subsequent pmax pmin 
prove reordered maintaining acceptability chunks delta gamma delta lie delta gamma delta 
take pair chunks ci cj delta gamma delta delta gamma delta ci assigned right cj 
swap ci cj 
affect pmax pmin pair 
cj moved ci ci pmax gamma pmin smaller 
ci moved cj cj pmax gamma pmin larger 
apply swaps desired property holds 
call new sequence 
denote sequence chunks delta gamma delta corresponding part sequence pos 
show pos converted losing acceptability 
position pos differ 
si item position item pos position position si allocated pos 
swap pos 
moved position algorithm allocated having checked feasibility 
moved position chunks pos increased pmax gamma pmin 
swap increase pmax gamma pmin position chunk feasible earlier infeasible 
apply swaps pos 
denote sequence chunks delta gamma delta corresponding part sequence neg 
show neg converted losing acceptability 
position neg differ 
si item position item neg position position si allocated neg 
swap neg 
moved position algorithm allocated having checked feasibility 
moved position chunks neg decreased pmax gamma pmin 
swap increase pmax gamma pmin position chunk feasible earlier infeasible 
apply swaps neg 
safe sequence iff earlier showed safe sequence iff words safe sequence iff contradicts assumption completes proof 
abreu rubinstein dilip abreu ariel rubinstein 
structure nash equilibrium repeated games finite automata 
econometrica 
going going gone 
survey auction types 
www com auctions bibliography html 
arrow kenneth arrow 
social choice individual values 
new haven foundation nd edition 
st edition 
aumann aumann 
acceptable points general cooperative person games 
volume iv contributions theory games 
princeton university press 
axelrod robert axelrod 
evolution cooperation 
basic books 
whinston douglas michael whinston 
coalition proof nash equilibria ii applications 
journal economic theory june 
douglas peleg michael whinston 
coalition proof nash equilibria concepts 
journal economic theory june 
binmore ken binmore 
game theory social contract playing fair volume 
mit press 
boddy dean mark boddy thomas dean 
solving time dependent planning problems 
proceedings eleventh international joint conference artificial intelligence pages detroit mi august 
boddy dean mark boddy thomas dean 
deliberation scheduling problem solving time constrained environments 
artificial intelligence 
bond gasser alan bond les gasser 
readings distributed artificial intelligence 
morgan kaufmann publishers san mateo ca 

deviation proof plans open multiagent environments 
proceedings th european conference artificial intelligence pages august 
brooks rodney brooks 
robust layered control system mobile robot 
ieee journal robotics automation ra 
burke prosser peter burke patrick prosser 
distributed asynchronous scheduler 
monte zweben mark fox editors intelligent scheduling pages 
morgan kaufmann 
john joseph 
law contracts 
west publishing nd edition 
charnes charnes 
balanced sets cores linear programming 
technical report cornell univ dept industrial eng 
operations res ithaca ny 
cheng wellman john cheng michael wellman 
walras algorithm convergent distributed implementation general equilibrium outcomes 

submitted 
clarke clarke 
multipart pricing public goods 
public choice 
cohen levesque philip cohen hector levesque 
intention choice commitment 
proceedings national conference artificial intelligence pages july 
cohen levesque philip cohen hector levesque 
intention choice commitment 
artificial intelligence 
susan kuwabara victor lesser meyer 
multistage negotiation distributed satisfaction 
ieee transactions systems man cybernetics 
ambrosio bruce ambrosio 
resource bounded agents uncertain world 
proceedings workshop real time artificial intelligence problems ijcai detroit august 
davis smith randall davis reid smith 
negotiation metaphor distributed problem solving 
ai memo artificial intelligence laboratory massachusetts institute technology cambridge ma may 
published readings distributed artificial intelligence alan bond les gasser editors pages morgan kaufmann 
davis smith randall davis reid smith 
negotiation metaphor distributed problem solving 
artificial intelligence 
dean boddy thomas dean mark boddy 
analysis timedependent planning 
proceedings national conference artificial intelligence pages st paul mn august 
decker lesser keith decker victor lesser 
shot dynamic coordination algorithm distributed sensor networks 
proc 
eleventh national conference artificial intelligence aaai july 
decker lesser keith decker victor lesser 
quantitative modeling complex computational task environment 
proc 
eleventh national conference artificial intelligence aaai july 
decker lesser keith decker victor lesser 
designing family coordination algorithms 
proceedings international conference multi agent systems icmas pages san francisco ca june 
decker keith decker edmund durfee victor lesser 
evaluation research cooperative distributed problem solving 
michael huhns les gasser editors distributed artificial intelligence volume research notes artificial intelligence 
pitman 
drexler miller eric drexler mark miller 
incentive engineering computational resource management 
huberman editor ecology computation 
north holland 
durfee lesser edmund durfee victor lesser 
negotiating task decomposition allocation partial global planning 
les gasser michael huhns editors distributed artificial intelligence volume research notes artificial intelligence pages 
pitman 
durfee lesser edmund durfee victor lesser 
partial global planning coordination framework distributed hypothesis formation 
ieee transactions systems man cybernetics september 
durfee durfee lesser corkill 
cooperative distributed problem solving 
barr cohen feigenbaum editors handbook artificial intelligence volume iv 
addison wesley 
durfee edmund durfee lee piotr gmytrasiewicz 
reciprocal rationality mixed strategy equilibria 
aaai pages washington dc july 
edelman joe edelman 
web page mention vickrey auction 
www cs dartmouth edu resume html 
ephrati rosenschein ephrati jeffrey rosenschein 
clarke tax consensus mechanism automated agents 
proceedings national conference artificial intelligence pages anaheim ca 
ephrati rosenschein ephrati jeffrey rosenschein 
multiagent planning dynamic search social consensus 
proceedings thirteenth international joint conference artificial intelligence pages chambery france 
ephrati rosenschein ephrati jeffrey rosenschein 
planning please agent intended plan 
group decision negotiation 
appear 
ephrati ephrati 
planning consensus autonomous agents 
phd thesis hebrew university 
ephrati ephrati 
non manipulable meeting scheduling system 
proc 
th international distributed artificial intelligence workshop lake washington july 
aaai press technical report ws 
fagin ronald fagin joseph halpern yoram moses moshe vardi 
reasoning knowledge 
mit press 
ferguson ferguson yemini 
microeconomic algorithms load balancing distributed computer systems 
proceedings ieee international conference distributed computer systems pages 
finin tim finin rich fritzson don mckay 
language protocol support intelligent agent interoperability 
proc 
ce washington conference june 
fischer klaus fischer org uller markus 
model cooperative transportation scheduling 
proceedings international conference multi agent systems icmas pages san francisco ca june 
friedman james friedman 
game theory applications economics 
oxford university press 
friend friend 
information processing approach small group interaction coalition formation game 
phd thesis carnegie mellon university 
fudenberg tirole drew fudenberg jean tirole 
game theory 
mit press 
garvey lesser alan garvey victor lesser 
design time real time scheduling 
ieee transactions systems man cybernetics 
garvey lesser alan garvey victor lesser 
survey research deliberative real time artificial intelligence 
real time systems 
gasser huhns les gasser michael huhns editors 
distributed artificial intelligence volume ii 
morgan kaufmann 
general magic general magic telescript technology foundation electronic marketplace 
white 
genesereth genesereth ginsberg rosenschein 
cooperation communications 
technical report stanford heuristic programming project computer science department stanford university stanford ca 
published readings distributed artificial intelligence alan bond les gasser editors pages morgan kaufmann 

manipulation voting schemes 
econometrica 
gilboa samet gilboa dov samet 
bounded versus unbounded rationality tyranny weak 
games economic behavior pages 
glance hogg glance tad hogg 
dilemmas computational societies 
proceedings international conference multiagent systems icmas pages san francisco ca 
gmytrasiewicz durfee gmytrasiewicz durfee 
logic knowledge belief recursive modeling preliminary report 
proceedings national conference artificial intelligence pages july 
gmytrasiewicz durfee gmytrasiewicz durfee 
rigorous operational formalization recursive modeling 
proceedings international conference multi agent systems icmas pages san francisco ca june 
irving 
principles rationality 
editors foundations statistical inference 
toronto holt rinehart winston 
grosz kraus barbara grosz sarit kraus 
collaborative plans group activities 
proceedings thirteenth international joint conference artificial intelligence pages chambery france 
groves ledyard theodore groves john ledyard 
optimal allocation public goods solution free rider problem 
econometrica 
gu ishida cheng gu toru ishida 
quantitative analysis contract net protocol 
proceedings international conference multi agent systems icmas page san francisco ca june 
poster 
hansen zilberstein eric hansen shlomo zilberstein 
monitoring progress anytime problem solving 
proceedings national conference artificial intelligence pages portland august 
hardin hardin 
tragedy commons 
science 
heiner ronald heiner 
origin predictable behavior 
american economic review september 
heiner ronald heiner 
origin predictable behavior modeling applications 
american economic review 
hogg tad hogg 
social dilemmas computational ecosystems 
proceedings fourteenth international joint conference artificial intelligence pages montreal canada 
horvitz horvitz 
reasoning beliefs actions computational resource constraints 
proceedings third workshop uncertainty artificial intelligence pages seattle washington july 
american association artificial intelligence 
kanal levitt lemmer ed uncertainty artificial intelligence elsevier pps 

horvitz horvitz 
reasoning varying uncertain resource constraints 
proceedings national conference artificial intelligence pages st paul mn august 
morgan kaufmann san mateo ca 
howard nigel howard 
paradoxes rationality theory political behavior 
mit press 
huberman clearwater bernardo huberman scott clearwater 
multi agent system controlling building environments 
proceedings international conference multi agent systems icmas pages san francisco ca june 
huberman hogg bernardo huberman tad hogg 
behavior computational ecologies 
huberman editor ecology computation 
north holland 
huhns michael huhns editor 
distributed artificial intelligence 
morgan kaufmann 
kahan rapoport james kahan amnon rapoport 
theories coalition formation 
lawrence erlbaum associates publishers 
kalai stanford ehud kalai william stanford 
finite rationality interpersonal complexity repeated games 
econometrica pages 
kalai ehud kalai 
solutions bargaining problem 
leonid hurwicz david hugo editors social goals social organization essays memory chapter pages 
cambridge university press 
whinston ravi andrew whinston 
frontiers electronic commerce 
addison wesley publishing 
ketchpel steven ketchpel 
forming coalitions face uncertain rewards 
proceedings national conference artificial intelligence pages seattle wa july 
klusch matthias klusch onn 
coalitions formation rational information agents 
maamaw eindhoven netherlands january 
submitted 
kraus sarit kraus jonathan gilad zlotkin 
multiagent negotiation time constraints 
technical report university maryland college park computer science department 
kraus sarit kraus 
agents contracting tasks non collaborative environments 
proc 
eleventh national conference artificial intelligence aaai pages july 
kreps david kreps 
course microeconomic theory 
princeton university press 
kristol david kristol steven low nicholas maxemchuk 
anonymous internet protocol 

submitted 
kurose simha james kurose rahul simha 
microeconomic approach optimal resource allocation distributed computer systems 
ieee transactions computers 
kuwabara ishida kuwabara toru ishida 
symbiotic approach distributed resource allocation coordinated balancing 
proc 
maamaw 
kuwabara kuwabara toru ishida 
market distributed resource allocation approach 
lander lesser susan lander victor lesser 
understanding role negotiation distributed search heterogeneous agents 
proceedings thirteenth international joint conference artificial intelligence pages chambery france 
lax lax 
insecure contracts resource development 
public policy 
jacques peter 
pay auction approach reallocation 
proceedings th european conference artificial intelligence pages august 
lesser corkill victor lesser daniel corkill 
functionally accurate cooperative distributed systems 
ieee transactions systems man cybernetics smc november 
lesser corkill victor lesser daniel corkill 
distributed vehicle monitoring testbed tool investigating distributed problem solving networks 
ai magazine fall 
published blackboard systems robert engelmore anthony morgan editors pages addison wesley readings ai magazine volumes robert engelmore editor pages aaai menlo park california 
lesser erman victor lesser lee erman 
retrospective view hearsay ii architecture 
proceedings fifth international joint conference artificial intelligence pages cambridge ma august 
lesser erman victor lesser lee erman 
distributed interpretation model experiment 
ieee transactions computers december 
published readings distributed artificial intelligence alan bond les gasser editors pages morgan kaufmann 
lesser victor lesser edmund durfee 
approximate processing real time problem solving 
ai magazine spring 
lesser victor lesser 
retrospective view fa distributed problem solving 
ieee transactions systems man cybernetics 
lin kernighan lin kernighan 
effective heuristic procedure traveling salesman problem 
operations research 
jokinen tuomas sandholm ari 
advanced computer supported vehicle routing heavy transports 
finnish artificial intelligence conference step new directions artificial intelligence volume pages espoo finland 
low steven low nicholas maxemchuk sanjoy paul 
anonymous credit cards 

submitted 
low steven low nicholas maxemchuk sanjoy paul 
collusion multi party communication protocol anonymous credit cards 
ieee acm transactions networking 
submitted 
luce raiffa duncan luce howard raiffa 
games decisions 
john wiley sons new york 
dover 
lundgren lundgren 
basic vehicle routing game 
technical report link oping univ dept mathematics sweden 
mackie mason varian jeffrey mackie mason hal varian 
pricing internet 
proceedings public access internet conference 
jfk school government may 
mackie mason varian jeffrey mackie mason hal varian 
faqs usage pricing 
ftp alfred sims berkeley edu pub papers html 
malone malone fikes howard 
enterprise market task scheduler distributed computing environments 
working wp sloan wp center information systems research massachusetts institute technology cambridge ma 
malone malone fikes howard 
enterprise market task scheduler distributed computing environments 
huberman editor ecology computation 
north holland 
eric 
theory implementation nash equilibrium survey 
leonid hurwicz david hugo editors social goals social organization essays memory chapter pages 
cambridge university press 
mcafee mcmillan preston mcafee john mcmillan 
analyzing auction 
journal economic perspectives 
milgrom paul milgrom 
economics competitive bidding selective survey 
leonid hurwicz david hugo editors social goals social organization essays memory chapter pages 
cambridge university press 
miller drexler mark miller eric drexler 
comparative ecology computational perspective 
huberman editor ecology computation 
north holland 
miller drexler mark miller eric drexler 
markets computation open systems 
huberman editor ecology computation 
north holland 
victor lesser brandon 
decentralized negotiation approach distributed planning problem 
group decision negotiation 
mor rosenschein mor jeffrey rosenschein 
time prisoner dilemma 
proceedings international conference multiagent systems icmas pages san francisco ca 
morgenstern morgenstern 
formal theory multiple agent nonmonotonic reasoning 
proceedings national conference artificial intelligence pages boston ma 
moses tennenholtz yoram moses moshe tennenholtz 
line reasoning line efficiency 
proceedings thirteenth international joint conference artificial intelligence pages chambery france 
mullen wellman tracy mullen michael wellman 
simple computational market network information services 
proceedings international conference multi agent systems icmas pages san francisco ca june 
muller muller mark 
existence dominant strategy mechanisms 
leonid hurwicz david hugo editors social goals social organization essays memory chapter pages 
cambridge university press 
myerson roger myerson 
bayesian equilibrium incentive compatibility 
leonid hurwicz david hugo editors social goals social organization essays memory chapter pages 
cambridge university press 
nash john nash 
bargaining problem 
econometrica 
nash john nash 
equilibrium points person games 
proc 
national academy sciences 
neiman daniel neiman david victor lesser tuomas sandholm 
exploiting meta level information distributed scheduling system 
proc 
twelfth national conference artificial intelligence aaai august 
neyman neyman 
bounded complexity justifies cooperation finitely repeated prisoner dilemma 
economic letters pages 
office technology office technology 
electronic enterprises looking 
peter 
game theory political theory 
cambridge university press 
osborne rubinstein martin osborne ariel rubinstein 
bargaining markets 
academic press 
osborne rubinstein martin osborne ariel rubinstein 
course game theory 
mit press 
papadimitriou yannakakis papadimitriou yannakakis 
optimization approximation complexity classes 
journal computer system sciences 
papadimitriou yannakakis christos papadimitriou yannakakis 
complexity bounded rationality 
stoc pages 
posner richard posner 
economic analysis law 
little brown nd edition 
andrew 
implementation nash equilibria economic environments 
leonid hurwicz david hugo editors social goals social organization essays memory chapter pages 
cambridge university press 
raiffa raiffa 
art science negotiation 
harvard univ press cambridge mass 
rao georgeff anand rao michael georgeff 
asymmetry thesis side effect problems linear time branching time intention logics 
proceedings twelfth international joint conference artificial intelligence pages sydney australia 
rao georgeff anand rao michael georgeff 
bdi agents theory practise 
proceedings international conference multi agent systems icmas pages san francisco ca 
rasmusen eric rasmusen 
games information 
basil blackwell 
rosenschein genesereth jeffrey rosenschein michael genesereth 
deals rational agents 
proceedings ninth international joint conference artificial intelligence pages los angeles ca august 
published readings distributed artificial intelligence alan bond les gasser editors pages morgan kaufmann 
rosenschein zlotkin jeffrey rosenschein gilad zlotkin 
rules encounter 
mit press 
rothkopf michael rothkopf ronald 
models bid taker cheating vickrey auctions 
journal business 
rothkopf michael rothkopf thomas edward kahn 
vickrey auctions rare 
journal political economy 
rubinstein ariel rubinstein 
finite automata play repeated prisoner dilemma 
journal economic theory 
russell wefald stuart russell eric wefald 
right thing studies limited rationality 
mit press 
russell wefald stuart russell eric wefald 
principles metareasoning 
artificial intelligence 
sandholm lesser tuomas sandholm victor lesser 
termination anytime algorithms 
ecai workshop decision theory dai applications pages amsterdam netherlands 
extended version univ mass amherst comp 
sci 
tech 
report 
sandholm lesser tuomas sandholm victor lesser 
coalition formation bounded rational agents 
proceedings fourteenth international joint conference artificial intelligence pages montreal canada august 
extended version appeared university massachusetts amherst computer science department technical report 
sandholm lesser tuomas sandholm victor lesser 
equilibrium analysis possibilities unenforced exchange multiagent systems 
proceedings fourteenth international joint conference artificial intelligence pages montreal canada august 
sandholm lesser tuomas sandholm victor lesser 
issues automated negotiation electronic commerce extending contract net framework 
proceedings international conference multi agent systems icmas pages san francisco ca june 
sandholm lesser tuomas sandholm victor lesser 
advantages leveled commitment contracting protocol 
proceedings national conference artificial intelligence pages portland august 
extended version appeared university massachusetts amherst computer science department technical report 
sandholm lesser tuomas sandholm victor lesser 
coalitions computationally bounded agents 
artificial intelligence special issue principles multiagent systems 
appear 
sandholm tuomas sandholm 
strategy decreasing total transportation costs area distributed transportation centers 
nordic operations analysis cooperation business turku school economics finland 
sandholm tuomas sandholm 
automatic cooperation area distributed dispatch centers vehicle routing 
international conference artificial intelligence applications transportation engineering pages san california 
sandholm tuomas sandholm 
bargaining network intelligent agents 
finnish artificial intelligence conference step new directions artificial intelligence volume pages espoo finland 
sandholm tuomas sandholm 
implementation contract net protocol marginal cost calculations 
proc 
th national conference artificial intelligence aaai pages july 
sandholm tuomas sandholm 
limitations vickrey auction computational multiagent systems 
proceedings second international conference multi agent systems icmas plaza kyoto japan december 
fox mark fox 
constraint directed negotiation resource 
michael huhns les gasser editors distributed artificial intelligence volume research notes artificial intelligence chapter pages 
pitman 
satterthwaite satterthwaite 
strategy arrow conditions existence correspondence theorems voting procedures social welfare functions 
journal economic theory 
cook levi karen cook margaret levi 
limits rationality 
university chicago press 
selten selten 
eines mit 
zeitschrift ur die 
sen sandip sen role commitment cooperative negotiation 
international journal intelligent cooperative information systems 
sen sandip sen formal study distributed meeting scheduling 
group decision negotiation support systems 
appear 
shapley lloyd shapley 
balanced sets cores 
naval research logistics quarterly 
kraus onn sarit kraus 
feasible formation stable coalitions autonomous agents general environments 
computational intelligence journal 
submitted 
kraus onn sarit kraus 
task allocation coalition formation autonomous agents 
proceedings fourteenth international joint conference artificial intelligence pages montreal canada august 
shoham tennenholtz yoav shoham moshe tennenholtz 
social laws artificial agent societies line design 
artificial intelligence 
simon herbert simon 
models bounded rationality volume 
mit press 
smart market smart market 
web page mention vickrey auction smart market 
wu wien ac pricing smart market html 
smith davis reid smith randall davis 
frameworks cooperation distributed problem solving 
ieee transactions systems man cybernetics smc january 
published readings distributed artificial intelligence alan bond les gasser editors pages morgan kaufmann 
smith reid garfield smith 
framework problem solving distributed processing environment 
phd thesis stanford university december 
revised version published research press 
smith reid smith 
framework distributed problem solving 
proceedings sixth international joint conference artificial intelligence pages georgia ussr august 
smith reid smith 
contract net protocol high level communication control distributed problem solver 
ieee transactions computers december 
sun microsystems sun microsystems 
web page mention vickrey auction 
www sun com cover html 
sycara katia sycara roth norman sadeh mark fox 
distributed constrained heuristic search 
ieee transactions systems man cybernetics special issue distributed artificial intelligence smc nov dec 

theory self enforcing agreements 
journal business 
tennenholtz moses moshe tennenholtz yoram moses 
cooperation multi entity model preliminary report 
proceedings eleventh international joint conference artificial intelligence pages detroit mi 
turner eaton roy turner peggy eaton 
handling unanticipated events collaboration 
proceedings cognitive science society atlanta georgia 
turner roy turner 
tragedy commons distributed ai systems 
proceedings th international workshop distributed artificial intelligence pages may 
van der linden verbeek wim van der linden albert verbeek 
coalition formation game theoretic approach 
henk wilke editor coalition formation volume advances psychology 
north holland 
van dyke parunak van dyke parunak 
manufacturing experience contract net 
michael huhns editor distributed artificial intelligence research notes artificial intelligence chapter pages 
pitman 
varian hal varian 
microeconomic analysis 
new york norton 
vickrey vickrey 
counter speculation auctions competitive sealed tenders 
journal finance 
vidal durfee jos vidal edmund durfee 
recursive agent modeling limited rationality 
proceedings international conference multi agent systems icmas pages san francisco ca 
von neumann von neumann 
theory games economic behavior 
princeton university press 
waldspurger carl waldspurger tad hogg bernardo huberman jeffrey kephart scott stornetta 
spawn distributed computational economy 
ieee transactions software engineering 
waters waters 
solution procedure vehicle scheduling problem iterative route improvement 
journal operational research society 
wellman michael wellman 
general equilibrium approach distributed transportation planning 
proc 
th national conference artificial intelligence aaai pages san jose ca july 
wellman michael wellman 
computational market model distributed configuration design 
proc 
th national conference artificial intelligence aaai pages seattle wa july 
zilberstein russell shlomo zilberstein stuart russell 
composing real time systems 
proceedings twelfth international joint conference artificial intelligence pages sydney australia 
zilberstein russell shlomo zilberstein stuart russell 
optimal composition real time systems 
artificial intelligence december 
zilberstein shlomo zilberstein 
operational rationality compilation anytime algorithms 
phd thesis university california berkeley 
zlotkin rosenschein gilad zlotkin jeffrey rosenschein 
domain theory task oriented negotiation 
proceedings thirteenth international joint conference artificial intelligence pages chambery france august 
zlotkin rosenschein gilad zlotkin jeffrey rosenschein 
extent cooperation state oriented domains 
computers artificial intelligence 
zlotkin rosenschein gilad zlotkin jeffrey rosenschein 
negotiation incomplete information worth strict versus tolerant mechanisms 
proceedings international conference intelligent cooperative information systems pages rotterdam netherlands may 
zlotkin rosenschein gilad zlotkin jeffrey rosenschein 
coalition cryptography stability mechanisms coalition formation task oriented domains 
proceedings national conference artificial intelligence pages seattle wa july 
