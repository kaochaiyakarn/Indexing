sound fast goal recognizer neal lesh oren etzioni department computer science engineering university washington seattle wa neal cs washington edu etzioni cs washington edu fax bulk previous goal plan recognition may crudely stereotyped ways 
neat theories rigorous justified practical 
systems heuristic domain specific practical 
contrast describe goal recognition module provably sound polynomial time performs real domain 
goal recognizer observes actions executed human repeatedly prunes inconsistent actions goals graph representation domain 
report experiments human subjects unix domain demonstrate algorithm fast practice 
average time process observed action initial set goal schemas action schemas cpu seconds sparc 
motivation plan recognition kautz pollack task identifying actor plan goal partial view actor behavior 
focused identifying actor goal 
potential applications effective goal recognizer 
goal recognition useful enhancing intelligent user interfaces goodman litman 
furthermore goal recognizer allow autonomous agent provide useful services people interacts completing current tasks offering advice better achieve goals 
describes goal recognition module 
consider integrate goal recognizer agent architecture 
scheme system observes actor executing sequence actions 
actor necessarily know observed keyhole recognition 
system attempts identify actor goal early denise draper robert goldman steve hanks henry kautz nick kushmerick diane litman mike perkowitz rich segal tony dan weld comments discussion 
special keith golden mike williamson ongoing supply critique coffee 
research funded part office naval research national science foundation iri 
planning possible 
mean identify actor goal 
attribute goal actor predict actor actions observed unobserved execution plans goal 
actor goal may conjunction various goals trash fixing car 
scenario illustrates sort want goal recognizer produce 
observed actor computer user entering commands unix shell 
suppose observe cd papers plausible goals point 
actor searching particular file 
wants know memory papers directory 
goal find free printer 
reading mail 
bother change directories goals 
changing directories irrelevant goals assume actor execute irrelevant commands 
allowed arbitrarily irrelevant actions predict actor goal observed actions unrelated goal 
suppose observe ls tex ps second line output goals previously rejected rejected 
reconsider goal determining memory usage papers 
optimal approach execute du actors acted optimally reject goal 
actors act optimally 
actor may execute tex ps add memory usages files 
may part suboptimal plan determine memory usage papers 
observe grep motivating tex reject memory usage goal 
reject goal searching file named tex grep command contribute 
actor looking file contains motivating file contains motivating named tex sections articulate definitions assumptions algorithm express justify produce 
validate system unix algorithm formal results domain independent 
overview objective build goal recognizer performs large real domains 
need way quickly determine goal inconsistent observed actions 
informally goal inconsistent observed actions actor possibly executed actions part plan satisfy goal 
determine consistency reason plans candidate goal 
reason tractably borrow techniques constructing manipulating graph representations planning problems originally developed produce search control generative planners etzioni smith peot 
analyzing interactions actions action schemas goal schemas consistency graphs defined detect cases valid plan exists goal 
plan recognition algorithms run exponential time shown perform large problems 
contrast algorithm sound rejects goal assumptions entail actor goal runs polynomial time size input goal recognition problem 
input smaller corresponding input plan recognizers 
implementation fast 
tested system data collected human subjects unix domain 
average time process observed action initial set goal schemas action schemas cpu seconds 
formulation goal recognition semi decidable 
follows polynomial time algorithm incomplete guaranteed reject inconsistent goal 
experiments algorithm rejects inconsistent goals 
organized follows 
section defines terms input output goal recognizer states assumptions 
section introduces consistency graphs describes algorithm works illustrative example 
section describes empirical validation 
sections discuss related limitations system 
problem formulation informal story 
actor constructs executes plan solve current goal 
plans may contain conditionals observable behavior results execution plan sequence actions 
system observes prefix action sequence 
plan consistent observed actions iff plan execution prefix goal consistent iff exists consistent plan goal 
key question constitutes plan goal 
assume actor constructs plans irrelevant actions 
assume actor constructs plan goal achieve data collected publicly available 
send mail neal cs washington edu details 
actor beliefs world 
assumption suggests system access actor beliefs 
system input arbitrary subset actor beliefs 
actor beliefs system goals prove inconsistent 
planning language formulation general accommodate planning languages 
uwl etzioni ai extension strips language express information gathering goals actions sensory effects 
necessary distinguish unix commands pwd cd 
uwl states sets literals 
possibly negated atomic formula 
conjunction literals state describes relevant relationships world state 
models goals sets literals 
conjunction literals model goal partial description state 
goal schema set literals contain variables 
schema instantiated replacing variables constants 
example goal schema searching file name variable instantiated form goal searching file named 
tex action schema consists name precondition set effects set 
action instance action schema unique id number 
cd action schema example instantiated different actions cd papers cd bin 
multiple executions action distinguished id numbers 
informally plans programs composed nested conditionals actions 
brevity define plans function executor acts interpreter plans 
executor mapping maps plan state action sequence results executing plan state 
refer action plan action coming 
action ai plan iff exists state executor ai 
ai aj actions plan iff execution aj appears appears prior aj 
consistency plan consistent observed actions execution plan produce observations 
definition plan consistent sequence actions iff exists state executor maps sequence actions prefix 
consistency goal defined relative set action schema model goal consistent observed actions exists consistent plan built goal 
plan goal potentially achieve goal model contain irrelevant actions 
define terms 
definition plan potentially achieves goal model iff exists state satisfied executing potentially achieves potentially achieves subset lesh etzioni goal recognizer takes goal recognition problem ii input returns set goal schemas 
input ii sequence actions 
assumed prefix actions executed actor 
set beliefs 
assumed subset actor beliefs 
set action schemas 
assumed superset action schemas actor plans 
set goal schemas 
actor goal assumed instance element output subset goal schema gq exists instance goal schema plan achieve goal actor beliefs constrained 
contains irrelevant actions 
composed actions execution sequence actions prefix multiple goals actor goal may conjunction various goals trash fixing car writing input output specification goal recognizer 
easy treat beliefs input ii subset actor beliefs 
mean plan contain irrelevant actions 
require action plan support action plan goal 
define support actions follows definition action supporting goal similar 
definition ai aj actions plan ax supports aj iff ai aj ai effect unifies precondition aj action ai aj effect negates support blocked action negates supporting effect 
upshot allow redundant sensory actions actor plans 
words assume actor remembers learns executing sensory actions 
define consistency goals 
definition goal consistent action sequence model action schemas iff exists plan consistent action instance schema potentially achieves model action supports action supports goal schema consistent instance goal schema consistent 
weaker requirement plan minimal order contain irrelevant actions 
planning goal recognizer goal recognition problem ii tuple action sequence observations model subset actor beliefs set action schemas actor plan composed actions set set goal schemas goal recognizer takes goal recognition problem returns ideally set goal schemas consistent summarizes input output specification goal recognizer 
view goal recognition process discarding goal schemas input set returning remaining goals 
sound recognizer discards consistent goal 
complete recognizer discards inconsistent goal 
recognizer returns means actor goal instance schema 
recognizer sound justified assumption 
assumption actor goal consistent model action schemas full action sequence actor executes prefix 
actor goal instance schema determining consistency exponential length longest plan doesn go state twice 
unbounded domain consistency 
section describe sound polynomial time incomplete goal recognizer 
goal recognizer goal recognizer algorithm takes goal recognition problem ii returns set goal schemas 
goal recognizer provably sound runs polynomial time 
section theorems provide intuitions true 
full proofs lesh etzioni 
section validate algorithm data gathered unix domain 
goal recognizer constructs manipulates single consistency graph input ii 
consistency graph directed graph nodes actions action schemas goal schemas 
shows simple consistency graph 
informally consistency graph represents plans actor executing 
actions represent observed part actor plan 
action schemas represent possible unobserved actions 
goal schemas represent goals actor 
edges indicate action support action goal 
consistency graph correct consistent plans represented graph 
definition consistency graph correct relative input goal recognition problem ii iff properties hold pi contains consistent goal schema contains action schema instance consistent plan goal contains edge vi vj vi vj vi instance vi supports vj instance consistent plan goal lesh etzioni strength assumption reject goal plan exists achieve actor beliefs 
simple case arises conjunct goal false model effect schema theorem impossible conjunct false legal 
obsolete rule leverages assumption action supports directly indirectly goal 
action schema path connected goal instance support goal correct contains consistent goal 
consistent plan consistent goal 
algorithm sound goal recognizer runs polynomial time size ii 
function recognize ii apply rules quiescence initialize ii 
return goal schemas resulting graph 
theorem recognize sound polynomial time size xi 
initialize function produces correct graph apply legal rules final graph correct 
correct graph contains consistent goal schema 
algorithm returns consistent goal schema sound 
initial graph contains au elements 
iteration potentially apply rule element 
rule applied element linear time size graph 
algorithm halts soon applying rules fails remove 
maximum number iterations number elements initial graph 
upper bound worst case running time number rules 
loose upper bound intended show algorithm polynomial 
actual implementation optimized current rule set 
analyzed dependency relationships rules fire subset rules iteration 
additionally apply rules single procedure 
test example connectedness observed action goals procedure call goal 
roughly times faster checking goal separately 
furthermore algorithm processes observed actions actual system incremental 
fold new actions processed graph re initialize graph time new action observed 
observe new action add fully connect node apply rules new graph 
example trace sample trace 
input recognizer ii cd papers grep planning motivating tex contains representations cd ls grep empty know actor beliefs contains find file named tex find file named tex contains motivating find free printer 
initialize function produces graph similar fully connected 
iteration matching rule removes edges resulting graph shown 
order rule removes edge papers 
prefix rule removes ls papers ep 
second iteration goal connection removes edges point removed goals 
third iteration obsolete rule removes 
fourth iteration rules fire 
set returned 
experimental validation section describe collected data converted goal recognition problems system performed problems 
gather raw data follows 
reading instructions subjects students department english goal descriptions 
subjects try solve goal executing unix commands 
task subjects indicate success failure 
prohibit subjects certain constructs commands pipes command awk 
converted raw data goal recognition problems 
generate observed actions matched observed unix command instance action schema command 
filtered commands considered typos 
action schemas unix commands including subjects 
indicating know actor initial beliefs 
conservative setting 
goal space consisted goal schemas file search goal schemas goals locating file qualities assorted non file search goals pairs goals 
evaluated goal recognizer goals find file named core 
find file contains motivating name ends tex 
find machine low load determine oren etzioni logged machine named 
compress large bytes files subdirectory tree 
goals file search goals 
goal pairs assorted goals 
goal demonstrates ability handle interleaved plans multiple goals 
goal assorted goals 
table summarizes results 
update observed action processed 
length plan number actions subjects executed achieve goal 
remaining goals goals graph update 
goal recognizer performed data 
average time process observed action cpu seconds sparc code written lisp 
goal recognizer incomplete general detected inconsistency goals observations experiments 
algorithm solved goal recognition problem formulated thoroughly quickly 

mechanism recognize people goals 
sense goal recognition occurs recognizer returns single consistent goal 
rarely occurred experiments 
example goal half goals remain 
subjects executed cd core 
commands support file related goals 
file related goals consistent entire plans executed solve goal 
common assumption plan recognition paradigms actor actions eventually serve distinguish single plan goal 
investigations suggest true unix domain relatively small sets possible goals 
view goal recognizer quickly prunes inconsistent goals useful module 
step assign probabilities remaining goals 
lesh etzioni propose different solution version spaces mitchell 
view goals hypotheses 
single strongest consistent exists know achieving goal benefit actor 
due space limitations describe special case approach subset convergence works problems 
define subset convergence occur goals space share common non empty subset 
subset convergence useful agent able fact goal part actor goal 
column table indicates subset convergence occurred goal goal subset convergence occur 
consider goal 
goals rejected grep observed 
remaining goals involve searching file contains word possibly characteristics name ends tex 
goal looking file contains word subset goals 
subset convergence occurred average actions observed average actions subjects completed task 
goal subject command indicated part goal find machine low load determine oren logged 
subset convergence occurred immediately 
second third command goal space converged goal 
goal goals pairs assorted goals include 
subjects achieve contrary inconsistent goal compressing large files example finding free printer 
subset convergence detects early goals include goal compressing large files 
related plan recognizers kautz require input plan event hierarchy consists top level goals primitive actions composite complex actions 
input differs significantly 
essentially take goals input primitive actions input 
definition constitutes valid plan goal replaces complex actions 
formulation goal recognizer consider low level actions composed plans 
eliminating complex actions significant may complex actions hierarchy 
input compact expressive allow arbitrary constraints placed steps plans 
allow arbitrarily long plans acyclic plan hierarchy 
rarely duplicated feature kautz theory system ability recognize concurrent interleaved plans 
kautz assumes actors execute minimum number consistent plans 
proceed similarly assume concurrent execution plans pn goals gn execution single plan 
gn technique recognize interleaved goal solving run algorithm normal goal space goals rejected run recognition pairs goals space collapses run recognition 
approach polynomial sound approximate consistency allow arbitrary numbers plans goals interleaved 
believe people rarely interleave large numbers plans 
assume actors pursue say goals simultaneously technique terminate polynomial sound 
pollack recognizing invalid plans 
allow invalid plans allow plans achieve goal actor incomplete model world 
plans achieve goal executed actual world state 
recognize plans built incorrect models action schemas pollack system 
system consider allowable plans searches explanatory plan 
trying select best probable plan combination plans charniak goldman 
complements re lesh etzioni search recognizer produce consistent goals subjected expensive probabilistic analysis 
litman extend term subsumption include plan recognition motivated need organize large numbers plans desire handle large domains 
vilain describes polynomial time plan recognizer grammatical parsing 
system sound complete restricted classes plan hierarchies approximates consistency relationships exponentially large plan space 
bauer definition plan refined include actions resembles definition plan consistent actions computational approach quite different 
critique algorithm requires polynomial time size input 
sophisticated algorithm described lesh etzioni runs time linear number input goals polynomial 
reasonable goal spaces may exponentially large relevant features domain number predicates 
solution version spaces mitchell 
view goals hypotheses explicitly compute strongest consistent hypotheses weakest consistent hypotheses 
boundaries compactly represent set consistent goals 
lesh etzioni identify class goals determine consistency goals explicitly computing consistency goals 
currently strongly leverage assumption action actor plan supports action goal 
basis reject goal finding free printer observe cd papers 
completely model domain actions contribute goals 
actor searching file contains printer names cd papers indirectly support finding free printer 
problem fail recognize obscure plan fail don model world 
eventually need stronger constraint current action support action goal 
hand approach sensitive noisy spurious actions 
assume observed action part goal directed plan 
may adequately capture role certain actions returning home directory brow 
currently exploring possibility learning actions regularly spurious observing actor long period time 
actions filtered observations 
addressed additional issues 
recall input observations actions formal action language 
automatically produce example instance cd action schema observable string cd papers 
actor executes command fails 
furthermore know actor finishes task begins 
believe goal consistency framework experimental apparatus puts planning position address issues 
algorithm formal results domain independent guarantee goal recognizer effective domain 
case study unix indicates goal recognizer performs 
believe results suggest approach various software domains 
generally approach particularly suited classes goals 
conjunctive search goals goal looking file large touched month second conjunctive set compressing files large touched month plans classes goals long task completion especially useful 
bauer bauer kohler paul phi logic tool intelligent help systems 
proceedings th international joint conference intelligence 

charniak goldman charniak goldman 
probabilistic model plan recognition 
proc 
th nat 
conf 
volume pages july 
etzioni etzioni hanks weld draper lesh williamson 
approach planning incomplete information 
proc 
rd int 
conf 
principles knowledge representation reasoning october 
etzioni oren etzioni 
static problem space compiler prodigy 
proc 
th nat 
conf 

goodman litman goodman litman 
interaction plan recognition intelligent interfaces 
user modeling user adapted interaction volume pages kautz kautz 
formal theory plan recognition 
phd thesis university rochester 
lesh etzioni lesh etzioni 
sound fast empirically tested goal recognizer version spaces 
technical report draft 
university washington 
mitchell mitchell 
generalization search 
artificial intelligence march 
pollack pollack 
plans complex mental attitudes pages 
mit press cambridge ma 
smith peot smith peot 
postponing threats partial order planning 
proc 
th nat 
conf 
pages june 
vilain vilain 
getting serious parsing plans grammatical analysis plan recognition 
proc 
th nat 
conf 
pages 
litman litman 
terminological reasoning constraint networks application plan recognition 
proc 
rd int 
conf 
principles knowledge representation reasoning october 
