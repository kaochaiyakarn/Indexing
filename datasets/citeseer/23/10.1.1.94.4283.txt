expressive description logics foundations practical applications ralf ller university hamburg computer science department vogt lln stra hamburg september acknowledgments prof dr bernd neumann 
encouraging comments enthusiasm years shaped discussed monograph 
emphasizing importance applications demonstrate adequacy theoretical suggested particularly consider real world problems 
description logic system race deal hard inference problems encountered real world applications 
interesting discussions research deductive information systems 
bernd neumann valuable comments draft monograph 
additional reviews monograph prof dr franz baader prof dr christopher habel 
am particularly grateful colleague dr volker haarslev 
discussing topics description logic systems years 
times investigating new optimization strategies turned effective hard implement 
long discussions volker haarslev lead development formal proofs algorithms implemented description logic system race application oriented thesis complemented theoretical results 
furthermore colleague michael wessel years exciting research area description logics spatial reasoning default reasoning 
michael wessel valuable comments final draft habilitation thesis 
contributed development race system testing writing documentation 
careful comments draft version monograph 
discussions collaboration context description logic reasoning reasoning topological relations am indebted carsten lutz theoretische informatik university aachen 
theoretical knowledge immensely contributed various decidability undecidability results area combined terminological topological reasoning 
members theoretische informatik aachen detailed comments papers covering particular theoretical topics summarized 
members cognitive systems group university hamburg particular carsten schr der members band project team gmbh rainer kay hidde thomas contributed results reported 

diploma students glen lehnert omar christian 
provided small pieces mosaic shaped monograph 
students computer science department contributed development race system 
contents german summary ii main part applications research problems research methodology 
overview 
description logic alcn hr concept language alcn hr 
assertional language alcn hr 
inference problems 
dls applications example 
related dl theory 
related dl systems generation 
second generation dl systems 
generation 
lessons learned 
race tableaux calculus inference system tableaux calculus alcn hr 
optimization techniques inference algorithms 
optimizing concept consistency reasoning 
optimizing tbox reasoning 
abox partitioning multiple tboxes aboxes 
demanding problems testing dl systems 
tbox specification verification telecommunication systems 
ontology engineering bio informatics umls tbox 
testing methodology 
extended new optimizations race 
optimizations concept consistency tbox reasoning optimizations abox reasoning summary benefit race technology 
alcn hr extended concrete domains description logic alcn hr concept language alcn hr assertional language alcn hr solving configuration problems alcn hr decidability alcn hr applying alcn hr configuration revisited 
unintended blocking 
limited expressivity 
analysis extension alcn hr discussion spatiotemporal terminological reasoning description logic alcrp concept language alcrp assertional language alcrp decidability undecidability results spatioterminological reasoning alcrp rcc reasoning alcrp rcc gis application 
spatiotemporal terminological reasoning spatioterminological default reasoning ii image understanding application default reasoning specificity computing extensions discussion deductive information systems example instance retrieval cooperative information systems agent computing multi agent inference problems supporting business inferences internet technology related summary information retrieval probabilistic description logics preliminaries classic probabilistic extension example retrieval summary assessment 
outlook sum iii iv teil german summary und motivation die probleme die der zu sind werden da zur sung werden der zu sind sowie auch eine gro 
es nicht da verschiedene ans tze und methoden zur bew der wurden 
zu sind diesem zum beispiel systeme uml unified modeling language das verhalten von systemen nge workflow modeling languages gesch 
das der ans tze ist die und bare zu unterst 
allen ans ist der nach 
es sich weiterhin ein systeme mit bzw 
auf der basis von modellen der ne gel st werden nnen 
sen diesem da die sung durch allgemeine bzw 
und nicht durch programmierung eines wird 
diese fa praktische und theoretische zur entwicklung von mit es glich ist deklarative die auf ft werden nnen und als basis nnen 
um die von modellen zu erm glichen ist es da die auf einer semantik 
auf der basis der semantik einer repr lassen sich formal 
das sen eines eines durch ein wird auch 
algorithmen zur von nnen unter auf die semantik der repr werden ob sie vollst und sind und auch 
je nach der repr kann die sung von durch verfahren 
kann zum beispiel ein durch ber einem extensional gel st werden 

bei anwendungen werden repr untersucht da die von nicht nur einer der daten besteht 
die von ein ber informationen 
sich und diese 
abiteboul sich da der fokus von auf wie und sowie auch auf und 
die von bei ber informationen bzw 
werden mu llt den bereich der 
genesereth nilsson fitting poole 
da repr anwendungen ben werden auch im eine gr ere chomicki saake kuper 
es daher nicht da die ergebnisse von zu und zur sentation im der informatik werden und 
unter dem formale systeme die einer logik nnen 
anwendungen von sind 
informationssysteme mit ein ber einen kann 
ein durch formale werden soll hier als werden 
ein mu allerdings nicht auf einer es kann durch sein 
die entwicklung von bzw 
hat eine lange tradition 
der sind viele ge aus und mit mathematischen zu 
viele sich zur sung und systeme 
dieser arbeit wird diesem ein ansatz dem theoretische ber die von repr durch praktische arbeiten zu erg werden 
sind die praktische von mit repr 
die entwicklung von algorithmen die vollst und sind und aber im nicht eine explosion ist ein und stellt auch aus einer 
wie nnen formale einem zur von werden 
diesem ssen repr die der praxis werden sollen eine ad eine art von ph und 
zum beispiel informationssysteme gis ber und nat objekte die basis 
falls durch gel st werden sollen ist die einer semantik die repr da nur die von definiert werden kann 
dabei ist das von bzw 
und wissen auf einer von 
die integration des schlie ens mit des schlie ens ist ein noch zu dem dieser arbeit durch die entwicklung von vollst und grundlagen werden 
um eine von modellen zu erm glichen auch im von repr untersucht werden die vollst und und 
auf verschiedene ans tze zur mit horn wird daher nur am 
auch die argumentation baader 
informationssysteme sind nicht die formale werden nnen 
durch das im bereich des verteilten systemen wird das problem der 
es dabei durch auswertung eines zu pr fen da auch unter allen werden nnen 
als die formale sind zu 
systemen wird eine von stark 
die von stellt dabei ein gro es problem dar 
daher besteht der wunsch von einem modell eines systems und einer von zu pr fen ob ein des systems werden kann 
diesem werden algorithmen zur modell fung model checking algorithms 
clarke kurshan eine um zu fen ob eine eines systems erf llt 
bei der modellierung eines systems ist dabei da das verhalten des systems als repr ist 
berg nge werden durch bzw 
st da pr ssen 
der modell fung ist es zu fen da eine die erf llt 
ein problem des der modell fung ist da nur ume werden nnen und ii nur von anwendungen werden nnen 
daher werden ma auch zur fung von 
nnen mit und unterst auch eine fung der katoen 
damit anwendungen werden nnen ssen und repr verwendet werden und verf sein 
wir werden dieser arbeit da entwickelt werden nnen die im bereich der von werden nnen und modell tze erg nnen 
eine von repr die die sehr gut ist wird als beschreibungslogiken description logics dls baader 
mit beschreibungslogiken wird eine modellierung von und ph der aus einer woods schmolze donini 
es werden zur von 
und bin re relationen sowie auf der semantik der repr fung 
zeit sind auch beschreibungslogiken mit relationen untersucht worden calvanese 
lassen sich einer anwendung unter auf beschreibungslogiken als und zur sung dieser zur verf gung 
mit anwendungen da ben werden damit nicht auf ad hoc zur werden mu 
die entwicklung von die auf vollst und algorithmen und im fall average case ein ist aber beschreibungslogiken ein 
dieser wurden zu den der 
es sind theoretische arbeiten zur entwicklung von kalk len beschreibungslogiken 
entwicklung von aber vollst und algorithmen verfahren das schlie en mit 
implementierung eines race zur hrung von untersuchungen zum average case verhalten von 
ren der des race von anderen von gro en ontology engineering sowie auch die von soft und am beispiel von 
erweiterung der theorie zu beschreibungslogiken zur von schl ssen 
ber und dom nen 
constraints mit anwendungen im bereich der 
theoretische arbeiten zur integration von zum und schlie en das schlie en mit beschreibungslogiken 
der verwendung der anwendungen aus bzw 
informationssysteme informationssysteme und orientierte informationssysteme 
dieser arbeit wird da sich beschreibungslogiken weise zur modellierung und sung lassen 
nicht wird da auch andere als basis von zum einsatz nnen datalog 
das beschreibungslogiken die motivation die 
stand der und ergebnisse im folgenden abschnitt wird der stand der forschung im der repr sentations und 
nach einer der sentation werden des schlie en hrt die 
der dieser arbeit von und schlie en sind 
werden die dieser arbeit sentation logische repr haben sich bei der von modellen als ein zur sentation 
wir dieser arbeit mit beschreibungslogiken prim 
tze brachman schmolze da sie sich viele als ein haben 
fr ans tze zur sentation noch stark durch ad hoc der gt 
hat sich durch die der semantik von repr eine siehe baader baader sattler einen ber verschiedene arbeiten 
die ergebnisse der da repr die sind 
durch die formale semantik von logischen repr ist es glich mit algorithmen zu 
werden glich die sich nicht auf verfahren sondern auf allgemeine formal st 
durch diese art der modellierung von systemen kann eine bei den bei hung der werden da eine auf und algorithmen und zur werden kann 
von die der ist diesem die der logischen repr 
der einsatz von sprachen und ist glich die da die im nicht wird 
viele sind auf der basis eines vollst und und kalk ls 
dabei wird die da sich ein einer anwendung bei sprachen durch formale sen das problem nicht einer zu als 
eine entwicklung und von ist nicht 
beschreibungslogiken sind ein der klasse der repr und im der hier 
beschreibungslogiken beschreibungslogiken werden 
zur repr sentation von klassen von verwendet 
eine anwendung werden primitive und mit zu 
bin re zwischen werden durch 

ber nnen die von werden 
im logischen und dr cken ber aus 
je nach der sprachen werden wie und negation zur sowie und zur der von siehe die alc schmidt smolka 
ein ist der bzw 
erf siehe 
ein ist wenn es eine die das eine nicht es die von dem sind 
eine von repr das einer anwendung und wird auch als tbox 
dabei wird zwischen und 
bei besteht seite nur aus einem 
bei beschreibungslogiken wird da die der der tbox und sind siehe nebel eine zur semantik von 
damit werden mit und oder mit hrt 
bei zur beschreibung von auf der seite ein 
damit wird eine hung der bei der modellierung siehe auch baader 
durch nnen auch ber objekte get werden eine von als abox wird 
da nicht nur der abox sind sondern allgemeine zur beschreibung von verwendet werden nnen sich auch wissen ber repr 
beschreibungslogiken wird eine semantik der welt open world semantics 
ein repr stellt sowohl als auch eine von zur verf gung die hier ohne technische details kurz hrt werden 
wie ist der dienst der erf bzw 

bei der eines einer anwendung die von auf hin 
ein dienst die zwischen zu 
die subsumption von ist den einer 



werden die und 
dies auf der basis der der tbox zur beschreibung des 
dieser dienst wird auch tbox und kann anwendungen zur des der phase der eines verwendet werden 
eine des besteht die und aus der tbox zu 

anwendungen kann dieser dienst zur auf das werden 
viele anwendungen ist es nicht nur ber konzepte ber von zu sondern ber ganz zu 
wie nnen ber durch formal werden 
der dienst ist die fung einer von einer abox auf 
auch die pr fung ob ein eine eines ist kann die von werden 
weiterhin kann die der konzepte aus der tbox werden von ein eine ist auch der abox 
dieser kann einem zur sung von verwendet werden 
die einer abox sind die von der tbox 
sie auch die basis den dienst des die von einem sind 
dienst kann zur recherche nach die erf sollen verwendet werden 
aus eines werden die ber eine relation zu diesem objekt objekte als ller dieser 
die ller nnen ber einen werden 
auf einige 
nicht standard soll kurz werden matching baader sters unter ber von rewriting terminologies baader sowie berechnung des common subsumer lcs cohen baader molitor 
die dieser der von und der integration von 
die lcs kann beispielsweise zum von durch verwendet werden 
dieser arbeit wird die lcs im einer anwendung zur 
aus der forschung es zu da die von anwendungen ad hoc erweiterungen nicht sind 
beschreibungslogiken die alc ist propositional vollst es wird die negation unterst daher der name attributive language complement 
es ist zu da sprachen die glich sind die standard auf abox zur hrt werden nnen 
das abox alc ist ohne pspace vollst schmidt smolka 
mit das problem exptime 
fr arbeiten zu beschreibungslogiken donini von alc mit das ohne allgemeine 
von alc werden auch unter dem beschreibungslogiken sprachen die eine als alc werden auch als 
die allerdings nur zur der 
beschreibungslogiken sind die im fall 
der zur von schr die von glichen ein alcn donini mit oder hollunder baader mit 

einen der 
attribute features dar 
attribute sind die nur einen ller 
eines haben nnen 
zur beschreibung von bzw 
relationen werden inverse transitive 
alc mit wurde sattler untersucht 
algorithmen den 
sprachen mit und wurden von horrocks untersucht 
mit dem system fact wurde diese logik eine implementation entwickelt horrocks 
fact unterst allerdings keine abox 
abox mit vollst und algorithmen sind ein dieser 
auf dem kalk buchheit die logik alcn wurde ein kalk abox der logik alcn hr alc mit und entwickelt haarslev ller 
dieser kalk als basis das abox race 
wir im abschnitt zur ck 
sich hrend der entwicklung von race der stand der 
ein soll hier die 
die von mit und logik bei der der wird horrocks sattler horrocks 
eine rung ohne abox wird horrocks 
wurde die ent des abox die logik horrocks 
eine implementation noch nicht vor 
weiterhin wurden im von beschreibungslogiken vollst und algorithmen das schlie en mit die der von und nicht nur ller sowie mit entwickelt tobies 
auch arbeiten zu den baader und schaerf 
eine arbeit sich mit 
bzw 
zwischen und stellt da alle werden wenn mit werden baader sattler 
eine ber die forschung im bereich beschreibungslogiken sei auf baader und baader sattler 
die auch von einer sehr 
den abschnitt haben wir da viele arbeiten sich auf die von repr sowie auf die worst case der verfahren den von oder verfahren den zwischen donini donini 
hrend die zu beschreibungslogiken auf das von teil sprachen mit donini cadoli hat sich zeit eine neue die sich damit im fall dom und zu die es die anwendungen zu baader ginsberg mcallester freeman giunchiglia sebastiani horrocks horrocks patel schneider 
auch arbeiten im der freeman 
der soll nicht auf eine optimierung auf der bit sondern sich auf die adaptive von und die verwendung von 
diesem sind zeit sehr im bereich des und der von worden 
auf arbeiten bzw 
fr hen wurde die alcn hr das repr sentations und race haarslev ller haarslev ller haarslev 
race stellt zur zeit eines der dar das abox mit vollst sowie algorithmen eine logik dieser unterst haarslev ller 
auch bei den tbox rt race zu den systemen ist hrend da zur zeit system das auch sehr gro ca 
ggf 
werden kann und auf vollst und algorithmen haarslev ller 
ber und dom nen viele anwendungen ist es nicht nur objekte zu 
ssen beispielsweise auch zahlen die modellierung werden 
wurden im bereich beschreibungslogiken untersucht 
siehe die arbeiten zu alc baader hanschke baader hanschke hanschke lutz 
alc nnen pr ber zahlen das schlie en werden eine mit einer von pr wird alc als dom ne 
diesem da sowohl beim als auch beim von die durch pr der dom ne ber werden 
die sprache alc lt im zu alc zwei neue 
alc die von und die verwendung von einem operator pr 
mit diesem operator kann die einer von werden ende sich ein 
objekt 
objekte auch variablen je nach der dom ne eine 
die der variablen durch eine pr werden kann nnen durch pr werden 
mittels einer abox nnen werden 
mit alc aus der anwendung im zu alc eine und sich viele praktische probleme sen lassen sind fr erweiterungen untersucht worden 
wie sich baader hanschke hrt die integration von alc ohne der von zur der repr siehe auch baader sattler 
die erweiterung von alc um einen operator den von ist beispielsweise allgemeine dom nen 
praktische anwendungen sind erweiterungen auf 
dieser arbeit werden dom nen die sprache alcn hr untersucht 
durch der pr auf die verwendung von im zu wurde eine sprache definiert alcn hr die durch eines vollst und und kalk ls werden da die standard sind 
die anwendungen von alcn hr sind 
dieser arbeit werden mit alcn hr gel st schlie en arbeiten zur integration von informationen werden dieser arbeit im von anwendungen zur untersucht 
ein ansatz zur von wird diesem zur siehe auch ller 
die arbeiten auf einer erweiterung der aln zur repr sentation von und beschreibungslogiken 
beschreibungslogiken koller 
auf andere diesem und auf der fuzzy set theorie beschreibungslogiken tresp molitor soll hier nicht werden 
eine implementation der koller logik wurde von und im band des nstliche intelligenz ller ller 
schlie en den beschreibungslogiken und ihre erweiterungen wurden wir uns dem auf dem des schlie ens zu 
dieser arbeit wird da das schlie en mit beschreibungslogiken eng mit dem schlie en werden kann und mu 
die auf der basis der semantik der rep und stellt nicht nur eine rein von dar 
der bereich des schlie ens eine gro hat und mit dem schlie en weise werden wird hier der bereich des schlie ens des schlie ens 
geo informationssysteme 
re es beispielsweise da sich ein objekt eines anderen 
durch die qualitative des die position nicht zu werden 
diese sind nicht oder zu siehe auch frank 
weiterhin kann es sein alle objekte eines zu ma chen ohne die objekte hlen 
zum beispiel nnen alle einer als werden 
diese ver die glichkeiten mit und lassen da der kombination von und schl ssen eine 
schlie en der bereich des schlie ens ist ein des schlie ens 
beim schlie en wird das qualitative verhalten von systemen auf durch verwendung von wie zu hoch zu und nicht durch absolute wer zu 
mit verfahren werden dann aus informationen neue informationen 
den hat sich das qualitative schlie en als ein siehe stock eine 
da der raum und damit nicht ad durch repr gr en ist nnen viele aus dem bereich des schlie ens nur auf werden 
eine das qualitative schlie en besteht kalk le mit repr glichkeiten und gr en zu erm glichen 
auch frank 
verwendung hat der rcc kalk zur repr sentation von randell 
zwischen sind viele anwendungen 
wir haben da diesem eine integration des schlie ens und des schlie ens ber relationen ist 
dies sei einem sehr beispiel erl 
wir ein mit sei definiert als ein das eine che 
weiterhin sei ein wald definiert als ein wald da alle die nicht zum wald keine chen sind 
durch es glich sein zu da ein mit das sich einem wald nicht kann 
ohne ein schlie en ber relationen mit der von ist dieses nicht glich 
die qualitative auf 
die von relationen ri und rj ri rj alle glichen zwischen und form einer 
durch hrung des einer logik auf das bennett die des von rcc werden 
bennett wurde untersucht das vollst eine ist 
nur aus rcc wurde die des nebel 
falls allerdings von relationen werden ist die pr fung der erf von rcc ein da nicht nicht ist renz nebel 
die einer global sung kann durch anwendung eines backtracking 
renz nebel werden maximal von rcc relationen die zur optimierung eines vollst werden nnen der 
von wurden renz untersucht 
rcc rt zu den gut des schlie ens 
dieser wird daher auf rcc zur wird rcc nur als ein beispiel einen zum schlie en 
die dieser arbeit ergebnisse sind allerdings nicht qualitative sondern lassen sich auch auf quantitative und andere qualitative repr 
mit den nnen zwischen gut repr werden 
ein besteht da bei den ans wissen ber die objekte die schl sse werden kann 
und schlie en haarslev wurde ein ansatz zum schlie en ber objekte von beschreibungslogiken 
dieser ansatz quantitative qualitative und information ber nen durch ge relationen die die integration erm glichen 
im logischen sind die relationen allerdings noch als schl sse ber relationen werden bei der noch nicht ad ber 
den abschnitt zu den 
die modellierung mit logischen repr wie beschreibungslogiken eine lange tradition hat wurde zeit die kombination von und bzw 
raum repr untersucht 
haarslev ller 
die arbeiten sind durch wie geo informationssysteme 
systemen ist eine integration der sentation und des bzw 
raum schlie ens 
haarslev ller wird auf der basis der classic brachman eine erweiterung zur integration relationen unter ber ihrer semantik und ein 
schl sse ber relationen werden mit dem ansatz auch die von hrt 
die ergebnisse werden haarslev auf allgemeine er 
um eine ad von und wissen zu erm glichen wurde die theorie zu alc lutz ller ller haarslev haarslev 
durch pr ber dom nen nnen und auch relationen als hrt werden 
durch wird eine hung der gegen ber alc 
ber zwischen lassen sich das schlie en siehe haarslev 
die alcrp die werden der werden lutz lutz haarslev 
ohne das vollst und aber kann nicht werden lutz ller 
aus des stands der forschung wird da alcrp mit einer dom ne mit pr rcc eine erste ordnung ist 
das sich mit alcrp auf weise 
die des wird durch den kalk aus haarslev 
zur der von alcrp sich haarslev 
dieser arbeit wird die anwendung von alcrp auch zur modellierung von und raum ph siehe auch lutz haarslev 
auf die der arbeiten zur modellierung von relationen mit soll hier allerdings werden siehe stock und frank 
en beschreibungslogiken es wurden im von sowohl theoretische als auch praktische arbeiten zur repr sentation von das en defaults hrt um damit die repr sentation von wissen zu unterst 
da das des ens sehr gro ist 
antoniou schaub arbeiten wird hier nur auf arbeiten die mit beschreibungslogiken 
zu den erweiterungen von systemen ren des ens unter verwendung von mit zur repr sentation von baader hollunder padgham zhang padgham nebel zur von mit baader hollunder sowie zum schlie en unter der der welt closed world assumption 
relevant sind diesem auch die arbeiten zur von donini donini donini 
im mit dom nen und alc wurden hanschke untersucht 
sse auf und relationen werden anwendungen beispielsweise im bereich der geo informationssysteme als 
wenn ber die position des einer ist als da sich das im zentrum der es sei es 
die von und informationen durch sse beschreibungslogiken wurde ller wessel ller untersucht 
anwendungen anwendungen des schlie ens mit defaults im bereich der von und sind haarslev 
repr nnen der praxis anwendungen 
um das potential des systems race sowie auch die glichkeiten der erweiterungen zu werden dieser arbeit anwendungen aus 
wir fung von von entwicklung von gro en der bzw 
schulz hahn von ger informationssysteme mit im handel 
die anwendungen wurden von anderen untersucht op 
cit 
sie zur des dl systems race 
die anwendungen die verwendung von im von und papazoglou 
beschreibungslogiken haben sich arbeiten als ein zur 
catarci lenzerini levy calvanese kashyap sheth klusch 
die dieser neue glichkeiten und auf 
als beispiel wir die von bei einem einem verteilten ller 
zur entwicklung eines repr sentations und wurde dieser arbeit ein ansatz 
es wurden sowohl im als auch im bereich 
die der arbeit schlie mit einer des und mit einem einige der glichen erweiterungen zu den hier pr arbeiten auf 
mit dem system race wurde ein sehr repr sentations und entwickelt 
die des race systems ist auf die sung von mit gro en tbox und 
race stellt neue und da gr ere von schl ssen die auf vollst und algorithmen nnen 
der zwischen und schild kann race auch als verwendet werden 
das der entwicklung von race war es eine zu die im bereich des schlie ens und im bereich des tbox und abox schlie ens 
wie die untersuchungen ssen diesem werden 
probleme die als typen von logischen werden der km sind entwickelt worden die diese bis sind als race 
allerdings nnen sie nur werden wenn die probleme mit den repr werden nnen 
anwendungen werden wie zur modellierung ben 
allerdings algorithmen den 
daher werden race die algorithmen zur hlt da sprachen ohne keine en zu sind 
race ist auch noch eines der die beschreibungslogiken verf sind 
die entwicklung von race ist noch nicht wie inverse sich der entwicklung und werden race 
man allerdings nicht au er lassen da mit der einf hrung von die integration wird 
die kann eine implementierung gr ere anwendungen nur werden wenn ist wie die im mit und werden nnen 
ein teil dieser arbeit das zwischen und schlie en 
mit der logik alcrp bzw 
der alcrp rcc wurde ein zur integration des und schlie ens am beispiel von 
wurde eine implementierung 
es mu allerdings werden da noch keine implementierung von alcrp und alc die im von alc mit der von race re 
allerdings die der entwicklung von race eine die entwicklung von alc und alcrp siehe erste ergebnisse 
es sei allerdings da die mit alcrp und der dom ne rcc glichen repr im bereich des schlie ens nur als ein sind 
lassen sich ph des schlie en mit anderen dom nen 
re es auch die mit alcrp im von alcn hr zu 
alcrp werden nicht unterst und bzw 
transitive nnen nur ber dom nen hrt werden 
die im von da die eine theoretische basis den von mit 
informationssysteme oder auch informationssysteme 
mit von wurden zur einer einem verteilten system dem repr und ihre werden nnen 
weiterhin werden im von zur analyse von auch siehe details der implementation der 
der dieser arbeit ansatz kann als erg zu anderen ans ge werden welche die aus der donini 
eine ber viele andere arbeiten mit die auf weise diese arbeit haben auch baader und baader sattler 
beschreibungslogiken die basis eine von einer sehr 
es wurde da qualitative relationen auf basis des rcc kalk ls nur als ein beispiel schlie en werden kann 
relationen sich nur zur repr sentation ganz zwischen 
wie ber form position und den des schlie ens werden ist ein noch 
weiterhin ist die integration von und schlie en diesem ein 
die zwischen und pr wurde im bereich untersucht siehe aber kautz ladkin meiri die von und pr ber 
wurde da die dom ne der zahlen ein erf ber tarski das nicht werden 
praktische anwendungen ist ein verfahren das noch nicht einem wurde 
zeit sind theoretische verf die eine implementierung eines erm glichen siehe die theorie der johnson da auf erf werden nnen 
die arbeiten sind allerdings noch einen zu 
ein noch problem ist die erweiterung der auf den mit dom nen im und informationen im 
relevant sind diesem arbeiten zur erf von 
ist die optimierung von nebel wissen 
bei gung von sich beispielsweise die der konzepte von ein eine ist mit 
eine der arbeiten zum en wurde durch die einf hrung von beschreibungslogiken siehe donini rosati 
durch nnen auch das und nicht die repr welt werden 
eine dieser im von schl ssen erm die von nicht schl ssen mit auch diesem bereich 
mit der verf von beschreibungslogiken wird es glich der sprache uml unified modeling language page jones eine formale semantik zu da uml nicht nur zur pr sentation und kommunikation von der einer anwendung verwendet werden kann sondern auch zur sung von werden kann ohne da code werden mu 
arbeiten zur von uml modellen mit ans der modell fung sich lilius lilius lilius 
erweiterungen von beschreibungslogiken sind noch nicht auf die modellierung von wissen untersucht worden 
wenn im keine position ist mit zur von der position des der der eine werden als einer position am 
einsatz und dieser im der repr sentation von und wissen beschreibungslogiken wurden noch nicht untersucht aber beispielsweise gis potential 
es wird da der dieser arbeit logische ansatz eine informationssysteme mit 
nnen im zur repr sentation von informationen ber objekte einer dom ne verwendet werden 
allerdings im werden ist das dieser technologie auf anwendungen mit 
es ist daher sehr abox schl sse zu die daten mit und unterst 
borgida brachman borgida erste ans tze 
es allerdings auch werden da die revision von logischen im von wissen sich noch ein 
sum mit der arbeit grundlagen ein repr entwickelt werden da mit teil probleme einer anwendung werden nnen 
ist eine entwicklung von und anwendungen mit glich 
die die die entwicklung von algorithmen da die die durch werden nicht ohne durch ad hoc der werden nnen 
arbeit ist um da vollst und auf der der algorithmen werden kann 
und da die implementation dieser algorithmen ist 
entwickelt nnen zum einsatz 
formale und auch beschreibungslogiken nnen als sich werden 
vor noch eine gro zwischen theorie und praxis 
mit der entwicklung von sich da theoretische ergebnisse glich und sind die implementierung von 
die von einer implementierung stellt neue theoretische arbeiten 
analyse von 
neue die race sind und auf der basis von ergebnisse entwickelt wurden erm glichen die von anwendungen 
nicht die die der dieser arbeit ergebnisse die sentation und auch die informatik 
wurde mu te offen 
ich da durch diese arbeit neue mit werden 
part ii main part chapter problems application developers facing projects involving information technology tend complex 
applications particular web context models large ontologies important 
aspects distribution safety verification concerns considered 
order reduce complexity topics knowledgebased systems object oriented frameworks unified modeling languages workflow models business re organization models dominate discussion ensure computer systems constructed hand match requirements hand reliable robust adaptable 
order fulfill requirements huge demand systems automatically solve complex sub problems applications declarative models domain 
addition verification models computational purposes required application scenarios 
formalization subtasks applications understood computational inference problems prerequisite support development powerful systems better quality development costs 
emphasized user application need aware internal computational processes formal models 
instance users successfully interact web information retrieval systems database technology aware underlying relational calculus 
habilitation thesis describes results practical theoretical investigations developing representation systems support construction declarative models checked consistency basis problem solving processes different application contexts 
order support automatic processing models modeling language clear semantics inference problems formally defined inference algorithms systematically analyzed formal inference systems suc developed genesereth nilsson fitting poole 
formal inference systems particular importance safety critical applications order check system specifications systems deployed practice 
formal model application domain inference systems directly implement subtasks application systems 
called information systems subtasks applications realized specifying queries answered explicitly information model 
query answering basic operation information systems web 
usually scenario realm information retrieval database systems 
research areas powerful representation query languages investigated 
mere information lookup answering queries information systems complex domains involves reasoning implicit information query answering systems require inference systems subcomponents 
new generation information systems especially web scenario called deductive information systems 
focus classical database systems mainly important aspects persistency efficiency storage requirements speed retrieval transactions rollback powerful representation languages required building applications inferences play important role database systems cf 
abiteboul 
surprisingly results research formal inference systems knowledge representation directly relevant conventional computer science vice versa chomicki saake kuper 
information system main services formal inference processes called deductive information system 
deductive information systems need implemented monolithic architecture comprised cooperating deductive subsystems 
development formal inference systems long tradition 
literature contains contributions different points view different mathematical background 
problems appropriate formal modeling inference techniques logical approach logical characterization various problem classes developed terms deduction induction abduction synthesis pursue computational approach combining theoretical results decidability different logical representation languages practical results concerning efficient proof procedures sound complete terminating 
efficient proof techniques turn needed implementing instance query answering specification checking systems expressive languages 
development efficient algorithms run combinatorial explosion average case active exciting research field practical theoretical point view 
context deductive information system scenarios formal representation systems applied practice support adequate representational expressivity model different kinds phenomena 
instance geographic information systems gis spatial knowledge artifacts natural objects provide basis problem solving processes 
application problems automatically solved problem specifications sound semantics representation formalism mandatory 
order able give characterization computed problem solution important integrate conceptual spatial temporal representation structures semantical basis 
question information retrieval contexts preferably representation languages sound complete inference procedures exist considered 
logic programming approaches horn clauses briefly discussed see analysis baader 
information systems area formal inference systems successfully applied 
growing interest electronic commerce context distributed systems raises problem verifying possibly interacting services provided circumstances 
furthermore telecommunication systems tend supply vast amount different features necessarily combined trouble 
models systems set constraints invariants formal verification prevalent demand ensure secure operation systems 
context model checking techniques see clarke kurshan overview successfully check property stated system finite state model valid 
problem model checking techniques finite state spaces handled ii control oriented aspects application verified 
model checking successfully complemented theorem proving techniques handle infinite models verify data models katoen 
family logic representation languages suited mentioned tasks known description logics dls baader 
main representational means concepts unary predicates roles binary predicates 
description logics strong correspondence modal logics interesting theoretical computational point view 
modeling languages application problems subproblems reduced formally defined inference services 
experiences applications indicate expressive description logics required solve practical modeling problems resorting ad hoc extensions 
expressive description logics development inference systems sound complete calculi relatively new research area 
focus habilitation thesis development decidable description logics expressive power solving approaches ary roles investigated calvanese 
application problems 
extensively investigates language features practical applications 
language feature current state art leads combinatorial explosion toy problems considered implementation 
significance new results shown discussing problems solved 
formalization application problems deduction tasks employment theoretically investigated proof systems problem solvers results faster development robust applications increased functionality 
experiments indicate average case solutions problems computed reasonable amount time todays computers worst case complexity class problems exponential 
applications research problems research methodology formal representation inference systems motivated different kinds applications checking specifications telecommunication systems 
development large ontologies bio informatics schulz hahn 
construction technical devices 
knowledge image interpretation 
deductive information systems application perspective ecommerce 
application scenarios investigated groups op 
cit 
serve interesting testbeds practical evaluation description logic inference algorithms 
configuration image interpretation tasks application area considered deductive cooperative information systems papazoglou 
particular motivate description logics context spatial geographical agent information systems 
description logics proven important technology information integration catarci lenzerini levy calvanese kashyap sheth klusch 
research problems tackled habilitation thesis characterized follows 
prevalent goal provide language adequate means representation inference 
aspects nonmonotonic reasoning default reasoning investigated context focus conceptual representation languages representing terminological assertional knowledge description logics 
sound complete algorithms expressive description logics developed 
decidability proofs sound complete algorithms allow optimized implementation developed evaluated practical implementation 
different subproblems solved way practical inference system 
development inference system formal calculus decidability proofs 
problem integrate extend techniques informed search ii techniques caching intermediate results 

application benchmark generators approach point combinatorial explosions occurs transition phase order identify combinatorial problems 
testing verifying implementation benchmarks results known 
automatic testing different optimization techniques dis enabled 

testing application problems encoded logical inference problems testing application knowledge bases manually composed automatically generated empirical experiments mass data possible 
second reasoning predicates discrete continuous domains real numbers integrated expressive conceptual reasoning description logics 
context configuration problems new dl representation language describing space possible configurations 
inference algorithm representation language soundness completeness termination shown 
third known theories dealing aspects spatial reasoning integrated framework conceptual reasoning description logics 
integrated treatment conceptual spatial reasoning semantical basis decidable description logic hard problem due best knowledge considered reported thesis 
application problems standard inference services important 
default reasoning conceptual spatial information problem solutions provided 
mentioned order solve application problem logical approach necessary analyze application problem formalized kind logic required 
application problems solved resorting specific inference service offered logical inference system 
different representation problems require different formalisms 
instance argued thesis case application scenario building deductive information system distributed context 
query results obtained inference systems different formalisms combined instance information system difficult problem translation data queries abstraction specialization combination results 
computational architecture developed certain subproblems solved formal reasoning techniques 
dealing technical aspects network protocols lower level communication techniques important problem 
progress area research methodology pursue thesis focus logical representations order define computed order organize multi agent inference scenario 
habilitation thesis shown expressive description logics various ways modeling problem solving application systems 
expressive description logics complement logic formalisms subproblems datalog deductive databases 
see broad spectrum possible applications main motivation practical theoretical investigations description logics thesis 
overview focusing description logic alcn hr chapter gives description logics definition syntax semantics concept role constructors 
terminological assertional axioms introduced 
furthermore inference problems defined 
description logic alcn hr sound complete abox calculus published haarslev ller 
alcn hr extends basic logic alc schmidt smolka number restrictions role hierarchies transitive roles 
chapter additional concept role constructors introduced subsequent chapters 
chapter provides foundation parts habilitation thesis 
order perform empirical tests practical inference algorithms tbox abox description logic inference system race reasoner aboxes concept expressions dl alcn hr implemented 
chapter gives design philosophy description logic systems see ller haarslev 
chapter motivation design dl representation reasoning systems 
dl system race described chapter 
race implemented convenient pronunciation alcn hr alc nature 
dl system abox reasoning dl alcn hr sound complete algorithms see haarslev 
implementation race practical inference procedures known literature see discussion adapted extended 
new algorithms data structures developed evaluated 
expressive description logic constructs combination sound complete terminating tableaux calculi theory literature cases currently unknown optimize average case 
implementing ad hoc version sound complete compute solutions simple inference problems methodology race system support constructors shown larger problems solved 
algorithms data structures implementation race chapter 
empirical evaluations different algorithms 
results published haarslev ller haarslev ller haarslev ller haarslev ller haarslev ller 
furthermore empirical investigations performance race encoding algorithmic problems modal logics searching maze described haarslev ller 
focus description logics considering direct correspondence description logics modal logics schild reveals results particular relevance parts computer science 
results chapter published habilitation thesis time 
chapter introduces results combination dl alcn hr constraint reasoning involving called concrete domains 
decidability resulting language alcn hr shown see haarslev 
language alcn hr logical representations application problems represented synthesis tasks configuration problems developed 
sixth chapter research results combination terminological spatial reasoning discussed 
promising combination spatial temporal conceptual reasoning semantical basis resorting ad hoc techniques dl alcrp haarslev haarslev 
today theoretical results particularly important knowledge representation formal modeling important field object oriented modeling database theory combination conceptual instance spatial reasoning possibly influence areas computer science near 
chapter originally earlier approaches concerning expressive variant haarslev ller 
examples haarslev ller 
initial results language alcrp calculus published lutz see lutz ller 
reader mainly interested spatial reasoning combination terminological reasoning skip chapters reading chapter may continue chapter 
chapter considers spatioterminological default reasoning ller wessel applications image understanding ller applications visual query languages haarslev 
chapter presents extended example 
different application problems different representation languages discussed 
order combine specific representation formalisms solving compound problems agent scenario investigated 
broker agent transform queries way specialist agents answer queries 
languages scenario implementations available practical applications 
pointers ongoing new results provided appropriate 
chapter published ller ller 
abstraction operators developed field machine learning common subsumer operation support example query answering 
parts chapter refer notions defined chapter concrete domains chapter complex roles 
chapter combination description logics bayesian networks information system 
new results defining abstraction operators framework see 
development abstraction operations context conceptual probabilistic inference systems demonstrates formalisms fruitfully combined 
chapter description logic alcn field formal inference systems description logics proven sound basis solving application problems 
detailed introductions description logics woods schmolze donini baader sattler 
relation description logics logic programming techniques described baader 
description logics main notions domain modeling concepts unary predicates roles 
dls roles binary predicates see calvanese dl ary roles 
set axioms tbox modeling terminology application 
knowledge specific individuals interrelationships modeled set additional axioms called abox 
description logic alc schmidt smolka propositionally complete representation language providing conjunction universal quantification full negation 
introductory example consider family relationships 
instance woman human gender restricted female man human gender restricted male 
concepts male female disjoint 
parent human child human 
furthermore mother woman parent 
kind terminological knowledge easily modeled concepts roles language alc 
woman human gender female man human gender male parent human child human mother woman parent male female declarations declare necessary sufficient conditions concepts left hand side 
declaration necessary conditions provided male declared disjoint female 
follows concepts man woman disjoint 
description logic alcn hr extends alc number restrictions role hierarchies transitively closed roles 
instance family example assume role descendant declared transitive 
direct descendant distinguished role hierarchies non transitive role child declared descendant 
child descendant concept terms composed describe complex conceptual notions 
queen small family defined mother children descendants 
type queen described axioms queen small family mother child descendant 
prince princess prince man princess woman case necessary conditions concepts queen small family prince princess provided 
turn reasoning individuals 
exists individual child turn child due descendent transitive child implicitly declared descendant 
child child queen small family descendant gender female individual known instance mentioned concept queen small family individual inferred instance prince princess 
assertional axiom descendant gender female proven instance princess due disjointness male female alternative prince disjunction prince princess ruled 
sections representation language alcn hr basic inference problems formally defined 
concept language alcn hr presenting syntax semantics language alcn hr definitions required 
definition roles role axioms role hierarchy set role names 
role name called atomic role role brevity 
furthermore set simple roles 
ifr role names role inclusion axiom 
ifr role name transitive called role transitivity axiom 
kinds axioms called role axioms 
set role inclusion axioms called role hierarchy 
additionally define set ancestors descendants role set transitive roles set role axioms 
definition role descendants ancestors set role axioms defined reflexive transitive closure set role axioms set defines ancestors descendants role set role axioms set transitive roles tr set role axioms defined transitive 
definition role box finite set role axioms called role box tr 
role box called brevity 
index omitted role box clear context 
definitions syntax concept terms alcn hr defined follows 
definition concept terms set concept names disjoint element concept term 
ifc concept terms arbitrary role simple role expressions concept terms conjunction disjunction negation value restriction exists restriction number restriction number restriction 
concept term may put parentheses 
concept names called atomic concepts 
brevity concept terms called concepts 
considered abbreviation arbitrary role term rewritten 
consider terms number restrictions language 
definition terminological axiom tbox concept terms terminological axiom 
terminological axiom called generalized concept inclusion gci 
finite set terminological axioms called terminology tbox 
pair axioms abbreviation 
definition gives model theoretic semantics language introduced 
definition semantics interpretation consists set domain interpretation function interpretation function maps concept name subset role name subset symbols concept expressions role names 
interpretation function extended arbitrary concept role terms follows denotes cardinality set interpretation model concept iff 
interpretation satisfies terminological axiom iff model tbox iff satisfies terminological axioms interpretation model iff role inclusions addition transitive assertional language alcn hr language representing knowledge specific individuals introduced 
definition assertional axioms abox oo set individual names individuals set oo old individuals disjoint set new individuals 
old individuals names explicitly appear abox input algorithm solving inference problem see initially mentioned individuals 
elements generated internally 
concept term role name oo individual names expressions assertional axioms abox assertions concept assertion role assertion abox finite set assertional axioms 
need additional terms individual called direct successor individual abox iff contains assertional axiom individual called successor direct successor exists chain assertions 
bn rn 
case ri rj ri call direct successor direct predecessor defined analogously 
interpretation function interpretation extended assertional language 
individual name mapped single element way oo ai bi unique name assumption 
ensures different individuals oo interpreted different objects 
unique name assumption hold elements ai bi may hold interpretation satisfies assertional axiom iff ai ci iff ai bi ri interpretation model abox iff satisfies assertional axioms interpretation model tbox abox said satisfy respectively 
definition knowledge base knowledge base triple tbox abox 
interpretation model knowledge base iffi model inference problems define inference problems 
inference problems relevant alcn hr description logics discussed 
definition consistency problem concept called consistent tbox iff exists model model 
abox consistent tbox model model 
knowledge base called consistent iff exists model 
concept abox knowledge base consistent called inconsistent 
definition subsumption problem concept term subsumes concept term tbox interpretations models 
subsumes said subsumed basic problems additional inference services provided description logic systems 
basic reasoning service compute subsumption relationship atomic concepts elements 
inference needed build hierarchy concept names specificity 
problem computing specific atomic concepts mentioned subsume certain concept known computing parents concept 
children general atomic concepts mentioned subsumed certain concept 
name concept ancestors concept descendants transitive closure parents children relation 
computation parents children concept name called classification tbox 
important inference service practical knowledge representation check certain atomic concept inconsistent 
usually incoherent atomic concept consequence modeling errors 
checking consistency atomic concepts mentioned tbox computing parents children called tbox coherence check 
description logic supports full negation consistency subsumption mutually reduced subsumes tbox inconsistent inconsistent subsumed 
consistency concept terms reduced abox consistency follows concept term consistent tbox iff abox consistent 
definition instance problem individual instance concept tbox abox iffi models 
description logics support full negation concept terms instance problem reduced problem deciding abox inconsistent 
test called instance checking 
definition direct types specific atomic concepts mentioned tbox individual instance called direct types individual knowledge base 
direct types inference problems reduced subsequent instance problems see nebel details 
definition instance retrieval retrieval inference problem find individuals mentioned abox instance certain concept term retrieval inference problem reduced subsequent instance problems 
definition filler retrieval set fillers role individual knowledge base defined ax means models models ax 
abox consistency problem decidable filler retrieval inference problem implemented follows 
test atomic concept mentioned tbox easy verify determining filler role individual reduced checking individuals mentioned abox abox test test inconsistent additional inference problems called non standard inference problems discussed literature 
sake completeness just mention matching baader sters rewriting concept terms terminologies baader common subsumer lcs cohen baader molitor computation maximal consistent minimal inconsistent abox subsets baader hollunder 
detailed discussion applications inference problems see cited literature 
haarslev ller shown abox consistency problem language alcn hr decidable 
decidability shown giving tableaux calculus sound complete terminates proofs see haarslev ller 
chapter description logic inference system race described 
race results haarslev ller implements dl reasoner offering inference services standard inference problems described 
dls applications example inference services offered dl representation inference system build application domain models implement specific sub problems applications 
examples section 
note conciseness examples somewhat small grained convey main ideas 
specifying terminological axioms modeling concepts merchant navy domain 
captain person ship home port 
port captain captain cargo ship ship captain captain cargo storage ship repair dock ship terminological axiom declares subsumption relationship atomic concepts 
persons 
axiom ship specifies filler attribute home port port dl terminology filler instance concept port 
furthermore filler attribute captain captain 
note necessary introduce name concepts application 
instance useful retrieve ship individuals captain role filler role captain 
implemented invoking retrieval inference service concept ship captain 
instance deductive information system certain concept term automatically computed instance web crawling activities real world problems large tboxes usually required 
ontology engineering phase large project new concept name introduced obvious concept names terminology related 
add example axiom ship captain example tbox 
ship captain ship captain captain explicitly stated evident due semantics ship captain subsumes cargo ship 
say cargo ship subconcept ship captain 
invoking inference service computing parents children new concept name ship captain example tbox lead answer ship parents cargo ship children 
dl reasoning inference system automatically issues warning probably modeling mistake concept name inconsistent 
furthermore concept names subsume equivalent warning generated 
subsumption relationships obvious subsumption concepts ship captain cargo ship example axioms indicate 
role axioms defined 
container storage cargo storage cooling storage container storage gas storage container storage role container storage cargo storage 
container storage defined cooling storage gas storage 
concept axioms added tbox 
container ship cargo ship container storage container ship container storage container cooling storage cooled container gas storage gas container type ship container storage cooling storage gas storage container ship ship 
called domain restriction role container storage declared second axiom 
individuals set relation individual role container storage left hand side individual container ship 
range restrictions defined 
individual holds fillers role container storage instances container fillers cooling storage instances concept cooled container fillers gas storage instances gas container 
axiom specifies type ship object fillers container storage fillers cooling storage fillers gas storage 
assume due safety problems container ships storage capacity containers cooled may contain gas classified dangerous ships 
instance axiom added tbox order define concept dangerous ship necessary sufficient conditions 
dangerous ship container storage cooled container gas container cargo storage toxic waste tbox classification non obvious subsumption relationships apparent 
due domain restriction container storage concept dangerous ship inferred instance container ship 
furthermore interesting deduced concept type ship subsumed dangerous ship 
fillers container storage exist individuals fillers roles cooling storage gas container 
fillers container storage instances concept cooled container gas container 
classifying tbox asking concept descendants dangerous ship yields type ship possibly 
container include dangerous things 
instance certain class containers toxic waste innocent name defined 
type container container cargo storage toxic waste type ship container storage type container unfortunately axioms type ship classified dangerous ship 
case cargo storage declared transitive role 
indicate facility supported alcn hr 
turn abox example introduce assertional axioms individuals 
circumstances individual instance concept instance set relation instance 
example ship individual instance concept ship set relation 
similar situation occurs persons customers set relation bank 
dynamic classification problem aboxes object representation 
ship example continued assertions 
ship yard yard ship repair dock created ship asking direct types reveals instance ship set relation yard ship repair dock due axiom tbox fillers ship repair dock instances ship 
instance classification dynamic longer ship related statement retracted 
applications kind dynamic typing trigger invoke certain actions 
instance listing set ships ship marked accordingly note sense abox expressive relational database 
assertional axioms individuals declared instances arbitrary concepts dl 
particular possible declare individual instance example 
standard databases usually supported generality 
difference description logic databases dls reasoning standard inference mode captain added example abox asking instance ship captain yield answer 
number restrictions simulate kind closed world reasoning 
example asserting abox statements captain ship automatically classified ship captain sufficient conditions ship captain fulfilled see axiom ship 
advanced reasoning examples description logics general alcn hr particular subsequent chapters 
related dl theory literature different kinds additional concept role constructors discussed hard characterize different languages common naming scheme 
seen example alcn hr different letters indicate operators supported specific description logic simple number restrictions indicates role hierarchies supported 
stands transitive roles 
alcn hr extension alcn polynomially reduced alcn buchheit vice versa 
letter indicates role conjunctions 
possible rephrase hierarchy role names set role conjunctions vice versa buchheit 
language alcn hr extends alcn additionally providing transitively closed roles 
alcn hr extends related description logics sattler horrocks 
contrast alcn hr logic supports called features letter 
principle role declared feature implicit gci form assumed 
features functional roles 
equality features fillers enforced letter 
description logics provide full negation 
case letter indicates exists restrictions form provided language ale provides existential restrictions disjunction negation concept names 
subsequent chapters letter indicate role hierarchies single inheritance 
furthermore suffix trans indicates availability operator transitive closure roles baader 
sound complete tableaux calculus concept reasoning alc qualified number restrictions hollunder baader 
qualified number restrictions indicated letter compared simple number restrictions qualified number restrictions restrict number fillers instances concept fillers 
logics extended tableaux calculus deciding concept consistency language shiq horrocks 
addition shiq supports qualified number restrictions inverse roles indicated letter 
naming scheme habilitation thesis name shiq tests prototype implementation horrocks reveal optimizations expressive languages addition inverse roles devised 
approach de giacomo lenzerini logic ciq reasoning tboxes aboxes introduced 
reasoning procedures developed ciq polynomial encoding ciq tboxes sublanguages ciq de giacomo lenzerini 
similar approach taken aboxes languages ci cq 
comparison alcn hr approaches mentioned ciq offers operators inverse roles transitive closure roles supports role conjunction role hierarchies allows number restrictions primitive roles 
implementation ciq developed 
description logics provide support reasoning individuals concept terms see schaerf 
describing concept extensionally set individuals construct 
indicated 
logics full existential restrictions form called fills construct introduced indicated letter 
construct indicates certain individual filler role instances concept 
operator syntactic convenience existential restrictions provided pronunciation assumed alc 
written see schaerf 
description logics supporting operator instance concept consistency problem defined knowledge base abox considered tbox classification 
practice means possible classify tbox advance results aboxes refer tbox 
open problem concept constructor sets individuals integrated expressive description logics inverse roles 
detailed overviews additional description logic operators see instance baader sattler 
tableaux calculus deciding abox consistency problem haarslev ller provides basis alcn hr description logic system race implements sound complete terminating inference algorithms standard inference problems mentioned 
race system optimization techniques implementation introduced detail chapter 
extension shiq dealing aboxes horrocks 
time writing dl inference system logic supporting reasoning abox inference problems comparable race available 
see chapters direct implementation tableaux calculus chronological backtracking hardly appropriate practical purposes 
dedicated search strategies necessary order avoid combinatorial explosion occur simple inference problems 
established new optimization techniques introduced implementation alcn hr give overview related development system architecture representing reasoning terminological assertional knowledge 
chapter related dl systems chapter description goals development different dl systems historical perspective 
description dl systems allows important insights development knowledge representation research field 
design decisions known systems discuss chapter reflect trends different knowledge representation research areas characterize point view knowledge representation different researchers advocate 
chapter discusses general capabilities systems gives analysis main language features design decisions system architectures 
analysis current systems light historical perspective lead new ideas development powerful description logic systems 
previous descriptions dl systems macgregor woods schmolze horrocks publications dl theory contain discussions description logic systems patel schneider nebel schmidt included appropriate 
systems mentioned see woods schmolze nebel 
generation inspired research human cognitive behavior proposals knowledge representation languages discussed late sixties 
quillian publications languages called semantic networks see quillian 
originally semantic network formalisms seen alternatives order logic 
similar spirit minsky introduced initial notion frame system 
motivation representation formalisms mimic human reasoning sense achieving cognitive adequacy 
idea support problem solving appropriate representation structures resemble representation structures assumed human information processing 
exploitation inheritance predominant idea frame systems 
specification knowledge bases simple representation structures intuitive epistemological adequacy 
pointed woods simple specify inference system supposed compute 
late seventies saw initial research relation frame systems order logic hayes hayes revealed aspects frame systems considered special instantiations order reasoning 
hayes argued frame reasoning entirely new way knowledge representation particular advantages order reasoning 
specific features frame systems order reasoning defaults understood time 
consequence publications researchers consider frame systems semantic network systems possible alternatives logic approaches 
criticisms early frame semantic network representation formalisms stimulated research development mathematical structures techniques defining semantics constructs supported different representation languages 
instance early frame systems clear distinction constructs representing generic knowledge sets individuals knowledge specific individuals 
furthermore frames data structures procedural programs 
programs formal specification expected compute rarely provided 
interpreting frame structures data structures woods suggested formal semantics clearly specify computed inference algorithms 
kl inspired critics woods brachman started develop new representation system called kl inherently included notion inferring implicit knowledge declarations brachman brachman 
initial approach logic kl started era representation systems formalize application problems inference problems constructs supported representation language 
prevailing inference patterns centered inheritance brachman 
final report kl language published brachman schmolze 
core ideas kl representation language epistemological level resulted problems languages offering built primitives general representation purposes cd theory schank 
providing general built primitives kl specific representation prob lem set adequate primitives defined user 
primitives denoted called concept names 
idea concept forming operators build new concepts basic concepts 
compound concepts referred concepts concept terms concept descriptions 
generic concepts intended denote classes individuals individual concepts intended denote individuals see nebel 
individuals related called roles turn primitive roles role names roles described role constructors brachman schmolze 
concepts roles building blocks representational purposes 
main idea concepts concept constructors kl meaning concept derived meaning superconcepts restrictions associated concept brachman schmolze 
kl generic concept consists set superconcept names set role descriptions set structural descriptions patel schneider 
roles viewed potential relationships individuals class denoted concept individuals world nebel 
role descriptions restrictions 
restricts class permitted fillers value restrictions number fillers number restrictions 
describe possible value number restrictions 
structural descriptions state relationships fillers roles see patel schneider 
individual concepts consist simply set values roles plus set generic concepts instance 
subconcept generic concept individual concept satisfy restrictions inherited generic concept 
semantics individuals completely worked see schmolze brachman cited nebel 
representation structures offered kl similar semantic networks frames 
initially structures offered kl called structural inheritance networks brachman brachman brachman levesque authors talk frame structures 
accordance nebel argue contrast cd theory schank providing large set primitive representation structures names kinds representation purposes development goal kl 
nebel points nebel important unique kl core idea note kl languages specific syntactic constructs specifying superconcepts 
specific constructs longer logic concept languages nineties 
big differences frame systems description logic systems restriction holds set relation role kl system concludes instance standard frame systems set relation known instance frame systems warning issued error signalled 
proving ways specify concept definitions possibility knowledge engineer declare relation high level concepts lower level primitives 
concept definition assignment unique name concept term 
kl known distinction kinds concept definitions definitions necessary sufficient conditions definitions necessary conditions called primitive definitions investigated knowledge representation purposes time 
original approach cycles allowed set concept definitions 
important consequence concept definitions necessary sufficient conditions reasoning relationships concepts important 
superconcept subconcept relationships dependent concept terms definitions 
especially notion defined concepts necessary sufficient conditions led idea concept subsumption 
frame systems superconcepts explicitly kl set direct superconcepts concept names computed automatically set concept definitions 
idea inheritance hierarchy subsumption hierarchy computed automatically inferring implicit information 
inferences kl open world assumption 
considering inheritance structure lattice direct superconcepts concepts inserted concepts automatically 
kl notion told subsumer mentioned explicitly list called superconcepts semantics computed specific subsumers concept names appearing tbox specific concept names subsuming certain concept term 
development algorithm computing direct subsumers classifier described schmolze 
inference component called realizer computes specific atomic concepts individual instance mark 
initial kl systems implemented interlisp smalltalk fikes 
inference services offered classifier realizer exploited system 
investigation defaults exceptions concept definitions published brachman 
nowadays semantical theory defaults description logic clearer see baader hollunder baader hollunder literature authors word definition synonym concept terms schmidt see woods 
case primitive concepts necessary conditions introduced specific marker concept terms 
semantics cycles analyzed baader baader nebel nebel 
called descriptive semantics provides advantages compared called fixed point semantics 
details see nebel 
publications expressive description logic supporting cyclic axioms descriptive semantics sound complete calculus buchheit 
baader schlechta padgham zhang padgham nebel baader hollunder baader hollunder donini 
kl workshop schmolze brachman clear informal specification semantics kl concept role constructors led serious problems 
development classifier intuitive meaning kl formalism nebel 
attempts logically reconstruct representation constructs schmolze israel israel brachman resulted deeper understanding formalism 
formal semantics implemented algorithms classification realization shown incomplete 
investigations showed kl formal semantics logical reconstruction approaches undecidable holds combination conjunction value restrictions role value maps schmidt 
brachman levesque thoughts tractability subsumption sublanguages discussed 
terminological reasoning concept definitions sublanguages low expressiveness shown inherently intractable nebel 
proposals semantics valued logics patel schneider patel schneider patel schneider patel schneider ensure tractable algorithms concerning concept consistency reasoning result weak expressiveness intuitive inferences sanctioned semantics see nebel 
result schmolze brachman semantics individual concepts quite clear concerning coreference unique name assumption see 
kl workshop schmolze brachman notions hybrid reasoning system consisting tbox set concept definitions abox set assertions concerning individuals precise 
change view kl spelled schmolze brachman pp 
see nebel summarized follows names representation structures important functionality inference services system provides 
inferences formally defined semantics representation formalism 
view led development functional view knowledge representation pursued development system krypton 
krypton knowledge representation system krypton brachman brachman brachman seen approach define new language kl family formal tarskian semantics 
distinction tbox abox mentioned krypton approach see macgregor 
similar kl distinction primitive defined concepts computation specific atomic concepts instantiate individuals core ideas krypton 
furthermore goal overcome problems individuals kl nebel 
krypton offers concept language low expressiveness 
initial approach brachman expressive tractable see mac gregor revised version brachman concept constructors krypton defined conjunction value restrictions role chains 
subsumption checking polynomial patel schneider 
abox full fledged resolution fopl theorem prover stickel abox reasoner krypton incomplete 
perspective krypton starts order logic theorem prover augments special purpose inference system terminological reasoning cut combinatorial search vilain 
krypton regarded efforts combining knowledge representation theorem proving techniques applications nebel 
dealing specific representation structures operations krypton offers called functional approach interface functions tell ask system define knowledge base ask queries respectively 
sense functional approach means krypton necessarily maintain instance inheritance hierarchy abox graph structure 
internal implementation purposes inference engine graph structures hidden user order avoid procedural operations carried knowledge representation structures 
arbitrary procedural operations usually related semantics representation formalism hard characterize represented computed solutions inference problems 
focus krypton structures maintained system centered question system user services available 
publications idea described knowledge level newell inference services concept terms checks consistency disjointness subsumption tbox specific subsumers abox consistency instance checking realization instance retrieval offered inference services 
user know level dependent implementation details questions system capable answering operations permitted allow new information provided derived 
instance important association individual certain role filler represented terms memory arrangements called symbol level 
counts underlying implementation operations supported order answer queries semantical level 
view kl representation systems major achievements krypton project 
kl time krypton knowledge representation system developed successor kl 
new implementation kl schmolze israel schmolze schmolze mark 
discussed roles ordered respect subsumption see schmidt 
assertional components kl initially discarded system see user guide robins 
compared initial kl implementation algorithms classifier faster average case obvious information exploited larger degree see macgregor macgregor 
subsumption algorithm incomplete hard characterize inferences omitted schmolze israel see patel schneider 
assertional reasoning component added system rup mcallester 
resulting system called kl vilain see schmidt 
kl propositional reasoner equality subsystem augmented called quantificational reasoning component subsystem 
propositional part component incremental additions retractions supported due facilities provided rup 
shown patel schneider concept language contains concept role constructs render satisfiability problem concept terms undecidable see schmidt 
concerning hybrid reasoning systematic integration tbox abox reasoning shortcomings 
rup different constants necessarily denote different objects unique name assumption built assertional component 
number restrictions imposed concepts intended effects concerning hybrid reasoning 
sources incompleteness pointed see analysis inferential gaps nebel 
research kl system demonstrated hybrid reasoning just matter integrating reasoning subsystems software level 
hybrid reasoning requires dedicated architecture implementing sound complete calculus turn developed deep analysis semantics representation constructs 
principle idea exploiting subsumption information resolution order reasoning integrated theorem proving systems 
research patel schneider influenced krypton architecture performance problems approach 
goal increase expressive power terminological representation component way efficient subsumption algorithm developed 
basically supported conjunction value restriction number restrictions concept forming operators 
minimum number restrictions range restricted roles qualifying minimum number restriction see patel schneider 
order provide effective inference algorithms information retrieval scenario approach expressiveness assertional component cut representation system comparable database revision mechanisms 
subsumption shown np complete see nebel nebel details 
initially proposed subsumption algorithm polynomial runtime incomplete 
called frame system reasonable expressiveness offered abox language 
frame essentially specification conditions describing individual instance terms restrictions 
supported defined frames primitive frames 
system adopts small interfaces approach krypton models built declaration interface tell interface application services realized query interface ask interface 
called frame system frames treated record structures manipulated procedural programs 
authors argued small knowledge representation system part larger systems different subcomponents 
main achievement small beautiful approach led design system classic discussed detail section 
second generation dl systems prototypical implementations generation systems study knowledge representation problems second generation dl systems extensively serious applications 
implementations discussed section prototypes stable 
addition nineties systems called description logic systems 
discuss systems tractable languages complete algorithms 
classic basic classic system supported logic aln tboxes aboxes plus facilities dealing numbers borgida 
classic available research purposes 
implementation languages common lisp interfaces described resnick 
full classic contained concept constructors referring individuals concept terms 
subsumption full classic initially assumed polynomial borgida 
problems individuals full classic recognized patel schneider 
time classic shown np complete lenzerini schaerf 
modified semantics concept constructors see borgida patel schneider interpretation function maps individuals concept terms disjoint sets domain objects 
semantics concerning individuals inference algorithms classic system shown complete borgida patel schneider 
non standard semantics concept constructors effect achieved exists restrictions atomic concepts disjunction atomic concepts individual new atomic concept ai introduced 
atomic concepts mapped sets individuals 
additionally set axioms ensures new atomic concepts disjoint 
term form replaced ai 
terms form 
replaced ai ain 
abox individual concept assertion added ensure individual instance associated atomic concept ai 
abox real coreference roles enforced 
hand call classic system complete 
refers non standard semantics individuals supported current system implementations 
hand transformation clear classic limited kind disjunction concept names definitions exist expressed retaining polynomial inference algorithms 
recommended techniques knowledge system development classic outlined brachman 
brachman brachman points tractable description logic guarantee system useful practice 
classic system carefully designed meet practical requirements guarantee predictable system behavior 
context system expected requires queries knowledge bases rarely change 
architectural design classic supports precomputation index structures queries answered quickly simple storage retrieval 
architecture possible careful selection concept role constructors description logic language 
note concept constructors directly provided classic 
ference services description logic supported classic implemented transforming concept expressions normal form structural subsumption 
normal form computed queries answered inspecting data structures encode normal form 
noted classic retraction told information possible optimized 
facility offered classic rule system 
rules applied individuals explicitly named abox 
furthermore rules applied forward chaining way 
basically rule precondition concept concept 
shown individual mentioned abox instance precondition concept concept assertion stating membership individual concept added abox 
order provide support modeling rule base statically checked inconsistencies 
instance rules preconditions subsume disjoint 
furthermore classic provides simple support closed world reasoning resnick see 
closing role individual means adding appropriate maximum number restriction role 
maximum number fillers restricted largest integer minimum number restriction integer corresponding role entailed knowledge base 
problem combination rules exact sequence closing operations determines holds resulting abox 
problems concerning different closing operations considered default reasoning theoretical background baader hollunder baader hollunder donini rosati 
integration defaults classic system see wahl lambrix 
classic systems provides support incorporating inferences domains 
consistency subsumption checking expressions domain reals integrated classic system extension interface borgida 
classic description logic systems designed respect users non experts description logic theory 
important lesson learned classic approach importance explanation output pruning facilities mcguinness borgida mcguinness borgida mcguinness 
classic system capable supporting reasonable form error reporting brachman 
current state art hardly adequate measure quality services brachman 
classic successful description logic modeling environment low expressiveness classic description logic hard system kinds applications 
cases users wanted expressiveness patel schneider 
sections discuss systems expressive description logics 
expected increases expressiveness came certain price 
predictability behavior classic terms performance reached systems implementing complete algorithms 
hand incomplete algorithms problem results computed system trusted general 
complete incomplete debate expressive description logic systems started eighties nineties 
describe systems loom back incomplete algorithms 
research description logic systems complete algorithms summarized discussion systems kris crack 
loom loom architecture macgregor bates macgregor offers tbox abox reasoning facilities description logic characterized name plus additional constructs dealing numbers see brill horrocks 
loom kl concept definitions necessary necessary sufficient conditions play important role domain modeling loom 
emphasized truth maintenance facilities revision built loom architecture right influenced design system macgregor macgregor brill 
loom versions description logics macgregor brill versions attempt develop description classifier predicate calculus macgregor 
instance facilities dealing definitions relations added 
inference algorithms loom system known incomplete 
design goals loom support rule programming yen yen macgregor burstein 
rule system possible specify additional necessary conditions individuals explicitly mentioned abox ii derived instances certain defined concept 
additional necessary conditions called implications loom macgregor 
note additional necessary conditions exploited tbox reasoning implications confused generalized concept inclusions standard newer systems 
order meet performance requirements applications loom developed natural language image interpretation incomplete algorithms concept consistency subsumption implemented 
concerning abox reasoning loom applications require specific strategies avoid computation unused results 
employing usual forward chaining strategy computing specific atomic concepts abox individuals instances loom uses scheme considers queries posed system 
backward chaining strategies query answering implementation macgregor brill 
rule system important detect individual instance concept precondition rule 
case forward chaining techniques exploited macgregor macgregor brill 
combination forward chaining backward chaining inferences specified certain application problem marking concepts accordingly 
user control inference process means responsible estimating effects declarations 
arguments loom approach summarized follows intractability representation language hardly avoided fulfill requirements users 
idea support features system set application specific ad hoc supplements resides macgregor 
obviously incompleteness problem long answers inference system interpreted right way answers trusted 
researchers argued inherent danger non expert users know recognize potential danger cf 
complete systems baader hollunder baader hollunder discussed 
combinatorial explosion occurs complete algorithm practice result available 
concerning incomplete algorithms decidable description logics similar arguments modeling environments order logic mentioned certain application concept terms checked consistency combinatorial explosion occurs complete algorithms incomplete algorithms provide support building tbox 
just signalling timeout execution complete algorithm runs combinatorial explosion result information 
case incomplete algorithm succeed finding inconsistencies 
note modern inference system technologies support complete reasoning incomplete reasoners preprocessors order speed inference system see chapter 
loom supports different kinds individuals classified instances light instances clos instances 
different kinds instances different levels inference services supported 
classified instances set specific atomic concepts classified individual instance computed new assertions specified 
instances rule forward chaining engine triggered possibly new assertions automatically added abox details see macgregor brill 
problem loom approach user perspective hard characterize source incompleteness loom reasoning algorithms see discussion horrocks 
inference techniques loom characterized macgregor system incomplete adequate measure quality service terms implementation independent characterization 
instance classic characterization incompleteness inference system concerning individual reasoning terms weak semantics offered representation constructs see 
noted specifying incompleteness semantical level trivial task 
incompleteness issues important context 
instance theoretical background giving semantics rule computations analyzed donini donini donini 
incomplete reasoning facilities problem considered tell ask interface 
example demonstrate incomplete inference algorithms effects situations user aware loom supports closed world reasoning 
strategy closing role individual count number known role fillers 
addition individuals explicitly mentioned abox existential restrictions minimum number restrictions considered 
assuming individuals result inconsistency 
demonstrated simple knowledge base example abox 
assume tbox exist axioms implicitly declared disjoint concepts loom system specific reasoning techniques conditioning implemented compute number necessary fillers 
closing role adding abox inconsistent 
loom incomplete case disjointness detected fillers assumed exist closing process 
added maximum number restriction restrictive system unsound closed world reasoning employed 
note semantic basis automatic closing roles offered loom hard characterize expressive representation languages 
obviously closing role candidate 
closing role possible 
case individuals specific constraints 
current version loom implemented common lisp available research purposes 
new system called common lisp java platforms way 
back flex research back berlin advanced computational knowledge representation system started approximately time loom system initiated 
back called knowledge representation environment von luck kindermann quantz 
description logic initial back system called 
support reasoning numbers attribute sets 
research inference algorithms basic back language stimulated development theoretical results complexity concept consistency reasoning nebel nebel semantics cycles nebel 
additionally terminological reasoning considered investigation development hybrid architecture consisting tbox abox 
issues integration balancing hybrid knowledge representation systems balanced expressiveness tight coupling hybrid systems analyzed nebel von luck nebel von luck 
research back system helped shape current view balanced representation schemes tbox abox 
tbox concept terms abox assert information individuals 
addition distinct individuals assumed denote distinct objects 
number role fillers counted compared number restrictions done krypton pointed woods schmolze 
algorithms back instance checking instance retrieval described nebel von luck nebel von luck kindermann randi 
general discussion problems incomplete algorithms sketched previous section applies back system inference algorithms back known incomplete 
order provide knowledge representation environment back architecture designed support incremental additions abox 
back attempts implement algorithms reasoning retractions abox assertions 
back supports retraction told information called literal retraction nebel kindermann 
supported loom system 
abox assertions retrieved database automatically computing sql queries 
applications considered back project reasoning time important 
integration temporal reasoning terminological reasoning investigated project members 
investigations incorporate temporal reasoning terminological reasoning reported schild fischer 
successor system flex quantz incomplete algorithms implemented description logic 
additionally reasoning equations inequations concerning integers supported 
furthermore flex system served testbed investigating weighted defaults quantz royer 
initial implementation flex developed prolog 
flex reimplementation 
implementation faster application knowledge bases performance sufficient 
appropriate optimization techniques see chapter investigated context description logics time development flex implementation 
general quite difficult compare different systems knowledge representation environments services offered representation languages standardized see patel schneider swartout proposal standardizing representation languages inference services 
experiences system implementations indicated limited expressiveness incompleteness reasoning lead problems applications 
researchers investigated implementation systems sound complete algorithms published eighties nineties 
consider schmidt smolka starting point development see donini 
tableaux calculi practical description logic implementations developed 
discuss architectures systems kris crack 
kris development sound complete reasoning systems expressive description logics started eighties 
main developments direction system kris 
approach kris implement sound complete algorithms expressive description logic develop optimization techniques tbox reasoning practice reasonable performance expected 
description logic kris alcn baader hollunder baader hollunder 
addition kris provides enumerated types operator interface reasoning called concrete domains baader hanschke baader hanschke linear inequations reals 
role conjunctions supported prototype implementation 
focus kris project tbox classification 
kris systems supporting sound complete abox reasoning expressive description logics 
multiple aboxes handled 
implementation language kris common lisp see hollunder user guide achilles description graphical user interface 
idea optimizing tbox classification exploit obvious information concerning told superconcepts primitive concepts 
concept definitions application knowledge bases right hand side conjunction concept names concept terms 
conjuncts concept names righthand side defined told subsumers 
important point avoid recomputation subsumption relations preceding computation steps 
caching propagation techniques implemented 
information propagated subsumption lattice expensive subsumption tests avoided possible 
kris system systematic empirical tests carried 
algorithms evaluated baader baader modern description logic systems see 
extensions defaults investigated see baader hollunder baader hollunder hollunder implemented kris 
benchmarks considered baader revealed performance kris tbox reasoning comparable systems time direct implementation nondeterministic tableaux algorithms developed proving decidability problems field theoretical computer science chronological backtracking kris leads performance problems applications 
main results kris project sound complete inference algorithms important starting point research optimized sound complete algorithms practical system development 
crack main research goals system crack implement sound complete algorithms dealing inferences individuals concept terms 
providing non standard semantics classic individuals mapped sets domain objects crack individuals mapped elements domain 
coreferences considered concept terms 
crack supports description logic 
implementation crack common lisp 
crack provided web interface 
similar way kris obvious information exploited architecture extent crack direct implementation tableaux rules underlying calculus 
middle nineties clear sound complete reasoning needed applications employed inference techniques developed manually deriving decidability results tableaux algorithms suited direct implementation 
clear long way go decidability proof working system performance average case 
section describe research new system architectures problem treated different optimization techniques concerning informed search retaining soundness completeness termination 
discuss research generation description logics provide optimization techniques suitable large scale practical applications overview additional systems interesting features developed nineties 
systems list systems discussed chapter certainly incomplete 
nineties large number projects involved development knowledge representation systems shows importance area 
usually description logic systems built core engine consistency checker 
services supplied important systems usable larger application projects 
points graphical manipulation representations investigated sb project kobsa kobsa 
implementation language common lisp 
techniques graphical interfaces support knowledge base development sb described see burstein description system 
furthermore sb contexts called partitions explored user modeling applications natural language generation 
important point dl inference systems persistency transaction management 
discussed back approach see borgida 
additional investigations rep system 
generation declarative nature description logic modeling important problems treated languages required longer tractable 
inspired theoretical advances handling number restrictions role tions generalized concept inclusions cyclic axioms descriptive se mantics alcn buchheit transitive roles sattler role hierarchies features horrocks nineties generation sound complete description logic systems developed 
logic alcn hr introduced previous chapter extended line 
calculus concept consistency de veloped alcn hr abox consistency considered right similar way alcn addition transitive roles alcn hr expressive alcn mentioned development sound complete calculi expressive description log ics alcn hr progress 
see optimization techniques expressive logics alcn hr developed 
new generation systems available today fact dlp race 
systems called fast average case 
systematic benchmarking performance competitions provided stable implementations 
directly implementing tableaux calculus theoretical decidability proofs complexity analyses rigorous investigation methods informed search developing generation description logic systems 
pioneering system fact 
details optimization techniques discussed chapter order novelties race architecture just mention features dl systems fact dlp sake completeness 
system fact supports tbox reasoning description logic horrocks horrocks 
furthermore experimental version fact supports concept reasoning inverse roles qualified number restrictions horrocks 
optimization techniques fact disabled version 
fact applications medical domain 
applications concerning query containment horrocks demonstrated necessity supporting abox reasoning 
similar techniques fact system dlp utilizes extended techniques optimizations horrocks patel schneider horrocks patel schneider horrocks patel schneider patel schneider 
dlp supports tbox reasoning description logic 
modal logic perspective called propositional dynamic logic pdl restricted form graded modalities simple number restrictions 
current version generalized concept inclusions tboxes forward supported optimizations possible certain algorithms dealing gcis currently implemented 
aboxes supported 
lessons learned considering evolving technology description logic systems clear nineties enormous interest description logic reasoning systems 
demonstrated quite large number system implementations 
currently modern dl systems sound complete algorithms 
system developers really rely answers computed dl system 
positive trend initiated development optimization techniques ensure stable runtimes average case inputs real world problems worst case complexity exponential see 
trend initiated landmark system fact 
original idea tell ask interface krypton realized modern systems 
currently systems support kind batch oriented behavior 
knowledge base tbox abox passed systems tell interface 
queries answered ask interface 
incremental additions knowledge base possible query answered 
difficulty complex transformations knowledge bases necessary order compute internal representation relatively fast query answering see discussion optimization techniques subsequent chapters 
price pay algorithms appropriately handling incremental additions knowledge base known 
features explanation facilities retraction developed expressive dls 
second quite important lesson see description logics expressiveness sound complete algorithms impose different view modeling 
concept definitions known instance classic longer central modeling device generalized concept inclusions representing cyclic implications equalities available 
third lesson learn considering description logic systems development implementation language hardly important magnitude speed compared expressiveness description logic 
really counts set optimization strategies implementation index data structures selection clever heuristics 
attempts provide distributed implementation description logic system 
performance problems network communication lead server solutions knowledge base processed single workstation computer may accessed different clients 
benchmark generators standardized application knowledge bases metering system performance 
different system implementations compared 
lesson development techniques incorporating space time description logics open issue 
necessity semantics integration temporal terminological reasoning emphasized investigations back project 
early approaches shown undecidable halpern shoham schild 
context planning opportunities integrated environment combining temporal terminological reasoning clearly demonstrated rhet system allen 
shown spatial reasoning topological relations induces non obvious subsumption relations concept terms haarslev ller 
return topic chapter 
description logics called object representation formalisms approaches deal ary relations schmolze calvanese 
chapter race tableaux calculus inference system chapter investigates optimization techniques practical reasoning expressive abox description logic systems 
discuss optimization techniques known field introduce new techniques tbox abox reasoning 
analysis description logic alcn hr described chapter 
order empirically evaluate optimization techniques alcn hr tableaux calculus dl system race developed haarslev 
race implements alcn hr reasoner answering queries concerning aboxes tboxes generalized concept inclusions gcis handle knowledge bases processed fact dlp 
demonstrated optimization techniques developed testing concept consistency concept subsumption horrocks patel schneider scale testing abox consistency directly integrated abox reasoning architecture 
introduce analyze optimization techniques novel significantly extend techniques horrocks patel schneider 
race supports logic alcn hr alcn hr expressive dl solving application problems see design philosophy race support representation constructs optimization techniques available developed 
seen section standard inference problems alcn hr reduced knowledge base consistency 
calculus decide consistency alcn hr knowledge base devised 
publication calculus language haarslev ller 
basically race freely available research purposes haarslev ller 
calculus set non deterministic rules 
implementation non deterministic algorithm dedicated search techniques required see 
tableaux calculus alcn hr step original abox knowledge base transformed tbox idea derive abox consistent empty tbox iff consistent 
calculus introduced applied role box order define transformation steps deriving introduce technical terms 
concept term define negation normal form 
definition negation normal form concept negation normal form iff negation signs occur front concept names 
proposition alcn hr concept term transformed concept nnf negation normal form recursively applying transformation rules subconcepts left right 
rule applicable resulting concept negation normal form models models nnf vice versa 
transformation possible linear time 
order deal gci number restrictions additional abox assertions internally 
definition additional abox assertions concept term individual names expressions assertional axioms universal concept assertion inequality assertion 
read 

interpretation satisfies assertional axiom iff iff ready define augmented abox input tableaux rules 
definition augmented abox initial abox define augmented abox tbox applying transformation rules gci assertion added concept term occurring transformed negation normal form 
oa 
set individuals mentioned set inequality assertions ai aj ai aj oa added order check consistency alcn hr knowledge base augmented abox computed 
tableaux rules applied augmented abox role box rules applied accordance completion strategy see 
lemma knowledge base consistent consistent role box empty tbox 
proof 
consistent exists model id ci di equivalent ci di di words due semantics satisfied 
shown applying arguments direction 
terminological axioms appropriately represented model model vice versa 
tableaux rules require notion blocking applicability 
called concept sets ordering new individuals notion blocking individual 
definition concept set abox individual occurring define concept set 
definition ordering define individual ordering new individuals elements occurring abox ifb introduced new individuals definition blocking individual blocked abox individuals call blocking individual conditions hold 

blocking individual said blocked ready define completion rules intended generate called completion see abox point refer abox consider aboxes derived definition completion rules conjunction rule 


disjunction rule nondeterministic 


role value restriction rule 



transitive role value restriction rule 



universal concept restriction rule 


mentioned 
role exists restriction rule generating 


blocking individual 
number restriction exists rule generating 


blocking individual 

bn 
sn bk sk bi bj bk bi bj 
bn number restriction merge rule nondeterministic 



bm 
sm 
bm sm 
bi bj 
bm bi bj bi bj replace occurrence bi bj call rules nondeterministic rules applied different ways abox 
remaining rules called deterministic rules 
call rules generating rules rules introduce new individuals 
abox rule applicable rule application controlled completion strategy accordance ordering new individuals see definition 
definition completion strategy define completion strategy observe restrictions 
meta rules apply rule individual rule applicable individual oo 
apply rule individual rule applicable individual completion rules applied order 
step skipped case corresponding set applicable rules empty 

apply rules long possible 

apply generating rule restart step long possible 
assume rules applied accordance strategy 
ensures rules applied new individuals ordering enforces kind breadth order 
despite completion strategy rule applicable different abox assertions cf 
rule rule application results possible abox cf 
rule 
computer program nondeterminism implemented search techniques 
branches search space referred choice points 
concrete implementation application rules stops immediately backtracks possibly remaining choice points called clash discovered 
definition clash clash triggers completion assume naming conventions 
abox contains clash clash triggers applicable 
clash triggers applicable called clash free 
primitive clash number restriction merging clash 
sm bi si bi bj clash free abox called complete completion rule applicable complete abox derived abox called completion abox containing clash obviously unsatisfiable 
purpose calculus generate completion initial abox proves consistency inconsistency completion 
mentioned soundness completeness termination calcu lus published haarslev ller 
abox reasoning alcn hr decidable 
chapter habilitation thesis decidability extension alcn hr proven proofs haarslev ller repeated 
optimization techniques inference algorithms hand tableaux calculus introduced previous section theoretical interest proving decidability abox consistency problem 
hand tableaux calculus provides basis developing implementation calculus part inference system 
practical purposes calculi highly inefficient nondeterminism handled simple backtracking search techniques 
development optimization techniques important research topic 
section briefly summarizes established optimization techniques known field order demonstrate effectiveness additional optimization techniques integrated architecture race system 
race uses highly optimized variant calculus alcn hr supported corresponding data structures 
techniques form basis modern dl system implementations fact dlp horrocks patel schneider 
techniques developed reasoners deciding concept consistency problem 
race demonstrate techniques scale integrated abox reasoning architecture haarslev ller 
order explain effect new optimizations known techniques need reviewed paragraphs 
optimization techniques definitions required 
brevity refer abox assertions involved application disjunction rule number restriction merge rule constraints 
addition abox assertions consistency proof referred constraints see schmidt smolka buchheit 
alternative introduced constraint called disjunct 
applying rule set constraints called expanding constraints 
completion derived expansion constraint constraint set constraints said satisfiable 
generating rules introduce constraints new individuals 
brevity contraints new individual introduced generating rule referred 
optimizing concept consistency reasoning section brief overview state art techniques incorporated race architecture 
detailed examples see cited literature 
normalization encoding normalization concepts ensures concepts represented canonical forms 
instance concept terms form chosen normalization 
encoding ensures concept term see stochastic search techniques proving satisfiability formulae selman 
stochastic search techniques incomplete stochastic techniques prove consistency formula inconsistency 
stochastic techniques investigated optimization techniques 
normal form unique identifier 
fact system number 
negation concept number encoded number 
concept number index array records additional information concepts 
software engineering purposes race different strategy 
numbers hard interpret debugging purposes race encodes concepts pointers record structures 
concepts normal form represented pointer 
record structure contains negated concept 
implementation clash detection mere search pointer number restrictions involved 
race necessity predefine number concepts handled allocating array certain size 
due object oriented architecture common lisp special print methods declared provide appropriate output situations lists concepts debugged inspector toolkit 
trace technique assume concept term checked consistency 
easily verified test carried considering subproblems succession 
necessary represent search space time 
checking consistency constraints generated proof discarded consistency checked 
subproblems idea applied recursively 
required certain trace search space represented memory 
note polynomial space requirements important 
reducing number abox assertions constraints considered time great advantage implementation oriented point view 
dl systems employ technique possible 
prerequisite trace technique rule applied right generating rules description logic alc trace technique schmidt smolka 
applicability idea expressive languages alcn shown hollunder nutt 
logic variant trace technique applicable due interaction features role hierarchies computation concept terms tested combination determination subproblems partitions complex due features merging operations necessary details see horrocks 
logic alcn hr number restrictions similar techniques determining partition tested subproblems complex 
restrictions role hierarchy taken consideration 
aboxes concept terms role assertions considered 
dependency directed backtracking indicated implementing nondeterministic algorithm practical computer requires search 
naive backtracking algorithms jumping choice point explore regions search space rediscovering contradictions clashes repeatedly 
dependency directed backtracking records dependencies expanded constraints case clash backtracks constraints responsible clash culprits subtree 
initial ideas dependency directed backtracking published stallman sussman 
fact system implementation horrocks dependency directed backtracking systematically integrated dl tableaux algorithm see ideas integrate dependency directed backtracking dl reasoning algorithms 
fact race recursion store state involved choice point accordance completion strategy recursive procedure applies tableaux rules set abox assertions constraints 
constraint expanded applying rule procedure recursively called process new set constraints 
applying rule procedure checks clash 
clash procedure backtracks way control flow continues appropriate choice point set nondeterministic rule 
form dependency directed backtracking called backjumping ginsberg horrocks 
backjumping point controlled list called catcher constraints 
constraints nondeterministic rule applied 
constraint expanded new constraint generated applying rule precondition constraints rule pushed list dependencies new constraints 
race implementation constraint dependencies precondition constraint pushed list dependencies resulting constraint dependency propagation 
clash dependencies clash culprits constraints generated constraints stored list backjumping started 
control flow falls back recursion 
choice point encountered backjumping checked involved constraint responsible clash culprit 
constraint list choice point safely bypassed 
case constraint remaining alternatives tried constraint considered unsatisfiable current subtree 
backtracking continues removes current constraint list clash dependencies adds saved clash dependencies previously unsatisfiable alternatives 
basic idea dependency directed backtracking implemented race due fact horrocks 
race provides support number restrictions dependency tracking mechanism extended rule abox reasoning 
insight empirical investigations fact system backtracking useful optimization technique description logic problems opposed results freeman propositional logic 
experiments fact dlp race demonstrated disabling dependency directed backtracking sense dependency management system wired race architecture data structures achieve maximum performance 
analyses dependency directed backtracking ginsberg 
ginsberg related technique called dynamic backtracking introduced 
semantic branching problems usually conjunctive normal form cnf 
contrast syntactic branching processing disjunctions writing order redundant search spaces may repeatedly explored semantic branching uses splitting rule replaces original problem smaller subproblems see freeman davis original concerning propositional logic 
semantic branching usually supported various techniques intending speed search 
boolean constraint propagation lookahead algorithm constraint propagator tries reduce size open search space 
satisfiability disjunct known called open 
expansion step race propagates truth value newly added constraint open disjuncts unexpanded constraints 
result step constraints satisfied disjunct satisfied deterministic exactly disjunct remains open clash disjunct leads completion 
heuristics guided search various heuristics select unexpanded constraint associated disjuncts 
similar fact race employs dynamic selection scheme 
called oldest strategy selecting constraint open disjuncts 
idea oldest strategy maximize effect dependency directed backtracking 
see ginsberg mcallester dynamic backtracking stochastic search algorithms 
new constraint generated search tree expansion number generated 
number represents age constraint 
smaller numbers represent older constraints constraints generated early search 
selected constraint leads clash backjumping performed see 
idea selecting oldest constraints skip search space possible performing backjumping 
constraint selected expansion open disjuncts chosen 
accordance freeman selection heuristics number negated non negated occurrences open disjunct unexpanded constraints 
numbers input priority function selects disjunct applying certain weighting scheme 
order minimize search space disjuncts preferred similar number negated non negated occurrences 
furthermore disjuncts selected constraint preferred occur constraints small number disjuncts 
idea strategy maximize effect boolean constraint propagation see 
order perform counting required implementing priority function quickly constraint race lists cross referencing constraints contain constraint disjuncts negated non negated form 
disjunct selected priority function determine constraint tried negated non negated form 
case failure alternative explored 
semantic branching combined backtracking specific dependency management required disjuncts backtracking forward checking 
semantic branching optimization techniques developed provers modal logics see called sat techniques initially described giunchiglia sebastiani 
optimizing tbox reasoning dealing tboxes requires specific optimization techniques tailored inference services provided 
lazy unfolding tableaux calculus described treats axioms form transforming universal concept restrictions form rule applied new individual introduced generating rules adds additional assertions 
worse universal concept restrictions contain disjunctions search space dramatically extended 
techniques efficiently managing search space integrated modern dl architectures see average case advantageous reduce number assertions prover deal 
kris system technique called lazy unfolding investigated baader baader logic alcn idea exploit special forms gcis tbox 
gci tbox concept name left hand side gci left hand side ii gci tbox iii gci cyclic respect tbox gci called primitive concept definition definition necessary conditions 
exists additional gci set called concept definition definition necessary sufficient conditions 
concept definition abbreviation 
call gcis represent primitive concept definitions simple gcis 
gcis referred true gcis 
concept definitions primitive concept definition called concept introductions 
tbox concept definitions primitive concept definitions identified additional rules dl prover expands assertions form lazy way 
discuss case 
exists primitive concept definition definition inserted abox assertion exists concept definition expanded way primitive concept definitions 
concept definitions assertions form treated similar way assertion expanded inserting abox 
need expanded mentioned technique exists primitive concept definition 
empirical tests indicate significant speed gain lazy unfolding technique implemented prover architecture baader baader 
gci transformations general idea technique eliminate true gcis preprocessing phase transforming concept definitions simple gcis horrocks 
gci transformation illustrated example 
gcis transformed single concept inclusion 
due transformation remains concept inclusion left hand side 
simple gci 
transformation fewer gcis tbox old gcis called absorbed gcis 
non simple gci absorbed represented universal concept restriction see corresponding rule tableaux calculus probably similar techniques dl systems kris 
kris contains systematic empirical evaluation effects 
section 
restrictions usually add disjunctions major source complexity see discussion lazy unfolding 
discussed simple gcis necessary introduce universal concept restrictions lazy unfolding technique 
summary goal compilation process keep structure gcis simple possible furthermore keep number small possible 
remaining gcis called meta constraints dealt rule completion rule marking propagation techniques race architecture incorporates tbox reasoning algorithms described baader baader computing sets parents children atomic concept tbox 
assume exists lattice concept names defined parent children relation see definition inference problems section 
assume parents children new concept name computed new concept name inserted called subsumption lattice 
parents new concept name cn computed called top search phase 
starting top lattice called concept subsumption relation cn concept names lattice determined 
search proceeds downwards specific concept names lattice subsume cn identified details see baader baader 
children cn identified analogous way called bottom search phase proceeding bottom lattice top 
construction subsumption lattice starts initial lattice consisting 
concept names inserted 
worst case constructing lattice requires subsumption tests number atomic concepts 
marking propagation techniques intermediate computation results subsumption lattice analyzed baader baader 
main idea avoid expensive subsumption tests full tableaux proofs exploiting obvious information far possible see kl kris described chapter 
flat model merging model merging strategy tries avoid consistency test conjunction concepts relies expensive tableaux technique see 
model merging test designed cheap test operating cached concept models sound incomplete consistency tester set concepts 
minimal computational overhead avoidance nondeterminism important characteristics test 
model merging test returns false sound complete tableaux calculus applied 
order precise term pseudo model concept model model understood sense interpretation pseudo model data structure containing recorded information 
model merging particularly important implementing tbox inference services 
test concept subsumes concept preceded may replaced merging test called pseudo models pseudo models data structures capture constraints represented completion prove consistency concept term 
constraints pseudo models completions consistent concept terms interact conjunction concepts consistent horrocks see detailed definition 
idea store constraints way test constraints interact executed fast way 
pseudo models mergable subsume technique realized fact system 
race extends technique alcn hr 
model merging test race correctly deals number restrictions model merging test realized incomplete structural consistency test language alen ale plus number restrictions role hierarchies 
non alen language constructs encountered answer structural subsumption test know case full sound complete alcn hr tableaux calculus 
order avoid redundancy details explained context proposed extensions 
abox partitioning multiple tboxes aboxes publications consider optimizations abox reasoning 
notable exception hollunder 
context kris system suggested automatically partition abox independent subparts 
scheme supported race 
race offers additional optimizations discussed sections 
kris system baader hollunder baader hollunder race supports declaration multiple aboxes certain tbox 
tbox inferences required 
tbox serve background knowledge employed specific inference problems data aboxes 
similar kris system contrast fact system race supports multiple tboxes tboxes objects stored data structures demanding problems testing dl systems achieved years interesting application problems solved existing dl technology development race 
new extended optimization techniques described chapter race cope complex knowledge bases developed area system verification medical ontologies 
case complexity due cyclic axioms case large number axioms concept names contributes complexity 
briefly introduce different variants knowledge bases areas time development processed race system appropriate time limits 
set quasi standard benchmark problems discussed order compare race dl systems extended new optimization techniques implemented race introduced 
tbox specification verification telecommunication systems application dl technology uses consistency inference problem order verify specification telecommunication systems 
telecommunication systems offer features complex apparent different features effectively combined 
features interact unwanted unforeseen ways 
unwanted feature interaction occurs telecommunication system installed site customer usually high reconfiguration costs consequence 
checking formal specification system installing essential 
progress area approaches interactions described formal logic interaction detection formulated reasoning task relatively rare 
automatically generated formal proofs derived verified provers raise confidence telecommunication system specification 
empirical studies shown interactions occurring telecommunication systems detected considering systems users 
approach detecting feature interactions description logics 
description logic alc tboxes containing cyclic gcis 
main idea encoding behavior phone system description logic tbox briefly reviewed 
behavior phone system modeled state space graph see 
state space graph vertices denote states edges represent actions 
states described concept names actions represented roles 
assume phone system certain state 
state instance concepts 
concepts set axioms defined 
axioms describe possible actions users states vertices actions edges telecommunication system subscribers symbol front action means successor vertex denotes system state constraints subscriber 
called subscribers 
basic idea exists restrictions right hand side axioms 
role exist restriction purpose denotes action certain subscriber 
concept exists restriction models state phone system action 
tbox model state space graph called basic call system subscribers 
part state space telecommunication system 
subscribers considered 
seen graph cyclic 
tbox describing state space contains indirectly cyclic axioms 
approach described features telephones call forwarding unconditional cfu terminating call screening rejecting calls tcs modeled set additional axioms feature subscriber 
specification basic call system faulty concept names initial tbox called bcs inconsistent 
certain features activated certain phones additional axioms added 
bcs coherent adding additional axioms activated features result inconsistency occur 
case feature interaction detected 
case instance subscriber redirects calls subscriber order receive phone calls aware subscriber rejects calls subscriber case subscriber unintentionally rejects calls bcs tbox possibly tbox additions activated features large state space encoded subscribers checking coherence cyclic tbox hard problem description logic inference systems 
due combinatorics adding subscriber results exponential increase runtime 
evaluating performance race bcs tboxes subscribers considered 
tboxes called bcs bcs bcs respectively 
evaluation results 
bcs problems considered representatives similar specification verification problems domains 
solving tbox coherence problem bcs extensions certain features demonstrates relevance dl inference technology modern software engineering verification problems shows practical usefulness race system context 
details bcs system formalization see 
ontology engineering bio informatics umls tbox web information systems thesaurus information retrieval proven effective means providing answers better focused interests users 
discipline called ontology engineering emerged various research fields artificial intelligence database theory 
main idea ontology engineering augment thesaurus semi structured representations inheritance inference techniques 
example consider reconstruction important parts umls unified medical language system mccray nelson 
reconstruction employs dl alcn cyclic axioms described schulz hahn introduces specific scheme uses concept names represent subset composition aspects word mentioned umls thesaurus 
tbox automatically generated specifications umls thesaurus schulz hahn 
instance notion heart axioms heart structures suffix heart parts suffix heart entities suffix declared see schulz hahn details ontology engineering organization founded see www ontology org 
ana heart ana heart ana hollow umls body part organ organ component ana heart ana hollow ana cardiovascular system ana heart ana heart ana heart anatomical part ana heart note disjointness declaration ana heart ana heart 
role axiom generated 
anatomical part ana heart anatomical part ana hollow scope chapter discuss pros cons specific modeling techniques umls reconstruction 
application projects comparable umls example necessary deal tboxes large number axioms 
addition applications small subset axioms true generalized concept inclusions gcis 
cases axioms concept axioms 
usually argued systems incomplete calculi deal knowledge bases axioms kind 
empirical analysis performance description logic system race shown description logic systems sound complete algorithms particularly useful simple large knowledge bases consisting mainly primitive concept definitions 
knowledge base called simple meta constraints remain absorption phase see section exist defined concepts 
performance race system evaluated different versions umls knowledge base 
umls preliminary version contains inconsistent concept names 
consists approximately concept names exists primitive concept definition 
addition umls role names declared 
role names arranged hierarchy 
umls new version reasons inconsistencies removed 
version umls empirical tests contains approximately concept names 
furthermore roles declared 
originally umls knowledge base developed loom macgregor 
loom encounters cyclic definition certain concept loom classify concept concepts concept 
due loom treatment cycles concepts placed called implies clause restrictions asserted individuals abox rule mechanism 
reason umls reconstruction uses implies domain range restrictions roles domain range restrictions asserted abox 
race pragmatic distinctions necessary 
order mimic loom behavior knowledge base versions umls umls different generated indicated letters 
version uses axioms style implies parts omitted tbox classification coherence checking 
version implies part loom knowledge base considered classification race 
additional axioms form generated added tbox 
ana heart developmental fo ana fetal heart surrounded ana version hardest version 
additional axioms provide domain range restrictions roles 
example anatomical part ana heart axioms generated 
anatomical part ana heart ana heart anatomical part ana heart ana heart axioms kind absorbed gci transformation algorithm fact 
roles umls tbox dl system deal domain range restrictions special way instantly run combinatorial explosion gcis kind treated universal concept restriction rule see section 
summary performance evaluation race tested different knowledge bases 
currently race dl system sound complete inference algorithms cope large tboxes generated umls reconstruction approach 
details performance analysis different optimization techniques 
testing methodology tests evaluating optimizations race cpu time measure performance 
researchers argued performance measurements consider cpu time operations involved algorithm 
operations recorded race system available debugging purposes semantic splits semantic branching number model merging tests number subsumption tests tableaux calculus number retracted models 
presenting internal details result discussion far fine grained general interest context 
furthermore operations specific certain implementation tableaux calculus constraint system sizes 
evaluation results chapter absolute runtime general indicator effect certain optimization technology 
benchmarks consist sequence problems requires exponentially increasing runtime instance doubling mere processing power results additional problem solved 
kind setting new algorithms data structures help achieving speed gain order magnitude 
application problems mentioned previous subsections important solved reasonable amount time hours 
see time writing race system deal kinds applications dl technology 
effectiveness optimization techniques evaluated additional tboxes developed application projects 
modern systems classification times range seconds minutes 
knowledge bases system competitions compare race systems 
galen tbox horrocks horrocks horrocks patel schneider 
different versions galen different dls ranging ale 
tboxes fss enhanced versions tboxes dl system comparison horrocks patel schneider 
restored role hierarchies domain range restrictions primitive roles gcis haarslev ller 
set new tboxes bike bike represent configuration knowledge various types bicycles alcn gcis 
bike bike evaluate efficiency implementation number restriction exists rule number restriction merge rule 
bike tboxes corresponding abox benchmarks available haarslev ller 
addition various tboxes derived applications set synthetic concept consistency tbox benchmark problems compare race systems 
set benchmark evaluating kris system baader fact system horrocks 
furthermore new set synthetic abox benchmarks developed order measure performance race system concerning abox consistency testing haarslev ller 
synthetic benchmark contains problem sets levels constructed way runtimes increase exponentially level level specific optimization techniques employed 
faster machine result additional level solved 
extended new optimizations race new optimization techniques developed race system 
extensions adaptations previously published techniques 
section gives overview utility different techniques empirical investigations 
optimizations concept consistency tbox reasoning section discuss tbox optimization techniques novel implemented evaluated time 
new transformations gcis results horrocks race transforms gcis form lazy unfolding effectively exploited 
formal analysis gci transformation techniques horrocks tobies 
race slightly extended scheme transforming gcis 
domain range restrictions roles implicitly gcis 
gcis removed race domain range restrictions specially treated race architecture see 
furthermore gcis form removed 
role declared features 
features handled special way accordance horrocks 
transformations motivated heuristic tries maximally simplify gcis absorb gcis elements set concept definitions primitive concept definitions elements specially treated race lazy unfolding technique see 
assume concepts negation normal form terms concept definition primitive concept definition defined 
transformation scheme starts sets initialized follows 
primitive concept definition gcis iteratively transformed removed added process stops returns gci transformation rule applicable anymore 
process employs transformation rules horrocks additional rule application steps roughly sketched 

gcis concept definition gcis removed term added 
exists concept definition dn di remove dn add dn dn condition di ensures transformation performed inclusion axiom di concepts 

exists gci dn exists di negated concept remove gci dn add gcis 
dn assume exist di transformation rules subsequently transform gci primitive concept definition absorbed primitive concept definition remains gci dn effectively treated 
furthermore possible absorb dj transformation rules 

furthermore gcis replace gcis gci form transformation implemented fact system 
represents application distributive law 
due experiences optimization techniques mentioning twice lead problems heuristics select disjuncts see section heuristics guided search section 
note contrast fact race supports absorption gcis inclusions inclusion definition exists 
knowledge bases handled effectively 
empirical investigations new gci transformation techniques 
concept required nnf concept scope negation concept name 
caching race caching intermediate computation results necessary prerequisite prove consistency concept terms horrocks patel schneider 
tableaux calculi testing concept consistency sets concepts representing conjunction manipulated 
concept sets called labels 
instance assume concept set contains set subset concepts role tableaux rule treating concepts identifies corresponding concepts checks completion 
concepts original concept set relevant test 
shown alcn hr trace technique applied consistency testing see section 
words concept sets resulting concepts corresponding concepts independently tested consistency interaction original concept set contains concepts 
solution consistency problem set concepts computed answer stored cache 
key cache set concepts considered 
cache value indicates conjunction key satisfiable 
cache expensive tableaux proof avoided cheap cache lookup indicates set concepts proven consistent inconsistent 
concept consistency cache technique described sketched horrocks patel schneider 
implementation tableaux calculus deciding abox consistency technique directly applied possible new individual generated applying rule treating assertions possibly identified old individual additional assertions possibly imposed 
furthermore consider logic alcn hr number restrictions require identification individuals 
role assertions restrictions imposed corresponding role mentioned situations ruled trace technique applicable 
assertions new individual interact assertions original abox consistency new assertions tested checking new partition fresh abox just concept constraints new individual consistent 
individual role assertions set concepts corresponding concept assertions checked cache caching technique implementations concept consistency algorithms employed 
cases sets implemented lists 
order preserve set semantics key cache retrieval list sorted elements list canonical order 









caching example blocking see text 
memory consumption lead problems memory management strategies necessary empirical tests indicate caching technique effective abox consistency problems see discussion effects caching disabled 
benchmark problems memory management techniques required order preserve upper bound memory consumption 
caching investigated dlp 
fact extended technique 
details published 
solving consistency problem cyclic inclusion axioms demonstrates caching depend blocking context 
blocking context considered carefully invalid models entered cache 
shown example 
consider tbox 
furthermore consistency concept tbox tested 
proof steps 
race system employs various heuristics choosing assertion expanded presentation purposes assume constituents conjunction disjunction considered writing order 
effect described occur specific selection strategies exploited presentation complex 
sequence expansion steps indicated numbers 
furthermore lazy unfolding strategy dealing inclusion axioms meta constraints 
step initial problem 
axiom involving disjunction get constraint systems see line 
assume alternative tried 
leads system number 
assertion step expanded axioms get constraint system step 
constraint expanded 
step corresponding system considered 
right hand side axiom inserted step 
constraint yields system step 
due blocking strategy see definition constraint system step expanded see constraint system step blocking individual 
assertion step assumed satisfiable 
corresponding interpretation indicated dashed arrow 
employed strategy cache intermediate results satisfiability stored pseudo model see details 
assume step pseudo model stored indicated 
example proof steps pending 
step remaining constraints step considered 
obviously second constraint role value restriction causes clash 
second alternative step considered 
corresponding system step 
consistency checked examining cache entry result consistent 
obviously erroneous 
reason caching principle described consider dependency satisfiability dependency tracking mechanism cache entries implemented race 
system detects inconsistency concept constraint system cached pseudo model dependent corresponding cache entries recursively invalidated 
certain tableaux proof consistency concept term interacts constraints strategy cache result checking consistency subproblem 
dependency tracking mechanism implemented race ensures correct behavior caching strategy case blocking 
race supports different caching policies 
cache finding information sorted sets concepts checking set concepts satisfiable unsatisfiable called equal cache implemented hash table 
furthermore pair caches satisfiable unsatisfiable concept sets provided 
caches support queries concerning encountered supersets subsets set concepts respectively 
equal cache enabled 
cache lookup fails superset subset caches consulted 
equal cache enabled retrieval results superset subset caches entered equal cache 
data structures subset superset caches inspired hoffmann hler 
default mode race uses subset superset caching 
context dl systems subset superset caching investigated race system see giunchiglia investigation technique modal logic provers require blocking 
summary empirical results bcs tboxes table runtimes example problems bcs bcs shown 
tests performed macintosh common lisp mhz partition mbyte 
caching problems solved reasonable amount time 
tests table equal caching enabled 
tests indicate subset superset caching enabled setting speed gain achieved 
runtimes increase dramatically subset superset caching disabled setting 
settings correspond setting respectively enhanced gci transformation techniques disabled 
execution times knowledge bases feature interactions concerning cfu tcs detected require comparable runtimes 
system fact extended caching equal caching subset superset caching horrocks 
runtimes bcs problems available 
details caching fact published 
initial version fact cope bcs 
dlp system support gci absorption deal bcs problems 
seen race handle specifications systems users 
progress support practical verification system specifications automatic theorem provers 
dealing systems users currently reach cf 
section 
table bcs tbox classification tests caching times seconds 
kb bcs bcs bcs exploiting deep models tbox reasoning section discussed subsumption test test check conjunction concepts satisfiable replace called flat model merging test 
analyze technique called deep model merging generalizes original model merging approach horrocks ways 
extend model merging technique logic alcn hr 
introduce deep pseudo models recursively traversed checked possible clashes 
best knowledge formal treatment showing soundness model merging 
definition pseudo model pseudo model concept term defined follows 
concept name role name feature name 
inconsistent pseudo model defined 
consistent exists set completions abox 
completion cis selected pseudo model concept defined tuple concept sets definitions brevity pseudo model called pmodel 
note set contains exists concepts contains concepts exists concepts features 
guarantees correct treatment features 
procedure mergable shown procedure implements flat deep model merging test 
case deep merging test blocking situation actual pmodel set ms member set vm visited pmodel sets 
initial call mergable empty set value vm 
third parameter 
controls deep flat mode see mergable 
assume procedure get pmodel retrieves concept cached pmodel 
case pmodel exist computed 
procedure atoms mergable tests possible primitive clash pairs 
applied set ms returns false exist ms 
returns true 
procedure critical tests potential number restriction clash set tries avoid true answers conservative 
procedure mergable ms vm ms ms vm return true ms atoms mergable ms return false ms critical ms return false ms collect ms ms mergable ms vm ms return false return true applied concept form pmodel current model set ms mk returns true exists pmodel ms role rs cases critical returns false 
procedure returns concepts form provided rs 
procedure collect applied concept form set pseudo models ms computes set qualifications 
define 
ms ms procedure collect returns set get pmodel 
observe implies feature 
prove soundness procedure mergable description logic alcn hr 
note mergable depends clash triggers particular tableaux calculus chosen detect potential clashes set 
proposition soundness mergable 
value true false cs cn mci get pmodel ci pm mci 
procedure call mergable pm returns true concept cn consistent 
proof 
proven contradiction induction 
assume call mergable pm returns true abox cn inconsistent exists completion concept ci satisfiable pm mergable return false due line procedure 
assume finite set containing contradictory aboxes encountered consistency test loss generality select arbitrary cand case analysis possible clash culprits 

primitive clash root individual propagated role assertions exist ci cj cs derived ci cj due satisfiability concepts ci holds associated mci pm due ci cj assumption call mergable pm returned true 
contradiction mergable called atoms mergable pm line procedure returned false ci cj 
number restriction clash detected exist successors successors derived assertions form sj ej nj sj sj 
concepts ci cs satisfiable exist subset cs ci cik cs ci cs ci ci cs ci rs sj due assump tion call mergable pm returned true 
contradiction exists concept mergable called critical mci pm lines procedure returned true 
individual successor chain role assertions rn assume clash discovered 
case primitive clash clash culprits derived assertions form rn rn rn due clash exists pair ei ej ei ej role assertion chain derived assertion form ak rk ek ak mk rk 
call graph mergable pm contains chain calls resembling chain role assertions 
induction call due syntax restriction elements transitive 
graph know node resembling call graph chain contains call mergable pm vm true mei pm atoms mergable called set ms mei ms call atoms mergable returned false ei ej contradicts assumption mergable pm returned true 
case number restriction clash argue analogous way 
chain role assertions number restriction clash detected individual chain 
exists corresponding call graph chain induction call mergable called critical set critical returned true 
contradicts assumption mergable pm returned true 
easy see proof holds case value 
flat mode conservative deep return false possibly true set collected empty line procedure advantage deep vs flat mode model merging technique demonstrated empirical tests set quasi standard application tboxes aboxes horrocks patel schneider horrocks patel schneider haarslev ller 
shows runtimes computing subsumption lattice tboxes 
tbox iteratively classified different parameter settings 
setting optimization techniques enabled second caching technique see disabled 
third setting caching deep mode model merging disabled flat mode model merging enabled 
different settings justified order optimization techniques applied tested consistency race 
caching applied 
cache entry exists deep model merging tried 
returns false standard tableaux test invoked 
tableaux caching reduce number encountered model merging tests advantage deep flat mode model merging accurately evaluated compares runtimes second third setting 
comparison settings indicates speed gain runtimes factor tboxes deep mode enabled 
comparison second setting clearly demonstrates deep mode compensate disabled caching technique 
empirical results application tboxes see indicate speed gain order magnitude mentioned additional gci transformation rules applied compare runtimes techniques enabled vs 
gci transformation 
speed gain galen tboxes galen galen contain gcis procedure horrocks setting setting setting galen galen galen setting setting setting bike bike bike bike bike bike bike bike bike galen tboxes bike tboxes evaluation model merging techniques runs tbox left right order corresponds top bottom order legend 
absorbs gcis galen dealing domain range restrictions domain range restrictions roles modeling constructs applications 
domain restriction role expressed gci individual set relation object role implied individual instance concept range restriction role expressed gci 
specifies individuals instances concept order avoid disjunctions race deals gcis domain restrictions generalized kind lazy unfolding 
similar way names situations unfolding concept terms axioms form occur easily identified unfolding domain restriction role applied constraint arbitrary alcn hr concept term encountered abox see alcn hr tableaux calculus possible absorb domain restriction expressed anatomical part ana heart ana heart equivalent inclusion axiom ana heart anatomical part ana heart lazy unfolding easily applied inclusion axiom ana heart exists 
case umls 
note principle race supports absorption gcis inclusions inclusion definition exists see 
knowledge bases handled effectively 
contrast domain restrictions range restrictions roles introduce disjunctions 
practical implementation advantageous keep number internal data structures managed small possible 
range restrictions considered existential restriction imposed certain individual cases easily detected 
summary empirical results standard tboxes table runtimes classifying realistic tboxes dl benchmarks quite terminological axioms listed see column named num 
concepts details see horrocks patel schneider 
knowledge bases different version tested extensions roles gcis indicates domain range restrictions roles ignored appropriately represented gcis respectively 
tests carried systems race fact kris test environment indicated macintosh common lisp 
version fact support number restrictions fact handle tboxes 
new version fact supports qualified number restrictions apply model merging runtimes compared 
furthermore kris support gcis tests left indicated na 
columns race implementation note due experiences domain restrictions easily considered recursive encoding process concepts 
encoding concept term domain restriction cause kinds trouble concerning negation term 
negation term suggested encoded special treatment necessary terms 
happens concept term knowledge base 
negation definitely case encoding procedure hardly guarantee uniqueness encoding result essential clash detection 
race indicate runtimes race deep model merging deep model merging enabled respectively 
table realistic tbox classification tests times seconds 
kb num 
concepts time race race fact kris roles na gcis na na roles na roles na gcis na na fss roles na fss gcis na na roles na gcis na na galen gcis na galen galen topological sorting achieving quasi definition order tbox classification race system employs marking propagation techniques introduced baader 
discussed techniques section 
large knowledge bases particularly important avoid traversals possible 
assume tbox classified transformed meta constraints cyclic primitive concept definitions exist 
concepts classified called definition order bottom search phase omitted concept names primitive concept definition exists baader 
baader assume concept name directly uses concept name occurs concept right hand side definition relation uses transitive closure directly uses 
uses precedes definition order 
acyclic tboxes uses relation irreflexive concept axioms set concepts processed definition order concept classified concepts definition classified 
case set children concept name consists bottom concept 
lazy unfolding domain restrictions applied domain restriction considered special way directly uses relation 
common syntactical restriction description logic systems accept tbox declarations include called forward 
language alcn hr offers cyclic axioms gcis general bottom search phase skipped horrocks page 
unfortunately umls examples forward involved value restrictions existential restrictions modalities 
definition order concept names computed preprocessing step 
addition slightly strict notion definition order developed 
assume relation directly refers similar directly uses considering occurring scope quantifiers 
uses transitive closure directly refers 
acyclic concepts refers relation induces partial order relation concept names 
concept names involved cycle treated node set si partial order 
topological sorting algorithm partial order serialized total order concept names sets concept names defined 
call serialization quasi definition order 
topological sorting order number refers relationships 
approximately log steps bottom search procedure requires steps worst case 
note baader experiments discussed involve computation serialization tbox axioms strict definition order 
classification tbox race concept names processed order linearization topological sorting 
atomic concept member set si inclusion available see section bottom search omitted 
refers relation quasi definition order serialization ensures concepts potential subconcepts certain primitive concept inserted inserted subsumption lattice bottom search performed 
quasi definition order conservative potential subsumers note alcn hr support inverse roles 
basic subsumption test subsumption lattice construction referred 
strict definition order classification necessary 
order effectively apply topological sorting optimization incorporating domain restrictions tableaux calculus necessary prerequisite meta constraints exist topological sorting valid optimization 
clustering problem large knowledge bases set children concept names get large 
top search procedures exhibits worst case performance optimization techniques baader effective 
implementation race special clustering technique employed 
concept names children certain concept name children grouped called bucket anew virtual concept definition anew assumed anew virtually inserted subsumption lattice children 
note bucket concepts anew virtual concepts sense mentioned set children parents concept names mentioned tbox 
assume certain concept name inserted 
testing ai subsumes top search phase findings suggest effective initially test anew subsume model merging technique 
subsumption test pmodel anew computed 
subsumption relation exists clustering introduces overhead 
cases subsumption relation ai clustering model merging test possibly replaces single model merging tests 
concept names primitive concept definitions included tbox 
pmodel anew model merging simple 
pmodel basically consists set negated concept names see section details model merging race 
performing single model merging test pmodel anew causes overhead performing steps testing subsumption ai 
new parent computed concept names involved bucket bucket structure recomputed 
best performance number concepts kept bucket depends number subconcepts concept 
number subconcepts concept hardly estimated 
strategy 
concept names inserted subsumption lattice number buckets increases 
new bucket created certain concept buckets clustering subconcepts buckets buckets smallest number children merged 
merging buckets anew bnew bm means bucket anew redefined anew bm bucket bnew reused new bucket created see 
hierarchical clustering techniques lead performance improvements subject research 
current evaluation clustering buckets uses setting 
note due subsequent merging operations need equal 
exploiting disjointness declarations discussed baader important derive told subsumers concept name marking propagation processes 
told subsumers race exploits set told disjoint concepts 
heart example section ana heart computed told disjoint concept ana heart examining inclusion axioms 
known concept subsumer concept told kind information recorded propagated appropriate marks see baader details marking propagation operations information rediscovered model merging tableaux subsumption test 
exploiting disjointness information investigated baader 
traversing subsumption lattice needed abox realization 
idea exploit disjointness information speed realization process follows 
instance checking test returns obvious instance concept member set told disjoint concepts subsumption lattice told disjoint concepts marked accordingly instance checking test concepts possibly involves expensive abox consistency test necessary 
large number instance checking tests performed exploitation disjointness information particularly effective abox realization see experimental results 
summary empirical results umls tboxes section basic idea encoding umls thesaurus tbox introduced 
major versions corresponding minor versions investigated 
umls contains concept names umls contains names 
versions approximately role names 
section effectiveness optimization techniques introduced previous sections evaluated umls tboxes 
measurements performed sun ultrasparc gbyte main memory solaris 
race implemented ansi common lisp tests franz common lisp 
results follows 
clustering topological sorting classifying umls done approximately hours concepts incoherent 
clustering topological sorting enabled hours necessary compute result umls 
second version umls requires hours optimization hours optimization 
reason enhanced performance constraints version concepts inconsistent 
domain range restrictions concepts inconsistent 
table evaluation classifications umls knowledge bases topological sorting clustering runtime hours minutes nst number subsumption tests nm number cached models maximal number children nb number buckets 
umls nst nm nb na na na na na 
na computation times race hours optimization hours optimization 
mbytes memory required compute classification results 
umls checking tbox coherence requires approximately minutes 
new second version umls contains additional part umls harder deal 
furthermore inconsistent concepts classification harder nodes subsumption lattice 
umls due large number inconsistent concepts subsumption lattice small concept disappear synonyms bottom concept 
umls checking tbox coherence requires minutes min min min 
detailed performance evaluations race applied umls tbox classification table 
order provide machine independent evaluation runtimes number subsumption tests indicators 
noted tableaux algorithm needed computing pseudo models 
words subsumption tests determined deep model merging tests 
comparison setting topological sorting clustering enabled setting clustering disabled reveals clustering effective optimization technique umls tboxes 
result umls setting topological sorting disabled clustering enabled supports fact topological sorting effective 
reason extraordinary runtime result setting umls completely clear 
due removed buckets 
bucket removed member bucket assigned new parent see 
topological sorting disabled 
effect apparent version possible effect due bug common lisp memory management system 
umls mbytes required 
setting clustering topological sorting disabled runtimes increase 
evaluation results second version umls require computational resources umls see discussion implies section 
incorporation domain range restrictions cause runtimes increase 
benchmark tboxes galen approx 
concepts results suggest overhead imposed clustering topological sorting optimization techniques significant gain observed 
summary results umls tboxes clearly demonstrate clustering particularly effective conjunction topological sorting establishing quasi definition order 
reported indicates sound complete description logic systems effectively deal instances large knowledge bases 
optimizations abox reasoning consider new optimization techniques abox reasoning investigated time development race 
paragraph inference problems considered role box role box omitted brevity 
exploiting flat models abox reasoning abox realized sequence instance checking tests 
realization individual occurring abox tbox computes direct types 
instance order compute direct types subsumption lattice concepts dn sequence abox consistency tests adi di required 
individuals usually members small number concepts aboxes adi proven consistent cases 
basic idea design cheap sound model merging test focused individual concept terms di explicitly considering role assertions concept assertions individuals mentioned interactions reflected individual pseudo model motivation devising novel individual model merging technique 
pseudo model individual mentioned consistent abox tbox defined follows 
consistent exists set completions pseudo model individual defined tuple definitions 
procedure get ind pmodel called individual mentioned consistent abox tbox appropriately creates pmodel retrieves cached pmodel individual model merging accomplished applying procedure mergable models computed get ind pmodel get pmodel 
flat mode third parameter set false 
proposition soundness individual model merging individual mentioned consistent abox tbox satisfiable concept ma denote pmodel returned get ind pmodel get pmodel set pm defined ma 
procedure call mergable pm false returns true abox consistent instance proof 
proven contradiction 
assume procedure call mergable ma false returns true abox inconsistent exists completion assume finite set containing contradictory aboxes encountered consistency test loss generality select arbitrary cand case analysis possible clash culprits 
definitions procedure see page assumed 

clash detected individual distinct consistent individual successor chain role assertions bn rn clash culprits derived newly added assertion propagated role assertion chain originating 
satisfiable consistent interaction role feature 
implies associated ma 
contradicts assumption mergable ma false returned true mergable eventually called collect ma returned non empty set line procedure 

case primitive clash concept assertion know propagated role assertions 
derived 
contradicts assumption mergable ma false returned true mergable called atoms mergable ma returned false line procedure 

number restriction clash detected exist successors implies set contains concepts form sj ej nj sj sj rs sj contradicts assumption mergable ma false returned true mergable called critical lines procedure returned true performance gain individual model merging technique empirically evaluated set aboxes containing individuals 
aboxes realized application tboxes bike derived bike configuration task 
tboxes especially vary degree explicit disjointness declarations atomic concepts 
shows runtimes realization aboxes 
abox realized different parameter settings 
setting optimization techniques enabled second setting optimization technique disabled considers disjointness concepts see section additionally third setting individual model merging technique disabled 
comparison setting reveals speed gain order magnitude individual model merging technique 
note logarithmic scale 
role path contraction order abox realization fast possible transformation technique aboxes developed maximizes effect caching techniques 
seen caching concept consistent important role assertion form technique interacts individual model merging prunes search space realization decreases number instance checking tests solved individual model merging 
setting setting setting runs clustered group application abox left right order clusters corresponds top bottom order legend evaluation model merging techniques bike aboxes runs abox left right order corresponds top bottom order legend 
optimization technique 
abox consistency abox decided transforming parts concept computed consistent iff transformed abox consistent caching techniques developed concept consistency problem applicable abox reasoning 
see aboxes parts thereof transformation possible 
empirical investigations indicate transformation overhead neglected 
informally role path contraction idea 
assume direct types certain individual computed 
transform original abox way acyclic role paths individuals tree abox structures represented appropriate concept 
corresponding concept role assertions representing role paths deleted abox 
order transform abox transformation rule applied possible individual realized 
illustrate contraction idea example 
indi example chain example abox chain contraction see text 
upper abox transformed lower 
vidual represented gray circle 
concept representing contracted role path added concept assertion individual starting contracted path 
rc contraction rule alc 


cn 
cn cn ci 
cn cn define algorithm contraction alc iteratively applies rule rc consistent input abox long possible 
computed abox subsequent steps 
rc longer applicable algorithm returns abox proposition algorithm contraction alc transforms consistent alc abox abox consistent iff consistent 
step rc removes role assertion form premise rc role assertion precondition applying rule 
role assertions original abox algorithm contraction alc terminates steps latest 
rule rc applied abox contain assertions individual considering new concept assertion sound complete rules underlying tableaux calculus see chapter see tableaux rules create new individual concept assertions original abox 
additional assertion cn expanded 
cn 
contraction rule rc alc aboxes associated tboxes alc tboxes 
presence number restrictions contraction applied abox exist role filler certain role reason individuals explicitly mentioned abox eliminated due unique name assumption 
individuals represented uniqueness information lost 
alcn hr aboxes need conservative contraction rule rc 
rc contraction rule alcn hr 


cn 




cn cn ci 
cn cn way define algorithm contraction iteratively applies rc consistent input abox proposition algorithm contraction transforms consistent abox abox consistent iff consistent 
argumentation contraction alc easy see algorithm terminates sound complete 
additional requirement premise guarantees role assertions transformed appropriate concept assertions exist role assertion occurs left hand side 
exists common number restrictions imposed 
role path contraction technique aboxes advantages 
number individuals role assertions reduced 

concepts resulting contraction automatically subject concept caching merging techniques 

abox realization multiplies savings effect due iterated instance checking tests individual named concepts tbox 
empirical tests instance checking problems haarslev indicate role path contraction technique effective 
graph shows execution times different problems abox realization instance checking 
due experiences set abox assertions reduced orders magnitude contraction technique 
speed gain technique indicated figures 
shows contraction technique result speed gain order magnitude 
secs abox problem size branch dum grz lin path ph poly lines dots indicate role path contraction race abox realization role path contraction 
lines dots indicate role path contraction 
lines color dots compared 
problems hard ask design sophisticated optimization techniques 
performance gain instance checking realization orders magnitude 
older abox dl systems kris baader baader able check abox consistency problem size greater time problems size 
summary benefit race technology empirical tests reveal new applications implemented race technology 
considered specification checking scenario telecommunications application 
second logical reconstruction medical knowledge implicitly represented umls thesaurus possible large knowledge base 
context race technology specification checking automated theorem proving techniques possible 
contexts secs abox problem size branch dum grz lin path ph poly lines dots indicate role path contraction race abox instance checking role path contraction 
lines dots indicate role path contraction 
lines color dots compared 
reliable applications possible due sound complete reasoning race 
achieved instances inference problems contexts solved reasonable amount time 
race supports literal retraction abox assertions incremental additions tboxes abox functional level operations time consuming 
additional research necessary integrate known optimization techniques race architecture develop new optimization techniques 
chapter alcn extended concrete domains application domain dls successfully applied configuration 
effective reasoners expressive languages available studies performed dls limited expressivity see wright undecidable logics buchheit buchheit 
description logic alcn hr expressive decidable representation language race effective inference engine available 
requirements derived practical applications dls ask expressive languages features covered previous chapters 
known reasoning objects domains called concrete domains reals important practical applications baader hanschke baader hanschke 
extension alcn hr knowledge representation system race concrete domain investigated 
unfortunately adding concrete domains expressive description logics lead undecidable inference problems 
instance baader hanschke proven logic alc plus operator transitive closure roles undecidable 
alcn hr offers transitive roles operator transitive closure roles see sattler detailed discussion expressivity differences 
lutz shown alc generalized inclusion axioms gcis undecidable 
termination soundness retained way extending alcn hr dl system race concrete domains alc losing completeness 
gcis discarded alcn hr concrete domains undecidable alcn hr offers role hierarchies transitive roles provide expressivity gcis 
role hierarchies possible implicitly declare universal role combination value restriction achieve effect gcis 
alcn hr extended concrete domain operators limited expressivity 
order support practical modeling requirements extent pursue pragmatic approach supporting limited kind predicate exists restriction supports features feature chains alc details see 
resulting language called alcn hr proving soundness completeness termination tableaux calculus decidability inference problems language alcn hr proved 
shown section alcn hr instance basis building practical application systems solving certain classes configuration problems see buchheit schr der 
description logic alcn hr description logic alcn hr augments alcn hr called concrete domains 
concept language alcn hr presenting syntax semantics language alcn hr additional definitions introduced alcn hr see chapter required 
definition features set feature names disjoint set role names 
brevity feature name called feature 
accordance baader hanschke define notion concrete domain 
definition concrete domain concrete domain pair set called domain set predicate names 
predicate name pd associated arity ary predicate pd concrete domain called admissible iff set predicate names closed negation contains name satisfiability problem 
nm xm 
able finite ni ni arity xjk name object 
assume negation predicate definitions syntax concept terms alcn hr extended follows 
definition additional concept terms predicate concrete domain 
fk features expressions concept terms 
fk predicate exists restriction 
concrete domain filler restriction 
definition gives model theoretic semantics language introduced 
concrete domain 
definition semantics interpretation id consists set domain set domain concrete domain interpretation function interpretation function maps concept name subset role name subset feature mapped partial function written predicate name arity mapped subset 
fn features predicate name 
interpretation function definition extended additional concept terms follows 
fn 
xn 
xn fn 
xn form terminological axioms alcn hr form alcn hr 
assertional language alcn hr assertional language extended follows 
definition additional assertional axioms oc set names concrete objects oc 
feature oo individual name 
xn oc names concrete objects expressions assertional axioms abox assertions concrete domain feature assertion 
xn concrete domain predicate assertion 
note concrete domain objects considered successors predecessors sense defined section 
interpretation function interpretation id extended assertional language 
concrete objects oc mapped elements interpretation satisfies assertional axiom iff ai xi fi assertional axiom 
xn iff 
xn pi solving configuration problems alcn hr buchheit buchheit configuration problem solving processes formalized synthesis inference tasks 
approach solution configuration task defined logical model knowledge base consisting conceptual domain model tbox task specification abox 
tbox describe configuration space 
note specific languages describing configuration space 
instance configuration frame language allows describe properties instances specifying restrictions required values named slots 
values single objects sets objects restrictions specified extensionally directly giving concrete values numbers symbols instances concepts intensionally describing sets sequences objects 
example expression language describes concept cylinder 
cylinder part motor displacement ccm ccm parts set piston piston rod valve cylinder required motor displacement ccm set parts parts consists exactly piston exactly piston rod valves 
expression transformed terminological inclusion axiom description logic providing concrete domains 
concrete domain defined baader hanschke set predicates buchheit additionally considers relations defined definite clauses 
polynomial equations inequations 
concrete domain admissible see baader hanschke 
cylinder example translated follows 
language alcn hr cylinder specification translated description logics 
role box defined contain role inclusion axioms 
cylinder part part piston part part piston rod part part valve part part tbox set terminological axioms 
instance range restrictions declared 
cylinder part cylinder piston part piston piston rod part piston rod valve part valve called cover axiom 
additional axioms ensure disjointness specific subconcepts 
piston piston rod valve piston piston rod valve piston rod piston valve valve piston piston rod axiom relates cylinder parts 
assume displacement declared feature 
cylinder part displacement displacement range parts cylinder part cylinder part piston part piston rod part valve part valve part term displacement range denotes unary predicate vol ofa numeric concrete domain dimension volume base unit furthermore assume predicate vol name medium large displacement declared concrete domain 
example abox simple cylinder displacement medium large displacement 
order solve configuration problem knowledge base tested consistency 
knowledge base consistent exists model 
model interpreted solution configuration problem buchheit 
note simplified example representation configuration problem 
instance abox additional assertions possible explicitly specify required cylinder parts order compute solution configuration problem sound complete calculus alcn hr knowledge base consistency problem required terminates input 
calculus returns consistent parts internal structures proof printed problem solution convenient form 
return point discussion tableaux calculus alcn hr decidability alcn hr calculus decide consistency alcn hr knowledge base devised 
calculus extension calculus alcn hr discussed section 
additional transformation rules required compute negation normal form alcn hr concepts 

fn 
fn fn negation definition fork fork elimination holds exists fork case fork replacement occurrence called fork elimination 
augmented abox language alcn hr forks eliminated 
easy see forks eliminated lemma holds alcn hr definition concrete object ordering concrete object ordering elements oc occurring abox defined follows 
oc introduced concrete objects completion rules alcn hr extended additional rule follows definition additional completion rule predicate exists rule generating 


fn 

xn oc xn fn 
xn xn fn 
xn 
xn oc eliminate forks fi xi fi fi remains rule called generating rule generates concrete objects 
proposition invariance aboxes role box 

derived applying deterministic rule consistent iff consistent 
derived applying nondeterministic rule consistent consistent conversely consistent nondeterministic rule applicable applied way yields abox consistent proof 

due structure deterministic rules immediately verify subset consistent consistent order show consistent applying deterministic rule consistent abox examine applicable rule separately 
assume id satisfies observe obvious consequence ri si iff conjunction rule applied get new abox 
id satisfies id satisfies role value restriction rule applied role assertion 
id satisfies holds ai bi si si ri id satisfies holds bi ci id satisfies transitive role value restriction rule applied assertion get 
id satisfies ai ai bi si si ti ri ai id satisfies holds bi exists successor bi ci follows bi ci ti ai ci ti ti ri ai contradiction assumption 
id satisfies universal concept restriction rule applied individual 
id satisfies holds ci holds ai ci id satisfies role exists restriction rule applied get abox 
id satisfies exists ai ri ci define interpretation function bi easy show satisfies number restriction exists rule applied get abox bk bi bj 
id satisfies exist distinct individuals yi ai yi ri define interpretation function bi yi 
bn 
easy show satisfies predicate exists rule applied 
fn get abox 
xn 
xn fn 
fork elimination xi may replaced zi zi 
id satisfies exist 
yn 
ai yi fi 
yn pi define interpretation function xi yi xi replaced zi 
yn pi fork elimination strategy rule guarantees concrete objects introduced previous steps eliminated 
ensured interpretation xi changed easy see satisfies 
assume satisfied 
examining nondeterministic rules show consistent obtained applying disjunction rule subset satisfied obtained applying number restriction merge rule exist bi bj bi bj 
define interpretation function bi bj xi xi bi 
obviously id satisfies suppose id satisfies nondeterministic rule applicable individual disjunction rule applicable aand consistent holds ai follows ai ci ai di 
disjunction rule applied way id satisfies abox number restriction merge rule applicable aand consistent holds ai ri holds ai bi ri loss generality need consider case 
conclude pigeonhole principle exist successors bi bj bi bj id satisfies individuals new individual 
assume bi id obviously satisfies bi bj 
abox rule applicable completion strategy alcn hr see definition 
set additional clash triggers required alcn hr definition additional clash triggers addition clash triggers definition additional clash triggers applied 
concrete domain feature clash concrete domain predicate clash 

nk pk aand conjunction 
ni satisfiable note decided required admissible 
pi abox containing clash obviously unsatisfiable 
purpose calculus generate completion initial abox proves consistency inconsistency completion 
lemma proves generating rule applied individual concept set ofa change succeeding aboxes 
note original abox contain elements see definition 
lemma stability abox generating rule applicable completion strategy 
abox derivable possibly empty sequence rule applications 

rule applicable individual 
concept set remains unchanged 
individual individual substituted individual 
proof 
original input abox elements mentioned rule applied holds 

contradiction suppose element completion rules rule applicable individual exist minimal rule applicable ai 
rule applicable rule applicable due strategy 
rule applicable individual 
ai 
follows ai ai rule applied exhaustive case analysis rules show new assertion form added ai 
rule applicable ai 
contradiction assumption 

contradiction suppose 
direct predecessor rule applied point 
due strategy generating rules applicable add new elements 
obvious contradiction 

follows point completion strategy 
order define canonical interpretation completion notion specific blocking individual introduced 
blocking individual called witness 
order show soundness calculus called canonical interpretation constructed completion 
construction process notion witness defined 
definition witness abox individuals call witness conditions hold 



lemma proves uniqueness witness blocked individual 
lemma abox new individual ifa blocked 
direct successor individual 
exactly witness 
proof 

contradiction suppose blocked exist ancestor abox generating rule applied follows definition generating rules new individual 
derived lemma conclude new individual 
exist blocking individual contradiction hypothesis 

follows directly condition definition 
definition canonical interpretation complete abox derived calculus augmented abox role box clash free exists variable assignment satisfies conjunction occurring assertions 
xn define canonical interpretation ic ic ic follows 
ic individual 
ic iff mentioned 
ic mentioned 
ic iff 
ic iff 
ric iff 
cn 
dn mentioned cn 
dn cn sn dn sn note variables 
cn 
dn necessarily denote different individual names 
construction canonical interpretation examples case 
lower example assume individual witness see text 
di ci di witness ci di ci si si construction canonical interpretation case illustrated examples 
lower example dotted arrow constructed due case definition canonical interpretation called gap 
cases seen special cases case introduced ic iff role ic iff witness role due lemma canonical interpretation defined exists unique blocking individual witness individual blocked 
theorem soundness complete abox derived calculus augmented abox role box model satisfies role axioms proof 
ic ic ic canonical interpretation abox constructed tbox clash free 
features interpreted correct way forks forks augmented abox ii forks immediately eliminated application rule 
rule rule introduces new assertions form note forks introduced rule due completion strategy 
ic maps features partial functions variable assignment function 
role inclusions satisfied holds sic ic ic ic ic shown follows 
case definition applicable 
exists chain possibly gaps witnesses see definition case 
corresponding construction ic adding aic ic ic tos applicable see 
tuple aic ic ic transitivity axioms satisfied transitive roles interpreted correct way transitive ric ic ic ic ic exist bic ic ic case definition applied tuple 
chain roles exists possibly gaps witnesses aic ic ic added 
prove ic satisfies assertion aor ic satisfies definition 
ic satisfies definition 

xn ic satisfies definition 
clash free exists variable assignment conjunction predicate assertions satisfied 
variable assignment computed concrete domain required admissible 
consider assertions form show induction structure aic ic concept name aic ic definition ic 
concept name concepts negation normal form see definition 
clash free contain aic ic aic ic ic ic ic complete aand induction hypothesis aic ic ic ic ic ic complete aor induction hypothesis aic ic ic ic ic ic show bic ic ic ic holds bic ic ic ic ic definition successor chain roles si exist corresponding witnesses domain elements si chain contain gaps associated witnesses see 
aic ic ic si ic ic exists tuples ci ic ci ic si ic due definition holds si ck complete 
reason induction hypothesis holds bic ic mentioned chain roles gaps see 
due definition case gap exists witness similar argument case applied case gap ci ci witness di ci blocking condition ensures concept set witness superset concept set blocked individual 
assumed di ci si aand complete holds ci applying argument inductively conclude cn aand bic ic induction hypothesis 
show exists individual bic ic aic ic ic ic ic abox complete aor blocked individual 
case aic ic ic definition ic case ci di bic ic induction hypothesis 
second case exists witness aand definition blocked hypothesis complete 
individual aand induction hypothesis bic ic definition ic case ci di di witness ci ci di wehave aic ic ic prove hypothesis contradiction 
assume aic ic exist distinct successors cases occur individual blocked ic 
successors rule applicable contradicts assumption complete 
blocked individual argument case holds leads contradiction 
show goal contradiction 
suppose aic ic exist distinct individuals ic 
bn ic aic bi ic ic 
cases occur 
individual blocked bi si si si 
rule applicable complete bi distinct bi bj contradicts assumption clash free 
exists witness bi si si si 
leads analogous contradiction 
due construction canonical interpretation case blocking condition witness non transitive role required simple role see syntactic restrictions number restrictions role boxes aic bk ic ic cic bk ic ic 

fn show exist concrete objects 
yn aic ic ic 
yn fn ic 
yn pic rule generates assertions 
xn fn 
xn clash free concrete domain predicate clash 
exists variable assignment maps 
xn elements conjunction concrete domain predicates satisfiable ic 
xn ic ic definition ic holds aic ic ic ic 
xn ic fn ic exist 
yn mentioned requirements fulfilled aic 
fn ic show aic ic clash free assertion oc hold exists aic ic ic ic due completeness individual aand previous cases aic ic ic satisfies ic satisfies assertions ic satisfies theorem completeness augmented abox role box 
consistent exists completion computed applying completion rules role box proof 
contraposition obviously abox containing clash inconsistent 
exists completion follows proposition abox inconsistent role box definition maximum number concepts completion augmented abox 
na subs subs called maximum number concepts function subs applied concept returns set concepts appearing substrings incl 

note na bounded length string augmented abox assume returns cardinality set plus 
lemma completion augmented abox furthermore tr finite set transitive roles mentioned role box set consisting individuals occurring cardinality greater tr na exist individuals concept sets equal 
proof 
rule generates assertions concepts mentioned rule 
new concepts form may generated 
number concepts bounded tr na tr transitive roles mentioned role box na different concepts exist tr na different concept sets individuals tr na individuals different concept sets additional individual new concept set 
lemma augmented abox completion furthermore tr finite set transitive roles mentioned role box occur tr na non blocked new individuals proof 
suppose tr na non blocked new individuals lemma know exist individuals 
definition assume loss generality holds 
condition implies blocking individual see definition 
contradicts hypothesis blocked 
theorem termination augmented alcn hr abox numbers occurring number restrictions expressed binary 
completion role box finite size tr 
proof 
completion lemma know non blocked new individuals 
total new individuals exist maximum number direct successors individual note bounded number concepts plus total sum numbers occurring numbers expressed binary sum bounded 
number individuals initial abox bounded total number individuals 
number different assertions form individual involved bounded assertion size linear total size assertions bounded 
number different assertions form bounded 
number different assertions form bounded due fork elimination 
number different assertions form 
xn bounded 
initial set concrete domain predicate assertions bounded addition individual may concept assertions yielding additional predicate assertions 
size theorem decidability checking knowledge base consistent decidable problem 
proof 
knowledge base augmented abox constructed linear time 
claim follows immediately lemma theorems 
applying alcn hr configuration revisited previous section decidability abox consistency problem language alcn hr shown 
principle configuration problems formalized consistency queries alcn hr knowledge bases indicated section solved 
input knowledge base consistent configuration represented model represented canonical interpretation derived completion 
due fact algorithm nondeterministic problems remain 
unintended blocking context configuration blocking lead undesirable model 
consider abox tbox empty role box 
possible completion derived concrete implementation knowledge base consistency algorithm completion blocked canonical interpretation contains loop role acceptable depend application context configuration solution 
noted specific case exists completion blocked individual 
configuration example section solved blocking 
limited expressivity engine configuration set cylinders equal piston displacements required 
alcn hr concrete domains predicates established single individual single cylinder different cylinders 
set cylinders part engine constrained abox respective concrete domain assertions 
fixed set individuals considered configuration process 
clear cylinder engine required expressive description logic needed 
analysis extension alcn hr possibility extending expressivity alcn hr employ predicate exists restriction alc offers feature chains baader hanschke 
call language alcn hr 
unfortunately holds alcn hr augmented predicate exists restriction supporting feature chains alc undecidable lutz shown alc generalized inclusion axioms gcis undecidable 
alcn hr offers role hierarchies transitive roles provide expressivity gcis 
undecidability proof may lead insights come new operators syntactic restrictions existing operators order develop representation language cope specific application requirements covered expressive decidable languages 
gci undecidability proof turing machines lutz involved give direct proof transitive roles role hierarchies demonstrate tboxes discarded alcn hr concrete domains undecidable general 
syntax semantics alcn hr slightly modified variant syntax semantics alcn hr definition new predicate exists restriction alcn hr subset simple roles called attributes distinguished see definition definition set simple roles 
attributes fn feature composition attributes features written fn called chain length 
single feature chain length called chain 
predicate concrete domain 
uk chains expression concept term 
uk predicate exists restriction 
addition alcn hr attributes roles value exists restrictions 
attribute mapped partial function ai fn chain ui denotes composition fn partial functions 
ifn interpretation function modified follows 
un 
xn 
xn un 
xn proposition undecidability alcn hr concept consistency problem alcn hr decidable 
proposition proven reduction post correspondence problem pcp 
general idea proof slight variation undecidability proofs description logics alc transitivity operator baader hanschke alcrp lutz lutz ller 
proof 
post correspondence problem defined follows 
nonempty finite set li ri li ri words alphabet solution sequence indices 
ik concatenations wl li wr ri rik denote word 
pcp known undecidable contains symbols 
reduction elements viewed digits 
base 
denotes nonnegative integer base nonempty word represents base see baader hanschke 
vw concatenation words vw length word function mapping set nonnegative integers 
wl wr features 
fm attributes 
furthermore transitive attributes fi 

instance pcp define concept wl null wr null wl constr pi wr constr pi wl constr pi wr constr pi wl wr predicates defined follows null constr li li constr ri ri fm wl search space post correspondence problem encoded model concept 
undecidability alcn hr proven showing consistent iff pcp solution 
consistency decided algorithm decide pcp solution 
show solution consistent 
easily seen considering definition 
consistent exist interpretation 
demonstrates interpretation encodes infinite search space solution assumed consistent wl wr holds 
paths search space leads solution 
prove consistent solution 
direction proven defining interpretation pcp known solution exists 
aij aij ai fm aij ai wl aij wr aij recursively defined concatenation functions concat words denotes floor function concat lj concat rj 
discussed undecidability proof alcn hr follows approach showing undecidability alc trans baader hanschke 
furthermore idea construct concept way satisfiable iff pcp solution taken lutz ller lutz haarslev 
basic idea undecidability proofs construct transitive role order propagate concept constraint individuals tree encodes search space pcp 
undecidability proof alcn hr similar effect achieved exploiting role hierarchies transitive roles 
analyzing model pcp clear undecidability caused possibility establish predicates concrete domain objects referred features different individuals left hand side corresponding abox assertions 
finite model property lost alcn hr 
long finite model calculus problem 
hope conditions non termination occur established 
conditions encountered answer inference problem unknown 
considering quite complex pcp concept detail discuss simpler alcn hr concept intended describing lists numbers previous subsection predicates established concrete objects referred different individuals 
assume car feature cdr attribute rest transitive cdr 
name cadr chain cdr car 
elements see section 
example car cadr rest 
car cadr decidability problems concrete domains cyclic axioms discussed buchheit 
configuration context instance list cylinders described 
cdr cdr car car car cdr 
list numbers greater decreasing 
cdr cdr car car car 
list numbers greater decreasing starting 
sketches model concept individuals concrete objects 
total strict ordering model concept example infinite 
example car car car cadr rest 
car car cadr shows interpretation continued right expected way 
equal easily seen interpretation model extended right successor filler role rest 
example cdr car cadr rest 
cdr car cadr model concept structure interpretation shown finite role filler cdr required 
interpretation consisting individual fillers cdr car model 
interpretation represents empty list 
application oriented point view necessary describe infinite lists 
concept example captures lists arbitrary cdr 
finite length 
exists finite model possible devise calculus compute configuration initial input abox cf 

language undecidable general sound complete terminating calculus deciding knowledge base consistency inevitably return unknown situations 
conjecture possible detect situations guarantee termination preserving answers trusted 
case linear structures discussed examples possible integrate additional proof techniques involving induction principle 
example example unknown returned 
details calculus worked 
discussion chapter description logic alcn hr introduced extension alcn hr 
tableaux calculus deciding knowledge base consistency problem alcn hr 
soundness completeness termination shown 
addition applications logic context configuration problems sketched 
cylinder example demonstrates requirements model configuration system fulfilled alcn hr calculus chapter solve simple configuration problems configuration space described alcn hr knowledge base see buchheit nter additional representation structures solving configuration problems 
dl system race extended support reasoning concrete domains near 
adaptation important optimization techniques dependency directed backtracking model merging context concrete domains discussed haarslev 
emphasized obviously concept example means compared concept example 
chapter spatiotemporal terminological reasoning previous chapters shown expressive description logics developed representation requirements different application scenarios adequately fulfilled formal inference systems 
facilities offered base language alc alcn hr considered number restrictions transitive roles role hierarchies 
race powerful dl inference system logic introduced 
furthermore language alcn hr introduced previous chapter extends alcn hr facilities reasoning domains reals 
alcn hr expressive description logic inferences required dealing natural phenomena adequately captured alcn hr logics 
instance spatial temporal knowledge represented appropriate way context terminological reasoning description logics see section 
approach role names represent spatial relations inside quantification ob jects inside certain object possible value exist restrictions 
alcn hr roles declared transitive sufficient capture instance qualitative spatial inferences 
consider example known topological spatial relations rcc theory cohn represented role names see 
ontological commitment assume domain object associated spatial representation feature area 
consider terminological axioms different kinds cities city city 
city city ntppi center dc suburb city city ntppi 
center dc suburb dc disconnected ec externally connected po partial overlapping tpp tangential proper part ntpp non tangential proper part elementary relations regions inverses tpp tppi ntpp ntppi relation eq equal shown 
kinds cities contain center topological relation ntppi non tangential proper part 
addition concept definition exists suburb disconnected topological relation dc city 
second definition existing suburb disconnected center city 
models concepts graph notation 
edges drawn full lines correspond existential quantification roles concept definitions 
dashed lines objects represent predicates holding associated area features objects 
require suburb disconnected city certainly disconnected region inside city case center region 
concept requires existence suburb disconnected center suburb indicated relations city see lower parts 
set possible topological relations example city easily verified rcc relation composition table see cohn 
considering see concept city subsume concept city predicate dc ec po tppi ntppi represents disjunction spatial relations including dc 
semantics topological relations represented role names defined roles modeling subsumption relation detected 
declaring roles transitive suffice achieve necessary inferences 
define city concept specialization city additional restriction individuals spatially connected 
city city spatially connected suburb role spatially connected interpreted disjunction topological city city ntppi dc dc center suburb city city ntppi dc ec po tppi ntppi ntppi dc dc center suburb city city dc center suburb models concepts city city inferred role filler relationships see text 
lower part examples spatial regions corresponding objects upper part 
regions assumed associated corresponding object feature area 
base relations dc disconnected 
concept city defined city additional value restriction role spatially connected 
directly apparent careful thinking reveals city specific city 
due value restriction role spatially connected see concept definition city infer dc hold city suburb 
additional restriction city see reasons city specific city 
semantics topological relations modeled representation formalism 
order formally integrate spatial terminological reasoning description logic alcrp developed see haarslev lutz haarslev 
description logic alcrp alcrp description logic expressive power alcn hr regarding features number restrictions time powerful incorporation roles defined predicates concrete domain 
note notions features defined slightly different way context alcn hr 
concept language alcrp syntax semantics language specifying concept role inclusions 
definition role terms disjoint sets role feature names respectively 
element atomic role term 
composition features written fn called feature chain 
simple feature considered feature chain length 
predicate name arity 
un 
vm feature chains expression un vm role forming predicate operator role term 
role name role term 
terminological axiom role axiom 
type terminological axiom called role 
role called defined role 
definitions define syntax concept terms alcrp 
definition concept terms set concept names disjoint element concept term 
ifc concept terms arbitrary role predicate concrete domain ui feature chain expressions concept terms conjunction disjunction negation concept value restriction concept exists restriction 
un predicate exists restriction 
concept term may put parentheses 
considered abbreviation 
alcrp possible introduce role box set role axioms 
need impose special conditions role boxes contrast alcn hr see section alcrp role axioms just part tbox 
definition tbox axioms concept name concept term 
terminological axioms 
finite set terminological axioms called terminology tbox left hand sides terminological axioms unique furthermore concept definitions acyclic 
axioms tbox called concept axioms 
definition provides model theoretic semantics language introduced 
concrete domain 
definition semantics interpretation id consists set domain set domain concrete domain interpretation function interpretation function maps concept name subset role name subset feature partial function predicate name arity subset ifu fn feature chain denotes composition fn partial functions 
fn symbols concept expressions role names 
un feature chains predicate name 
interpretation function extended arbitrary concept role terms follows 
un 
xn 
xn un 
xn 
un 
vm 
xn 
ym 
xn un 
ym vm 
xn 
ym interpretation model tbox iff satisfies concept axioms int terminological axioms role introductions assertional language alcrp language representing knowledge individuals introduced 
abox finite set assertional axioms defined usual definition abox assertions set individual names 
furthermore set names concrete objects 
concept note difference semantics features alcn hr alcrp 
term role name individual names 
xn names concrete objects expressions assertional axioms concept assertion role assertion concrete domain feature assertion 
xn concrete domain predicate assertion 
interpretation function interpretation concept language extended assertional language additionally mapping individual name single element unique name assumption necessarily hold 
concrete objects mapped elements interpretation satisfies assertional axiom iff ai ci iff ai bi ri iff ai xi fi 
xn iff 
xn pi interpretation model abox tbox iff model furthermore satisfies assertional axioms decidability undecidability results notion model inference problems alcrp defined similar way alcn hr see section 
mentioned brevity role box considered context alcrp 
lutz ller haarslev shown unfortunately inference problem checking consistency concepts aboxes generic language alcrp undecidable general 
haarslev restricted variant alcrp described decidable syntactically restricted concept terms 
mentioned alcrp inference problems decided restricted alcrp concept terms admitted 
definition concept term called restricted tbox iff equivalent unfolded negation normal form fulfills conditions subconcept term form complex role term contain terms form complex role term 
subconcept term form complex role term contains predicate exists restrictions quantify technical reasons assume concept term subconcept term 
attribute chains length ii contained inside value exists restrictions contained terminology called restricted iff concept terms appearing right hand side terminological axioms restricted abox called restricted tbox iff restricted concept terms restricted terminology theorem abox consistency problem restricted alcrp concept terms decidable admissible concrete domain 
proof haarslev 
restricted concept terms subsumption relationship tested 
follows proposition 
proposition set restricted alcrp concept terms closed negation 
proof see haarslev 
spatioterminological reasoning examples discussed section employ reasoning concrete domain represent spatial relations domain objects 
due widespread focus topological relations known rcc theory randell 
alcrp rcc presenting examples briefly introduce concrete domain rcc 
consider specific spatial objects spatial representations polygons 
shown rcc provides predicates describe qualitative spatial rcc relations roles spatial objects 
relations depicted 
definition concrete domain rcc defined topological space domain rcc contains non empty regular closed subsets called regions short 
set predicate names defined follows unary concrete domain top predicate region region rcc rcc negation region region rcc 
basic predicates dc ec po tpp ntpp tppi ntppi eq correspond rcc relations see 
refer haarslev formal definition semantics 
order name disjunctions base relations need additional predicates 
unique names disjunction predicates enforced imposing canonical order basic predicate names dc ec po tpp ntpp tppi ntppi eq 
sequence pn basic predicates canonical order additional predicate arity defined 
predicate name pn pn rcc iff rcc pn rcc predicate dc ec po tpp ntpp tppi ntppi eq called spatially related 
binary predicate inconsistent relation inconsistent relation rcc negation spatially related 
proposition concrete domain rcc admissible 
proven haarslev 
results renz conclude exists model individuals polygons necessarily internally connected 
specific contexts disturbing applications internal connectedness required 
instance countries islands connected main area country reasoning alcrp rcc gis application city examples chapter demonstrate importance spatioterminological tbox reasoning 
role axioms abovementioned implicit subsumption relationships different city concepts follow 
ntppi area area ntppi dc area area dc spatially connected area area ec po tpp ntpp tppi ntppi eq concrete domain rcc introduced turn example expressive power alcrp demonstrated context spatioterminological abox reasoning 
consider set additional role city country city country city country port port port candidate configurations abox individuals see text 
axioms 
related area area spatially related inside area area tpp ntpp inside area area tppi ntppi touching area area ec overlapping area area po tpp ntpp tppi ntppi eq concept axioms constitute tbox example reasoning alcrp rcc 
sea sea sea coastal city city touching sea country overlapping sea sea ocean coastal city defined city touched sea sense ocean 
furthermore second axiom enforces countries overlap seas 
inferential power alcrp rcc explained instance problem concerning abox 
loc city country country port port sea sea loc country inside loc port inside port sea touching tbox abox example contain restricted concept terms 
inference problems decidable 
consider instance problem instance loc coastal city posed query description logic system 
indicated see section answer query determined test abox inconsistent assertion loc coastal city added 
possible spatial configurations abox information shown 
considering definition inside topological relation city loc country country tpp tangential proper part ntpp non tangential proper part 
basic relations city port tppi ntppi inverse port port tangential non tangential proper part city 
port touches sea sea relation ec externally connected due second terminological axiom country sea overlap base relations po tppi ntppi eq third configuration leads consistent scenario 
due query claimed loc coastal city holds sea touching city see terminological axiom coastal city 
abox inconsistent answer query instance loc coastal city 
spatiotemporal terminological reasoning considering general mechanism integrating concrete domains clear instance alcrp deal qualitative temporal relations time intervals allen 
idea define concrete domain allen modeling constraints time intervals binary predicates representing allen interval algebra meets met overlaps overlapped contains starts started finishes finished equal disjunctions basic predicates 
constraint satisfaction algorithms known literature see gerevini overview employed check polygon polygon bird dredging area jan feb mar apr may jun jul clip city map see text 
satisfiability conjunctions predicates 
furthermore baader hanschke shown technical perspective disjoint admissible concrete domains combined form single admissible concrete domain combination operator called 
extension concerning roles predicates alcrp discussed haarslev 
combination rcc allen defines predicates conjunctions predicates component concrete domains spatial temporal concrete domain 
temporal domain combination spatial domain illustrated example gis application introduced 
assume gis database certain area defined bird march may see dark gray bar 
ti ti ti part planning scenario assume hypothetical dredging operation scheduled april june inclusive middle gray bar 
affected area creek bach indicated hatched region 
addition assume dredging creek involves handling trucks dredging machinery 
assume existence called support area touching real dredging area creek topological relation ec 
furthermore background knowledge indicate support process starts earlier lasts longer proper dredging operation dredging machinery installed see light gray bar example 
obviously reader expect spatiotemporal constraints conceptual knowledge knowledge individuals example suggest dredging active bird sanctioned planning module gis 
question planning problem gis facilities solved knowledge representation techniques logical inferences 
describe solution description logic alcrp rcc allen 
planning problem represented knowledge base consistency problem 
tbox contains background knowledge domain abox represents supposed spatial temporal constraints bird certain dredging operation 
domain objects bird dredging operation represented abox objects 
idea show corresponding abox proven inconsistent constraints modeling knowledge informally introduced previous section 
ontological decision assume temporal intervals associated individuals feature duration 
define spatiotemporal process process interval region exist fillers corresponding features 
predicate interval assumed check membership corresponding concrete domain see admissibility criterion definition 
spatiotemporal process process duration interval area region noisy process process dredging support process spatiotemporal process noisy process addition auxiliary concepts introduced capture dredging support process 
concepts partially defined inclusion axioms 
concept spatiotemporal process subsequent terminological inclusion axioms specific spatiotemporal processes 
interaction space time example represented introducing roles ec ntppi overlaps relate fillers corresponding area duration fea tures 
ec area duration area duration ec ntppi overlaps area duration area duration ntppi overlaps connected ends overlaps area duration area duration connected ends overlaps predicate ec ensures constraint ec imposed fillers area features ii constraint describes relation fillers duration features 
ntppi overlaps corresponding constraints established area duration features respectively 
define role connected ends overlaps combining spatial connectedness generalized temporal overlapping 
predicates domains simultaneously hold pair individuals 
partially define concepts dredging process bird 
dredging process spatiotemporal process ec dredging support process bird spatiotemporal process noisy process connected ends overlaps connected noisy process spatiotemporal role ec relate dredging support process appropriate way 
bird modeled non noisy spatiotemporal process fillers defined spatiotemporal role connected ends overlaps objects turn connected non noisy processes 
idea definition temporally overlapping connected objects spatially connected noisy processes cause inconsistency 
alcrp criterion fulfilled terminology 
order represent gis information concerning bird simply add abox axiom individual assumed represent available information particular bird stored gis 
hypothesis dredging process additional abox axioms individual spatiotemporal relationship see 
bird dredging process ntppi overlaps neglect technical details gis implementation relation abox dl system 
bird po tppi ntppi ntppi overlaps ec dredging process dredging support process spatial constraints temporal constraints ntppi area ec overlaps duration duration ends overlaps abox testing satisfiability dredging process query implicit spatial temporal information shown constraint nets see text 
abox checked consistency 
graphical representation abox shown 
due constraints abox individual generated 
individual constraint dredging support process asserted 
furthermore additional constraints resulting spatiotemporal relationship derived see role ec spatial temporal constraints 
filler connected ends abox see 
due value restriction role concept bird new constraints added 
value restriction connected asserted 
fillers connected role respect 
consider individual 
constraint noisy process added 
causes clash dredging support process noisy process definition 
due spatiotemporal constraints way find consistent tableau abox inconsistent 
reader easily verify existence dredging support process required abox inconsistent example dredging process assumed noisy process 
case inconsistency concerning course 
example shows interaction spatiotemporal conceptual knowledge important gis systems 
inconsistency abox interpreted application system way dredging operation better planned period year 
note abox reasoning easily replaced model checking implicit processes see exists constraint definition dredging process part input gis system 
application system knowledge predicate role connected subsumes predicates ntppi ec po tppi ntppi 
attractive compute alternatives duration intervals scope example 
necessary dredging support process need directly available 
furthermore alcrp seen defined roles interaction different concrete domains provides powerful modeling technique available alc alcn hr example abox explicitly added spatiotemporal constraint ntppi overlaps bird dredging process 
required corresponding abox assertion inferred 
principle add similar constraints pair spatiotemporal processes 
find way avoid 
explicit regions time intervals indicated 
concept forming predicate operator additional predicates extended concrete domain order represent quantitative knowledge regions time intervals explicit coordinates time points respectively 
problem combining metric topological constraints investigated research see haarslev 
spatioterminological default reasoning investigate reiter approach reiter terminological default reasoning spatial information 
originally default rule form written fopl formulae 
called precondition rule terms called justifications consequent 
intuitively idea default reasoning starting world description known true default rules applied augment default rule yield set beliefs 
default applied added set current beliefs iff entailed set formula consistent current set beliefs entailed 
defaults may interact depending set default rules applied different possible worlds hypotheses computed 
possible worlds referred extensions see formal definition 
depending reasoning mode consequence problem terminological default theories decide assertional axiom member extensions skeptical mode extension credulous mode reiter 
description logic concept terms default rules order propositional logic formulae extensively considered baader hollunder 
terminological default theory pair abox finite set terminological default rules preconditions justifications consequents concept terms 
concept terms correspond unary predicates ranging free variable defaults called open defaults 
contrast closed defaults contain free variables 
reiter original proposal approach baader hollunder applies defaults individuals explicitly mentioned world description abox 
default rules applied implicit individuals introduced restrictions 
kind semantics consequence problem decidable see baader hollunder details 
closed default rules obtained instantiating free variable concept expressions explicitly mentioned abox individuals see baader hollunder formal definition 
closed defaults concept membership assertions abox concept axioms 
closed default theory set consequences theory referred extension set deductively closed formulae defined fixed point construction 
case terminological default reasoning spatial information interesting conclude spatial relations default 
extended approach baader hollunder able deal role assertions default rules 
achieved allowing alcrp rcc aboxes inside default rules 
discussing computation extensions closed default theories consider examples defaults context terminological reasoning spatial information 
image understanding application illustrate dl integrated topological reasoning example part aerial image interpretation task 
idea defaults hypothesis generation regarding classification areas image 
default reasoning component dl generate extensions abox representing hypothesized classifications consistent rest knowledge base 
consistency check involves spatial reasoning 
additionally spatial relationships areas hypothesized example case partial object occlusions see 
example suppose incomplete knowledge regarding classification object 
know country area known area 
image interpretation system may want generate possible hypotheses city lake 
area country city country lake country country country generation hypotheses object concepts plausible hypotheses size area obviously different hypotheses disjoint city lake 
hypotheses generated plausible sight 
particular require countries disjoint relation dc touching relation ec system deduces hypothesis shown generated 
formalizing example alcrp rcc role forming predicate operator declare set role axioms mentioned rcc predicates inside contains overlaps touches disjoint area area tpp ntpp area area tppi ntppi area area po area area ec area area dc definitions concepts required model domain objects representing different kinds regions tbox satisfies alcrp criteria 
conceptual background knowledge applies subsequent examples 
area natural region area region administrative region country region administrative region large scale area city region administrative region large scale area lake region natural region area river region natural region area area dimensional region extent 
furthermore distinguish administrative regions natural regions disjoint concepts 
difference country region city region large scale 
concepts disjoint 
intention concept definitions obvious 
country country region contains country region overlaps country region inside country region city city region inside country region lake lake region river river region overlaps lake region contains inside lake region country country region contain contained country regions 
countries overlap country regions 
city belong specific country lie country 
unfortunately write directly inside country unfolded resulting term longer restricted 
somewhat weaker version base concept country region 
world model city inside country 
river require overlaps inside lake region 
river flowing lake river touches lake region river flowing lake specific river touches lake region recall rcc relations ec po ec ntpp tpp disjoint 
country city country city 
city country region subtle inferences due topological constraints 
reasonable state cities overlap cities ignored sake brevity 
formalizing hypothesis generation way discussed informally consider spatioterminological default rules area city city area lake lake area country country suppose abox world description shown country area contains inside closing defaults instantiating defaults abox individuals yields different closed defaults 
assume replaced corresponding assertional axioms instantiating default area city city individual yields closed default rule area city city expressions city called assertional axioms abox axioms 
notation di ind refer default instantiated individual ind closed default rules examine status default applied adding city abox yields contradiction country 
concepts country region city region disjoint due large scale large scale 
default applied 
get augmented abox extension see country area city contains inside default applied adding lake abox yields contradiction country 
administrative region lake defined natural region disjoint concepts 
default applied 
get augmented abox extension see country area lake contains inside abox augmented default city apply 
ord applied resulting different extensions 
default applied entailed abox 
default applied default applied 
adding default consequent country yield inconsistent abox known country contains country region holds 
contains holds country imply country region default applied 
get extension corresponding wrong interpretation 
example subtle inference demonstrated showing default defined applied conclude object city 
corresponds abox world description country area overlaps overlaps trying assert city result constraint city region inside country region 
polygon appropriate country region overlaps holds 
due exists restriction exists implicit individual country region inside holds 
seen way find spatial arrangement inside overlap contain country may overlap may contained country region way conclude possibly city 
example lake cloud river incomplete spatial information 
consider 
case incomplete spatial information topological relationship cloud occludes relevant parts objects 
corresponding abox lake river know lake river hypothesis generated previous default rule applications conclude conceptual background knowledge spatial relationship river lake ec touches dc disconnected disjoint 
possibilities river overlaps lake contained lake 
hypothesize possible spatial relationships default rule applications 
shows concept class memberships deduced defaults 
important insight duality spatial relations object pairs conclude concept memberships known concept memberships conclude particular spatial relations objects 
unfortunately relations individuals expressed terminological default rules introduced far limited concept expressions 
extend terminological default rules introduced baader hollunder permitting called abox patterns concept expressions ller wessel 
abox patterns basically aboxes placeholders individuals written capital letters 
closing default rules instantiates patterns possible combinations individuals yielding closed defaults alcrp rcc aboxes lake river disjoint disjoint lake river touches touches closing patterns instantiating abox lake river yield different closed defaults alcrp rcc aboxes instantiating yields closed default rule lake river disjoint disjoint additionally allowing variables able refer specific abox individuals abox patterns instance individual 
default reasoning specificity consider world description river flowing lake lake known river flowing lake river conclude lake lake 
complex role assertion touches added lake river flowing lake touches touches case render application invalid specific yields touches 
default da said specific db da db iff da db db da denotes precondition default algorithms computing called extensions specificity developed baader hollunder baader hollunder 
strong conjecture algorithms applied alcrp rcc context 
contrast ordinary extensions called extensions reiter 
example get different extensions extension containing abox axiom touches 
extension containing disjoint derived specific active defaults applied computing extensions 
render application impossible active specific 
concludes illustrating examples 
shown standardized reasoning services dl generate hypotheses consistent available knowledge 
course building blocks required image interpretation 
questions regarding ordering extensions verification possible extensions additional evidence incorporation metric information treated cases answered 
line hope value inference services demonstrated 
section show consequence problem decidable terminological default theories default rules containing alcrp rcc aboxes 
obtain ordinary aboxes abox patterns closing consequence problem decidable defaults abox patterns 
believe important result extends applicability default reasoning interpretation tasks arise high level computer vision 
computing extensions intuitively closed terminological default theory deductively closed set consequences theory referred extension 
usual exact definition fixpoint construction 
cite formal definition taken baader hollunder 
th stands deductive closure set formulae 
description logic context abox 
definition set closed formulae closed default theory 
define ei ei th ei th th extension iff th th ei note principle definition extension th non constructive nature definition deductive closure th iteration step 
see definition induces algorithm computing extensions implicit entailment subproblems definition decidable see baader hollunder 
order able infer spatial relations domain objects basic terminological default reasoning approach described baader hollunder adapted 
basic idea precondition justifications consequent default aboxes 
definition spatioterminological default rule spatioterminological default short form consistent restricted alcrp rcc aboxes may contain predicate role axioms form area area rcc predicate arity 
spatioterminological default theory tuple set spatioterminological default rules consistent restricted alcrp rcc abox 
lemma restricted alcrp rcc abox axiom logically entailed restricted alcrp rcc abox sat sat xnew xnew sat xnew region xnew iff sat sat sat sat sat area xnew new atomic concept appear abox xnew marker concept 
analogously resp 
new unused concrete domain marker predicate 
predicates property interact concrete domain predicates pi 
arbitrary conjunctions concrete domain predicates pi pi satisfiable iff pi satisfiable 
pi unsatisfiable regardless satisfiability pi 
additionally primitive role feature 
sat decides abox consistency problem abox please note interpreted domain objects interpreted concrete domain objects 
concrete domain domain disjoint 
proof 
sketch case instance checking problem decidable restricted concept term 
second case deals primitive role assertions 
case successor assertion xnew entail xnew xnew new unused atomic marker concept 
obviously contradict assertion xnew 
trick applied check holds 
primitive roles successor concrete domain object contradict assertion xnew 
check presence concrete domain filler asserting region holds propagate xnew marker xnew yields immediate contradiction recall concrete domain domain disjoint 
propagate new unused concrete domain marker predicate 
stated resp 
affect satisfiability concrete domain predicates pi possibility get contradiction respect asserted concrete domain object want infer successor domain successor concrete domain 
check presence domain filler asserting additionally check known successor asserting 
fifth case decide binary concrete domain predicate holds concrete domain objects 
exists concrete domain predicate negation case problematic alcrp rcc language provide negation operator predicate role axioms 
check area area area region area region holds 
nnf area region area region area 
area region inconsistent resulting term area area area area 
obviously alcrp rcc abox 
inconsistent iff ai ai inconsistent 
note predicate name exists concrete domain required admissible 
theorem consequence problem spatioterminological default theory decidable 
proof 
considering sound complete tableaux calculus deciding consistency restricted alcrp rcc aboxes th iff 
th view abox representative extension 
fixpoint construction definition tester determining abox really extension default theory 
extension abox having form set called generating defaults simply check element extension 
inference problems need decided 
th ei easily tested checking ei 
decide abox entailment problem iff decide assertional axiom ai logically entailed ei ai ei ai 
decided lemma 

th checked testing bn iff consistent 
abox consistency problem restricted alcrp rcc aboxes decidable 

th th ei fixpoint constructed finite number steps consider finite number defaults 
principle decide abox equivalence problem 
abox equivalent abox iff abox equivalence problem reduced abox entailment problems 
baader hollunder algorithm discussed computing extensions 
empirical tests prototype implementations indicate algorithm efficient average case 
strong conjecture algorithm applicable alcrp rcc context 
furthermore easily seen results spatioterminological default theories wrt 
alcrp rcc extended alcrp 
discussion context computer vision theory applying spatioterminological default reasoning investigated 
chapter extends previous alcrp rcc haarslev haarslev integrating default reasoning spatioterminological reasoning 
new contributions previous terminological default reasoning baader hollunder base language expressive spatioterminological description logic alcrp rcc 
allowing concept terms formulae default rules restricted alcrp rcc aboxes complex role assertions necessary application oriented point view imposes number theoretical problems 
shown possible extensions closed alcrp rcc spatioterminological default theory effectively computed 
implementation alcrp described 
implementation alcrp default reasoning substrate implementation alcrp tbox abox management system rcc relation network consistency checker available research purposes 
qualitatively speaking tests current implementation indicate small problems abox assertions results expected reasonable time currently runtimes dramatically increase individuals involved 
pointed spatioterminological default reasoning provide important service constrained hypothesis generation vision systems 
development underlying foundations necessary step knowledge vision system architectures powerful inference services employed costly error prone application specific programming 
pointed selection rcc predicates motivated widespread 
calculi qualitative quantitative spatial representations considered 
see careful theoretical analysis spatial structures 
chapter deductive information systems information sources various kinds available increasing number users major challenge computer science provide adequate access retrieval mechanisms 
true web information nature tends highly unorganized heterogeneous dedicated databases designed provide particular service 
example instance retrieval instance retrieval inference problem usually defined respect concept abox tbox possibly 
problem slightly extended 
characterize set individuals retrieved concept term alternatively set example individuals 
example instance retrieval problem filter concept set individuals 

filter concept set individuals 
example individuals 
purpose select similar individuals set preselected individuals 
note individuals 
need instances show example individuals derive second concept term describing individuals related example individuals 
returned individuals instances order retrieve individuals related example individuals necessary compute abstraction representing commonalities example individuals 
relatedness individuals usually hard define pursue approach 
individuals consider direct types individuals respect tbox 
specifically describe individual example instance retrieval query conjunction direct types 
informally speaking idea compute abstraction direct type conjunctions 
abstraction represent commonalities example individuals described direct type conjunctions 
give formalization commonalities set concepts terms common subsumer lcs 
definition common subsumer concept common subsumer consistent concepts iff subsumes common subsumer subsumed see cohen 
representation language contains operator lcs concepts disjunction input concepts 
seen description logic languages classic offer operator 
furthermore applications expressivity classic appropriate 
restricted language aln successfully representing domain models cases 
advantage consistency problem case 
investigations develop algorithms computing lcs expressive languages 
language aln lcs consistent concepts computed follows cohen 
lcs operation applied tbox concept axioms arguments unfolded applying lcs function 
concept term transformed unfolded form iteratively replacing inserting concept names defining terms 
lcs lcs lcs lcs lcs lcs min lcs max easily verified lcs associative operation 
lcs operation define sequence qi query concepts 
ti conjunction direct types individual ik 

tn set direct type conjunctions example individual ik parameter example instance retrieval operation 
furthermore lcs qi 
qin 
function successively applies argument left associative function result previous application initially components third argument sequence 
index ni cardinality set qi 
qi defined set parents 
note exists equal 
example instance retrieval problem find minimal index sequence concepts qi set example individuals 
proper subset set individuals qi retrieved instance retrieval qi qin ors retrieved instance retrieval 
minimal index obtained result example instance retrieval operation qi 
proper subset qi ors 
concept filter concept introduced 
addition example instance retrieval lcs operator subtask bottom construction knowledge bases dls aln cyclic concept definitions baader sters 
see kietz morik similar application concerning constructive induction classic tbox data 
cooperative information systems agent computing section cooperative information system scenario different agent specific reasoning capabilities discussed 
guiding example tv assistant database containing tv program information 
task tv assistant guide tv selecting favorite program item potentially large set candidates 
example tv assistant able identify pirate movie sailing ships movies new german digital tv channel broadcasts minutes 
furthermore preferences user tv program tv assistant determine suitable commercials 
demonstrated description logics play important role important area business applications 
obviously large variety criteria tv express preferences 
may want refer contents program item terms genre type main characters location historical events plot may want refer production information producer cast recording technique date origin particular viewer situation language age requirements 
criteria existing tv program services genre cast age recommendations deductive information retrieval infancy 
prevailing approaches inference access retrieval utilize textual information terms keywords word statistics 
surface textual information retrieval typically string indexing offers advantages particular queries involving natural language terms availability text documents 
hand string indexing unreliable respects 
documents may produced aim support textual retrieval 
matter chance desirable keyword really appears document 
second examples tv program selections show naturally expressed queries may involve terms specific textual descriptor data conceptually close sailing ship 
similarly may interested movie home town say hamburg 
inference retrieval index descriptors involving string hamburg possibly locations spatially related hamburg northern germany hamburg famous red light district 
apparent additional conceptual information exploited avoid unwanted retrieval hits involving certain popular food items 
chapter investigate conceptual descriptions description logics deductive information retrieval agent scenario 
chapter deals main aspects 
strengths limitations dls information retrieval investigated 
second cooperation strategies agents reasoning different dls analyzed 
investigating dls information retrieval consider wide variety languages analyzed research partly implemented far 
important differentiating aspect dls expressiveness concept expressions may formulated particular dl resulting complexity inference procedures consistency checking subsumption computations 
dls fairly limited expressiveness attractive runtime properties dls enriched expressiveness pay doubly exponential inference complexity 
furthermore certain restrictions expressiveness observed dl may undecidable sense terminating inference procedures sound complete exist longer 
may acceptable applications considered severe disadvantage reliability stake 
know dls today reasonable expect single dl optimally suited knowledge applications 
consider heterogeneous special purpose knowledge bases dls different expressiveness 
knowledge bases may designed meet different design goals 
knowledge base may provide quick crude inferences may allow sophisticated inferences cost longer response times third may specialist temporal reasoning forth spatial reasoning 
led investigate dl systems agent scenario different dls organized cooperate information retrieval task 
general structure agent scenario shown 
user may software system submits information retrieval tasks broker central node agent network 
broker may invoke services program agent gis agent tv broker agent tv assistant web software user user user overview system architecture 
broker agent communicates agent responsible tv program agent specialist geographical information system gis requests 
broker agent provides interface software tv assistant web server 
agent nodes 
knowledge bases agents may different dls may developed independently 
order communicate broker certain interschema knowledge formulate information retrieval task result 
consider instance retrieval instance checking basic information retrieval tasks 
defined instance retrieval inference service dl system concept term submitted query task retrieve individuals instances concept term 
instance checking query comprises concept term set individuals checked concept term 
tasks identical logical perspective amount consistency checking aboxes full negation supported logic 
consider application example extension instance retrieval examples compute second concept term retrieved individuals instances see 
reasoning processes agent agent terminology obvious instance checking performed agent task formulated terms agent terminology 
scenario task broker transform queries subtasks thereof employed 
purpose broker equipped interschema knowledge relates different terminologies 
broker approximate assertional descriptions concept terms expressions concepts roles particular details see 
exceptional cases expressions may equivalent general approximations 
interesting question reasoning employed instance checking correctness result 
section shown possible albeit extent 
basic idea approximate queries way concept term query constrains individuals specialized individual descriptions generalized 
approximated individuals instances approximated concept term original individuals instances original concept term 
hand aware fact combined logics agents may undecidable 
case inconsistency may detected reliably procedure combines knowledge agents 
inherent limitation interesting consequences regarding draw multi agent information retrieval scenario 
multi agent inference problems turn multi agent information retrieval problem sketched section 
agents comprising different knowledge bases expressed different description logics cooperate information retrieval 
approach section presumes agents plays part broker called specialists supply information broker 
broker receives queries user communicates specialists delivers answers user 
communication user performed broker terminology 
able communicate agents broker knowledge concept role names agent relate broker terminology interschema axioms catarci lenzerini 
main task broker transform queries terminology agent transform answers back broker terminology 
described precisely 
inference problems namespaces order description logic application set atomic concepts roles tailored application specified 
relationships atomic concepts roles defined axioms 
distinguish different knowledge bases define notion namespace 
definition namespace namespace set atomic concepts atomic roles common prefix name namespace 
definition concept role namespace concept called concept namespace iff atomic component concepts prefix 
role called role namespace iff prefix 
notion namespace special role broker agent specified 
knowledge base contains atomic concepts roles multiple namespaces different prefixes 
broker perform inference services different namespaces 
instance broker compute parents necessarily atomic concept namespace tbox result set specific atomic concepts namespace subsume set children namespace direct types individual certain namespace defined analogously 
namespace transformations concepts roles aboxes consider instance checking task broker may invoke specialist 
query consists concept term individual name abox broker terminology 
task check individual instance concept term 
broker prove knowledge base individual instance concept term task solved see section inconsistent queries 
broker knowledge inconclusive specialist may help 
query transformed approximate query concepts roles namespace specialist 
key idea transform query abox abstracted concept term refined specialized 
furthermore necessary ensure abstractions refinements fulfill certain criteria see section 
definition abox abstraction abox abstraction abox iff holds 
heuristics compute abox abstraction 
role role assertion abox specific namespace destination agent inserted 
note specific namespace destination agent may synonym role transformed 
specific unique namespace consulted agent new role dynamically added appropriate inclusion axioms new role set specific 
exists tbox certain destination agent agent name related 
role related assumed atomic roles agent 
similar transformations employed atomic concepts concept assertions 
synonyms conjunction parents namespace destination agent inserted 
note worst case returned abstraction certain concept 
definition concept refinement concept refinement concept iff subsumes different strategies computing concept refinements 
order refine query concept children namespace destination agent computed 
children 
cn concept refinement disjunction cn 
bottom concept returned child second strategy employed 
refinement computed form concept 
similar way abstraction process abox roles concept terms query concepts transformed 
consider existential restriction example 
transformation concept general namespace destination agent result recursive transformation atomic concepts transformation disjunction children namespace destination agent see strategy 
strategy defaults order specialize queries see wahl lambrix applications context information retrieval 
refinement rewriting concepts terminologies investigated instance baader cheng 
broker query answering consider answers different agents combined logical perspective 
take principled view problem 
assume tboxes representing knowledge agents respectively 
instance alcn hr tbox alcrp tbox 
con results section know combination alcn hr alcrp undecidable 
general know sound complete terminating calculus answering query posed knowledge bases dls 
consider instance checking problem instance knowledge base 
furthermore assume abox inconsistent 
idea address query suitable transformation thereof knowledge base separately 
answer instance checking problem instance 
obvious answer 

order address query may transform assume abox 
instance may contain number restrictions concept terms 
transform instance checking problem instance 
solved abstraction refinement easily seen exploit answer original query answer subproblem instance 
answer instance 

terminologies return sure result undecidability 
attempt solve inference problem instance addressing knowledge base separately 
answer complementary query answer original query instance sure 
limitations inevitable basis sound query answering schema arbitrary agent scenario 
agent sound complete terminating sub algorithm inference tasks question 
specific agent broker poses inference problems agents 
task broker needs tbox close approximation tboxes agents 
put things describe instance checking query dealt multiagent scenario 
broker tries answer query abox 
answer negative broker consults agent namespace contains individual query 
concept query specialized broker abox fragment individual abstracted order preserve correctness 
answer specialist positive answer returned broker 
case negative answer assume specialist returns abox fragment individual question mentioned 
broker transforms information terminology consult specialist agents enriched abox information individual 
case atomic concepts roles translated specialist namespace preserving correctness abox abstraction concept refinement 
specialists returns broker returns answer undecided 
case broker may try answer query negated concept 
specialists succeeds answer original query remains undecided 
broker delegates example instance retrieval task specialist agent name determined namespace individuals mentioned example instance retrieval query 
restriction individuals namespace 
filter concept concept namespace broker 
transformed understandable consulted specialist agent 
transformed filter concept defined concept refinement namespace consulted agent 
supporting business inferences internet technology discussed motivating scenario agentbased architecture investigate section information retrieval application 
particular focus tv assistant main task provide personalized tv programs web environment 
user ask personalized tv program providing time window ii examples broadcasts characterize interests 
tv assistant retrieve broadcasts time window called basic selection mark broadcasts special interest user examples personal selection 
done example highlighting broadcast program table 
second task tv assistant select advertisements inserted personalized program display 
accomplish advertisements associated conceptual descriptions called trigger concepts types broadcasts advertisements displayed 
broadcast contained personal selection user turns instance trigger concept associated advertisement shown 
application scenario assume tv assistant services multiagent information system shown 
basic program selection retrieved posing instance retrieval query tv broker agent time window expressed conceptual constraint 
tv broker agent forwards query program agent receives basic program selection 
second step personal program selection obtained posing instance retrieval query tv broker agent examples provided user time window filter concept 
answer set broadcasts personal selection associated additional information example actors main location case movie 
advertisements determined trigger concepts maintained tv assistant 
broadcast personal selection tv broker agent asked broadcast instance trigger concept 
scenario agents tv broker agent possibly solve instance checking problem 
assume program agent asked 
answer broker turns specialist case gis agent spatial reasoning power 
agents detail discuss examples 
agents application example program agent uses language aln concept axioms non cyclic terminological axioms additional condition terminological axiom left hand side axioms 
prototype system program agent ller implemented knowledge representation system classic brachman provides optimized abox implementation language aln classic supports slightly expressive dl see chapter 
chapter subset implemented knowledge base 
assume tbox program agent contains terminological axioms explained section 
program agent perform example instance retrieval procedure explained section 
extend domain model definitions movie define new concepts sailing ship titanic subconcepts ship 
addition assume soldier pirate declared subconcepts person 
furthermore domain model extended concepts specific movies 
important roles movies main character main location 
examples terminological axioms 
soldier person pirate person sailing ship ship titanic ship pirate movie movie main character 
pirate captain main location sailing ship titanic movie movie main character captain main location titanic action movie movie main character action hero structure shown abox represents small excerpt domain model objects abox tv assistant application 
notion titanic modeled concept instance different individual ships carry name 
movie movie main character main location captain soldier sailing ship movie main character movie main location movie pirate movie movie titanic movie second example assume program agent detailed information james bond movie world world action movie james bond action hero loc loc london country continent asia port port sea sea world james bond main character world loc main location world loc main location loc country capital loc port port port sea located country continent located continent gis agent uses description logic alcrp rcc 
assume tbox gis agent contains role concept axioms introduced section 
role gis agent scenario understood discuss inferences central agent tv broker agent 
tv broker agent uses description logic alcn hr 
assume atomic concepts roles program agent gis agent corresponding terminological axioms available tbox tv broker agent 
atomic concepts roles imported agents indicated prefix 
prefixes pa ga ba program agent gis agent tv broker agent respectively 
queries tv broker agent trigger concepts atomic concepts roles prefix ba 
part tbox tv broker agent specifies relationships roles program agent roles gis agent terms terminological axioms pa capital ga inside pa port ga inside pa located ga touching pa located continent ga inside pa main location ga inside ga spatially connected ba spatially connected description logic alcn hr relationships manifested role inclusion axioms 
furthermore order approximate semantics topological rcc relations ga inside ga inside declared transitive roles 
obviously ga touching transitive role 
agent acquaintance axioms indicating direct subsumption relationships parents children atomic concepts imported agent added automatically tbox tv broker agent 
instance role axiom ga inside ga spatially connected added tbox tv broker agent 
additional concept inclusion axioms employed relate concept terms different tboxes 
axioms set automatically modeled system engineer 
pa ga city pa london ga city pa ga country pa port ga port pa sea ga sea ga coastal city ba coastal city ga coastal city ga city ga touching ga sea ga country ga overlapping ga sea ba asian city pa city ga inside pa asia note generalized concept inclusion axioms 
addition axioms section representing knowledge gis agent included tbox tv broker agent appropriate prefixes 
reasoning examples example assume movie movie filter concept example query posed program agent 
example base instance retrieval movie movie answering query lcs operation applied unfolded direct types movies see section returns concept movie main character captain main location ship see abstraction original movies computed 
pirate movie concept sailing ship abstracted ship titanic movie concept titanic abstracted ship 
resulting lcs concept query retrieving instances abox program agent 
results query restricted time window filter concept 
example movie movie instance lcs concept returned answer possibly 
second example assume advertisements trips asian cities associated appropriate broadcasts 
trigger advertisements consider concept ba spatially connected ba coastal city concept ba spatially connected ba asian city set interest travel agency 
retrieval result movie world isan instance trigger concept associated role fillers ba spatially connected instances ba coastal city ba asian city examined find trips offered travel agency 
idea course viewing movie people inclined book cruise main location movie 
tv broker prove world instance ba spatially connected ba asian city ga inside declared transitive role knowledge base tv broker agent 
need consult agent 
unfortunately abox associated world see tv broker agent prove movie instance ba spatially connected ba coastal city 
prove instance ba spatially connected ba coastal city 
scenario tv broker agent asks gis agent check individual world instance concept ga spatially connected ga coastal city 
transforming abox tv broker agent received program agent abox delegated gis agent 
world james bond loc ga city loc ga city country ga country port ga port sea ga sea world james bond ga related world loc ga inside world loc ga inside loc country ga inside loc port ga inside port sea ga touching country continent ga inside considering example section easily verified answer gis agent query ga spatially connected ga inside 
fact third configuration shown qualitatively describes exactly relation see 
map indicating position capital 
tv broker agent knows result query adds result abox originally sent gis agent example assertion world ga spatially connected ga coastal city 
software module tv broker instructed insert specific travel agency commercials associated trigger concepts case 
note general combining knowledge independent knowledge bases may uncover inconsistencies 
example abox returned gis agent prove inconsistent abox tv broker agent 
case meaningful answer supplied 
example section demonstrates combined expressive power different dls 
alcn hr provides generalized concept inclusions role hierarchies transitive roles needed represent knowledge required application domain 
ontological interdependencies captured due undecidability results 
formalism alcrp rcc itis possible include ontological interdependencies concerning conceptual spatial knowledge 
possible extend language alcn hr inverse roles socalled qualified number restrictions horrocks order better approximate knowledge specialists case gis agent tv broker agent 
developing optimized abox reasoner implementation extended logic difficult task subject research 
case due undecidability result approximation 
agent architecture proposed chapter provides organized way cope undecidability incompleteness problems resulting combination different expressive representation languages 
related information retrieval distributed context commercially interesting research topic 
exists vast amount scientific contributions hardly possible cover small subset 
different approaches pros cons 
focus related concerning information retrieval context description logics database theory data structure conversion tsimmis system garcia molina knowledge representation approaches fensel 
early application description logics information retrieval purposes 
authors focus multi valued logic order capture notion relevance contributions rely standard semantics 
instance information manifold project levy extended classic description logic brachman called conjunctive queries order provide expressive query language 
solutions query refinement defaults developed lambrix 
subsumption conjunctive queries expressive description logics investigated horrocks 
interesting support stance retrieval conjunctive queries expressive description logics alcn hr development efficient algorithms instance retrieval conjunctive queries active research area 
approach described horrocks tessaris 
conjunctive queries related datalog specifications 
datalog approaches reasoning supported specific model database conjunctive queries description logics models considered 
approach mcguinness relies classic system 
uses called ontologies supporting web browsing search 
focuses retrieval web pages annotated ontological notions 
agent communication description logic context considered klusch 
addition complementary approach game theory control activity agents 
schema integration inter schema knowledge modeling investigated catarci lenzerini 
contrast approach chapter catarci lenzerini rely assumption domains different agents identical 
consequence notion intensional inclusion different concepts defined extension inclusions gcis 
desired considered agent scenario 
decomposition queries multidatabase scenario considered cardiff 
ideas taken context applied agent scenario 
newest results information integration description logic capturing expressiveness entity relationship models described calvanese 
summary agent oriented problem solving analyzed formal knowledge representation point view 
interschema knowledge central agent called broker transforms inference problems delegated agents preserving sound inference algorithm 
discussed examples involving instance retrieval instance checking 
example motivation delegation employ agent uses expressive description logic program agent inferences computed efficiently 
second example agent description logic different expressive power employed dealing instance checking problem solved knowledge represented broker 
seen combined description logic undecidable general 
abstraction abox refinement query concept proposed section yields sound inference algorithm delegation inferences lost abstraction general refinement specific 
knowledge broker close approximation knowledge represented consulted specialist 
examples indicate alcn hr suited representation language broker 
hand logic expressive approximate knowledge agents 
hand race exists implementation guarantees quite encouraging performance practical reasoning 
deficiencies approach indicated 
combined language alcn hr alcrp decidable general possible check input abox inconsistent combined knowledge agent system 
cases query answering useful due inconsistent input abox remain undetected 
specialist agent conclude abstracted abox inconsistent cases abstraction consistent original 
idea circumvent problem cases compute refinement input abox broker refuse query answering specialist acquaintances prove refinement inconsistent 
details approach investigated 
implicit knowledge plays important role agent communication expressive representation languages exists canonical form format knowledge interchange 
comparisons different representation structures computed semantical basis 
chapter discusses examples context spatioterminological reasoning 
apparently key adequate domain knowledge modeling definition ontological notions class subclass part relations 
representation formalisms capture semantics spatial object required order avoid unintended models 
topological relations discussed chapter part story 
obviously reasoning facilities spatial knowledge augmented reasoning techniques temporal knowledge see section account context spatiotemporal terminological reasoning 
combination spatial temporal terminological reasoning adequately exploited agent oriented scenario investigated chapter subject research 
information retrieval probabilistic description logics previous section seen task similarity information retrieval split subtasks direct types finite set individuals computed yielding finite set concepts 
lcs concepts computed 
determining instances lcs concept retrieval concept 
purpose similarity information retrieval task fulfilled known realization inference service 
third subtask determining instances lcs concept accomplished instance retrieval inference service knowledge representation system 
certain cases computing lcs set concepts yields general concept 
consequence large set information items retrieved resulting information flood items displayed 
ranking needed define new operator computing commonalities concepts 
chapter pursue second approach define lcs operator takes additional domain knowledge account 
main contribution chapter proposal probabilistic lcs operation probabilistic extension dl aln introduced koller knowledge representation system classic 
probabilistic lcs operator classic ability model degree overlap concepts 
probabilistic lcs operator investigate retrieval approach known information retrieval techniques integrated formally investigated inference services dls 
preliminaries classic despite name classic support concept operators supported classic system 
description logic classic aln negation concept names value restrictions number restrictions nr nr 
assume nr abbreviation nr nr 
semantics concepts terms interpretation way specified 
note expressible respectively 
definitions required algorithms 
definition depth depth concept recursively defined follows nr nr depth 
depth depth 
note contrast usual definitions concept depth define depth number restrictions 
definition canonical form 
cm concepts 
rm set roles occurring toplevel nesting depth 
cm 
ci canonical form iff ci ini ir ji 
ik atomic concept negated atomic concept atomic concept appearing rj rj rj canonical form 
easy see concept transformed equivalent concept canonical form linear time 
example shows concept computed lcs general useful retrieval concept 
sports tool st sports broadcast sb team sports broadcast tsb individual sports broadcast isb basketball football fb tennis tr atomic concepts sports tool atomic role basketball broadcast bb team sports broadcast sports tool sports tool basketball football broadcast fb team sports broadcast sports tool sports tool football tennis broadcast tb individual sports broadcast sports tool sports tool tennis concepts 
subsequently concept abbreviations brackets 
consider user interested tv broadcasts similar fb bb 
computing lcs fb bb result useful retrieval concept tsb sports tool sports tool st user interests expressed fb tb 
lcs computation yields retrieval concept sb sports tool sports tool st denoting set sports broadcasts sports tool 
general concept retrieval concept result large amount tv broadcasts acceptable part user 
suitable result allow tsb sports tool sports tool st isb sports tool sports tool st alternative retrieval concepts 
plausible davis cup matches instance teams tennis players compete 
intuition non empty overlap concepts tsb isb adequately quantified aln 
classic comes play 
order model degree overlap concepts probabilities knowledge representation system classic introduced koller 
dl underlying classic probabilistic extension aln augmented functional roles attributes 
goals classic compute probabilistic subsumption relationships form denoting probability individual instance instance case write 
order fully describe concept atomic concept components properties number restrictions universal role quantifications need described 
set probabilistic classes classes introduced describing probability distribution properties individuals conditioned knowledge individuals occur right hand side role 
class represented bayesian network classes pis root class 
root class describes distribution individuals classes describe distribution role successors assuming independence distinct individuals 
bayesian networks modeled directed acyclic graphs nodes represent atomic concepts number restrictions number class role successors drawn pc 
addition classic introduce extra nodes negations atomic concepts 
dependencies model conditional probabilities modeled edges network 
instance individual state probability individual instance isb condition instance sb 
range variables node representing atomic negated atomic concept true false number subset 
order guarantee termination inference algorithm computing subset finite 
number number tool basketball st st class sports tools st basketball st st st football st football st st st pc tool sts sbs st st sports tool st sports broad 
st sports tool st sb sb st st tennis st number tool st st tennis st st st st pc tool sts sbs st st st class sports broadcasts individual sports broadcast sb sb st team sports broadcast sb isb classic tbox sports broadcasts 
sb isb sb isb sb isb role successors role bounded 
function bound indicates maximum number role successors range pc node set classes indicating classes successors drawn 
reason introducing special nodes negations atomic concepts extension enables evaluate expressions form necessary property subsequently 
order demonstrate advantages probabilistic lcs operator create classic tbox overlapping concepts 
shows knowledge base sports broadcasts enriched probability information 
instance stated broadcast considered team sports tsb probability broadcast sports sb individual sports isb 
classes represented 
concept sports broadcasts root class role successors role drawn class sports tools 
concept probability pp individual instance computed standard inference algorithm bayesian networks 
example probability pp tsb sports tool sports tool computed setting nodes tsb true number sports tool pc sports tool sts 
bayesian network propagation yield value 
formalism computing expressions form possible express degree overlap probability 
probabilistic description logic summarized section possible define probabilistic lcs operator takes account degree overlap concepts 
probabilistic extension example retrieval intuitively concepts 
cm key idea allow concepts candidates probabilistic common subsumer 
cm non empty overlap 
cm 
order keep set candidates finite consider concepts depth larger max depth ci 

viewpoint information retrieval severe restriction practical applications deeply nested concepts usually relevant individuals instances concept fb sports tool sports tool example 
definition 
cm aln concepts root class classic tbox 
define set concept candidates 
cm 
cm pp pp cm depth max depth ci 

definition induces observation 
proposition 
cm aln concepts 
worst case cardinality 
cm exponential proof 
classic tbox 
cm atomic concepts 
ci cj bound 
cm exponential function threshold equal number candidates exponential worst case practice value chosen runtimes acceptable 
step want measure effectiveness certain candidate retrieval 
helpful able express probability individual instance concept disjunction 
language operator contained aln definition essentially taken rohatgi 
definition 
cm aln concepts 
define cm 
ck ck ck ck 
cm 
ck ck noted definition extend syntax underlying dl 
proposition 
cm concepts 
computing cm exponential proof obvious omitted 
retrieval environments customary real numbers recall precision 
values indicate quality concept function appropriate 
measures qualities potential compared 
comparison formalized notion dominance triples re 
cm pe 
cm re 
cm pe 
cm 
definition recall 
cm aln concepts 
define recall 
cm re 
cm cm cm definition larger recall measure concept specific probabilistic subsumption 
cm 
concept perfect recall yielded iff re 
cm 
example candidate atomic concept re 
definition crisp lcs concept expression necessarily need subsume 
cm completely order candidate 
motivates precision measure 
definition precision 
cm aln concepts 
define precision 
cm pe 
cm cm cm cm scenario concepts illustrating meaning recall precision 
precision measures probability randomly chosen individual instance ci 
instance candidate consequence definition lcs 
cm pe 
cm 
illustrates meaning measures concepts represented areas space 
recall re corresponds ratio size hatched area size 
precision pe ratio size size union appropriate values see re smaller re pe larger pe proposition 
cm aln concepts 
computing re 
cm pe 
cm takes time exponential length 
cm 
proof 
cm cm cm claim follows proposition 
considerations define set concepts 
cm set triples component concept 
cm components recall precision 
concrete application user able specify minimum values measures willing accept 
example specify recall preventing obtaining general concepts restricting amount retrieved data 
notion dominance candidates define set probabilistic common subsumers 
definition dominance 
cm aln concepts 
re 
cm pe 
cm dominates re 
cm pe 
cm iff re 
cm re 
cm pe 
cm pe 
cm 
definition probabilistic common subsumers 
cm aln concepts 
define set probabilistic common subsumers 
cm lcs 
cm re 
cm pe 
cm 
cm ir ir re 
cm pe 
cm re 
cm pe 
cm dominates re 
cm pe 
cm 
lcs 
cm called minimal iff re 
cm pe 
cm re 
cm pe 
cm lcs 
cm definition formalize ideas conditioned general case concepts 
defining lcs 
cm consider concepts non empty overlap 
cm 
accept triples best quality measures accept dominating triples lcs 
cm 
definition derive statement 
proposition set lcs 
cm properties lcs 
cm finite 
ii minimality re 
cm pe 
cm lcs 
cm 
ci re 
cm pe 
cm re 
cm re 
cm pe 
cm pe 
cm depth depth 
proof 
obvious maximum depth concepts lcs 
cm limited maximum depth 
cm number concept components 
cm finite ensuring number candidates finite 
lcs 
cm finite 
re 
cm pe 
cm lcs 
cm fact ci 
follows immediately definition 
cm 
re 
cm pe 
cm re 
cm re 
cm pe 
cm pe 
cm depth depth follows lcs 
cm contains dominating triples re 
cm pe 
cm depth max depth ci 

minimal set lcs 
cm computed steps set concepts non empty overlap 
cm computed 
proposition states necessary criterion corresponding algorithm terminate set concepts non empty overlap ci finite 
concept set compute parameters re 
cm pe 
cm build set dominant triples lcs 
cm 
proposition ii guarantees relevant retrieval concept better recall precision corresponding measures triples lcs 
cm 
minimal set lcs 
cm determined 
done successively eliminating triple re 
cm pe 
cm lcs 
cm long condition holds re 
cm pe 
cm lcs 
cm re 
cm pe 
cm lcs 
cm necessary equivalence test performed structural comparisons involved concepts canonical form 
general minimal lcs 
cm unique rule stating triple eliminate case triples equivalent concepts 
similarity information retrieval application problem sets instances equivalent concepts equal 
procedure computes set candidates concepts 
cm tbox bayesian network bn 
step atomic concepts negated atomic concepts bayesian network collected set non empty overlap 
cm 
computing concept candidates example compute concept candidate fb tb get sb tsb isb 
secondly build set conjunctions concepts nonempty overlapping 
cm including ones consisting conjunct 
case yield sb tsb isb sb tsb sb isb isb tsb sb tsb isb 
part algorithm collect number restrictions having non empty overlap 
cm set 
maximum number role successors bounded guarantee finiteness 
abbreviation sports tool abbreviation sports tool sports tool 
example 
subsequently roles ri quantifications occurring 
cm involving ri add concepts non empty overlap ri quantifiers 
algorithm 
example compute st 
inx conjunctions number restrictions involving role concept overlap quantifiers 
abbreviation sports tool st abbreviation sports tool st example 
collect conjunctions elements occurring roles conjunction non empty overlap 
cm 
example role get 
re sults conjunctions atomic negated atomic concepts ones conjunctions number restrictions quantifications combined returned algorithm 
example consists concepts list ones unique equivalence 
sb tsb isb tsb isb sb tsb isb tsb isb sb tsb isb tsb isb desired 
theorem concepts 
cm bayesian network bn representing classic tbox algorithm compute concept candidates returns set 
cm 
proof 
give sketch proof 
algorithm compute concept candidates terminates maximum number iterations bounded maximum depth 
cm 
sound output concept non empty overlap 
cm 
complete algorithm recursively checks possible concepts resulting concept forming operators aln nonempty overlap 
cm 
set concept candidates computed algorithm easily transformed set pairs concepts equivalent 
additional algorithm transforming lcs 
cm minimal lcs 
cm necessary 
recall precision determined candidate means formulae definitions 
done straightforwardly algorithms concepts 
cm input parameters returning re 
cm pe 
cm respectively 
set lcs 
cm contains triples quality measures dominate triples 
algorithm computes largest subset dominant triples re 
cm pe 
cm 
en ren 
cm pen 
cm 
example get lcs fb tb sb sb tsb tsb isb isb 
result get possible retrieval concepts 
sb crisp lcs fb tb 
naturally concept precision definition lcs fb tb concept completely subsumes fb tb 
alternatively result suggests tsb isb retrieval concepts 
concepts better recall measure retrieval results smaller set information items 
hand tsb isb worse precision measure sb probability meeting individual incorporate commonalities represented concepts fb tb higher 
concepts involving quality measures ones involving reason classic tbox follows number sports tool need consider 
procedure compute concept candidates 
cm bn initialization 
max depth depth cm literals box insert 
ci dk insert 
ci roles 
cm number restrictions 
cm insert lr ur bound 
cd quantification 
cm relevant classes 
cd 
cm insert results compute concept candidates 
insert dk insert 
ci insert 
ci return procedure compute minimal 
en rn pn lcs 
cm sort 
en rn pn pi ton eliminate lcs 
cm ri pi 
theorem 
cm aln concepts 
worst case computing lcs 
cm takes time exponential proof 
result follows proposition computing set candidates 
cm subtask computing lcs 
cm 
propositions show sources complexity inference task 
due subterms cm cm occurring definitions computation precision recall measure take time exponential number computation set candidates takes time exponential number concepts 
practice exponential behavior computation comes effect knowledge bases overlapping concepts 
building tbox number concept overlaps kept small threshold set appropriately 
summary section contributed problem similarity information retrieval basis dl aln 
shown certain cases computation commonalities crisp lcs operation yields general retrieval concepts result information flood retrieval context 
order circumvent problem introduced probabilistic lcs probabilistic extension dl aln 
proved retrieval concepts provided operation sense optimal alternative retrieval concepts computed crisp lcs operation 
demonstrating performances operator example showed meaningful retrieval results achieved operator 
retrieval approach integrated known information retrieval techniques formally investigated inference services dls 
shown information system scenario possible successfully apply theory integrating probabilistic logical representation formalisms probabilistic abstraction operator information retrieval applications implemented see details implementation 
chapter discussed application description logics information processing tasks different areas 
applications range verification specifications telecommunication systems support development large ontologies bio informatics domain deductive information systems agent oriented retrieval scenario 
description logics constitute common basis projects lively area research 
conclude assessment problems solved habilitation thesis apparent extensions 
assessment modeling application problems inference problems tableaux calculi expressive description logics alcn hr alcn hr alcrp developed 
development extended new optimization techniques empirical evaluation dl system race shows significant practical problems represented inference problems 
emphasized importance sound complete terminating tbox abox reasoning solving subproblems applications 
advantage solid theoretical foundation new applications extended developed effort 
research summarized habilitation thesis complements approaches exploring description logic landscape complexity theory point view donini 
detailed overviews theoretical description logic research baader baader sattler repeated 
race system powerful representation inference system developed 
practical inspired landmark results optimization strategies horrocks 
architecture race tailored application problems tboxes aboxes provides new optimization techniques larger application projects description logic systems sound complete algorithms 
empirical investigations indicate price pay modeling expressive languages 
specific combinatorial problems encoded consistency tests certain kinds logical formulae specialized inference systems slightly faster race problems formalized modal logic km see giunchiglia 
instance number restrictions come price complex clash tests slow performance race pure propositional modal logic inference problems quite bit race adapts clash testing algorithms language constructs certain problem 
race fastest systems available today development optimized algorithms active area research newer versions race support optimization techniques powerful language features 
integration new features inverse roles race architecture possible complex safely integrate new features optimized inference algorithms 
currently kind gap proven calculus level implemented order achieve adequate performance optimized search caching strategies 
part considers spatioterminological reasoning 
important combination spatial terminological reasoning theory proposed alcrp rcc 
authors published complexity analyses lutz developed prototypical implementation 
exist optimized implementation alcrp alc comparable performance race alcn hr 
results race provide basis developing adequate algorithms alcrp practically implemented 
results topic discussed haarslev 
aspects spatial reasoning captured alcrp rcc step 
order achieve soundness completeness termination abox consistency algorithm syntactic restrictions imposed formulae alcrp knowledge bases 
furthermore dl part alcrp doesnot offer number restrictions role hierarchies transitive roles introduced concrete domains 
important insight interesting concrete domains provide expressivity syntactic restrictions necessary ensure termination 
application examples discussed thesis demonstrate results pro vide foundation information systems answer queries distributed scenario reasoning conceptual spatial information 
outlook emphasized qualitative spatial relations rcc calculus taken example dealing aspects spatial reasoning 
topological relations kind knowledge relevant spatial reasoning 
instance reasoning shape position orientation investigated context conceptual reasoning description logics 
addition integration quantitative knowledge spatioterminological reasoning important area research 
generalization spatioterminological default reasoning investigated extending description logics autoepistemic operators donini rosati 
operators integrity conditions restrictions data model represented world expressed 
investigation operators context spatioterminological default reasoning lead fruitful results 
idea defining roles concrete domain predicates alcrp concrete domain consistency tester generalized 
external reasoner concrete domain possible reason properties relations description logic formalism 
words interesting investigate ways integrate semantics spatial relations semantics description logic formalism 
research just started wessel 
new language called extends alc role axioms instance meaning rcc relations directly provided specifying role axioms turn directly correspond composition table rcc 
language useful enhanced reasoning conceptual knowledge wessel 
explained small example 
consider man brother sister turn sister daughter computer science student 
claim computer science students obvious wrong 
consider alc concept term man brother sister sister daughter computer science student computer science student representing relationships roles inherent inconsistency concept detected 
role axioms required order derive inconsistency operator denotes role composition 
brother sister sister sister daughter daughter sister daughter sister sister sister decidable currently open research question 
availability expressive description logic inference systems possible extend development uml unified modeling language page jones 
description logics possible define semantics parts uml uml presentation communication purposes design phase software project optimized inference system solving problems code algorithms written manually 
furthermore possible dl system verifying uml state space models 
investigations verifying state space models uml model checking techniques described lilius lilius lilius 
argued logical approach pursued thesis provides foundation information systems inference components 
aboxes represent information specific objects certain domain 
long aboxes tboxes kept main memory spectrum possible applications somewhat limited 
interesting investigate algorithms implementing abox persistency transactions rollback 
noted revision context logical representation formalism research topic 
context spatial knowledge revision retraction definitely exciting areas research 
sum years research field covered habilitation thesis seen contributions different groups perspectives 
application examples thesis demonstrate results important knowledge representation computer science general 
intention field develop representation medium modeling way automatic inferences supported application sub problems automatically solved invoking inference service 
insights gained developing optimization algorithms convinced services provided automatic inference systems hardly provided ad hoc software development reasonable amount time necessary reliability 
key successful development applications description logics inference services particular data structures storing information 
expressive description logics optimized inference systems necessary prerequisite success practical context 
formal inference systems general description logics particular called changing discipline 
previously gap theoretical results implemented modeling inference systems 
implemented systems incomplete algorithms supported weak representation languages 
optimization techniques today clear theoretical results decidability complexity expressive description logics directly relevant practical 
achieved learned 
hope stimulates new research results near 
bibliography abiteboul hull vianu 

foundation databases 
addison wesley 
burstein 

knowledge editing environment 
int 
man machine studies 
achilles hollunder 

kris knowledge representation inference system user guide 
technical report deutsches forschungszentrum nstliche intelligenz gmbh document 
aiello doyle shapiro editors 
fifth international conference principles knowledge representation cambridge mass nov 
allen 

maintaining knowledge temporal intervals 
communications acm 
allen 

rhet system 
acm sigart bulletin 


sb dealing sets efficiently 
proceedings ecai pages 
antoniou 

nonmonotonic reasoning 
mit press 
bouma de rijke 

description logics feature interaction 
lambrix 
baader 

terminological cycles kl knowledge representation languages 
proceedings eighth national conference artificial intelligence aaai pages boston usa 
baader 

augmenting concept languages transitive closure roles alternative terminological cycles 
proceedings th international joint conference artificial intelligence ijcai pages sydney australia 
baader 

logic knowledge representation 
wooldridge veloso editors artificial intelligence today trends developments number lecture notes computer science pages 
springer verlag 
baader buchheit hollunder 

cardinality restrictions concepts 
artificial intelligence 
baader franconi hollunder nebel 

empirical analysis optimization techniques terminological representation systems making kris get move 
applied artificial intelligence 
special issue knowledge base management 
baader hanschke 

scheme integrating concrete domains concept languages 
twelfth international conference artificial intelligence harbour sydney australia aug pages 
baader hanschke 

scheme integrating concrete domains concept languages 
technical report dfki rr german center ai dfki 
baader hanschke 

extensions concept languages mechanical engineering application 
ohlbach editor proceedings advances artificial intelligence th german conference artificial intelligence pages 
springer verlag berlin 
baader hollunder 

kris knowledge representation inference system system description 
dfki technical memo tm deutsches forschungszentrum nstliche intelligenz kaiserslautern 
baader hollunder 

kris knowledge representation inference system system description 
acm sigart bulletin 
published baader hollunder 
baader hollunder 

terminological knowledge representation system complete inference algorithms 
proceedings international workshop processing declarative knowledge volume lecture notes computer science pages kaiserslautern germany 
springer verlag 
baader hollunder 

embedding defaults terminological knowledge representation formalisms 
nebel pages 
baader hollunder 

prefer specific defaults terminological default logic 
proc 
ijcai pages 
baader hollunder 

embedding defaults terminological representation systems 
automated reasoning 
baader hollunder 

priorities defaults prerequisites application treating specificity terminological default logic 
automated reasoning 
baader hollunder nebel franconi 

empirical analysis optimization techniques terminological representation systems making kris get move 
proceedings third international conference principles knowledge representation reasoning kr pages boston usa 
baader sters 

computing common subsumer specific concept presence cyclic aln concept descriptions 
herzog nter editors proceedings nd annual german conference artificial intelligence ki volume lecture notes computer science pages bremen germany 
springer verlag 
baader sters 

matching description logics existential restrictions 
cohn giunchiglia selman editors proceedings seventh international conference knowledge representation reasoning kr pages san francisco ca 
morgan kaufmann publishers 
baader sters molitor 

rewriting concepts terminologies 
cohn giunchiglia selman editors proceedings seventh international conference knowledge representation reasoning kr pages san francisco ca 
morgan kaufmann publishers 
baader mcguinness nardi patel schneider editors 
description logic handbook 
cambridge university press 
baader molitor 

building structuring description logic knowledge bases common subsumers concept analysis 
proceedings th international conference conceptual structures iccs lecture notes artificial intelligence 
springer verlag 
baader sattler 

description logics concrete domains aggregation 
prade editor proceedings th european conference artificial intelligence ecai pages 
john wiley sons baader sattler 

expressive number restrictions description logics 
journal logic computation 
baader sattler 

tableau algorithms description logics 
dyckhoff editor proceedings international conference automated reasoning tableaux related methods tableaux volume lecture notes artificial intelligence pages st andrews scotland uk 
springer verlag 
baader schlechta 

semantics open normal defaults modified preferential approach 
proceedings european conference symbolic quantitative approaches reasoning und uncertainty ecsqaru volume lecture notes computer science pages granada spain 
springer verlag new york 
baader editor 
proceedings international workshop description logics dl august august aachen germany 
cheng 

refining concepts description logics 
baader pages 


funktionen 
springer verlag berlin 
bennett 

spatial reasoning propositional logics 
doyle pages 
bennett cohn 

composition table provide complete tractable proof procedure relational constraint language 
proceedings ijcai workshop spatial temporal reasoning 
borgida 

description logics data management 
ieee transactions knowledge data engineering 
borgida brachman mcguinness resnick 

classic structural data model objects 
proceedings acm sigmod international conference management data portland oregon 
borgida brachman 

loading data description reasoners 
proc 
acm sigmod conf 
data management pages washington borgida isbell mcguinness 

reasoning black boxes handling test concepts classic 
padgham editor proceedings international workshop description logics nov cambridge massachusetts pages 
aaai press menlo park 
technical report ws 
borgida mcguinness 

asking queries frames 
aiello pages 
borgida patel schneider 

semantics complete algorithm subsumption classic description logic 
journal artificial intelligence research 
brachman 

concept structural foundations semantic networks 
international journal man machine studies 
brachman 

epistemological status semantic networks 
findler editor associative networks representation knowledge computers pages 
academic press new york 
brachman 

isn ieee computer 
brachman 

trees defaults definitions knowledge representation 
ai magazine 
brachman 

reducing classic practice knowledge representation theory meets reality 
principles knowledge representation reasoning third international conference cambridge mass oct pages 
brachman fikes levesque 

krypton functional approach knowledge representation 
ieee computer 
revised version appears brachman levesque 
brachman fikes levesque 

krypton integrating terminology assertion 
proc 
third national conference artificial intelligence aaai pages 
brachman gilbert levesque 

essential hybrid reasoning system knowledge symbol level accounts krypton 
proc 
ninth international conference artificial intelligence ijcai los angeles ca 
morgan kaufmann san mateo 
brachman levesque 

tractability subsumption frame description languages 
proc 
fourth national conference artificial intelligence aaai pages 
brachman levesque editors 
readings knowledge representation 
morgan kaufmann los altos 
brachman levesque reiter editors 
proceedings international conference principles knowledge representation reasoning kr toronto canada 
morgan kaufmann san mateo 
brachman mcguinness patel schneider resnick borgida 

living classic kl language 
sowa pages 
brachman schmolze 

overview kl knowledge representation system 
cognitive science pages 
franconi tessaris 

implementing testing expressive description logics 
proceedings dl international workshop description logics pages rome italy 
brill 

loom manual version 
marina del rey 
buchheit donini schaerf 

decidable reasoning terminological knowledge representation systems 
journal artificial intelligence research 
buchheit donini schaerf 

decidable reasoning terminological knowledge representation systems 
artificial intelligence research 
buchheit klein nutt 

configuration model construction constructive problem solving approach 
sudweeks gero editors proc 
th international conference artificial intelligence design lausanne switzerland 
kluwer dordrecht 
buchheit klein nutt 

constructive problem solving model construction approach configuration 
technical report dfki tm german center ai dfki 
cadoli 

tractable reasoning artificial intelligence 
lecture notes artificial intelligence 
springer verlag berlin 
calvanese giacomo lenzerini nardi rosati 

description logic framework information integration 
cohn pages 
cardiff catarci santucci 

exploitation interschema knowledge multidatabase system 
proc 
th krdb workshop athens greece 
sunsite informatik rwth aachen de publications ceur ws vol 
catarci lenzerini 

representing interschema cooperative information systems 
int 
journal intelligent cooperative information systems 
johnson 

quantifier elimination cylindrical algebraic decomposition 
springer verlag 
chomicki saake 

logics databases information systems 
kluwer academic publishers 
clarke kurshan 

computer aided verification 
ieee spectrum 
cohen borgida hirsh 

computing common subsumers description logics 
proceedings aaai pages 
aaai press mit press 
cohn bennett gotts 

representing reasoning qualitative spatial relations 
stock pages 
cohn giunchiglia selman editors 
proceedings seventh international conference principles knowledge representation reasoning kr breckenridge colorado usa 
cohn schubert shapiro editors 
proceedings sixth international conference principles knowledge representation reasoning kr trento italy june 


modellierung technischer systeme der 
chapter 
nter strecker editors 
das ein und dom nen volume 
springer verlag 
davis logemann loveland 

machine program theorem proving 
communication acm 
de giacomo lenzerini 

tbox abox reasoning expressive description logics 
aiello 
donini lenzerini nardi nutt 

complexity concept languages 
information computation 
donini lenzerini nardi nutt schaerf 

epistemic operator description logics 
artificial intelligence 
donini lenzerini nardi schaerf 

reasoning description logics 
brewka editor principles knowledge representation 
csli publications 
donini lenzerini nardi nutt 

complexity concept languages 
proceedings second international conference principles knowledge representation reasoning kr pages 
morgan kaufmann los altos 
detailed version appeared dfki research report rr kaiserslautern 
donini lenzerini nardi nutt 

tractable concept languages 
proceedings th international joint conference artificial intelligence ijcai pages 
morgan kaufmann los altos 
detailed version appeared dfki research report rr kaiserslautern 
donini lenzerini nardi nutt schaerf 

adding epistemic operators concept languages 
nebel pages 
donini lenzerini nardi nutt schaerf 

queries rules definitions epistemic sentences concept languages 
lakemeyer nebel editors theoretical foundations knowledge representation reasoning lecture notes artificial intelligence lnai pages 
springer verlag 
donini nardi rosati 

autoepistemic description logics 
proceedings fifteenth international joint conference artificial intelligence ijcai pages 
doyle sandewall torasso editors 
fourth international conference principles knowledge representation bonn germany may 


backtracking am beispiel german 
document deutsches forschungszentrum nstliche intelligence germany 


predication calculus qualitative spatial representations 
freksa mark editors proc 
international conference spatial information theory cosit germany pages 
springer verlag 
fensel erdmann studer 

ontobroker high idea 
proceedings th international flairs conference flairs island florida 
fikes 


schmolze brachman 
published bbn research report bolt beranek newman june 
fischer 

integration temporal operators terminological representation system 
technical report technical university berlin computer science department project kit kit report 
fitting 

order logic automated theorem proving 
springer verlag berlin 
frank 

spatial ontology 
stock pages 
frank 

different types time gis 
egenhofer golledge editors spatial temporal reasoning geographic information systems pages 
oxford university press 
freeman 

improvements propositional satisfiability search algorithms 
phd thesis university pennsylvania computer information science 
garcia molina papakonstantinou quass rajaraman sagiv ullman vassalos widom 

tsimmis approach mediation data models languages 
journal intelligent information systems 
genesereth nilsson 

logical foundations artificial intelligence 
morgan kaufmann 
gerevini 

reasoning time actions artificial intelligence major issues 
stock pages 
ginsberg 

dynamic backtracking 
journal artificial intelligence research 
ginsberg mcallester 

gsat dynamic backtracking 
doyle pages 
giunchiglia giunchiglia 

sat dlp ta comparative analysis 
lambrix pages 
published ceur workshop proceedings volume sunsite informatik rwth aachen de publications ceur ws vol 
giunchiglia 

subset matching size bounded cache satisfiability modal logics 
proceedings international conference tableaux pages 
springer verlag 
giunchiglia sebastiani 

sat decision procedure alc 
aiello pages 
nter editor 
ergebnisse aus dem 
infix sankt augustin 
haarslev 

fully formalized theory describing visual notations 
marriott meyer editors visual language theory pages 
springer verlag berlin 
haarslev horrocks ller patel schneider 

dl benchmark suite 
available url www informatik de moeller dl benchmark suite html 
haarslev lutz ller 

foundations spatioterminological reasoning description logics 
cohn pages 
haarslev lutz ller 

description logic concrete domains role forming predicate operator 
journal logic computation 
haarslev ller 

qualitative spatial reasoner progress report 
editor th international workshop qualitative reasoning italy june istituto di numerica pavia italy pages 
haarslev ller 

spatioterminological reasoning subsumption geometrical inferences 
rousset pages 
haarslev ller 

applying alc abox consistency tester modal logic sat problems 
murray editor proceedings international conference automatic reasoning analytic tableaux related methods tableaux saratoga springs ny usa number lecture notes artificial intelligence pages 
springer verlag berlin 
haarslev ller 

empirical evaluation optimization strategies abox reasoning expressive description logics 
lambrix pages 
haarslev ller 

expressive abox reasoning number restrictions role hierarchies transitively closed roles 
technical report fbi hh university hamburg computer science department 
available url www informatik de haarslev publications report fbi ps gz 
haarslev ller 

race system description 
lambrix pages 
haarslev ller 

race system download page 
available url www informatik uni hamburg de race 
haarslev ller 

consistency testing race experience 
proceedings international conference tableaux pages 
springer verlag 
haarslev ller 

expressive abox reasoning number restrictions role transitively closed roles 
cohn 
haarslev ller 

high performance reasoning large knowledge bases 
baader pages 
haarslev ller 

optimizing tbox abox reasoning pseudo models 
baader pages 
haarslev ller schr der 

combining spatial terminological reasoning 
nebel fischer editors ki advances artificial intelligence proc 
th german annual conference artificial intelligence saarbr cken sept volume lecture notes artificial intelligence pages 
springer verlag berlin 
haarslev ller 

race user guide manual version 
technical report fbi hh university hamburg computer science department 
available url www informatik uni hamburg de haarslev publications report fbi ps gz 
haarslev ller wessel 

description logic alcn hr extended concrete domains 
technical report fbi hh university hamburg computer science department 
available url www informatik uni hamburg de haarslev publications report fbi ps gz 
haarslev ller wessel 

diagrammatic representation reasoning chapter visual spatial query languages semantics description logic 
springer verlag 
halpern shoham 

propositional model logic time intervals 
journal association computing machinery 
hanschke 

declarative integration terminological constraint data driven goal directed reasoning 
technical report dfki rr german center ai dfki 
hayes 

defense logic 
proc 
international joint conference artificial intelligence pages 
hayes 

logic frames 
editor frame conceptions text understanding pages 
de gruyter berlin 
reprinted brachman levesque 
hoffmann hler 

new method query index sets 
proceedings sixteenth international joint conference artificial intelligence ijcai pages 
morgan kaufmann publishers 
hollunder 

algorithmic foundations terminological knowledge representation systems 
phd thesis university saarbr cken department computer science 
hollunder baader 

qualifying number restrictions concept languages 
allen fikes sandewall editors second international conference principles knowledge representation cambridge mass april pages 
detailed version appeared dfki research report rr kaiserslautern 
hollunder 

kris manual 
technical report deutsches forschungszentrum nstliche intelligenz gmbh 
hollunder nutt 

subsumption algorithms concept languages 
proc 
th european conference artificial intelligence ecai stockholm sweden 
extended version published dfki research report dfki rr 
horrocks 

optimising tableaux decision procedures description logics 
phd thesis university manchester 
horrocks 

expressive description logic fact fiction 
cohn pages 
horrocks 

fact 
lambrix pages 
published ceur workshop proceedings volume sunsite informatik rwth aachen de publications ceur ws vol 
horrocks 

benchmark analysis fact 
proceedings international conference tableaux pages 
springer verlag 
horrocks patel schneider 

dl systems comparison 
proceedings dl international workshop description logics pages trento italy 
horrocks patel schneider 

fact dlp automated reasoning analytic tableaux related methods 
proceedings international conference tableaux pages 
horrocks patel schneider 

optimising propositional modal satisfiability description logic subsumption 
artificial intelligence symbolic computation pages 
horrocks patel schneider 

optimising description logic subsumption 
journal logic computation 
horrocks sattler 

description logic transitive inverse roles role hierarchies 
journal logic computation 
horrocks sattler tessaris tobies 

query containment dlr abox 
report theoretical computer science rwth aachen germany 
see www lti informatik de forschung reports html 
horrocks sattler tobies 

practical reasoning expressive description logics 
ganzinger mcallester voronkov editors proceedings th international conference logic programming automated reasoning lpar number lecture notes artificial intelligence pages 
springer verlag 
horrocks sattler tobies 

reasoning individuals description logic shiq 
editor proceedings th international conference automated deduction cade lecture notes computer science germany 
springer verlag 
horrocks tessaris 

answering conjunctive queries dl aboxes preliminary report 
baader pages 
horrocks tobies 

reasoning axioms theory practice 
cohn giunchiglia selman editors principles knowledge representation reasoning proceedings seventh international conference kr pages san francisco ca 
morgan kaufmann publishers 
israel brachman 

remarks semantics representation languages 
brodie mylopoulos schmidt editors conceptual modeling perspectives artificial intelligence databases programming languages 
springer verlag new york 
bates robins 

developments 
proc 
fifth national conference artificial intelligence aaai pages 


sb graph user manual 
technical report university saarland germany computer science department sfb memo nr 



sb graph 
technical report university saarland germany computer science department sfb memo nr 

german 


durch die berechnung von einer german 
diploma thesis diplomarbeit 
kashyap sheth 

semantic heterogeneity global information systems role metadata context ontologies 
cooperative information systems trends directions 
academic press 
katoen 

concept algorithms tools model checking 
des mathematische und informatik vol 
number 
kautz ladkin 

integrating metric qualitative temporal reasoning 
proc 
aaai pages anaheim ca 
kietz morik 

polynomial approach constructive induction structural knowledge 
machine learning 
kindermann 

retraction object descriptions back 
technical report technical university berlin computer science department kit project group kit report 
kindermann quantz 

implementation back system version 
technical report technical university berlin computer science department kit project group kit report 
kindermann randi 

object recognition retrieval back system 
technical report technical university berlin computer science department kit project group kit report 
klusch 

cooperative information agents internet german 
phd thesis university kiel 
kobsa 

experiences sb knowledge representation workbench natural language applications 
acm sigart bulletin 
kobsa 

utilizing knowledge components sb knowledge representation workbench 
sowa pages 
koller levy pfeffer 

classic tractable probabilistic description logic 
proc 
aaai pages providence rhode island 
kuper libkin paredaens 

constraint databases 
springer 
lambrix borgida lenzerini ller patel schneider editors 
proc 
international workshop description logics 
published ceur workshop proceedings volume sunsite informatik rwth aachen de publications ceur ws vol 
lambrix wahl 

default extension description logics intelligent search engine 
proc 
st hawaiian int 
conf 
system science 
lambrix editor 
proceedings international workshop description logics dl july august link ping sweden 
lenzerini schaerf 

concept languages query languages 
proceedings ninth national conference artificial intelligence aaai pages 
levy rajaraman ordille 

query answering algorithms information agents 
proceedings aaai th national conference artificial intelligence 
lilius 

production cell exercise formal verification uml model 
technical report turku centre computer science 
lilius 

semantics uml state machines 
technical report turku centre computer science 
lilius 

vuml tool verifying uml models 
technical report turku centre computer science 


kl classifier 
schmolze brachman 
published bbn research report bolt beranek newman june 
lutz 

representation topological information description logics german 
master thesis university hamburg computer science department 
lutz 

complexity reasoning concrete domains revised version 
report theoretical computer science rwth aachen germany 
see www lti informatik de forschung papers html 
lutz 

reasoning concrete domains 
dean editor proceedings sixteenth international joint conference artificial intelligence ijcai pages stockholm sweden 
morgan kaufmann publishers 
lutz haarslev ller 

concept language role forming predicate restrictions 
technical report fbi hh university hamburg computer science department 
lutz ller 

defined topological relations description logics 
rousset pages 
macgregor 

deductive pattern matcher 
proc 
seventh national conference artificial intelligence aaai pages 
macgregor 

evolving technology classification knowledge representation systems 
sowa pages 
macgregor 

inside loom description classifier 
acm sigart bulletin 
macgregor 

description classifier predicate calculus 
proc 
twelfth national conference artificial intelligence aaai pages 
macgregor bates 

loom knowledge representation language 
technical report university southern california information sciences institute marina del rey technical report isi rs 
macgregor brill 

recognition algorithms loom 
proc 
aaai conference artificial intelligence pages menlo park cambridge london 
aaai press mit press 
macgregor burstein 

description classifier enhance knowledge representation 
ieee expert 
ller 

content information retrieval computation common subsumers probabilistic description logic 
wache duschka fensel lenzerini rousset editors workshop intelligent information integration ecai pages brighton england 
technical report technologie zentrum informatik universit bremen 
ller 

computing probabilistic common subsumers description logics 
burgard cremers editors proceedings ki 
deutsche nstliche intelligenz pages 
springer verlag 
mark 

realization 
schmolze brachman 
published bbn research report bolt beranek newman june 


rep system overview 
acm sigart bulletin 


persistent store large shared knowledge bases 
ieee transactions knowledge data engineering 
mcallester 

reasoning utility package user manual 
technical report massachusetts institute technology artificial intelligence laboratory ai memo 
mccray nelson 

representation meaning umls 
methods information medicine 
mcguinness 

explaining reasoning description logics 
phd thesis graduate school new brunswick rutgers state university new jersey 
mcguinness borgida 

explaining subsumption description logics 
proc 
th international joint conference artificial intelligence ijcai montreal canada pages 
springer verlag new york 
mcguinness 

frontiers artificial intelligence applications chapter ontological issues knowledge enhanced search 
ios press washington dc 
sebastiani 

model information retrieval terminological logic 
proc 
acl sigir int 
conference research development information retrieval pittsburg pa pages 


relevance terminological logic information retrieval 
proceedings sigir pages 
meiri 

combining qualitative quantitative constraints temporal reasoning 
artificial intelligence 
minsky 

framework representing knowledge 
winston editor psychology computer vision pages 
mcgraw hill new york 
reprinted brachman levesque 
ller haarslev 

description logic systems 
baader 
ller haarslev lutz 

spatioterminological reasoning geometric inferences alcrp approach 
technical report fbi hh university hamburg computer science department 
ller haarslev neumann 

semantics information retrieval 
int 
conf 
information technology knowledge systems vienna budapest 
ller haarslev neumann 

expressive description logics agent information retrieval 
knowledge engineering agent technology 
ios press 
ller neumann wessel 

computer vision description logics progress 
proceedings integration speech image understanding corfu greece pages 
ieee computer society los alamitos 
ller wessel 

terminological default reasoning spatial information step 
freksa editor proc 
international conference spatial information theory cosit germany pages 
springer verlag 
ller wessel haarslev 

terminological default reasoning spatial information extended 
lambrix pages 
nebel 

computational complexity terminological reasoning back 
artificial intelligence 
nebel 

reasoning revision hybrid representation systems volume lecture notes artificial intelligence 
springer verlag berlin 
nebel 

terminological reasoning inherently intractable 
artificial intelligence 
nebel 

terminological cycles semantics computational properties 
sowa pages 
nebel 

computational properties qualitative spatial reasoning results 
brauer editors proceedings ki advances artificial intelligence th annual german conference artificial intelligence bielefeld germany sept volume lecture notes artificial intelligence pages 
springer verlag berlin 
nebel rich swartout editors 
proceedings third international conference principles knowledge representation reasoning kr 
morgan kaufmann 
nebel von luck 

issues integration balancing hybrid knowledge representation systems 
morik editor proceedings pages 
springer verlag berlin 
nebel von luck 

hybrid reasoning back 
ras saitta editors methodologies intelligent systems pages 
north holland 


inferences temporal object descriptions terminological representation system 
technical report technical university berlin computer science department project kit kit report 
newell 

knowledge level 
artificial intelligence 
padgham nebel 

combining classification nonmonotonic inheritance reasoning step 
ras komorowski editors methodologies intelligent systems ismis pages 
springer verlag 
padgham zhang 

terminological logic defaults 
proceedings thirteenth international joint conference artificial intelligence ijcai pages 
page jones 

fundamentals object oriented design uml 
addison wesley 
papazoglou 

cooperative information systems trends directions 
academic press 
patel schneider 

small beautiful knowledge representation 
proceedings ieee workshop principle knowledge systems denver revised extended version ai tech 
rept 
schlumberger palo alto research 
patel schneider 

valued semantics frame description languages 
proc 
fifth national conference artificial intelligence aaai pages 
patel schneider 

decidable logic knowledge representation 
phd thesis department computer science university toronto ontario canada 
available technical report 
patel schneider 

hybrid decidable logic knowledge representation system 
computational intelligence 
patel schneider 

valued semantics terminological logics 
artificial intelligence 
patel schneider 

undecidability subsumption 
artificial intelligence 
patel schneider 

performance dlp random modal formulae 
lambrix pages 
published ceur workshop proceedings volume sunsite informatik rwth aachen de publications ceur ws vol 
patel schneider mcguinness brachman resnick 

classic knowledge representation system guiding principles implementation rationale 
acm sigart bulletin 
patel schneider kobsa guarino macgregor mark nebel yen 

term subsumption languages knowledge representation 
ai magazine 
patel schneider swartout 

description logic knowledge representation system specification krss 
www db research com user papers krss spec ps 


overview 
acm sigart bulletin 
kindermann quantz 

back system revisited 
technical report technical university berlin computer science department kit project group kit report 
poole mackworth goebel 

computational intelligence 
oxford university press 
quantz bergmann kellner 

flex system 
technical report technical university berlin computer science department project kit vm kit report 
quantz royer 

preference semantics defaults terminological logics 
nebel pages 
quillian 

word concepts theory simulation basic semantic capabilities 
behavioral science 
reprinted brachman levesque 
quillian 

semantic memory 
minsky editor semantic information processing pages 
mit press cambridge mass randell cui cohn 

spatial logic regions connections 
nebel rich swartout editors principles knowledge representation reasoning cambridge mass oct pages 
morgan kaufman 
reiter 

logic default reasoning 
artificial intelligence 
renz 

canonical model region connection calculus 
cohn pages 
renz nebel 

complexity qualitative spatial reasoning maximal tractable fragment region connection calculus 
proceedings th international joint conference artificial intelligence ijcai pages 
resnick borgida brachman mcguinness patel schneider 

classic description manual common lisp implementation version 
technical report bell labs murray hill ny 
robins 

manual 
technical report university southern california los angeles information sciences institutes knowledge representation project 
rohatgi 

probability theory mathematical statistics 
wiley series probability mathematical statistics 
rosati 

autoepistemic description logics 
technical report phd thesis ix dipartimento di informatica sistemistica universita degli study di roma la sapienza 
rousset editor 
proceedings international workshop description logics dl sep gif sur france 
universite paris sud paris 
sattler 

concept language extended different kinds transitive roles 
rz lldobler editors 
deutsche nstliche intelligenz number lecture notes artificial intelligence pages 
springer verlag berlin 
schaerf 

query answering concept knowledge representation systems algorithms complexity semantic issues 
phd thesis dipartimento di informatica sistemistica universita di roma la sapienza salaria roma italy 
schank 

conceptual information processing 
north holland amsterdam 
schaub 

automation reasoning incomplete information semantic foundations efficient computation 
lecture notes artificial intelligence 
springer verlag berlin 
schild 

correspondence theory terminological logics preliminary report 
twelfth international conference artificial intelligence harbour sydney australia aug pages 
schild 

tense logical extension terminological logics 
technical report technical university berlin computer science department project kit kit report 
schild 

combining terminological logics tense logic 
damas editors progress artificial intelligence th portuguese conference ai volume lnai pages porto portugal 
springer verlag 
schmidt 

algebraic terminological representation 
technical report max planck institute computer science mpi report mpi 
schmidt 

subsumption kl undecidable 
brachman pages 
schmidt smolka 

attributive concept descriptions complements 
artificial intelligence 


temporal constraint handler 
technical report technical university berlin computer science department project kit kit report 


temporal terminological logic 
proc 
ninth national conference artificial intelligence aaai pages 


persistent maintenance object descriptions back 
technical report technical university berlin computer science department kit project group kit report 
schmolze 

language semantics 
technical report bbn laboratories cambridge ma 
schmolze 

terminological knowledge representation systems supporting ary terms 
brachman pages 
schmolze brachman editors 
proceedings kl workshop 
published bbn research report bolt beranek newman june 
schmolze israel 

kl semantics classification 
technical report research knowledge representation natural language understanding annual report bbn report bbn laboratories camb ma 
schmolze 

classification kl knowledge representation system 
proc 
eigth international conference artificial intelligence ijcai karlsruhe germany pages 
morgan kaufmann 
schmolze mark 

experience 
computational intelligence 
schr der ller lutz 

partial logical reconstruction 
baader nter nutt editors proceedings workshop knowledge representation configuration number dfki memos pages 
schulz hahn 

knowledge engineering large scale knowledge reuse experience medical domain 
cohn pages 
selman levesque mitchell 

new method solving hard satisfiability problems 
proc 
aaai pages 
sowa editor 
principles semantic networks explorations representation knowledge 
morgan kaufmann publishers san mateo 
stallman sussman 

forward reasoning dependency directed backtracking system computer aided circuit analysis 
artificial intelligence 
stickel 

connection graph resolution theorem proving program 
proc 
third national conference artificial intelligence aaai pages 
stock editor 
spatial temporal reasoning 
kluwer academic publishers dordrecht 


fuzzy description logic 
proc 
aaai wisconsin 
tarski 

decision method elementary algebra geometry 
university california press berkeley ca 
tobies 

complexity reasoning cardinality restrictions nominals expressive description logics 
journal artificial intelligence research 
tresp molitor 

description logic vague knowledge 
technical report report theoretische informatik rwth aachen 


effective logic computation 
john wiley sons 


design implementation description logic provers alc alcrp german 
thesis 


den erf bei beschreibungslogiken mit dom ne german 
diploma thesis diplomarbeit 

haarslev 

adapting optimization techniques description logics concrete domains 
baader pages 
vilain 

restricted language architecture hybrid representation system 
proc 
ninth international conference artificial intelligence ijcai los angeles ca 
morgan kaufmann 
von luck nebel 

back system revisited 
technical report technical university berlin computer science department kit project group kit report 
wahl 

default extension description logics applications 
master thesis link ping university thesis department computer information science 


closed terminologies description logics 
proceedings thirteenth national conference artificial intelligence aaai pages 
wessel haarslev ller 

alc role axioms 
baader pages 
woods 

link foundations semantic networks 
bobrow collins editors representation understanding studies cognitive science pages 
academic press new york 
reprinted brachman levesque 
woods 

understanding subsumption taxonomy framework progress 
sowa pages 
woods schmolze 

kl family 
lehmann editor semantic networks artificial intelligence pages 
pergamon press oxford 
wright brown palmer berman moore 

knowledge configurator supports sales engineering manufacturing network systems 
ai magazine 
yen juang macgregor 

polymorphism improve expert system maintainability 
ieee expert 
yen neches macgregor 

clasp integrating term subsumption systems productions systems 
ieee transactions knowledge data engineering 
ceri faloutsos snodgrass subrahmanian zicari 

advanced database systems 
springer verlag berlin 

