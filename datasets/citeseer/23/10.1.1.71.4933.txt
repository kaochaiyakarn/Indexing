journal artificial intelligence research submitted published generalizing boolean satisfiability ii theory dixon dixon com time systems suite eugene usa matthew ginsberg ginsberg com time systems suite eugene usa eugene luks luks cs uoregon edu computer information science university oregon eugene usa andrew parkes parkes cirl uoregon edu cirl university oregon eugene usa second planned papers describing zap satisfiability engine substantially generalizes existing tools retaining performance characteristics modern high performance solvers 
fundamental idea underlying zap problems passed engines contain rich internal structure obscured boolean representation goal define representation structure apparent easily exploited improve computational performance 
presents theoretical basis ideas underlying zap arguing existing ideas area exploit single recurring structure multiple database axioms obtained operating single axiom subgroup group permutations literals problem 
argue group structure precisely captures general structure earlier approaches hinted give numerous examples 
go extend davis putnam logemann loveland inference procedure broader setting show earlier computational improvements subsumed left intact new method 
third series discusses zap implementation presents experimental performance results 

second planned series papers describing zap satisfiability engine substantially generalizes existing tools retaining performance characteristics existing high performance solvers zchaff moskewicz madigan zhao zhang malik :10.1.1.24.7475
dixon ginsberg parkes refer zap discussed variety existing computational improvements 
appeared jair third currently available technical report dixon ginsberg hofer luks parkes peer reviewed :10.1.1.76.9754
ai access foundation 
rights reserved 
dixon ginsberg luks parkes davis putnam logemann loveland dpll inference procedure eventually producing table 
rows columns described page 
efficiency proof propagation learning rep length resolution technique method sat eee watched literals relevance cardinality exponential unique watched literals relevance unique watched literals strengthening boolean symmetry eee believed sat sat exponential 
reasons exp improvement order rows table correspond observations regarding existing representations satisfiability research reflected labels column 
sat refers conventional boolean satisfiability representing information conjunctions disjunctions literals cnf 

cardinality refers counting clauses think conventional disjunction literals ili li cardinality clause form li positive integer 
pseudo boolean clauses extend cardinality clauses allowing literals question weighted wi positive integer giving weight assigned associated literal 

symmetry involves techniques designed explicitly exploit local global symmetries problem solved 

deals universally quantified formulae quantifications finite domains known size 
columns table measure performance various systems variety metrics 
please see preceding zap dixon fuller explanation relatively comprehensive list earlier discussed 
zap theory 
efficiency representation measures extent single axiom proposed framework replace cnf 
cardinality pseudo boolean quantified languages possible exponential savings achieved 
argued savings possible relatively cardinality pseudo boolean encodings relatively 

proof length gives minimum proof length representation classes problems pigeonhole problem parity problems due tseitin clique coloring problems 
indicates exponential proof length indicates polynomial length 
symmetry exploitation techniques provide polynomial length proofs certain instances method brittle changes axiomatization regard polynomial approach general 

resolution indicates extent resolution lifted broader setting 
straightforward pseudo boolean case cardinality clauses problem natural resolvent cardinality clauses may cardinality clause may cardinality clauses derived result 
systems exploit local symmetries search symmetries inference step problem believed provided reasons maintained inference remains defined quantified axioms requiring linear complexity unification step 

propagation technique describes techniques draw existing partial assignment values variables 
systems zhang stickel watched literals idea moskewicz zhang stickel efficient mechanism known 
approach lifted somewhat simpler method lifted average case exponential savings obtained result ginsberg parkes 

learning method gives technique typically save inference proceeds 
general relevance bounded learning bayardo miranker bayardo schrag ginsberg effective technique known 
augmented strengthening pseudo boolean case order reasoning quantified formulae 
goal current add single line table dixon ginsberg luks parkes efficiency proof propagation learning rep length resolution technique method sat eee watched literals relevance cardinality exponential unique watched literals relevance unique watched literals strengthening boolean symmetry eee believed sat sat exponential 
reasons exp improvement order zap exponential ppp reasons watched literals exp improvement order parity zap approach inference focus series papers 
basic idea zap realistic problems boolean clauses versions single clause 
notion precise shortly point think instances quantified clause versions particular ground instance 
versions turn correspond permutations set literals problem 
example suppose tying prove impossible put pigeons holes pigeon get hole 
boolean axiomatization problem include axioms pn pn pn pn pn pn pn pn pn pn pn pij says pigeon hole clause says pigeon pigeon hole 
second clause column says pigeon pigeon hole 
second column refers hole 
fairly clear axioms reconstructed interchanging pigeons holes intuition zap attempts capture 
approach interesting fact reasoning large set clauses possible reason single clause instance set permutations 
see sets permutations occur naturally highly structured sets called groups exploiting structure lead significant efficiency gains representation reasoning 
comments table 
zap theory cardinality pseudo boolean methods achieve exponential reductions problem size practice achieve reductions zap guaranteed requisite structure replace set axioms single axiom size log number variables problem proposition 
fundamental inference step zap np respect zap representation complexity worse exponential representation size polynomial number boolean axioms resolved 
practice average case complexity appears low order polynomial size zap representation polynomial logarithm number boolean axioms resolved dixon 
zap obtains savings attributable case casting general setting equivalent watched literals boolean case 
particular observation dependent variety results computational group theory discussed third series dixon 
addition learning boolean consequences resolution zap continues support relevance bounded learning schemes allowing derivation firstorder consequences parity arguments combinations thereof 
order deliver claims section summarizing dpll algorithm modifications embody progress casting dpll precise form needed zap best capture architecture modern systems zchaff 
section summary ideas new providing ideas group theory 
section describe key insight underlying zap 
mentioned structure exploited earlier examples corresponds existence particular groups permutations literals problem 
call combination clause permutation group augmented clause efficiency representation column table corresponds observation augmented clauses group structure improve efficiency encoding 
section resolution describes resolution broader setting section proof length presents variety examples ideas showing pigeonhole problem clique coloring problems tseitin parity examples admit short proofs new framework 
section learning method dpll algorithm new terms discusses continued applicability relevance setting 
concluding remarks contained section 
implementation details including discussion propagation techniques deferred third series papers dixon 
third include presentation performance details point note merely zap exhibit polynomial performance natural encodings pigeonhole parity clique coloring problems 
sharp contrast methods theoretical best case performance experimental average case performance known exponential problems classes 

boolean satisfiability engines dixon ginsberg luks parkes zap descriptions standard davis putnam logemann loveland dpll boolean satisfiability algorithm described informally extensions dpll deal learning 
goal describe implementation theoretical ideas 
precise dpll extension relevance bounded learning rbl 
general definitions need give description dpll algorithm learning reason maintenance setting 
prove implementation ideas retain soundness completeness dpll amount memory grows polynomially problem size 
result generally accepted relevance learning dynamic backtracking ginsberg generalized bayardo miranker schrag bayardo miranker bayardo schrag know previous proof rbl stated properties 
definition partial assignment ordered sequence distinct consistent literals 

ln definition ili clause denote suppose partial assignment 
say possible value poss ambiguity possible write simply poss poss 
words poss number literals satisfied valued reduced true clauses require true literal 
set clauses write poss subset poss similar way define curr curr write subset curr informally poss means partial assignment extending literal true room extra literals true 
literals assigned values literal true single unvalued literal literals false 
poss means partial assignment extended way cause satisfied 
see poss set clauses falsified curr gives current excess number satisfied literals opposed poss gives possible excess set poss curr set clauses currently satisfied unvalued literal 
generally referred unit clauses 
note passing definition easily extended deal pseudo boolean boolean clauses extension focus 
zap theory definition annotated partial assignment ordered sequence 
ln cn distinct consistent literals clauses ci reason literal li ci true indicating li branch point ci clause 
li literal ci 
poss ci 
li annotated partial assignment called sound respect set clauses ci reason ci 
reasons property literals 
li included partial assignment possible conclude li directly ci way ci satisfied 
definition clauses set literals 
say resolve unique literal 
resolve resolvent denoted resolve disjunction literals set 
reasons result resolving defined true resolve conventional resolvent true 
definition set clauses partial assignment 
nogood clause entailed falsified nogood clause entailed position basic building blocks dpll rbl unit propagation procedure 
computes obvious consequences partial assignment procedure unit propagation compute unit propagate set clauses annotated partial assignment poss curr poss element poss li literal highest index return true resolve ci element poss curr literal unassigned return false dixon ginsberg luks parkes procedure returns pair values 
indicates contradiction 
second value reason failure consequence clausal database falsified partial assignment nogood 
contradiction second value suitably extended partial assignment 
procedure modified annotated partial assignments annotate new choices extended 
proposition suppose boolean satisfiability problem sound annotated partial assignment 

unit propagate false sound extension 
unit propagate true nogood proof 
interests maintaining continuity exposition proofs including 
deferred appendix 
proofs proof sketches appear main text exposition way 
describe relevance bounded learning procedure relevance bounded reasoning rbl sat problem set learned nogoods annotated partial assignment fixed relevance bound 
compute rbl unit propagate true empty return failure remove successive elements satisfiable poss poss return rbl solution return literal assigned value return rbl true procedure fairly different original description dpll go 
general variables assigned values branching line unit propagation lines 
unit propagation terminates reaching contradiction finding solution false line test line fails branch variable selected assigned value procedure recurs 
unit propagation procedure fails returns true new nogood new clause learned adding search backtracks zap theory point satisfiable 
learned clauses irrelevant poss value exceeds irrelevance cutoff removed 
note remove learned irrelevant nogoods obviously remove clauses part original problem specification 
reason sets original learned clauses respectively maintained separately 
procedure fail contradiction empty clause derived 
cases progress augmenting set clauses include new nogood eliminates current partial assignment 
resetting branch literal take opposite value davis original description algorithm new clause learned added problem 
new clause causes previous variable take new value 
description ambiguous variety points 
specify far backtrack line branch literal chosen line 
concerned choices zap takes approach zchaff implementation straightforward 
theorem rbl sound complete rbl return satisfying assignment satisfiable report failure unsatisfiable 
rbl uses amount memory polynomial size exponential relevance bound 
discussed length zap authors focused extending language boolean satisfiability ways preserve efficiency rbl 
extensions include ability deal quantification ginsberg parkes pseudo boolean cardinality clauses barth hooker dixon ginsberg hooker nemhauser wolsey parity clauses baumgartner massacci li 

concepts group theory relevance bounded learning part background need describe zap need basic ideas group theory 
excellent available topic give brief account 
goal terse sequence definitions claim self contained provide insight regarding goals underlying philosophy group theory generally 
face similar problem final series draw heavily results computational group theory compact hopefully helpful overview broad area mathematics 
definition group set equipped associative binary operator 
operator identity inverse 
remarked zap systems zchaff moskewicz backtrack point unit 
dixon ginsberg luks parkes words function associative group operator required commutative commutative group called abelian 
typical examples groups include group integers operation addition 
similarly groups rationals reals addition 
multiplication zero needs excluded inverse get groups note group integer integers common groups include zn positive integer group integers mod group operation addition mod prime set nonzero integers mod multiplicative inverse group multiplication 
group contains single element trivial group 
group denoted 
groups described far abelian non abelian groups hard come 
example set matrices real entries nonzero determinants group multiplication matrix nonzero determinant inverse 
group called general linear group denoted gl 
particular interest called permutation groups definition set 
permutation bijection 
proposition set 
set permutations group composition operator 
proof 
simply matter validating definition 
functional composition known associative necessarily commutative identity function identity composition operator 
permutation bijection permutations inverted give inverse operator group 
group permutations called symmetry group typically denoted sym 
take view composition acts second 
note variable order 
permutation groups interest worthwhile introduce additional notation dealing case subset integers 
special case 
abbreviate sym sym simply sn 
course get groups permutations including permutation particular set element set consisting identity permutation permutation swaps specific elements closed inversion composition group 
general definition group 
subset called subgroup group 
denoted inclusion proper write zap theory subgroup group subset includes identity closed composition inversion 
finite group closure composition suffices 
understand suppose subset closed composition 
finite eventually integers assume follows closed inversion subgroup 
proposition group suppose subgroups 
subgroup 
clear closed inversion composition component groups definition group subset 
unique smallest subgroup containing denoted called subgroup generated order element defined 
generated subgroup unique formed intersection subgroups containing intersection subgroup virtue proposition 
trivial subgroup generated consisting identity element order identity element 
element order nonzero exponent 
remarked element set ab group represents trivial permutation ab permutation swaps easy see ab group generated ab 
order ab 
similar way abcd permutation maps back subgroup generated abcd abcd ac bd third element simultaneously swaps swaps order permutation abcd abcd called cycle 
subgroup previous subgroup generated ab abelian full permutation group sym abelian 
hard see abelian specific permutation 
slightly interesting group generated abcd ac 
group elements abcd ac bd ac ad bc bd ab cd permutations don ac second 
abcd ac ac abcd group abelian 
hard see group fact group rigid motions square vertices labeled permutation abcd corresponds rotation square second ac flip diagonal 
permutations simply rotate square second flip dixon ginsberg luks parkes group abelian flip followed clockwise rotation different rotation followed flip 
similar way basic twists rubik cube generate permutation group size approximately giving accessible permutations faces 
general suppose permutation set obviously consider image denote image usual customary denote reason inline notation fg natural opposed unnatural fg mentioned previously 
dropped explicit composition operator 
continuing form set images varies elements permutation group called orbit definition sym permutation group 
orbit denoted 
returning case permutations integers suppose integer permutation 
consider group permutations generated set powers eventually order 
orbit set 

suppose integer appears sequence say images read sequence images sense write piece permutation example indicating mapped mapped mapped back 
course cycle doesn tell happens integers need cycle 
permutation swaps addition mapping write moved write general mention variables fixed permutation preferring longer 
omit commas cycles continue abbreviate simply abc 
need indicate explicitly cycles part single permutation introduce extra set parentheses rewriting zap theory permutation written product disjoint cycles way 
composing permutations written fashion drop replace example abc abd ad bc point moved cycle second 
point moved cycle changed second moved moved cycle moved second 
notions need closure stabilizer definition sym closure denoted mean set definition group sym pointwise stabilizer denoted gl subgroup set stabilizer denoted subgroup example consider group generated permutation considered 
hard see group generated cycle cycle 
subgroup point stabilizes set identical 
subgroup set stabilizes permutation leaves set intact 

axiom structure group need details procedures order implement ideas procedures inherit certain weaknesses dpll originally described 
weaknesses hope address 
appearance poss curr inner unit propagation loop requires examination significant subset clausal database inference step 
dpll rbl fundamentally resolution methods known problem classes exponentially difficult resolution methods easy language extended include cardinality parity clauses 
examples structure examining examples specialized techniques help address difficulties 
dixon ginsberg luks parkes discussed dixon ginsberg parkes set axioms need investigated dpll inner loop structure exploited speed examination process 
ground axiomatization replaced lifted search axioms specific syntactic properties np complete number variables lifted axiom called reason 
cases search techniques applied problem 
example suppose looking instances lifted axiom unit poss curr instance unit propagation possible result 
notation 
implicit universal quantification quantification domain finite size 
assume domains size corresponds ground axioms 
true surely conclude time conclude unit instances instance satisfied 
true single pair need examine possible values unit instances reducing total useful follows example specific assume chosen element domain 
single lifted axiom corresponds set ground instances introduce ground literals instances get zap theory point structure implicit obscured 
return details example shortly 
cardinality structure sets axioms encode pigeonhole problem known exponentially difficult resolution method haken 
shown variety authors cook turan dixon ginsberg pigeonhole problem solved polynomial time extend representation include cardinality axioms xm shown zap single axiom equivalent conventional disjunctions 
section consider example detail 
suppose clause saying xi true 
equivalent parity clauses consider clauses naturally expressed modular arithmetic exclusive xk mod xk mod parity sum xi specified odd 
known axiom sets consisting parity clauses isolation solved polynomial time gaussian elimination examples exponentially difficult resolution methods tseitin 
examples discussed single axioms reveal structure straightforward boolean axiomatization obscures 
case single axiom equivalent cardinality axiom equivalent disjunctions parity axiom form general equivalent boolean disjunctions 
formalizing structure dixon ginsberg luks parkes course ground axiomatizations equivalent original descriptions structure original descriptions 
structure obscured ground encodings 
goal section process understanding structure way lets describe general terms 
start note axiom sets consists axioms equal length follows axioms obtained single simply permuting literals theory 
literals permuted literals sign literals permuted negated versions 
instance permutation suffices 
example set permutations needed generate ground axiom clearly just set sym literals permuted arbitrarily move element 
set subgroup full permutation group literals variables easily seen closed inversion composition 
example involving parity clause 
set permutations needed generate axioms literals exchanged negations set closed group inverse composition operations 
element composition disjoint transpositions element inverse 
composition elements third 
remaining example bit subtle expected axiomatization obscures underlying structure far effectively 
understand example note set axioms generated set transformations underlying variables 
transformation swap values leaving values unchanged corresponding permutation included single permutation induced changes relevant ground literals 
relation doesn appear argument 
terms literals zap theory similar way swapping values corresponds permutation produces consider subgroup sym 
generated clauses obtained single clause permuting values clear image single clause set exactly complete set clauses 
example operating axiom produces fifth axiom swapped 
alternatively straightforward calculation shows maps axiom second axiom 
clear point examples common 
case set ground instances corresponding single non boolean axiom generated single ground instance elements subgroup group permutations literals problem 
provided clauses length obviously subset opposed subgroup produce clauses single 
subgroups highly structured objects fewer subgroups subsets 
expect priori particular sets permutations arising examples structure subgroups 
fact particular subsets subgroups subsets general leads general belief structure subgroups captures generalizes general idea structure underlying motivating examples 
problems structure subgroup property absent 
instance random sat example encoded single literal clause set permutations needed recover entire problem isolation 
structure set permutations original set clauses unstructured 
examples considering hand structure implicit requirement set produce clauses group 
see group structure just computational properties needed lift rbl boolean satisfiability techniques broader setting 
point surprising fact subgroup idea captures structures discussed zap 
surprising various structures reduce proof size similar flavor structure speed unit propagation 
general 
subsets approximately subgroups 
dixon ginsberg luks parkes uniform 
strikes remarkable types structure different purposes fact instances single framework 
technical insight zap rests generalizing language boolean satisfiability required range examples considered suffices annotate ground clauses needed reproduce larger axiom set 
formalize note reasonable permutation maps literal literal respect semantics axiomatization map 
definition set variables denote wn subgroup consisting permutations map literal map 
informally element wn corresponds permutation variables choice flip subset wn size wn 
position state definition augmented clause variable boolean satisfiability problem pair boolean clause wn 
ground clause instance augmented clause clause called base instance 
aim remainder show augmented clauses properties needed justify claims 
represented compactly 
combined efficiently generalization resolution 
generalize existing concepts quantification finite domains cardinality parity clauses providing natural generalizations proof techniques involving clauses 
rbl extended little computational overhead manipulate augmented clauses ground ones 
propagation computed efficiently generalized setting 
points discussed sections 
final point series 
efficiency representation point fact augmentations represented compactly consequence group structure 
example surrounding reconstruction example group question full symmetry group elements number variables cardinality clause 
lifting example 
note passing wn called wreath product sn typically denoted sn 
specific group wn called group permutations harrison 
zap theory describe group terms generators listing elements group contains 
general recall proofs appear appendix proposition set ground clauses equivalent augmented clause represented generators 
possible polynomial time find set generators 
log 
size full permutation group sn 
single generator takes space corollary augmented clause theory containing literals expressed log space 
result strengthened proposition jerrum knuth sn 
possible find polynomial time set generators size 
reduces log corollary simply 
proceeding regarding computational complexity 
group theoretic constructs interest computed time polynomial group size basically simply enumerates group evaluates construction generate test 
interesting collection group constructions computed time polynomial number generators group number variables problem 
proposition time polynomial number variables problem 
note size group vastly greater number instances particular augmented clause 
example cardinality clause xm associated symmetry group sym 
xm acts instance xm reproduce full boolean axiomatization 
instance corresponds 
distinct group elements variables clause permuted 
particular case symmetry group sym 
xm fact generated permutations 
xm 
definition augmented clauses called equivalent identical sets instances 
denoted 

methods nonconstructive babai showed length increasing sequence subgroups sn imposes bound number generators needed compare proof proposition 
methods neumann stated generating set size 
dixon ginsberg luks parkes proposition augmented clause 
instance 
proposition augmented clause distinct instances 
subgroup described log generators 
furthermore generators monte carlo polynomial time algorithm constructing generators proposition results promised boolean axioms involving variables captured instances augmented clause augmented clause represented generators proposition guarantees log generators suffice 
specific instances discussed representational efficiencies greater clause boolean total type cardinality parity axioms generators size dv row gives number boolean axioms generators needed represent clause type total size generators 
cardinality clause complete symmetry group variables expressed exactly generators size size 
number boolean axioms explained section 
parity clause xk mod number boolean axioms number ways select number xi half subsets 
xk 
remove set subset remaining xi parity including appropriate 
parity groups fk captured generators form xi xi 
total size alternatively combine single generator full symmetry group 
xk describe parity clause exactly generators total size 
clause involving variables domain size corresponds set individual domain axioms 
saw section formalize section associated group described symmetry groups domains quantified variable groups generators size required 

monte carlo algorithm deterministic arbitrarily high specified probability changing complexity seress 

noted earlier sn generated transposition cycle 


depending sizes number generators needed product symmetry groups reduced cases total size unchanged 
zap theory note total sizes virtually optimal cases 
cardinality parity clauses surely essential enumerate variables question size respectively 
clauses simply enumerating domains quantification takes space vd 

resolution turn question basing derivations augmented clauses ground ones 
preliminaries proposition ground clauses permutation wn resolve resolve definition set augmented clauses say entails augmented clause writing instance entailed set instances augmented clauses position consider lifting idea resolution setting discuss intent lifting 
think augmented clause having force similar instances result resolve augmented clauses obtain augmented resolvent set resolutions sanctioned resolving instance 
unfortunately proposition augmented clauses set resolvents instances clauses correspond single augmented clause 
capture exactly set possible resolvents augmented clauses 
augmented resolvent expect properties 
sound 
says instance sanctioned resolving instance instance 

complete resolve instance 
may able capture possible resolvent augmented clause surely capture base case obtained resolving base instance directly base instance 

monotonic resolvent 
clauses resolved stronger resolvent stronger 

polynomial possible confirm resolvent polynomial time 
dixon ginsberg luks parkes 
stable cg resolve resolvent 
roughly speaking says groups input clauses augmented resolvent obtained resolving base instances operating group 

strong element moved similarly element moved resolve resolvent 
says group actions distinct acts leaves completely vice versa able get complete group resolvents answer 
group corresponds base resolvent resolve acted group generated 
definition definition augmented resolution called satisfactory satisfies conditions 
note require definition augmented resolution unique 
goal define conditions augmented resolvent opposed augmented resolvent 
best knowledge suggested proposition satisfactory definition augmented resolution defines resolvent augmented clauses uniquely 
satisfactory definition augmented resolution consider examples help understand basic issues 
consider example resolving clauses bc instances single instance write somewhat compactly bc respectively 
resolving clauses individually see able derive pair clauses words augmented clause bc certainly possible capture setting base instance just resolvent base instances 
group generated bc come 
answer introducing additional notation 

condition requires instance augmented resolvent groups act independently case 
zap theory definition permutation set 
denote result restricting permutation set 
note permutation fixed 
definition 
kn 
gn sym say permutation sym extension 
gn 
kn gi gi ki gi ki denote set extensions ki gi 
definition says particular extension ki gi simultaneously extend elements individual groups gi groups act various subsets ki 
example suppose sym ed permutation extension gi ki restricted member sym restricted member ed words mapped mapped desired 
set extensions bc bd bcd cd ed edc bc de note set group closed group operations edc permitted mapped don care go edc ecd 
considered context resolution suppose trying resolve augmented clauses 
level result resolve ci gi legal resolvent original clauses instance sanctioned resolving instances originals 
define resolvent resolve ci gi seen example ci gi ci gi wn need group 
know proposition may single group captures possible resolvents 
simply require augmented resolvent ci gi obvious polynomial test inclusion group set 
overcome difficulties need version definition produces group extensions opposed just set definition 
kn 
gn sym say permutation sym stable extension 
gn 
kn denote set stable extensions gi gi gi 
gn 
kn stab ki gi 

write ci gi ci gi may group 

possible test polynomial time simply test generator membership closed group operation fact generators sufficient conclude dixon ginsberg luks parkes definition modified definition restriction just original sets ki gi gi closure ki recall definition 
example sym ed stable extension member sym restricted closure member ed restricted 
means care candidate permutation maps set stable extensions simply bc bc fact mapped virtue mapped virtue means fixed permutation stab ki gi resulting set stable extensions small 
general proposition stab ki gi sym 
words stab ki gi subgroup sym 
point need deal monotonicity condition definition 
resolve resolve see issue suppose resolving sym ed groups act seen take group stable extensions group resolvent conclude bc 
replace resolving result stronger sym 
replace bc result different stronger bc de monotonicity considerations suggest definition suppose augmented clauses resolve conventional sense 
resolvent augmented clause form resolve stab ci hi wn hi gi 
canonical resolvent denoted resolve augmented clause resolve stab ci gi wn 
proposition definition noncanonical resolution satisfactory 
definition canonical resolution satisfies conditions definition monotonicity 
zap theory proceeding consider example preceded definition bit detail 
looking augmented resolvents sym ed 
find resolvent selecting sym ed need definition compute group stable extensions 
take trivial group group stable extensions trivial see resolve resolvent 
choices interesting 
take stable extensions leave clause fixed move image second consistent 
produces augmented resolvent de 
hand take leave fixed exchange freely get sym resolvent 
computed group stable extensions earlier discussions example augmented resolvent bc weaker resolvent previous paragraph 
take bc exchange independently exchange get augmented resolvent bc de 
choices mentioned discussion monotonicity preceded definition 
variety additional remarks definition 
canonical resolution lacks monotonicity property shown earlier example 
addition resolvent augmented clauses obviously depend choice representative elements addition choice subgroup stab ci gi 
resolve get contradiction 
rewrite attempting resolve resolution possible 
address version rbl lifted general setting need ensure trying resolve base instances resolve 
see achieved maintaining ground reasons literal annotated partial assignment 
ground clauses resolve contradiction search needs backtrack 
point computational issues involved evaluation stab ci gi 
component groups described listing elements incremental construction possible generators gradually added impossible extend group violating definition 
dixon ginsberg luks parkes described terms generators suggested results section computing stab ci gi involves computational subtasks dixon recall definition 
group set find 

group set find gc 

groups described terms generators find set generators 


restriction sense restriction find element 
great deal say issues describing zap implementation 
point merely time complexity known polynomial second fourth problems known polynomial time 
computational group theory systems incorporate procedures rarely exhibit super polynomial behavior construct examples force take exponential time usual terms number generators groups absolute size 
claimed result resolution unique reasons zap fundamental inference step np respect zap representation low order polynomial complexity practice 
reasons breaks ambiguity surrounding remarks regarding complexity correspond computational observations just 

examples proof complexity turn examples discussed previously order axioms quantified finite domains standard examples proof complexity including pigeonhole problems clique coloring problems parity clauses 
see ideas generalize conventional notions quantification providing additional representational flexibility cases 
examples ground axiomatization recast augmented clauses give polynomially sized derivation unsatisfiability augmented resolution 
lifted clauses deal lifted clauses suppose quantified clause xyz 
additional requirement able compute stab ci gi wn stab ci gi 
issue practice representation groups represented intersections wn 
included generator group automatically include generators dual permutation literal sign flipped 
zap theory suppose domain grounding clause involves working map takes elements produces ground atoms corresponding 
words set variables problem injections images disjoint injection distinct relation instances mapped distinct ground atoms 
permutation elements define permutation 
words mapping set permutations set permutations sym sym definition groups function 
called homomorphism respects group operation 
clear proposition sym sym injection homomorphism 
words copy sym inside sym corresponding permuting elements domain similar way define homomorphisms 

consider subgroup sym generated images sym sym sym 
clear images commute intersection trivial permutation 
means collectively inject product sym sym sym sym denote xy sym sym sym sym clear original quantified axiom equivalent augmented axiom xy sym sym sym dixon ginsberg luks parkes necessarily distinct elements respectively 
quantification exactly captured augmentation 
interesting thing happens resolution setting proposition quantified clauses term tp tq tp tq common instances 
suppose pg augmented clause equivalent qg augmented clause equivalent pg qg resolve 
terms tp tq common instances result resolving conventional lifted sense equivalent resolve pg qg 
example 
suppose general unifier appearances binds produce version augmented clauses clear select ground instances pg qg resolve resolvent ground instance interesting part group 
note simply image pg entire embedding sym sym sym sym corresponding lifted axiom image qg similarly embedded image sym sym corresponding 
group stable extensions embeddings corresponds bindings variables extended permutation variables question words bindings consistent common ground literals expressions mapped ground literal sets bindings disjoint attempt map quantified literals ground instance 
condition guaranteed conditions proposition require non resolving literals common ground instances 
particular example choose instances resulting augmented clause group mapping sym sym sym corresponds quantified clause 
condition requiring lack commonality ground instances necessary consider resolving quantified case get zap theory xy augmented case hard see resolve get corresponding choose resolve get clear representations superior 
conventional compact obscures fact stronger entailed 
particular example simple examples involving longer clauses residual unbound variables complex 
proof complexity conclude section demonstration zap produce polynomial proofs problem instances appearing original table 
pigeonhole problems examples known exponentially difficult conventional resolution systems pigeonhole problems ways simplest 
usual denote pij fact pigeon hole variables problem 
denote subgroup allows arbitrary exchanges pigeons holes isomorphic sn sn 
particular example straightforward single global group able analysis 
axiomatization saying pigeons hole saying pigeon hole 
proposition augmented resolution proof polynomial size mutual unsatisfiability 
proof 
consequence stronger proposition independent proof appendix 
ideas proof needed analysis clique coloring problem 
dixon ginsberg luks parkes proposition implementation procedure branches positive literals unsatisfied clauses line produce proof polynomial size mutual unsatisfiability independent specific branching choices 
strikes remarkable result possible find proof polynomial length augmented framework presence unit propagation difficult 
careful proof result appendix useful examine detail prover proceed small pigeon hole example 
branching say saying pigeon hole 
unit propagation allows conclude immediately pigeon hole annotated partial assignment literal reason true try putting pigeon hole extend partial assignment literal reason true point forced put pigeons hole leads contradiction literal reason resolving reasons produces resolve reason get 
continuing backtrack produces 
operating clause usual symmetry group swapping hole hole produces pigeon go 
resolve clauses get 
implies pij usual symmetry conclude original axiomatization unsatisfiable 

conclude pigeon hole symmetry existing choice pigeon hole course 
symmetry group applied original clauses derived nogoods branch choices 
alternatively branch choice corresponds augmented clause 
clique coloring problems zap theory pigeonhole problem difficult resolution easy proof systems clique coloring problems difficult resolution approaches pseudo boolean axiomatizations 
clique coloring problems derivatives pigeonhole problems exact nature pigeonhole problem obscured 
somewhat specifically say graph includes clique nodes node clique connected graph colored colors 
graph known clique problem equivalent pigeonhole problem 
know clique embedded graph problem difficult 
formalize eij describe graph cij describe coloring graph qij describe embedding clique graph 
graph nodes clique size colors available 
axiomatization eij cil cjl 
ci cin 
qi qim 
qij 
eij eij means edge graph nodes cij means graph node colored jth color qij means ith element clique mapped graph node axiom says nodes graph color colors available connected edge 
says graph node color 
says element clique appears graph says elements clique map node graph 
says clique clique clique elements map disconnected nodes graph 
pigeonhole problems global symmetry problem nodes clique elements colors swapped 
proposition augmented resolution proof polynomial size unsatisfiability 
proof appendix presents zap proof size clique coloring problems size graph size clique 
zap implementation produces shorter proofs size dixon 
short proofs involve derivation manipulation subtle clauses complex understand 
move parity clauses note approach proposing properly stronger symmetry breaking axioms crawford ginsberg luks roy approaches taken krishnamurthy 

clear conclude zap bad authors 

dixon ginsberg luks parkes symmetry breaking approach original axiom set modified soon single symmetric instance falsified instance symmetric variants 
authors krishnamurthy achieve similar effect attaching symmetry way symmetric instances removed soon possible disprove 
authors approach augmented clauses capable exploiting local symmetries subset entire axiom set 
authors require presence global symmetry entire structure problem 
parity clauses discuss specific example show determining satisfiability set parity clauses augmented resolution 
proof modeled proof satisfiability parity clauses lemma theory consisting entirely parity clauses 
determining satisfiable discussed proof basically gaussian reduction argument 
definition subset set variables 
say permutation flips variable denote fs subset wn consisting permutations leave variable order unchanged flip number variables lemma fs wn 
lemma 
xk subset set variables 
parity clause xi equivalent augmented clause xk fs parity clause xi equivalent augmented clause show xk fs proposition theory consisting entirely parity clauses 
determining satisfiable augmented resolution 
zap theory note passing construction section fails case modularity clauses base 
problems set permutations flip set variables size congruent mod group 
need identity included included follows xn xn xn xn xn xn included 
clear coincidence deep connection fact mod clauses expressed compactly augmented clauses solvable polynomial time 

theoretical procedural description addition resolution examination procedures shows need able eliminate nogoods irrelevant identify instances augmented clauses unit 
discuss issues 
problems irrelevance easier deal 
ground case remove clauses longer relevant augmented version remove clauses longer possess relevant instances 
defer final series discussion procedure determining relevant instance 
defer discussion specific procedure computing unit propagate include theoretical comments point 
unit propagation partial assignment need determine instances axioms unit 
suppose denote set satisfied literals theory set unvalued literals 
particular augmented clause looking 
condition says satisfied literals second unvalued literal 
procedure unit propagation compute unit propagate set augmented clauses annotated partial assignment 
ln cn li literal highest index return true resolve ci literal unassigned add return false dixon ginsberg luks parkes note addition adding new literal includes instance clause led propagation augmenting group usual 
augmented clause virtue proposition 
augmented version procedure procedure relevance bounded reasoning rbl sat problem set learned nogoods 
annotated partial assignment fixed relevance bound 
compute rbl unit propagate true empty return failure remove successive elements unit remove augmented clauses relevant instances return rbl solution return literal assigned value return rbl true examining procedures see need provide implementations 
routine computes group stable extensions appearing definition augmented resolution needed line unit propagation procedure 
routine finds instances disjoint needed line unit propagation procedure 
routine determines instance poss fixed needed line procedure 
problems known np complete remind reader continue measure complexity terms size domain number generators particular group number generators logarithmic number instances particular augmented clause 
case practical complexity solving problems appears low order polynomial 
focus final series development efficient procedures achieve goals incorporation zchaff prover evaluation performance resulting system 

zap theory aim give theoretical description generalized representation scheme satisfiability problems 
basic building block approach augmented clause pair consisting ground clause group permutations literals theory intention augmented clause equivalent conjunction results operating elements argued structure requirement group provides generalization wide range existing notions quantification finite domains parity clauses 
went show resolution extended deal augmented clauses gave generalization relevance bounded learning setting procedures 
showed resulting proof system generalized order techniques applied finite domains quantification produce polynomially sized proofs pigeonhole problem clique coloring problems tseitin graph coloring problems parity clauses general 
described specific group theoretic problems need addressed implementing ideas 
discussed previous section 
implementing group operation associated generalization resolution 
finding unit instances augmented clause 
determining augmented clause relevant instances 
return issues final series dixon describes implementation ideas computational performance 
acknowledgments members cirl technical staff time systems paul beame university washington david hofer cis department university oregon assistance ideas series papers 
anonymous reviewers comments improved exposition greatly 
sponsored part air force office scientific research afosr number air force research laboratory afrl number small business technology transfer research advanced technology institute ati number office naval research onr number national science foundation nsf number ccr defense advanced research projects agency darpa air force research laboratory rome ny agreements numbered 
views expressed authors 
appendix proofs proposition suppose boolean satisfiability problem sound annotated partial assignment 
dixon ginsberg luks parkes 
unit propagate false sound extension 
unit propagate true nogood proof 
case need show extension procedure leaves sound partial assignment 
words add show 

appears 
literal false virtue assignment note explicitly set literal poss literal set false second case proposition result resolving clause reason ci entailed virtue soundness see falsified note clause poss surely falsified literal reason ci li falsified li 
follows result resolving clauses falsified assignments theorem rbl sound complete return solution satisfiable theory report failure unsatisfiable 
rbl uses amount memory polynomial size exponential relevance bound 
proof 
soundness immediate 
completeness note nogood learned eliminates additional portion search space backtrack constrained go far newly learned nogood removed irrelevant 
claim extend definition somewhat defining reason literal learned clause involving valued literal point clause learned 
show literal reasons number variables problem 
see set reasons point 
reason set time learned current point literals unassigned current partial assignment 
follows fixed partial assignment holds life literals unassigned values set literals assigned values reason ri view ri simply set literals contains ri set literals appearing ri outside stable partial assignment rj learned ri literal li ri rj rj stable partial assignment precluded set variable assignments led ri 
words ri unique reason set know ri reason corresponds choosing literals complement variables problem literals set number reasons bounded follows total number reasons learned bounded follows 
theorem lagrange finite group divides 
zap theory proposition set ground clauses equivalent augmented clause represented generators 
possible polynomial time find set generators 
log 
proof 
simplest approach suffices 
gi checking see gi 
generator gi performed polynomial time known method sims dixon luks seress gi generated set add new generator 
virtue lagrange theorem subgroup larger half size group properly contains adding new generator set doubles size generated set 
follows number generators needed exceed log 
proposition augmented clause 
instance 
proof 
instance cg instances clauses form cgg cgg cg gg similarly instance clause form cg definition sym 
say acts transitively proposition augmented clause distinct instances 
subgroup described log generators 
furthermore generators monte carlo polynomial time algorithm constructing generators proof 
basic ideas proof follow methods introduced babai luks seress 
proof particular result bit involved require existing familiarity group theory 
set instances acts transitively consider sequence 
uniformly distributed random elements hr 
gr particular 
suppose hr act transitively orbit hr proper subgroup lagrange theorem implies probability gr probability hr enlarges average orbits enlarged passing hr hr 
orbits partition entire set orbit enlarged merged orbits 
fact half orbits enlarged implies total number orbits reduced expected number orbits hr consequence high probability exists log hr acts transitively 
probability failure kept fixed 
implementation algorithm implicit proof requires ability select uniformly distributed random elements available cost element standard data structures permutation group computation seress 

reason monte carlo method known deterministic polynomial time test testing acts transitively note may exponential number variables problem 
dixon ginsberg luks parkes proposition ground clauses permutation wn resolve resolve proof 
suppose literal resolved think represented simply literals contain resolvent corresponds permuting gives equality consequence fact permutation question member wn simply 
right hand side simply resolve 
proposition augmented clauses set resolvents instances clauses correspond single augmented clause 
proof 
consider resolving augmented clause bc instances augmented clause dc corresponding ground clauses obtained resolving instances clauses uniform length instances single augmented clause 
proposition stab ki gi sym 
proof 
suppose stab ki gi 
fixed gi similarly 
gi stab ki gi 
equality holds virtue definition stable extension second holds necessarily gi closure ki 
inversion similar 
definition definition augmented resolution called satisfactory resolvent satisfies conditions 
sound 
note algorithm explicitly requires know advance 
necessary quantity known computable polynomial time 
methods computing efficient practice 
zap theory 
complete resolve instance 

monotonic resolvent 

polynomial possible confirm resolvent polynomial time 

stable cg resolve resolvent 
strong element moved similarly element moved resolve resolvent 
proposition definition noncanonical resolution satisfactory 
definition canonical resolution satisfies conditions definition monotonicity 
proof 
deal conditions definition time 

soundness instance form resolve simultaneously extends acting acting 
proposition just resolve clauses instance second instance proposition follows soundness resolution 

completeness resolve instance resolve 
monotonicity resolvent stab ci ki ki hi 
hi gi follows ki gi resolvent 

polytime checking assume provided intermediate groups simply check stab ci hi 
stab ci hi group virtue proposition suffices check generator stab ci hi 
straightforward 
generator need simply check restricting gi image ci gi produces permutation restriction element gi 
remarked proving proposition test known 
stability clear resolve resolvent element clearly stable extension 
need additional condition cg cg show resolve canonical resolvent explicit requirement group stable extensions subgroup cg cg stable extensions dixon ginsberg luks parkes agree elements cg agree elements resolve 
canonical resolvent equivalent resolve 

strength clear group stable extensions bigger permutation agrees contained group 
gi element gi odd gi odd gi odd gi 
case similar resolve canonical resolvent 
proposition quantified clauses term tp tq tp tq common instances 
suppose pg augmented clause equivalent qg augmented clause equivalent pg qg resolve 
terms tp tq common instances result resolving conventional lifted sense equivalent resolve pg qg 
proof 
proof contained discussion surrounding example main text 
base instance augmented resolvent clearly instance quantified resolution group remarked group stable extensions embeddings corresponds simply bindings variables resolvents extended permutation variables question 
means bindings consistent regard values selected shared terms distinct quantified literals mapped identical ground atoms 
condition follows assumption non resolving literals common ground instances 
proposition augmented resolution proof polynomial size mutual unsatisfiability 
proof 
explaining proof goes generally subsequently provide details 
fact pigeon holes conclude pigeons holes pigeons hole 
pigeons holes conclude pigeons hole 
similarly pigeons hole leaving hole final pigeon 
formalize write ak fact pigeons holes ak basic strategy proof show denote original axioms hp 
hp 
hp ak ak 
notation vaguely similar krishnamurthy problem solved techniques different 
pij zap theory 
hp denotes contradiction 
addition group appears original axiomatization drop derivation feel free resolve cg derived claim note instance 
second ak need remove variables pjk refer kth hole 
resolve clause get pij pk pk pk pk note holes mentioned disjunction right expression st higher apply group conclude pk resolve instance get pij pij pk pk say ak 
pk pij pij dixon ginsberg luks parkes need derive contradiction say resolving pin pn pn pn gives pn conclude pij acting group resolving instance gives desired contradiction 
lemma assuming branch positive literals unsatisfied clauses pjk branch decisions solving pigeonhole problem 
set unit propagations result branch decision exactly set sk pik 
proof 
prove induction number branch decisions 
base case take consider branch decision pjk 
pik sk instance form pjk pik causes unit propagation pik 
instances contain literals refer hole produces unit propagations 
instance total literals literal refers hole instance unvalued literals generate unit propagation 
inductive case assume lemma holds branches 
assumption branch decision pjk subsequent unit propagations value exactly variables involving hole argument base case 
pjk st branch decision 
clause produces exactly set sk pik unit propagation instance unvalued literals generate unit propagations 
key observation branch decision subsequent unit propagations value variables variables refer particular hole 
lemma 
lm partial assignment obtained solving pigeonhole problem branch decision positive literal unsatisfied clause 
branch decision li subproblem open branch 
li li solved unit propagation 
proof 
assume exploring subproblem 
li pjk branch variable pjk 
subproblem 
li pjk explored unsatisfiable generated nogood defining reason failure 
nogood augmented clause form am pjk zap theory ai unsatisfied 
li global symmetry group problem 
recall virtue lemma original branch decisions subsequent unit propagations valued variables referred particular hole 
consider set holes referred partial assignment 
li 
call set branched pjk pigeon assigned hole 
follows assumption branch positive literals unsatisfied clauses 
words pigeon excluded holes prior decision place hole derived nogood asserts pigeon go hole 
small example worked main text nogood represents single clause 
represents set clauses generated applying permutations am pjk 
apply permutation swaps hole hole literals 
am unchanged remain unsatisfied 
li 
clause am instance unit partial assignment nogood generates series unit propagations indicating pigeon hole holes known excluded hole available pigeon contradiction occurs subproblem 
li pjk closed 
proposition implementation procedure branches positive literals unsatisfied clauses line produce proof polynomial size mutual unsatisfiability independent specific branching choices 
proof 
note rbl search tree size polynomial number branch decisions number variable assignments result unit propagation bounded number variables 
show search tree size polynomial number pigeons suffices show number branch decisions polynomial show branch heuristic number branch decisions specifically 
descend tree branching propagation contradiction reached describe partial assignment created show contradiction drawn 
show backtracking process proving empty clause derived single backtrack 
specifically show open branch search tree closed propagation 
branch decisions needed 
lemma deals branch decisions 
st decision 
branch decision pjk generate set unit propagations sk pik 
time generate additional unit propagations 
assigned pigeons unique hole empty hole remaining 
hole remaining pigeons say pigeons forced hole occupy 
leads expected contradiction 
lemma shows dixon ginsberg luks parkes branches necessary total number branches rbl search tree polynomially sized 
proposition augmented resolution proof polynomial size unsatisfiability 
proof 
proof proceeds similarly proof proposition details far intricate 
ground axioms suppress augmentation global symmetry group 
analog pij ith node clique gets jth color qi qim manipulate form clearly cnf 
statement pigeon hole node clique gets color cm cmn expression ak similarly pij qk cmk cmn saying index index graph node clique element suitable color gets mapped 
order expressions need convert cnf 
distributing produce list conjuncts form bm bi form cik cin 
possible expressions form 
expressions instance result acting global group cmk cmn qk cmk cmn 
qk qk view instances general construct indexed giving number initial clauses row corresponds zap theory second row corresponding follows ak effectively qij important realize haven started prove re just setting machinery needed duplicate proof proposition 
remaining piece analog framework axiom pij saying hole contain pigeon 
cij saying node clique mapped node graph mapped get color 
derive resolving 
clearly weakening 
pij pair clauses derived polynomial time usual acted group ready proceed main proof 
base step derive conjunction qij say cm cmn cm cmn row obviously weakening saying node graph gets color 
final row equivalent saying element clique gets node graph 
inductive step show ak ak 
simplifying notation help introduce cij cij cik cij qi jk 
ak dixon ginsberg luks parkes cmk cmk km pigeonhole proof need reduce number holes colors increase number pigeons clique elements 
step need resolve away appearances cik 
claim possible derive cm qk cmk cm qk cmk km qk cmk show working bottom arrays description top 
row expression clearly weakening final row 
suppose done considering corresponding derivation disjunction ci cm qk cmk recall cjk cik cmk cjk want remove cjk term resolving adding literals form qk cmk 
instance resolvent result resolving qk cmk cjk cj qk cmk cik cj cj cj cmk qk cmk done means derived ki ci cm qk cmk operating usual group allows exchange variables arbitrarily matters terms involve variables involve 
zap theory variables number terms involving variables respectively 
derived ci cj kj cj cm qk cmk essentially swapped node node 

resolve eliminate trailing kj term 
literals ch subset chk get cik cj cj cj cmk qk cmk continue fashion gradually raising second index term obtain ci cm qk cmk 
hard part done exploited symmetry nodes remains symmetry colors 
derivation color final cmk obviously irrelevant provided chosen set 
higher numbered colors higher numbered colors appear cj derived ci cm qk cmk ci cm qk cm ci cm qk cm resolve domain axiom get cm cm cmn ci cm qk cm cmn say ci cm qk cm ci cm qk subscript final variable import provided remains resolve ci cm qk ci cm qk ci cm qk 
domain axiom get say dixon ginsberg luks parkes qk qk ci cm qk qk ci cm ak desired 
remains show derive contradiction 
continue procedure attempt derive derive instance terms simply vanish concluding instance simply qk cmk qk cmk indices subject usual symmetry know ci ci cin resolve ci cin get 
resolve instances qm qmn get desired contradiction 
lemma theory consisting entirely parity clauses 
determining satisfiable proof 
proof essentially gaussian reduction argument proceeds induction number variables result immediate 
suppose contains variables clause containing 
obviously equivalent eliminate axiom appears 
resulting theory tested satisfiability polynomial time result follows 
zap theory lemma suppose axioms sets disjoint 
follows furthermore proof system derive polynomial time determine satisfiability sets parity clauses polynomial time 
proof 
adding produces 
sufficient solve sets parity clauses polynomial time shown proof lemma 
lemma fs wn 
proof 
fs closed inversion element fs inverse 
see closed composition suppose flips variables set flips variables set 
flips variables 
fs 
lemma 
xk subset set variables 
parity clause xi equivalent augmented clause parity clause equivalent augmented clause xk fs xi xk fs dixon ginsberg luks parkes proof 
see implies note certainly implies xk 
result operating disjunction element fs flips number elements follows 
converse suppose fails number xi true 
disjunction flips exactly xi true obviously satisfied literals flipped number elements instance augmented clause unsatisfied 
second equivalence clearly follows replace 
proposition theory consisting entirely parity clauses 
determining satisfiable augmented resolution 
proof 
need show conditions lemma met 
assume loss generality conditions lemma cases involve simply flipping sign variables involved 
light lemma augmented axioms fx fx disjoint 
clause obtained resolution clearly group involved 
elements group stable extensions group elements fx fx words permutation leaves variables unchanged simultaneously flips number elements 
claim exactly elements flip subset number elements 
show stable extension flips number elements arbitrary subset 
flips odd number elements flip odd number elements say number elements 
parity number flipped elements total number flipped odd match element fx extension 
parity number flipped elements odd number flipped odd 
see flipping number elements corresponds stable extension note simply flipping ensure flips number elements relevant subset 
flips number elements flips subsets parity 
flips number elements flips number elements zap theory leave 
flips odd number elements flip 
way corresponding elements fx fx suppose denote ks group flips arbitrary subset shown result resolution ks ft note resolution step polytime result explicitly 
claim implies ks ft removed elements disjunction 
prove induction size result immediate 
specific instances ks ft ks ft resolve stability property definition conclude ks ft follows inductive hypothesis 
point note variables appear clause drop ks group affecting way 
concluded ft applying lemma see equivalent needed lemma 
proof complete 

general augmented resolution known polynomial number generators groups question 
polynomial groups restricted form considered 
dixon ginsberg luks parkes babai 

length subgroup chains symmetric group 
comm 
algebra 
babai luks seress 

fast management permutation groups siam computing 
barth 

davis putnam enumeration algorithm linear optimization 
tech 
rep mpi max planck institut informatik saarbr cken germany 
barth 

logic constraint programming vol 
operations research computer science interfaces series 
kluwer 
baumgartner massacci 

taming 
lloyd dahl furbach kerber lau palamidessi pereira sagiv stuckey 
eds computational logic cl vol 
pp 

springer 
bayardo miranker 

complexity analysis space bounded learning algorithms constraint satisfaction problem 
proceedings thirteenth national conference artificial intelligence pp 

bayardo schrag 

csp look back techniques solve real world sat instances 
proceedings fourteenth national conference artificial intelligence pp 

hooker 

optimization logical inference 
wiley interscience 
cook turan 

complexity cutting plane proofs 
discrete applied mathematics 
crawford ginsberg luks roy 

symmetry breaking predicates search problems 
proceedings fifth international conference principles knowledge representation reasoning boston ma 
dixon ginsberg 

combining satisfiability techniques ai 
knowledge engrg 
rev 
dixon ginsberg hofer luks parkes 

generalizing boolean satisfiability iii implementation 
tech 
rep time systems eugene oregon 
dixon ginsberg parkes 

generalizing boolean satisfiability background survey existing 
journal artificial intelligence research 
ginsberg 

dynamic backtracking 
journal artificial intelligence research 
ginsberg parkes 

search 
proceedings seventh international conference principles knowledge representation reasoning breckenridge colorado 
zap theory 

logical reduction methods zero programming 
operations research 
haken 

intractability resolution 
theoretical computer science 
harrison 

switching automata theory 
mcgraw hill 
hooker 

generalized resolution cutting planes 
annals operations research 
jerrum 

compact representation permutation groups 
algorithms 
knuth 

notes efficient representation permutation groups 
combinatorica 
krishnamurthy 

short proofs tricky formulas 
acta informatica 
li 

integrating reasoning davis putnam procedure 
proceedings seventeenth national conference artificial intelligence pp 

luks 

permutation groups polynomial time computation vol 
dimacs series discrete mathematics theoretical computer science pp 

amer 
math 
soc 
mciver neumann 

enumerating finite groups 
quart 
math 
moskewicz madigan zhao zhang malik 

chaff engineering efficient sat solver 
th design automation conference 
nemhauser wolsey 

integer combinatorial optimization 
wiley new york 


lower bounds resolution cutting planes proofs monotone computations 
symbolic logic 


enumerating finite groups order 
ann 
math 


theory groups 
springer 


preprocessing probing mixed integer programming problems 
orsa journal computing 
seress 

permutation group algorithms vol 
cambridge tracts mathematics 
cambridge university press cambridge uk 


complexity resolution generalized symmetry rules 
alt 
eds proceedings stacs volume springer lecture notes computer science pp 

tseitin 

complexity derivation propositional calculus 

ed studies constructive mathematics mathematical logic part pp 

consultants bureau 
dixon ginsberg luks parkes zhang stickel 

implementing davis putnam method 
journal automated reasoning 

