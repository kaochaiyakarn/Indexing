automatic generation vulnerability signatures david james newsome dawn song carnegie mellon university pittsburgh pa usa cmu edu explore problem creating vulnerability signatures 
vulnerability signature matches exploits vulnerability polymorphic metamorphic variants 
departs previous approaches focusing semantics program vulnerability exercised sample exploit semantics syntax exploit 
show semantics vulnerability define language contains inputs exploit vulnerability 
vulnerability signature representation regular expression vulnerability language 
signatures error rate empirically measured known test cases quality vulnerability signature formally quantified possible inputs 
provide formal definition vulnerability signature investigate computational complexity creating matching vulnerability signatures 
systematically explore design space vulnerability signatures 
identify central issues vulnerability signature creation vulnerability signature represents set inputs may exercise vulnerability vulnerability coverage number vulnerable program paths subject analysis signature creation vulnerability signature created representation coverage 
propose new data flow analysis novel adoption existing techniques constraint solving automatically generating vulnerability signatures 
built prototype system test techniques 
experiments show automatically generate vulnerability signature single exploit higher quality previous exploit signatures 
addition techniques security applications may independent interest 
hao wang jha university wisconsin madison madison wi usa jha cs wisc edu vulnerability type bug attacker alter intended operation software malicious way 
exploit actual input triggers software vulnerability typically malicious intent devastating consequences 
popular effective exploit defense mechanisms signature input filtering called content filtering improvements signature generation widespread impact 
need automatic signature generation techniques manual signature generation slow error prone 
fast generation important previously unknown zero day vulnerabilities exploited orders magnitude faster human respond worm outbreak 
automatic techniques potential accurate manual efforts vulnerabilities tend complex require intricate knowledge details realizable program paths corner conditions 
understanding complexities vulnerability consistently proven difficult humans source code level cots software assembly level 
challenges automatically creating signatures 
task automatically constructing signatures complicated fact usually different polymorphic exploit variants trigger software vulnerability 
example buffer overrun vulnerability network service may triggered different protocol messages 
example referred exploit variants may differ syntactically semantically equivalent exploit different assembly instructions effect 
approach need distinguish polymorphism referred polymorphism 
morphing tools publicly available automatically generate polymorphic exploit variants 
effective signature constructed property vulnerability exploit observation 
limitations previous approaches 
importance signature generation problem prompted researchers investigate automatic signature generation techniques 
previous approaches fall categories require manual steps employ heuristics may fail settings techniques rely specific properties exploit return addresses vulnerability signatures limited underlying signature representation generate specific vulnerabilities specific circumstances 
example approach pattern extraction methods syntactically identify bit patterns appear attack samples innocuous samples 
techniques incapable handling polymorphic worms vulnerable adversarial environment attacker inject false superfluous tokens learning red herring attack 
approach application exploit semantic information 
techniques heuristics rely specific properties exploits value overwrite return address invariant 
shown previously heuristics may real world vulnerabilities 
addition previous line systematically explored design space signature creation focusing single design point creating regular expressions control hijacking attacks 
regular expressions recognize simple syntactic properties may precise settings regular expressions recognize vulnerability valid invalid checksums need distinguished 
approach roadmap central issues 
approach departs previous analyzing vulnerability uncovered new exploit attack analyzing exploit 
high level main contribution new class signature call vulnerability signature specific details exploit successfully control program executing input potentially result unsafe execution state 
formal approach reasoning vulnerability signatures 
intuitively vulnerability signature matches set inputs strings satisfy vulnerability condition program 
vulnerability condition specification particular type program bug memory writes allocated buffer space 
systematically explore design space vulnerability signatures identify important dimensions signature represented expressiveness trade matching accuracy efficiency vulnerability covered signature trade amount analysis performed signature false negative rate 
develop new techniques creating vulnerability signatures different representations 
focus representations highlight inherent accuracy efficiency creation time trade offs design space turing machine signatures symbolic constraint signatures regular expression signatures 
contributions 
presents systematic approach formal model methods create vulnerability signatures static program analysis 
require single sample exploit initially identify vulnerability 
automatic signature generation approach applicable vulnerabilities vulnerability condition formally specified 
approach uncovers rich new domain representing signatures new techniques creating 
particular provide formal definition vulnerability signatures 
approach leads new perspective vulnerability signature represented different language classes different expressive powers 
explore design space vulnerability signature show inherent trade signature matching accuracy different representations 
particular perfect signature created turing machine signatures section matching may take unbounded amount time 
hand signatures allow fast matching accurate regular expression signatures section 
introduce notion vulnerability signature coverage 
see challenge vulnerability may reachable infinite number paths program presence looping 
show iteratively consider path separately signature generation scale 
methods allow identify created vulnerability signature approximates perfect vulnerability signature 
specifically setting identify control imprecision introduced 
property easy quantify quality generated vulnerability signature 
develop new static analysis techniques regular expression data flow framework section novel existing techniques program chopping constraint satisfaction problem domain 
provide prototype implementation techniques automatically create signatures real world vulnerabilities 
prototype addresses automatic signatures creation hardest scenarios program binary 
require source code type information prototype applicable cots software 
results show techniques automatically generate signatures higher quality previous techniques 
vulnerability signature section give formal definition vulnerability signature 
intuitively vulnerability signature representation set inputs satisfy specified vulnerability condition vulnerability conditions formally defined section 
explore dimensions design space vulnerability signatures signature representation coverage 
roughly speaking design points signature representation dimension trade matching accuracy matching efficiency 
design points vulnerability signature creation dimension trade creation time signature coverage program paths analyzed 
problem setting 
motivate approach vulnerability signatures setting new exploit just released unknown vulnerability 
site detected exploit means dynamic taint analysis stack protection wishes create signature recognizes exploits 
site furnish analysis tuple program exploit string vulnerability condition execution trace experiments assembly level assume binary program instruction trace techniques source code level 
goal create vulnerability signature match malicious inputs examining running addition want create signatures quickly scenarios signatures deployed immediately detection value 
take iterative approach generates successively better signatures 
successive signature match exploit variants requiring exploit samples 
running example 
running example 
example language clarity implementation operates program binaries 
example returns url request begins keyword null returned 
example null 
running example returns url request form url null 
assume aaaa 
corresponding trace number corresponding line number 
vulnerability condition heap overflow input satisfies program exploited th iteration line url characters long characters allocated 
vulnerability signature definition vulnerability tuple program sequence instructions ik vulnerability condition defined formally 
execution trace obtained executing program input denoted 
execution trace simply sequence actual instructions executed 
vulnerability condition evaluated execution trace satisfies vulnerability condition denote language vulnerability lp consists set inputs program resulting execution trace satisfies domain inputs formally lp language defined lp exploit vulnerability simply input lp executing input results trace satisfies vulnerability condition vulnerability signature matching function match input returns exploit benign running perfect vulnerability signature satisfies property exploit lp match benign lp show section language lp represented different ways ranging turing machines precise accept exactly lp regular expressions may precise error rate 
soundness completeness signatures 
define completeness vulnerability signature match lp match exploit match accepts lp 
incomplete solutions false negatives 
define soundness lp match benign match accept extra lp unsound solutions false positives 
consequence rice theorem signature representation turing machine sound complete representations pick 
setting focus soundness tolerate false negatives false positives 
section show reformulate algorithm generate complete unsound signatures 
vulnerability conditions vulnerability condition function takes instruction current program state returns exploit indicating benign new program state reflecting execution instruction exploit called vulnerability point 
intuitively vulnerability point instruction may cause unsafe execution bounds write line running example 
formally vulnerability condition function benign exploit memory including state variables vulnerability condition set variables defined program map memory locations values continuation stack instruction execute 
formally execute instruction order trace instruction affect vulnerability condition state variables 
scenario local memory vulnerability detection algorithm may keep track important variables bounds allocated memory binds values registers normally soundness lp stating equivalent contra positive 
note strictly necessary convenient assume vulnerability condition memory separate evaluation stack cisc instructions may dereference calculated memory address instruction addr value map bit memory locations values including stack heap addresses 
encode algorithm described section inline encoding original program vulnerability point signature creation 
note need specified type vulnerability 
contribution specify vulnerability condition assume 
note entire programming languages specified similar manner formal operational semantics techniques apply vulnerability condition stated algorithm 
running example vulnerability condition check dereference sure allocated bounds 
way accomplish shadow pointer safe pointer value records base address size memory allocated 
dereference checked see corresponding safe pointer bounds 
formal operational semantics vulnerability condition may look exp exp vn benign exploit rule says order calculate memory dereference form exp exp evaluated 
exp resolved address second rule says lookup context get safe pointer 
safe pointer contains base address size dereferenced value range specified benign returned exploit 
signature representation classes explore space different language classes represent lp vulnerability signature 
signature representation pick determines precision matching efficiency 
investigate concrete signature representations reflect intrinsic trade offs accuracy matching efficiency turing machine signatures symbolic constraint signatures regular expression signatures 
turing machine signature precise false positives negatives 
matching turing machine signature may take unbounded amount time loops applicable scenarios 
symbolic constraint signatures guarantee matching terminate loops approximate certain constructs benign exploit benign 
tm signature running example program looping memory aliasing may lead imprecision signature 
regular expression signatures extreme point design space matching efficient elementary constructions counting approximated accurate representations 
turing machine signatures 
turing machine tm signature program consisting instructions lead vulnerability point vulnerability condition algorithm inlined 
paths lead vulnerability point return benign paths lead vulnerability point satisfy vulnerability condition return exploit 
tm signatures precise trivial tm signature error rate emulating full program 
tm signature running example symbolic constraint signatures 
symbolic constraint signature set boolean formulas approximate turing machine signature 
turing machine signatures loops matching evaluating symbolic constraint signature input terminate loops 
symbolic constraint signatures approximate constructs loops memory updates statically 
result symbolic constraint signatures may precise turing machine signature 
represent inclusive range inp means input bytes inclusive 
symbolic constraint signature considerable simplification readability running example 
signature states byte input matches signature input byte followed space characters followed path program path program control flow graph 

symbolic constraint signature running example 
non space characters 
non space characters needed order overflow byte allocated url buffer 
note signature created unrolling loops lines tm signature 
example statically infer times unroll loop general inferences possible upper bound unroll loops provided approach taken bounded model checkers 
regular expression signatures 
regular expressions powerful signature representation may considerable false positive rate circumstances 
example known limitation regular expressions count succinctly express conditions checking message proper checksum simple inequalities 
regular expression signatures widely practice 
regular expression signature produce running example data flow techniques described section matches input begins followed zero spaces followed represented non space characters signature types 
main contributions construction language class may represent signature 
signature user free pick appropriate representation situation 
leave systematic formal investigation signature representations context free languages 
signature operations efficiency summarize upper bounds various signature operations table 
due space constraints prove bounds extended version 
vulnerability language lp recognized vulnerability signature representation match operation 
matching efficiency primary concern picking signature representation 
turing machine signature representation creation signature size matching minimization equivalence turing machine sig 
poly poly undecidable undecidable undecidable symbolic constraint sig 
poly poly poly exp exp regular expression sig 
poly exp exp table 
summary approximate bounds vulnerability signature representations consider program length signature size poly denotes function polynomial exp denotes function exponential matching undecidable matching reduced halting problem symbolic constraint signatures matching done polynomial time 
regular expression matching performed linear time 
tm signatures created encoding inlining vulnerability condition takes polynomial time 
symbolic constraint signature generation requires creating tm signature additional polynomial time transformation unrolling loops fixed number times 
regular expression signature creation entails solving symbolic constraint signature may take exponential time fact pspacecomplete performing data flow analysis original program takes polynomial time 
accurately represents solutions symbolic constraints approximates original program dataflow analysis accurate see section 
signature merging important operation 
model merging signatures equivalent performing single analysis lab la lb union languages vulnerabilities 
union operation tm signatures done creating new condition cab ca cb evaluates true ca cb union operation symbolic constraints disjunction individual constraints constraint system satisfied 
union operation regular expression operator 
monomorphic execution path mep polymorphic execution path pep signature coverage introduce notion vulnerability signature coverage create vulnerability signature respect subset program paths exploit may follow 
ability consider subset paths vulnerability opposed program paths exploit may follow important creating signature program paths lead vulnerability may expensive 
signature creation techniques take iterative approach order scalable successively improve signatures considering small coverage incrementally increasing coverage include program paths vulnerability 
consider single path program input may take satisfies vulnerability condition call monomorphic execution path mep coverage 
initial mep path usually path taken sample exploit 
mep covers program instructions executed exploit single path vulnerability point excluding statements effect computation line sample exploit semantically op respect vulnerability 
mep conditional branch encountered target instruction leading vulnerability point target state benign 
mep straight line program 
vulnerability point vulnerability condition evaluated returns benign ex 
vulnerability signature consists inputs reach exploit state 
note straight line programs imply single input leads vulnerability point usually exists inputs reach vulnerability point vulnerability condition evaluates exploit 
example exploits usually payload executes arbitrary attacker code 
straight line program return exploit exploits different payloads execution different variants differ vulnerability condition satisfied 
polymorphic execution path pep coverage includes different paths vulnerability point 
complete pep coverage includes paths vulnerability point 
complete pep coverage signature accepts inputs lp signature complete 
formally complete coverage obtained generating signature chop program includes instructions may executed read statement exploit may read vulnerability point 
chop distinguished nodes 
corresponds input read statement multiple input read statements exist node connected read statement control flow graph 
corresponds inlined vulnerability condition branch returning ex 
outline algorithm computing chop section 
signature creation algorithm initially mep path consisting instructions executing exploit trace compute program chop vulnerability initial read sample exploit vulnerability point 
chop contains possible execution paths exploit read trace vulnerability point 
initially create signature mep path execution trace iteratively improve considering paths 
running example mep coverage consists instructions executed trace 
complete pep coverage consists lines excluding line 
automatic vulnerability signature creation high level algorithm computing vulnerability signature program vulnerability condition sample exploit corresponding instruction trace depicted 
section detail perform steps 
pre process program exploit received disassembling program section 
converting assembly intermediate representation ir section 

compute chop respect trace chop includes paths vulnerability point including taken sample exploit section 

compute signature compute turing machine signature section 
final representation 
compute symbolic constraint signature tm signature section 
final representation 
compute regular expression signature symbolic constraint signature section 
disassembling binary program converting ir disassemble binary identify function boundaries 
require symbol table functions identified prologue epilogue 
convert disassembled instructions intermediate representation ir 
ir disambiguates instructions making implicit hardware side effects explicit 
step seemingly straight forward fairly involved 
main complication address modern architectures implicitly set test hardware registers affect program execution tests sets appear explicitly assembly 
example overflow flag may automatically set executing arithmetic operation tested conditional jump 
complication register may indexed different modes lower bits eax register instruction affecting simultaneously affect eax ir 
concretely instruction set contains instructions perform hardware test set operations register 
extra ir statements added operations reflect updates done hardware 
worse statements add specific particular mode operands 
architecture bit mode bit mode set depending format instruction operands 
example add ax bx addition bit mode registers specified bits long 
overflow carry flag implicit hardware assisted effects set respect bits 
similar instruction add eax ebx bit mode implicit hardware effects done respect bits 
perform remaining steps program chopping vulnerability signature creation ir statements 
computing chop ir compute chop vulnerability respect exploit trace discussed section 
note chopping algorithm results imprecise chop lack pointer analysis 
result chop smaller program path begins read statement trace ends vulnerability point 
select signature generation step set paths compute signature 
perform chop program callgraph 
chop contains functions may executed reading exploit vulnerability point 
chop performed essentially doing reachability analysis function call sequence may reach vulnerability point included 
callgraph directed graph function vertex edges represent caller callee relationship functions 
perform algorithm callgraph create chop start ir statement read statement exploit trace vulnerability point trace functions enclosing nodes respectively 
note path appears trace 
add extra edge resulting loop callgraph 
calculate strongly connected component scc containing 
scc chop contains reachable functions 
disassemble convert ir binary program exploit trace compute chop vulnerability condition select paths chop create tm sig turing machine signature symbolic execution constraint constraint generation solving symbolic constraint signature regular expression signature 
high level view steps compute vulnerability signature 
problem deal binary level widespread indirect jumps jmp eax indirect jmp direct 
note indirect jumps correspond source code constructs function pointers compiler generated optimizations 
central issue target indirect jump potentially instruction 
result control flow graph including dependency graphs edge indirect jump instructions 
order deal widespread indirect jumps binaries pointer analysis creating callgraph target indirect jump special node 
algorithm computing chop essentially ignore indirect jumps chop computed 
computing chop constrain indirect jump target chop 
limitation approach technically incorrectly excluding function appears target indirect jump 
indirect jump problem may may disappear implemented function pointer analysis 
remains unclear point precisely analysis able pin targets indirect jumps 
computing signature compute signature respect chop 
compute pep signature iteratively considering single mep paths data flow analysis optimization 
iterative method works pick path set paths chop perform analysis output corresponding vulnerability signature 
complete pep coverage signature section analysis paths chop 
describing compute complete pep tm signature turn input symbolic constraint regular expression signature generation 
benign benign benign benign benign benign exploit 
mep tm signature running example 
turing machine signature generation mep turing machine signature generation 
initial mep turing machine signature created respect path followed instruction trace 
initial signature match sample exploit certain exploit variants changing exploit payload 
create initial mep tm signature reading instruction trace including corresponding ir statements 
sequential instructions trace correspond sequential statements mep turing machine signature 
conditional branch statements exactly targets ir signature creation benign exploit 
branch lead vulnerability point returns benign 
exploit returned vulnerability point reached vulnerability condition satisfied 
encode vulnerability condition function 
vulnerability point insert jump function final check see program vulnerable state returns exploit satisfied 
shows mep vulnerability signature return running example vulnerability check inlined 
pep turing machine signature generation 
pep turing machine signature created similar mep turing machine signature 
pep signature computes chop computes jump targets lead vulnerability point standard graph reachability analysis 
paths terminate lead vulnerability point return benign 
insert call vulnerability condition function vulnerability point returns benign exploit 
shows complete pep vulnerability signature vulnerability condition inlined 
symbolic constraint signature generation symbolic constraint signature set constraints exploit vulnerability satisfy 
tm signature input symbolic constraint signature generation high level generate constraints represent meeting correct conditionals tm reach vulnerability point satisfy vulnerability condition 
symbolic constraint signature approximation tm signature may statically estimate effects loops memory updates constraints input 
symbolic constraint system built symbolically evaluating tm signature program symbolic inputs actual inputs values 
formally build constraints symbolically executing paths tm 
function tm signature represented control flow graph cfg direct graph ir instruction node transfer control instructions edge distinguished entry exit nodes 
conditionals control flow graph constraints take appropriate branch reach vulnerability point satisfy vulnerability condition 
single static assignment ssa form 
convert ir single static assignment ssa form prior symbolic constraints step performed pre processing phase 
normally memory locations registers destructively updated times lifespan program destructively updates right hand side rhs assigning left hand side lhs 
symbolic execution requires variable treated single logical entity assigned 
ssa form semantically equivalent form program satisfies criteria 
ssa form sequential statements just unique renaming lhs 
example 
control statements ssa introduces special assignment called functions merges possible definitions variable 
example statement assigned true branch false branch 
mep symbolic execution 
perform mep symbolic execution evaluating mep tm signature 
recall mep tm signature straight line program 
single path goes vulnerability point vulnerability condition 
paths returning benign need considered 
result symbolic execution set constraints input variables met results execution vulnerability point inlined vulnerability condition 
creating symbolic input variables length symbolic input consider initially length sample exploit statement executed inputs resulting symbolic formula step 
fundamental operation types evaluate symbolically memory updates arithmetic operations branch predicate evaluation 
symbolic execution arithmetic operations simply substitution procedure 
example memory store operation assignment value symbolic memory location stack heap assignments handled uniform fashion 
adopt model similar handling memory updates 
initial state 
reads writes modeled expressions write memory location value yields new addr ite addr addr result write ite expression 
subsequent read behaves follows address read applied argument write expression 
supplied address matches returned recurse memory address addr 
loss generality assume branch predicate je jump equal jz jump zero vi evaluates true order create desired total path 
branch predicate forms arithmetic constraint expressions involving memory reads writes relating symbolic execution constant jz jz jump zero results constraint 
constraints evaluate constant machine instructions allow comparison expression constant 
total symbolic formula just conjunction branch predicate 
constraint system consisting conditions branch predicate returned desired signature 
optionally constraint systems simplified consists deducing multiple constraints collapsed single constraint 
pep symbolic execution 
pep symbolic execution similar mep case deal loops 
loops handled computing fixed points 
data flow analysis widening operator guarantee iteration compute fixed point terminates 
currently algorithm handle loops identify induction variables chapter loop 
example induction variable loop compute bounds induction variable bound induction variable 
assume induction variable index input array condition loop 
condition loop bounds induction variable gives desired result 
loop condition generated regular expression signature generation computing mep regular expression signatures method generating regular expression solve constraint system set ing members regular expression method explored heavily test case generation literature 
adopt approach problem setting 
divide conquer 
number variables consider single path may large millions variables assembly level 
address reader may notice expression precise wonder solution precise 
answer precise symbolic representation symbolic representation loop regular expression signature reflect inputs may cause loop executed time 
problem decomposing mep single path solution smaller sub paths consider independently 
mep path 
sub path sequence instructions cfg 
subpath independently evaluated respect sub path computation affect computation vice versa 
formally partition partition data dependencies sub path data dependency exists computes value uses 
computation sub path affect computation sub path sub path independently solved final solution combined 
solution sub path computed solving corresponding constraint system sub path 
full path conjunction sub paths 
mep solution 
approach allows divide single mep possibly smaller sub problems 
mep path correspond evaluating symbolic input order 
sub paths independent reorder sub paths case 
signature mep concatenation solution sub path 
solution si resulting signature sn 
computing pep regular expression signatures consider approaches computing pep solution 
method considers mep path pep independently solves symbolic constraints exactly 
second method optimization data flow analysis applied portions pep control flow graph certain conditions stated met 
data flow analysis optimization works basic blocks paths require access constraint solver 
exact pep solution 
pep solution iteratively explores paths solves mep solution 
note practice create initial mep signature sample exploit process paths background 
approach generates initial narrow signature quickly continues refine perform analysis 
pep data flow optimization 
cases may able determine data dependencies partition vulnerability components cfg components direct comparisons input values 
example protocols keywords constant values specific fields input simply compared 
data flow analysis efficiently compute language accepted components 
component data dependencies components solution component inlined complete pep mep solution 
high level data flow analysis iteratively processes cfg fixed point data flow facts reached 
data flow analysis widely compilers highly efficient 
data flow analysis combines regular expressions accepted basic block block contiguous instructions single entry exit point regular expression accepted entire component 
due space constraints give rough overview dataflow analysis leave discussion extended version 
high level cfg edge labeled set data flow facts case regular expression accepted basic block true edges negated regular expression false edges 
key component data flow analysis specifying meet operator summarizes multiple incoming edges node combined combining regular expression point confluence incoming edges 
operator states combine regular expressions confluence point confluence point corresponds regular expression 
running example instructions line analyzed independently data flow analysis resulting regular expression byte input 
note realistic programs usually larger components example amenable data flow analysis 
evaluation implementation implemented prototype system evaluate techniques automatically generating signatures 
section briefly discuss implementation details prototype evaluation results 
evaluation results show mep vulnerability signature far higher quality signatures generated previous approaches 
focus creating regular expression signatures require generation turing machine symbolic constraint signature 
implementation total prototype implementing techniques lines code 
currently bounded model checker help build solve symbolic constraints produce regular expression signatures 
disassembling program converting ir obtaining instruction traces 
binary program disassembler 
translate instruction appropriate ir statement translation language 
instruction traces efficiently generated modern architectures including hardware software 
instruction trace contains instruction address optionally value operands instruction executed 
number instructions executed may large corresponding trace efficiently represented 
currently pin create traces 
solving constraint system 
model checking solve system constraints 
translate constraints constraints variables 
assert model checker vulnerability condition unsatisfiable 
model checker verify vulnerability condition unsatisfiable solve constraint system counter example construction satisfying input 
process iterated exhaustively enumerate possible satisfying inputs exploits 
regular expression signature satisfying inputs 
process may slow input byte may values 
currently apply widening operator byte appears unconstrained iterations wild card byte 
widening step may introduce false positives eliminated desired 
show precise regular expression signature generation reduced model checking problem extended version 
exploring precise generation techniques techniques practical examples may theoretically limited area 
implementation limitations 
current implementation prototype researching automatic signature generation 
prototype works research setting number limitations 
mentioned previously alias analysis currently supported 
specifically assume memory locations aliases 
addition possible imprecision may introduce symbolic execution limitation prevents computing true chop 
current chopping algorithm precise true chop source code despite fact primarily model checker 
primarily results larger mep pep coverages necessary 
second currently create sub paths control flow analysis may accurately identify sub paths independent section 
ir transformations handle floating point operations currently support entire instruction set add operations needed experiments 
limitations orthogonal problem resolved implementing known techniques 
currently manually verify problems introduce errors results 
mep evaluation webserver written 
version vulnerable common sprintf style request long 
specifically exploit vulnerability meet conditions request method get head byte requested file name followed requested filename contain substring requested filename characters long 
exploit sample consists request get followed shell code followed protocol string 
experiment vulnerability condition pointer able write return address 
signature result quality 
generated symbolic constraints partitioned distinct subpaths analyzed independently 
solved constraints create regular expression little second average time partition 
generated regular expression signature 
regular expression perfect necessary conditions reach vulnerability stated previously 
particular recognizes get keyword case insensitive bytes 
bytes constraints signature contained exploit explicitly tested mep vulnerability path exploit took 
contrast signature previous exploit specific signature generation approaches best identify small parts signature match different exploit variants crashes server injecting code 
signatures catch exploit variants single exploit sample 
bind bind popular dns servers 
bind supports secret key transaction authentication mechanism messages signed transaction signature 
bind susceptible stack overflow vulnerability processing code 
attacker send valid dns transaction signature request order exploit vulnerability 
dns binary protocol messages struct 
dns exploit tcp udp consider udp protocol messages 
dns messages header followed number resource records rr 
exploit vulnerability satisfy conditions request query represented byte message questions meaning field specifying number questions byte offsets greater zero properly encoded questions starting offset field specifying number additional resource records byte offsets greater zero dns contain resource record type field set af 
dns may different resource records single request specific byte offset field function fields request 
vulnerability exploit lion worm sample exploit 
signature result quality 
generated symbolic constraints partitioned distinct graphs independently analyzed 
generated regular expression signature specified bytes zero bytes indicate query exploit byte byte query bytes fa byte additional resource records section followed field type 
verify constructed signature identified constraints met exploit vulnerability 
verified rate signature matching dns requests trace taken high traffic dns server serves top level domains 
false positives 
pep evaluation chop took functions reachable accepting connection vulnerability point including libraries 
mentioned previously technique generating pep signature consider mep path independently 
technique estimate effects multiple paths simultaneously 
current prototype implementation technique limited moderate sized functions 
unfortunately bind vulnerabilities extremely large library function consists basic blocks 
addressing scalability issues important part 
expect existing state reduction techniques model checking help solve problem 
evaluate pep techniques synthetic examples 
compile running example binary calculate full pep solution 
regular expression generated 
total time compute answer seconds 
alternatively tool produce regular expression independent component pep data flow facts produce final signature 
setting tool runs slightly faster perform symbolic evaluation possible paths 
discussion provide extensive analysis including proofs hardness signature creation data flow framework extended version 
application scenarios 
high level techniques generate input string reaches instruction binary 
applications techniques plan investigating include improve existing pattern extraction signature generation algorithms 
quality signature generated pattern extraction techniques generally improves number exploit samples increase 
techniques iteratively generate new exploit sample different sample exploit scenario give pattern extractor labeled exploit uses improve existing signature 
note previous scenarios pattern extraction limited addition may able label tokens may help analysis 
note analysis help defend red herring coincidental token attacks 
perform robust vulnerability identification 
known known bug exploitable 
developer set appropriate read statement line bug 
techniques generate sample exploit possible confirming bug exploitable 
vendor patches possible paths vulnerability 
missing alternate paths security problem embarrassment vendor patched systems may compromised 
techniques adapted see patch covers possible ways vulnerability may exploited 
complete unsound signatures 
satisfying solution generated symbolic equations exploit string signature sound complete 
complete potentially unsound signature false negatives false positives created setting initial signature removing input leads state 
identifying sources signature imprecision 
construction allows signature creator tune accuracy generation time ways 
creator choice signature representations 
second creator choose information retain expressive representations 
example creating symbolic representation creator may choose times loops unrolled 
third creator choose analysis perform 
example creating regular expression signature theorem proving employed enumerate input string may exploit program faster accurate data flow analysis 
believe choices allow creator gain fundamental understanding accuracy final generated signature comparing generated signature perfect tm signature 
related signature creation 
section detailed previous area 
mention independently proposed signatures essentially straight line programs regular expressions mep symbolic constraint signatures 
creates signature execution path taken sample exploit explore extensive coverages vulnerability signature representations 
estimating language classes 
significant part creating vulnerability signature boils conservatively estimating higher powered language turing machine lower power language regular expression 
techniques provide way accomplishing 
example mohri nederhof algorithm converting certain context free languages regular expressions 
unaware significant area 
program analysis 
static analysis techniques symbolic execution interpretation model checking theorem proving dataflow analysis program slicing 
areas active research area benefit new advanced techniques 
impossible note related static analysis reader referred overview subject 
automatic test case generation research explores problem automatically creating input reaches particular point program 
interested similar problem want approximate inputs reach certain location 
problem setting relaxed may tolerate signatures false positives negatives 
closely related area static analysis program generated string expressions 
line aims discovering possible strings generated opposed accepted program 
christensen performed string analysis java programs type information available 
extended christensen binaries 
techniques exciting research needed apply techniques problem setting 
particular approach handles strings types integers 
general framework obtaining new type signature called vulnerability signatures 
single sample exploit techniques automatically generating signature higher quality previous approaches 
addition formulation opens wide variety signature representations 
particular discuss distinct types vulnerability signature representations turing machine symbolic constraints regular expressions 
provide theoretical practical insights signature representations 
conclude approach promising alternative techniques 

www cag lcs mit edu 

www ca tar gz 

org 
aho sethi ullman 
compilers principles techniques tools 
addison wesley publishing 
bosch 
complete instruction trace generation hardware bus collect 
rd ieee euromicro conference 
bourdoncle 
efficient chaotic iteration strategies widenings 
proc 
international conference formal methods programming applications lncs 

liu song 
design space analysis worm defense systems 
proc acm symposium information computer communication security 
cmu tr cmu cs 
newsome song wang jha 
automatic generation vulnerability signatures 
technical report cmu cs carnegie mellon university 
bryant lahiri 
modeling verifying systems logic counter arithmetic lambda expressions uninterpreted functions 
proc 
computer aided verification cav 
engler 
execution generated test cases system code crash 
technical report cstr stanford 

story dumb patch 

com research pdf 
cert cc 
isc bind contains buffer overflow transaction signature handling code 
www kb 
cert org id 
christensen ller schwartzbach 
precise analysis string expressions 
proc 
th international static analysis symposium sas volume lncs pages 
springer verlag june 
available www brics dk jsa 
kidd 
goh 
string analysis binaries 
proc 
th acm workshop program analysis software tools engineering paste 
clarke grumberg peled 
model checking 
mit press 
clarke 
tool checking ansi programs 
jensen podelski editors tools algorithms construction analysis systems tacas volume lecture notes computer science pages 
springer 
cost crowcroft castro rowstron zhou zhang barham 
containment internet worms 
th acm symposium operating system principles sosp 
cousot cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc 
th acm symposium principles programming languages popl jan 
crandall su wu chong 
deriving unknown vulnerabilities zero day polymorphic metamorphic worm exploits 
proc 
th acm conference computer communications security ccs 
detlefs nelson saxe 
simplify theorem prover program checking 
technical report hpl hp labs 

polymorphic shellcode engine spectrum analysis 
www phrack org show php 
godefroid klarlund sen dart directed automated random testing 
proc 
international conference programming language design implementation pldi 
botella 
automatic test data generation constraint solving techniques 
acm symposium software testing analysis 
botella 
clp framework computing structural test data 
international conference computational logic 
gupta mathur soffa 
automated test data generation iterative relaxation method 
acm sigsoft symposium foundations software engineering 
hopcroft motwani ullman 
automata theory computation 
addison wesley 
jackson rollins 
chopping generalization slicing 
proc 
second acm sigsoft symposium foundations software engineering 
jordan 
dealing 
virus bulletin magazine 
kildall 
unified approach global program optimization 
st acm symposium principles programming languages popl 

kim karp 
automated distributed worm signature detection 
proc 
th usenix security symposium august 
king 
symbolic execution program testing 
communications acm 
crowcroft 
creating intrusion detection signatures honeypots 
proc 
second workshop hot topics networks hotnets ii november 
robertson vigna 
worm detection structural information executables 
rapid advances intrusion detection raid 
robertson vigna 
static disassembly obfuscated binaries 
proc 
th usenix security symposium 
liang sekar 
fast automated generation attack signatures basis building self protecting servers 
proc 
th acm conference computer communications security ccs 
wang keromytis stolfo 
flips hybrid adaptive prevention 
proc 
th international symposium advances intrusion detection raid 

luk cohn muth patil lowney wallace 
pin building customized program analysis tools dynamic instrumentation 
proc 
programming language design implementation pldi conference june 
milenkovic milenkovic 
tuple compression novel method compression branch instruction traces 
proc 
th international conference parallel distributed computing 
mohri 
nederhof 
robustness language speech technology 
kluwer academic publishers 
moore shannon voelker savage 
internet quarantine requirements containing self propagating code 
ieee infocom conference 
muchnick 
advanced compiler design implementation 
academic press 
nethercote seward 
valgrind program supervision framework 
proc 
third workshop runtime verification rv boulder colorado usa july 
newsome karp song 
polygraph automatically generating signatures polymorphic worms 
proc 
ieee symposium security privacy may 
newsome song 
dynamic taint analysis automatic detection analysis signature generation exploits commodity software 
proc 
th annual network distributed system security symposium ndss february 
pierce 
types programming languages 
mit press 
code 
exploit 
www 
com mailing lists todays att ramin 

www redshift com atp 
reps 
precise interprocedural chopping 
proc 
third acm sigsoft symposium foundations software engineering 
liao cook schultz de nicolas 
bus driven instruction trace tool powerpc microprocessors 
ibm journal research development 
singh estan varghese savage 
automated worm fingerprinting 
proc 
th acm usenix symposium operating system design implementation osdi dec 
staniford paxson weaver 
wn internet spare time 
th usenix security symposium 

hunting metamorphic 
virus bulletin conference 
uhlig mudge 
trace driven memory simulation survey 
acm computing surveys 
cert 
vulnerability note vu isc bind contains buffer overflow transaction signature handling code 
www kb cert org id 
wellington 
rfc secret key transaction authentication dns 
www ietf org rfc rfc 
txt 
wang guo simon 
shield vulnerability driven network filters preventing known vulnerability exploits 
proc 
acm sigcomm conference august 
weiser 
programmers slices debugging 
communications acm 
xu ning kil zhai 
automatic diagnosis response memory corruption vulnerabilities 
proc 
th acm conference computer communication security ccs 
