compact adaptive placement schemes non uniform capacities andr heinz institute dept electrical engineering university paderborn paderborn germany hni de kay heinz institute dept mathematics computer science university paderborn paderborn germany kay hni de christian scheideler dept computer science johns hopkins university charles street baltimore md usa scheideler cs jhu edu study problem designing compact adaptive strategies distribution objects heterogeneous set servers 
ideally strategy allow computation position object low time space complexity able adapt near minimum amount replacements objects changes capabilities servers objects distributed servers capabilities 
previous techniques able handle requirements part 
example standard hashing techniques achieve non uniform distribution objects set servers time space efficient computation position objects usually adapt change capabilities 
strategies hashing achieve goals 
furthermore give list applications strategies demonstrating efficiently distributed data management web caches adaptive random graphs may interest peer peer networks 
categories subject descriptors computer communication networks distributed systems distributed databases data storage representations hash table representations analysis algorithms problem complexity algorithms routing lay supported part dfg massive algorithmen anwendungen 
partially supported emerging technologies programme eu contract number ist alcom ft 
part done member heinz institute paderborn university supported massive algorithmen anwendungen permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
spaa august manitoba canada 
copyright acm 
database management database administration data dictionary directory general terms algorithms theory keywords adaptive hashing non uniform disks balls bins raid distributed data storage web caching random graphs 
study problem designing compact adaptive placement schemes servers non uniform capacities 
particular interested schemes allow achieve goals 
faithful distribution distributing set objects set servers way fraction objects stored server equal close share total capacity system 

efficient localization computing position object low time space complexity 

fast adaptation adapting changing capacities near minimal movement objects 
especially space complexity important aspect space available store lookup table objects tasks solved trivial way 
placement scheme low space complexity called compact 
standard approach achieving items random hash functions 
problem hash functions usually adaptive 
consider example hash function mod mod distribute set objects servers 
new server added left choices replacing require virtually objects replaced adding additional rules force certain set objects replaced new server long run destroy compactness hashing scheme 
compact adaptive placement schemes applications 
consider example storage system consists large collection disks 
time new disks may added old disks may taken fail 
ensure storage system maximum performance desirable distribute data available disks capabilities 
disks system configuration change redistribute data efficient way 
techniques currently practice various raid levels solve problem efficiently 
example virtually data replaced fully integrate new disk existing raid array 
raid levels allow support non uniform disks 
efforts way expand raid levels handle non uniform disks efficiently general solution 
addition re distributing data disks capabilities important able determine disk storing particular data item fast compact way ensure high load data requests handled reasonable amount resources 
problem distributing blocks set disks closely related application web caching evenly distributing number copies original object set web caches see 
web caching introduces new level complexity placement algorithm distributed internet environment client may know participating web caches 
additional task algorithm web caching minimize number copies object required guarantee client sufficiently consistent view web caches copy object client 
important application adaptive placement schemes problem distributing tasks processors distributed system 
adaptivity important may predictable long task executed long extent processor may available 
order exploit full strength distributed system may necessary redistribute tasks processors 
tasks may need exchange information important current position task computed fast compact way 
forth important area adaptive placement schemes may valuable tool adaptation random graphs changes number nodes edges node degrees 
results known construct static random graphs investigated far efficiently adapt example random regular graphs changes stay random 
algorithms solve problem may particular interest peer peer networks random graphs desirable properties low diameter high expansion 
give applications section specify model give overview previous results new results 
model adopt extend standard balls bins model server represented bin object representing data block task represented ball 

set possible bins 
set possible balls system time 
suppose current number balls system current number bins system assume simplicity balls bins numbered consecutive way starting numbering gives unique numbers ball bin strategies 
current capacity bin parameter current capacity distribution system defined 
dn 
capacity bin arbitrarily defined storage capacity bandwidth computational power mixture theses parameters 
remainder relative values 
achieved simply dividing original capacity bin capacity system 
goal achieve bin capacity obtains balls 
system may change way number available balls number available bins capacities bins change 
case placement scheme needed fulfills criteria faithfulness scheme called faithful expected number balls places bin arbitrarily small 
time efficiency scheme called time efficient allows fast computation position ball 
compactness call scheme compact amount information scheme requires compute position ball small particular depend logarithmic way 
adaptivity call faithful scheme adaptive case change number balls bins capacities system allows redistribute balls get back faithful distribution 
measure adaptivity placement scheme competitive analysis 
sequence operations represent changes system intend compare number re placements balls performed scheme number re placements balls performed optimal strategy ensures operation distribution balls bins perfectly faithful bin exactly balls 
placement strategy called competitive sequence changes requires re placement expected number times number balls optimal adaptive perfectly faithful strategy need 
clarify definition notice capacity distribution system changes dn optimal perfectly faithful strategy need replacements objects 
example capacity distribution changes bin leaves bin enters system ideally fraction objects moved 
see sections constant describes faithfulness algorithms influences time efficiency compactness algorithms minor influence number replacements balls small 
compare number replacements algorithms ideal bound replacements optimal algorithm 
previous results compact adaptive placement strategies relatively new 
far strategies known uniform capacities available bins capacity 
model represented available bins 
case remains cope situations new bins enter old bins leave system 
karger adaptive hashing strategy faithful competitive resp 
competitive new bins renamed take role departing bins destroy properties shown oblivious 
addition computation position ball takes expected number steps 
data structures need log bits ensure high probability distribution balls deviate constant factor desired distribution 
furthermore extending strategy straightforward way achieve faithful distribution heterogeneous case may require tremendous increase space complexity see section 
alternative competitive placement strategy uniform demands 
scheme requires log bits log steps evaluate position ball 
furthermore keeps deviation desired number balls bin extremely small high probability number balls fulfills ln maximum number balls bin bounded ln 
scheme achieves high probability log bits 
scheme extendable straight forward way non uniform capacities see attempts 
adaptive placement strategy proposed sanders 
considers case bins fail suggests set forwarding hash functions time set bins intact time included range 
description strategy cope reasonably failed disks runs problems number disks grows 
new results best knowledge strategies extendable non uniform demands significant increase memory losing faithfulness condition bad adaptivity explanations see section 
new strategies called share sieve compact faithful arbitrary non uniform capacity distributions competitive arbitrary changes capacity distribution arbitrarily small 
demonstrate strategies interesting applications distributed data management web caching adaptive random graphs may interest peerto peer networks proving additional properties share sieve important areas 
tools results need called chernoff hoeffding bounds 
lemma chernoff hoeffding 
consider set independent random variables 
xn take values range 

holds pr min pr overview sections analyze new strategies share sieve 
give applications including distributed data servers web caching generation adaptive random graphs 
finished 

share strategy share strategy works phases 
phase handles heterogeneous capacities bins data structure containing intervals appropriate length bin allows reduce non uniform placement problem uniform placement problem 
ball result phase set bins equally contain second phase strategy uniform capacities determine bin stores share strategy requires subroutine adaptive hashing strategy uniform capacities 
say system uniform capacities available bins uniform case capacities change new bins enter system old bins leave system 
strategies noted previous results section competitive uniform case 
give example strategy karger useful goals 
nearest neighbor strategy start strategy called nearest neighbor solves problem redistributing balls uniform capacities 
works follows suppose random function fb set independent random functions 
gk may depend function fb 
maps balls uniformly random real numbers interval function 
maps bins uniformly random real numbers interval 
ball assigned bin closest regard mapping viewing ring assigned bin minimizes min min fb fb 
proofs follows strategy faithful competitive expected sense renaming bins allowed implemented way location ball determined expected constant time 
requires ensure constant factor deviation expected number balls bin 
results space consumption log words assuming word hold log bits including hash functions 
think strategy easily extended cover heterogeneous case allowing bins capacity random points 
require ir cmax cmin points faithful cmax maximum capacity cmin minimum capacity bin 
worst case number points violating severely conditions space complexity 
hand restricting total number points strictly guarantee faithfulness capacity distribution just consider bins capacities constant 
strategies mentioned previous results problems 
non uniform algorithm ready describe share strategy 
mentioned share needs adaptive strategy uniform capacities 
convenience nearest neighbor strategy called command nearest 
call number ball represents set bins nearest neighbor applied 
return value function number bin storing share hash functions addition hash functions nearest neighbor hash function 
maps balls uniformly random real numbers interval hash function 
maps starting points intervals bins uniformly random real numbers 
addition fixed parameters 
stretch factor needed ensure high probability simplify analysis 
specify values 
share works way suppose capacities bins represented 
dn sure bins high capacity complicate proofs strategy bin introduce virtual bins necessary additional bin rest total capacity equal bin left regarded single virtual bin 
easy see transformation creates virtual bins capacity 
virtual bin interval length fixed stretch factor reaches sd mod viewed ring 
assume prevent interval wrapped times 
keeps description analysis share simple 
cx cx cx called contention point total number endpoints intervals cut frames frame cx important ensure data structures share low space complexity 
computation position ball simply done calling nearest 
algorithm share input number ball data structure containing intervals output bin number stores phase query data structure point derive interval set phase bin nearest return bin share algorithm 
strategy correctly require point covered interval lemma clarifies case 
lemma 
stretch factor ln sufficient ensure cx ball placed 
proof 
point holds pr cx probabilities independent chernoff bounds ln show probability point having contention cx pr cx cx having frames recall require points consider probability frame contention state lemma time space complexity share 
assume word hold log max bits 
exclude considering time space complexity hash functions 
simply efficient hash function vast pool known hash functions may chosen 
theorem 
suppose number hash functions nearest neighbor share implemented position ball determined expected time space words considering hash functions 
proof 
proof time complexity uses trick 
idea divide segments size min keep separate search structure segment 
case time locate ball equal time compute segment plus time finding right frame give segment time executing uniform 
total number frames expected number frames overlapping segment constant 
expected time call nearest constant total time locate ball constant 
concerning space requirement mentioned proof previous lemma cx 
endpoint interval expected number intervals crossing considering fact interval starts leaves frame borders implies expected number intervals frame 
different frames expected amount words necessary storing set intervals belonging frames 
furthermore words necessary store data structure max segments 
nearest neighbor needs frame intervals words 
total amount space needed share words 
show share faithful 
simplicity treat virtual bins real bins share position defined sx cx sx property lemma 
holds ln sx 
furthermore sx proof 
know lemma cx furthermore chernoff bounds imply pr cx pr cx follows pr sx pr cx pr cx pr sx pr cx pr cx pr cx ln sx probability frames true probability compute sx ln cx 
holds sx pr sx pr sx constant close 
share bin defined sd sx dx property lemma 
holds ln proof 
setting ln follows lemma probability sd sx dx sd dx hand probability sd sx dx sd dx allows prove theorem 
theorem 
share faithful 
proof 
recall nearest neighbor faithful bin points bins balls expected number balls bin brought arbitrarily close 
random variable bx denote number balls precisely dx dx 
recall definition sx denote number balls bx assigned bin furthermore random variable denote load total number balls placed holds sd nearest neighbor faithful holds pr bx pr sx bx sx dx arbitrarily small 
fact sx follows lemma 
sd sd dx arbitrarily small 
way shown md arbitrarily small 
complete description share specify share adapts changing system 
suppose change capacities system 
dn 

note includes new bin enters system simply modelled including value 
case share performs socalled lazy update strategy fixed constant 
specifies laziness share 
share changes capacity bin cause total capacities system deviate endanger results shown long sufficiently small 
share faithful respect true capacity distribution 
capacities bins change balls moved way call uniform results correct position ball 
various ways solving algorithmically focus replacements balls need competitive ratio share 
theorem 
share competitive ratio 
proof 
share random hashing easy see changes number balls require share replace balls order remain faithful 
consider changes capacities bins 
suppose capacity distributions actual distribution bins may identical distribution demanded system lazy update rule new capacity distribution 
chosen 
know 
furthermore know case cx arbitrarily small 
holds expected share bin 
consider fixed bin change 
number replacements caused bin 
outside 
case set causes worst case replacement expected number balls sufficiently small 
holds 
get bound just exchanging positions calculation 
altogether share requires replacement balls changing capacity distribution minimum amount movements required perfectly faithful placement scheme theorem follows 
summarize properties share faithful time space efficient competitive 
drawbacks number balls bin highly concentrated capacity large space complexity depends just complicated scheme remove drawbacks 

sieve strategy describe alternative adaptive hashing strategy drawbacks previous strategy rely extra placement strategy uniform capacities 
strategy requires hash functions assign ball real number chosen independently uniformly random range 
suppose initially number bins equal log cut ranges size demand range bin 
range assigned bin allowed select interval starts lower intervals way described detail ball mapped point interval assigned bin owning 
say range completely occupied bin interval covers range 
bin ranges allowed range completely occupied 
furthermore demand bin total amount interval covered intervals equal slightly deviate assume 
ensures property 
lemma 
capacity distribution possible assign ranges bins fashion bin select intervals total size equal 
proof 
bin allowed partly occupied range ranges partly occupied 
remaining ranges cover range sufficient accommodate ranges completely occupied bins 
suppose assignment bins intervals ranges lemma fulfilled 
propose strategy described distribute balls bins fall back bin specified 
random hash functions 
hl 
initially log parameter specified 
implies result algorithm sieve input number ball output bin number stores set interval bin return return number fall back bin sieve algorithm 
theorem 
sieve implemented position ball determined expected time space words considering hash functions 
proof 
bins occupy exactly half interval probability ball succeeds placed round 
expected computation time ball position 
space requirement words information occupancy ranges stored 
ball assigned bin loop algorithm called failed ball 
obviously expected fraction balls fail equal expected share balls bin apart fall back bin get equal 
want ensure bin gets expected share ensure specify select fall back bin 
initially bin largest share fall back bin 
happens time step share largest bin exceeds share fall back bin factor role passed bin 
ensure bin gets expected share non fall back bin choose adjusted share fall back bin chooses adjusted share 
adjusted shares represent valid share distribution adjusted shares selection intervals non fall back bin gets true share fall back bin gets true share adjusted shares ensure expected share bin precisely equal capacity 
arrive 
theorem 
sieve perfectly faithful 
addition high concentration expected value shown 
theorem 
bin random variable denote number balls placed holds pr min pr theorem follows directly chernoff bounds assumption balls choose values independently random 
log better concentration expected value achievable share reasonable amount resources see lemma 
order show sieve adaptivity consider cases 
capacities change 
number ranges increase accommodate new bins 
role fall back bin change 
number levels increase ensure share fall back bin share strategy changes number balls require sieve replace balls order remain faithful share random hashing 
considering situation capacities system change 

strategy bin reduces intervals way partly occupies range bin extends share partly occupies range 
easy check ranges available bins increase share range bin 
remains bound expected fraction balls replaced 
lemma 
change capacity distribution involve change fall back bin replacement strategy competitive ratio 
proof 
resp 
denote adjusted share bin resp 

fraction taken away bin equal 
furthermore fraction added bin equal 
expected fraction balls participating placement round sieve affected change distribution shares equal remaining balls previously participated second round fraction affected equal 

xr denote fraction balls previously participating round yr denote fraction balls participating round replaced 
exclude failed balls fail stored fall back bin 
case yr represents total fraction balls need replacement 
xr exr yr xr obtain 
xl ex ex yr xr know round expected fraction participating balls placed 
xr perfectly faithful placement scheme move fraction balls proves lemma 
consider situation number ranges increase 
happens new bin introduced requires log grow 
case simply subdivide old range new ranges 
property kept bin partly occupies range replaced 
consider situation role fall back bin change 
recall happens bin maximum share twice share fall back bin 
old new fall back bin 
suppose number bins system share time selected share large share total amount changes shares 
changing involves movement expected fraction balls formula log sufficiently large amount replacement hidden replacements necessary react changes capacity distribution system 
consider situation number levels grow 
necessary case new bins introduced fall back bin may able willing store fraction blocks 
ensure happen strategy share fall back bin integer increase number levels 
strategy cause balls replaced 
show fraction balls replaced hidden amount balls replaced due changes distribution requirement 
fall back bin required increase resp 
initial fall back bin bin exists sk current fall back bin requires increase 
know size fall back bin 
suppose sk took role fall back bin share twice large share share share got role fall back bin total amount changes shares sk shown true longer history fall back bins sk changing involves movement expected fraction dk dk balls sufficiently large amount replacement hidden replacements necessary accommodate changes distribution shares 
arrive result 
theorem 
sieve competitive arbitrarily small 
note sieve strategy easily executed distributed way bin knows complete capacity distribution case change capacities bin compute locally way consistent bins assignment intervals ranges changes 
bin check ball stored replaced necessary sends ball correct bin 
similar strategies scenarios balls replaced 
course strategy sieve share 

applications section list possible applications adaptive hashing schemes 
distributed data servers consider situation distributed data server storage area network 
system may large collection disks quite disks break added replaced 
previous data management strategies raid severe problems changes 
addition able faithfully distribute data blocks disks achieving high adaptivity dynamic placement scheme able ensure requests data blocks distribution data blocks 
share sieve random hash functions easy check share sieve strategy fulfill property 
particular theorem shown 
theorem 
share probability data request sent disk brought arbitrarily close capacity sieve ensures probability data request sent disk equal capacity proof 
consider set requests data blocks 
data block weight number requests relative weight 
consider share 
recall notation theorem 
bx redefined total relative weight balls redefined total relative weight balls bx assigned bin bx blocks pr dx blocks dx dx follows desired 
sieve simply fact ball probability exactly placed bin conclude load bin fulfills blocks pr placed blocks web caching web cache called proxy server network entity satisfies requests behalf web server 
order realize web cache disk storage keeps storage copies requested objects 
web caches enjoying wide scale deployment internet reasons 
web cache substantially reduce response time client request particularly bottleneck bandwidth client original server bottleneck bandwidth client cache 
second web caches substantially reduce web traffic internet 
percent internet traffic web traffic significant reduction web traffic translate significant improvement internet performance 
multiple web caches located different places internet cooperate improve performance 
example cooperative caching system nlanr caching system consists number backbone caches united states akamai caching system provides caching services companies world 
clients hash function discover cache stores object 
consider happens set active caching machines changes client aware different set caches 
situations plausible internet 
case clients may inconsistent view caches 
need data placement scheme able support inconsistent views 
view demand distribution 
vn may deviate current capacity distribution 
dn 
consistency view min obviously closer closer ensure consistency view close correlation probability computing correct bin ball need definition 
placement scheme called oblivious matter system evolved reach capacity distribution distribution balls bins 
non oblivious scheme may happen client determine correct position balls view matches current demand distribution 
important oblivious placement schemes ensure happen 
share oblivious sieve 
consider share strategy 
result generalizes result karger uniform non uniform demand distributions 
theorem 
suppose share 
constant log log chosen view consistency holds data element log copies location copy current demand distribution proof 
prove theorem steps 
consider fixed copy ball show probability bin stored constant smaller 
show probabilities different copies run situation nearly independent probability copies location polynomially small 
result theorem 
consider fixed copy ball 
cx set bins intervals containing set bins intervals containing furthermore ox cx constant choose log cx ox simplify calculations assume cx ox clearly probability location equal probability placed bin ox nearest neighbor bin set cx pr bin ox cx probability bin 
want determine probability copies 
ball bins face problem dependencies probabilities known copy bin copy close may set bins may happen may bin get extra probability lemma shown 
lemma denotes event bin lemma 
holds 
pr 
proof 


furthermore event radius holds pr 
pr pr 
pr pr 
pr pr 
obviously pr remains show pr 
negligible terms consider 
cx negligible terms outside radius interval cx contains point probability true points independent 
pr 
completes proof 
lemma follows pr 
ak choosing log probability copy ball bin polynomially small completes proof 
adaptive random graphs problem generating random graphs long history 
closely related models random graphs stand 
case probability space consists graphs fixed set distinguishable nodes 
space consists subgraphs kn edges 
turn probability space elements equiprobable 
get random element space simply pick random subset size set possible edges easy achieve having access sequence log perfectly random bits 
space defined 
get random element space select edges independently probability edges probability included random graph 
represents class regular graphs size node degree 
elements assumed equiprobable 
number algorithms proposed generate regular graphs uniformly random practical significance 
bollobas algorithm takes expected time order practical 
polynomial time algorithm order nd 
prohibitively difficult implement applies 
simpler algorithms proposed 
graphs proven generated uniformly random 
steger wormald algorithm easy implement fast practice expected runtime nd 
prove algorithm generates regular graphs approximately uniformly sense regular graphs nodes limit probability selected 
graph constructions mentioned number nodes parameters fixed 
done number nodes parameter changes 
class random graph easily adapted changes remains random node removed simply delete edges incident node added simply choose new edges independently probability change handled minimum amount change edge random number edges active number actual class easy solution 
assign edge random number choose edges largest numbers 
difficult check change rule keep graph random member 
furthermore expected number changes necessary keep property minimal 
consider class 
generalize class vector degrees represents degree node 
known efficiently adapt graphs changing remain random member class 
perfectly faithful strategy deterministic sense just expectation needed case share sieve 
sieve close perfectly faithful demonstrate sieve maintain random graphs close class 
simplicity assume degrees half total degree 
guarantees class empty 
node represents bin sieve 
node choose edges endpoint endpoint determined sieve 
guarantees expected number edges incident node deviation log log furthermore easy see sieve competitive change compared expected number changes necessary ensure graph random member 
arrive theorem 
theorem 
sieve allows adapt random graphs competitive way remain graphs close random members 
known random graphs nice properties close optimal diameter expansion 
useful network applications routing distributed sorting load balancing 
adaptive random graphs may particular interest peer peer networks 
peer peer networks overlay networks connect nodes existing network provide distributed services search content integration administration 
main properties characterize network 
central node handles communication peers client server model 
queries fan network results collected propagated back originating node 
furthermore topology constantly changing nodes may join leave network time 
popular examples protocols freenet gnutella limewire kazaa 
protocols computer science literature include chord past tapestry protocol 
peer peer network established internet peers may large differences computational power bandwidth connection internet storage capacity willing able contribute network 
order fully exploit performance peer peer network important take properties consideration construction network distribution data peers 
possible distribute data non uniform way done sections construct peer peer networks non uniform degree connecting users 
addition popular peer peer solutions freenet gnutella broadcasting search contents 
fast feedback operation important ensure number queries reach sent node proportional bandwidth connection internet realized diameter peer peer network low possible 
algorithms generation adaptation random graphs class appear valuable tool solve tasks efficient way 
demonstrated principle possible certainly step direction 

compact adaptive placement schemes non uniform capacities 
open problems remain schemes optimal 
example possible construct compact scheme perfectly faithful close competitive requires amount space depends current number bins current number balls logarithmic way 
share depends sieve depends maximum number bins system far 
competitive competitive 
question worth investigate reduce deviation number balls bin expected value sieve achieve 
interesting maintenance random graphs closer random members 

meyer auf der heide stimulating discussions anonymous referees valuable comments 

bollobas 
probabilistic proof asymptotic formula number labelled regular graphs 
european journal combinatorics 
scheideler 
efficient distributed data placement strategies storage area networks 
proc 
th acm symposium parallel algorithms architectures spaa pages 
cortes 
case disk arrays 
proc 
ieee international conference cluster computing cluster pages 
cortes 
extending heterogeneity raid level 
usenix boston june 
hoeffding 
probability inequalities sums bounded random variables 
american statistical association journal 
karger lehman leighton levine lewin panigrahy 
consistent hashing random trees distributed caching protocols relieving hot spots world wide web 
proc 
th acm symposium theory computing pages 
koren krishna 
synthesis interconnection networks novel approach 
proc 
th international conference dependable systems networks pages 
mckay wormald 
uniform generation random regular graphs moderate degree 
journal algorithms 
raghavan upfal 
building low diameter networks 
proc 
nd ieee symposium foundations computer science pages 
rowstron druschel 
storage management caching past large scale persistent peer peer storage utility 
symposium operating systems principles pages 
sanders 
reconciling simplicity realism parallel disk models 
proc 
th acm siam symposium discrete algorithms soda pages 
siam philadelphia pa 
steger wormald 
generating random regular graphs quickly 
combinatorics probability computing 
stoica morris karger kaashoek balakrishnan 
chord scalable peer peer lookup service internet applications 
proc 
acm sigcomm pages aug 

generating graphs uniformly random 
computing supplement 
zhao kubiatowicz joseph 
tapestry infrastructure tolerant wide area location routing 
technical report ucb csd computer science division university california berkeley berkeley california april 
zimmermann ghandeharizadeh 
heterogeneous extension raid 
proc 
international conference parallel distributed processing techniques applications pdpta 
