approximation di erence description logics sebastian brandt theoretical computer science rwth aachen cs rwth aachen de ralf theoretical computer science kiel ti informatik uni kiel de theoretical computer science rwth aachen cs rwth aachen de approximation new inference service description logics rst mentioned baader molitor 
approximating concept de ned description logic means translate concept concept de ned second typically expressive description logic concepts closely related possible respect subsumption 
provides rst depth investigation inference task 
prove approximations description logic alc ale exist propose algorithm computing 
measure accuracy approximation introduce syntax oriented di erence operator yields concept contains aspects approximated concept approximation 
argued purely semantical di erence operator introduced suited purpose 
logics consideration propose algorithm computing di erence 
approximation description logics dls rst mentioned baader molitor possible new inference problem 
rst investigate problem depth 
informally approximation de ned follows con partially supported deutsche forschungsgemeinschaft dfg project ba 
cept de ned dl source nd concept upper lower approximation dl destination subsumes subsumed ii minimal maximal concept subsumption property 
mainly focus upper approximations 
number di erent applications inference problem mention see knowledgebase cation application mentioned 
translation knowledge bases 
approximation automatically translate knowledge base written expressive dl semantically closely related knowledge base expressive dl 
translation may necessary port knowledge bases di erent knowledge representation systems integrate di erent 
non standard inferences expressive dls 
nonstandard inferences dls computing common subsumer lcs matching uni cation concepts introduced support construction maintenance dl knowledge bases see overview 
restricted quite dls example allow concept disjunction 
approximation overcome problem extent 
example existing matching algorithms lifted handle expressive dls follows directly matching concept patterns de ned small dl concepts de ned dl handled existing matching algorithms rst approximate concept small dl match approximation 
information may lost matcher general correct accuracy result may suce 
example fact main motivation investigate approximation rst place computation commonalities concepts 
inference service chemical process engineering application support bottom construction knowledge bases 
typically lcs employed accomplish task 
formally lcs concepts say de ned dl speci concept subsumption subsumes concepts 
case allows concept disjunction lcs just disjunction tc 
problem user inspecting concept learn actual commonalities approximation commonalities explicit rst approximating sublanguage allow express concept disjunction computing lcs approximations sublanguage 
supporting frame user interfaces dl systems 
interaction dl systems users little knowledge representation expertise may diculties understand full expressive power underlying dls 
overcome problem knowledge representation systems equipped simpli ed frame user interface built top powerful dl system 
examples systems tambis system ontology editor oiled built top fact dl system 
occasions systems concept descriptions user editing inspection solution inference problems 
concept descriptions need restricted representation frame user interface may overwhelm inexperienced user 
cases approximation helpful means represent concept descriptions simpli ed fashion suited user interface users level expertise 
main technical result section show concept descriptions de ned standard dl alc allows concept conjunction disjunction value existential restrictions full negation approximated dl ale dl allow concept disjunction full negation 
upper approximation natural question regards loss information aspects captured propose di erence operator yields concept di erence equivalent 
words contains information missing approximation operator de ned 
requires general concept description subsumption satis es equivalence 
see purely semantical de nition di erence yields unintuitive concepts 
propose new syntax de nition better captures intuition di erence 
roughly speaking di erence obtained syntactically removing parts section provide formal definition give heuristic algorithm computing di erence alc ale concept description 
section experiences prototypical implementations algorithms conclude remarks 
full proofs main theoretical results provided appendix 
proofs details technical report 
description logics concept descriptions inductively de ned help set concept constructors starting set nc concept names set nr role names 
consider concept descriptions built constructors shown table 
dl ale concept descriptions formed constructors top concept concept conjunction existential restriction value restriction primitive negation bottom concept 
dl alc additionally provides concept disjunction td full negation 
note alc concept description negated ale negation allowed front concept names 
dl ale alc concept description formed constructors allowed called concept description 
usual semantics concept description de ned terms interpretation 

domain 
non empty set interpretation function 
maps concept name nc set 
role name nr binary relation 
extension 
arbitrary concept descriptions de ned inductively shown second column table 
important traditional inference services provided dl systems computing subsumption hierarchy 
concept description sub syntax semantics ale alc 
fx 
fx 
nc 

table syntax semantics concept descriptions 
sumed description holds interpretations equivalent strictly subsumed subsumption equivalence pspace complete alc np complete ale 
order approximate alc concept descriptions ale concept descriptions need compute common subsumer ale de nition concept descriptions cn description logic concept description common subsumer lcs cn lcs cn short ii concept description property satis es depending dl consideration lcs concept descriptions need exist exists de nition unique equivalence 
instance alc lcs trivially exists lcs ale allow concept disjunction existence obvious 
shown lcs ale concept descriptions exists size may grow exponentially size input descriptions computed exponential time 
computing approximations section show alc concept descriptions approximated ale concept descriptions 
rst de ne notion approximation formally 
de nition dls concept description 
called upper lower approximation approx short ii minimal maximal property implies concept descriptions note approximations need exist general 
consider example dls fug ftg dls allow concept conjunction concept disjunction respectively 
denote concept names 
exist upper approximation concept description conversely exist lower approximation concept description 
note approximations need uniquely determined 
example lower approximations de ned 
restrict investigations upper approximations 
speak approximations mean upper approximations 
concentrate upper ale approximations alc concept descriptions 
ale allows concept conjunction immediately follows upper ale approximations exist uniquely determined equivalence upper ale approximations alc concept ud de nition upper approximation ud ud implies na approximation approach turn question upper ale approximations computed alc concept descriptions 
rst na approach problem show fails 
motivate de nition correct approximation algorithm 
easy see alc concept description ale concept descriptions ale approximation lcs 
having observed think alc concept description approximated simply replacing concept disjunction lcs operator evaluating lcs operators inside 
alc concept description ex concept names illustrates case obtained approximation lcs easily check ex fact correct upper ale approximation ex turns turn concept descriptions certain normal form substituting disjunctions lcs 
roughly speaking normal forms obtained distributing concept conjunctions concept disjunctions 
example yields concept description replacing disjunction lcs yields lcs correct result 
example illustrates normalizing concepts way suce general case 
description ex normal form substituting concept disjunction lcs yields lcs ale approximation ex 
reason need propagate value restrictions existential restrictions order obtain correct approximations existential restrictions 
follows rst introduce normal forms approximation algorithm works normal forms propagation alc alc alc normal form sake simplicity assume set nr role names singleton frg 
de nitions results easily generalized arbitrary sets role names 
assume conjunction ale concept description contains value restriction form due equivalence 
notation needed access di erent parts ale concept description alc concept description disjunction occurs value existential restrictions prim denotes set negated concept names bottom concept occurring top level conjunction exists value restriction form top level conjunction val val ex fc exists top level conjunction cg 
de nition alc concept description alc normal form 

form 
prim ex val val concept description ex alc normal form obviously alc concept description turned equivalent concept description alc normal form 
unfortunately may take exponential time example ta 
ta shows alc normal form size exponential approximation algorithm approximation algorithm structural characterization subsumption alc concept description alc normal form ale concept description idea compared disjunct comparison turn similar structural characterization subsumption ale concept descriptions 
full proof see 
theorem alc concept description alc normal form speci ed de nition ale concept description 

prim prim 
ex exists ex val 
val val 
approximation algorithm denoted approx ale depicted 
nds ale concept description speci possible satis es conditions input alc concept description output upper ale approximation 
approx ale approx ale 
transform alc normal form 
cn return approx ale prim ex 
ex cn approx ale val ng approx ale val ng recursive algorithm approx ale 
theorem 
trivial 
case approx ale needs show conditions theorem satis ed ii minimal concept description property 
see appendix full proof 
theorem alc concept description ale approximation exists uniquely determined equivalence computed approx ale approx ale approx ale 
order apply algorithm approx ale examples rst transform ex alc normal form ex compute actual approximation concept description approx ale ex lcs approx ale approx ale lcs approx ale approx ale lcs approx ale approx ale lcs lcs lcs see existential restriction correctly approximated algorithm approx ale second example ex alc normal form approximation directly obtained steps approx ale ex approx ale approx ale approx ale approx ale approx ale see na approach approx ale algorithm propagates value restrictions yields correct approximation 
shown lcs ale concept descriptions grow exponentially size concept descriptions 
approx ale lcs ale concept descriptions immediately follows ale approximation grow exponentially 
show approx ale runs double exponential time see appendix details 
corollary ale approximation alc concept descriptions may grow exponentially double exponential time algorithm computing 
exists exponential time approximation algorithm open problem 
di erence operator previous section seen compute ale approximation alc concept description 
pair approximated approximating concept natural question regards loss information aspects captured answer question requires notion di erence concept descriptions 
instance comparison example concept ex approximation au reveal value restriction captured approximation 
rst de nition di erence operator proposed declares di erence concept descriptions cg maximum de ned respect subsumption 
alc provides full negation general concept di erence example concept ex approximation di erence operator consequently return obviously help human user ascertain information lost approximation 
example suggests look syntactic minimum semantic maximum order nd compact representation di erence concepts 
syntactic minimum de ned socalled ordering 
ordering ordering ale concept descriptions proposed deal syntactical redundancies 
order extend case need introduce analogous ordering alc concepts 
idea obtain alc concept description means kinds modi cations 
firstly making inconsistencies explicit secondly removing disjuncts conjuncts replacing existential value restrictions respective 
formally leads de nition 
de nition alc concept descriptions alc normal form 

cn obtained performing steps 
remove disjuncts 
remaining remove conjuncts prim remove conjuncts ex remove conjunct val remaining ex fval replace removed resulting concept 
example consider equivalent concept descriptions 
removing disjunct disjunct remaining existential restriction nd ordering provide new de nition di erence operator 
de nition alc concept description ale concept description 
di erence de ned minimal alc concept description intuitively idea remove redundant noted case di erence di erence operator minimum maximum note di erence priori uniquely determined 
abuse language notation refer di erence see theorem 
coming back example section di erence de nition ex approximation desired 
di erence algorithm having de ned di erence operator need devise algorithm compute di erence algorithm proposed compute di erence ale concept descriptions want extend case alc concept description ale concept description 
illustrated example consider case alc concept description di erence redundancies removed 
ex ex ex common ex di erence ex ex yield ex smaller concept ex 
obtain result di erence existential value restrictions ex computed atb auc buc intuitively computing di erence alc concepts necessary computation ale concept description 
handling di erence disjunctions disjunction occurs left hand side di erence form 
cn di erence computed distributing di erence disjunction computing 
cn rst removing possibly redundant disjuncts 
case disjunction right hand side 
dn dually try compute 
conjunction 
dn 
example distributing di erence disjunction obtain buc atb 
idea turning di erence conjunction di erences yields simpli cation 
analogously obtains second di erence 
altogether removed obtain desired 
unfortunately similar straightforward approaches decomposing di erence 
disjunction 
dn fail 
currently question compute di erences disjunctions right hand side remains open problem 
heuristic approach rst step solution propose heuristic algorithm di depicted 
computes di erence alc concept description alc normal form ale concept description 
disjunction subconcepts di erence obtained rstly computing di erences disjuncts eliminating semantically redundant resulting disjuncts 
disjunction occurring right hand side di erence computation simply omitted see de nition di erence existential restriction ex val val required 
despite straightforward approach properties shown computation di 
full proof appendix 
theorem alc concept description alc normal form ale concept description 

di 
ale concept description uniquely determined modulo associativity commutativity concept conjunction di coincide 

oracle subsumption di runs polynomial time size case ale concept description di exactly computes di erence theorem 
alc concept description know di remove theorem 
di computed exact di erence experiences prototypical implementation di show algorithm works quite satisfactorily practice 
illustrate consider simple example concept ex ale approximation 
order compute di erence di ex ex rst transformed alc normal form yielding 
compute di di 
rst expression condition algorithm di causes removed 
existential restriction left rst expression evaluates second expression similarly yields nally obtain exactly ex approx ale ex 
analogously verify di ex approx ale ex ex approx ale ex 
improved heuristic simply omitting val de nition see case val ale concept description de ne di approx ale val cases comes closer val val 
note val ale concept description approx ale val val val val 
example consider alc concept description 
rst version di applied di yield improved version yields auc uc approx ale auc input alc concept description 
cn alc normal form ale concept description output di 
di 
di di iteratively remove di disjunction case di di 
di prim di val val value restriction omitted case di val val computed follows fc ex 
exists fc val val ii exists ex val val fc fe di val val val ale concept description di val 
algorithm di 
buc 
improved di fails ex ex approx ale atb value restriction ex remains unchanged 
due additional complexity caused computation approximation algorithm di longer polynomial time algorithm oracle subsumption prototypical implementations evaluated rst prototypical implementation approx ale realized lisp fact system underlying subsumption tester 
implementation approx ale utilizes optimized lcs implementation described 
contrast approx ale algorithm speci ed implementation reduces number lcs calls advance 
concept descriptions alc normal form disjuncts share existential restrictions due normalization 
existential restrictions cause unnecessary lcs calls approximating existential restrictions 
combinations cartesian product existential restrictions yield argument sets lcs supersets combinations 
supersets yield general redundant lcs concept descriptions 
example computing approximation concept description starts computing equivalent alc normal form 
computation actual approximation naive realization approx ale induces lcs calls lcs lcs lcs lcs lcs lcs 
trivial combinations lcs lcs add existential restrictions approximation subsumed combinations 
case existential restrictions obtained lcs 
order obtain correct approximation general suces compute lcs combinations subset combinations 
method employed implementation compute rst minima subset set combinations apply lcs minima 
applied approx ale alc concepts tbox derived application chemical process engineering 
application tbox contains concepts roles 
surprisingly unfolded input concepts concept sizes turned approximations smaller unfolded input concepts 
approximations average concept size just third size unfolded input concepts average 
test concept descriptions approximated seconds runtime 
unfortunately implementation ran memory computing approximations randomly generated alc concepts similar size consisting disjunctions disjuncts 
chemical process engineering application disjunctions consist smaller number disjuncts may cases appear practice 
prototypical implementation approx ale indicates despite high theoretical complexity approximation inference practicable cases relevant applications 
optimizations course necessary 
standard optimization techniques lazy unfolding highly improve performance run times sizes returned concepts 
implemented prototype di algorithm 
rst evaluation applied di implementation test concepts derived process engineering tbox 
precisely applied di alc concept descriptions evaluation approx ale approximations generated approx ale implementation 
test cases di implementation returned concept descriptions average size maximum size 
turned cases concept size di erence original concept description approximation unfolded normalized concept 
runtimes computing di erence took seconds average di erence computed seconds 
approx ale prototypical implementation behaved randomly generated concept descriptions 
practical applications non standard inference powerful optimizations necessary 
output concept descriptions need smaller compact order readable comprehensible human user 
investigated approximation new inference problem dls 
main technical result time algorithm computing upper approximations alc concepts ale devised 
introduced syntax di erence operator measure accuracy approximations ecient heuristic algorithm uses subsumption testing oracle compute di erence concepts 
rst evaluation implementations approx ale di indicates need optimization 
important concepts returned algorithms quite big hard read comprehend human user necessary rewrite concepts concept de nitions underlying alc tbox obtain smaller concepts 
purpose needs extend existing rewriting approach ale alc 
direction course extend results expressive dls 
fact approach extended approximation alcn concept descriptions concept descriptions alen sublanguages thereof shown 
remains extend lcs approximation dls quali ed number restrictions adapt di erence operator description logics quali ed number restrictions 
baader molitor 
computing common subsumers description logics existential restrictions 
dean editor proceedings th international joint conference arti cial intelligence ijcai pages 
morgan kaufmann 
baader molitor 
rewriting concepts terminologies 
cohn giunchiglia selman editors kr principles knowledge representation reasoning pages san francisco 
morgan kaufmann 
baker brass bechhofer goble paton stevens 
tambis transparent access multiple bioinformatics information sources 
glasgow major lathrop editors th int 
conf 
intelligent systems molecular biology pages montreal canada 
aaai press menlo park 
bechhofer horrocks goble stevens 
oiled reason able ontology editor semantic web 
baader brewka th 
eiter editors proceedings joint german austrian conference ai ki volume lecture notes arti cial intelligence pages vienna austria 
springer verlag 
borgida etherington 
hierarchical knowledge bases ecient disjunctive reasoning 
levesque brachman reiter editors proceedings st international conference principles knowledge representation reasoning pages toronto canada may 
morgan kaufmann 
brandt 

nonstandard inferences description logics buy proceedings ki workshop applications description logics number ceur ws vienna austria september 
rwth aachen 
proceedings online available sunsite informatik 
de publications ceur ws vol 
brandt 

approximation di erence description logics 
report theoretical computer science rwth aachen germany 
see www lti informatik 
de forschung reports html 
brandt 

approximating alcn concept descriptions 
see www lti informatik 
de forschung papers html 
appear 
cohen borgida hirsh 
computing common subsumers description logics 
swartout editor proceedings th national conference arti cial intelligence pages san jose ca july 
mit press 
donini lenzerini nardi hollunder nutt spaccamela 
complexity existential quanti cation concept languages 
arti cial intelligence 
horrocks 
expressive description logic fact ction 
cohn schubert shapiro editors kr principles knowledge representation reasoning pages 
morgan kaufmann san francisco california 

non standard inferences description logics volume lecture notes arti cial intelligence 
springer verlag 
molitor 
computing common subsumers alen nebel editor proceedings seventeenth international joint conference arti cial intelligence ijcai pages 
morgan kaufman 
sattler 
terminological knowledge representation systems process engineering application 
phd thesis theoretical computer science rwth aachen germany 
schmidt schau smolka 
attributive concept descriptions complements 
arti cial intelligence 

making di erence subtraction operation description logics 
torasso doyle sandewall editor proceedings th international conference principles knowledge representation reasoning pages bonn frg may 
morgan kaufmann 

molitor 
lazy unfolding computation common subsumers 
proceedings international workshop description logics dl stanford usa august 
appendix proof theorem loss generality may assume alc normal form algorithm approx ale starts computing alc normal form input represented uniquely alc normal form 

show approx ale 
show structural induction conditions subsumption theorem hold 
approx ale trivially satis es subsumption conditions 
may assume induction hypothesis claim holds subconcepts occurring existential value restrictions 
nd de nition approx ale set prim approx ale primitive concepts equals prim subset prim 
show approx ale val ng exists existential restriction ex val subsumed lcs approx ale val ng 
pick induction hypothesis holds val subsumed approximation approx ale val 
de nition lcs guarantees val subsumed approx ale val ng 
show val val approx ale induction hypothesis know value restriction val subsumed approximation approx ale val consequently lcs nd val subsumed approx ale val ng 
show approx ale ale concept descriptions loss generality ale normal form 
proof induction structure approx ale may assume claim holds subconcepts occurring existential value restrictions 
trivially approx ale subsumption induces facts prim prim set prim approx ale primitive concepts de ned intersection prim implies prim prim approx ale 
ex existential restriction ex induction hypothesis guarantees val subsumed approx ale val consequently lcs holds approx ale val ng val val 
induction hypothesis know value restriction val subsumed approximation approx ale val val 
similarly nd approx ale val ng val 
proof corollary algorithm approx ale expects input alc normal form 
transforming normal form applying approx ale may necessary transformation role level currently visited 
jcj computation approx ale starts transforming 
tcm disjunction topmost role level modify lower role levels 
concept exponentially polynomial disjuncts topmost level limited size recursive structure approx ale expressions computed 
conjunction prim primitive concepts 
existential restriction approx ale val mg tuple ex 
value restriction approx ale val mg 
obviously step computed polynomial time size exponential time exponentially disjuncts turn linear number existential restrictions number existential restrictions computed step double exponential existential restriction lcs set exponential cardinality computed 
element set form approx ale val 
approx ale recursively invoked concept description size bounded size role depth decreased 
computation tree approx ale lcs evaluated time size double exponential size need show evaluating lcs occurring computation tree increase complexity 
start evaluate lcs bottom top computation tree approx ale 
lcs operation tree exponential number arguments argument size double exponential jcj 
easily show argument ale normal form properties contains subexpression form nc 
subexpression form holds value restriction propagated existential restriction 
holds concepts returned approx ale properties 
shown size lcs bounded product sizes arguments 
evaluating lcs bottom level yields concept descriptions size double exponential 
evaluation process iterated level computation tree approx ale lcs occur 
depth tree bounded jcj precisely role depth evaluation carried double exponential time 
proof theorem 
proof structural induction prim conjunction di ud equivalent cnd cnd conjunction primitive concepts prim prim 
pc denote conjunction primitive concepts prim prim 
pc term di ud equivalent conjunction cnd pc expression equivalent loss generality may assume exactly disjuncts top level induction ud 
follows disjunction top level show di ud ud 
characterization subsumption theorem conditions hold equivalence set prim di primitive concepts equal intersection prim di prim de nition intersection prim prim prim 
equal prim prim set primitive concepts conjunction induction hypothesis conjunction di val val val equivalent val val 
de nition val equivalent val val concludes case 
show 
consider existential restriction ex 
nd existential restriction ex di val di previous case know val di equivalent val ud 
ex ud equal union ex ex may distinguish cases 
ex choose occurs set ex di ud union concept descriptions ex di ex 
nd conjunction di ud subsumed ex ex conditions ii de nition algorithm di guarantee exists existential restriction ex di properties 
val ale concept description form di val val conjunction val val subsumed induction hypothesis di val equivalent val val 
consequently nd val val subsumed easy see val val equivalent val ud equivalent val di know 
existential restriction conjunction di ud subsumed ale concept description form val 
case analogous previous 
show 
analogy case consider existential restriction ex di 
nd existential restriction ex val subsumed cases discriminate 
ex select occurs set ex existential restrictions 
ex di ex exists ex di val val val depending val ale concept description 
choose induction know val 
result shown 

proof technical report 
