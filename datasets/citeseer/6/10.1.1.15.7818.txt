accomplishments research challenges meta programming invited tim sheard pacific software research center ogi school science engineering oregon health science university 
ogi 
edu vv ww home page www cse ogi edu sheard springer verlag www springer de comp lncs index html years study meta programming systems formal systems worthy study right vastly accelerated 
time lot accomplished remains done 
invited talk wish review accomplishments research challenges hopes spur interest meta programming general lead new better meta programming systems 
break sections 
overview section try classify meta programs groups 
purpose provide common vocabulary describe meta programming systems rest 
section describe number contexts metaprogramming useful 
knowledge areas metaprogramming techniques developed helps reader understand motivation research areas discuss 
section motivate meta programming systems right tools problems outline number particular areas believe interesting research accomplished new research needs done 
claim set issues exclusive metaprogramming system address issues listed 
meta programming system designer diner restaurant pick choose full meal menu choices 
section menu 
sections elaborate detail areas outlined section 
discuss ideas different researchers think important meta programming picture 
areas outlined proposed research projects 
proposals level detail assign new student project personally carried research 
accomplishments research challenges meta programming continue food metaphor sections discuss general preparation menu items ingredients need special handling special techniques apply broad areas cooking 
cookbook describes item menu cooking class general techniques building understanding meta programming systems 
section discuss number existing meta programming systems 
understanding designed taxonomy meta programming systems lie 
section discuss metaml system attempt building useful meta programming system 
world meta programming meals metaml full course meal 
look forward meals especially am diner chef 
taxonomy meta programs meta programming system meta programs manipulate object programs 
meta program may construct object programs combine object program fragments larger object programs observe structure properties object programs 
term object program quite loosely 
sentence formal language 
meta programs include things compilers interpreters type checkers theorem provers program generators transformation systems program analyzers 
program meta program manipulates data object representing sentence formal language object program 
kind meta programs 
meta programs fall categories program generators program analyzers 
program generator meta program address class related problems family similar solutions instance class 
constructing program object program solves particular instance 
usually generated object program specialized particular problem instance uses resources general purpose non generated solution 
program analysis meta program observes structure environment object program computes value result 
results data control flow graphs object program properties properties source object program 
examples kind meta systems program transformers optimizers partial evaluation systems 
addition view meta programs generators analyzers mixture important distinctions 
static vs run time 
program generators come flavors static generators generate code written disk processed normal compilers run time code generators programs write construct programs immediately execute tim sheard programs generated 
take idea extreme letting generated code run time code generator multi stage programming 
examples run time program generators multi stage programming language metaml run time code generation systems synthesis kernel fabius 
example static program generator yacc 
manually vs automatically annotated 
body program generator partitioned static dynamic code fragments 
static code comprises meta program dynamic code comprises produced 
staging annotations separate pieces program 
call meta programming system programmer places staging annotations directly manually staged system 
staging annotations place automatic process meta programming system automatically staged system 
historically area partial evaluation pioneered technique terminology placing staging annotations automatic way intervention programmer 
write normal program declare assumptions static dynamic nature programs inputs system place staging annotations 
clear manually placing annotations viable alternative 
homogeneous vs heterogeneous 
distinct kinds metaprogramming systems homogeneous systems meta language object language heterogeneous systems meta language different object language 
kinds systems useful representing programs automated program analysis manipulation 
important advantages homogeneous systems 
homogeneous systems level unbounded level object program meta program manipulates level object programs 
homogeneous single type system type meta language object language 
homogeneous meta systems support reflection operator run eval translates representations programs values represent uniform way 
run time code generation possible 
homogeneous systems important pedagogical usability property user need learn single language 
uses meta programs meta programming provides various benefits users 
explain benefits 
performance 
common objective meta programming systems performance 
meta programs provide mechanism allows general purpose programs written interpretive style perform accomplishments research challenges meta programming usual interpretive overhead 
write general purpose inefficient program writes program generator generates efficient solution specification 
interpretive style eases maintenance construction single program solves problems 
program easier maintain similar individual programs 
parser generator yacc illustrative example 
general purpose parsing program generate efficient parser specification language grammar 
partial evaluation 
partial evaluation meta programming technique improve performance 
partial evaluation optimizes program priori information program inputs 
goal identify perform computations possible program run time 
common type partial evaluation line partial evaluation distinct steps binding time analysis bta specialization 
bta analysis determines computations performed earlier stage names inputs available run time static inputs 
specialization uses values static inputs produce improved program 
translation 
common meta programming translation object program object program 
source target languages may may 
examples translators compilers program transformation systems 
reasoning 
important meta programs reason object programs 
object programs sentences formal language analysis discover properties object program 
properties improve performance provide assurance behavior validate meaning preserving transformations 
examples reasoning meta programs program analyses flow analyses type checkers 
reasoning meta programs build theorem proving systems lego hol coq isabelle study implementation logical frameworks elf twelf lf 
pedagogy 
pedagogical meta programs program observation 
computation proceeds stages 
inputs arrive stages computation comprising stage program incorporates current inputs anticipates stage 
higher order functions provide convenient mechanism structuring staged programs 
higher order language solutions proceed accepting input producing result function deal stage 
functions extensional observed noticing behave applied inputs hard explain understand programs written style intermediate stages observed 
meta programmed solution alleviates problem 
stage producing function output stage produce code function output 
code observable structure quite illuminating 
illustrate complex algorithms great ef tim sheard fect example continuation passing transform monad transformers combinator parsers mobile code 
meta programming means program transportation 
networks bring data program networks bring program data 
security reasons intensional representations programs transported network 
representations analyzed security safety purposes ensure compromise integrity host machines run 
transported programs object programs analyses meta programs 
meta programming hard 
meta programming hard programs complex 
large computer programs may complex entities constructed humans 
programmers utilize features manage complexity 
features built programming languages include type systems catch syntactically correct semantically meaningless programs scoping mechanisms localize names needs think abstraction mechanisms functions object hierarchies module systems hide irrelevant details 
features add considerably complexity languages embedded generally considered worth cost 
write programs manipulate programs deal complexity twice programs write data manipulate 
meta programming system knows deals directly complexities object language 
meta language deal directly type system scoping discipline abstraction mechanisms object language meta programmer encode features lower level mechanism complicating difficult task 
meta programming system help 
meta programming system supposed manipulation object programs easier 
easy understand programmer interface meta object languages seamlessly provide high level abstractions capture details object language patterns meta programs fast case program generators generate fast code 
utility providing general purpose solutions needs reused systems 
lots addressing issues clear fit missing 
research areas meta programming area long time 
lisp hackers right 
programs data 
formal area study metaprogramming active area research decade accomplishments research challenges meta programming 
huge amount remains done 
supply ph students thesis topics years 
varies highly theoretical proofs engineering problems systems building 
important worth doing 
overview areas list 
rest discuss items detail 
representing programs section 
programs data complex entities 
represent hide unnecessary details important structure evident common operations easy express efficient implement 
presentation section 
presentation interface object language meta programming system provides programmer 
presentation immense effect usability system 
experience metaml shows object language templates look object language programs great boon meta programmer 
integrating automatic manual annotation section 
partial evaluation systems save user bother placing staging annotations user automatic system loses control structure output 
manually placing staging annotations provides complete control cases tedious error prone 
techniques married harmonious relationship 
observing structure code sections 
techniques representing code data 
code type 
done support dual nature provide usable presentation 
representations hide internal structure code interface internal structure code necessary code observed 
interface easy reflects user logical view object code structure view implemented hard obtain 
manipulating binding constructs section 
object languages include binding constructs introduce delineate scope local variables 
far meta program concerned actual name variables immaterial 
name long consistent manner 
generating programs needs invent new local names guaranteed different existing names 
necessary prevent possibility introduce scope inadvertently hide necessary variable 
program transformation analysis flip side coin dealt 
deconstructing programs ensure locally scoped variables escape scope unbound 
manipulating typed object programs sections 
write programs find discipline typed programming language valuable ignore 
type systems catch errors sooner facilitate writing programs 
wouldn want benefits object programs 
typed meta programming system catch type errors tim sheard object programs compile time meta program 
metaml system see sections start area 
problems addressed include meta programs generate manipulate object programs different object types depend metaprogram input issues involving polymorphism inside object programs issue type safety effects meta programming 
heterogeneous meta systems section 
heterogeneous systems meta language object language different 
heterogeneous systems bring new set challenges forefront 
object language new different type system defined 
type meta program say type object programs produces possible embedded type system object languages type system meta language 
guarantee type systems way similar compatible metalanguage type system 
type systems may 
example meta language may polymorphic lambda calculus object language cardelli object calculus simple embedding possible 
building implementations section 
implementations meta programming systems rare 
especially lack implementations run time code generating systems 
competing needs systems 
generate code quickly 
generate fast code 
hard 
doing impossible 
control tradeoff 
general purpose program generators able generate code interacts different object program environments 
really need yacc language 
build meta systems ability produce object programs interact differing environments 
theory meta programs section 
reliable systems possible understand theory systems wish build 
meta programs subtle semantic difficulties just occur ordinary programs 
theory meta programming systems necessary isolate problems understand interaction system features 
theory leads tools 
sections discuss areas detail 
sections give example programs times imaginary existing languages 
choice language style examples 
hand built large system metaml great care adhere standard ml syntax semantics give examples ml style language 
hand ml style postfix application type constructor application int list quoted variables represent type variables inability give type declarations programmer gives type function accomplishments research challenges meta programming definition push style akin haskell typing prototypes qualified type system 
choose 
giving examples actual metaml programs adhere ml style 
places adhere haskell style program definition 
representing programs meta systems represent object programs strings graphs algebraic data structures 
string encoding represent code fragment simply 
constructing combining fragments represented strings done simply due lack internal structure deconstructing quite complex 
seriously automatically verifiable guarantee programs constructed syntactically correct 
example static type string clearly imply string represents syntactically correct program 
problem strings internal structure corresponding object language structure 
perl meta language object language say html manipulation moves implementing language manipulations user 
better move common tasks meta language implementation programmer need solve problems 
lack internal structure serious advice programmers unequivocal serious meta programmer consider representing programs strings 
lisp systems expressions add internal structure program representations really solve syntax correctness prob lem 
expressions legal object programs course expressions 
lisp lacks static typing mechanism extremely useful meta programming 
algebraic approach capture object language structure rigorous manner 
solution vein data structuring facility akin algebraic datatype facility standard ml haskell 
datatype encoding address destructuring problem syntactic correctness problem 
datatype encoding essentially syntax 
encoding fragment haskell algebraic datatype apply variable tuple variable variable datatype declared follows data exp variable string apply exp exp tuple exp constant int abs string exp datatype encoding immediate benefit correct typing meta program ensures correct syntax object programs 
languages support pattern matching datatypes haskell standard ml tim sheard deconstructing programs easier string representation 
constructing programs verbose cumbersome constructors variable apply tuple 
drawback requirement meta programmer aware detailed mapping concrete syntax object language data structuring component meta language 
possible better manipulate representation familiar feel concrete syntax object language 
presentation quasi quote representation attempt user interface object language object language concrete syntax possible 
actual representation object code hidden user means quotation mechanism 
object code constructed placing quotation annotations normal object language concrete syntax fragments 
inside quotations anti quotation annotations allow programmer splice computations result object code 
am told idea quasi quotation originates logicians willard quine book mathematical logic rudolph carnap book logical syntax language 
description early quasi quotation appears guy steele evolution lisp describes various dialects maclisp supported feature calls pseudo quoting pseudo quoting allowed code compute replacement value occur template 
called pseudo quoting template surrounded call operator ust quote specially marked places template 
lisp back quote begins quasi quotation comma preceding variable parenthesized expression acts anti quotation indicating expression treated quotation computation evaluate piece object code 
short history quasiquotation lisp article name alan bawden pepm proceedings invited talk describes detail 
lisp quasi quotation unaware special needs variables binding forms 
quasi quotation ensure variables atoms occurring back quoted expression bound rules static scoping 
example plus bind plus scope term appears treat lambda ep reasonable way respects binding occurrence 
wasn design implementation scheme macro system quasi quotation dealt properly issues 
metaml fixes problem employs static typing discipline accomplishments research challenges meta programming types quasi quoted expressions object level types useful important extension 
quasi quote presentation mechanism benefits string algebraic datatype representation 
guarantees syntactic correctness object programs type correctness meta programs maintains ease construction object programs 
short metaml metaml homogeneous manually annotated run time generation system 
metaml angle brackets quotations tilde antiquotation 
call object level code inside pair angle brackets anti quoted holes template stands computation build object code fragment shape quoted code 
syntactic correctness guarantee metaml template mechanism guarantees type correctness object level treats object level variables manner respects static scoping 
illustrate features val val val code val code show example construct object program fragment anti quotation mechanism splice object program fragment code 
note definition code uses template hole 
introduce new type constructor pronounced code type meta level terms evaluate object code 
note code fragment assigned code type type inside angle brackets indicates type object program 
example type type int 
type system helps user construct formed object programs 
useful features tracks level variables bound 
attempts variables level lower level bound sense reported type checker 
example fun id valid fn id error te variable bound stage early stage example stage variable anti quotation stage 
semantically meaningless reported type error 
metaml quasi quoted template involving variable binding automatically alpha renames bound variables manner precludes inadvertent tim sheard name capture 
note bound variables alpha renamed fn val fn int int particularly useful computing body lambda abstraction anti quoted computation 
computation places variable bound lambda abstraction context variable bound way inadvertent capture result 
fun plus val plus fn int val plus val fn int int note plus splices argument context locally bound 
plus context bound metaml confuse 
metaml statically scopes free variable occurrences code templates 
results variable level greater level bound 
fun val fn int int int val val fun andalso run val int note free variable code template refers function int int int scope template defined function boot boot boot scope run 
code pretty printer places percent sign front code template indicate statically bound object variable 
run operator metaml transforms piece code program represents 
useful think run indicating composition run time compilation execution 
example build generator power gen 
apply obtain piece code power code 
run code obtain function power fun 
apply function obtain answer fun power gert fun power val power gert int int val power code power gen accomplishments research challenges meta programming val power code int val power fun run power code val power fun fn int int power fun val int metaml run move stage 
legal anti quotation lambda binding possibility run may applied variables bound stage 
example val bad run cause error object variable bound piece code run applied 
kind error just occur normal programs complicates semantics type systems homogeneous systems 
thought put devising type systems disallow programs 
metaml interesting operator lift 
evaluates argument constant value containing function produces piece code represents value 
example lift val lift rev val metaml angle brackets escapes lifts run operator staging annotations 
indicate boundaries metaml program program text moves meta program object program 
staging annotations metaml placed manually programmer considered part language 
metaml staging annotations semantic meaning part language definition just hints directions language preprocessors 
argued manually staged programs hard write larger counterparts input partial evaluation system saving user lot 
advent modern programming systems quasi quote staging annotations remains seen argument holds 
experience manually annotated programs percent size counterparts 
nice benefits systems 
partial evaluation line partial evaluation automatic staging system 
consider simple partial evaluation function pe 
takes representation program tim sheard static parameter dynamic parameter returns answer 
analyses program automatically produces annotated program static parameter input produces representation function dynamic parameter answer 
description infer pe type example consider program val ans pe fn ans lift int evaluates new stage program 
step called binding time analysis 
stage program run applied specialization stage produces new specialized program val special run ans val special int note static addition performed specialization time 
integration function pe manually staged language provide benefits manually automatically staging program 
partial evaluators staged languages exist remains interesting engineering problem integrate 
intensional analysis code metaml originally designed allowed construction execution see section code 
observation structure code decomposition originally supported included formal property studies performed 
consider problem implementing pe function previous section 
tools need 
obvious pe needs observe structure argument 
argument lambda abstraction application constant variable 
variable statically scoped object bound variable 
metaml code implemented datatype 
interface datatype includes quasi quote template notation function run 
internal interpreter code implemented algebraic datatype lines exp datatype section 
internal representation visible programmer wish insulate programmer details internal structure allowing construct object programs syntax template mechanism meta programs 
order allow intensional analysis code explicit internal representation supply interface code type 
actual metaml implementation far complicated deal short section consider exp datatype defined section illustrate key ideas 
accomplishments research challenges meta programming data exp variable string apply exp exp tuple exp constant int abs string exp suppose built quasi quotation mechanism internally stores templates exps means constant means apply means abs variable 
support interface type reveal details actual implementation type exp supplying constants types display haskell style language 
gensym sym var sym mint instance eq sym isvar sym monad failure fail plus operation associative fail unit 
help think type constructor additional structure 
interpretation expression evaluates ust expression evaluates ust evaluates fail 
case operators succeed producing result sub structure matched fail 
operator try sequence potentially failing expressions 
operators isvar gensym var deal variables binding operators lambda abstraction 
actual name bound variable matter implementation respect constraint 
type constructor sym type member eq class 
operators equality testing gensym var 
operator abs works conjunction operators symbols analyze structure lambda abstractions variables 
operator applied piece code object level abstraction returns meta level function 
argument meta level function re produces body abstraction occurrences bound variable replaced argument 
scheme user observe actual names object variables 
operator gensym produces new symbols observed sym type interface 
interface designed avoid harmful variables 
example test code term matches code value writes follows 
haskell syntax excellent support monadic computation return operators 
test bool test arg tim sheard return notation successful match binds elements left arrow failure causes complete expression fail 
gensym vat generate new object level variables 
key observation production variables happens monad write equality function compares pieces code syntactic equality modulo alpha equivalence follows eq bool eq var var return false purpose monad put structure possibility failure delimit scope object bound variables may live 
problem gensym may produce free variables eliminated 
example return var returns variable binding location 
saving grace expression type purpose monad prevent escape variables 
important open question get monad 
operation type clearly general allow sym values escape monadic computation 
solution qualified type qualifying follows run contain code things safe 
clearly wants write code analyzers return code 
accomplish interesting open question 
approach lifted complex object code expressions case expressions 
example exists 
applying object level case succeeds returns pair 
part pair list corresponding arm case second part pair corresponds argument case 
example accomplishments research challenges meta programming test cons xs sum xs nil cl arg item list corresponding arms case pair 
element corresponds constructor function second element example meta function obtain right hand side arm 
example binding test example binds meta variables types bindings indicated table arg arg cl int cl int clearly remains considerable extend polish proposal robust apply realistic size object language 
case metaml needs deal statically scoped variables length deal typing issues constructors tuple 
higher level interfaces code analysis quasi quoted templates introduced way construct code patterns code matched 
supplies interface intensional analysis code interface previous section 
quasi quoted template pattern anti quoted variables template meta variables bound object code fragments pattern matching 
built simple prototype implementation metaml 
fun decompose decompose error bad val decompose fn decompose val decompose error bad engineering problems remain solved fully templates patterns 
pattern templates antiquotation indicate meta variables destined bound pattern matches 
templates include tim sheard context form concrete syntax disambiguate kind object level term matched 
cases remain problematic constants constructs 
wants match particular constant straightforward just wrap quoting brackets object language pattern matches code containing constant 
fun true false write pattern matches code constants doing binds meta variable value constant code matched 
easy algebraic datatypes 
algebraic datatype exp introduced section write fun constant templates context inside brackets distinguish constants 
example matches code just constants 
similar problem occurs matching language constructs sequence consist unbounded number similar sub constructs 
examples include tuples expressions multiple bindings 
example pattern matches tuples components 
fun pattern match tuples 
easy algebraic datatype approach 
pattern tuple xs matches tuples metavariable xs bound list sub expressions 
typing interface problematic 
robust template approach pattern matching code need address issues 
quasi quoted templates match binding constructs function abstraction case expressions requires solving problems variable escape saw section 
quasi quotes distinguish stages valuable property quotes anti quotes serve staging annotations distinguish meta program object program 
annotations important remove ambiguity 
consider program transformation replaces exceptions types haskell object program 
meta program defines magic brackets specify transformation 
lambda el raise try match data inl inr inl inl lambda match el lambda vl match vl inr inr inl inr inl lambda match inl lambda inr accomplishments research challenges meta programming transformation meta program 
meta programs described format typically research papers 
manipulates separate 
case analysis structure source object language builds element target object language 
contains meta variables 
tell variables 
skilled programming language researcher probably past experience context 
unambiguous algorithm leaves desired 
staging annotations remove ambiguity 
metaml staging annotations 
lambda vl match vl inr inr lambda inr note quotations delimit object code anti quotations indicate meta computations compute object code sub terms 
possible distinguish object variables meta variables noting binding occurrence quotations 
unresolved problems remain 
percent front attempt indicate pattern match variables meta variable bound object variable pattern matches 
problem concerns manipulating binding occurrences object variables lambda 
example solution similar feel function section 
patterns matching lambdas bind variables functions terms terms 
discussed detail section 
templates heterogeneous meta systems metaml implementation object language meta language share fixed representation parser type checker representation meta object languages chosen metaml system developers 
heterogeneous system templates problematic 
single fixed object language user define multiple object languages 
fixed strategy shared representation possible 
heterogeneous system meta programmers develop representations 
step direction addressed conctypes annika aasa 
describes algebraic datatype facility extended allows concrete syntax descriptions 
fixed parsing strategy tim sheard embedded extension users write conctype specifications behave grammar specification algebraic datatype definition 
integrating system treats object bound variables sensibly handles ambiguity problems constants sequence constructs allows object language typing remains open problem 
manipulating binding constructs seen meta programs particularly difficult write correctly manipulate object terms notion statically scoped variables 
related problems 
occurs generating programs include new binding occurrences 
generating new binding construct meta systems operator produces new unique name introduced 
strategy avoid inadvertent name capture free variables scope binding construct 
solution awkward separates name binding prescribes stateful implementation new names selected 
section discussed quasi quote template interface hide gensym process programmer 
second problem occurs deconstructing programs include binding occurrences 
exact representation bound variable generally uninteresting meta program subtle administrative changes object program maintains original meaning 
names need special attention prevent escape bound variables scope 
discussion intensional analysis code handling variables major complication 
representation meta program freed responsibility concretely representing bound variables names facilitates correct program manipulations quite useful 
interesting representation technique idea goes back church exploits binding mechanism metalanguage implement binding mechanism object language 
saw function 
illustrate elegance approach contrast definition term term 
term represent object language lambda abstraction meta language function abstraction 
note examples id term apply term represented applying constructor meta language function 
accomplishments research challenges meta programming data term art term term abs string term const int vat string id abs var apply abs abs art vat vat data term art term term abs term term const int id abs apply abs abs arr higher order syntax representation haas term elegant concrete representation variables needed necessary invent unique new names constructing lambda expressions hope clash names 
unfortunately drawbacks 
haas works fine constructing statically known representations quickly breaks trying construct observe representation algorithmic way 
problems illustrate examples 
haas bindings opaque 
pattern match observe structure body abs object level binding represented functions meta language metalevel functions extensional 
observe casting term example simulated evaluation session haskell noticing id prints abs fn 
id abs main id abs fn junk 
haas admits junk 
terms meta language type term represent legal object program 
consider example junk abs case app const legal object abstraction behaves way analyzing bound variable 
loss ty 
haas exist meta functions expressed 
consider writing show function term turns term string suitable printing 
legal metaprogram value show app show 
show show const tostring show abs show tim sheard term term function need sort variable type term apply unfortunately thing created solved section gensym var 
tricks solving problem matters worse 
latent effects 
haas delays non termination effects 
problem especially obvious strict language 
computational effects meta language introduced purely syntactic representation object language 
worse effects introduced observed 
term observed multiple times causes effects introduced multiple times 
example functions delay computation non terminating computation producing term may delay non termination term object observed 
may arbitrarily far construction things hard debug 
consider function bad 
bad const const bad app app bad bad bad abs abs diverge bad bad walks term increasing explicit constant 
suppose programmer mistake placed erroneous divergent computation abs clause 
note bad immediately diverge 
believe trick representing object level binding binding mechanism meta language 
higher order syntax 
catch function abstraction mechanism right binding mechanism 
function abstraction binding mechanism metalanguage 
solution introduce new binding mechanism 
years ago dale miller informally proposed simple elegant exten sion sml supporting higher order syntax new kind variable binding call object level binding 
proposal illustrated simplicity elegance haas means representing object languages left formal semantics typing system demonstration practical usefulness open problems 
illustrate variation miller extension basis representing object languages binders 
simple operational semantics variation miller language established operational semantics sound ad equate respect simple natural reduction semantics 
outline object level binding works 
consider lambda calculus example 
infix operator meta language term constructor new binding mechanism type constructor 
define algebraic datatype term analogous term new object level binding con struct function abstraction 
datatype term app term term abs term term const int accomplishments research challenges meta programming terms type introduced meta language construct object binding 
example app const term term 
convention hashed variables denote object level variables distinguish meta level variables 
new operator properties evaluation binding 
latent effects junk arise body object binding computation suspended function constant piece data 
solve problems object level binding evaluates binding operator 
attempts construct object language program abs bottom abs bottom expression left term language uses meta language binding mechanism abstraction 
succeeds representing object language program obviously meaning 
expression right term language represent object language program semantics evaluation proceeds objectlevel binding operator terminates 
note effect left object language program representation junk right non termination occurs object language program constructed object language program 
lazy setting similar problems occur manifest differently 
pattern matching repeatedly abs cause re computed 
pattern matching abs evaluate 
intuitive way think object level binding think having underlying order implementation supplied rich interface 
inside order implementation object level bindings represented pairs 
construction abs term translated underlying representation term construct provide fresh name required object bound variable gensym abs var important emphasize underlying firstorder implementation hidden user 
earlier criticized construct construct stateful forces meta language stateful purely functional 
fortunately gensym observed observe value name produced gensym 
interface hidden underlying implementation allows access variables restricted ways possible mask 
higher order pattern matching 
solve problem new binding mechanism support higher order pattern matching 
higher order pattern pattern match constructor tim sheard abs takes object level binding argument 
patterns higher order pattern binds meta variable meta variable bound higher order pattern bind object term binds meta level function type term term 
illustrate consider rewrite rule object terms term expressed abs app const prime indicates meta variable rule indicates capture free substitution const 
subtlety free occurrences inside higherorder pattern matching precise 
bound meta variable introduced higher order pattern function term term func tion behaves function hy 
idea concrete extending notion pattern metalanguage 
patterns explicit object level abstractions pattern variables inside body object level abstraction higherorder pattern variables bind functions 
rewrite rule specified follows abs tx app tx const const example function matches argument objectlevel abstraction 
body abstraction application term constant 
function part object application term 
term may free occurrences object bound variable write pattern name object term matches 
higher order pattern composed application variable variable 
application reminds user function formal parameter object bound variable underlying implementation order term patterns form term efficient implementation visualize follows abs subst const loss expressivity 
simple programs expressed simply meta language construct object binding introduce object variables 
example identity function term expressed identity app app identity identity identity const const identity abs abs identity identity fourth clause identity function illustrates pattern matching construct object level variables introduced operator 
similar isvar function section pattern matches object level variable binds meta variable term matched 
necessary introduce new object variable simply place holder eliminate completely computation 
accomplishments research challenges meta programming problem show function section reason gensym var functions section 
solution problem new language construct discharge 
construct discharge el introduces new object level variable scope body el 
value discharge construct body el 
body el type object level binding object term 
addition discharge incurs obligation variable appear value body el 
implementation raise error occurs 
example consider function counts number const sub terms terra 
count term int count const count app count count count abs discharge count count note fourth clause conveniently replaces introduced object bound variables guaranteeing object variable appears result 
obligation variable escape body discharge construct may require run time check example result type int occurrence happen 
freshml alternative approach binding contrast higher order syntax approaches binding mechanisms meta language represent binding constructs alternative approach emerged andrew pitts murdoch gabbay 
frankel set theory dates back 
theory model reason datatypes represent order terms variable names modulo convertibility 
freshml introduces language constructs correctly manipulating terms type system ensures manipulating equivalence classes 
intuitively approach resembles version known nameless de bruijn style representing binding constructs 
main advantage programmer burden reasoning complicated algorithmic interface nameless terms cast user friendly setting 
shall example language slightly modified syntax demonstrate concepts 
data abs atm app var arm tim sheard expression var type atm denotes atom abstraction 
think atom abstraction consisting pair atom representing object variable name lambda term may contain name subterm 
language contains constructs ensuring freshness atoms respect bindings inside terms 
val apply abs abs app war war term apply represents known lambda calculus term hx hy construct build atom abstraction 
construct introduces fresh atom bound meta variable construct evaluates atom abstraction type atm freshness construct assures actual name atoms atom abstractions irrelevant freely transposed obtain equivalent values 
language supplies facilities pattern matching atom abstractions 
consider examples fun right abs app abs app fun wrong abs app app abs function right analyzes abstraction 
pattern matching similar apart pair 
type system ensures result function lambda term depend actual name object variable second function wrong rejected type checker resulting term may result terms belonging different equivalence classes different transpositions atom happens atom denoted occurs subterm 
freshml haas seek model classes equivalent terms 
freshml approach advantage formalized set theoretical foundation supporting order datatype style induction terms 
haas freshml approach lack efficient robust implementations programming language setting experiment 
open problems area include development operational semantics development calculus performing equational reasoning 
manipulating typed object programs meta programmed systems gain wider acceptability especially run time code generators systematic efforts guarantee safety properties object programs produced developed 
example type safety 
key tracking type safety object programs static analysis meta programs manipulate embedding type object program type object terms 
metaml straight forward accomplish 
explained new type constructor accomplishments research challenges meta programming give object level term code type 
metaml homogeneous sys tem type object level terms captured type system capture types meta language 
quasi quotation mechanism exploited infer type object language fragments meta language languages structure typed type system 
principal design feature metaml 
val val val code val code show note type pronounced code int code type metaml type correctness meta program guarantees type correctness syntactic correctness object programs manipulates 
polymorphism staging section discuss interaction staging polymorphism 
hindley milner style type inference bound variables generalized polymorphic types 
staging introduces new possibility generalization 
templates new generalization point 
homogeneous meta systems designed code templates rank polymorphic types 
question studied context inferring static types dynamic documents mark shields ph thesis thesis shields studies interaction staging implicit pa rameters 
interesting implicit parameters staged context interpreted parameters supplied environment generated code execute 
interaction staging implicit parameters polymorphism discussed quite interesting 
example type assigned template 
design issues implicit problem quite complex scope short synopsis 
refer thesis full details 
tim sheard dependently typed meta programs unusual meta programs different inputs type produce object programs different types 
behavior usually typed dependent type system 
example write meta program metaml style quasi quotations 
result applying values different type type depends value normally indicates pi type 
pi type function arrow type right dot depend value bound variable left dot 
give function dependent type int 
function function int types 
go int language dependent types programs dependent types explicit type signatures 
signatures notoriously difficult discover reason dependent types normally normal programming languages 
unfortunately useful meta programs dependent types occur time 
open problem discover mix dependent types meta programming usable manner 
approach writing dependently typed meta programs delay typing till run time 
approach code type constructor longer type constructor simply type 
metaml code constructed templates representation code run time carries information structure code information type 
quasi quoted template anti quotations statically typed assigned type val val bad error sub term function 
accomplishments research challenges meta programming code run splicing piece code anti quotation meet run time check code type meaningful context 
templates statically typed splicing run wait run time type checking 
example consider algebraic data type representing syntax simple functional language data term chat nat bool var string abs string term app term term cond term term term eq plus possible write interpreter interp term env code constructed dynamically type checked constructed 
interp env interp env interp var env env interp abs env interp extend interp app env interp cond env interp eq env interp plus env interp app gnat gnat env causes run time type error code fragment spliced context requires function 
similar kind error occur running piece code 
term run interp true env causes run time error result interp typed program type bool context requires int 
rich dependent type system infer kinds errors statically 
remains open problem 
typing heterogeneous meta programs heterogeneous systems simple code type constructor longer possible type system meta language may completely different type system needed type object language 
idea typing object level term type applied argument encodes type object level term 
need broaden notion legal argument type constructor 
tim sheard kinds 
functional languages notion kind fine distinction types types values 
type grammar int tree kind grammar star example types int int int int int int tip tree int example kinds int star int int star int int star tree star star star star star typed language types partition value space sets values similar properties 
kinds partition type space sets types similar properties 
types fall partition values historical reasons kind star 
example kinds table 
type constructors construct types types give type constructors higher order kinds 
distinguish kind arrow type arrow distinguish kind relation type relation 
years functional languages supported extensible type systems 
user add formed types defining new types algebraic datatype definition facilities 
example haskell add type constructor tree writing data tree tip fork tree tree definitions add new type constructor tree grammar formed types new values tip fork tip tip formed values 
addition extensible kinds extensible types way attack problem object code types 
introduce new kind algebraic structure models type object terms 
new kind index object term type constructor 
writing comment add new kind grammar formed kinds new types grammar formed types 
types familiar types kind kind star 
notice program values types 
types kind star encode object level types object programs 
indexed object types 
enriched type system sufficient power encode object language type constructor takes kind parameter indicating type object term encoded 
call type accomplishments research challenges meta programming indexed type index set set formed type terms kind 
order represent types need generalize algebraic datatype definition facility 
explicitly kinding type type constructor defined full type datatype constructor functions 
example familiar tree definition data tree tip fork tree tree considered short hand verbose precise definition data tree star star tip tree fork tree tree tree power define object language expression language products 
values algebraic datatype type type constructor applied kind data exp star int exp xy ab exp exp exp exp exp ab pi exp exp object languages usually specified syntax specifies form type judgments specifies membership set formed object terms 
enriched algebraic datatype definition mechanism cooperation extensible kind mechanism powerful mechanism allows single framework 
note meanings type judgments right captured type system metalanguage types value constructor functions object type exp open problem construct system typed metaprogram type exp specification object term described proof object type functions indexed typed terms 
object language representations indexed types manipulated meta programs normal way 
type system meta language maintain typedness terms 
simple example 
data value star int value value value value eval exp value eval eval eval eval eval case eval eval case eval introduced second object language call value 
value indexed type index exp meta program eval transforms exp value tim sheard meta programs manipulate indexed object level terms need richer type checking system type traditional programs 
problems 
function eval type checked polymorphically recursive type 
clause eval eval eval occurrences eval 
terms eval val type exp value eval eval type exp value eval eval type exp value second third instances reconciled giving eval polymorphically recursive type 
important considerations type inference polymorphically recursive functions general possible 
means meta programs manipulate indexed object level terms explicit type signatures eval exp value 
problem concerns way functions type checked 
usually clause multiple clause definition exactly type 
indexed object level terms rule relaxed 
study clauses left type right 
eval eval exp value eval eval eval eval exp value eval case eval eval exp value eval pi case eval eval exp value note type exp value second exp value clause incompatible unified indices incompatible 
indexed type constructors identical indexing clause gives typing eval exp value 
clause differs indices indices instance declared indices clauses mutually exclusive exhaustive typing clause independently sound mechanism 
open problem find right combination type system theory prove soundness property 
indexed types dependently typed programs world indexed object terms special class programs dependent types easy understand handled quite efficiently programs dependency index type value 
programs handled quite easily constrained qualified type system 
constrained type system function constrained type form va ca interpret types meet constraint accomplishments research challenges meta programming ca function type constraint qualifies quantification 
types type class system haskell 
mechanism track dependencies indexes 
example consider alternative eval function returning kind object term value returns actual tuple 
note qualified type eva eva encodes exp eva eva eva eva eva case eva eva case eva function eva dependent type type result depends value exp consumes 
dependency weaker 
type eva depends index parameter type exp value 
express type eva 
interpret eva type constraint encodes met eva takes exp input produces value type rule encodes star rule encodes int encodes encodes encodes predicate types simple prolog definition 
constraint encodes track type dependency result eva input 
tracking dependencies 
understood theory constraint propogation management brought bear meta programs eva 
consider function eva constrained type system constraint encodes type eva propagated type inference type encodes int exp int int prolog rules constraint resolution solve constraint encodes int unifying 
infer new type exp int int 
sound system built ideas answer questions remains open problem 
discussed ways deal dependently typed meta programs require full dependent type declarations meta programs language cayenne type checking 
second 
put type checking run time 
pro gram errors caught run time 
tim sheard third extensible kinds implement indexed types 
index track value information length list type objects 
dependency index value 
fourth extend third mechanism qualified types track sophisticated dependencies 
theory meta programs foundations meta programming systems laid programming language community 
theoretical far concentrated metaprogramming systems generating code 
denotational operational type theoretic treatments abound 
area code analyzers considerably 
flemming nielson hanne nielson thoroughly studied denotational semantics interpretation level languages context compiler design specification 
area partial evaluation attacked performance problems interpreted solutions 
particular interest meta programming community robert jesper jorgensen 
study un typed multi stage languages context binding time analysis offline partial evaluation 
important early formal investigations staging computation carried rowan davies frank pfenning 
studied typed multi stage languages :10.1.1.16.4975:10.1.1.28.4059
languages explore type systems find connections intuitionistic modal logic linear time constructive modal logic languages type constructors code 
important relating areas thesis walid taha 
thesis explains utility program generation general importance type safety guarantee generation paradigm 
thesis explains detail difficulties arise specifying mathematical semantics staged programs presents proofs 
proof justifies claim type safe programs generated 
proof subject reduction proof 
key technical contribution provides type system generated code run executed framework code constructed 
taha thesis explains metaml combines features useful features 
important generalization davies pfenning 
guarantee highly desirable system run time code generation 
addition type properties taha provide equational theory staged programming language 
theory prove staged programs normal program staged partially evaluated counterpart 
taha equational theory built equivalence proof small step reduction semantics operational big step semantics 
accomplishments research challenges meta programming taha reduction semantics relies standard notion substitution earlier need additional machinery performing renaming run time 
insight major advance theory program generators 
opens way standard techniques manipulating program generators formal objects 
addition taha thesis done improving preciseness type systems metaml 
type systems designed prevent phase errors situations values stage prior definition illustrated section 
papers develop reduction natural semantics prove important properties 
denotational semantics perspective categorical analysis studied eugenio moggi tim sheard walid taha benaissa yielding semantics class categorical models 
motivated categorical analysis group rigorous formulation metaml supporting open closed code 
theoretical study multi stage imperative programming languages undertaken eugenio moggi walid taha 
study operational semantics type systems language safely combines imperative state multi stage programming 
practical applications semantic approaches meta programming systems bear fruit 
supply firm foundation engineering necessary realizing robust implementations staged programming languages done 
building implementations meta programming general staged programming particular important way think computation 
long time hampered attempts promote view computation lack vocabulary lack running systems treat object computations class manner 
challenge building robust implementations program generation systems remains 
attempts really caught attention community large 
metaml attempt 
metaml interpreter attempt provide tool representations programs called code class objects 
metaml excellent tool demonstrating meta computation expressed high level abstraction type safe manner interpreter code produces slow interact languages systems 
exercise staged language implementation learned valuable lessons 
building system polishing people may supporting huge amount 
notable exceptions tim sheard metaml largest system worked respects toy 
despite limitations building metaml extremely valuable experience worth sharing 
important lessons learned building metaml system summarized 
homogeneous system 
metaml homogeneous system meta language object language 
homogeneity plays important role aspects metaml experience shown heterogeneous systems important role play 
heterogeneous system fixed meta language possible build multiple systems different object language system multiple object languages equally useful 
template presentation 
metaml constructs object code pattern object code templates 
templates look object language represent 
program fragments easy combine larger program fragments templates holes 
templates metaml really easy construct object programs 
remains done templates pattern match code deconstructing object programs 
explicit annotations 
manually placing staging annotations burden supported quasi quote presentation 
manually annotated programs percent non staged versions 
annotations semantically meaningful just ad hoc suggestions compiler preprocessor 
define precisely mean implementation certainly problematic 
staged generators 
metaml stage meta programming generation system 
metaml produces code generators 
metaml generators produce object code output generator stage 
limit number stages metaml program 
useful theoretically little practical 
programmers find hard write programs stages 
intensional analysis code 
metaml designed produce code analyzers ability analyze internal structure code objects important capability designed meta programming system 
analysis code important domain program generation allows generators optimize code generated 
static scoping 
metaml handles free variables object code templates building code free variables obey rules static scoping 
variables free template bound scope template appears scope resulting code executed 
metaml handles bound variables object code templates way guarantees name clashes inadvertent variable capture 
type safety 
metaml type safe meta programs guaranteed manipulate produce type safe object programs 
important lesson learned 
writing meta programs hard 
accomplishments research challenges meta programming dimensions possible introduce errors 
tools objectlevel typing help programmer task worth weight gold 
observability 
object programs observed printed 
essential debugging meta programs 
metaml object programs pretty printed manner normally written programmers 
represented representation unfamiliar meta programmer 
reflection 
metaml object programs constructed typed run single system 
ability test generated code leaving meta system great boon programmers 
facility ought available meta programming system heterogeneous system 
meta language ought embed interpreter facilitate object language testing 
attempts emphasized different aspects code generation paradigm 
particular speed important concern run time generation systems 
tradeoff dimension generate code quickly generate code runs fast 
techniques support strategies get way addressing 
basically strategies achieving run time code generation 
generate source code abstraction run time generate machine code directly run time 
implemented straightforward manner run time compiler 
lends post processing phases code transformations register allocation 
processing requires time goal generating code quickly thwarted 
requires larger run time systems compiler available 
generating machine code directly complex potentially quicker perform intermediate step required 
unfortunately important optimizations register allocation harder perform scheme 
generating machine code hard generic cross platform compatible machine architecture intimately involved code generation phase 
issues addressed include allocation garbage collection generated code constructing generated code unknown unbounded size collecting generated code longer needed 
garbage collection systems designed collect data code resident different portions memory 
staged system maxim code data true 
problem run time code generation different kinds variables bound lambda bound global external different access methods depending kind variable may reside stack heap exception sml nj collects code code allocated heap 
tim sheard register 
keeping track run time difficult general purpose solutions kinds variables introduce inefficiencies 
light discuss dynamic code generation systems 
tcc 
pronounced tick compiler tcc designed generate code run time 
stage language type system object level 
uses template approach construct object level code implementation independent manner 
goal generate code quickly generate code runs fast 
claim tcc generates code rate order instructions generated instruction depending level dynamic optimization employed 
sophisticated run time register allocation scheme increase performance generated code 
tempo 
tempo large project investigating partial evalu ation strategies code 
aspect tempo dynamic code gener ation specialization 
capability relies binding time analysis partial evaluator 
static parameters input dynamic code generation partitions code stages 
static stages compiled normal fashion dynamic stages reduced code templates 
template compiled sequence instructions generates code run time 
tempo staging performed semiautomatic manner bta 
tempo implementation strongly tied code generation capabilities gnu compiler portable 
strong advantage tempo system ability applied existing code base 
dynamo project 
dynamo project works imple infrastructure building programs dynamic optimizations run time information unavailable static optimizers perform optimizations program executing 
dynamo compiler broken number stages 
user annotations determine stages run statically compile time dynamically run time annotated code fragment 
user specific tradeoffs speed vs time space vs time depending stages compiler delayed run time 
stage uses different run time representations code better suited certain kinds optimizations 
annotations somewhat adhoc nature placed programmer 
annotations potentially profiling information decide representation code particular piece source program fully compiled 
fabius 
fabius compiler staged language 
fabius uses explicit annotations stage program ml language 
staging annotations fabius type systems devised frank pfenning rowan davies 
metaml fabius dynamic code generator types object level code 
accomplishments research challenges meta programming uw dynamic compilation project 
dynamic compilation system 
regions code marked specialization variables regions declared dynamic static 
analysis determines code compiled compile time code deferred run time compilation 
regions nested overlap 
annotations provided programmer control number tradeoffs space time 
implementations generated number different architectures applications meta programming worked read interesting applications meta programming techniques think worth mentioning 
macro design 
macros application staged programming macros define computation intended run compile time 
macro systems string lisp scheme macro systems designed run type checking 
macros traditionally define new binding constructs 
scope meta systems discussed note 
steven ganz amr sabry walid taha designed macro system strongly typed capable introducing new binding constructs 
providing translation macro language stage metaml program 
language implementation 
staged programming combined mon ads implement domain specific languages 
staging semantics interpreter produces compiler language interpreted 
monads complement staging describing control structure effects manner orthogonal staging issues compiler implementation 
equational logic metaml prove compiled code produces outputs non staged interpreter 
dynamically adaptable software 
staged programming specify adaptive systems profiling information gathered run time recompile adapt better current running environment 
metaml staging annotation allow programmer express difficult concept high level abstraction frees user completely minutiae runtime code generation 
interacting systems 
generators designed generate code single environment 
build meta systems ability produce object programs interact differing environments 
environment program generator fixed legacy system clients control 
wouldn nice construct generator configured generate code multiple environments 
norman ramsey written clear tim sheard exposition interesting issues need addressed building system 
hope notes inspire discussion research implementation efforts field meta programming 

aasa 
user defined syntax 
phd thesis chalmers university dept computer science chalmers university sweden 

aasa 
precedence conc types 
fpca conference functional programming languages computer architecture copenhagen denmark pages new york june 
acm press 

aasa petersson 
concrete syntax data objects functional languages 
proceedings acm conference lisp functional programming pages 
acm acm july 

abadi cardelli 
imperative object calculus invited 
theory practice object sytems 

augustsson 
cayenne language dependent types 
acm sigplan notices jan 

auslander philipose chambers eggers 
fast effective dynamic compilation 
proceedings acm sigplan conference programming language design implementation pages philadelphia pennsylvania may 

barras comes courant herbelin huet murthy parent paulin sa qi werner 
coq proof assistant manual version 
technical report inria august 

bawden 
quasiquotation lisp invited talk 
acm sigplan workshop partial evaluation semantics program manipulation pages 
acm brics notes series january 


benaissa moggi taha sheard 
categorical analysis multi level languages extended 
technical report cse department computer science oregon graduate institute dec 
available 


benaissa moggi taha sheard 
logical modalities multistage programming 
federated logic conference floc satellite workshop intuitionistic modal logics applications july 
appear 

burger 
compilation profile driven dynamic recompilation scheme 
phd thesis indiana university computer science department march 

burger dybvig 
infrastructure profile dynamic recompilation 
proceedings international conference computer languages pages 
ieee computer society press 
accomplishments research challenges meta programming 
burstall goguen 
informal specifications clear 
boyer moore editors correctness problem computer science pages 
academic 
reprinted software specification techniques gehani andrew editors addison wesley pages 

moggi taha 
closed types simple approach safe imperative multi stage programming 
automata languages programming pages 

carnap 
logical syntax language 
kegan paul 

church 
formulation simple theory types 
journal symbolic logic 

consel hornof marlet muller thibault volanschi 
tempo specializing systems applications 
computing surveys electronic section 

consel noel 
general approach run time specialization application conference record popl rd acm sigplan sigact symposium principles programming languages pages st petersburg beach florida jan 

davies 
temporal logic approach binding time analysis 
proceedings th annual ieee symposium logic computer science pages new brunswick july 
ieee computer society press 

davies pfenning 
modal analysis staged computation 
rd annual acm symposium principles programming languages popl pages st petersburg beach jan 

de bruijn 
lambda calculus notation nameless dummies tool automatic formula manipulation application church rosser theorem 

math 

dybvig 
om syntactic abstraction 
higher order symbolic computation apr 

dybvig hieb bruggeman 
syntactic abstraction scheme 
lisp symbolic computation dec 

elliott 
extensions applications higher order unification 
phd thesis school computer science carnegie mellon university may 
available technical report cmu cs 

engler hsieh kaashoek 
language efficient machine independent dynamic code generation 
proceedings rd acm sigplan sigact symposium principles programming languages popl pages st petersburg beach florida january 
earlier version available mit lcs tm 

fegaras sheard 
revisiting catamorphisms datatypes embedded functions programs fi om outer space 
conf 
record rd acm sigplan sigact syrup 
principles programming languages popl st petersburg beach fl usa jan pages 
acm press new york 

gabbay pitts 
new approach syntax involving binders 
longo editor proceedings lth annual symposium logic computer science lics pages trento italy july 
ieee computer society press 

gabbay 
theory inductive definitions equivalence semantics implementation programming language 
phd thesis cambridge university 
tim sheard 
ganz sabry taha 
macros multi stage computations typesafe generarive binding macros 
proceedings acm sigplan international conference functional programming icfp new york september 
acm press 

jorgensen 
efficient multi level generating extensions program specialization 
swierstra hermenegildo editors programming languages implementations logics programs plilp volume lecture notes computer science pages 
springer verlag 

jorgensen 
fast binding time analysis multi level specialization 
bjorner broy editors perspectives system informatics volume lecture notes computer science pages 
springer verlag 

jorgensen 
automatic program generator multi level specialization 
lisp symbolic computation 

gordon melham 
hol theorem proving environment higher order logic 
cambridge university press 

mock philipose chambers eggers 
expressive dynamic compiler tcs theoretical computer science 

philipose mock chambers eggers 
evaluation staged run time optimizations 
proceedings acm sigplan conference programming language design implementation pages atlanta georgia may 

harper honsell plotkin 
framework defining logics 
proceedings symposium logic computer science pages washington june 
ieee computer society press 
conference held cornell university ithaca new york 

harrison sheard 
dynamically adaptable software staged language 
proceedings workshop semantics applications implementation program generation september 
appearing proceedings 

hornof jim 
certifying compilation run time code generation 
higher order symbolic computation dec 

johnson 
yacc compiler compiler 
technical report bell labs 

jones 
qualified types theory practice 
programming research group oxford university july 

jones 
theory qualified types 
krieg bruckner editor esop th european symposium programming rennes france february proceedings volume lecture notes computer science pages 
springer verlag new york ny 

lee leone 
optimizing ml run time code generation 
sigplan conference programming language design implementation pages 

leone lee 
lightweight run time code generation 
partial evaluation semantics program manipulation orlando florida june technical report department computer science university melbourne pages 

leone lee 
dynamic specialization fabius system 
acm computing surveys es sept 

accomplishments research challenges meta programming 
lewis launchbury meijer shields 
implicit parameters dynamic scoping static types 
proceedings th acm symposium principles programming languages pages jan 
acm press 

massalin 
synthesis implementation fundamental operating system services 
phd thesis columbia university 

miller 
extension ml handle bound variables data structures prelim report 
informal proceedings logical frameworks bra workshop june 
available upenn cis technical report ms cis 

moggi 
functor categories level languages 
fossacs volume lecture notes computer science 
springer verlag 

moggi taha benaissa sheard 
idealized metaml simpler expressive 
european symposium programming esop volume lecture notes computer science pages 
springer verlag 

moggi taha benaissa sheard 
idealized metaml simpler expressive 
lecture notes computer science 

nielson 
program transformations denotational setting 
acm trans 
prog 
lang 
syst july 

nielson 
correctness code generation level meta language 
robinet wilhelm editors proceedings european symposium programming esop volume lecture notes computer science pages mar 
springer 

nielson 
level semantics interpretation 
theoretical computer science dec 

nielson nielson 
level semantics code generation 
theoretical computer science jan 

noel hornof consel lawall 
automatic template runtime specialization implementation experimental study 
proceedings international conference computer languages pages 
ieee computer society press 

oregon graduate institute technical reports 
box portland usa 
available online fi om ftp cse ogi edu pub tech reports readme html 
viewed august 

paulson 
isabelle theorem provers 
odifreddi editor logic computer science pages 
academic press 

sheard taha 
dali untyped cbv functional language supporting fn st order datatypes binders technical development 
submitted icfp 

sheard taha 
dali untyped cbv functional language supporting fn st order datatypes binders technical development 
technical report cse ogi 
available 

pfenning 
elf language logic definition verified meta programming 
fourth annual symposium logic computer science pages pacific grove california june 
ieee computer society press 

pfenning 
logic programming lf logical framework 
huet plotkin editors logical frameworks pages 
cambridge university press 
tim sheard 
pfenning 
system description twelf meta logical framework deductive systems 
ganzinger editor proceedings th international conference automated deduction cade volume lnai pages berlin july 
springer verlag 

pitts gabbay 
metalanguage programming bound names modulo renaming 
backhouse oliveira editors mathematics program construction 
th international conference mpc ponte de lima portugal july 
proceedings volume lecture notes computer science pages 
springer verlag heidelberg 

poletto hsieh engler kaashoek 
tcc language compiler dynamic code generation 
acm transactions programming languages systems march 

poletto sarkar 
linear scan register allocation 
acm transactions programming languages systems september 

pollack 
theory lego proof checker extended calculus constructions 
phd thesis university edinburgh 

pu massalin ioannidis 
synthesis kernel 
usenix journal computing systems winter 

ramsey 
pragmatic aspects reusable software generators 
proceedings workshop semantics applications implementation program generation pages september 
workshop held collaboration international conference functional programming icfp 

sheard 
metaml staged programming language 
lecture notes computer science 

sheard benaissa 
dsl implementation staging monads 
second conference domain specific languages dsl austin texas october 


shields 
static types dynamic documents 
phd thesis department computer science oregon graduate institute feb 
available www 
cse 
ogi 
edu mbs pub thesis thesis 
ps 

shields sheard jones 
dynamic typing staged type inference 
proceedings th acm sigplan sigact symposium principles programming languages pages jan 

steele jr gabriel 
evolution lisp 
acm sigplan notices 

taha 
multi stage programming theory applications 
phd thesis oregon graduate institute science technology july 
revised october 
available author taha cs chalmers se 

taha 
sound reduction semantics untyped cbn multi stage computation theory metaml non trivial 
proceedings acm sigplan workshop evaluation semantics program manipulation pepm pages jan 
acm press 

taha 
sound reduction semantics untyped cbn stage computation 
theory metaml non trivial 
sigplan workshop partial evaluation semantics program pepm jan 

taha 
benaissa sheard 
multi stage programming axiomatization type safety 
th international colloquium automata languages programming volume lecture notes computer science pages aalborg july 
accomplishments research challenges meta programming 
taha 
benaissa sheard 
multi stage programming axiomatization type safety 
technical report cse oregon graduate institute 
available 

taha sheard 
multi stage programming explicit annotations 
proceedings cm sigplan symposium partial evaluation semantic program manipulations pepm amsterdam pages 
acm 
extended revised version appears 

taha sheard 
metaml multi stage programming explicit annotations 
technical report cse department computer science oregon graduate institute jan 
extended version 
available 

taha sheard 
metaml multi stage programming explicit annotations 
theoretical computer science 
revised version 

thibault consel muller 
safe efficient active network programming 
seventeenth ieee symposium reliable distributed systems srds pages washington brussels tokyo oct 
ieee 

van quine 
mathematical logic 
harvard university press cambridge edition 
