hierarchical modularity matthias blume princeton university andrew appel princeton university cope complexity large systems sufficient divide simple pieces pieces numerous large 
hierarchical modular structure natural solution 
article explain approach applied software 
compilation manager provides language specifying individual modules fit hierarchy related semantically 
pay particular attention structure global name space program identifiers module linkage potential name clashes unrelated parts program negatively affect modularity 
discuss theoretical issues building software hierarchically describe implementation cm compilation manager standard ml new jersey 
categories subject descriptors software engineering tools techniques modules interfaces programming languages language constructs features modules packages general terms design languages management additional key words phrases compilation management linking modularity modules name visibility program structure 
imagine working large software project consists main module various parts implementation see 
course development want able add refine replace components causing disturbance rest system 
particular modification module require modifications parts conceptually related 
wish list illustrates array problems really problem viewed different angles structural refinement 
principles structuring entire programs applicable parts program 
example supported part nsf ccr 
authors addresses blume research institute mathematical sciences kyoto university kyoto japan email blume kyoto ac jp appel department computer sciences princeton university princeton nj email appel cs princeton edu permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions programming languages systems vol 
july pages 
matthias blume andrew appel lib main main newy fig 

schematic view software project 
subsystem newy consists parts outside presents module 
grouping 
conversely grouping existing modules able form larger modules 
examples library modules lib 
structural refinement grouping really refer underlying idea prefer case top development constructing programs bottom fashion existing parts 
sharing 
addition components newy library primitives base api 
modules 
groups modules produced structural refinement disjoint 
libraries source code 
suppose purchase library lib software vendor 
possible having inspect recompile modify constituent parts vendor may want provide source code 
libraries imports 
libraries usually rely libraries 
example lib imports 
provided exported interfaces match import interface possible user supplied version 
acm transactions programming languages systems vol 
july 

hierarchical modularity extending interfaces 
developed extending existing older version called 
want able directly reuse original code adding wrapping code export interface richer contains definitions exported 
minimizing dependencies 
moving affects components indirectly main 
necessary recompile modify module 
cutoff recompilation 
certain modifications export interface affect export interface cause main recompiled 
compilation unit recompiled source code imports changed 
names separate modules 
internally implementation uses name communication modules 
appear library interface library clash regardless name variable type module name space 
redefinitions 
module exports uses form different exported done ways avoid clash uses name clashes module 
module main needs refer lib exported 
authority names exports 
true want modify variety reasons 
able simultaneously possible rename definitions time import 
multiple alternative module implementations 
experimenting implementation mean trying various different approaches implementing module 
example provide implementation replacing entail modifications recompilations changes export interface 
versions safely differ take advantage imports available imports 
profiling want versions object derived source code 
enables transparently selectively provide profiling debugging support 
important versions interface need modify recompile clients 
clients lib access source code 
location 
typically components program stored sort file system provided underlying operating system 
development files may frequently change names locations 
example called name change necessary recompile modules 
requires file name hard wired result compiling client modules worse source code 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel compilation manager software cm able gracefully handle situations listed 
group model provides support structural refinement grouping 
avoids name clashes allows redefinitions necessary 
dependency graphs dags permit sharing 
libraries source code supported stable library mechanism 
libraries import libraries type safe linking ensure consistency 
interfaces extended nested groups 
built analyzer automatically calculates dependencies compilation modules cutoff recompilation helps minimize actual recompilation 
separation programming configuration languages possible seamlessly relocate replace compilation units entire libraries 
cm solution list problems showed 
example feldman feldman modern derivatives tools explicitly manipulate object files library archives environments symbol tables expert users achieve goals outlined 
put manipulations control sophisticated system adams solomon 
cm uses techniques internally provides simple declarative specification language interface operations 
hand operation intermodule semantics user programming language way cm operation ml intermodule semantics 
requiring dependencies spelled full improves logical inference engine calculate dependencies declarative database 
may possible emulate cm behavior doing require implement cm syntactic semantic analyses specification put differently implement cm top 
logic inferencer performance problems due inefficient search strategy 
upside persistent database avoids struggle native file system semantics 
area cm take lessons 
explicit symbol table manipulations provide great power conceivable problem related name resolution 
example solution ad hoc link time renaming identifiers reported experimental modula programming language environment developed part vesta brown ellis 
power comes price program longer understood solely terms programming language written 
take account semantics tools happen manipulate various intermediate objects emerge process compilation 
semantics system version dependent rarely documented rigor applied programming language definitions power far reaching impact meaning program 
situation especially original programming language aiming semantic clarity foundedness 
avoid problems control full power explicit symbol table manipulations providing amounts programming language extension standard ml sml cm 
new cm part programmer express desired grouping modular components directly having acm transactions programming languages systems vol 
july 
hierarchical modularity know operations cm invoke behalf 
pleased find modest extension sml sufficient achieve desired effect 
result feel completely new programming language 
believe programming cm easier programming associated tools 
explain cm internals terms low level operations environments 
clearly restricted ml languages carried fairly directly 

aspects modularity compilation management separate compilation need split programs smaller pieces compile resulting fragments separately arose practical considerations machines small compilers efficient handle large bodies code parnas 
established physical boundaries placed cleverly profoundly positive impact program structure 
long time separate compilation key element modern software engineering cardelli 
divide conquer 
abstraction modularization divide conquer software engineering 
ability verify partial designs isolation enables programmers operate teams 
hundreds thousands people body code important individual pieces separated 
need communication programmers purpose coordinating individual tasks quickly gets hand 
modularization great help single person projects provides way serializing 
programmer focus efforts part having worry possible implications 
type checking interfaces 
type systems compile time decidable formal systems track intermodule dependencies 
type safe linking extension ordinary linking name address resolution notifies programmer inconsistency type module exports identifier type module imports 
link time notification valuable prevents kinds run time bugs 
link time notification necessary development important detect problems early needs revised redone 
explicit interfaces way writing modules depend 
cut graph potential dependencies dense sparse 
adherence constraints laid interface definitions verified compile time saves precious development time 
hierarchical modularity modularization separate compilation synonymous cases compilation unit boundary module boundary 
modern programming languages tend adequately support modularization compilation units 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel printf hello world stdio printf fprintf sprintf fig 

sharing source file 
programming languages programmer control interface source file guarantee shared clients 
declare static local functions exposed 
programmer way prohibit stdio referring symbols system prevent system 
article concerned modules consist potentially span compilation unit 
modular structure assumed introductory example arises naturally engineering tasks 
cope complexity large projects routinely divided parts 
parts interoperate interface specifications 
interfaces hide internal complexity part implementation parts 
modularization module overly complex modules 
accomplished hierarchical structure module constructed submodules 
course subdivision part manifest interface 
seen outside part acts single module internally structured smaller subcomponents 
result hierarchy modules 
hierarchical modularity new concept large engineering projects 
case software systems applied informally programming languages compilation management provided active support jacobson 
real world examples show need hierarchical modularity 
depicts situation module stdio shared different projects 
administer interface compiler guarantee absence unwanted dependencies 
fully supported programming languages 
large scale programming need take 
important allow stdio group source files summary interface controls group interface various clients see 
illustrates cm deal situation 
library stdio implemented cm group clients explicitly list group import services 
client depend implementation details explicitly advertised group export interface 
subgroup relationship unidirectional 
stdio group acm transactions programming languages systems vol 
july 
printf hello world stdio fprintf sprintf printf hierarchical modularity fig 

sharing groups source files 
want group sources act module 
explicit interface placed stdio opposed constituent components guarantees absence undesired dependencies expose local objects 
language mechanisms expressing requirements 
printf hello world fprintf stdio sprintf printf fig 

controlling sharing groups 
cm structure project shown collection groups 
export interface group stdio sure implementation details local function exposed clients 
time stdio specific listing imports depend 
mention part imports 
design group caters specific needs selected clients subsequent modification client cause incompatibilities compatible 
semantics versus dependencies compilation management deals separate problems 
hand provide way describing semantic relationships separate modules names resolved module boundaries hierarchies modules formed 
hand determine intermodule compilation dependencies subset sources needs compiled recompiled order 
essentially part optimization compilation process 
ways going start dependency information derive resulting semantics program start semantic description try infer dependency information 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel automatic tool route convenient tool really care semantics just needs follow dependencies easy 
exemplified approach works generic way arbitrary programming languages tools 
drawback programmer wants know meaning program read descriptions compilation dependencies annotated associated build operations unix commands understand semantics semantics interactions infer program meaning challenging task cases 
cm takes approach 
provides language describing semantics system divided separate modules 
group model described section 
specifies hierarchy modules scoping rules span module boundaries 
specification semantic aspects cm calculate resulting compilation dependencies 
names name spaces module exports definitions definition known modules name second importing module purpose time 
problem programmer second module certainly aware anyway easily avoid name conflict 
coordinating development conceptually related components relatively easy 
name clashes detected early development cycle occasional conflict resolved occurs 
require modifications unrelated components 
troubling names conceptually unrelated modules kept apart 
second module import may easily happen programmer know module existence 
fact having know unrelated modules clearly desirable programmer participates large project modules 
preventing clashes means amount coordination necessary making development independent modules difficult 
discuss examples undesirable effect see figures 
library designers attack problem naming conventions example adding prefix exported identifiers 
reality preventive measures applied nearly universally guarantee prefixes clash 
result difficult simultaneously libraries sold different vendors especially conceptually connected different purposes unrelated parts program 
entire source code libraries available challenging problem resolve naming conflicts ford section 
modern languages block structure provide different localized scopes names 
scoping permits name multiple times independently 
solve problem external name clashes simply extend idea global name space 
block structure group level acm transactions programming languages systems vol 
july 
hierarchical modularity place unrelated libraries different scopes need worry name clashes 
related modules scope need access exported identifiers 
unrelated modules different scopes avoid potential name clashes 
related modules enclosing group unrelated modules different groups 
fully support hierarchical modularity external scoping follow program group structure 
managing global name space rule cm important aspect 
programming language versus configuration language really need language layer 
question asked considering modern languages module layer intended dealing large scale programming 
name clashes programming language names church calculus church barendregt just calculus uses conversion renaming bound variables name conflicts programming language environment provide mechanism dealing problem 
avoid name conflicts hope restrict way compromise modularity 
cm places name conflicts occur 
programming language conflicts guaranteed modular benign kind 
explain notion modular conflicts show deal 
second kind name clash occurs cm configuration language 
names language file names underlying operating system 
solving conflicts amounts moving files directories 
operations require knowledge contents files implementation incur recompilations 
ml module system versus cm cm merits area handling files managing recompilation clear 
configuration language albeit simple provides expressive power goes underlying ml language 
simple example see clear consider project involving programmers alice bob chet 
alice charge project knows bob chet bob chet unaware existence 
alice asks bob write module chet assigned module large bob chet independently subdivide tasks 
result bob delivers implementation structure separate auxiliary module implementing structure needed order implement happens chet provides implementation structure auxiliary module implements helper structure alice written main module uses bob structure chet structure faces problem putting source files order lets compile final program 
unfortunately acm transactions programming languages systems vol 
july 
matthias blume andrew appel bob helper module structure struct bob code structure struct 
alice main module structure struct 

chet helper module structure struct chet code structure struct 
fig 

ordering puzzle 
plain standard ml ordering compilation source files give correct result 
glue code alice needs able program written inspecting internal internal details case names helper modules bob chet solutions 
possible ordering ml source files desired effect bob chet helper modules get way cause name conflicts 
possible solution alice short modifying bob chet code insert glue modules locally rename structure conflict programmer code 
insert glue code alice needs know internals bob chet implementations wanted avoid 
analysis bob chet source code subsequent insertion glue modules renaming operations mechanized ml module system cm 
cm bob chet deliver group 
groups export precisely alice asked 
alice put final program having know internal structure colleagues solutions 
scenario described may simplistic 
danger name conflicts real programs may relatively low 
small danger unnecessary detail programmer keep mind 
cm group model really simple natural idea effective solving problem 
programming languages modules systems languages example name spaces ellis stroustrup packages ada dod java arnold gosling provide means spreading implementation named module compilation units 
case previous example see bob chet implemented respective helper modules leaving assigned main module bob implement helper module chet uses names acm transactions programming languages systems vol 
july 
hierarchical modularity mean cm fix badly designed module system just particular language 
see answer question negatively notice trick works ml alice told bob implement helper modules names start chet auxiliary global names start say ml module system fundamentally weaker 
importantly ml low tech approach solution ada require prior agreement programmers 
break prior agreement obtained situation encounter time module existed integrated new project 
words programming language module systems tend give support top program design fail case bottom development 
comes module systems approaches taken modern languages look similar form bundling definitions bundle appears new name module name 
definition names different modules clash 
module module 
consequently potential top level module names cause problems supposed solve removing names global name space 
sml structure names clash name space names interfere modula cardelli modules may conflict due unfortunate choice module names 
java package identifiers designed globally unique clients package name sources impossible relink client different version conceptual package purpose debugging profiling modifying recompiling client source 

cm software cm compilation manager standard ml new jersey sml nj short appel macqueen 
standard ml milner enjoys considerable popularity programming language research community impact real world programming cm concrete realization tightly integrated ml ideas design broadly applicable languages 
cm cm java built similar lines 
progress cm java bauer 
main building blocks tools linking manipulating symbols tables exist waiting put 
purpose cm comparable equal compilation configuration managers 
examples feldman system modelling language mesa cedar mitchell lampson schmidt swinehart vesta levin mcjones hanna levin chiu levin 
group descriptions play role cm system models play vesta makefiles play 
cm viewed modest extension standard ml 
tight coupling sml cm possible keep configuration language simple 
cm convenient automatic dependency analysis avoids need extensive hand crafted specifications 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel course features come cost 
cm generic compilation management tool spirit geared specifically deal ml 
cm extensible toolbox accomodate variety language processors fully integrated sophisticated management sml code 
cm sml tightly coupled level source files level object files 
source level cm implements automatic dependency analysis blume understand programming language deals 
object level cm handle sml nj formats files symbol tables executables 
points concept hierarchical modularity 
sml nj implementation cm easier automatic dependency analysis cm convenient 
cm incremental recompilation manager harper known sc harper 
developed cm study sc availability sc source code great help started 
irm sc take advantage sml nj visible compiler interface support cutoff recompilation 
cm improves sc group model implements hierarchical modularity offers full support libraries permits explicit export interfaces 
cm software integral part sml nj project blume 
advantage sml nj compiler development team sml nj users teaching appel 
cutoff recompilation aside name space management scoping grouping main service offered cm compilation manager mechanism establish consistency sources derived objects 
cm important derived object 
result compiling sml compilation units 
compilation units depend compilation units 
consists parts executable code static environment 
static environment plays role symbol table records type information definitions exported compilation unit 
sml depends sml compiler take account static environment exported sml bin able produce sml bin 
static environment exported bya sml bin changes sml recompiled 
approach taken safely approximates recompiling sml time sml gets recompiled 
overly pessimistic 
deep dependency graphs occur frequently sml programs lead unnecessary recompilations 
long static environment sml bin stays recompiling sml require subsequent recompilation sml 
cutoff recompilation adams strategy cm takes advantage observation 
efficiency comparing entire static environments cm compares relatively small fingerprints gunter 
fingerprinting method crc polynomials broder 
fingerprinting means exists possibility extremely interfaces erroneously match really match 
acm transactions programming languages systems vol 
july 
hierarchical modularity bit fingerprints probability mistake order smaller probability hardware failure 
may considered imperfection chosen live 
groups group consists list exports list members exports simply ml symbols member ml source file group 
group description file general format group export symbol member 
convenience programmer choose leave list export symbols empty 
case cm provide suitable default 
library special kind group constituent modules part main program main program directly indirectly refers 
library descriptions look group descriptions keyword group replaced library 
export list library left empty 
probably simplest example group empty export list subgroups members groups group main sml application code table sig interface table abstraction table sml implementation table abstraction group description file place cm analyze dependencies components system determine feasible ordering re compilation steps carry necessary 
hierarchies explained large programs broken multiple groups groups arranged hierarchy 
easier manage large systems related sources kept unrelated sources kept apart 
software reuse promoted consolidating generally useful components libraries 
multiple definitions name allowed group restriction exists definitions different groups 
cycles 
definitions sml form cycles module boundaries 
particular structure sml refer structure sml time structure refers structure rule checked enforced cm 
languages permit cycles modules believe reasonable allow cycles group investigated idea depth 
groups subgroups 
shown group mentioned description group called subgroup client imports sources client refer freely symbols defined exported subgroup 
client provide new definitions subgroup symbols masking subgroup definition 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel usr sml lib sources cm main sml local stuff sml pgl lib cm array sig sml array sml draw sml group structure signature sources cm shapes sml util exports sml structure main sml local stuff sml pgl sources cm usr sml lib lib cm library library structure draw structure shapes signature array structure array array sig sml array sml structure draw sml shapes sml util exports sml fig 

cm group description files 
shows sketch program group descriptions sample directory hierarchy hold associated files 
directory contains source files main sml local stuff sml description sources cm 
application exports symbols structure signature 
imported graphics library pgl described pgl sources cm 
furthermore imports sml nj library installed central location system administrator 
relative path names description files refer files directory contains description 
sources cm util sources cm group sml sml util sources cm group sml sml sources cm sml sml group sml sml util sources cm util sources cm group sml sml sml sml fig 

simple group hierarchy 
suppose sml sml sources group needs refer subgroup containing util sml util sml 
case create description files refer 
acm transactions programming languages systems vol 
july 
group structure table signature table structure main functor main sml fct sml sml table sources cm rcs parser grm main sml table sources cm 
hierarchical modularity sources cm fct sml structure table signature table structure rcs parser grm sml structure table signature table structure main functor fig 

group export list 
notice outer group may export necessarily definitions exported inner group 
usually cm automatically identify description files member list names 
cm treated names group description files 
relative file names resolved respect directory contains description file see 
auxiliary tools 
members sml sources group descriptions 
require special processing cm analyzer understand 
done tools example ml yacc source file parser grm fed ml yacc produces sml files parser grm sig parser grm sml 
cm applies tools cascades necessary 
example place grammar file parser grm corresponding rcs archive parser grm cm rcs tool run command check copy grm ml yacc tool take produce parser grm sig parser grm sml processed cm directly 
built toolbox cm extensible 
allows seamless addition new tools existing set predefined ones writing lines standard ml 
export lists 
group export list 
list consists ml symbols restricts filters set definitions exported 
export list group explicitly group export definitions precisely symbols listed regardless defined group subgroups 
programmer provide explicit export list cm supplies default 
export lists useful adding interface entire set source files 
interface governs outside clients see members group freely refer exports 
section discusses summary interfaces improve separation software components 
list symbols export list appears keyword group library keyword sml distinguish symbols different name spaces write structure struct sym structure symbol signature sig sym signature symbol functor fct sym functor symbol sym functor signature symbol 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel group description export list look 
libraries 
library special kind group 
differences libraries ordinary groups small mainly concern notion implicit export interfaces 
library empty export list 
programmer provide list exported symbols explicitly 
choice intend enforce discipline creating libraries 
second library exports importing group group uses implicit export interface 
idea incidental member library accidentally pollute export list client 
preprocessor 
time reads description file cm applies simple preprocessor allows conditional linking group sml version error version sml nj old 
elif defined os unix unix sml sml endif role dependency analysis cm provides language specifying semantic structure large programs consist separately compiled modules arranging modules hierarchy groups libraries 
hierarchy directly reveals dependencies groups dependencies individual source files group explicitly 
cm dependency analysis maintains illusion unordered source collections 
balancing act explicit dependencies groups implicit dependencies groups important 
impose certain restrictions source language able dependency analysis tractable blume 
restrictions indiscriminately entire program groups 
seen particularly true requirement disjointness exported names 
dependency analysis groups significantly simplifies task writing group descriptions 
cm easier attractive tool 
compilation configuration management tools provide automatic dependency analysis require programmer specify dependencies explicitly 
dependency information usually coded specification lan discussed cite possible ways restrict language 
cm chose export definitions name different sources group ml open construct prohibited top level 
acm transactions programming languages systems vol 
july 
hierarchical modularity guage imagine adding dependency analysis auxiliary program calculates generates specifications 
examples tools generate input source code dubois 
caches files stable groups cm uses variety caches speed analysis recompilation steps 
caches provide fast access information long cm session kept running 
ambient file system provides second level caches 
remember results expensive operations session 
important kind cache 
plays role binary object file enables cm avoid compiling sources 
cm stores compilation results keeps main memory 
reduces file system traffic ongoing edit compile debug sessions data readily available main memory need reloaded auxiliary storage 
dependency analysis expensive compilation cost analyzer parse sml source files 
little information source file necessary drive analysis process 
cm extracts important small part caches main memory file system 
files purpose called dependency files 
sizes tend corresponding source files 
implementation convenient create dependency file source file 
existence cached information means cm need consult original source file 
case result compiling source file depend source environment effect 
environment result compiling source predecessors dependency graph 
modifications may require source recompiled 
guarantee source need consulted ensure ancestors dependency graph stay fixed 
leads cm notion stable groups groups explicitly designated remain unaltered foreseeable 
examples stable groups central libraries installed maintained system administrator 
process stabilization creates special version dependency file called 
acts archive summarizing individual files 
file system activity required dealing stable groups fewer files opened read 
computers comparatively slow access file system improve performance considerably 
systems difference 

group model linking separately compiled modules associates imports module corresponding exports modules 
association mediated global name space linking takes place 
global name space sufficiently structured problems modularity arise 
exact nature problems depends structure name acm transactions programming languages systems vol 
july 
matthias blume andrew appel fig 

direct relation 
program fragments directly related explicitly refers definition exported 
fig 

indirect relation 
program fragments indirectly related third fragment explicitly imports 
space 
analyze examples ml 
cases strawman examples commonly programming languages authors aware suffer similar problems 
discussion introduce notion directly indirectly related modules 
enable state conditions naming related conflicts consider acceptable modularity 
conditions satisfied cm group model demonstrate formally develop simple calculus linking 
relationships modules name conflicts especially troublesome interfering parts program unaware existence 
obvious modules conceptually related know anyway 
interested avoiding naming conflicts precisely cases conceptual link 
course conceptual link precise language 
strengthen idea define mean unrelated modules 
definition 
groups said directly related explicitly imports 
indirectly related third group imports definitions 
case call unrelated see figures 
shown relationship modules transitive 
definitions said interfere cause name conflicts parts program unrelated 
name conflicts related modules acceptable see resolved simple local modifications affect part program occur 
call conflicts modular 
acm transactions programming languages systems vol 
july 
hierarchical modularity fig 

module relationship transitive 
examples modules unrelated related 
means potential name clash part system easily spread entire program 
definition 
name conflict associated restriction name usage called modular affects related parts program parts definition directly indirectly related 
definability availability cases ml kernighan ritchie language potential naming conflicts causes restrictions definability names 
avoided ml potential conflicts causing restrictions availability definitions 
definability 
definable program point adding definition cause name conflict definition program 
availability 
definition available program point name defined refers meaning assigned program certain identifiers potentially taken libraries parts program unrelated 
identifiers longer definable see 
ml program arbitrarily definitions name 
eliminates restrictions definability creates new restrictions availability 
parts larger program may able see early definition variable different intervening definition inhibiting access intended see 
examples discussion 
global name space lack structure definitions conceptually local small group sources promoted globally visible 
example implementations standard library export function purpose function called functions printf sprintf 
exported library 
application program supposed refer directly indicated presence leading underscore name 
magic names inelegant clumsy solution general problem 
give guarantees guarantees necessary programming environment trying promote safety security 
course static require printf sprintf acm transactions programming languages systems vol 
july 
matthias blume andrew appel foo foo motif toolkit intrinsics xt xlib graphics application portable graphics api pgl standard library libc gl win api win api identifiers 
fig 

restrictions definability inhibit modularity 
imagine portable graphics library pgl provides uniform api implemented top motif silicon graphics gl win 
programmer graphics application ideally pgl black box careful interfere various libraries pgl implemented 
entire classes identifiers avoided windows avoid conflicts gl scores symbols account win names creators new library designs choose purpose 
val val fun fig 

restrictions availability inhibit modularity 
sml program value meant calculated terms gravitational constant defined earlier 
third conceptually unrelated compilation unit redefines original definition unavailable 
case resulting program type check problem detected compile time 
cases program produce unintended result 
acm transactions programming languages systems vol 
july 
hierarchical modularity forth implemented compilation unit 
approach magic names scales 
modularity suffers programmer uses portable api graphics routines fictitious pgl worry implemented 
single global name space programmer careful symbols taken example windows libraries scheifler program linked 
excludes hundreds identifiers argument extends basis libraries may serve implementation platform pgl 
write completely portable code foresee development leads alternative implementations 
course impossible 
client pgl certain identifiers potentially taken libraries represent pgl 
cm implement pgl group export list mentions identifiers supposed accessible clients 
consequently application programmer tell pgl implemented application code truly independent libraries underlying pgl concrete realization 
cm group implementing equivalent standard library list export list 
client library accidentally voluntarily access corresponding routine 
matches intention local library implementation 
environments linking cardelli presents excellent discussion problems arise modules separate compilation 
notion framework describing reasoning consistent type safe linking 
type safe linking example provided sml nj visible compiler appel macqueen prerequisite analysis linking problem focus 
place cardelli notation uses functions express operations environments equations describing properties 
directly correspond actual operations real symbol tables reflect implementation cm 
environments 
separate compilation individual sources compiled respect environment represents definitions exported compilation units 
formally environment partial mapping long identifiers ide denotations long identifiers nonempty sequences simple identifiers 
express access members structure means dot notation programming languages 
notation stands long identifier id component ide simple identifier id hd head component long identifier hd ide ide hd id id domain denotations depends programming language 
sml correspond compilation unit static dynamic semantics 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel ml lib mod mod sml details abstraction mod compile link compile context environment imported symbols exported environment exported symbols source def exports imports fig 

compiling linking context 
source file compiled subsequently linked respect table imported definitions 
case sml compiling linking combined step context environment representing definitions imported compilation units 
language specific differences uniformly def operator model compiling linking source respect context 
hand external identifiers stand machine addresses 
case domain locations 
language dependent issues domain labels lab 
labels uniquely identify definition program 
distinguish different bindings identifier having consider meaning identifier semantics language 
lab ide domain dom ide environment set identifiers bound 
call hd dom head domain ide 
environment empty domain 
prefixes long identifiers bound environment bound environment dom dom environments combined operator hd 
operator associative commutative dom dom 
compiling linking 
def operator see abstraction compiler linker 
calculates incremental delta environment containing just bindings corresponding definitions explicit compilation unit def source acm transactions programming languages systems vol 
july 
def def def hierarchical modularity fig 

compilation environments sml 
sml context environment compiling source built incrementally layering exports sources compiled earlier top initial basis environment 
fig 

compilation environments conceptually source program compiled respect global environment constructed layering exports sources top initial basis environment 
implementations resolve circularity link time compile time compiler takes information header files uses approximation global environment 
programming languages differ calculate input environment def consider program consisting sources sn written sml 
export environment source si def def def def si initial basis environment 
situation depicted 
hand source file linked context global environment 
global environment constructed combining exports sources see def si acm transactions programming languages systems vol 
july 
matthias blume andrew appel fig 

linking subsets sources 
operator specific extension def calculates export environment subset sources 
returns incremental delta environment binds symbols explicitly defined subset sources 
consistent way def works single sources 
process linking corresponds solving system simultaneous equations 
identifiers bound environment def def def def dom dom resulting commutativity linking order independent straightforward 
source programmer provide header files containing information necessary construct incomplete version suitable compiling source full available sources compiled 
cumbersome sml allows mutual recursion compilation units 
linking subsets sources 
define lang source language dependent extension def sets sources 
global definition visible entire program 
operator passes context argument fact global environment individual calls def constituent sources 
resulting delta environments combined yielding delta environment entire subset see sn def def sn sml 
sml dependency analyzer turn set sources sequence blume source source acm transactions programming languages systems vol 
july 
sml def def def context hierarchical modularity incremental exports fig 

compiling ordered sets sml sources 
sml operator extends def sets sml sources 
individual exports incrementally layered top initially empty environment 
result delta environment containing bindings identifiers defined sn analogous behavior def step function incrementally builds resulting export environment intermediate values layered top initial context serve context needed compiling individual sources set step step si si step si def si step exports source combined eventually form exports entire sequence second layering operation source necessary form corresponding compilation context see 
explains occurrences definition step 
sml partial orders 
si occurs left sj sn intuitively means sj depends si 
able optimize recompilation may want capture idea sources depend 
total orders contain relations consider partial orders 
represent partial order dag sources predecessor function source source dependency analyzer calculate source source source sml revised accordingly 
compile source set respect express result def compiling source acm transactions programming languages systems vol 
july 
matthias blume andrew appel terms base environment exports predecessors def def sml def def general summations equations require total order imposed set sources 
problem resolved ensure export domains individual sources disjoint 
turns restriction necessary anyway dependency analysis intractable blume 
cm enforces rule group globally 
impose restriction globally cause restrictions definability 
important aspect group model require name imported source free exported source resolved definition words definitions take precedence definitions name come context environment 
formally expressed invariant ide dom def definability availability revisited definability 
formally definability name determined rule definable si iff dom definition source file affects definability availability entire program 
creates unfortunate implicit coupling compilation units modular means programmer aware identifier part entire program including program libraries linked 
availability 
treatment sml code requires defined ordering sources compiled 
identifier definable definition source si binds available sj definition sources si sj definition si available sj iff hd summation binary operation 
slight oversimplification declaration provide new definition currently constructor tag datatype 
acm transactions programming languages systems vol 
july 
hierarchical modularity sml situation definitions interfere definability names 
impact availability nonlocal programmer aware definitions exported earlier sources 
resulting implicit coupling inhibits modularity 
groups groups localize effects definitions 
group model constructed way names unrelated groups interfere 
source group refers definition exported group description name explicitly imports 
establishes direct relationship conflicts groups modular 
formally group grp triple 
set sources set imported groups set identifiers thinning group export interface 
grp source grp ide set groups grp set cumulative import set transitive closure import set 
graph direct dependencies acyclic 
group cumulative import set 
thinning reduction number definitions exported group understood filter operation applied environment 
filter retains bindings long names start simple identifier filtered environment head domain restricted ide hd example standard library list printf sprintf forth export list omitted 
initial basis standard library 
context environment compiling set sources group 
defined terms group imports grp export environment group grp acm transactions programming languages systems vol 
july 
matthias blume andrew appel group part context 
definition named redefined sources chosen consider unordered sets imported groups 
summation eq 
order independent domains imported environments disjoint 
require indirectly related groups export definitions identifier 
grp dom dom modular conflicts resolved formalism equivalent name conflict case environments domains disjoint participate operation 
group model operation applies export environments unrelated modules 
possible conflicts fact modular see definition 
practical important group model remaining modular conflicts resolved locally modifying group cause problem 
situations arise export environments sources group contain definitions identifier 
environments joined eq 
defines 
source provides definition identifier defined imported groups 
violation eq 
imported groups independently provide definitions identifier 
interferences kind removed locally changing offending sources 
second kind clash definition obtained imported groups definition sources legal defined meaning 
definition group sources override imported definitions see eqs 

intended situation resolved simple change group sources necessary rename point import identifier access particular binding imported group 
technique require changes exporting group resolve clashes third kind 
renaming expressed operation environments 
show rename long identifier ide ide ide ide acm transactions programming languages systems vol 
july 
hierarchical modularity renaming environments defined terms identifier renaming 
obtained renaming looking looking 
take arguments opposite order eq 

ide ide general formally describe renaming extend notion groups 
imported groups see domain eq 
described regular groups arbitrary number identifier pairs 
pairs specify renaming operations see eq 

imp grp imp ide ide grp source imp ide special case dealing language ml renaming built compilation manager explicitly obtained administrative groups 
cm currently implements original model renaming 
administrative group imports binding name exports different 
possible renaming ml expressed source language see 
definition form val structure establishes alias mean behavior ml exhibits limitations approach abstracting denotations labels 
deal case correctly introduced explicit equivalence relation labels 
unnecessary complicate calculus just able handle minor language specific point 
scheme examples languages administrative groups general way defining name alias 
variable definition languages creates new unique meaning 
means cm compilation manager implement renaming directly 
noted standard ml create aliases truly indistinguishable original 
example variable val status constructor constructor 
right issue cm deal type value definitions top level 
structures signatures functors tracked 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel structure structure 
structure 
structure structure 
fig 

administrative groups 
sml achieve effect renaming import administrative groups source language provides facilities defining identifier proper alias 
languages including scheme lack language feature 
languages necessary build renaming group model 
implicit export interfaces mentioned group descriptions may leave export list empty 
case cm provides default 
group exports defined sources imported subgroups 
formally group il set imported groups libraries 
export list provided cm calculated dom sml il 
back ml provide self contained explanation meaning program managed cm providing translation back standard ml 
translation provide dynamic part cm semantics link time execution state 
far dealt static part 
translation turn entire program consisting individual compilation units single piece ml source code 
meant practical way implementing cm merely means gaining insight cm semantics 
see example 
translation embed code contained individual compilation unit single skeleton glue code 
glue code play role global environment providing import bindings compilation unit remembering resulting export bindings 
final result translation concatenation source fragments fragments obtained original sources method 
start full dependency graph program 
graph directed acm transactions programming languages systems vol 
july 
structure struct val structure structure struct val structure struct val hierarchical modularity local structure struct val structure fresh local structure fresh structure structure fresh local structure struct val structure fresh local structure fresh structure fresh structure struct val structure fresh fig 

back ml 
left hand side schematically shows cm group structure simple program 
solid boxes standard ml source files dotted boxes symbolize grouping 
right hand side shows source equivalent single source standard ml program 
program explicit renaming operations cm normally handled automatically 
acyclic 
pick postorder traversal graph 
code fragments generated original sources concatenated order 
postorder guarantees source appears sources depends 
left nondeterminism description specified actual traversal 
leaves freedom order link time side effects chosen 
eliminate uncertainty undesirable point view prescribing ordering sibling nodes dependency graph requiring particular kind traversal 
actual implementation done far problem practice 
workaround possible programmer create artifical static dependencies serve enforce desired ordering 
way making aspect semantics predictable programmer supply total ordering sources group losing main features cm convenient 
practical advantage design dependency analysis nearly trivial 
code fragment obtained source embedding set pre 
map bindings exported fresh identifiers provide bindings free identifiers referring auxiliary identifiers bound predecessors environment formalism obtain correct set pre acm transactions programming languages systems vol 
july 
matthias blume andrew appel nitions 
change domain environments set program identifiers ide 
words compilation environment source maps source free identifiers identifiers ide ide 
code establishes free identifiers aliases corresponding names 
xn free identifiers definition equates xi xi 
precise syntax definition standard ml depends name space xi belongs 
particular namespace xi xi xi namespace structure functor signature 
ym names bound exported generate fresh names zm bind exports export environment def zj 
keeping xi yj local scopes sure name clashes zj chosen fresh 
fragment derived looks follows local namespace namespace xn xn xn namespace namespace ym zm ym 
group model employed sml nj compilation manager enables modular large scale programming 
traditionally difficult potential naming conflicts creates dependencies unrelated parts program 
cases examined problems manifested restrictions definability names availability definitions 
cm group model arranges sources hierarchical structure 
export environments combined necessary avoiding name clashes 
eliminate clashes controls way longer compromise modularity local modifications suffice resolve 
cm seen extending language ml augmenting hierarchical coarse grain modularity separately compiled source files basic building blocks 
extension modest 
group model intuitive cm configuration language surprisingly small simple automatic analysis frees programmer tedious task having keep track intermodule dependencies 
viable approaches tried apply languages ml 
question asked parts 
possible implement acm transactions programming languages systems vol 
july 
hierarchical modularity hierarchical modularity automatic dependency analysis programming languages 
second solution elegant cm 
certainly answer part demonstrated hierarchical modularity group model implemented terms simple operations environments layering filtering renaming 
great challenge implement operations systems example symbol tables unix object files 
efficient calculation dependencies standard ml proved unusually difficult 
languages fact easier 
answer second part question question solution elegant cm clear 
measure elegance speculate 
say ml sml nj particular especially pleasant rewarding create compilation manager 
part due fact ml particularly suited implementation compilers turns compilation management tools 
sml nj provides visible compiler interface easy implement type safe linking cutoff recompilation 
importantly ml target compilation management tool 
elegant language module system widely regarded sophisticated expressive existence 
cm add support hierarchical modularity 
possible keep configuration language simple 
aside positive aspects ml proved difficult deal 
cases concern automatic dependency analysis described separately blume 
simplicity cm model benefited built integrated expressive elegant programming language 
expect similar tools similar languages comparably elegant 
generalpurpose compilation managers define extensions language 
may versatile complicated different languages language specific details taken care differently 
fixed base language need significantly richer notation expressing dependencies 
adams solomon 
overview software development environment 
tech 
rep cs tr computer sciences department university wisconsin madison 

adams tichy 
cost selective recompilation environment processing 
acm january 
appel 
modern compiler implementation ml 
cambridge university press cambridge england 
appel macqueen 
standard ml new jersey 
rd international symp 
prog 
lang 
implementation logic programming wirsing ed 
springer verlag new york 
appel macqueen 
separate compilation standard ml 
proc 
sigplan symp 
prog 
language design implementation 
sigplan notices june 
acm transactions programming languages systems vol 
july 
matthias blume andrew appel arnold gosling 
java programming language 
addison wesley reading ma 
barendregt 
lambda calculus syntax semantics 
north holland amsterdam 
bauer appel 
mechanisms secure modular programming java 
tech 
rep tr department computer science princeton university 
july 
blume 
standard ml new jersey compilation manager 
manual accompanying sml nj software 
blume 
dependency analysis standard ml 
acm trans 
program 
lang 
syst 
july 
broder 
applications rabin fingerprinting method 
sequences ii methods communications security computer science santis vaccaro eds 
springer verlag 
brown ellis 
bridges tools extend vesta configuration management system 
tech 
rep digital equipment systems research center 

cardelli 
program fragments linking modularization 
proceedings th acm symposium principles programming languages 

cardelli donahue glassman jordan kalsow nelson 
modula report 
tech 
rep research report dec systems research center palo alto ca 
chiu 
levin 
vesta repository file system extension software development 
tech 
rep digital equipment systems research center 
june 
church 
calculi lambda conversion 
princeton university press princeton nj 

system manual 
dod 
military standard ada programming language 
tech 
rep mil std department defense naval publications forms center philadelphia pa dubois 
software portability nd edition nd ed 
reilly associates sebastopol ca 
ellis stroustrup 
annotated manual 
addison wesley reading ma 
feldman 
program maintaining computer programs 
unix programmer manual seventh edition volume 
bell laboratories 
ford back benson lepreau lin shivers 
flux oskit substrate kernel language research 
proceedings th acm symposium operating systems principles 
gunter 
abstracting dependencies software configuration items 
proceedings fourth annual acm sigsoft symposium foundations software engineering 
acm press 
hanna levin 
vesta language configuration management 
tech 
rep digital equipment systems research center 
june 
harper lee pfenning rollins 
compilation manager standard ml new jersey 
acm sigplan workshop ml applications 

harper lee pfenning rollins 
incremental recompilation standard ml new jersey 
tech 
rep cmu cs department computer science carnegie mellon university 
feb jacobson 
object oriented development industrial environment 
oopsla object oriented programming systems languages applications 
acm sigplan 
kernighan ritchie 
programming language second edition 
prentice hall englewood cliffs new jersey 
lampson schmidt 
organizing software distributed environment 
acm sigplan symposium programming language issues software systems 

acm transactions programming languages systems vol 
july 
hierarchical modularity lampson schmidt 
practical polymorphic applicative language 
tenth annual acm symposium principles programming languages 

levin mcjones 
vesta approach precise configuration large software systems 
tech 
rep digital equipment systems research center 
june 
milner tofte harper 
definition standard ml 
mit press cambridge ma 
milner tofte harper macqueen 
definition standard ml revised 
mit press cambridge ma 
mitchell maybury sweet 
mesa language manual 
tech 
rep csl xerox parc 
parnas 
criteria decomposing systems modules 
commun 
acm dec 
scheifler gettys newman 
window system library protocol 
digital press bedford ma 
swinehart zellweger hagmann 
structure cedar 
acm sigplan symposium language issues programming environments 
sigplan notices 
received july revised april accepted july acm transactions programming languages systems vol 
july 
