fault resilience main memory databases handling process halting failures data corruption philip lewis bohannon dissertation submitted graduate school new brunswick rutgers state university new jersey partial fulfillment requirements degree doctor philosophy graduate program computer science written direction badrinath approved new brunswick new jersey january fl philip lewis bohannon rights reserved dissertation fault resilience main memory databases handling process halting failures data corruption philip lewis bohannon dissertation director badrinath tightly coupled database architecture application code shares address space database management system 
tightly coupled architectures allow capabilities database extended allow applications access data stored large random access memories directly substantial performance advantage 
tightly coupled system vulnerable faults application code 
dissertation addresses forms process failure tightly coupled database architectures 
hardware mutual exclusion mechanisms developed tolerate process halting failures retain performance advantage associated hardware locks 
mechanisms developed simple spin lock queueing spin lock designed scale large number processors shared memory system 
second prevention detection recovery algorithms developed problem data corruption due wild writes application programs 
recovery algorithms trace errors limited form read logging extended aid recovery problems due incorrect input faulty application logic traditional database management systems 
ii gratefully acknowledge guidance support rajeev rastogi avi silberschatz training researcher production thesis 
am grateful badrinath tomasz imielinski belief help develop abilities 
iftode minsky ken ross agreeing serve committee 
sudarshan dan seshadri served invaluable mentors time research performed 
additionally intellectually examples alex borgida barbara ryder ann haym hirsh rutgers 
received encouragement support numerous friends colleagues rutgers bell labs gratefully acknowledge 
lloyd tucker intellectual guidance past years helpful comments text 
spouse underwood child austin love support 
iii dedication parents ken julia 
iv table contents ii iii dedication iv list figures xi 

motivation closely coupled database architectures 

spin locks process halting failures 

spin locks database management systems 

simple spin locks 

queuing spin locks 

corruption dbms data 

related 
closely coupled dbms architectures 

memory mapped persistent stores 

extendible database management systems 

concurrency control 

fault tolerant locking techniques 

wait free data structures 

node failure shared memory systems 

data corruption 

failure studies 

ad hoc techniques 

robust data structures 

memory protection 

type safety 

sandboxing 

logical corruption 

background dal main memory storage manager 
architecture 

layers abstraction 

pointers offsets 

storage allocation 

transaction management dal 

multi level recovery 

system overview 

transactions operations 

logging model 
undo redo logging 
pre commit 
log flush 

ping pong checkpointing 

abort processing 

recovery 
single database file recovery 

fault tolerance 

protection bad writes 
memory protection 
codewords 

process failure 

collections indices 
vi 
heap file 

extendible hash 

tree indexes 

dali relational manager 



recoverable spin locks 
background 

hardware support atomicity 
atomic instructions 
cache lines 

common atomic instructions 

weak consistency 

spin locks contention scalability 

queueing spin locks 

system model 

problem statement 

overview approach 

acquisition release protocol 

system data structures 

spin lock acquisition 

spin lock release 

example normal operation 

cleanup process 

example cleanup procedure 

proof correctness 

overview 

time ordering proof 

definitions 
vii 
process states 

proofs 

recovering scalable spin locks 
problem statement 

overview 

recoverable mcs lock protocol 

recoverable mcs lock acquisition 

recoverable mcs lock release 

cleaning 

proof correctness 

assumptions 
meaning time relationships 

definitions 

states process 

proof correctness 

compare swap 

recoverable spin locks extensions implementation performance 
extensions 

multiple concurrent locks 

driver code interaction 

example routines 

correctness issues 

implementation dal main memory storage manager 

recoverable spin lock performance 

data corruption 
overview 
viii corruption control structures 

codewords detect corruption 

preventing direct physical corruption 

hardware protection 

read 
read aries 

detecting direct physical corruption 

data codeword 

corruption detection deferred maintenance 
actions normal processing 
auditing 

recovering data corruption 
overview 

read logging 
generating checkpoints free corruption 

correctness real world correspondence 

corruption spread 

interaction external systems 

models recovery 

recovery algorithms 

cache recovery model 

prior state recovery model 

redo transaction recovery model 
recovery 
user notification 
extension logical corruption 

delete transaction model 
recovery algorithm 
ix redo phase 
undo phase 
checkpoint 
discussion 
extension codewords read log records 
extension recovering logical corruption 

logical corruption 

backward analysis 

optimizing recovery redo transaction model 

performance corruption protection 
performance mprotect 

implementing read logging 

workload 

protection domain size 

results 
directions vita list figures 
architecture dal system 

layers abstraction dal 

segments chunks 

overview recovery structures 

extendible hashing dal 

definition atomic instructions 

sparc memory consistency model 

simple spin lock owner 

system data structures 

spin lock acquisition code 

spin lock release code 

normal operation spin lock acquisition release code 

owns procedure 

example run owns 

states transitions proof 

mcs lock protocol 

system data structures 

recoverable mcs lock acquisition 

recoverable mcs lock release 

cleanup code 

release compare swap 

simple lock driver code 

lock driver code 

acquire release second 
xi chapter database management systems dbms distinguished software systems essential concerns 
concern organization storage retrieval large amounts data 
second concern protection data loss corruption 
transaction arguably successful single tool history computing ensuring availability integrity application data 
transaction represents contract database management system dbms application programmer greatly simplifying task producing application programs destroy integrity database 
contract summarized known acid properties described description adapted atomicity transaction changes state atomic happen happen 
consistency transaction correct transformation state 
actions taken group violate integrity constraints associated state 
requires transaction correct program 
isolation transactions execute concurrently appears transaction executed 
durability transaction completes successfully commits changes state database introduced transaction survive failures loss volatile memory 
contributions thesis goal protecting application data stored dbms loss corruption due software errors 
contributions fall general category software fault tolerance see example 
techniques dbms resilient certain common classes application failures minimal performance cost 
failures include halting processes unintended application writes corrupt data database buffers errors user input incorrectly specified coded transactions 
terms acid properties increased protection amounts relaxing application programmer obligations consistency supply transactions correct programs 
motivation backdrop class systems application code closely coupled database 
define systems closely coupled share hardware protection domains communicating domains 
example closely coupled application may share address space database server dbms may consist libraries directly linked application executable 
performance motivation closely coupled architectures 
addition achieving goals improving fault resilience closely coupled applications contributions widely applicable 
techniques applicable logging dbms applicable wide variety shared memory applications database system example 
errors faults techniques provide resilience broadly characterized halting failures data corruption 
halting failure process thread terminated unexpectedly important activity due internal program error action taken operating system failure processor 
focus halting failures occur process thread interacts low level concurrency control mechanism known spin lock 
variety spin lock mechanisms proposed see novel schemes address halting failures mechanisms 
result production recoverable spin lock mechanisms locking mechanism considered recoverable arbitrary halting failures processes acquire attempt acquire lock cause bounded periods unavailability lock mechanism 
implement recoverable versions locking mechanisms study performance relative original 
prove correctness properties resilience process halting failures 
second class failures address class failures resulting data corruption 
corruption defined effects database data stemming unintended updates characterized physical logical 
physical corruption example unintended update wild write due programming error affects database buffers structures logical corruption consider updates arising incorrectly coded transactions erroneous input 
novel schemes addressing data corruption compare level protection provided schemes proposed schemes implement schemes study impact corruption protection performance normal processing main memory dbms 
motivation closely coupled database architectures describe trends database research commercial development close coupling database application pressing concern 
note techniques applicable high performance database domain motivated development 
recoverable spin locks interest highly available shared memory system techniques tracking recovering corruption applicable database system persistently logs update activity 
identify trends led application code closely coupled database 
advent database systems memory mapped architecture 
multi gigabyte main memories easily affordable expect databases fully cached decreasing impact disk latency performance consequently increasing relative impact interprocess communication 
memory mapped database systems including object oriented systems developed avoid inter process communication minimize cost individual accesses particularly support needs computer aided design cad systems 
memory mapped databases designed support high performance fault tolerant applications example dali main memory storage manager 
research object oriented database systems exodus ode success commercial products served demonstrate memory mapped architecture direct application access data critical significant class applications 
memory resident memory mapped storage architectures recoverable virtual memory cricket texas store demonstrated significant performance gains user application code direct access database storage structures :10.1.1.106.4431
systems risk data corruption due application errors significantly higher standard database management systems process boundaries separate application programs database data 
second trend resulting application code direct access internal system structures development extensible database systems postgres 
commercial relational systems allow execution application logic server stored procedures extensible systems allow application specific data types added dbms 
types implemented user supplied support code linked directly dbms code 
user case considered expert typical application developer user supplied code expected match reliability system code 
commercial success illustra postgres current integration illustra technology dbms informix lend great deal support position close coupling application code dbms inescapable trend evolution database management systems 
error trends lead greater concern software errors general 
study field errors tandem computers reflects industry wide trend improvement hardware reliability 
increase reliability matched stored procedures represent close coupling usually specified restricted language 
software 
result percentage errors attributed software rose reliability systems rose 
new techniques addressing software faults production dbms system code seemingly required continue increase reliability dbms closely coupled application code 
spin locks process halting failures noted speed primary motivating factor sharing address space application process dbms 
multiple processors system supports shared memory provide form synchronization construct allow processes access shared data mutually exclusive manner 
traditional mechanism achieving goal semaphores see 
typical semaphore implementation provided unix systems semaphore operations wait signal implemented calls operating system kernel 
technique allows os de schedule processes waiting resource system calls may extraordinarily expensive equivalent thousands instructions 
avoid excessive cost modern hardware platforms offer mechanisms highspeed synchronization 
overview mechanisms chapter 
mechanisms characterized acquisition protocol features repeated attempts acquire semaphore tight loop 
activity known spinning leads term thesis concurrency control mechanisms spin locks 
particular consider spin locks implement binary semaphore single process allowed hold semaphore time 
spin locking implementations binary semaphores extensively studied parallel computing operating system communities 
point reader operating systems texts survey surveys performance analysis anderson graunke 
spin locks typically orders magnitude faster operating system semaphores generally acknowledged important factor success multi processor shared memory systems 
concretely problems solving give example simplest spin locks implemented 
implementation atomic instruction test set reads memory location value location free replaces locked returns result program 
lock consists single memory location 
process trying acquire lock uses test set try acquire lock process replace status free locked 
release lock value stored memory location set back free 
cost acquisition release low instructions compared kernel call operating system semaphore 
thesis consider resilience spin locks described sophisticated variations arbitrary process processor thread death 
process dies holding spin lock possible determine fact 
possible return spin lock active 
process dies process acquiring releasing lock 
example described lock consider process dies instruction lock acquisition 
case fact owns lock presumably register processor flag information probably lost death process certainly lost processor fails 
recovery process failure particularly important systems high availability requirements apparent alternative shut processing restore shared resources consistent state reinitialize semaphores restart system 
spin locks database management systems database management system excellent example system fast semaphore implementations important 
dbms typically large number semaphores referred latches database literature contention low repeatedly acquired released course transaction 
systems spin locks operating system semaphores important efficiency 
cases application code directly linked database management code opportunity process fail holding latches increases significantly 
shared memory programs dbms intended long running fault resilient application 
dbms prime example case recovery spin locks process failure significant concern 
simple spin locks simple test set spin lock discussed example recovery process failure reduces completely ability determine ownership lock 
consider process timed waiting spin lock process holds identified querying operating system determined process suffered halting failure progressing normally 
case waiting process may simply unlucky succession processes acquired released lock 
identity process holds determined busy lock easily distinguished lock held failed processes 
simple spin locks determining ownership critical step recovery failure failed process 
knowledge dead process holds lock information application specific information carry appropriate recovery actions resources guarded spin lock 
actions carried bit state associated locking mechanism spin lock may simply released allowing processes application continue normal operation 
unfortunately difficult determine ownership spin locks commonly atomic test set atomic register memory swap instructions 
see section providing correct efficient mechanism determine ownership simple test set spin locks issues addressed chapter 
approach problem global picture local just examining failed process examine processes may wanted acquire spin lock 
global picture gives information determine lock ownership 
slightly sophisticated spin lock algorithms combine simple spin lock particular back policy 
back policy determines behavior process attempting acquire lock held process 
solution recoverability simple spin lock orthogonal back policy technique directly applicable variants 
queuing spin locks significant scalability issue simple spin locks led development queuing spin locks 
idea process desiring lock adds queue processes waiting lock 
process spins private location associated position queue single global location bus traffic generated lock acquisition release dramatically reduced see section details 
obviously performance reasons queue managed efficiently 
examine issue providing algorithms property recoverability arbitrary process halting failures 
forms queuing lock proposed literature concentrate proposed scheme mcs lock 
unfortunately problem dealing process halting failures queuing lock reduce simply determining ownership simple spin locks due presence queue data structure 
recoverable implementation sure queue restored sane state failed processes prevent live processes acquiring lock 
short failed processes removed queue 
corruption dbms data addition abnormal termination processes software errors important concern database systems closely coupled application code 
large class errors memory corruption 
corruption caused variety problems including loops extend array bounds writes pointers corruption program stack 
errors particularly tend propagate slowly detectable long offending instructions executed 
fact study field errors mvs ims db sullivan addressing errors accounted field errors 
compared types errors identified study higher percentage addressing errors noted having significant customer impact 
part thesis address issue detecting recovering corruption data database system 
define corruption need distinguish valid updates erroneous updates cause corruption 
physical corruption distinguish valid updates invalid ones manner similar 
idea valid updates exactly prescribed interface updates treated errors 
invalid update said cause direct physical corruption bytes updated 
direct logical corruption caused write database uses prescribed interface faulty application logic faulty input 
data directly corrupted unintended updates 
examples unintended updates pointers corrupted program stack case physical corruption protection form corruption directly motivated memory mapped database architectures 
extend techniques aid dealing logical corruption thorny issue dbms regardless architecture 
data directly corrupted physically logically may read process issues writes value read 
data written manner indirectly corrupted process involved said carried corruption 
process may database maintenance process focus transaction carried corruption carrying process executing transaction 
integrity constraints widely studied prevent certain cases logical corruption rules data violated see example 
address cases integrity constraints input validation techniques fail due programming error invalid input unintended updates database 
integrity constraints may effective check expensive run erroneous value fact acceptable values data item money transferred wrong account 
data record intended model reality underlying reality may change invalidating data 
example items may taken inventory updating database 
consider cases inherently impossible prevent assume problem detected usually database user notices incorrect output 
approach preventing physical corruption programming language techniques type safe languages sandboxing 
type safe language java increasing database community type safe languages proven high performance situations sandboxing may perform poorly certain architectures see related section details 
communication process domain boundaries database server process provides protection communication orders magnitude slower access process space highly tuned implementations 
due cost increasing number systems give application code direct access system buffers including extensible systems object databases memory mapped memory architectures 
sullivan stonebraker investigate hardware memory protection improve software fault tolerance dbms environment guarding data buffer cache 
example calls added postgres page containing tuple updated 
performance experiments protection relatively inexpensive 
overhead amounted processing time cpu bound workload ignored disk latency processing time disk latency included 
number factors motivated consider possible techniques protecting data dbms 
memory protection primitives accessed system calls may slow 
informal test systems available confirmed performance mprotect vary widely comparable workstations see section 
second threaded application threads access pages unprotected threads decreasing effectiveness scheme 
main memory dbms information allocation information control information need stored page user data 
case dal system experiments implemented significantly increase number pages protected unprotected single operation 
new techniques prevention detection corruption 
read scheme associates word codeword region data prevents transaction reading corrupted data verifying codeword matches data time read 
transaction read corrupted data transaction carried physical corruption prevented 
data codeword scheme expensive variant read allows detection direct physical corruption asynchronously auditing codewords 
deferred maintenance data codeword scheme avoids possible contention codeword table update processing 
detecting indirect logical physical corruption approach logging information reads read logging employed allowing database log function similarly audit trail updates data 
interestingly negative impact read logging scheme limited actual values read logged 
identity item read optionally checksum value logged 
corruption detected prevented techniques corruption recovery employed restore database uncorrupted state 
high level approach recovering indirect logical corruption described davies 
problems exist trying implement approach modern transaction processing system major contribution thesis development concrete models algorithms certain cases automate task recovery transaction carried indirect corruption 
introduce models recovery 
model redo transaction model uses logical descriptions transactions repair database state 
second model delete transaction model focuses removing effects corruption database image 
attempt aware formalize problem recovering corruption databases 
algorithms applied recovery logical physical corruption 
addition tracing techniques aid determining scope logical corruption 
general recovery logical corruption tremendously difficult problem potential pitfalls 
consider techniques important building blocks providing automatic support recovery database management systems 
ascertain performance algorithms detecting recovering physical corruption study impact schemes tpc style workload implemented dal main memory storage manager 
goal evaluate relative impact normal processing schemes easily ported variety architectures operating systems 
addition schemes study hardware protection technique similar 
detection direct corruption overheads imposed cause throughput update transactions decreased 
prevention transaction carried corruption read costs space overhead increasing performance improves 
detection transaction carried corruption read logging costs 
hardware protection decreases throughput dal platform relatively fast protection primitives 
remainder thesis organized follows 
chapter discusses related 
background system model recovery algorithms dal mainmemory storage manager discussed chapter 
chapter presents recoverable variant simple spin locks 
recoverable queuing lock chapter extensions spin lock algorithms performance experiments chapter 
chapter presents prevention detection schemes data corruption 
recovery corruption chapter 
performance study data corruption chapter 
directions chapter 
chapter related examining greater detail systems relying data close integration application data dbms code motivate increased concern fault resilience 
touch operating systems processes may share address spaces subject similar problems 
term architectures closely coupled architectures 
related high speed concurrency control locking protocols previous fault tolerance area 
describe database general faulttolerance literature related protecting data corruption due various forms process failure 
closely coupled dbms architectures section discuss research commercial efforts led database programming environments user application code tightly coupled database 
coupling may simply mean portion database mapped user address space may imply application code tightly coupled database code 
usually implies tighter integration code typically leads tighter integration data avoid excessive interprocess communication 
memory mapped persistent stores discuss research commercial systems fall category memory mapped persistent data store 
efforts generally motivated desire provide degree database style convenience protection transactional properties example non standard applications benefit standard relational systems 
computer aided design cad systems commonly mentioned target audience systems 
primary goal drastically lower access cost database interaction 
database objects contain direct pointers objects opposed value joins architecture designed navigation data structures pointers takes place close native pointer dereference speeds 
addition improving performance systems typically seek minimize distinction database data normal programming language data application programming interface provide applications model single level store 
cad applications persistent stores include high performance realtime systems example telephone switching billing web content delivery applications maintain meta data applications example meta data coda file system implementation persistent programming languages 
systems built principles include cricket shekita white dewitt texas singhal kakkad wilson recoverable virtual memory rvm kumar steere kistler commercial system objectstore :10.1.1.106.4431
recoverable virtual memory somewhat different goals features discuss 
cricket designed validate single level store class applications modern virtual memory hardware 
texas designed validate hardware pointer swizzling 
pointer swizzling refers practice replacing object identifiers virtual memory addresses mapping data user address space 
practice tends require significant overhead access object page objects provides speed native hardware pointer dereferencing subsequent accesses 
essential tools providing memory mapped access systems cricket texas objectstore page protection trapping page faults 
modern unix systems allow pages process virtual address space protected reads reads writes subsequent accesses trigger signal process 
handling trapping signal database system partially linked user process take actions necessary provide user access page 
signal handler returns processing continues original access succeeded 
sequence events referred page fault mimics behavior virtual memory operating system page fault time 
cricket built mach database routines supplied handle page faults mach concept external pager 
concerned integrity mapped data performance discuss variations page mapping strategy pointer swizzling implementation systems 
systems endeavor allow compiled code operate persistent transient instances type implementing persistence orthogonal type 
approach advantage minimal disturbance user programming interface relieves user explicit attention database programming structures 
systems emphasizing capability important implementation techniques require modification compiler 
order provide transactional properties memory mapped data compiler support additional semantics loaded page fault operation supporting concurrency control recovery 
concurrency control additional semantics consist acquiring page lock page read write mode type access 
recovery write lock granted image page preserved 
addition serving undo information case transaction abort page image available cut amount redo logging done typically technique page 
page consists comparing new contents page original commit time 
addition generating redo log records changed regions actions index maintenance taken modified data 
note systems depend critically assumption page level locking acceptable application developer 
case somewhat suspect assumption page level locking rejected modern relational databases 
page level locking valid assumption cad style applications primary goal extending persistence non persistent applications concurrency seen nice crucial feature 
recoverable virtual memory rvm grew system implementation coda file system carnegie mellon 
application needs crash recovery primarily interested aspects transaction processing feature rich system significant drain cpu resources tests showing half cpu usage attributed 
reliance mach seen significant barrier portability overhead feature set terms servers code size justifiable 
rvm designed preserve benefits transaction processing removing constraints possible providing lighter weight transaction processing facilities 
achieved memory mapping database process space opposed paging access simplifying assumptions database smaller virtual memory allowing hardware pointers swizzling steal buffer management policy 
contrast systems logging accomplished page 
application responsible indicating data updated set range call preserved undo image marked region saved commit time 
authors noted difficult detect bugs rvm due omission set range call resulting modified data un modify crash system restart 
updates outside dbms sanctioned methods key error types addressed thesis providing simpler alternative suggestion language support solve problem 
authors pointer swizzling research systems cricket explicitly acknowledge tradeoff performance protection inherent memory mapped architecture 
systems rvm implement logging transactional durability form page unable distinguish updates intended application erroneous updates garbage pointers 
authors cricket systems take position user data mapped user address space exposed corruption system meta data free space lists lock tables 
locks general implemented remote procedure call rpc logging lock release done rpc commit time latching necessary user process 
dependent large granularity essentially page locking avoid overhead lock related rpcs 
mention technique protect user data unintentional writes 
concurrency control handled rpc apparent need recoverable concurrency control mechanisms 
believe continued development page mapping approach require increased shared memory latching need fine grained sharing early release latches index pages 
rvm system information logs presumably stored application space entire system handled user library code 
concurrency control implemented user space concurrency issues left application control 
memory paged access user data presumably address space duration application exposing data damage bad writes 
extendible database management systems thread research leading tight integration application dbms code area extensible database systems 
systems designed goals mind simplifying task creating new database management systems enabling creation database management systems tailored specific applications 
early example genesis dbms toolkit batory barnett smith wise 
authors sought understand interconnection low level dbms features concurrency control storage allocation collection management components treated modular way interchanged affecting correctness 
successor predator project explored data structure compilers create tailored data management solutions specific applications 
major effort relational database extensibility postgres project berkeley evolved commercial product illustra integrated informix dbms form informix universal server 
represents significant acceptance dbms extensibility commercial database application development community led competing features announced major relational dbms vendors 
essential goal allow new data types added dbms give privileges standard types including indexing user code written programming language accepted dbms run protection domain 
functions associated operations needed dbms implement type comparison output new type specific functionality 
user may develop new access structures index new types 
accepting user code dbms protection boundary dbms subject corruption due errors code 
motivation previous protecting databases corruption sullivan stonebraker 
concurrency control mentioned strong performance related reasons processes share address spaces speed hardware synchronization spin locks reasons 
locks may inaccessible process dies time 
describe related locks efforts synchronization vulnerable process failure 
discuss older software techniques appears mutual exclusion mechanism may easily recovered case process failure 
complicating factor implementing schemes lack sequential consistency guarantees modern multi processors 
describe making synchronization objects data structures synchronize tolerant process failures 
review herlihy wait free data structures similar techniques turek ensure progress processes contending lock 
fault tolerant locking techniques older software approaches mutual exclusion rely atomic instructions may easily recovered case process halting failure little modification 
example standard starvation free software mutual exclusion algorithm eisenberg mcguire uses process state information stored array 
scheme state process respect spin lock determined immediately inspecting appropriate array element 
interference processes removed resetting state 
simply algorithms 
primary reason resources 
algorithms require time proportional number processes acquire spin lock solutions synchronization hardware typically require small constant number accesses 
furthermore systems require space proportional number processes times number spin locks opposed sum synchronization hardware approaches 
algorithms designed assuming sequentially consistent memory may need redesigned weakly consistent memory system 
scheme bershad implementing mutual exclusion notifying operating system particular section code restarted interrupted context switch 
scheme solve problem ownership tracking simple locks requires modification os extend multi processors 
sun solaris operating system uses spin lock mutual exclusion kernel 
track process ownership order avoid priority inversion priority lock current owner temporarily raised highest waiting threads priorities allowing holding process progress release spin lock higher priority thread proceed 
synchronization primitives sparc architecture register memory swap test set face problem similar addressed thesis requires determining ownership lock owner priority may raised 
solution reserve hardware register indicate process attempting acquire spin lock 
interrupt handlers checking register second register designated hold result test set instruction 
register indicates lock second register indicates atomic instruction lock successful owner filled continuing interrupt 
takes register completely quite fast requires modification kernel presumably modification compiler ensure certain registers code generation 
techniques processor fails contents registers lost 
yen describe locking mechanism explicitly designed recoverable case process failure tolerates failure recovering process 
algorithm processes access locks special pointers 
pointers bit associated 
locks acquired released atomically swapping bit lock bit 
mechanism ownership lock determined time examining processes lock pointers points lock bit set 
algorithm depends atomic memory memory swap acquire lock note acquisition process specific data structure step 
instruction knowledge available currently popular processor architectures discussion fully describe second register presumably required 
exactly inability note ownership atomically lock acquisition simple spin lock recovery problem interesting 
wait free data structures large body herlihy exists non blocking wait free data structures :10.1.1.38.1642
non blocking data structure guaranteed process progress finite number steps 
wait free data structure stronger property processes progress finite number steps 
techniques motivated concerns process failure slow similar motivation techniques thesis 
herlihy writes conventional techniques implementing concurrent objects typically rely critical sections ensuring process time operate object :10.1.1.38.1642
critical sections poorly suited asynchronous systems process halted delayed critical section faster processes unable progress 
possible sources unexpected delay include page faults exhausting scheduling quantum preemption halting failures 
approaches proposed herlihy achieve independence critical sections consist basic techniques :10.1.1.38.1642
technique sufficiently powerful atomic instruction typically compare swap updates shared data structures 
data structures taken consistent state atomically instruction 
objects fit machine word swap directly 
larger objects pointer object 
process wants update object copies entire object updates specific portions uses compare swap swing pointer new version points old version 
process restart new value object 
process forced try process progress ensuring non blocking property 
second technique investigated herlihy allows development wait free data structures 
algorithms processes carefully install specifications intend shared data structures processes capable executing take turns completing part processes 
turek shasha follow technique providing general mechanism replacing critical section code executed wait free data structure unfinished interested parties represented progressing processes help complete slow halted processes 
wait free techniques described require rewriting concurrent data structures different paradigm 
done process mechanical far straightforward task complicated system number critical sections 
significantly conservative goals provide measure benefits non blocking wait free data structures systems critical sections standard mutual exclusion mechanisms 
includes recovery halting failure process extended failure process progress known halted 
critical section abstraction remains intact avoiding redesign algorithms depend 
goal techniques machines powerful hardware abstractions compare swap 
relatively common instruction roughly equivalent load locked store conditional instructions locking cache lines far universal available sun sparc architecture hp pa risc 
fact prevents algorithms designed compare swap easily portable large group popular systems 
issue theoretical results show atomic instructions weaker compare swap test set swap fetch add incapable solving class problems represented consensus problem presence halting failures :10.1.1.38.1642
result conflict goals circumvent assumption distinguished system process fail 
node failure shared memory systems ramamritham consider problem recovery failed cpu cache 
pair shared memory sm cache coherent system 
similar failure processor shared memory system similar halting failure set processes situation address 
ability log information global memory updates migrated cache processor 
similar logging updates shipping page shared disk system 
depends particular implementation mutual exclusion ability lock cache line program control 
interested continued processing process processor failure focuses ensuring transactional consistency cache memory lost focus recovery process processor failure mutual exclusion constructs held 
chapin rosenblum devine lahiri gupta describe hive effort provide fault containment smp system 
concern systems scale relatively large number processors mean time failure may unacceptably short 
system said contain faults probability application failure proportional amount resources uses opposed size system 
hive approaches fault containment partitioning processors system cells related processors run instance operating system 
memory architecture non uniform hardware support track memory associated cells cell read write 
cell fails pages write assumed failed applications pages fault 
primary concerns hive share resources efficiently system minimizing exposure applications running cell failure cell 
thesis hive system concerned processor halting failures wild writes application kernel code 
techniques apparently complementary 
example hive simply throws away page holds hardware spin locks may cause excessive halting applications contending locks 
may better associate lock set pages invalidate shared pages process failed cell held lock benefiting recoverable spin locks 
similarly dbms running hive system possible codeword techniques thesis determine page buffer cache affected failed cell page write set cell limiting affect failure furthering goal fault containment 
data corruption corruption data directly associated erroneous code wild writes identified sullivan significant source errors production database systems 
errors noted particularly difficult trace may expressed failure system corrupted data accessed 
section discuss related detection correction errors 
directly comparable new methods detecting corruption database management systems parity words 
techniques especially fall heading robust data structures relate issue recoverable mutual exclusion represent general techniques data structures guarded recoverable spin lock recovered consistent state halting failures certain failures 
note commercial databases may implemented techniques detecting corruption information publicly available 
page direct corruption detection scheme inspired codeword scheme protecting telephone switch data far aware codeword detection recovery techniques read logging techniques published description research commercial database system 
reviewing studies failures production systems discuss ad hoc techniques protecting dbms structures follow reviewing formal robust data structures discuss stonebraker sullivan memory protection 
review techniques fault tolerance literature address similar problems 
finish presenting related recovery logical corruption database systems 
failure studies results study field errors tandem computers reviewed showed percentage errors attributable software rose 
thesis sullivan reviews field errors recorded ibm internal databases mvs operating system database products ims db 
study categorized errors control errors addressing errors data errors 
control errors affect variables represent current state program 
data errors cause result computation wrong cause system mistaken state 
addressing errors corrupt values values routine 
studies determined field errors reported control errors errors addressing errors data errors 
frequency error reported tracked fields recorded data judge severity error 
addressing errors recorded uniform manner mvs support database errors studied closely context 
mvs addressing errors errors high impact user 
amount written tends small usually physically close area intended updated 
studies categorized field conditions triggered errors symptoms brought error attention user information significant bearing 
ng chen compare reliability database software different interfaces persistent cache model direct read write memory protection direct read write memory protection postgres database system 
inject variety faults hardware software check persistent data corrupted 
persistent memory cache lead significant increase risk corrupting persistent data 
reliable memory interesting avenue explore performance enhancement main memory database systems main directly address risk data corruption 
interesting points come extensive fault injection study 
crashes due injected faults resulted persistent data corrupted 
system test consisted postgres authors comment large number assertions code interrupt software propagation example care taken system code may taken application code 
note paging clean buffer pages tends limit effect random corruption periodically throwing away pages allowing clean copy read disk 
buffers grow larger cleaning effect reduced limit corrupted page stay indefinitely 
mainmemory database example limit case cost ram ensures commercial databases approach limit case caching memory longer periods time 
comparing studies illustrates difficult predict errors scientifically 
particular addressing errors errors contributed errors ng chen 
ng chen weighted results sullivan numbers category weigh results 
certainly results difference fault injection scenario field errors 
certain class error causes system fail reliably quickly certainly caught testing kind error show statistically significant fault injection study performed ng chen 
ad hoc techniques presents number specific techniques detecting corruption dbms data structures 
certainly useful techniques somewhat ad hoc sense specifically designed individual dbms storage structures 
example recommended words reserved page image buffer manager defense wall detect writes erroneously extend page boundary 
techniques suggested adding redundancy data structures similar proposals discussed ffl marking free data special bit patterns 
ffl storing redundant information lists verify length information 
ffl checks pointer consistency specific tree implementation 
ffl adding sequence numbers chained hash table overflow buckets detect pointer errors introduce infinite loops 
contrast techniques general detect wide variety data corruption errors 
techniques detect errors resulting incorrectly coded database routines sense approaches complementary 
robust data structures taylor morgan black provides theoretical structure design data structures recover certain failures 
introduced notions detectability notion change single word arbitrary modification structural encoding data structure 
erroneous modification key data values considered 
data structure detectable exists procedure report true data structure instance results applying fewer changes correct instance data structure 
similarly data structure correctable exists procedure repair changes resulting unique correct instance erroneous data structure instance originated 
assumed data structure consists header number nodes connected pointers 
nodes allowed identifying fields indicate part data structure instance assumption changes arbitrary memory reproduce identifying field instance identifying field correct node allocated instance 
counts allowed 
show examples linked list tree structures different detectability attributes 
provide number upper lower bounds detectability data structures pointers identifying fields counts structures contain 
result data structure correctable contain disjoint sets pointers possible reach nodes structure set pointers 
additional experience producing correctable data structures taylor black form principles follow trying design data structures correction detection routines 
interest taylor seger consider special case erroneous changes result crashes 
crashes may take forms halting error program image data structure intact point failure system failure disk image available 
strategy employed cases carefully code modification algorithm maximum amount information available correction routine 
example insertion algorithm means fully initializing new node changing pointer data structure instance visible 
note similar update techniques wait free data structures discussed 
similar strategy employed crash recovery example newly inserted node written disk writing node contain pointer 
techniques generally powerful database logging techniques may useful non database applications take advantage recoverable spin locks handle process halting failures 
techniques may useful certain transient internal database structures overhead logging unacceptable 
perspective robust data structures effectively shared structures guarantee recovery halting failures concurrent environment recoverable mutual exclusion mechanism employed 
memory protection stonebraker sullivan techniques hardware mechanisms memory protection prevent class physical data corruption address parity word techniques 
model sanctioned updates done special routines 
routines remove hardware protection page larger region change update return protection update 
study performed postgres extensible relational database examines techniques expose page single page unguarded expose segment entire guarded region memory unguarded temporarily deferred write changes side area dbms data exposed system call copy group changes back database buffers 
experimental operating system specially modified allow fast protect memory 
study compares techniques standard postgres additional technique termed full protection uses expose page buffered data expose segment internal structures locks 
performance reported cases flush omitted commit processing leading full cpu utilization flush retained leading cpu utilization 
cpu bound case techniques cost full protection caused overhead 
disk bound case techniques overhead 
writing special system calls sprite operating system making translation lookaside buffers hardware platform page protection turned relatively cheaply 
unfortunately described section unable reproduce overhead figures commercial unclear full protection scheme apparently expensive disk bound case workstations available 
assume modifications operating system allowed significantly expensive protection available portable environment 
contrast new techniques introduced thesis require special operating system hardware support easing portability dbms 
importantly performance schemes limited operating system implementation mprotect system call see section 
memory protection protect logical corruption 
way dealing problems simply roll back database state prior corrupt update resolve transactions update manually 
techniques possible identify subset transactions directly indirectly affected error selectively roll back redo manually automatically cases 
type safety presumably type safe languages provide protection direct physical corruption techniques example spin operating system 
example type safety speed operating system design opal operating system chase levy lazowska baker harvey 
designed bit address spaces virtual pointer basic object naming system 
protection basis virtual segments essentially memory mapped regions 
process may map multiple segments right map virtual segment controlled operating system 
different threads process access different subsets virtual segments mapped process address space 
protection order multiple pages authors suggest type safe compiler provide bulk protection system 
java increasingly server side stored procedures godfrey mayr seshadri von eicken compare performance compiled java context query processing 
determined java function primarily computation parameters speed comparable directly linked functions 
significant database data accessed large number callbacks performance problems arose 
just time compilation java promising approach situations 
dominant cad high performance uses memory mapped database systems unclear approach fully relied techniques thesis may helpful 
sandboxing sandboxing see example provides alternate technique protecting data rewriting object modules minor performance impact 
object module rewriting redesigned target architecture may significant limit portability technique requires number free registers perform may applicable architectures large register set intel architecture 
contrast techniques language instruction set independent 
logical corruption recovery logical corruption extends transaction boundary appears originally discussed davies concept spheres control precursors concept transaction see pages 
davies gives steps taken recovery logical error post process recovery 
symptom error detected 

data suspected sources error gathered sphere control example locks data 

paths dependency searched forward find data affected error data added sphere control 

data item affected user decides compensate 
logical corruption thesis viewed developing algorithms implement parts outline modern transaction processing systems 
example propose algorithms help find source error trace errors corruption forward source read logging information addition normal update information transaction log 
read logging trace dependencies similar audit trail proposed 
audit trail defined sophisticated read logging propose presumably expensive implemented recursively tracks activities audit trail correct errors 
majority transaction processing algorithms developed published 
aware subsequent efforts computer science database community support audit trail 
chapter background dal main memory storage manager number database applications particularly telecommunications industry industries involved real time content delivery high performance access data required 
applications typically need high transaction rates coupled low latency transactions impose stringent durability availability requirements 
example consider real phone application phone call data recorded queries data issued 
application requires albeit small requests lookups updates processed second milliseconds latency lookups minutes time year 
increasing availability large relatively cheap memory suggests database applications reside entirely entirely main memory 
applications experience performance benefits having data cached main memory 
storage manager supporting applications tailored main memory significant additional performance benefits achieved shown 
storage manager provides core functionality database system concurrency control recovery mechanisms storage allocation free space management transaction management indices 
numerous implementations storage managers disk resident data 
include storage managers exodus starburst 
exception starburst main memory storage component aware storage manager tailored mainmemory resident data 
system transaction processing test bed memory resident data full feature storage manager 
dal system implemented bell laboratories storage manager persistent data architecture optimized environments database main memory resident 
number principles evolved dal guide design evolution 
principles direct access data 
dal uses memory mapped architecture database mapped virtual address space process allowing user acquire pointers directly information stored database 
related principle interprocess communication basic system services 
concurrency control logging services provided shared memory communication server 
guiding principle dal enables creation fault tolerant applications 
primary expression principle transactional paradigm dominant technology providing fault tolerance critical applications 
fact dal provides advanced explicitly multi level transaction model facilitated production high concurrency indexing storage structures 
dal system includes support recovery process failure addition system failure codewords memory protection help ensure integrity data stored shared memory 
key requirement applications expect store data main memory consistency response time 
support fine grained concurrency control minimal interference due latching help provide consistency dal 
principles guided dal implementation toolkit approach support multiple interface levels 
implies example logging facilities turned data need persistent locking turned data private process 
second principle means low level components exposed user critical application components optimized special implementations 
applications prefer high level relational interface 
dal systems database larger main memory named honor dal famous painting persistence memory 
locks logs system db db file db file user process user process virtual memory process virtual memory process shared memory user code dali lib user code dali lib checkpoints logs architecture dal system long database fits virtual address space process architecture dal storage allocation indexing recovery facilities designed deliver high performance database fits main memory 
chapter provide brief overview components constitute dal storage manager 
detailed description dal architecture 
dal system basis storage manager currently internal product lucent technologies 
architecture dal architecture database consists database files special system database file 
user data stored database files data related database support log lock data stored system database file 
enables storage allocation routines uniformly persistent user data non persistent system data locks logs 
system database file persistently stores information database files system 
shown database files opened process directly mapped applications heap file indexing logging locking allocation relation manager layers abstraction dal address space process 
dal memory mapped files sharedmemory segments provide mapping 
different processes may map different sets database files may map database file different locations address space 
feature precludes virtual memory addresses physical pointers data database files provides important benefits 
database file may easily resized 
second total active database space system may exceed addressing space single process 
useful machines bit addressing physical memory significantly exceed amount memory addressable single process 
bit machine considerations may significantly mitigated leading consider physical addressing 
single database file limited gigabytes process map close database files expected far exceed total database space 
layers abstraction important feature dal architecture organized multiple layers abstraction support toolkit approach discussed earlier 
illustrates architecture 
highest level users interact dal relational manager 
level call heap file indexing layer provides support fixed length variable length collections template indexing abstractions 
general level need interact individual locks latches 
specifies policy lower level locking lock plus handle 
services logging locking latching multi level recovery storage allocation exposed lowest level 
new indexing methods built layer special purpose data structures application database management system 
course level complex user interface proven creation higher level interfaces database systems described 
pointers offsets crucial performance mapping database pointers virtual memory addresses done efficiently 
dal process maintains database offset table specifies memory database file mapped 
table implemented array indexed integer database file identifier 
primary kind database pointer dal contains database file local identifier offset database file 
dereferencing database pointer simply involves adding offset contained virtual memory address database file mapped looked offset table 
second form database pointer available cases database file known context 
example pointers certain index reside particular database file 
case may store just offset database file pointer 
offsets full pointers implemented simple template classes allow smart pointers 
storage allocation describe storage allocation mechanism dal 
database file dal comprised segments contiguous page aligned units allocation similar clusters file system 
illustrated chunk collection segments 
recovery characteristics memory transient zeroed persistent specified chunk basis time chunk creation 
zeroed memory remains allocated recovery byte set zero 
transient memory data longer allocated recovery 
users allocate chunk specify particular start data chunk collection segments 
segment contiguous page aligned space 
segments chunks segment 
segments arbitrarily large size database arbitrarily large objects stored contiguously 
allocation chunk system returns standard dal pointer space specifies offset file 
elements shown linking segments chunk stored special chunk control information 
storing control information separately data reduces likelihood corrupted stray application pointers 
chunk different allocators available trade speed safety size 
allocators record allocated space retained user remember size allocated data 
required avoid excessive overhead small items 
layer allocator implemented store data allocated space required 
currently defined implemented allocators dal ffl power allocator allocates storage buckets size minimum item size 
ffl coalescing allocator allows allocation exact amounts space merges adjacent free space free tree 
transaction management dal section transaction atomicity isolation durability achieved dal 
transaction management dal principles multi level recovery 
knowledge dal implementation multi level recovery main memory implementations explicit multi level recovery reported date 
scheme data logically organized regions 
region unit physical locking recovery directly related concepts segments chunks 
region tuple object fits single segment arbitrary data structure list tree possibly comprising entire chunk 
region single associated lock exclusive shared modes referred region lock guards accesses updates region 
multi level recovery multi level recovery provides recovery support enhanced concurrency semantics operations 
specifically permits weaker operation locks place stronger shared exclusive region locks 
common example index management holding physical locks transaction commit leads unacceptably low levels concurrency 
undo logging done physically recording exactly bytes modified insert key index transaction management system ensure descriptions valid transaction commit 
descriptions refer specific updates specific positions typically implies region locks updated index nodes retained ensure correct recovery longer needed correct concurrent access index 
multi level recovery approach replace low level physical undo log records higher level logical undo log records containing undo descriptions operation level 
insert operation physical undo records replaced logical undo record indicating inserted key deleted 
replacement region locks may released restrictive operation locks retained 
example region locks particular nodes involved insert released operation lock newly inserted key prevents key accessed deleted retained 
main memory stable log active trans 
table dirty page table database stable log database ckpt dpt cur ckpt ckpt ckpt stable system log system log tail disk active trans table att undo logs redo log undo log trans 
local logs overview recovery structures system overview gives overview structures recovery 
database mapped address space process described section 
checkpoint images database ckpt ckpt reside disk 
stored disk cur ckpt anchor pointing valid checkpoint image database single system log containing redo information tail memory 
variable stable log stores pointer system log records prior pointer known flushed stable system log 
single active transaction table att stored system database stores separate redo undo logs active transaction 
dirty page table dpt maintained database system database records pages updated checkpoint 
att undo logs dirty page table stored checkpoint 
dirty page table checkpoint referred ckpt dpt 
transactions operations transactions model consist sequence operations 
similar assume operation level associated 
operation level database represents single database file 
fact different database files checkpointed different times transactions span database files arbitrarily 
generalization multiple database files straightforward omitted clarity space 
consist sequence operations level gamma transactions assumed level call operations level gamma physical updates regions level operations 
transactions distinguish pre commit commit record enters system log memory establishing point serialization order commit commit record hits stable log 
terminology operations pre commit point meaningful referred operation commit thesis 
transaction obtains operation lock operation executes lock granted operation commutes operation locks held active transactions operations obtain region locks 
locks region released operation pre commits operation lock level held transaction containing operation level pre commits 
locks acquired transaction released pre commits 
deadlock handled checking cycle wait graph transaction waited certain amount time lock 
multi level variation phase locking described guarantees isolation transaction operation transactions operations 
logging model dal uses logging implement atomicity durability transactions 
undo logs ensure incomplete transactions operations rolled back case transaction operation abort redo logs ensure durability face system failure 
recovery algorithm maintains separate undo redo logs memory transaction 
stored linked lists entry transaction att 
update part region generates physical undo redo log records appended transaction undo redo logs respectively 
undo redo logging updates dal done place updates transaction bracketed calls functions 
physical update database region generates undo image redo image transaction abort crash recovery 
undo redo logs dal stored transaction basis local logging 
lower level operation committed redo log records moved local redo log system log tail memory undo information operation replaced logical undo record 
steps take place prior release lower level locks 
copy logical undo description included operation commit log record restart recovery 
dal recovery algorithm repeats history physical level undo processing redo records generated forward processing 
pre commit transaction operation pre commits redo log records transaction redo log appended system log logical undo description operation included operation commit log record system log 
exception logical undo descriptors redo records written system log normal processing 
operation pre commits undo log records sub operations updates deleted transaction undo log logical undo log record containing undo description operation appended transaction undo log 
memory undo logs transactions pre committed deleted required 
locks acquired operation transaction released pre commit 
log flush system log flushed disk transaction decides commit ensuring durability committed transactions 
contents system log tail flushed stable system log disk transaction commits checkpoint 
system log latch obtained performing flush flushes occur concurrently 
stable system log tail called system log 
variable stable log stores pointer system log records prior pointer known flushed stable system log 
flushing physical log records note pages written log record 
information dirty pages noted dirty page table dpt 
ping pong checkpointing checkpointing ensures final portion log needed recovery 
implement checkpointing dal copies database image stored disk alternate checkpoints write dirty pages alternate copies 
strategy called ping pong checkpointing see 
ping pong checkpointing strategy permits checkpoint created temporarily inconsistent updates may written corresponding undo records having written 
writing dirty pages sufficient redo undo log information written bring checkpoint consistent state 
failure occurs creating checkpoint checkpoint consistent recovery 
writing dirty data disk checkpoint notes current stable log variable stable log stored checkpoint 
start point scanning system log recovering crash checkpoint 
contents memory ckpt dpt set dpt dpt zeroed noting stable log zeroing dpt done atomically respect flushing 
pages written pages dirty ckpt dpt completed checkpoint dirty current memory ckpt dpt 
words pages modified current checkpoint image written pages checkpoint written 
necessary ensure updates described log records preceding current checkpoint stable log database image current checkpoint 
checkpoints write dirty pages obtaining latches interfering normal operations 
fuzzy checkpointing possible log records generated updates restart recovery effects idempotent 
uncommitted update effects checkpoint image undo log records written disk database image written 
performed checkpointing att checkpointing data checkpoint att writes undo log records status information 
checkpointing log flush done declaring checkpoint completed consistent toggling cur ckpt point new checkpoint reason 
undo logs deleted transaction operation pre commit may happen checkpoint att 
checkpoint completes system fails log flush checkpoint may contain uncommitted updates undo information 
log flush ensures transaction operation committed updates undone compensating operation undo information log 
abort processing transaction aborts successfully complete execution updates operations described log records transaction undo log undone traversing undo log sequentially 
transaction abort carried executing reverse order undo record just execution part transaction 
correct abort processing face system failure ensures atomicity transactions dal 
philosophy repeating history new physical redo log records created physical undo record encountered abort 
similarly logical undo record encountered new compensation proxy operation executed undo description 
log records updates performed operation generated normal processing 
furthermore proxy operation commits undo log records deleted logical undo record operation undone 
commit record proxy operation serves purpose similar served compensation log records clrs aries restart recovery encountered logical undo log record operation undone deleted transaction undo log preventing undone 
recovery recovery refers actions taken system failure return database transaction consistent state reflecting exactly effects transactions committed 
recovery stable log flushed disk information stored checkpoint 
checkpoint taken database created may taken subsequently recovery described completed checkpoint 
part checkpoint operation system log disk noted database image checkpointed recovery point checkpoint checkpoint completed 
updates described log records preceding point guaranteed reflected checkpointed database image 
restart recovery initializing att transaction undo logs copy att undo logs stored checkpoint loads database image sets dpt zero 
rolls forward system log stored disk applying redo log records recovery point completed checkpoint database appropriate pages dpt set dirty log record 
application redo log records necessary actions taken keep checkpointed image att consistent log applied far 
actions mirror actions taken normal processing 
example operation commit log record encountered lower level log records transaction undo log operation replaced higher level undo description 
redo log records applied active transactions rolled back 
completed operations invoked directly transaction directly invoked incomplete operation rolled back 
order operations different transactions rolled back important undo level sees data structures consistent 
operations transactions rolled back rolled back followed operations level 
single database file recovery times may important recover part database interrupting processing portions 
dal portion database may recovered line fashion follows 
database marked transactions modified portion may update 
active transactions updated portion recovered forced roll back log records generated normal 
current point log noted thenthe previous checkpoint reloaded log replayed forward recovery point checkpoint recovery point 
normal recovery physical redo actions affect portion database recovered played 
log records normally affect att recovery ignored 
active transactions rolled back log records generated rollback log prior recovery point undo processing necessary recovered portions database may updated transactions 
fault tolerance section features fault tolerant programming dal provided directly transaction management 
techniques help cope process failure scenarios 
second techniques help detect recover user programs stray pointers corrupt persistent data stored shared memory 
third technique returns system fully available state process dies transactions progress 
protection bad writes direct access principle dal implies user application code linked directly dal libraries access data stored database shared memory 
comes inevitable chance application error lead bad writes uninitialized corrupt pointers cause persistent data corrupted 
dal provides mechanisms minimizing probability errors lead corrupting persistent data 
memory protection applications wishing prevent corruption due stray pointers map database file special protected mode 
database files dal uses mprotect system call disable updates file process 
page updated undo log record update generated called page 
transaction unprotected pages re protected 
erroneous update attempt update protected page resulting protection violation 
advantage scheme erroneous writes detected immediately traced source debugger 
disadvantage system calls significant performance hit 
result scheme beneficial debugging applications read databases databases low update rates 
codewords alternate technique error detection associate logical parity word codeword page data 
codeword scheme implemented dal data codeword scheme chapter defer discussion point 
process failure process killed halts due protection violation fact detected cleanup server 
server spawns cleanup agent abort progress transactions started process 
cleanup processing incorporates spin lock algorithms thesis additional actions taken cleanup server agent described section 
directory pointer dp directory key entry hash header extendible hashing dal collections indices storage allocator provides low level interface allocating freeing data items 
dal provides higher level interfaces grouping related data items performing scans associative access indices data items group 
heap file heap file dal abstraction handling large number fixed length data items implemented thin layer top power allocator 
addition insertion deletion heap file supports locking unordered scan items 
item locks obtained transparently items inserted deleted updated scanned 
scans supported bitmap stored items segment 
extendible hash dal includes variation extendible hashing described 
overview structure appears 
structure matches bucket concept standard extendible hashing broken hash header list key entries 
directory entry points hash header multiple directory entries point single hash header 
variable maintained hash index bits computed hash value key determine directory entry key directory contains entries 
allowing multiple directory entries point bucket prevents hash headers allocated directory entries key values hashed 
searching key value fairly straightforward involves searching key value list key entries pointed directory entry key 
insertions complex involve splitting individual key entry lists certain cases doubling entire directory 
algorithm attempts keep lists threshold size 
order prevent interference searches inserts lock maintained hash header 
lock obtained shared mode searches traversing list key entries header exclusive mode inserting list 
scheme permits high degree concurrency allowing searches inserts involving different hash headers execute concurrently 
scheme blocks searches splits directory resized 
tree indexes authors proposed trees storage efficient data structure main memory databases 
trees avl trees proposed 
avl trees height left right subtrees tree may differ 
avl trees node tree stores multiple key values sorted order single key value 
order keep occupancy high internal node minimum number key values contain typically gamma maximum number keys stored node 
searching key value tree relatively straightforward 
node check see key value bounded left right key value node case key value returned contained node key value contained tree 
key value left key value left child node searched right child node searched 
process repeated key node searched null 
insertions deletions tree bit complicated 
insertions deletions variant search described find node bounds key value inserted deleted 
insertions room node key inserted node new node allocated containing key 
deletions key deleted node node de allocated node empty case number keys node falls specified minimum keys node different node 
insert delete allocation de allocation node may cause tree unbalanced rotations rr rl ll lr described may need performed 
tree implementation uses key locking avoid phantom phenomenon 
high concurrency provided requiring operations tree obtain tree latch duration operation duration transaction 
inserts deletes obtain latch mode search operations obtain latch mode 
dali relational manager dal relational manager class library interface relational system sql support limited definition statements 
access data classes corresponding tables iterators search criteria schema information stored tables limited views project select joins allowed 
indices may created arbitrary subsets attributes table 
referential integrity supported foreign key constraints null values 
navigation supported iterators single table 
conjunctive query may specified iterator automatic index selection performed 
extension relational model inter table joins may stored schema 
open iterator new iterator matching tuples table may easily opened 
join relationship may materialized leading underlying pointer list structures similar network database 
feature required allow high speed navigation competes object oriented models requiring explicit pointer types 
overview architecture dal main memory storage manager 
knowledge dal contains explicit implementation multilevel recovery main memory disk systems 
described storage architecture dal implementation tree extendible hash index structures 
described extensive features detection bad writes processes 
facilities implemented dal protection process failure arise algorithms developed thesis described subsequent chapters 
chapter recoverable spin locks chapter introduce spin lock mechanisms recoverable face process halting failures 
section detailed background information construction spin lock algorithms 
section gives formal hardware model derive results 
section gives precise statement problem solving section provides overview approach 
section recoverable lock acquisition release protocols section describe cleanup takes place case process failure 
proof correctness scheme section 
recoverable variant complicated queue lock chapter extensions performance information apply algorithms chapter 
background section background issues recoverable spin lock algorithms sections 
discussing support atomicity provided modern hardware platforms 
discuss correctness issues considered implementing concurrency algorithms weak consistency models supported processors 
discuss performance issues arise spin lock algorithms high contention multiple processor environments 
hardware support atomicity general modern hardware provides support high speed concurrency control providing atomic instructions providing mechanism lock cache lines 
formal model algorithms atomic instructions give overview approaches 
atomic instructions atomic instruction takes form read memory location operation value depends particular instruction write back memory location 
system ensures processor execute read write memory location read write atomic instruction 
systems effects atomic instructions blocked interfering progress 
example atomic instructions section common atomic instructions 
cache lines data transferred cache main memory fixed length blocks known cache lines usually order bytes length 
systems atomicity viewed cache problem instruction set problem 
processor cache mechanism cache coherency provided part mechanism allows processor lock lines cache 
systems cache line locked processor allowed read write memory location line lock released 
systems read write processor locked line allowed bit set allows locking processor detect intrusion 
wide variety synchronization abstractions built facility lock cache lines 
particular atomic instructions described section may easily implemented 
synchronization abstraction locking cache line implemented example sequent symmetry series dec alpha architecture 
common atomic instructions example atomic instruction compare swap specified registers say 
contains address memory location operated 
int compare swap register int target register int old register int new target old target new return return void swap register int target register int val int tmp target target val return tmp int test set register int target int tmp target target return tmp void fetch add register int target register int val int tmp target target target val return tmp definition atomic instructions 
location contains value equal contents replaced 
atomic instructions include test set swap fetch add 
fetch add atomically adds value memory location returns old value implemented nyu widely adopted 
compare swap popular architectures hp pa risc sparc prior version test set form swap 
give definitions instructions presenting functions 
architecture supporting instructions function implemented atomically corresponding instruction 
clarity parameters functions registers 
weak consistency modern multi processor shared memory systems provide limited consistency guarantees application programmers 
fact significantly complicates design correct locking algorithms processors 
systems said implement forms weak consistency processors opposed full sequential consistency 
considers history loads stores processor system including values read written sequential consistency requires interleaving histories processors leads consistent schedule load operations memory location return value stored location 
pointed lamport assumption hold modern multiprocessor systems fact trend consistency hardware designers pursue higher clock speeds 
basis weak consistency pipelining 
example load may issued soon address decoded value may returned stages depending arrives cache memory 
second load instruction decoded value arrives highly pipelined system go ahead issue request memory system 
second value may arrive example available cache value main memory 
source weak consistency store buffering 
case number outgoing stores proceeding concurrently subsequent apparently unrelated instructions execution 
model showing correctness synchronization algorithms assumes store buffering source weak consistency effect terms application programs similar regardless source 
simple example illustrating unexpected results obtained weak consistency adapted appears 
init init example assumes execution 
sequential consistency execution processes case value 
weak consistency initial stores may reach global memory apparently unrelated reads respectively executed fact possible value final state 
modern processors provide mechanisms ensure greater consistency memory system 
cases example alpha takes form explicit memory barrier instruction 
instruction forces outstanding loads stores instructions preceding stream completed load store subsequent instruction may begun 
architectures sparc architectures prior version explicit memory barrier synchronization instructions test set effect 
processors communicate control synchronization instruction sequential consistency result 
goal allow processors execute highly pipelined fashion private data slow certain shared data ensure correctness 
spin locks contention scalability section review variety spin locking mechanisms motivated need respond contention need scale large number processors 
discussion performance studies conducted graunke anderson 
note studies report results experiments conducted platform sequent symmetry 
study graunke anderson examining simple test set spin lock 
lock described detail section 
studies conclude common hardware mechanisms cache coherency lock cause excessive bus traffic processors waiting single lock 
example system invalidation cache coherency sequent symmetry test set instruction succeeds acquiring lock causes processors lock cached refresh cache line containing lock caches system 
processors caching lock processors refresh cache block 
processors attempt acquire lock simultaneously bus traffic generated 
variation simple spin lock process spins doing simple reads performs test set lock status free read 
variation helpful reducing bus contention simple spin lock critical section guarded lock relatively long bus invalidation traffic generated protocol lock changing hands 
lock released processor executes test set turn causes processors invalidate cached copy lock refresh cache line 
studies find critical section guarded lock short lock performs slightly better simple test set lock high contention 
papers consider variety backoff techniques reducing overhead related lock contention 
protocols developed ethernet style networks failed attempt acquire lock causes process pause amount time retrying 
usually subsequent failures lead process delay longer retrying 
techniques capable significantly reducing excessive bus traffic simpler protocols anderson observes careful implementation achieve benefit 
back strategies drawback burst contention spin lock lead processes building relatively long delay amounts 
contention drop quickly critical section may sit idle processors wait back delay times 
graunke discuss tournament lock single lock replaced group locks organized tree 
processes owns root lock enter critical section 
process may initially try acquire root fails try acquired locks path leaf root 
tree branches ways level sufficiently deep lock contention processors time 
technique effective reducing contention significant space overhead 
essential locking mechanism locks discussed far unchanged single port memory store swap load store swap load store swap load store swap load pn memory system processors non fifo store buffers sparc memory consistency model simple test set lock locks identical simple spin lock terms ability recover case process attempting acquire lock experiences halting failure 
queueing spin locks study graunke anderson concludes presenting variation queue lock 
idea process desiring lock adds queue processes waiting lock 
wait spinning private location associated position queue 
location changes lock changes hands processor cache receives invalidation message 
third queueing lock called mcs lock developed mellor crummey scott 
focus mcs lock recoverability lock chapter 
system model assume hardware model multiple processors sharing common memory 
account difficulties faced implementing synchronization algorithms modern processors described section assume weak memory model stores potentially forwarded global memory order certain synchronization instructions 
particular take partial store ordering pso model basis correctness proofs 
augment model concept fence instruction forces writes issued far globally visible 
particular formalism chosen intended model sparc architecture popular processors implement similar consistency models believe solution map easily systems correctness re proven 
brief overview partial store order model 
model partial orders partial ordering memory operations generated processor denoted partial ordering memory operations executed global store denoted 
informally axioms defining effects operations model follows 
total order store operations global store totally ordered 
atomic swap write global store memory location allowed load store parts swap 
termination writes buffered local store eventually carried global store 
value value returned load processor store order stores load order load ordering op op op memory operation denotes load location processor storage barrier store operations processor separated storage barrier fence instruction fence appear order location ordering writes location processor carried order generated formally denotes store location processor 
term fence denote generic storage barrier instruction 
shared memory systems aware weak consistency guarantees alpha provide storage barrier instructions 
cases sparc architectures prior version synchronization instructions achieve effect storage barrier possibly higher cost 
term integer synonymously term word assume reads writes word atomic assumed pso model 
assume processes fail safe modify lock control information provided interface code 
assume register contents lost process halting failure 
assume application ask operating system particular process died informed process death 
algorithms dead represent ability 
assume distinguished system process execute application code subject halting failures 
assumption algorithms contradict known negative result 
problem statement consider atomic test set implementation spin lock 
noted key requirement recovering locks ability reliably determine ownership lock 
obvious step tracking ownership spin lock require successful attempt acquire set latch immediately followed write stores new owner identifier process thread identifier abbreviate process id owner field associated lock 
refer step registration ownership lock process 
acquisition release protocol variation simple spin lock 
clearly steps atomic compare swap instruction find process currently owns spin lock 
discussed section common architectures lack compare swap instruction implement steps atomically 
suppose processes system find waiting enum struct lock flag owner acquire attempt lock pid test set flag free mutex owner pid return acquired return busy acquire attempt acquire lock lock pid repeat forever stat acquire attempt pid stat acquired return acquired sleep repeat acquire lock release lock spinlock owner process flag free release lock simple spin lock owner longer resource ought waited 
examining lock structure may determined particular process holding lock 
consulting operating system process question dead safe attempt clean lock data structures may guard 
unfortunately detection ownership complicated fact processes may get interrupted may killed acquisition registration spin lock may state acquired know process 
symmetric problem arises releasing spin lock performed release interrupt actions leave spin lock unknown owner 
case directly distinguish spin lock having acquired dead process lock having acquired process alive progressed step second step 
problem find acquisition release protocol allows determine finite number steps process halted holds particular lock 
overview approach step solving problem require processes trying acquire spin lock note pointer spin lock interested process shared location 
call location process wants field 
say process registers interest lock sets wants field point lock interest sets wants field back null 
collection processes wants fields provides set possible owners spin lock 
set overestimate ownership sense owner member set 
contrast owner information stored lock underestimate ownership set process process id immediately gained access spin lock back process immediately releasing 
processes decide try acquire lock time may set reset wants field making difficult get consistent picture set 
clearly lock introduced help get consistent picture halting failures lock handled turn 
solve problem introduce flag associated spin lock called cleanup progress require processes attempt get spin lock flag set 
flag provides barrier raised prevents new processes entering set potential owners 
solution distinguished process called cleanup process attempt recover spin locks affected processes halting failure 
cleanup process assumed free halting failures 
cleanup flag particular lock set cleanup process attempts resolve ownership lock 
possibility exists processes repeatedly acquire release spin lock leaving spin lock acquired unregistered status tested cleanup process registering ownership tests cleanup process 
distinguish case death single process indeterminate state 
explored counter incremented lock acquisition distinguish cases 
complicated proof correctness considerably abandoned approach 
additional tools determine dead process holds spin lock 
start setting cleanup progress flag gathering list potential owners wants information 
making copy wants information helps avoid certain pathological scenarios streams new processes 
reasonable wait situation resolves wait finite number processes give interest register ownership lock 
design algorithm process advance instructions register ownership notice progress flag set relinquish interest spin lock 
method handling case processes fail progress described chapter 
enum struct lock flag initially free owner initially process boolean cleanup progress initially false struct lock wants system data structures acquisition release protocol detailing shared data needed scheme spin lock acquisition release protocols 
procedure determining ownership case failure section 
system data structures example declaration data structures recoverable protocol 
structure lock flag refers actual test set target variable owner set process acquiring lock 
cleanup progress written cleanup process form new processes described earlier 
represents data needed process access spin lock 
member wants variable set process point spin lock trying acquire reset null releasing failed attempt acquire lock 
spin lock acquisition spin lock acquisition attempt routine acquire attempt shown pseudo code 
indentation indicates nesting 
labels left ease subsequent discussion 
code shows explicit storage barrier instructions denoted fence 
instructions required architecture supports sequential consistency required weaker consistency model assume 
process sets wants variable ma wants indicate spin lock wishes acquire checks sure cleanup progress tries acquire lock 
attempt successful process records new ownership owner pid returns 
fails process clears wants variable returns enveloping routine acquire lock 
waits returns failure acquire lock 
routine acquire lock repeatedly calls acquire attempt succeeds 
easily extended time fail number attempts implement back strategy 
spin lock release spin lock release code simple clearly demonstrates underestimation overestimation ownership owner ma wants respectively 
point indicated extra fence required termination process act fence 
may case example process terminates due processor failure assume process failure fact act fence 
example normal operation illustrate left successful acquisition recoverable spin lock right attempt fails due contention 
shown boxes associated changes state lock 
successful acquisition illustrated left process begins registering interest spin lock point checking status 
test set finds spin lock registers ownership setting lock owner process id 
point control returned application code may access protected resource 
acquire attempt lock ma register boolean cleanup ma wants fence cleanup cleanup progress cleanup ma wants null fence cleanup progress sleep endwhile return failed acquire try test set flag free mutex owner pid fence return acquired ma wants null fence return busy acquire attempt acquire lock lock pid ma pid repeat forever stat acquire attempt ma stat acquired return acquired sleep repeat acquire lock spin lock acquisition code release lock ma lock ma wants owner process fence flag free fence ma wants null release lock spin lock release code lock owner lock free lock busy wants finds gets spin lock registers ownership uses resource user code ownership releases spin lock wants null lock lock lock lock owner owner owner owner owner lock wants finds doesn get spin lock wants null sleeps normal operation spin lock acquisition release code failed attempt get lock illustrated right important note check point registering interest attempting get spin lock 
note process interest mutex sleeping 
simple spin lock attempt guarantee fairness 
cleanup process cleanup process executes procedure owns shown detail determine ownership spin lock 
high level procedure owns proceeds follows 

raise cleanup progress temporarily preventing process currently want spin lock getting 

take overestimation snapshot processes acquire spin lock cleanup period 
snapshot called viewwants gathered process wants variables 

main loop cleanup routine waits conditions state spin lock observable live owner registered 
viewwants empty live process remains possibly spin lock 
occurs decision immediately appropriate status returned 
cleanup routine waits little retries eliminating candidates viewwants simple tests 
occur eventually occurs limited assumption progress see section 
second condition occurs spin lock held held dead process 
point appropriate status returned calling program 
note possible return value owns indicates lock held dead process process returned owner 
section explains case pose difficulty argue ownership exactly determined 
driver code called owns takes appropriate action return status discussed section 
performance code improved ways 
test determine owner spin lock known done executing main code function 
second check added perform wait line eliminating candidates 
omit optimizations code simplicity exposition proof 
example cleanup procedure resolving status spin lock straightforward ownership registered dead alive process spin lock currently free 
cases determination ownership simple 
impractical give examples cases non trivial example cleanup routine operation 
scenario begins process calling acquire attempt 
step takes register intention acquire spin lock setting wants finding cleanup progress attempts get spin lock succeeds 
crucial point right registering ownership suffers halting failure 
dying enters acquire attempt registers intention acquire finds cleanup progress false attempt acquire context switch occurs 
point player begins registers intention acquire takes context switch check cleanup progress 
cleanup process notices dead test done carefully reading owner field call dead done atomic action 
handled second reading owner dead returns true 
interested begins owns immediately raising cleanup progress true 
wakes finds goes waiting loop 
cleanup process snapshot called viewwants potential spin lock holders 
snapshot atomic produce superset possible holders case comes processes 
quickly removed dead reset wants field back null 
single live process may holding spin lock registers ownership may case dead process holds example 
cleanup routine waits progress 
section allow process killed time progress 
progress attempt get spin lock fails held time progresses instructions interest spin lock going sleep try soon tries cleanup ends stopped 
soon cleanup process notices interest removes viewwants 
viewwants empty concludes live process hold spin lock 
lock held concludes held dead process registered 
cases possible process acquiring spin lock registered process process releasing spin lock case process carried actions guarded resources safe handle situation lock acquired 
second case handled release successfully completed normal operation 
case lock may simply released 
determination cleanup process lowers setting cleanup progress false 
newcomers attempt acquire example shown getting 
proof correctness state lock held dead process change theorem allows useful recovery routines built owns 
theorem procedure owns terminates reports ownership status spin lock accurately reflects state point time owns called 
proving theorem give intuitive overview correctness argued 
boris mark verification tool generate independent mechanized proof correctness case processes attempting acquire spin lock 
overview correctness cleanup algorithm follows main points 
suppose algorithm observes informative state spin lock free owned process 
lock observed free represents accurate state lock assumption spin lock works correctly 
observes registered owner subsequently seen alive owner alive owned lock observed owner owner owner field underestimation ownership 
note time observed state reported state may longer exist 

cleanup progress raised set true viewwants gathered process viewwants get spin lock 
eliminates scenarios involving infinite stream processes 

viewwants finite process progress dies leave set 
algorithm decision viewwants empty assumption progress guarantees algorithm terminate 
algorithm doesn terminate viewwants empty spin lock held held dead process potential live owners members viewwants 
registered owner process dead process just acquired spin lock update structures finished updates verge releasing 
case safe free spin lock see section technical note point 
time ordering proof proof correctness depends existence partially ordered execution history totally ordered history events equivalent 
assumption sequential consistency 
extend model section follows 
addition operations load store fence introduce operation corresponding initiation store processor add operation immediately preceding define new relationship extension particular execution contains edges involve store 
order defined follows 
extension op op op op extension op store op op op op 
note local store ordering preserved minimality edge introduced rules 
claim vh relationship associated particular history execution definition vh acyclic 
proof sketch give constructive proof 
consider total order ignoring initiate operations 
load operations processor order order total order operations processor 
insert operations total order just load operation preceding preserving ordering operations claim total order satisfies requirements extensions showing acyclic 
edge introduced extension trivially satisfied definition total order 
edge introduced extension edge relates load initiate operations relation satisfied construction 
load store pairs relation satisfied load ordering axiom construct construction 
initiate store pairs order relation satisfied initiates introduced earliest location preceding load corresponding stores 
execution construct total order shown proof claim 
properties value property restated terms total order value value returned written latest prior load total order followed latest initiation exists 
value property ensures load reads latest value total order precedes available locally 
total order equivalent particular execution represents particular pattern inconsistent values available different processors 
inconsistencies fact normal operation stores propagated global memory arbitrary delay 
fence abstraction limit nondeterminism 
refer points total order points time 
reason possible total orders execution correspond possible partial orders 
proof depends existence global time sequential consistency believe informal proof extended formal proof partially ordered model 
algorithm operating system calls determine process died 
model action assuming dying process final synchronized write particular memory location indicate dead 
definitions process cleanup process overloaded refer process id appropriate 
spin lock system 
wants wants variable process spin lock access record defined structure 
sequence points total order time relationships refer order 
dead method polling operating system determine process alive 
start point store global store value true assigned cleanup progress process executing owns 
view event process executing owns passes having fixed initial value viewwants 
empty event process executing owns exits loop having removed member viewwants 
finish point order store false cleanup progress happens call owns 
process states purposes algorithm describe states process may respect ownership particular spin lock 
state defined terms value global variable written process definition read terms time value visible cleanup routine prove algorithm terminates finish associated interval considered possibly infinite 
start finish may start propagated global memory see section 
fence follows write ensuring relationships assumed definitions hold globally 
correctness algorithm fact process exactly states transitions suitably controlled 
fact principle cleanup progress removal possible transition cleanup routine executes forcing process progress reach quiescent observable state 
state user code wants pointer process null 
may user code entry exit points acquire attempt exit point release lock 
may move state second assignment acquire attempt 
state pre process acquire attempt location cleanup process copy wants pointer process non null assignment cleanup cleanup progress executed time process try acquire spin lock step acquire attempt 
examples locations include steps right acquire attempt 
important note process steps state variable cleanup assigned true step assignment step attempt acquire spin lock 
fence accesses wants cleanup progress ensures registration wants information globally visible process enter state 
process leaves state state immediately assignment false variable cleanup step enters state sets wants pointer null 
enters state process passed 
state waiting cleanup process seen cleanup progress true waiting change variable back false propagate global memory visible false state 
processes steps state 
state indeterminate acquire attempt location past assignment false variable cleanup process globally registers ownership spin lock fence returns state step failure get spin lock 
examples code locations state right assignment false value local variable cleanup attempt get spin lock 
state registered process registered owner spin lock 
may move state finishing spin lock calling release lock 
state indeterminate process release lock 
state transition diagram process respect spin lock summarized transition diagram 
states double circled ones assume process progress 
dotted line transition effectively removed cleanup progress set true 
proofs lemma process holds spin lock time wants global store 
proof examination code 
wants set fence executed attempt get spin lock 
symmetrically wants set back null failed attempt acquire releasing spin lock 
fence test set instruction acts fence immediately precedes assignment null wants activity regarding spin lock finished visible cleanup process time wants global store 
lemma finds cleanup progress true point start finish making assignment cleanup set wants null attempting acquire change value wants finish proof inspection code 
note definition time start cleanup progress value true globally 
assignment true value cleanup cause process set wants null go loop waits value cleanup progress return false 
definition earliest occur finish time process acquire spin lock 
lemma process wants global store start finish get spin lock time finish point cleanup 
proof contradiction assume wants holds point finish lemma set wants time statement changes wants null statement immediately followed fence point process sets wants occurred program reaches point 
acquire lock finish execute statement reach 
definition start finish find cleanup progress true lemma attempt acquire lock 
contradiction 
lemma live process holds spin lock time view finish member viewwants point 
proof contradiction process holds spin lock time view finish viewwants time view wants read read loop point execution start view lemma process may hold spin lock finish contradiction 
lemma live process holds spin lock time view finish member viewwants time 
proof lemma know process may hold view finish initially computed value viewwants time view show live process holds may removed viewwants finish processes removed viewwants point cases case wants equal global store time polled 
view finish lemma acquire spin lock 
case dead returns true 
dead longer concerns claim lemma procedure owns returns falling loop state reported spin lock accurate point time start proof return falling loop procedure goto point 
case point 
registered process dead false point 
owner read global store held live process status reported 
case point 
spin lock free held dead process 
value free process reflects state 
note case process holds spin lock may die owns returns second process viewwants may acquire lock die owns returns apparently making return value incorrect 
guarantee reflect states spin lock call 
lemma cleanup progress remains true process progress states finite amount time 
proof follows facts 
state transition table processes acyclic cleanup progress true see 
second states consist straight line branching code leading states sub cases correspond current state process viewwants time view finish state process state cleanup may polled seen viewwants 
immediately move state point assignment fence 
state get spin lock go state get spin lock go state 
state processes state unregistered owner spin lock straight line code release control spin lock set wants null global store moving state 
lemma cleanup process exits points process viewwants removed finite amount time 
proof cases 
case suppose process dies observed state observed state cleanup process returns covered lemma 
case process removed 
case suppose process observed state 
states wants null process removed test 
case alternative cases process remains indefinitely state returns repeatedly causing removed viewwants 
happen lemma 
theorem procedure terminates reports ownership status spin lock accurately reflects state point time called 
proof main loop owns exits viewwants empty lemma gives valid state returned caller 
viewwants finite 
lemma gives early return take place member eventually leave 
members left test viewwants fail algorithm arrive 
assume arrives lemma live process holding spin lock member viewwants set empty 
process holds spin lock dead process holds 
test lock seen held status held returned owner id process process holding died registering ownership process status dead 
lock free free returned lock status 
situations value returned owns accurately reflects ownership mutex point owns lock viewwants owner cleanup progress true fence start viewwants foreach process fence wants viewwants viewwants fpg view viewwants owner owner owner process dead owner status held owner alive goto done flag free status free process goto done code slow processes goes sleep short foreach viewwants wants dead viewwants viewwants fpg endwhile fence empty owner owner status static 
may owned process flag held status held owner dead status free process done cleanup progress false fence finish return status owns owns procedure cleanup waits lock owner cleanup lock owner cleanup lock owner cleanup lock owner lock owner cleanup crashes 
registering ownership wants finds wants finds cleanup begins viewwants snapshot finished removed viewwants wants null removed viewwants wants finds wants null finds tries wants finds gets lock doesn get lock viewwants empty held dead returned 
data cleaned returned service cleanup gets lock registers example run owns wants attempt get seen registers ownership de registers ownership failed get passes wants null user code pre waiting cleanup indeterminate registered indeterminate states transitions proof chapter recovering scalable spin locks described section drawbacks exist simple spin locks carry recoverable variant chapter 
simple spin lock implementations processors multi processor system frequently access attempt write lock control variable 
update attempted update uses synchronization instruction leads cache invalidation messages sent processors 
volume messages contribute significantly load system bus 
volume messages increases number processors performance phenomenon described poor scalability 
chapter examine recoverability spin lock algorithms address problem 
algorithms building queue processes waiting lock 
queue non empty process wait spins private location associated position queue 
lock released owner sets flag process queue spinning 
flag different cache line processor cache receives invalidation message lock changes hands 
focus primarily queueing algorithm called mcs lock develop variants algorithm handle process halting failures 
problem statement versions mcs lock protocol swap 
algorithms swap construct queue compare swap transition lock release queue entry empty queue 
clarity recoverability problem solution terms simpler algorithm uses compare swap 
extension handle case compare swap unavailable section problem modify protocol queue structure maintained case multiple process failure 
informally ffl queue entries lost starvation due loss queue structure 
ffl process time believes owns lock 
ffl owner dies ownership transferred dead process live process reasonable amount time 
give examples failure processes executing mcs lock protocol lead inability processes acquire lock 
adaptation mcs lock algorithm process queue node type qnode mynode pointer 
queue node consists pointer locked flag indicates process lock 
value locked waiting owned released deviating slightly original protocol 
lock consists single field tail points node queue 
contains lock acquisition release routines adapted 
acquisition algorithm called behalf process straightforward 
swap lock pointer acquire simultaneously lock tail point mynode returning pointer previous node 
previous node pointer point mynode 
second assignment takes place traversal list node pointed lock tail assuming assignments taken place 
point spins waiting previous owner lock pass ownership immediately assumes ownership previous owner 
lock release code proceeds follows 
entry list successor just sets node flag owned entry list setting acquire lock lock lock register qnode mynode qnode pred mynode null mynode locked waiting pred swap lock tail mynode pred null pred mynode mynode locked owned mynode locked owned return lock acquired release lock lock lock register qnode mynode mynode locked released mynode null queue compare swap lock tail mynode null return lock released mynode null mynode locked owned give ownership process queue mynode null return lock released mcs lock protocol 
null 
releasing lock node mynode may successor case algorithm go little trouble 
mynode field null process queued lock successor performed swap logically successor patched field 
compare swap set lock tail null pointing mynode 
compare swap succeeds implying lock tail pointed mynode queue fine 
compare swap fails returns false come started adding queue 
case just spins waiting field filled 
version algorithm vulnerable process failure places 
example process dies waiting lock receives lock release 
similarly owning releasing lock death process prevent ownership passed 
particularly difficult window initial swap acquire code subsequent assignment pred links new node queue 
process died executing swap setting field queue broken point 
pathological cases involving multiple process failures occurring window queue fragmented separate lists 
attempting recover fragmented list difficult distinguish field set due dead process set due slow process 
remainder chapter addresses problem recovering mcs lock case process failure 
overview solution term recoverable mcs lock lock adds features original algorithm 
approach similar spirit taken chapter simple spin locks 

pointer lock called wants introduced qnode structure 
process indicates interest lock setting wants variable point lock attempting acquire changing released 

boolean flag called volatile added qnode structure 
process indicates modify structure queue setting volatile variable true resets variable modification finished stores modification reached global store 

boolean flag cleanup progress integer clean cnt added lock structure 
processes attempting acquire release lock respect cleanup progress take steps modify queue flag set certain processes volatile flags set 
release routine examines clean cnt determine cleanup process released lock behalf partially executed release 

dead process wants pointer seen point lock cleanup routine invoked lock 
cleanup routine takes steps ensure restore consistency lock queue 
assume processes progress volatile flags set 
assuming concurrency mechanism starvation free just process enters spin lock acquisition release code receives cpu time execute interrupted returns spin lock code finite amount time 
process may violate assumption having low priority getting cpu time os extension deal case discussed chapter 
assumption additions algorithm outline steps taken cleanup process finding process died accessing lock 
new processes prevented disturbing lock queue structure setting cleanup progress true lock 
second routine waits processes want lock set volatile flag false 
point queue stable inconsistent appropriate steps taken return consistency including adding links missing due failed processes 
cleanup progress set back false restoring lock normal operation 
note correctness procedure depends limited assumption progress guarantees cleanup routine wait forever processes set volatile flags false 
simplicity presentation assume process may hold spin lock time 
may easily extended allow multiple concurrent locks process qnode structures process 
note allocation brokered recoverable locks 
process identifier stored qnode mechanism exist qnode mapped process cleanup server 
note technique guarantees remote lock acquisition release normal operation 
case process failure processes executing protocol may spin single global cleanup progress variable causing flurry invalidation messages system bus value changes 
enum owned struct qnode qnode locked lock wants boolean volatile struct lock qnode tail int clean cnt boolean cleanup progress system data structures 
episode bus contention correspond event process failure execution cleanup routine 
events thousands times expensive single flurry bus contention system dire circumstances extremely rare 
chose introduce extra complexity protocols retain remote property failure case 
recoverable mcs lock protocol recoverable mcs lock protocol 
data structures scheme summarized consist queue node qnode process entity lock lock 
recoverable mcs lock acquisition lock acquisition code 
notable changes involve handling new volatile wants fields qnode structure 
note set process adds queue checking cleanup progress flag 
cleanup progress seen true wants set back null volatile false process waits cleanup finished returning failure caller 
process reaches value false seen cleanup progress 
acquire attempt lock lock register qnode mynode mynode null qnode pred mynode volatile true mynode wants lock fence lock cleanup progress mynode wants null mynode volatile false fence lock cleanup progress sleep little return failed acquire lock try mynode locked waiting pred swap lock tail mynode pred null pred mynode fence mynode volatile false mynode locked owned spin mynode locked owned fence mynode volatile false return acquired acquire attempt acquire lock lock lock qnode mynode repeat forever stat acquire attempt mynode stat acquired return acquired repeat acquire lock recoverable mcs lock acquisition 
point algorithm original volatile set back false waiting locked flag changed owned 
consistent meaning volatile process waiting lock modify queue structure call acquire attempt 
note wants continues point lock lock released 
recoverable mcs lock release algorithm release lock complicated acquisition due code 
describe case handled code describing simpler cases 
action release code set volatile true indicating intention adjust queue structure 
routine checks cleanup progress acquire routine 
note code symmetrical corresponding code acquire similar piece code occurs 
release lock lock lock qnode mynode mynode volatile true fence lock cleanup progress mynode volatile false lock cleanup progress sleep little return lock released try mynode locked released mynode null compare swap lock tail mynode null mynode volatile false mynode wants null return released int cc lock clean cnt cleanup proc sets flag fence mynode volatile false mynode null cc lock clean cnt lock cleanup progress false spin mynode volatile true fence lock cleanup progress cc lock clean cnt mynode volatile false mynode wants null lock cleanup progress sleep little return released fence mynode locked owned give lock process queue fence mynode volatile false mynode wants null return released recoverable mcs lock release 
mynode seen successor routine proceeds simple case passing ownership successor 
fence instructions required correctness example ensures processes appear owner time outside observer 
mynode successor algorithm attempts change lock tail point null atomically ensuring points mynode 
note need compare swap instruction relaxed mcs lock algorithm 
corresponding relaxation algorithm section 
compare swap succeeds queue empty algorithm notes longer modifying queue structure setting volatile false swap serves fence longer interested lock setting wants null 
describe complicated cases may arise due concurrent release acquisition lock 
mynode seen point null lock tail seen pointing node mynode compare swap fail 
case process issued swap acquisition algorithm issued assignment 
process releasing lock wait set releasing process field 
cc lock clean cnt part check handles case dies executing possibly infinite loop 
cleanup routine started take responsibility freeing lock releasing process process spins 
wait done volatile flag unset ensure key property processes progress volatile flags set true 
process wait process volatile flag set second process die preventing progressing violating property 
volatile set back true check cleanup progress 
necessary maintain invariant processes go state volatile false statement modifies structure list cleanup progress 
cleanup take place cleanup routine chosen new owner queue 
clean cnt incremented cleanup routine sure releasing process attempt pass ownership corrupt locking mechanism 
alternative strategy cleanup routine recognize processes middle release call try 
complicate proof correctness simplifying algorithm 
node successor algorithm back case code continues described 
cleaning mechanism assumes separate process thread known cleanup process responsible returning lock consistent state case process failure 
details concerning process initiates cleanup coordinates allocation de allocation qnode structures section 
describe algorithm restore lock consistency 
procedure cleanup proceeds follows 
cleanup progress lock set true preventing processes don volatile set modifying list structure 

list parties interested lock assembled set viewwants subset may potentially modifying queue structure placed set 

cleanup process waits empty live process modifying queue 

processes interested lock longer volatile sections code clean cnt lock incremented ensuring process releasing lock continue release cleanup routine assigned new owner 

queue empty point routine returns freeing qnode process died 

owner determined 
pass dead processes removed viewwants 
owner dead structure guarded lock suspect cleaned calling cleanup guarded structures routine supplied user 
owner waiting process dies immediately check caught subsequent run cleanup routine 

nodes live processes waiting lock pointed lock reassembled single list 
repairs breaks list caused dead processes safely ignoring original order queue lock fifo failure takes place 

owner replaced head queue node new head owner tail placed 
case single node list handled 

lock returned active setting cleanup progress back false 
note case simple spin locks previous chapter process determining owner separated cleaning guarded data structure 
lock restored sanity process owner died owner died lock cleaned queue returned 
proof correctness presenting proof correctness lock algorithm provide overview correctness conditions proved 
points summarize correctness conditions 
ownership 
queue empty single owner cleanup process owned lock start process released lock died 
point owner 


lock just write cleanup progress processors dead cleanup lock lock lock cleanup progress true fence start viewwants set processes want lock set processes viewwants volatile field true foreach process volatile dead remove stable lock clean cnt lock tail null lock cleanup progress false fence return owner process foreach node viewwants dead pid locked owned lock cleanup guarded structures locked released remove viewwants locked owned owner process dead lock tail lock tail null check lock tail re attach viewwants 
locked waiting arbitrary order owner process owner owner owner process owner locked owned process owner lock tail fence lock cleanup progress false finish cleanup code 
waiting lock acquired lock just 
processes added lock queue 

dead processes 
processes seen dead cleanup routine removed queue 

termination 
cleaning queue takes finite amount time 
points outline proof 
viewwants holds candidates owning waiting lock subset viewwants holds candidates modifying lock 
follows careful manner wants volatile flags set cleanup progress flag 
note sets overestimates individual process set may longer want lock able modify respectively 

empty live process may modifying queue ownership may change 

empty finite amount time 

remainder cleanup algorithm working stable possibly inconsistent structure correctly repairs queue necessary chooses new owner 

process seen dead cleanup routine included queue 
assumptions assume ease exposition proof process operates processor 
assume protocol modifying extent modification thereof works sense processes owning state time possibly due interference cleanup routine 
assume process progress cpu cycles volatile true 
correctness algorithm relate state queue cleanup state queue cleanup finished 
lemmas supporting proof form time time certain property holds 
statements carefully considered insure meaningful algorithms partial store order pso model see section 
meaning time relationships proof refers number time relationships 
particular times start stable finish terms referring value certain variable certain time 
refer start state system cleanup finish state 
approach argue synchronization instructions fences events related points time related stores reads global store 
example consider fence 
ensures updates volatile wants global store cleanup progress read 
cleanup process writes cleanup progress read come global store 
statements ordered total order events global store 
cleanup routine write cleanup progress followed fence reading values volatile wants 
situations conclude read false volatile cleanup routine implies corresponding process read value cleanup progress 
proof refer event happen start 
describe meaning time relationship statements terms formal model 
actual proof meanings fences level detail 
start event global store start follows start event store true cleanup progress event local store processor cleanup processor start follows event load fence executed global store start stable defined similarly start event global store load true volatile flag loop preceding stable comment cleanup routine 
finish event global store finish precedes event global store corresponding store false cleanup progress 
note immediately preceding fence guarantees preceding writes issued cleanup routine reached global store 
event local store processor finish load fence precedes event executed global store store false cleanup progress 
values variables times refer values global store 
appropriate fence instructions ensure values needed claim fact propagated global store 
start state defined considering values local variables processor point order read cleanup progress return true final state considers point read cleanup progress return false 
definitions check cleanup progress load value cleanup progress global store 
process cleanup process 
fld refer field fld qnode element 
states process states proof correctness lock state waiting 
process queue queue read cleanup progress flag value read false indicating cleanup progress may executed swap 
live process leave state acquiring lock 
state owning 
process owns lock hold process executed swap value returned null process entered releasing state 
mynode locked owned global store process called release lock subsequently read value false cleanup progress reached assigns released mynode locked 
live process leaves owning state enters releasing state 
state releasing 
loosely mynode locked released process responsibility making process owner 
precisely process passed read cleanup progress having read value false occurred process set lock tail null global store 
process set process locked flag owned flushed value global store 
process cleanup progress true lock clean cnt cc 
state inactive 
state 
process isn owner running lock protocol code state 
process may running acquire release code certain cases state 
acquire attempt process loaded cleanup progress flag acquire code path lead returning failure considered inactive 
similarly release lock process modified shared information successful release lock considered inactive 
note releasing state corresponds process trying pass lock condition exiting state indicates cleanup process may steal ownership adjusting clean cnt lock 
note setting cleanup progress true effect preventing transitions part processes inactive waiting owning releasing 
proof correctness correctness conditions 

process inactive start state immediately start inactive dead final state immediately finish 

process waiting state start live finish waiting owning state 

process owning state time start stable dead owning state finish 
releasing process start state dead inactive final state 

cleanup routine sets lock tail null sets process locked flag owned process owning releasing state finish 
final state owner lock queue empty 

process seen dead cleanup process queue pointed waiting process field owner final state 

procedure cleanup terminates finite amount time 
proof claims 
lemma volatile wants members qnode modified process owns qnode 
variables cleanup progress clean cnt modified cleanup server 
proof immediate examination code 
lemma assignments volatile true wants null followed checks cleanup progress modifying shared data proof examination code 
lemma check cleanup progress followed code sets volatile false sleeps finish proof immediate examination code 
lemma assignments process fields qnode wants volatile field lock structure lock cleanup progress volatile true wants global store 
proof follows examination code acquiring releasing locks 
note assignment volatile true wants followed fence synchronization instruction modification queue data symmetrically fence synchronization instruction executed modification queue data setting volatile back false wants back null ensuring claim 
lemma process volatile false global store start modify queue structure lock tail locked field enter releasing state prior finish proof lemma guarantees modifications queue done volatile true wants lemma gives transition volatile false true wants null followed check cleanup progress lemma process executes check modify queue structure finish may process enter releasing state entry state defined reading value false cleanup progress happen start lemma process wants null global store start modify queue structure enter owning state prior finish proof definition process wants null inactive state 
inactive process execute swap enter state lemma follows directly lemma lemma 
lemma single process set volatile true wants local global store start finish proof follows lemma lemma 
lemma stable finish owning state viewwants 
proof viewwants constructed polling process checking wants variable points global store 
polling done start lemma ensures process included viewwants enter owning state lock viewwants superset processes may owner 
lemma stable finish locked field qnode field lock change local global store changed cleanup routine 
proof constructed polling process checking wants field points lock volatile flag true 
processes removed seen dead volatile set false 
stable defined point empty 
lemma ensures process wants volatile false point start modify queue 
corollary stable finish process may enter leave owning state changed cleanup routine 
proof ownership changes changing locked field qnode tail field lemma process owning state volatile false locked owned global store 
proof definition owning state observation point acquire attempt routine locked set owned fence executed volatile set false 
lemma process waiting state volatile false locked waiting global store 
proof definition waiting state observation point acquire attempt routine locked set waiting swap executed volatile set false 
locked flag changes owned definition process left waiting state 
lemma stable finish live process 
owning state iff cleanup process read locked owned 
waiting state iff viewwants cleanup process read locked waiting 
proof examination code definition stable lemma guarantees processes change state stable finish lemma cases process owning state locked owned global store volatile flag process true 
live process volatile true stable finish similarly waiting lemma 
note process assigns ownership assigning process volatile flag true transfer take place stable finish lemma live process releasing state stable finish proof lemma process volatile equal false global store enter releasing state stable finish alternative process volatile flag true remained releasing state having set volatile back false 
need show process set volatile false cleanup longer releasing state 
show considering point release lock code volatile set false 
null successfully swapped lock tail global store compare swap definition process longer releasing 
process locked flag set owned fence ensures value forced global store definition process longer releasing 
cleanup progress true claim states stable finish definition process releasing state 
lemma process releasing state observes cleanup progress true process subsequently reads cleanup progress false cc lock clean cnt 
proof follows fact process read cc volatile flag true 
cleanup code increments clean cnt stable live processes set volatile false 
due fence value global store process read cleanup progress false 
lemma finish processes seen dead cleanup server nodes queue new owner node queue 
proof follows removal dead processes viewwants 
check process dead process removed viewwants placed new queue 
note assuming processes seen dead cleanup process processes died cleanup check dead process trigger run cleanup routine 
lemmas give proof claims 

process inactive start state immediately start inactive dead final state immediately finish 
definition inactive examination code process inactive state pass read cleanup progress changing states 
start finish read return value true read global store definitions start finish state cleanup progress true global store 
lemma process sleep finish leave inactive state 

process waiting state start live finish waiting owning state 
consider process waiting start state live finish state 
lemma viewwants set locked flag waiting 
point see processes seen dead added queue demonstrating claim proved list node 
examination code ensures pre existing owner prepended list node list owner proving claim 

process owning state time start stable dead owning state finish definition owning state process check cleanup progress lemma process execute stores change state finish lemmas examination cleanup show process recognized owner cleanup routine left state 

releasing process start state dead inactive final state 
follows lemma guarantees live process releasing plus fact process releasing state moves inactive proof claim process entered state 

cleanup routine sets lock tail null sets process locked flag owned process owning releasing state finish lemmas guarantee live owner recognized 
examination code shows existing process assigned variable owner point process locked flag set owned lock tail set null 

final state owner lock queue empty 
follows examination cleanup code 
code process assigned owner tail lock set null 

process seen dead cleanup process queue pointed waiting process field owner final state 
claim follows lemma fact new owner node taken viewwants 

procedure cleanup terminates finite amount time 
lemma process set volatile true start finish cleanup progress set true process volatile set true straight line code waiting process set volatile false finite time termination axiom value propagated global store 
limited assumption progress section process die set volatile false time finite amount time case information reach global store subsequently process removed cleanup routine 
process removed finite amount time loop control condition empty true finite amount time 
compare swap compare swap release routine complicated somewhat case lock released node queue 
idea swap null lock 
returned value old tail points mynode done 
new processes added list test indicated node list swap 
rest new code attempts replace new nodes correctly queue 
done swap newly gathered list old tail contents lock 
lock may changed careful 
value returned second swap 
null attempted add list list entries old tail nodes need worry 
case list nodes indicated mynode lock 
null nodes added list 
node added saw null lock pointer immediately assumed lock 
pointer represents list patch list lost nodes mynode 
second swap swapped list lock queue done 
full explanation examples see 
code recoverable version release doesn compare swap appears 
code follows case compare swap closely 
note tests cc clean cnt mirror situation original release code 
pleasantly release algorithm require changing cleanup code acquisition code 
release lock lock lock qnode mynode qnode old tail mynode volatile true fence lock cleanup progress mynode volatile false lock cleanup progress sleep little return lock released try mynode locked released fence mynode null old tail swap lock tail null old tail mynode mynode volatile false mynode wants null return released swap lock tail old tail int cc lock clean cnt fence mynode volatile false mynode null cleanup progress cc lock clean cnt spin mynode volatile true fence lock cleanup progress cc lock clean cnt mynode volatile false mynode wants null lock cleanup progress sleep little return released null mynode locked owned mynode mynode locked owned mynode null fence mynode volatile false mynode wants null return released release compare swap 
chapter recoverable spin locks extensions implementation performance chapter presenting extensions recoverable spin lock algorithms chapters 
extensions sections deal non progressing processes allowing process hold multiple locks concurrently 
implementation issues addressed section including overview implementation simple recoverable lock dal main memory storage manager 
section compare performance recoverable lock algorithms non recoverable algorithms 
extensions cleaning lock simple spin lock chapter queueing spin lock chapter approach taken cleanup process wait certain set processes failed longer middle acquiring releasing lock 
simple spin lock case condition met wants pointer process longer points lock owner lock set lock case cleanup process waits volatile flag set back false 
algorithms construction acquire release protocols process loops waits process performing required action 
cleanup depends limited assumption progress part processes process suffer halting failure advance instructions 
conceivable process violate assumption progress system provided code die cleaned 
example process getting cpu time due operating system scheduling policies transferred user interrupt handler contained infinite loop attempt acquire lock case wait arbitrary amount time 
potential lack progress significant concern process time suffered halting failure progress may killed 
recall usefulness spin lock algorithms predicated rest application able deal halting failures artificial halting failure may preferable extended unavailability resource 
note need kill processes introduced recoverable lock algorithm factor cause process progress acquiring lock equally cause progress holding lock 
implement extension algorithm timer introduced cleanup algorithm 
timer set creation viewwants lock reset process removed viewwants 
timer duration tunable parameter reflecting acceptable duration resource loss application 
code introduced location owns cleanup expiration timer simply pick member viewwants kill process 
approach removes assumption progress claim processes eventually leave viewwants cost possibly killing process making progress spin lock acquisition code process may hold lock ensuring cleanup complete duration resource unavailable limited 
multiple concurrent locks fairly straightforward extend algorithms described handle multiple spin locks assuming process attempting acquire release spin lock time may hold 
simple spin locks implementation extends algorithm section replacing wants pointer array pointers 
lock pointed pointers owned acquired just released process locks owned 
acquiring lock process selects unused element array wants pointer algorithms section 
long process holds lock chosen element array points lock 
size array limits number spin locks held concurrently process 
complete handling multiple locks remains include element wants array process computation viewwants respective cleanup algorithms 
similar solution handling multiple locks applicable recoverable mcs lock 
case array qnode structures allocated process 
simple spin lock case acquiring lock process qnode wants pointer null 
determination viewwants section extended check qnode process wants points lock cleaned 
driver code interaction cleanup process started initialization shared memory system continues running processing place shared data 
periodically polls os determine process system died 
process died wants field pointing lock cleanup process uses owns cleanup depending type doubt lock restore lock available state 
section give sample driver code cleanup process recoverable lock algorithms address issues come allocation deallocation process specific information lock access records respectively 
example routines gives example driver code recoverable simple spin lock chapter 
main loop polls dead processes clean lock procedure clean lock lock null return stat pid stat held pid process owner process fence lock release lock return live return owner process fence lock release lock return return lock free clean lock cleanup simple main repeat forever foreach current process list dead clean lock wants deallocate sleep repeat cleanup main simple lock driver code cleanup mcs main repeat forever foreach current process list dead cleanup qnode wants deallocate qnode sleep repeat cleanup main lock driver code information returned owns clean failed processes 
recoverable mcs lock described chapter shows simpler routine required 
routine simple cleanup handles complexity deciding cleanup structures guarded lock 
correctness issues driver code implications correctness cleanup algorithms 
ensure lock structures affected halting failures cleaned 
issue addressed visiting lock wanted process dies separate run cleanup routine 
example run owns decides spin lock alive held process dead fact died immediately cleanup process called dead access record cleaned run cleanup routine 
similarly cleanup routine notices process dead deallocate lock related information process lock access record qnode process explicitly considered driver code 
ensures lock process time halted get cleaned case mcs lock ensures dead processes get removed queue multiple calls cleanup required 
issue release locks held dead processes owner field contains process 
case lock released required writes data structure failed process completed release takes place 
certainly case process termination acts fence 
situations example processor failure assumption may hold extra fence described section required 
implementation dal main memory storage manager recoverable variant simple spin lock algorithm implemented dal main memory storage manager successor storage manager developed bell labs see chapter 
section summarize implementation 
callback routine pointer associated lock initialized 
callback routine corresponds algorithms thesis pointer passed callback routine called allow cleanup routine access data structure lock guards 
callback routine may return values 
indicates data structure guarded lock successfully cleaned lock released 
second return value indicates possible clean guarded structure 
case system simulates system crash recovery discarding memory data structures including corrupted checkpoints disk logs recover 
additional subtlety arises may problem systems 
problem cleanup routine wait lock 
deadlock result process holding lock suffers halting failure 
problem may easy avoid service routines system acquire spin locks may easy determine calls result lock acquired 
considered overly restrictive require callback routines described acquire locks 
solve problems execution cleanup routine kept simple separate process known cleanup agent spawned handle tasks including calls user provided callback functions may require spin lock acquired 
possible processes system detect simulated crash suspend database recovered feature termed graceful crash handling 
simple spin lock recoverable simple spin lock mcs lock recoverable mcs lock lock fence sunos solaris semaphores acquire release second 
recoverable spin lock performance implemented recoverable algorithms simple spin lock original mcs locking algorithm sparc processor 
tested speed algorithms contention running mhz sparcstation 
fence sparc swap dummy memory location 
significant impact performance discuss 
performance results 
numbers represent acquire release pairs second 
tests indicate adding recoverability simple mcs lock algorithms sparc decreases performance factor respectively 
impact mcs lock relatively smaller due greater complexity original mcs lock algorithm 
resulting figures pairs second respective algorithms order magnitude better os semaphores 
number titled fence represents speed algorithm fence instructions implemented nop swap 
correct protocol indicate significant portion performance hit algorithm comes cost swap instructions 
recoverable protocol may significantly costly machine relatively inexpensive fence instruction 
previously published mcs timing results expect recoverable mcs algorithm far scalable high contention case simple recoverable spin lock chapter 
factors may excessive algorithms far faster alternative operating system semaphores space efficient software techniques see chapter 
chapter data corruption chapter begins discussion second major class failures thesis addresses corruption database data 
presenting definitions database corruption overview approach section 
describe techniques prevent detect physical database corruption codewords sections 
chapter recovery techniques aid removing corruption database 
chapter results study performance impact prevention detection algorithms normal transaction processing dal 
overview described data corruption may direct indirect logical physical 
direct physical corruption defined update memory image database data happen prescribed methods 
example standard disk system update internal buffer latch calls logging routines usually call constitute direct physical corruption 
described section updates dal bracketed calls physical corruption defined update interface 
applications direct access data direct physical corruption result application errors stray pointers application code 
dbms may source errors 
ng chen fault injection study postgres system faults injected dbms led corruption permanent data protection database 
comment relatively little code postgres interacts user data directly reasonable suppose risk damage applications share address space dbms large 
direct logical corruption includes update uses prescribed interface error 
examples direct logical corruption include accidental deletion customer updates account balances program computed interest incorrectly entry incorrect amount sales commission payroll computations 
direct corruption occurred corrupted data may read subsequent transaction 
transaction considered corrupt transaction writes data database data assumed corrupt 
note newly corrupted data may read transactions corruption propagated 
call corruption indirect corruption particular corruption 
forms indirect corruption example database processes dbms dependent assumed far common 
deal primarily transaction carried corruption thesis 
note corruption may negative defined absence data items 
example record deleted error indirect corruption may occur subsequent transaction reads data 
subtle form transaction carried corruption call phantom corruption 
data considered corrupt updated 
consider transaction intends add interest payment accounts corruption index causes account missed update routine 
scenario say data touched corrupted data touched corrupted 
define phantom corruption formally consider transaction read corrupted data 
database state transaction operated serialization order replaced clean state corruption occurred 
re execute transaction new state 
writes transaction differ original execution transaction result phantom corruption 
writes executions corrupting 
indirect corruption discussed detail chapter 
corruption control structures corruption occur database image transient database control structures lock information interfaces data typically uniform interface user data tuples index structures techniques described protect control structures entail significant individual implementation effort structure covered 
reason include protection control structures study 
protecting entire segment provide protection control structures 
aware segment level protection mechanisms unix platforms available mechanism available easily combined schemes protection persistent data studied thesis 
mechanism protection control structures cost approximately times protection data buffers cpu bound tests 
codewords detect corruption basic known idea codeword corruption detection follows 
data protected divided protection regions associated codeword 
updates prescribed interface update codeword region 
update prescribed interface occurs stored codeword updated 
high probability assuming codeword scheme compute codeword region match stored codeword 
section introduce non standard requirements codewords detecting corruption 
require effect update codeword summarized delta 
update consists old new values updated part protection region delta function location old new values updated area 
particular delta depend old codeword 
schemes delta stored redo log record require information delta small big codeword 
assume codeword update operation phi codeword region prior update old codeword update new new old phi delta 
may sequence updates region deltas applied order codeword 
assume update progress exclusive access updated data exclusive access ensured means region locks 
codeword change delta computed update exclusive access updated data 
require pair updates phi delta phi delta phi delta phi delta 
possible treat composed updates initial value updated area value zeros second zeros value holds delta gamma call undo value denote delta update zeros delta call redo value denotes delta update zeros phi delta phi delta gamma phi delta shall assume function omega combine delta gamma delta delta delta gamma omega delta codeword schemes satisfy requirements 
scheme parity encoding size codeword word 
parity code bitwise exclusive words region 
th bit codeword represents parity th bit word region 
case parity omega phi delta compute bitwise exclusive 
easy check parity code properties require 
particular delta update simply consists exclusive update update values words involved update 
delta requires word storage 
choices error detection codes example summation scheme codeword word wise summation data region modulo codeword scheme satisfying requirements 
focus choice best error detecting code integration code transaction processing system 
preventing direct physical corruption prevention physical corruption take place times time direct corruption bad write time attempt read corrupt data indirect corruption 
section hardware protection scheme takes approach read scheme takes second 
hardware protection direct physical corruption largely prevented virtual memory support provided operating systems 
basic approach un protect page access re protect 
un protection re protection done database code surrounds update example fixing page buffer pool 
update done outside routines page protected hardware mechanism cause program terminated 
database processes threaded un protected pages vulnerable threads hardware memory protection process resource 
turning protection expensive protect involves system call performance operation varies widely protect un protect pairs second ultrasparc pairs second hp see section 
read alternative preventing direct corruption data preventing corrupted data transaction 
accomplish consistency data protection region codeword checked read persistent data 
details scheme 
notes adapting disk recovery scheme follow section 
protection latch associated protection region acquired exclusively data updated reader needs check region codeword 
flag codeword applied stored undo log record physical update indicate change codeword applied 
flag allows transaction rollback functions dal bracket physical update see section 
actions taken normal transaction processing 
ffl update update protection latch region acquired undo image update noted undo log flag codeword applied undo log record set false 
ffl update update completed redo image recorded updated region undo image undo log record image determine change codeword 
codeword updated change flag codeword applied undo log record update set true 
protection latch released 
ffl undo update undo processing executes logical actions dal recovery algorithm generates redo log records updates just normal processing 
correspondingly codeword changed reflect update just forward processing 
undo processing encounters physical undo log record handled differently redo processing taken place represented flag codeword applied undo log record 
flag set true protection latch acquired codeword protection region modified back update 
flag false change codeword protection latch acquired held forward processing 
regardless value flag undo actions applying update generating log record undo executed 
protection latch released 
ffl read verify integrity data protection region reader acquires protection latch region computes codeword value region compares stored codeword region 
order prevent corruption reaching disk image performs integrity check reader 
reader finds region match codeword region steps taken described section recover data corruption 
read aries section describe read scheme need modified page architecture aries 
aries systems protection region may chosen page case page latch protection latch 
performance study indicates may lead acceptable performance may necessary associate multiple codewords page 
codewords codeword applied flag may stored page excluded codeword computations 
page propagated disk regions page checked described 
detecting direct physical corruption section describe data codeword data codeword deferred maintenance schemes detecting direct physical corruption 
data codeword detecting preventing direct physical corruption accomplished variant read scheme described section 
maintenance codewords accomplished manner check codeword read dropped favor periodic audits 
process auditing asynchronous check consistency contents protection region codeword region 
carried just read region place read scheme 
performed audits asynchronous sense significantly larger protection regions 
case protection latch may concurrency bottleneck 
new latch codeword latch may introduced guard update actual codewords protection latch need held shared mode 
audit protection latch taken exclusive mode obtain consistent image protection region associated codeword 
particular data audited propagation disk page steal page system 
corruption detection deferred maintenance alternate approach protecting data codewords data codeword deferred maintenance scheme designed reduce contention codeword table 
scheme stores codeword updates log records updates codewords log flush update data item 
need obtain page latches checkpointing codeword auditing page flushing interfere updates 
codeword updates done log flush system log latch prevents concurrent flushes serves serialize access codewords 
deferred maintenance scheme result increased throughput update transactions particularly main memory databases relative cost latching substantial 
due greater cost auditing protection region scheme compatible read 
scheme redo log record additional field redo delta stores delta change codeword caused update generated log record 
undo record codeword applied flag 
assume simplicity area covered redo log record span protection regions assumption easily ensured splitting log records span protection region boundaries 
actions normal processing actions taken various steps described 
provide context regular actions taken steps included 
note information added existing log records due corruption detection scheme log records mentioned part standard dal recovery algorithm see section 
ffl update add undo log record update local undo log transaction performed update set codeword applied undo log record false 
ffl update create redo log record update 
find corresponding undo log record 
compute delta undo image undo log new value updated area store redo delta field redo log record 
add redo log record update redo log set codeword applied undo log record true 
ffl undo update physical update undo log proxy redo log record generated redo image old value undo record 
codeword applied flag undo record true redo record generated delta delta gamma included proxy record reverse effect 
delta gamma computed current contents region undo log record stored redo delta proxy log record 
codeword applied flag false redo log record generated codeword delta applied flusher 
codeword changed changed just create proxy record usual store special value results change codeword redo delta 
case finish processing physical undo log record replacing image database undo image log 
note due repeating history physically executing logical undo action rollback causes physical updates codeword processing updates done normal updates 
ffl flush flushing physical redo log record flusher applies redo delta log record codeword page 
note system log latch held duration flush variable stable log updated reflect amount log known disk 
auditing logging scheme updater task simpler job auditor significantly difficult 
reads page partial updates may captured 
log information bring page update consistent state compared codeword value 
requires performing small scale version dal recovery algorithm checkpoint time 
avoid expense executing algorithm entire database introduce fuzzy 
idea simply compute codeword value page ignoring ongoing updates compare codeword value codeword table 
match assume page correct 
note introduces slightly increased risk missing error effect codeword set valid progress updates exactly complement effect codeword corrupt data region 
consider additional risk extremely small approximately probability error going undetected codeword place 
steps taken audit database 
page note value codeword table page 
compute codeword latches locks 
note value codeword table page second time 
computed value match noted value add page au needed 

note stable log au 

copy pages au needed side 

extract trailing physical undo log records affecting pages au needed process transactions active transaction table att 
call collection physical records au att 
records gathered different transactions independently latch entry ensure operations committed transaction gathering records log 

get flush latch execute flush cause codewords outstanding log records applied codeword table 
note new stable log au 
note codeword values pages au needed copy codeword table called au codewords 
release flush latch 

scan system log au au 
physical redo records apply pages au needed applied side copy pages 
undo corresponding physical redo au att removed 

remaining physical undo records au att applied checkpoint image 

compute codewords page au needed compare value au codewords 
differ report basic corruption occurred page 
flush step certain set updates page applied codeword table 
codewords pages au needed captured au codewords point 
purpose rest algorithm step ensure side copy page checked contains exactly updates 
prior updates may partially completely missing checkpoint image reapplied step 
dal redo log records immediately placed system log updates may taken place recorded various transactions local redo undo logs 
note codeword deltas updates reflected codeword table 
updates undone step leaving side image page consistent updates reflected codeword page au codewords long corruption occurred 
algorithm individual transactions blocked long gather outstanding physical undo records current operation 
chapter recovering data corruption chapter discuss schemes aid removal corruption database 
section give overview corruption recovery including mechanisms trace corruption 
section discuss models corruption recovery section schemes remove corruption models example tracking corruption physically deleting history transaction encountered corrupt data 
section techniques applicable source optimizing recovery logical corruption 
overview recovery models chapter vary widely complexity difficulty 
recovery direct physical corruption relatively simple recovery form indirect corruption complex 
scheme recover indirect corruption general comprised parts method tracing flow corruption method information context particular database management system remove corruption 
section introduce technique tracing flow corruption adding limited information reads database recovery log 
techniques required recovery logical corruption detection direct logical corruption definition impossible 
corruption recovery may recover effects indirect physical corruption 
accomplish possible trace physical dependencies level granularity example logical logging may possible map logical log records pages 
fault injection study performed ng chen study reliability non volatile buffer cache dbms addition hardware protection reduced incidence data corruption indicating significant risk exists physical corruption go undetected 
hardware protection scheme corruption may occurred time page unprotected 
errors may detected codeword schemes thesis area corrupted page specified part update prescribed interface called 
cases corruption may introduced prescribed routines case meet definition physical corruption 
errors codeword audit procedures able automatically detect corruption 
corruption form logical corruption audit mechanisms described asserts dbms available determine location lower bound time error recovery mechanisms described section aid subsequent recovery 
read logging order detect indirect physical logical corruption introduce idea limited read logging 
data item read identity item added transaction log 
determined audit means certain data corrupt read log records help determine subsequent transactions fact read corrupt data serving form audit trail 
shall see read log records combined rest log allow transaction log mechanism tracing flow indirect corruption database 
format read log records vary depending type logging done dbms type corruption intends trace 
information logged reads physical logical may optionally contain checksum information read 
logical read logging chosen read write locks may logged 
regardless approach writes preceded reads data may assume write region implicitly read significantly reduce number read log records required 
information reads logged physically physical start point length data read logged 
item read tuple index node persistent data structure required database consistency 
approach valid recovery method repeat history physically 
discussed chapter exactly approach logging taken dal 
logging lowest level negative corruption handled implicitly storage structure index node allocation table updated delete referenced subsequent search seen item 
optionally codeword data read written read log record 
event crash codeword detect physical corruption may occurred audit detected 
codeword detect exactly item physically corrupted 
example audit detects corrupted protection region assumed absence codeword read log record transaction reading region time previous successful audit read corrupted data 
codeword precise check 
information logged logically logical corruption traced possible map logical entity physical region page 
may possible especially physiological system slotted page architecture 
logging locks obvious technique implementing read logging logical level mechanism detecting conflicts reused detect corruption flow 
negative corruption caught lock mechanism detect phantom data scans reused 
example system uses predicate locks logged 
note write mode locks logged reads may occur write lock update necessarily take place 
alternative logging locks track logical corruption log checksum logical state data structure 
exactly dependent operation 
property satisfied operation executions log logical checksum high probability give logical result 
example index lookup log checksum index entries retrieved ignoring physical details location index 
note methods may log dependencies techniques chapter assume read logging may adapted methods 
example dependencies may traced entirely application level example additional audit tables 
set transactions limited transactions simple may possible determine identity transaction input parameters data may read 
logical corruption particular alternatives replace read logging 
remainder thesis assumed reads logged physically match physical write logging dal recovery algorithm 
generating checkpoints free corruption read logging supports recovery indirect corruption crucial disk image free direct corruption indirect corruption recovery require loading archive image 
propagating dirty pages memory disk sufficient audit pages written 
dirty pages direct physical corruption possible clean page direct corruption transaction carried corruption page written 
checkpoint data indirectly corrupted 
correct way ensuring checkpoint free corruption create checkpoint checkpoint written audit page database 
page database direct corruption indirect corruption occurred 
certify checkpoint free corruption 
technique directly applied page flushes disk system amounts auditing pages buffer cache write dirty page disk page steal time 
similar strategy followed set pages copied side audit pages performed writing database image disk 
ensure direct physical corruption escape undetected clean page discarded room new page audited 
correctness real world correspondence recovery models idea computation correct state produces correct state 
results errors removed transactions read corrupt data re run order get correct results 
reasonable model ignores fact major role database model external reality error recovery essentially method compensating error transaction see uses compensation 
known problem actions applies error recovery 
actions truly firing performing medical test may cases database external action compensated expense justified 
example stock purchased high shipping costs paid may better business perspective deal situation exists try achieve state existed error 
may important portions database continue model real world closely possible database function desired manner 
portions database constraints may need excluded automatic recovery application specific actions taken 
case physical corruption assume caught relatively quickly actions taken place 
case logical corruption may assume certain data manual intervention required apply recovery algorithm appropriate portions database 
directly address limits recovery algorithms fundamentally affect interaction recovery subsystem focus 
integrating algorithms error recovery framework deals data subject see chapter 
corruption spread prevention success corruption detection recovery dependent rate corruption spreads quickly detected 
physical corruption may detected quickly audit logical corruption may detected user auditor notices problem 
case success corruption recovery may depend greatly rate corruption spread easily quantified 
rate spread depends factors turn dependent details dbms implementation particular application database 
factor probability initial corrupt read take place time period 
second probability new transaction read data corrupted indirectly previous transactions 
probability initial corrupt read varies application workload internal dbms implementation techniques data directly corrupted 
certainly data database corrupt transaction follows example key pointer root node tree index 
similarly may data cause damage currently free space data cause little damage text description processing just display 
second factor probability new transaction read data corrupted depends frequency contact transactions depends application dbms implementation 
addition probability grow time data indirectly corrupted 
consider variants application updates customer information 
variant transaction updates global summaries total business done customers variant global statistics computed needed individual transactions touch customer 
clearly corruption propagate extremely quickly case slowly second 
possibility wide corruption spread may appear automatic algorithms recover corruption unworkable 
corruption spread entire database truly invalidated usefulness undoubtedly disaster techniques appear applicable corruption affected large portions database 
fact important read logging techniques determine disaster occurred 
consider case database administrator data entered incorrectly days ago suspects effects error spread widely 
limited extent corruption proven expensive recovery methods employed example need manually large portions database restore days old state 
tables ruled possibly corrupt set may greatly ease real life task dealing manually corruption 
interaction external systems thesis assume corruption carried transactions care taken algorithms ensure physical corruption carried obvious ways database processes 
database interact external systems may read database information submit subsequent transactions database fact dependent corruption 
example corruption may extra money available account causes user enter stock purchase transaction 
deal corruption carried users external systems thesis 
corruption impossible trace conservatively 
users talk users take computer point view arbitrary action corrupt data 
note may useful estimate flow corruption user framework algorithms limiting data item terminal follows 
data item 
user sees corrupt value supplier consider updates supplier corrupt 
assumes displayed information may communicated users influences updates data item 

user 
know bad data displayed particular particular user doubt updates user 
ignores people communicating 
note case longer possible trust original inputs transactions non corrupted assumption techniques 
may case user loop ignored cleaning corruption 
example customer may inventory levels placing order inventories levels incorrect may best ignore fact simply best effort fulfill order 
models recovery define models corruption recovery cache recovery model prior state model delete transaction model redo transaction model 
model cache recovery deals direct physical corruption 
models deal logical indirect physical corruption 
cache recovery model corruption removed cache pages assuming indirect corruption occurred consequently corrupt data values reflected log records 
prior state model goal return database transaction consistent state prior possible occurrence corruption 
commercial systems support model 
clearly recovery model leaves desired may impractical request users re submit done corruption 
corruption limited specific object table prior state recovery recreate error free copy object reintroduced date database 
procedure described retrieve objects deleted error oracle dbms 
extension prior state model direct error identified corrected transactions affected error logically re run history transactions re run serialization order original set transactions 
call redo transaction model corruption recovery 
redo transaction model recovering corruption model phantom corruption may detected comparing output re run transaction original 
data values written considered corrupt 
clearly automatic implementation redo transaction depends availability logical log transactions run input parameters 
log may difficult impossible collect applications especially transactions interact extensively users 
transaction level log unavailable automatic recovery model impossible 
final model delete transaction model assume logical information available allow redo corruption dealt deleting effects transactions database image 
transaction read corrupted data deleted history data transaction wrote reading corrupt data treated corrupted transaction 
implement recovery algorithm model clearly understood means delete transaction history 
possible interpretation allow serializable execution remaining transactions 
definition acceptable values read transactions values exposed outside world change modified history 
define correctness model consider transaction execution histories original history delete history history specified reads writes issued transaction 
reads writes certain transactions longer appear 
histories include values read written operation operation value read written corresponding operation delete history conflict consistent original history read preceded write preceded similarly view consistent read returns value returned correct recovery algorithm delete transaction model recovers note notions conflict view consistency distinct standard notions conflict view equivalence 
database delete history conflict view consistent original history 
note follows definition conflict consistent delete history final state data item written transaction delete set value written deleted transaction 
recovery algorithms consider utilize extend dal recovery algorithm implement models recovery discussed 
note algorithms recovery corruption tightly integrated restart recovery 
detecting error simply note region failing audit cause database crash 
corruption recovery handled part subsequent restart recovery 
cache recovery model algorithm useful recover direct corruption recovery indirect corruption required 
invoked fails read scheme audit detects codeword error data codeword scheme 
case indirect corruption prevented second assumed occurred 
auditing pages propagated disk ensure disk image free corruption repairing corrupted cache image accomplished applying standard recovery techniques region data corrupted 
technique described aries page latched process unexpectedly terminated 
dal similar technique reload latest checkpoint replay physical log records forward described section 
prior state recovery model prior state model recover form corruption source corruption determined recovery accomplished standard techniques 
case techniques similar media failure 
archive image database loaded log played forward latest point known prior corruption 
point reached log truncated restart recovery executed possibly generating additional log records 
redo transaction recovery model order recover corruption redo transaction model require logical redo log available transaction code necessary redo transactions 
particular logical log transaction level transaction external inputs example user saved 
assume transaction writes logical description commit record 
shall require commit order serialization order ensured requiring transactions hold locks multi level recovery schemes locks level gamma transaction 
recovery corruption recovery begins prior state model database recovered transaction consistent state known prior corruption 
tail log recovery saved log truncated see section 
scan forwards re execute transactions committed find commit record logical re execution information re execute transaction 
aborted transactions ignored 
logging done usual re execution 
re executed transactions read non corrupted data produce non corrupted results 
user notification depending nature corruption may helpful determine results exposed outside world corrupt 
accomplish transaction reports user log values output user 
re execution values checked values logged transaction re executes 
match user notified 
extension logical corruption algorithm easily extended recover logical corruption 
accomplished old log prior recovery order correct erroneous transaction transactions 
instance may fixed errors transaction code may correct user inputs place wrong user inputs 
may delete transaction replace transactions 
known direct logical corruption occurred techniques section aid making determination 
delete transaction model logical log available recovery may take place delete transaction model see section description model 
main idea scheme corruption removed database refusing recovery perform writes influenced corrupt data 
order transactions performed writes recovery appear aborted committed 
certain transactions may removed history refusing perform writes order ensure corrupt transactions effectively removed ensuring final history executed recovery algorithm consistent delete history obtained removing corrupt transactions original execution see section 
delete transaction model recovery algorithm need checkpoint update consistent addition free corruption 
dal checkpoint recovery necessarily update consistent recovery completed physical changes may partially reflected checkpoint image certain updates may earlier updates 
algorithm obtain update consistent checkpoint dal simplification audit procedure data codewords deferred maintenance scheme 
essentially auditing algorithm section modifications ffl checks codewords codewords noted flush latch held 
ffl dirty page table dpt au needed determine pages need consistent 
ffl point log denoted au auditing algorithm ck 
performed checkpoint update consistent point log ck 
recovery algorithm recovery start database image known non corrupt update consistent point log ck described 
note physical errors detected checkpointing auditing may know exactly error occurred error may propagated transactions detected 
algorithm conservatively assumes error occurred immediately audit lsn point log clean audit began 
tables maintained 
transaction said read corrupt data data noted read write log record transaction 
restart recovery consists redo phase followed undo phase 
redo phase checkpointed database loaded memory redo phase dal recovery algorithm initiated starting forward log scan ck 
forward scan steps taken log record types mentioned handled normal recovery ffl read write log record record indicates transaction read corrupted data transaction added may appear 
ffl log record physical write cases consider 
transaction generated log record case redo applied database image dal recovery algorithm 

transaction generated log record case data written inserted 
data updated 
ffl operation log record transaction checked operations undo logs transactions currently 
conflicts operations transaction added 
ensures earlier corrupt transaction rolled back 
conflict handled normal restart recovery algorithm 
ffl logical record commit operation commit transaction abort transaction record ignored transaction generated log record 
record handled normal restart recovery 
ffl audit lsn passed data noted corrupt audit added 
undo phase forward scan incomplete transactions rolled back 
normal dal algorithm undo incomplete transactions performed logically level level 
note redo phase transaction possibly empty undo log containing actions taken transaction read corrupted data 
undo phase portions corrupt transactions undone corrupt transactions progress time crash 
checkpoint extended restart recovery algorithm completed performing checkpoint ensure recovery crashes find clean database free corruption 
checkpoint performed recovery may rediscover corruption fact additionally declare transactions started recovery phase corrupted 
note checkpoint invalidates archives 
log may amended recovery avoid problem explore option 
discussion section database image algorithm reflect delete history consistent case conflict consistent original transaction history 
see informally case observe top level reads non deleted transactions read value history played recovery original history 
data possibly read different values previously placed top level reads implemented terms reads physical level corruption tracked 
second observation database image consistent contains original contents plus writes transactions appear delete set 
follows correctness original recovery algorithm fact initial portion corrupted transactions rolled back undo phase normal incomplete transactions produce consistent image 
ensured allow subsequent operations conflict operations 
extension codewords read log records codewords stored read log records detection indirect physical corruption precise 
particular dispensed definition reading corrupt data replaced definition transaction read corrupt data cases hold 
codeword stored read log record match computed codeword corresponding region database recovered 

codeword stored write log record indicating treated read followed write codeword match computed codeword corresponding region database 
second benefit storing codewords read log records case true system failure opposed caused failed audit possible detect physical corruption occurred audit crash 
precisely physically corrupt data detected transaction read recovery codeword transactions match database image recovered 
codewords corruption recovery algorithm executed error detected restart 
note modified algorithm produces recovery schedule original history propagating corruption corrupt transaction wrote data data item delete history 
benefits traded slight degradation performance see chapter details 
extension recovering logical corruption algorithm easily adapted recover logical corruption 
corruption may occurred checkpoint archive image taken prior error restored ck point recovery starts taken archive 
audit lsn defined latest point log corruption known occurred point 
point known techniques section help locate 
point audit lsn passed recovery data directly affected corrupting error added 
logical corruption approaches recovering logical corruption context redo transaction delete transaction models 
section discuss issues involved determining logical corruption introduced outline efficient variant redo transaction recovery scheme restricted recovery model 
backward analysis may useful determine probable source corruption set data items 
algorithm aid task 
idea trace backward log tracking corruption flowed data items 
assumption single transaction caused corrupt data reasonable assumption errors rare 
assume data items known corrupt 
set data suspected corrupt 
associate data item set integers range 
prior algorithms termination know data item fact corrupt 
indicates known corrupt data affected corruption corrupted 
similarly set suspect transactions set associated semantics analagous follows assuming corrupt possible explain corruption known corrupt item 
corruption explained due existence chain events corruption flowed 
read corrupt data source direct corruption 
initialized known corrupt items items initialized singleton set fig 
process log backwards acting log record cases ffl log record write data item transaction add set equal 
ffl log record read data item add set 
step contains elements offer user possible root cause 
accepted done continue 
algorithm assumes single instance direct corruption resulted known corrupt data items continues single transaction explain known corrupt data 
may show user possible solutions involving multiple data items 
triggered example processing certain amount log finding single transaction solution 
optimizing recovery redo transaction model unfortunately redo transaction model corruption recovery logical transaction may take time similar original execution error discovered days reasonably expected take days recover database 
time database unavailable 
outline alternative approach implementing redo transaction model assumes level recovery model logical physiological redo logging 
record level operations logged record level locks held duration transaction latches held pages duration operation 
goal algorithm primarily log recovery re executing select transactions 
algorithm may model recovery algorithm logical read logging described section 
transaction said read corrupted data ffl reads data table 
ffl logical codeword computed operation recovery match codeword recorded log 
addition actions normally taken recovery corruption recovery algorithm proceeds processing records follows ffl log records transaction saved commit abort record transaction seen 
ffl commit log record transaction encountered read log records transaction scanned determine transaction read corrupted data 
transaction marked corrupt 
transaction marked corrupt re executed logically new logical redo records replace redo records log 
data original transaction wrote written re execution added 
transaction marked corrupt log records executed 
ffl abort record transaction log records transaction discarded 
redo records logical record level locks held transaction executing log records point commit record appears correct 
note transaction re executed generate different log records 
fact operations performs may completely different ones originally performed 
transactions executed commit point new transaction serialize respect transactions originally executed concurrently 
read data written transaction serialized actions cause new conflicts transactions serialize transactions read corrupt data re executed 
chapter performance corruption protection goal performance study compare relative cost different levels protection example detection versus prevention comparing different techniques obtaining level protection 
case interested impact scheme normal processing opposed time taken recovery 
corruption recovery expected relatively rare time required highly dependent application workload 
algorithms studied implemented storage manager storage manager developed bell labs dal main memory storage manager 
performance mprotect describing comparison schemes looking relative performance memory protection primitives commonly available unix hardware 
table evaluate basic performance memory protection primitive number hardware platforms locally available 
case pages protected unprotected repeated times 
numbers reported average number pairs operations accomplished second 
limited sample indicates variability performance mprotect hp twice integer performance sparcstation specint hp opposed sun gives fourth performance sparcstation performing mprotect operations 
database performance netlib org 
possible compare numbers machines specint numbers available newer systems 
platform pairs sec sparcstation ultrasparc hp sgi challenge dm table performance protect implementing read logging computation codeword values reads takes place contexts part codeword computing codeword stored read log record 
general implementation difficulty traded window potentially undetected corruption 
minimize window undetected corruption codeword computation read occurred 
computation read direct corruption take place window computation codeword read 
case read performed write read codeword read checked write potentially cause transaction carried corruption read scheme designed prevent 
precisely write allowed visible transaction possible undo write physically logical undo corrupt read trusted 
example page system approach perform read page fix ed shared mode leaves window computation read undetected corruption occur 
alternatively occur time introducing possibility write issued fix ed data takes place case provision physically undo write error detected time 
read logging read log record appear log subsequent writes recovery algorithms consider subsequent writes suspect 
case simpler codeword fix time 
eliminate window checking codeword data explicit call perform check inserted reads writes possibly exposed transaction 
example pages fixed read mode duration complicated action analysis code required add additional calls 
implementation page assumed write read codeword checked calls 
added calls reads persistent data part write 
case codeword included read log record codewords added write log record added read log record 
calls read part write added portions code performance tests including allocation code relation manager index structure hash table 
workload workload examined single process executing tpc style transactions 
database consists tables branch teller account history bytes record 
database contained accounts tellers branches 
ratios record types changed specified tpc order increase size smaller tables limit effects cpu caching tables 
benchmarks run ultrasparc mhz processors gigabyte memory 
tables memory run logging checkpointing ensuring recoverability 
run operations done operation consists updating non key balance fields account teller branch adding record history table 
non page architecture dal transaction updated average pages 
pages involved free list management allocating history record involved setting null information tuple 
tuples updated expect page system require number mprotect pairs 
point revisited 
transactions committed size ops sec slower table domain sizes operations commit times dominate 
test run times results averaged 
results reported terms number operations completed second 
protection domain size presenting general results discuss tradeoff implementation read algorithm 
read algorithm verifies read computing codeword regions read intersects 
codeword stored protection domain size region leads time space tradeoff scheme 
performance read data codeword maintenance variety sizes protection domains bytes page size machine 
small size protection domains scheme performs may add space usage database 
scheme breaks hardware protection protection domains 
results shown table 
results table representative selection algorithms discussed thesis shown average number operations second algorithm achieved tests relative slowdown algorithm compared baseline alternative design highly concurrent test group commits introducing great deal complexity variability test 
corruption algorithm direct indirect ops sec slower baseline data cw def 
correct data cw correct data cw byte correct prevent data cw def 
correct correct data cw def 
cw correct correct data cw byte correct prevent memory protection prevent unneeded data cw byte correct prevent table cost corruption protection algorithm just system running corruption protection 
experiments show detection direct corruption achieved cheaply cost simple deferred maintenance data codeword protection 
small domain size economical cost depending acceptability space overhead 
read logging lowers space overhead raises cost significant may worthwhile automatic support repairing database employed results erroneous transactions logical corruption tracked 
logging checksum data read increases accuracy corruption recovery algorithms adds cost bringing 
memory protection standard mprotect call costs double performance hit codeword protection read logging 
large domain sizes fares poorly 
monitoring number mprotect calls hardware scheme determined average operations updated pages 
tuples touched operation extra page updates arise updates allocation information control information residing page tuple 
number may significantly smaller page system improve performance hardware protection read relative detection schemes 
factor improvement realized variability performance mprotect described section erase gain systems 
results form codeword protection implemented dbms application code direct access database data 
detection direct corruption quite cheap limited far better allowing corruption remain undetected database 
levels protection may implemented offered users may safety performance tradeoff 
chapter directions motivated needs main memory storage manager application processes direct access database data concurrency control handled spin locks shared memory thesis examined fault resilience techniques environment 
part thesis addressed effect process halting failures spin lock acquisition release 
chapter recoverable variant simple spin lock developed techniques extended highly scalable queue spin lock chapter 
recoverable variants times slower original algorithms order magnitude faster operating system semaphores far space efficient software mutual exclusion algorithms 
recoverable simple spin lock implemented part dal main memory storage manager currently lucent technologies internal product named dal 
applicable software fault tolerant shared memory application 
second part thesis addressed corruption data due unintended updates 
originally motivated physical corruption due pointers memory overruns shared memory environment dal resulting techniques application tracing recovering logical corruption due incorrect user input errors transaction programs serious problems dbms 
codeword techniques detection physical corruption chapter including deferred maintenance technique uses database log prevent concurrency bottlenecks codewords 
chapter read logging techniques introduced allow effects logical physical corruption traced subsequent transactions may read corrupt data 
logs automatically recover corruption delete transaction logical redo models corruption recovery 
chapter techniques corruption prevention detection shown perform significantly better hardware prevention unintended updates non page database environment dal 
furthermore codeword schemes depend simple integer operations expect easily portable perform consistently platforms scale speed integer performance new machines hardware protection may slower certain systems expensive system calls 
recovery mechanisms designed remove effects corruption database techniques determining source logical corruption chapter 
expect approach recoverability spin locks applied hardware spin locks may fault resilient environment 
may possible formalize process transforming non recoverable lock recoverable lock 
continuing press forward improving techniques tracing recovering logical corruption variety ways 
extent system envision follows outline davies post process recovery user participates interactively define recovery process 
case required database reflects real world state recovery logical corruption respect correspondence 
handle unrecoverable actions possible classify database items reflect real world action 
may done schema definition time cases may specified interactively user recovery 
problem users read corrupted data enter new transactions error 
errors flow external systems users may approached treating systems users pseudo data items corrupt data set 
user interaction may required corruption appears spread widely 
may important ignore spread corruption certain updates 
example may known small errors global statistics may meaningfully affect users application statistics may corrected tracing corruption transactions read statistics 
may require user interaction 
recovery approach removing localized logical corruption may impractical corruption days old potential time processing log may days 
recovery action create proposed compensation normal transaction processing continues 
locks acquired prevent corruption equivalent establishing new recovery sphere control terminology 
user allowed modify proposed compensation described leading iterative application algorithms trace correct corruption 
compensation approved user applied locks released 
abiteboul vianu 
transactions integrity constraints 
acm sigact sigmod symp 
principles database systems march 
agrawal gehani 
ode object database environment language data model 
proc 
acm sigmod int conference management data may 
agrawal gehani 
ode object database environment language data model 
pages portland oregon may 
aho hopcroft ullman 
design analysis computer algorithms 
addison wesley 
anderson 
performance spin lock alternatives shared memory multiprocessors 
ieee transactions parallel distributed systems january 
batory barnett smith wise 
genesis extensible database management system 
zdonik maier editors readings object oriented database systems 
morgan kaufman 
batory thomas 
lightweight dbms generator 
technical report tr dept computer science university texas austin june 
bershad anderson lazowska levy 
lightweight remote procedure call 
acm transactions computer systems february 
bershad redell ellis 
fast mutual exclusion uniprocessors 
procs 
international 
conf 
architectural support programming languages operating systems pages october 
bershad savage pardyak gun sirer fiuczynski becker chambers eggers 
extensibility safety performance spin operating system 
proceedings fifteenth acm symposium operating system principles pages copper mountain resort colorado december 
jr generalized audit trail requirements concepts data base applications 
ibm systems journal 
bohannon parker rastogi seshadri silberschatz sudarshan 
distributed multi level recovery main memory databases 
proceedings int conference parallel distributed information systems december 
bohannon rastogi seshadri silberschatz sudarshan 
architecture dali main memory storage manager 
journal multimedia tools applications march 
carey dewitt graefe richardson schuh shekita 
exodus extensible dbms project overview 
zdonik maier editors readings object oriented databases 

carey dewitt richardson shekita 
storage management objects exodus 
kim lochovsky editors object oriented concepts databases 
addison wesley 
chapin rosenblum devine lahiri gupta 
hive fault containment shared memory multiprocessors 
proc 
th acm symp 
operating systems principles sosp pages december 
chase levy lazowska baker harvey 
lightweight shared objects bit operating system 
procs 
object oriented programming languages systems applications conference oopsla pages 
chomicki 
real time integrity constraints 
acm sigact sigmod symp 
principles database systems san diego june 
digital equipment 
alpha architecture handbook 
davies jr data processing spheres control 
ibm systems journal 
delgrande 
formal bounds automatic generation maintenance integrity constraints 
acm sigact sigmod symp 
principles database systems san diego march 

personal communication 

survey synchronization methods parallel computers 
ieee computer july 
dubois briggs 
memory access buffering multiprocessors 
proceedings international symposium computer architectures pages june 
eisenberg mcguire 
comments dijkstra concurrent programming control problem 
communications acm november 
fagin nievergelt pippenger strong 
extendible hashing fast access method dynamic files 
ibm res rj july 
fisher lynch paterson 
impossibility distributed consensus faulty process 
journal acm april 
garcia molina salem 
main memory database systems overview 
ieee transactions knowledge data engineering december 
godfrey mayr seshadri von eicken 
secure portable database extensibility 
proc 
acm sigmod int conference management data seattle wa june 
lehman 
locking latching memory resident database system 
proc 
int conf 
large databases pages august 
gottlieb 
overview nyu project 
technical report note new york university july 
graunke 
synchronization algorithms shared memory multiprocessors 
ieee computer june 
gray 
census tandem system availability 
ieee trans 
system reliability october 
gray reuter 
transaction processing concepts techniques 
morgan kaufmann san mateo california 
gupta cheng gupta breuer 
objectoriented vlsi cad framework 
computer pages may 
haas chang lohman lapis lindsay pirahesh carey shekita 
starburst mid flight dust clears 
ieee transactions knowledge data engineering march 
reuter 
principles transaction oriented database recovery 
acm computing surveys december 
hennessy patterson 
computer architecture quantitative approach nd ed 
morgan kaufmann 
herlihy 
impossibility universality results wait free synchronization 
technical report cmu tr cs may 
herlihy :10.1.1.38.1642
methodology implementing highly concurrent data structures 
acm sigplan symp 
principles practice parallel programming march 
jagadish rastogi silberschatz sudarshan 
dali high performance main memory storage manager 
proc 
int conf 
large databases 
khanna 
realtime scheduling sunos 
winter usenix conference 
korth levy silberschatz 
formal approach recovery compensating transactions 
th international conference large data bases pages august 
rusinkiewicz cichocki sheth thomas 
bounding effects compensation relaxed multi level serializability 
distributed parallel databases october 

principles error detection storage structures database systems 
reliability engineering 
lamb landis orenstein weinreb 
objectstore database system 
cacm october 
lamport 
multiprocessor computer correctly executes multiprocess programs 
ieee trans 
computers september 
lehman carey 
study index structures main memory database management systems 
proc 
int conf 
large databases pages august 
november 
personal communication 
lomet 
mlr recovery method multi level systems 
proc 
int conference management data pages 

oracle dba handbook 
osborne mcgraw hill 
maier 
making database systems fast cad applications 
technical report oregon grad ctr tr cse december 
mellor crummey scott 
algorithms scalable synchronization shared memory multiprocessors 
acm transactions computer systems february 
mohan lindsay pirahesh schwarz 
aries transaction recovery method supporting fine granularity locking partial rollbacks write ahead logging 
acm transactions database systems march 
mohan levine 
aries im efficient high concurrency index management method write ahead logging 
proc 
acm sigmod int conference management data june 
mohan 
recovery coherency control protocols fast page transfer fine granularity locking shared disks transaction environment 
proceedings seventeenth international conference large databases barcelona pages september 
ramamritham 
recovery protocols shared memory database systems 
proc 
sigmod pages may 
morgan taylor 
survey methods achieving reliable software 
ieee computer february 
ng chen 
integrating reliable memory databases 
procs 
international conf 
large databases pages august 
ousterhout 
aren operating systems getting faster fast hardware 
usenix summer conference proceedings pages 
plotkin 
sticky bits universality 
proceedings eigth annual acm symp 
principles computing pages 
randell 
system structure software fault tolerance 
ieee computer february 
rowe stonebraker 
postgres data model 
proc 
th int conf 
large data bases pages september 
salem garcia molina 
system transaction processing testbed memory resident data 
ieee transactions knowledge data engineering march 
satyanarayanan kumar steere kistler 
lightweight recoverable virtual memory 
proceedings acm sigops 
shekita :10.1.1.106.4431
cricket mapped persistent object store 
proc 
persistent object systems workshop martha vineyard ma september 

replication supporting fault tolerant object databases 
proceedings acm sigmod international conference management data pages may 
silberschatz 
operating system concepts 
addison wesley fourth edition 

formal specification memory models 
technical report csl xerox december 
singhal kakkad wilson 
texas efficient portable persistent store 
proc 
fifth int 
workshop persistent object systems september 
sparc international sparc architecture manual version 
stonebraker rowe 
design postgres 
proc 
acm sigmod int conf 
management data may 
stonebraker rowe eds 
postgres papers 
technical report ucb elec res lab memo rev jun november 
sullivan 
system support software fault tolerance highly available database management systems 
phd thesis university california berkeley january 
sullivan stonebraker 
write protected data structures improve software fault tolerance highly available database management systems 
procs 
international conf 
large databases pages 
tanenbaum 
operating systems design implementation 
prentice hall second edition january 
taylor black 
principles data structure error correction 
ieee transactions computers july 
taylor morgan black 
redundancy data structures improving software fault tolerance 
ieee transactions software engineering november 
taylor morgan black 
redundancy data structures theoretical results 
ieee transactions software engineering november 
turek 
computation presence slow downs 
technical report new york university ph thesis august 
turek shasha prakash 
locking blocking making lock concurrent data structure algorithms nonblocking 
proc 
acm sigact sigmod sigart symposium principles database systems june 
wahbe lucco anderson graham 
efficient software fault isolation 
proceedings fourteenth acm symposium operating system principles pages asheville north carolina december 
white dewitt 
high performance mapped object store 
proc 
acm sigmod int conference management data 
yen 
systematic incorporation efficient fault tolerance systems cooperating parallel programs 
int symposium fault tolerant computing pages june 
young tevanian rashid golub chew bolosky black baron 
duality memory communication implementation multiprocessor operating system 
proc 
eleventh symposium operating system principles pages december 
vita philip lewis bohannon attended birmingham southern college birmingham alabama 
computer science 
birmingham southern college 
programmer tom mcleod software birmingham alabama 
graduate computer science rutgers state university new jersey new brunswick new jersey 
teaching assistant department computer science 
contractor bell laboratories murray hill new jersey 
bohannon sudarshan recoverable user level mutual exclusion proceedings th ieee symposium parallel distributed processing 
bohannon silberschatz recovering scalable spin locks proceedings th ieee symposium parallel distributed processing 
member technical staff research bell laboratories new jersey 
bohannon parker rastogi seshadri silberschatz sudarshan distributed multi level recovery main memory databases proceedings international conference parallel distributed information systems 
bohannon rastogi seshadri silberschatz sudarshan architecture dali main memory storage manager multimedia tools applications 
rastogi seshadri bohannon silberschatz sudarshan logical physical versioning main memory databases proceedings rd international conference large databases 
rastogi bohannon parker seshadri silberschatz sudarshan distributed multi level recovery main memory databases distributed parallel databases 
ph computer science 
