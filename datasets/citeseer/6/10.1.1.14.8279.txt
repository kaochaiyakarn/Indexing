mining specifications glenn ammons dept computer sciences university wisconsin madison wisconsin usa ammons cs wisc edu dept computer sciences university wisconsin madison wisconsin usa bodik cs wisc edu james larus microsoft research microsoft way redmond washington usa larus microsoft com program verification promising approach improving program quality search possible program executions specific errors 
need formally describe correct behavior errors major barrier widespread adoption program verification programmers historically reluctant write formal specifications 
automating process formulating specifications remove barrier program verification enhance practicality 
describes specification mining machine learning approach discovering formal specifications protocols code obey interacting application program interface data type 
starting assumption working program debugged reveal strong hints correct protocols tool infers specification observing program execution concisely summarizing frequent interaction patterns state machines capture temporal data dependences 
state machines examined programmer refine specification identify errors utilized automatic verification tools find bugs 
preliminary experience mining tool promising 
able learn specifications captured correct protocol discovered serious bugs 

difficult imagine software bugs 
richness variety errors require equally diverse set techniques avoid detect correct 
testing currently detection method choice 
high cost inherent limitations testing lead renewed interest approaches finding bugs 
promising directions tools systematically detect important classes errors :10.1.1.134.9305
program verification tools prevent programming errors quickly cheaply identify early development process error corrected programmer familiar code 
testing verification tools provide strong assurances program free certain type error 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl jan portland usa copyright acm isbn 
tools general statically compute approximation program possible dynamic behaviors compare specification correct behavior 
specifications easy develop language specific properties avoiding null dereferences staying array bounds 
language properties difficult express check potentially apply program written language investment verification tool amortized easily 
hand specifications particular program say abstractions datatypes may difficult expensive develop complexity mechanisms limited number people understand 
specifications may apply program benefits correspondingly reduced 
program verification widely cheaper easier ways formulate specifications 
explores approach automating process producing specifications 
technique called specification mining discovers temporal data dependence relationships program follows interacts application programming interface api datatype adt 
specification miner observes interactions running program uses empirical data infer general rule programs interact api adt 
rules concisely summarized state machines capture temporal data dependences 
state machines examined programmer refine specification identify errors utilized automatic verification tools find bugs 
mining proceeds assumption executing program presumably passed tests generally uses api adt correctly miner identify common behavior produce correct specification programs contain errors 
start program text feasible infeasible paths intermixed correct paths indistinguishable mining begins traces program run time interaction api adt 
traces limited feasible paths general contain errors 
program illustrates points 
program uses server side socket api 
generally observes correct protocol create new socket call socket prepare accept connections calling bind listen call accept connection service connection call close destroy unfortunately program buggy return statement line executed closed 
program buggy individual interaction traces correct 
shows trace 
cond rarely true difficult invent test force program behave badly 
hand correct traces enable miner int socket af inet sock stream 
bind serv addr sizeof serv addr 
listen 
int ns accept addr len ns read ns buffer 
write ns buffer size cond return cond close ns close example program socket api 
socket domain type proto return bind addr addr len return listen backlog return accept addr addr len return read fd buf len return write fd buf len return read fd buf len return write fd buf len return close fd return accept addr addr len return read fd buf len return write fd buf len return close fd return close fd return part input mining process trace execution program 
infer specification correct protocol 
verification tool uses specification examine program paths find rare bug 
specification mining system composed parts tracer flow dependence annotator scenario extractor automaton learner 
tracer instruments programs trace record interactions api adt compute usual results 
implemented tracers 
replacement stdio library requires recompiling programs 
general executable editing tool allows arbitrary tracing code inserted call sites 
tracers produce traces standard form rest process independent tracing technology 
flow dependence annotation step refining traces interaction scenarios fed learner 
connects interaction produces value interactions consume value 
scenario extractor uses dependences extract interaction scenarios small sets dependent read fd write fd close fd socket return bind listen accept return close fd output mining process specification automaton socket protocol 
interactions puts scenarios standard form 
automaton learner composed parts shelf probablistic finite state automaton pfsa learner postprocessor called 
pfsa learner analyzes scenario strings generates pfsa small generate scenarios 
pfsa nondeterministic finite automaton nfa edge labelled interaction weighted edge traversed generating accepting scenario strings 
rarely edges correspond infrequent behavior removes 
discards weights leaving nfa 
human validate nfa inspection point nfa specification program verification 
shows specification socket protocol program 
contributions introduce new approach called specifications mining learning formal correctness specifications 
specification portion program verification dependent primarily people automating step improve appeal verification help improve software quality 
observation common behavior correct behavior refine specifications mining problem problem probabilistic learning execution traces 
develop demonstrate practical technique probabilistic learning execution traces 
technique reduces specification mining problem learning regular languages shelf learners exist 
rest organized follows 
section develops test inputs run flow dependence annotator instrumented program annotated traces scenario extractor scenarios scenario seeds automaton learner specification tracer program traces overview specification mining system 
formal statement specification mining problem 
section discusses tracers flow dependence annotator 
section describes scenario extractor automaton learner 
section presents dynamic checker mined specifications 
section discusses results experiments mining tool checker 
section discusses related section concludes 

problem section develops formal statement specification mining problem 
ambitious specification mining attempts solve unsolvable problem problem 
set traces interactions api adt set correct traces interactions api adt 
unlabelled training set interaction traces find automaton generates exactly traces called specification 
algorithm finds called specification miner 
rest section examines successive restrictions problem lead problem attacked methods 
simplifications choosen accomodate techniques specification mining problem certainly possible 
problem solved places restrictions set recursively enumerable exist 
require generated finitestate automaton regular language 
decision forced practical considerations 
model checkers require finite state specifications 
second algorithms learning finite state automata relatively developed 
simply say regular traces programs regular 
example consider program linkedlist takes number command line constructs linked list size allocating nodes unlabelled training set mean information provided elements malloc destroys linked list deallocating nodes free allocated freed order 
ignoring finite arithmetic traces form regular language 
regular language defined finite alphabet linkedlist unbounded number distinct malloc free calls 
second linkedlist number malloc calls followed equal number free calls canonical non regular language 
linkedlist traces form regular language traces contain 
trace object mentioned trace consider subtrace trace containing calls malloc return calls free passed subtrace simply malloc call followed free call 
trace mentions objects subtrace object 
subtrace exactly particular object allocates frees 
replace object subtrace standard name say std identical learner strong hint free follow malloc 
call renamed interaction scenarios 
approach simplifies problem ways 
learner learn directly traces 
preprocessor extracts interaction scenarios traces 
scenarios manipulate data objects linkedlist example 
second set cs correct scenarios required regular 
simplified specification mining problem defined problem 
set interaction scenarios api adt manipulate data objects 
cs regular set correct scenarios 
unlabelled training set ts interaction scenarios find finite state automaton generates exactly scenarios cs problem impossible solve 
careful reader may noticed training set ts depend cs matter cs subset valid training set 
obviously conditions basis choose ss definition problem allowed training sets chosen liberally order allow noisy training sets contain bad examples bugs cs satisfactory definition noise wait problem simplified 
simplify problem assuming training set fact infinite sequence scenarios cs element cs occurs problem 
set interaction scenarios api adt manipulate data objects 
cs regular set correct scenarios 
ts 
infinite sequence elements cs element cs occurs 
examine elements ts produce finite state automaton asn sequence finite state automata 
property asn generates exactly scenarios cs asn asn say sequence 
identifies cs limit 
surprisingly problem undecidable 
definition problem inspired mark gold seminal language identification limit gold shows regular languages identified limit theorem 
proof long repeat idea proof members infinite regular language learner way learner forced change guess infinitely cycling sequence finite sublanguages infinite language 
intuitively learner dilemma finite sequence examples infinite language sequence examples finite language learner basis preferring 
cs possibly infinite regular language gold theorem applies problem 
gold learning regular languages examples 
subsequent avoids dilemma exploited gold proof providing learner extra information allows justify choosing general automaton general vice versa 
class approaches presents learner examples generated probability distribution sort approach particularly interesting gives learner method dealing noise input 
task learner learn close approximation probability distribution set interaction scenarios api adt manipulate data objects 
probability distributions say approximation measure distance just problem restricted cs regular set restricted manageable class distributions 
choose distributions generated probabilistic finite state automata pfsa probabilistic analogue nondeterministic finite state automaton 
pfsa tuple qs qf output alphabet 
set states 
qs start state automaton 
final state automaton 
probability function giving probability transitioning outputting symbol 
note qf 
pfsa generates distribution assigns positive probabilities strings regular language 
basing definition standard definition learning probabilistic finite automata give final formulation specification mining problem problem 
set interaction scenarios api adt manipulate data objects 
target pfsa distribution generates 
intuitively assigns high probabilities correct traces low probabilities incorrect traces 
confidence parameter approximation parameter efficiently find probability pfsa distribution approximation efficiently means mining algorithm run time polynomial upper bound number states size alphabet int instrumented socket int domain int type int proto int rc socket domain type proto fprintf trace fp socket domain type proto return domain type proto rc return rc illustration trace instrumentation instrumented version socket 
unfortunately reasonable distance metrics shown problem efficiently learnable 
efficient solution case required acyclic deterministic 
interesting specifications program behavior contain loops chose greedy pfsa learning algorithm guaranteed find approximation practice generates succinct specifications 

tracing flow dependence annotation section describes tracing flow dependence annotation produce input scenario extractor 
tracing tracer instruments program running produces trace interactions api adt usual results 
assumes tracer records function calls returns depending api adt mining system allows tracing events variable accesses network messages 
shows illustration trace instrumentation specifically code instrumented version socket call 
wrapper calls real socket records information interaction name call socket arguments return value 
entire socket api traced instrumented version function 
system currently uses tracers 
instruments stdio library capturing library calls macro invocations api 
second consists parts perl scripts automatically generate instrumented versions function calls api tool edits program executables replace calls routines calls instrumented versions 
tool eel executable editing library general 
takes input executable library instrumented functions file specifying calls executable replace calls instrumented functions 
time consuming part tracing interface writing instrumented version api call believe step easily automated 
tracers record interactions format rest mining system independent particular tracer 
interaction skeleton form interaction attribute 
attribute interaction names interaction name function attribute names ith attribute interaction 
skeletons just convenient way grouping interactions 
appear traces 
interaction instantiates skeleton assigning values attributes interaction attribute 
attribute vn tracing function calls interaction attributes usually represent function arguments return values 
structured data represented flattening structures 
example code struct int int void tracer record interactions instances skeleton convention names traces letter interactions variations letter actual interactions trace length numbered example 
tn notation denotes attribute interaction traces dependence analysis type inference untyped trace dependences flow dependence annotator annotated traces detailed view flow dependence annotator 
flow dependence annotation flow dependence annotation annotates input trace flow dependences type assignments 
scenario extractor uses annotations extract scenarios small sets dependent interactions trace put scenario canonical form 
detailed view shows flow dependence annotation step process 
dependence analysis marks trace flow dependences constrain interactions may reordered identify related interactions grouped scenario automaton learner 
type inference assigns type interaction attribute trace 
scenario extractor uses types avoid naming conflicts puts scenario standard form 
dependence analysis type inference examine entirety input trace running time nearly linear 
miner treats values objects underlying representation unknown 
interactions depend results interactions 
example bind call line depends socket call line bind call uses file descriptor returned socket call 
order interactions reversed 
contrast interactions manipulate file descriptor lines exchanged interactions manipulate file descriptor lines groups operations independent 
importantly scenario contains interactions related close line include interactions lines 
socket return bind listen accept return close fd users bind listen accept read fd write fd close fd attributes socket interactions define values 
flow dependences connect attributes change state object attributes define object interaction attributes depend state object attributes object 
ideally dependence analyzer annotate trace flow dependences information trace 
current system relies expert tell analyzer attributes interactions may define objects attributes may objects 
done api adt 
extending system infer sets users automatically 
simplicity examples assume socket valued attributes interactions carry dependences 
lists attributes interactions define socket values 
constructed table follows 
socket kernel maintains hidden data structure 
fields structure carry state socket socket closed open accept connections 
fields simply hold data bytes outstanding port socket connected 
typically modify state fields data structure 
users typically read fields 
fields structure merely hold data ignored 
creating required expert knowledge 
note state fields socket data structure change set api calls may follow changes 
example socket closed read write calls longer allowed 
fact close changes state socket inferred trace close reads writes close reads writes 
interactions change state change sorts interactions may follow 
hope replace expert automatic tool uses fact infer sets users 
lists attributes define objects dependence analysis dynamic version reaching definitions problem 
analyzer traverses trace 
tn order tn maintaining table maps values attributes actual interactions 
initially empty 
defines object annotator updates map uses object maps analyzer places flow dependence running time algorithm scales linearly length trace 
space required scales linearly number different values referenced trace 
notational convenience introduce relation flow dependence relation extended interaction attributes interactions natural way df holds type socket return type bind type listen type accept type accept return type read fd type write fd type close fd valid typing skeleton attributes trace 

type inference step flow dependence annotator 
type inference assigns type skeleton attribute involved dependences 
value flows instance skeleton attribute instance skeleton attribute type inference assigns skeleton attributes separate types 
strictly speaking flow dependences give scenario extractor information extract scenarios put standard form 
section explains scenario extractor assurance values flow certain attributes scenario reduce naming conflicts 
type inference infers typing satisfies condition df typing gives skeleton attribute skeleton attribute type 
gives typing skeleton attributes socket trace 
example skeleton attribute type socket attributes trace dependence chain instance close fd attribute 
inference algorithm uses tarjan union find algorithm requires time nearly linear trace 
type starts initial typing gives skeleton attribute unique type 
visits dependence unifies types skeleton attribute skeleton attribute type inference complete dependences visited 

scenario extraction automaton learning section explains scenario extractor automaton learner 
tool extracts interaction scenarios small sets interdependent interactions annotated traces prepares automaton learner 
second tool infers specifications scenarios complete traces reasons 
primary reason scenarios shorter traces running time pfsa learner increases third power length input typical automaton learners 
restrict scenarios refer small number objects bounding size scenario 
section argues bounding number objects specification mining tractable 
bounding number objects severe limitation verification tools verify specification holds multiple bindings program objects specification objects 
example protocol specified mentions objects tool attempts verify program bind instance ns simulates loop lines 
scenario extractor simplifies scenarios passing automaton learner specification mining system uses shelf pfsa learner 
alternative tried design special purpose learner scenarios 
schemes benefits costs 
shelf learners learn similar automata strings 
design transforms scenarios strings new learner substituted learner currently 
new learner learns changes mining system necessary 
learner learn may need changed components automaton learner require modification 
experience flexible design helpful 
settling pfsa learner tried rejected pfsa learner 
hand special purpose learner defer decisions mining system invoking shelf learner 
example scenario extractor replaces concrete values scenario names regard names values scenarios 
extractor names equivalent scenarios exact way see details scenarios close equivalent extractor choice names prevent pfsa learner merging states able merge different naming 
scenario extraction extraction standardization simplification scenario extractor scenarios simplified scenarios annotated traces scenario seeds scenario strings detailed view scenario extractor 
detailed view scenario extractor 
receives inputs 
set traces annotated described section 
addition user controls scenarios extracted supplying set scenario seeds 
seed interaction skeleton 
extractor searches input traces interactions match seeds extracts scenario interaction 
example suppose extractor trace socket interactions accept return seed 
extractor produce scenarios accept line accept line 
extraction producing scenarios input traces step extraction process 
informally scenario set interactions related flow dependences 
formally annotated trace socket domain type proto return bind addr addr len return listen backlog return accept addr addr len return seed read fd buf len return write fd buf len return read fd buf len return write fd buf len return close fd return scenario extracted line 
tn scenario set 
tn property 
chain flow dependent interactions extractor builds scenario interaction trace matches scenario seed 
scenario seed interaction initially matches seed 
user tunable parameter restricts number interactions extracted scenarios 
scenario contains ancestors descendants seed interaction 
extractor prefers ancestors descendants position input trace close position seed interaction 
interaction ts matching seed extractor uses step algorithm produce scenario 
extractor constructs sets sa closest ancestors ts sd closest descendants ts ad ts sa sd extractor uses simple prioritized worklist algorithm construct set ancestors descendants 
initial worklist set immediate ancestors descendants ts repeatedly worklist empty ancestors descendants extractor removes worklist ancestor descendant position trace nearest ts adds set ancestors descendants adds immediate ancestors descendants worklist 
result ad necessarily scenario interactions flow dependence chains ancestors ts descendants ts missing 
interactions lie trace earliest ancestor ta ad latest descendant ad reachable flow dependences ancestor ts flow dependences reverse descendant ts extractor searches depth forwards element sa backwards element sd construct socket return bind listen accept return seed read fd write fd read fd write fd close fd simplification scenario 
socket return bind listen accept return seed read fd read fd write fd write fd close fd scenario string simplified scenario 
sar sa reaches dr sd final scenario sad sar dr 
shows scenario extracted trace accept line 
seed marked 
note interactions inherit dependences annotated trace 
simplification extracted scenarios simplification eliminates interaction attributes carry flow dependence training traces 
typing inferred dependence annotator see section assigns type skeleton attribute instance attribute involved flow dependence trace 
simplification preserves interaction attribute corresponding skeleton attribute typed 
simplified version scenario 
standardization standardization converts scenario scenario string pfsa learner 
standardization improves performance pfsa learner producing scenario strings similar scenarios receive similar strings 
shows result standardizing scenario 
standardization applies transformations naming reordering 
naming replaces attribute values symbolic variables 
value replaced symbolic name value replaced symbolic name 
naming exposes similarities different scenarios naming flow dependences 
example scenario extracted line manipulates different socket values naming calls values 
value flows attribute naming indicates dependence assigning name attributes 
dependence annotation typing section guarantees skeleton attributes assigned different types values flow instances attributes 
naming uses separate namespace attributes type 
illus original seed seed untyped typed nearly equivalent scenarios scenario strings untyped typed naming 
equivalent scenarios simplified scenarios scenario strings standardization standardization mapping 
separate namespaces help expose similarities pfsa learner 
lines line differs scenario 
assume naming assigns names interaction turn starting seed interaction 
types naming treats lines differently 
reordering order scenario interactions 
scenario contains interactions partially ordered flow anti output dependences 
scenario corresponds directed acyclic graph dag 
order interactions appear original traces just legal total order 
reordering puts scenarios dag total order trace order differs pfsa learner fewer distinct strings 
reordering swapped write line read line 
pfsa learner interaction scenario string merely atomic letter 
emphasize point right hand side replaces interaction shorthand letter 
standardization uses small number letters represent set scenarios 
small alphabet increases pfsa learner opportunities find similarities scenario strings 
pfsa learners run slowly large alphabets 
rest section discusses standardization algorithm detail 
high level standardization mapping simplified scenarios scenario strings 
mapping preimage scenario string set equivalent scenarios 
intuitively equivalent scenarios manipulate objects way 
define equivalence standardization algorithm show equivalence characterizes scenarios standardization maps scenario string 

sn simplified scenario 
permutation permutation 
permutation equivalent scenarios 
naive maxsize maximum size scenario totally ordered set maxsize symbolic names permutes dependence preserving permutations foreach permutes dependence preserving foreach add return lexicographically smallest element naive standardization algorithm 
swap source sink dependence 
illustrates dependence preserving permutation swaps read line write line 
naming replaces value symbolic name taken set attribute symbolic name attribute 
say dependence preserving 


simplified scenarios 
equivalent iff dependence preserving permutations dependence preserving 
fact choice important 
assert equivalent dependence preserving dependence preserving dependence preserving 
presents naive standardization algorithm 
naive tries dependence preserving permutations dependence preserving permutation returns scenario string comes lexicographic order 
naive assigns scenario string equivalent algorithm permutations equal 
equivalent naive generates set 
equivalence characterizes preimage naive promised 
running time algorithm exponential 
algorithm removes exponential behavior considering standard naming permuted scenario 
optimization safe equivalent dependence preserving naming differ values depend identities values attributes types dependences carry 
draws names separate name spaces separate types 
operation returns foreach attribute type type skeleton attribute value value namespace name space type namespace value set namespace value namespace replace value namespace value 
sn index seed dist dist dist dist dist dist dist dist dist better reset name spaces permutes dependence preserving permutations foreach permutes named add named return lexicographically smallest element better standardization algorithm 
available name name space fixed order resetting name space causes name space 
names seed interaction works outward 
name value chosen consistently constraints naming increase interactions named 
interactions near seeds similar scenarios named 
worst case running time better exponential 
expect better worst case better solve dag isomorphism problem encoding arbitrary dags scenarios dag isomorphism np complete 
better performance possible common case trace scenarios arbitrary dags 
particular interactions scenario names named attributes 
final standardization algorithm uses names reduce number permutations considers 
standardize considers dependence preserving permutations put skeletons interactions smallest possible lexicographic order 
exponential number orderings 
case set interactions selected line element recursion branches 
appropriate implementation sorts interactions algorithm runs case time proportional log experience time spent running standardize insignificant part scenario extraction time 
automaton learning section presents algorithms data structures learning specification automaton 
automaton nfa edges labelled standardized interactions language includes common substrings scenario strings extracted training traces plus strings pfsa learner adds generalizes 
automaton learning steps 
shelf learner learns pfsa 
removes infrequently traversed edges converts pfsa return skeleton precedes skeleton lexicographically pos permutes ready selected ready foreach selected rest pos foreach rest pos permutes permutes return permutes standardize reset name spaces permutes foreach permutes named add named return lexicographically smallest element final standardization algorithm 
final start pfsa dropping edges low weights identify hot core 
edge labels omitted 
nfa 
pfsa learner shelf learner learns pfsa accepts training strings plus strings 
learner variation classic tails algorithm 
briefly tails algorithm works follows 
retrieval tree constructed input strings 
algorithm computes strings length strings generated state trie 
states qa generate strings merged 
process repeats merges possible 
pfsa learner modifies tails comparing states generate strings 
resulting pfsa accepts superset strings training scenarios due generalizations performed learner 
parameter controls size extracted chosen user large include interesting behavior 
ends training scenarios contain uninteresting behavior 
fact see experimentally typical pfsa hot core transitions occur frequently core surrounded cold region transitions occurs infrequently 
away cold region leaving just hot core 
simply drop edges low weights 
consider pfsa edge labels important omit satisfying scenario strings language simplified scenarios satisfying simplification concrete scenarios satisfying standardization scenarios satisfy ted 
edges weight low compared edges weight 
string pfsa traverse edge start state edge state 
despite low weight string traverse edges traverse edges weight 
better measure edge heat likelihood traversed generating string pfsa 
problem computing measure known markov chain problem 
problem reduces inverting square matrix number rows columns equal number transitions pfsa 
computing heat edge removes edges cutoff parameter removes unreachable states pfsa drops frequencies edges 
result nfa human validate inspection 

verification section discusses verification tools miner specifications 
program verification tools distinguish programs satisfy specification programs 
discuss tools clarify mean satisfying specification 
specification 
construction language contains set scenario strings 
containment strict automaton learner introduce strings scenario strings 
standardization mapping see scenario string corresponds set simplified scenarios 
turn scenario string corresponds set concrete scenarios 
shows chain mappings 
say scenarios satisfy interaction trace 
say satisfies seed interaction interaction scenario seeded satisfies say program satisfies specification interaction trace execution satisfies constructing program verification tools specifications outside scope subject ongoing research 
ways tool 
tool construct scenario satisfies interaction seed encountered simulating abstraction reporting error scenario constructed seed 
alternatively tool translate automaton generates traces scenario strings 
trace automaton generates traces satisfy verification tool exhaustively search trace reporting error 
sorts tools able simulate simplification standardization 
shows trace verification algorithm program verification algorithm works way 
algorithm experiments see section 
verify takes trace specification maximum scenario size 
attempts verify trace satisfies specification extracting suc satisfies spec language spec return true return false verify 
spec maxsize loop foreach size size maxsize scenarios extract size foreach scenarios std standardize satisfies std spec loop size size return fails trace verification algorithm 
larger scenarios finds satisfactory reaches maximum scenario size 
interactions trace necessarily ordered training traces algorithm exactly extraction algorithm learner 
extract size returns scenarios seeded total exactly size ancestors descendants 
distance seed ancestors descendants important 

experimental results section presents results experiment mining specifications traces programs 
analyzed traces programs xlib toolkit intrinsics libraries windowing system 
traces record interaction library call callback library client code 
interaction attributes include arguments return values calls plus fields structures represent protocol events 
tracing tool uses executable editing library eel instrument solaris sparc executables 
traces collected full runs widely distributed programs selection mechanism 
studied selection mechanism communication conventions manual gives english descriptions rules behaved programs mechanism 
experiment concentrated rule specifies programs obtain ownership selection rule says client calling pass timestamp derived event triggered call 
table lists program studied origin distribution contrib directory number static calls library routines chosen seeds number training scenarios extracted trace 
authors gathered traces running program minutes trying exercise selection code doing cut paste operations exercising functionality possible short time 
specification mining depends sizable training set traces 
case number training traces small turned contained violations rule 
result miner able discover rule trained programs 
order learn rule needed remove buggy traces training set 
hypothesized miner help find bugs poor training name source static seeds scenarios bitmap distrib distrib distrib distrib xterm distrib clipboard contrib contrib display contrib contrib contrib contrib contrib contrib ted contrib test canvas contrib ups contrib contrib table client programs studied experiment 
set 
identifying buggy traces miner require inspecting trace manually bugs 
miner predicted inspect traces correct traces collected miner rule automatically validate remaining traces 
experiment arranged client programs random order went iterative process run program gather trace mine specification trace expert examines specification expert extracts hot core specification correct select random order start remaining client program order run program gather trace verify trace specification verification succeeds add trace training set generate new specification examine scenarios failed scenario violates rule add trace training set generate new general specification report bug trace fails verify expert marks buggy includes training set 
expert decides initial specification correct experiment accepted initial specification see obvious bugs set training scenarios 
expert needs extract hot core training set small 
experiment tested hypotheses hypothesis process find bugs reduce number traces expert inspect 
hypothesis miner final specification match rule 
hypothesis human agree states final pfsa belong final specification 
name verifies 
reason failure action accept bitmap spec 
narrow accept ups bug 
reject ted spec 
narrow accept accept xterm spec 
narrow accept display spec 
narrow accept spec 
narrow accept accept accept accept benign violation reject spec 
narrow accept bug 
reject benign violation reject clipboard benign violation reject table results processing client program order processed 
table lists client programs order processed 
traces accepted including initial trace rejected overly narrow specification 
point specification stabilize accepted initially rejected dynamic verifier 
expert inspect traces supports second part hypothesis 
conjecture process continued false rejection rate continued drop 
programs violated rule 
programs benign violations specification programs bugs 
specification applies programs selection mechanism cut paste programs benign violations selection mechanism implement communication protocol 
violations indicate rule described universally applicable document clarified 
specification miner helped find bugs documentation omission unexpected benefit 
specification experiment 
legibility sake omits arguments 
arguments participate dependences core specification 
specification compact states edges 
matches english rule closely complexity arising ways api receives event 
addition specification exposes common pattern client calls repeatedly indicates call successful 
final hypothesis expert agree states final pfsa thrown 
final pfsa states 
expert access results threw retained remaining twelve merged form nfa 
expert disagreed states 
assigned likelihoods lower deleted states likelihoods higher retained states 
deleted states likelihoods remaining retained states likelihoods 

related ernst proposed automatic deduction formal specifications 
daikon tool works learning invariants involving program variables dynamic traces 
resulting time time time time time time time time time time start nfa selection ownership specification 
formal specifications key difference approach 
daikon specifications arithmetic relationships hold specific program points precondition entry procedure 
contrast specifications express temporal data dependence relationships calls api 
temporal specifications capture different aspect program behavior daikon predicates values structures 
forms specifications complementary naturally require radically different learning algorithms 
ernst techniques suppressing parts learned specifications useful programmer 
context temporal specifications result corresponds appropriately selecting heavy core initial pfsa 
related tool houdini annotation assistant esc java 
starting initial guessed candidate set annotations similar daikon houdini uses esc java refute invalid annotations 
focus houdini annotating points single program true properties focus tool discovering temporal properties hold programs interface 
authors described tools extract automaton models 
cook wolf describe tool fa models software development processes traces events 
differs extract specifications program traces reduced simpler form palatable fa learner 
ghosh describe techniques learning typical behavior programs system calls 
intend models intrusion detection models need characterize particular program behavior miner finds rules generally applicable understandable humans 
wagner dean intrusion detection system extracts automaton models source code traces 
system extracts models apply single program 
reiss extract structure traces model sequence operations individual objects data temporal dependences objects 

addresses important problem tool chain problem semi automatic formulation correctness specifications accepted model checkers similar tools 
formulated problem machine learning problem provided algorithm reduction finite automaton learning 
experimental remains ahead initial experience promising 
anand raman peter jon patrick allowing pfsa learner anonymous referees helpful comments early draft 
supported part national science foundation ccr ccr university wisconsin graduate school donations ibm microsoft research 

thomas ball majumdar todd millstein sriram rajamani 
automatic predicate abstraction programs 
proceedings acm sigplan conference programming language design implementation volume acm sigplan notices pages july 
thomas ball sriram rajamani 
automatically validating temporal safety properties interfaces 
proceedings th international spin workshop model checking software number lecture notes computer science pages may 
thomas ball sriram rajamani 
bebop path sensitive interprocedural dataflow engine 
proceedings acm sigplan workshop program analysis software tools engineering acm sigplan notices pages july 
biermann feldman 
synthesis finite state machines samples behaviour 
ieee transactions computers 
william bush jonathan pincus david 
static analyzer finding dynamic programming errors 
software practice experience 
andy chou yang benjamin chelf seth hallem dawson engler 
empirical study operating systems errors 
proceedings th acm symposium operating systems principles sosp pages october 
douglas comer david stevens 
internetworking tcp ip 
client server programming applications bsd socket version 
prentice hall englewood cliffs nj usa 
jonathan cook alexander wolf 
discovering models software processes event data 
acm transactions software engineering methodology july 
robert deline manuel fahndrich 
enforcing high level protocols low level software 
proceedings sigplan conference programming language design implementation pldi pages june 
dawson engler david yu chen seth hallem andy chou benjamin chelf 
bugs deviant behavior general approach inferring errors system code 
proceedings th acm symposium operating systems principles sosp pages october 
michael ernst jake cockrell william griswold david notkin 
dynamically discovering program invariants support program evolution 
ieee transactions software engineering february 
flanagan leino 
houdini annotation assistant esc java 
international symposium fme formal methods increasing software productivity lncs volume 
ghosh christoph michael michael 
real time intrusion detection system learning program behavior 
raid volume lecture notes computer science pages 
mark gold 
language identification limit 
information control 
michel michel minoux 
graphs algorithms 
john wiley sons 
michael kearns mansour dana ron rubinfeld robert schapire linda sellie 
learnability discrete distributions 
proceedings sixth acm symposium theory computing pages 
james larus eric schnarr 
eel machine independent executable editing 
proceedings sigplan conference programming language design implementation pldi pages june 
christoph michael ghosh 
finite automata mine execution data intrusion detection preliminary report 
raid volume lecture notes computer science pages 
william griswold michael ernst adam david notkin 
quickly detecting relevant program invariants 
proceedings nd international conference software engineering june 
kevin murphy 
passively learning finite automata 
technical report santa fe institute 
anand raman peter jon patrick 
beam search algorithm pfsa inference 
pattern analysis applications 
anand raman jon patrick 
sk strings method inferring pfsa 
proceedings workshop automata induction grammatical inference language acquisition th international conference machine learning icml 
reiss 
encoding program executions 
proceedings rd international conference software icse pages los alamitos california may 
ieee computer society 
dana ron yoram singer naftali tishby 
learnability usage acyclic probabilistic finite automata 
proceedings th annual conference computational learning theory pages 
acm press new york ny 
david rosenthal 
inter client communication conventions manual version 
consortium sun microsystems 
part distribution 
robert endre tarjan 
efficiency linear set union algorithm 
journal acm 
david wagner drew dean 
intrusion detection static analysis 
proceedings ieee symposium security privacy may 
