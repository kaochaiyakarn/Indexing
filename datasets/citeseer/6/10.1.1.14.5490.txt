software practice experience vol 
august compiled instruction set simulation christopher mills stanley jim fowler department electrical engineering ohio state university neil avenue columbus oh summary efficient method simulating instruction sets described 
method allows compiled instruction set simulation macro expansion capabilities languages 
additionally show semantics case statement allows instruction branching incorporated efficient manner 
method compared conventional interpreted techniques shown offer considerable performance benefits 
key words interpreters simulation emulation instruction set design number reasons instruction set simulation important steps development efficient computer architecture 
simulation requires exact specifications instructions developed 
secondly compiler available instruction set real programs tested architecture 
means compiler debugged hardware constructed simplifying debugging portion system 
thirdly profiling instruction frequency allows instruction set designer determine effectiveness individual instructions 
example risc architectures emphasize inclusion frequently operations instruction set 
fourthly extensive simulations synthetic real programs computer architect gain insight expected performance implemented architecture 
careful matching compiler computer architecture yield particularly elegant computing system 
instruction set simulation established technique 
classical descriptions simulation methods discussed gries 
may described efforts build fast efficient simulators grouping source instructions translating unit 
excellent overview dasgupta discusses various simulation techniques 
unfortunately regardless simulation technique simulating architecture time consuming 
simulators instruction interpreters operate register transfer level 
simulator usually written hardware description language hdl standard language simple benchmark takes minute run computer may take hours simulate 
best reduces number received september john wiley sons revised march mills fowler size programs designer test may result architecture running benchmarks actual programs 
worst tested architecture architectural errors discovered design phase 
designer advantage simulator operate efficiently possible 
discusses simple method reduce execution time instruction set simulators greatly 
method introduced significant utility interpreted simulation techniques alternative strengths particularly detailed analysis data instruction path utilization 
interpreted simulation instruction set simulation normally done 
program stored simulator memory way simulated computer 
simulator program repeatedly fetches instructions memory opcode select routine execute simulate effects opcode maintain statistics instruction frequency execution time example suppose investigating frequency instructions stack machine 
instructions add top stack accumulator command represented symbolically ac ac sp sp sp pc pc simulate code switch pc case add freq add ac sp break simulator fetch add instruction program counter pc increment branch appropriate case 
pop top stack add accumulator increment counter keeps track number times add executed 
compiled simulation simulating computer architecture similar implementing programming language 
programming language assembly language simulated computer represent theoretical machines mapped real hardware 
approaches mapping interpretation compilation 
compilation distinct efficiency advantages interpretation interpreter spends majority time fetching decoding operations compiled simulator spends time performing computation 
interpreted programming language overhead interpretation steps reasonably small individual instructions interpreted perform lot compiled instruction set simulation instruction set simulation interpretation steps consume time spent simulate instruction 
course relative cost interpretation opposed computation depends complexity instruction addressing modes typically simulators interpretation techniques execute instructions interpreted instruction 
macros compiler languages provides excellent wellknown facility compiling simulated assembly language host machine language line macro expansion 
experimenter needs create macro instruction emulated code assembly language function 
previous example add defined define add freq add ac sp add line preprocessor expand statements turn compiled directly machine language host machine 
machine register ac declared register variable result usually mapping simulated assembly language host machine language instruction simulation instruction instruction frequency accounting 
example sun compiler add generates instructions freq addl problem approach branching 
labels goto statements accomplish simple branching indirect jumps including return subroutine instructions directly implemented goto 
luckily switch statement implement branching 
macro case label address instruction simulated program enclosed switch statement program counter 
branch instruction encountered macro sets program counter destination branch break transferring control back enclosing switch statement branches correct instruction 
case statement acts label break statement flow control fall case statement simulated instruction 
means instructions cause branch occur modify program counter break switch statement 
operations simply fall case 
program counter advanced simply reloaded branch occurs 
allows zero overhead non branching instructions 
define add baz branch accumulator zero instructions define add case freq add ac sp define baz case freq baz ac pc break true switch pc mills fowler add baz means add opcode address baz instruction branches back add 
switch construct usually compiled compiler efficient jump table overhead branch overhead indexed indirect jump 
switch construct added benefit trapping illegal instruction 
ill formed branch jump middle instruction data area corresponding case label address 
note case labels need correspond actual instruction addresses 
long value program counter case label branch function 
possible construct assembler take advantage feature just output arbitrary integers label encounters 
labels numerical order place restrictions ordering case labels 
addressing modes flags complex addressing modes flags problems 
instructions possible addressing modes best set macros calculate effective address set macros implement operations 
likewise architecture cpu flags set arithmetic operations group flag setting macros created 
implementing addressing modes separating macros define address modes instruction operations results instruction definitions shorter clearer 
example suppose architecture addressing modes direct indirect instructions add add accumulator direct ac ac add accumulator indexed ac ac add accumulator ac ac compiled instruction set simulation load accumulator direct ac load accumulator direct ac load immediate index register displacement absolute address immediate value 
implement instructions macros define operations add load define add op define ld op addressing modes direct indexed define direct mem define mem instructions implementing flags define add da case freq add add op ac direct define case freq add op ac define case freq add op ac define da case freq ld op ac direct define case freq ld op ac define case freq ld op consider architecture status register significant bit zero flag 
zero flag set arithmetic operation yields zero result 
define status register zero flag unsigned long int status define zero define macros test set clear flag status register define flag status define status define status macros implementation instruction set macros 
example redefine add instruction zero flag set result zero baz branch zero instruction take advantage zero flag mills fowler define add case freq add ac sp ac zero zero define baz case freq baz flag zero pc break flag macros similar fashion 
flags defined large programs considerations general compilers limit size switch statements 
limit albeit limitation compiler restriction length simulation code placed switch construct vary compilers 
example cc gcc compilers sun workstations investigated determine switch size limitations 
programs compile switch construct similar indexed indirect jumps jump tables 
correct compilation switch object code generated body switch statement exceed range indexed indirect jump 
limit switch limit number case statements switch contain restriction size code generated case statements 
compilers tested sun maximum size compiled switch statement approximately bytes 
compiler handles programs exceeding byte limit differently 
cc compiler generates error assembly compiled code 
hand gcc compiler generates errors compilation assembly object code produces segmentation fault error executed 
fortunately compiled simulation technique adapted handle larger programs simulation code switch statements 
specifically code similar true switch pc start program pc switch pc add switch pc pc compiled instruction set simulation sub halt ab simulation code broken blocks exceed switch size limit 
pc incremented instruction necessary switch block set pc address instruction switch 
verified branches properly switch statements enclosed loop 
multiple switches sacrificed ability trap illegal instruction longer default statement switch blocks 
default prevent branching switch block 
noted partitioning program switch statements introduces sequential search switch blocks execution branch instruction 
cost search increase program size remain insignificant relation execution instructions 
problems encountered compiled simulation technique describe 
example complex source instructions generate code easily optimized particular compiler 
interpretive simulators problem better compilers yield faster code case 
related concern code generated compiled simulator may adversely affect cache virtual memory performance host machine minimizing speed advantages technique 
due fact code generated technique largely consists jump tables execution instructions simulated may distributed fairly large address space 
interpretive simulators problem 
general principle locality hold programs written compiled technique interpreted technique 
simulating large programs compilation time compiled simulator significant may outweigh savings execution time 
large compiled simulation program expected executed times interpreted simulation may efficient process considers cost compilation compiled simulator 
program needs run times increased execution speed compiled simulator probably offset time cost compilation 
examples results complete example discuss performance characteristics simple cpu fibonacci benchmark unsigned main unsigned value fib mills fowler value fib return value unsigned fib unsigned return fib fib return processor emulate registers accumulator program counter stack pointer frame pointer currently executing procedure 
implement subset processor instructions macros need instructions code benchmark 
complete program listed appendix broken logical segments macro definitions instruction set execute function contains assembly code fibonacci benchmark main program calls execute prints execution statistics 
execute function macro definitions kept separate files simplify changes benchmark instruction set 
example program output appendix ii 
determine effects compiled simulation program compared nearly identical version interpreted simulation 
addition configurations tested determine performance technique realistic fashion 
cache implemented function call external independent process communicated pipe 
accounting code kept track frequency instruction 
results simulations shown table importantly seen table compiled simulator nearly times faster interpreted simulator 
note savings execution time outweigh additional cost compilation time compiled simulator 
note incorporation cache functional piped table program time relative speed native code compiled accounting compiled cache interpreted cache compiled functional cache compiled piped cache compilation time approximately compiled instruction set simulation system obvious cost execution time practical system cache simulation pivotal part proposed architecture simulated 
interpreted simulators slowed caching incorporated 
include cache timing show functionally implemented cache incurs significantly cost associated drawbacks discussed 
performance statistics cache hits misses gathered having macro pass address current instruction parameter macro function performs cache mechanism writing address standard output read separate cache program sending output file post simulation analysis 
shown approach functionally implemented cache advantage speed second approach piped cache advantage generality cache program simulator distinct cache size increased recompiling simulator instruction set modified changing cache 
final approach benchmark incur overhead file require additional program executed generate statistics cache performance 
compiled simulation clearly superior interpreted simulation especially architecture simulated easily described sequence statements 
advantages efficiency portability elegance 
programming languages preprocessor peculiarities switch statement particularly suited 
macro assembler better job translating certain architectures ones flags significant loss portability 
compiled approach drawback conceptually model processor internal actions interpreted approach 
level abstraction probably need completely different simulator event driven 
consequently compiled instruction simulators best efficient instruction set prototyping tools 




cad tools design crisp ieee design test june pp 

patterson reduced instruction set computers communications acm 
birnbaum jr risc high precision architecture ieee compcon 

pp 

crisp instruction set architecture ieee compcon pp 

survey risc processors computers mid ieee computer september pp 

tanenbaum stevenson van staveren description experimental machine architecture block structured languages informatica rapport vrije university amsterdam january 
wirth microprocessor architectures comparison code generation compiler communications acm 
mills fowler 
reduced high level language instruction set ieee micro june 

gries compiler construction digital computers wiley new york 

assemblers compilers program translation computer science press rockville md 

may mimic fast system simulator proceedings sigplan symposium interpreters interpretive techniques st paul minnesota june pp 


dasgupta computer architecture modern synthesis volume wiley new york 

dasgupta hardware description languages microprogramming systems ieee computer pp 


murray computer digital system architecture prentice hall englewood cliffs new jersey 
appendix example program simulated stack architecture include stdio 
ram start program start 
define start define typedef unsigned long int ul char opc add adi unsigned halt halt jsr lai lar ldi ldr lds link pa pi sar ul cycles ul freq pc fp sp ac define paddr fprintf stderr start ld start compiled instruction set simulation void main int ul starttime mem malloc time mem malloc start sizeof ul null fprintf stderr error allocate ram exit starttime time execute mem fprintf stderr executed bad address fprintf stderr normal termination freq freq cycles fprintf stderr paddr pc fprintf stderr paddr sp fprintf stderr paddr fp fprintf stderr lx ld ac ac fprintf stderr total instructions lu 
total cycles lu fprintf stderr total execution time lu seconds time starttime fprintf stderr lu opc freq freq freq cycles freq cycles ifdef cache define fetch case stdout define fetch case endif define pc sp fp ac opcode definitions define add fetch freq define adi fetch freq define fetch freq break mills fowler define halt fetch freq return define jsr fetch freq break define lai fetch freq define lar fetch freq define ldi fetch freq define ldr fetch freq define lds fetch freq define link fetch freq define pa fetch freq define pi fetch freq define sar fetch freq define fetch freq break int execute register ul register ul start switch lds start start jsr start start halt start link start main int value lai start sar start pi start value fib jsr start start sar start lar start adi start sar start ldi start start start lar start return value start link start fib int lar start ldi start start start lar start return fib adi start pa start jsr start start ldr start fib adi start pa start jsr start start add start compiled instruction set simulation start lai start return start default return appendix ii 
program output normal termination start 
start 
start 

total instructions 
total cycles 
total execution time add adi halt jsr lai lar ldi ldr lds link pa pi sar seconds 

