generic haskell applications ralf hinze johan jeuring institut informatik iii universit bonn bonn germany ralf informatik uni bonn de www informatik uni bonn de ralf institute information computing sciences utrecht university box tb utrecht netherlands cs uu nl www cs uu nl open university netherlands 
generic haskell extension haskell supports construction generic programs 
lecture notes discuss advanced generic programming applications generic dictionaries compressing xml documents zipper data structure represent tree subtree focus attention focus may move left right tree 
describing implementing examples encounter advanced features generic haskell type indexed data types dependencies generic abstractions generic functions adjusting generic function default case generic functions special case particular constructor 
generic polytypic type indexed function function instantiated data types obtain data type specific functionality 
examples generic functions functions derived haskell show read :10.1.1.18.8266
part lecture notes entitled generic haskell practice theory introduced generic functions shown implement generic haskell 
assume reader familiar part notes 
related different kind generic programming see backhouse 
generic programming important 
generic programming programs easier write programs written untyped style written language types 
programs come free 
programs simple adjustments library functions complicated traversal functions 
hinze jeuring course programs simpler write programs generic programming language hand programs complicated 
try give feeling generic programs useful 
lecture notes describe advanced generic programming applications generic dictionaries compressing xml documents zipper 
applications described detail 
examples encounter new generic programming concepts type indexed data types 
type indexed data type constructed generic way argument data type 
equivalent type indexed function level data types 
default cases 
define generic function function cases default case 
new definition provide certain case default case applies copies case function 
constructor cases 
constructor case generic program deals constructor data type requires special treatment 
constructor cases especially useful dealing data types large number constructors small number constructors need special treatment 
dependencies generic abstractions 
write generic function uses generic function dependency generic abstraction 
introduce concepts go 
example digital searching 
digital search tree trie search tree scheme employs structure search keys organize information 
searching useful various data types allow keys information data type 
means construct new kind trie key type 
example consider data type string defined data string nil cons char string 
represent string indexed tries associated values type follows data fmap string null string node string fmap string 
trie strings typically index texts 
constructor null string represents empty trie 
component constructor node string contains value associated nil 
second component node string derived constructor cons char string string 
assume suitable data structure associated lookup function char characters generic haskell applications predefined 
prerequisites define look function strings follows lookup string string fmap string lookup string null string lookup string nil node string tn tc tn lookup string cons node string tn tc lookup string tc 
look non empty string cons look obtaining trie recursively searched look functions result type reverse monadic composition monad denoted compose lookup string 
case just consider data type bush binary trees characters leaves data bush leaf char bin bush bush 
bush indexed tries represented data type data fmap bush null bush node bush fmap bush fmap bush 
components store values constructed leaf values constructed bin 
corresponding look function lookup bush bush fmap bush lookup bush null bush lookup bush leaf node bush tl tf tl lookup bush bin bl br node bush tl tf lookup bush bl lookup bush br tf easily recognize look functions data types tries instances underlying generic pattern 
section show define trie associated functions generically arbitrary data types 
example compressing xml documents 
extensible markup language xml mark text structure information 
xml documents may large markup added content 
xml compressor compress xml document quite large factor 
xml document usually structured dtd document type definition specification describes tags may xml document positions order 
dtd hinze jeuring way type xml document 
xml document called valid respect certain dtd follows structure specified dtd 
xml compressor information dtd obtain better compression 
example consider small xml file book lang english title dead famous title author ben elton author date date book 
file may compressed separating structure data compressing parts separately 
compressing structure dtd document 
element book title author date chapter element title pcdata element author pcdata element date pcdata element chapter pcdata attlist book lang english dutch required know elements attributes say appear dtd dtd document contains elements replace markup element xml file valid respect dtd natural number log bits 
main ideas xmill 
improve xmill recording choices xml document 
document choice language book number chapters 
elements encoded inferred dtd 
section describes tool idea described jansson jeuring context data conversion 
translate dtd data type construct generic functions separating contents strings shape constructors value data type encoding shape value data type information number constructors data type 
xml compressors just class xml tools easily implemented generic programs 
xml tools implemented generic programs xml editors xml databases xml version management tools 
example zipper 
zipper data structure represent tree subtree focus attention focus may move left right tree 
example zipper corresponding data type bush called loc bush defined type loc bush bush context bush data context bush top context bush bush bush context bush 
generic haskell applications type locations efficiently navigate tree 
example bush loc bush loc bush bush leaf leaf bush bin tl tr tl tr right bush loc bush loc bush right bush tl tr tr tl right bush navigation function bush moves focus attention leftmost subtree current node right bush moves focus right sibling 
huet defines zipper data structure rose trees data type bush gives generic construction words 
section describe zipper detail show define zipper arbitrary data type 
applications generic programming 
applications mentioned examples application areas generic programming 
haskell deriving construct 
haskell deriving construct generate code example equality function functions reading showing values data types 
classes eq ord enum bounded show read derived 
definitions equivalents derived functions library generic haskell 
compiler functions 
functions compilers generic functions garbage collectors tracers debuggers test tools typed term processing 
functions pattern matching term rewriting unification generic functions implemented generic functions 
form functionality applications exactly determined structure input data 
common applications generic programming functions traverse data built rich mutually recursive data types constructors perform computations single couple constructor 
example consider function traverses syntax tree returns free variables tree 
variable constructor special done cases variables collected children passed parent 
function defined instance generic haskell library function crush special constructor case variables 
examples generic traversals see mmel peyton jones 
generic haskell code programs discussed lecture notes downloaded applications page www generic haskell 
org 
hinze jeuring notation 
improve readability notation generic functions notes slightly differs notation part notes 
example part lecture notes write equal char equal int eqint equal unit unit unit true equal eqa eqb inl inl eqa equal eqa eqb inl inr false equal eqa eqb inr inl false equal eqa eqb inr inr eqb equal eqa eqb eqa eqb equal con eqa con con eqa function equal generic function recurses type structure argument type 
recursion implicit arguments eqa eqb cases 
part lecture notes write equal char equal int eqint equal unit unit unit true equal inl inl equal equal inl inr false equal inr inl false equal inr inr equal equal equal equal equal con con con equal recursion type structure explicit equal expressed terms equal equal 
think style readable especially generic function depends generic function 
functions written style translated style vice versa expressiveness lost gained difference readability 
generic haskell compiler accept explicit recursive functions probably near 
formal description generic haskell explicit recursion 
organization 
rest organized follows 
section introduces generic dictionaries implements generic haskell 
section describes compressor xml documents 
section develops generic zipper data structure 
section summarizes main points concludes 
lecture notes contain exercises 
solutions exercises webpage generic haskell project www generic haskell org 
generic dictionaries trie search tree scheme employs structure search keys organize information 
tries originally devised means represent generic haskell applications collection records indexed strings fixed alphabet 
wadsworth connelly generalized concept permit indexing elements built arbitrary signature 
section go step define tries operations tries generically arbitrary data types arbitrary kinds including parameterized nested data types 
material section largely taken :10.1.1.46.223
concept trie introduced thue means represent set strings see 
simplest form trie multiway branching tree edge labelled character 
example set strings ear earl east easy eye represented trie depicted right 
searching trie starts root proceeds traversing edge matches character traversing edge matches second character forth 
search key member represented set search stops node marked marked nodes drawn filled circles right 
tries represent finite maps 
case marked nodes additionally contain values associated strings 
interestingly move sets finite maps mere variation scheme 
shall see essential development 
level trie seen composition finite maps 
collection edges descending node constitutes finite map sending character trie 
interpretation mind relatively straightforward devise implementation string indexed tries 
strings defined data type data string nil cons char string represent string indexed tries associated values type follows 
data fmap string null string node string fmap string null string represents empty trie 
component constructor node string contains value associated nil 
type nil may domain finite map represented trie 
case component equals 
second component corresponds edge map 
keep introductory example manageable hinze jeuring implement ordered association lists 
type char char just note result type key domain finite map returned 
building define look function strings 
look empty string access component trie 
look non empty string say cons look edge map obtaining trie recursively searched lookup string string fmap string lookup string null string lookup string nil node string tn tc tn lookup string cons node string tn tc lookup string tc equation monadic composition take care error signal 
wadsworth connelly generalized concept trie permit indexing elements built arbitrary signature elements arbitrary non parameterized data type 
definition lookup string gives clue suitable generalization look trie node string tn tc contains finite map constructor data type string look cons look functions components composed 
generally data type constructors corresponding trie components 
look constructor fields select corresponding finite map compose look functions appropriate types 
constructor fields nil extract associated value 
second example consider data type external search trees data dict tip string node dict string dict 
trie external search trees represents finite map dict value type element fmap dict data fmap dict null dict node dict fmap string fmap dict fmap string fmap dict 
generic haskell applications data type fmap dict nested data type recursive call right hand side fmap dict fmap string fmap dict substitution instance left hand side 
consequently look function external search trees requires polymorphic recursion 
lookup dict dict fmap dict lookup dict null dict lookup dict tip node dict tl tn lookup string tl lookup dict node node dict tl tn lookup dict lookup string lookup dict tn looking node involves recursive calls 
lookup dict type dict fmap dict fmap string fmap dict substitution instance declared type 
note absolutely necessary fmap dict lookup dict parametric respect codomain finite maps 
restrict type lookup dict dict fmap dict fixed type definition longer type checks 
explains construction finite set abstraction 
generalized tries particularly interesting application generic programming 
central insight trie considered type indexed data type 
renders possible define tries operations tries generically arbitrary data types 
necessary prerequisites hand know define tries sums products 
trie sum essentially product tries trie product composition tries 
extension arbitrary data types uniquely defined 
mathematically speaking generalized tries isomorphisms 
fin fin fin fin fin fin fin fin denotes set finite maps note fin written explains equations known laws exponentials 
signature put idea concrete terms define type indexed data type fmap kind types kind 
fmap fmap assigns type constructor kind key type kind 
hinze jeuring implement operations tries 
empty fmap isempty fmap bool single 
fmap lookup fmap insert 
fmap fmap merge 
fmap fmap fmap delete fmap fmap value empty empty trie 
function isempty takes trie determines empty 
function single constructs trie contains binding element 
function lookup takes key trie looks value associated key 
function insert inserts new binding trie merge combines tries 
function delete takes key trie removes binding key trie 
functions insert merge take argument called combining function applied bindings key 
instance new old new combining function insert new binding override old binding key 
finite maps type fmap int addition may sensible choice 
interestingly see combining function convenient feature user necessary defining insert merge generically types 
properties operations specified previous section satisfies number laws hold generically instances properties formally specify parts informal descriptions operations proved definitions sections fixed point induction 
see hinze examples proofs properties generic functions 
lookup empty lookup single just lookup merge combine lookup lookup combine combines values type combine 
combine combine just just combine just just combine just just just 
law instance states looking key merge tries yields result looking key trie separately combining results 
combining form associative generic haskell applications merge associative 
furthermore empty left right unit merge merge empty merge empty merge merge merge merge 
functions insert delete satisfy laws insert empty single delete single empty 
operations satisfy laws omit 
type indexed tries noted generalized tries laws exponentials 
fin fin fin fin fin fin fin order define notion finite map customary assume value type contains distinguished element base point see 
finite map function value finitely arguments 
implementation tries inconvenient strong assumption type classes purpose 
explicitly add base point necessary motivating definition fmap example type indexed data type 
fmap fmap unit fmap int patricia dict fmap char fmap fmap fmap fmap fmap fmap fmap con fmap type optional pairs 
data null pair optional pairs ordinary pairs definition fmap fmap fmap fmap hinze jeuring representation major drawbacks relies essential way lazy evaluation ii inefficient see :10.1.1.46.223
assume exists suitable library implementing finite maps integer keys 
library instance data structure known patricia tree 
data structure fits particularly current setting patricia trees variety tries 
clarity qualified names referring entities defined hypothetical module patricia 
remarks order 
fmap type indexed data type 
way construct values type fmap means functions interface 
furthermore contrast type indexed functions constructor index con doesn mention constructor description anymore 
type depend value constructor description definition type indexed data type 
trie unit type tries isomorphic types general isomorphic 
instance unit unit unit ignoring laziness fmap unit fmap unit unit trie type different representations empty trie just 
implementation 
similarly elements null pair represent empty trie 

mentioned section kind fmap types kind 
type constructors higher order kinds kind fmap looks surprisingly similar type type indexed functions higher order kinds 
trie type list trie type list applied trie type fmap 
type type indexed type kind indexed kind 
general fmap fmap fmap fmap fmap fmap fmap box type kind called super kind 
example 
specialize fmap data types 
data list nil cons list data tree tip node tree tree data fork fork data sequ ends zeros sequ fork ones sequ fork generic haskell applications types represented see section part lecture notes list fix list unit list tree fix tree tree tree fork sequ fix sequ unit sequ fork sequ fork 
recall binds stronger 
consequently corresponding trie types fmap list fix fmap list fa fa fmap list fa fmap tree fix fmap tree fa fb fa fmap tree fa fb fb fmap tree fa fb fmap fork fa fa fa fmap sequ fix fmap sequ fa fmap sequ fmap fork fa fa fmap sequ fmap fork fa 
aside note interpret type optional triples nested optional pairs data null triple haskell permits definition higher order kinded data types second order type constructors directly coded data types 
bring equations applicative form 
data fmap list fa null list node list fa fmap list fa data fmap tree fa fb null tree node tree fa fmap tree fa fb fb fmap tree fa fb types parametric variants fmap string fmap dict defined section fmap string fmap list corresponding string list char fmap dict fmap tree fmap string fmap string corresponding dict tree string string 
things interesting consider nested data types 
data fmap fork fa node fork fa fa data fmap sequ fa null sequ node sequ fmap sequ fmap fork fa fa fmap sequ fmap fork fa hinze jeuring generalized trie nested data type second order nested data type 
nest termed second order parameter instantiated recursive call ranges type constructors order kind 
trie fmap sequ second order nest parameter fa kind changed recursive calls 
contrast fmap tree order nest instantiated parameter kind 
quite easy produce generalized tries second order nests 
swap components sequ third constructor ones sequ fork ones sequ fork third component fmap sequ type fmap sequ fmap fork fa fa fa instantiated fmap sequ consequently second order nest 
empty tries empty trie defined follows 
type empty fmap type empty empty empty empty empty empty unit empty char empty int patricia empty empty null empty empty empty con empty definition illustrates interesting aspects programming generalized tries 
explicit polymorphic type empty necessary definition 
consider line empty type fmap fmap 
defined terms empty type fmap means empty polymorphically 
words empty polymorphic recursion 
suppose want define function emptyi function empty uses different value say empty trie integers 
definition fmap says patricia tree changed definition fmap 
default case define emptyi terms empty follows emptyi empty emptyi int emptyi empty 
function emptyi equal function empty cases int case uses special empty trie 
generic haskell applications example 
specialize empty lists binary random access lists 
empty list fa 
fa fmap list fa empty list ea null list empty fork fa 
fa fmap fork fa empty fork ea node fork ea empty sequ fa 
fa fmap sequ fa empty sequ ea null sequ second function empty fork illustrates polymorphic parameter ea type fa element fa fa 
functions empty list empty sequ show mechanically generated definitions slightly improved argument ea needed 
function isempty takes trie determines empty 
type isempty fmap bool type isempty isempty isempty isempty isempty isempty unit isempty char null isempty int patricia isempty isempty null true isempty false isempty isempty isempty con isempty function isempty assumes tries normal form empty trie represented null example pair null null 
example 
specialize isempty lists binary random access lists 
isempty list fa 
fa bool fmap list fa bool isempty list iea null list true isempty list iea node list tn tc false isempty fork fa 
fa bool fmap fork fa bool isempty fork iea node fork tf iea tf isempty sequ fa 
fa bool fmap sequ fa bool isempty sequ iea null sequ true isempty sequ iea node sequ tv tf ts false hinze jeuring singleton tries function single constructs trie contains binding element 
construct trie sum case return pair component inhabited 
component empty trie 
means single depends empty 
generic haskell supports dependencies empty trie single trie sum product constructor cases function single 
dependency shows type function single higher order kinds type mentions type empty 
type single 
fmap type single empty single single plain generic functions seen catamorphisms structure data types :10.1.1.41.125
dependencies get power paramorphisms 
single single single unit unit just single char single int patricia single single inl pair single empty single inr pair empty single single single single single con con single example 
specialize generic function lists binary random access lists 
single list fa 
fa 
fa 
list fmap list fa single list ea sa nil node list just ea single list ea sa cons ks node list sa single list ea sa ks single fork fa 
fa 
fa 
fork fmap fork fa single fork ea sa fork node fork sa sa single sequ fa 
fa 
fa 
sequ fmap sequ fa single sequ ea sa ends node sequ just null sequ ea single sequ ea sa zeros node sequ single sequ empty fork ea single fork ea sa ea single sequ ea sa ones node sequ null sequ sa single sequ empty fork ea single fork ea sa generic haskell applications simplify mechanically generated definitions definition fork involve sums single fork require argument ea safely removed 
look look function implements scheme discussed section 
type lookup fmap type lookup lookup lookup lookup lookup lookup unit unit fm fm lookup char fm fm lookup int fm patricia lookup fm lookup null lookup inl pair fma fmb lookup fma lookup inr pair fma fmb lookup fmb lookup fma lookup lookup fma lookup con con fm lookup fm sums look function selects appropriate map products composes look functions components 
lookup result type monadic composition 
example 
specializing lookup concrete instances probably matter routine 
lookup list fa 
fa list fmap list fa lookup list la ks null list lookup list la nil node list tn tc tn lookup list la cons ks node list tn tc la lookup list la ks tc lookup fork fa 
fa fork fmap fork fa lookup fork la fork node fork tf la la tf lookup sequ fa 
fa sequ fmap sequ fa lookup sequ la null sequ lookup sequ la ends node sequ te tz te lookup sequ la zeros node sequ te tz lookup sequ lookup fork la tz lookup sequ la ones node sequ te tz la lookup sequ lookup fork la function lookup list generalizes lookup string defined section lookup string lookup list 
hinze jeuring inserting merging insertion defined terms merge single 
insert 
fmap fmap insert merge single function insert defined generic abstraction 
generic abstraction generic function defined terms generic function 
abstracted type parameter restricted types fixed kind 
case insert works types kind 
exercise section define insert generic function works type constructors kinds 
merging tries surprisingly simple 
function combine defined section function merging association lists 
define merge follows 
type merge 
fmap fmap fmap type merge merge merge merge merge merge unit combine merge char fm fm fm fm merge int fm fm patricia merge fm fm merge con merge sum case distinguish empty nonempty tries merge null merge null merge pair pair pair merge merge 
interesting equation product case 
tries type fmap fmap 
merge recursively call merge supply combining function type fmap generic haskell applications fmap fmap moment reflection reveals merge desired combining function 
merge merge merge definition merge shows necessary implement operations general immediately needed 
merge simpler type fmap fmap fmap able give defining equation 
example 
complete picture specialize merging operation lists binary random access lists 
different instances merge surprisingly concise types look complicated 
merge list fa 

fa fa fa 
fmap list fa fmap list fa fmap list fa merge list ma null list merge list ma null list merge list ma node list tn tc node list tn tc node list combine tn tn ma merge list ma tc tc merge fork fa 

fa fa fa 
fmap fork fa fmap fork fa fmap fork fa merge fork ma node fork tf node fork tf node fork ma ma tf tf merge sequ fa 

fa fa fa 
fmap sequ fa fmap sequ fa fmap sequ fa merge sequ ma null sequ merge sequ ma null sequ merge sequ ma node sequ te tz node sequ te tz node sequ combine te te merge sequ merge fork ma tz tz ma merge sequ merge fork ma deleting function delete takes key trie removes binding key trie 
char case need help function removes element association list char hinze jeuring similarly int case 
function delete defined follows delete delete delete unit unit fm delete char fm fm delete int fm patricia delete fm 
cases product case straightforward 
product case remove binding product 
lookup trie binding remove binding obtaining trie empty delete complete binding insert binding original trie pass combining function overwrites existing bindings trie 
description follows function delete depends functions lookup insert depends function empty isempty 
need kind indexed typed version function insert defined exercise section 
type delete fmap fmap type delete lookup insert isempty empty delete delete delete null null delete inl pair pair delete delete inr pair pair delete delete case lookup delete just isempty delete insert delete con con delete function delete maintain invariant empty trie represented null pair null null example 
easy adapt definition invariant maintained 
type delete complex dependencies give instance delete list 
generic haskell applications delete list fa 
fa 
fa fa fa bool fa 
fa fa list fmap list fa fmap list fa delete list la ia iea ea da nil null list null list delete list la ia iea ea da nil node list tn tc node list tc delete list la ia iea ea da cons null list null list delete list la ia iea ea da cons node list tn tc case la delete list la ia iea ea da tc tc just tc iea tc da tc ia tc tc related knuth attributes idea trie thue introduced strings contain adjacent repeated substrings 
de la recommended tries computer searching 
generalization tries strings elements built arbitrary signature discovered wadsworth independently 
connelly formalized concept trie categorical setting showed trie functor corresponding look function natural transformation 
implementation generalized tries okasaki textbook functional data structures :10.1.1.54.6229
tries parameterized types lists binary trees represented standard ml functors 
approach works regular data types fails nested data types sequ 
case data types second order kind indispensable 
exercise 
define function insert generic function kind indexed kind 
download code functions described section www generic haskell org including solution exercise 
want avoid looking implementation insert solving exercise 
exercise 
define function update updates binding trie 
update 
fmap fmap binding value type trie type fmap update returns 
hinze jeuring generic xml compressor extensible markup language xml popular standard describing documents markup structure 
xml documents may large markup added content 
lot bandwidth store send xml documents 
xml compressors reduce size xml document considerable factor 
section describes generic xml compressor ideas described context data conversion jansson jeuring 
section shows xml compressor implemented generic program briefly discusses classes xml tools profit implementation generic program 
example shows generic haskell implement xml tools behaviour depends dtd schema input xml document 
example tools include xml editors databases compressors 
generic haskell ideally suited implementing xml tools knowledge dtd provide precise functionality manipulations xml document preserve validity xml editor better compression xml compressor 
generic haskell programs typed 
consequently valid documents transformed valid documents possibly structured dtd 
generic haskell supports constructing type correct xml tools 
generic features generic haskell xml tools easier implement surprisingly small amount code 
generic haskell compiler may perform kinds advanced optimisations code partial evaluation deforestation difficult conceive implement xml tool developer 
implementing xml compressor generic program implemented xml compressor called generic program 
separates structure contents compresses structure knowledge dtd compresses contents unix compress utility :10.1.1.118.8921
replace element pair open close keywords element minimal number bits required element dtd 
distinguish components tool component translates dtd data type component separates value data type structure contents component encodes structure replacing constructors bits component compressing contents 
course implemented decompressor similar compressor omit description 
see website latest developments 
generic haskell source code obtained website 
generic haskell applications translating dtd data type 
dtd translated haskell data types 
example dtd element book title author date chapter element title pcdata element author pcdata element date pcdata element chapter pcdata attlist book lang english dutch required translated data types data book book book attrs title author date chapter data book attrs book attrs lang data lang english dutch newtype title title string newtype author author string newtype date date string newtype chapter chapter string 
haskell library particular functionality module obtain data type dtd functions reading parsing writing pretty printing valid xml documents value generated data type 
example value dtd book lang english title dead famous title author ben elton author date date chapter chapter chapter preliminaries chapter book translated value data type book book book attrs english title dead famous author ben elton date chapter chapter preliminaries 
element translated value data type just constructors labelled fields 
attribute translated value contains labelled field attribute 
generic haskell constructs con label distinguish elements attributes generic programs 
introduced label construct lecture notes 
represent record labels data types similar con construct 
hinze jeuring separating structure contents 
contents xml document obtained extracting pcdata parsable character data characters tags cdata character data characters possibly tags starting cdata document 
generic haskell contents value data type obtained extracting strings value 
example value obtain result dead famous ben elton preliminaries 
generic function extract extracts strings value data type defined follows type extract string type extract extract extract extract extract extract unit unit extract string extract inl extract extract inr extract extract extract extract extract con con extract note possible give special instances generic function particular type extract string definition 
furthermore translates dtd data type kind defined extract just data types kind 
higher order kinds pose problems 
operator product case source inefficiency 
removed standard transformation see exercise part lecture notes 
structure xml document obtained removing pcdata cdata document 
generic haskell structure shape value obtained replacing strings empty tuples 
obtain value different type occurrences type string replaced type 
example type indexed data type 
example type obtain data type book isomorphic data type generic haskell applications data attrs data attrs attrs data newtype newtype newtype newtype structure example value attrs type indexed data type shape replaces occurrences string data type unit 
shape unit unit shape string shape shape shape shape shape shape shape con con shape generic function shape returns shape value data type 
kind indexed type 
type shape shape type shape shape shape note name kind indexed type function shape type indexed data type shape 
distinguished index 
shape shape shape unit unit unit shape string shape inl inl shape shape inr inr shape shape shape shape shape con con con shape hinze jeuring shape contents obtained means function extract value obtain original value means function insert insert shape string generic definition kind indexed type insert left exercise 
encoding constructors 
constructor value encoded follows 
calculate number constructors data type 
calculate position constructor list constructors data type 
replace constructor bit representation position log bits 
example data type constructors third constructor encoded 
start counting 
furthermore value data type single constructor represented bits 
consequently values types string lang running example represented bits 
assume exists function constructor returns pair integers position list constructors data type number constructors data type 
int int function defined means function constructors returns constructor descriptions data type 
function defined module collect library generic haskell 
constructors function constructors defined arbitrary kinds module collect 
omit definitions function constructors function 
function encode takes value encodes value type bin list bits defined part lecture notes 
difference function encode defined part lecture notes encode constructors value choices sum 
average function encode compresses better function encode part lecture notes 
type encode shape bin type encode encode encode interesting case definition function encode constructor case 
give simple cases encode encode encode unit encode string encode encode encode encode inl encode encode inr encode generic haskell applications unit string encode 
product case encodes components product concatenates results 
sum case strips inl inr constructor encodes argument 
encoding happens constructor case function encode 
function bits calculate bits position argument constructor constructor list number constructors data type currently scope 
definition bits omitted 
encode con con bits encode bits int int bin omit definition function decode list bits value data type 
function inverse function encode defined section similar function decodes part lecture notes 
compressing contents 
remains compress contents xml document 
moment unix compress utility compress strings obtained document :10.1.1.118.8921
analysis perform compare xml compressors 
analysis section limited example generic program latest development xml compression 
furthermore able obtain executables source code existing xml compressors 
existing xml compressors 
structure specific compression methods give better compression results conventional compression methods unix compress utility :10.1.1.118.8921
exist xml compressors know xmill ict xml xpress lossy xml compression 
perform exhaustive comparison compressor compressors briefly compare compressor xmill 
compression ratio 
performed initial tests comparing xmill 
tests representative impossible draw hard results 
test examples better xmill 
think improvement compression ratio considerable 
replace tool generates data type schema expect achieve better compression ratios 
hinze jeuring code size 
respect code size difference xmill dramatic xmill written lines 
main functionality lines generic haskell code 
course fair comparison add code library distributed compiler interpreters haskell code handling bits code implementing unimplemented features xmill 
expect able implement xmill features code size xmill 
extensions 
relatively simple way improve analyze source files valid respect dtd count number occurrences different elements constructors apply huffman coding 
implemented simple extension 
xmill stores strings elements called containers 
standard approach xmill different containers different elements example authors stored author container dates date container strings example container dates similar standard compression methods compress containers larger factor single file obtained storing strings appear xml document 
easy implement feature generic program 
adaptive arithmetic coding compress constructors 
specializing 
compressing xml documents compressing values arbitrary data types necessarily generated 
suppose data type contains constructor age takes integer argument denotes age human 
currently safe upperbound age human suffices bits integer argument age 
suppose calculates bits age 
reuse definition encode constructor case define function 
encode case age age encode function generic encoding function values form age uses different compress function 
shown implement xml compressor generic program 
compresses better example xmill uses information xml document dtd 
generic haskell applications exist classes xml tools implemented generic programs benefit implementation 
examples tools xml editors xml databases 
combination generic programming generic haskell useful implementing kind xml tools dtds play important le 
generic programming tools easier write lot code pertaining dtd handling optimisation obtained generic programming compiler resulting tools effective directly depend dtd 
example dtd aware xml compressor described compresses considerably better xml compressors don take dtd account xmill 
furthermore compressor smaller xmill 
think generic haskell useful developing dtd aware xml tools features xml tools difficult express generic haskell 
functionality dom methods node interface hard express typed way 
flexible extension type indexed data types offer solution problem :10.1.1.1.6342
believe fusing tool schemas generic haskell obtaining domain specific language generic programming dtds schemas promising approach 
tools depend dtd untyped approach obtain tool works document 
advantages generic programming longer apply 
exercise 
adapt function extract returns list containers container list strings 
return possibly empty container constructor name 
exercise 
empty containers approach previous exercise 
analyse data type occurrences type string constructors 
analysis return containers constructor names contain strings 
exercise 
function insert takes shape contents list strings value inserts strings right positions shape 
define function insert generic function kind indexed type 
exercise 
adapt current version huffman coding standard constructor encoding section 
sure encodings 
zipper section shows define called zipper arbitrary data type 
advanced example demonstrating full power type indexed data type number generic functions working 
hinze jeuring zipper data structure represent tree subtree focus attention focus may move left right tree 
zipper tools user interactively manipulates trees instance editors structured documents proofs programs 
important note focus zipper may move recursive components 
consider example data type tree data tree tip node tree tree 
left subtree node constructor current focus moving right means moving right tree label 
implies recursive positions trees play important le definition generic zipper data structure 
obtain access recursive positions explicit fixed points data type definitions 
zipper data structure defined induction called pattern functor data type 
tools zipper allow user repeatedly apply navigation edit commands update focus accordingly 
section define type indexed data type locations consist subtree focus context define navigation functions locations 
basic idea zipper pointer reversal 
follow pointer subterm pointer reversed point subterm parent go 
location pair consisting current subterm pointer parent 
upward pointer corresponds context subterm 
represented follows 
constructor recursive subcomponents introduce context constructors 
km 
consider location 
tm 
go left context 
tm old context represent combined context simply plug hole obtain 
tm 
new location 
tm 
picture illustrates idea filled circle marks current cursor position 
tm tm left right data types fixed points pattern functors tm mentioned order zipper explicit fixed points data type definitions 
introduce data type fix generic haskell applications define data type fixed point pattern functor 
pattern functor recursion explicit data type 
newtype fix fix labelled variant data type fix defined section part lecture notes 
example data types natural numbers bushes defined explicit fixed points follows data type nat fix data bushf char type bush fix bushf 
easy convert data types defined fixed points original data type definitions natural numbers bushes 
nested data types mutually recursive data types defined terms particular definition fix 
type indices higher kinds types occur indices generic function kind base kind 
example int char unit kind kind 
section going define generic functions base kind 
need slightly different type indices generic functions operating types kind con con id constant functor lifts type kind kind 
need unit char general primitive types 
overload con lifted versions previously defined counterparts 
new type index set indices kind identity functor id hinze shows types normal forms types kind 
locations location subtree context encodes path top original tree selected subtree 
type indexed data type hinze jeuring loc returns type locations argument pattern functor 
loc loc fix context fix context context fix ctx data lifted version 
type loc defined terms context constructs context parameterized original tree type 
context value empty represented type path root tree 
path constructed means argument type type indexed data type ctx 
type indexed data type ctx defined induction pattern functor original data type 
seen derivative calculus pattern functor 
derivative denoted const follows definition ctx need access type arguments right hand side definition 
ctx ctx id ctx unit void ctx char void ctx ctx ctx ctx ctx ctx definition understood follows 
possible descend constant constant cases contribute result type denoted empty type void type values 
id case denotes recursive component possible descend 
may occur context 
descending value sum type follows structure input value 
ways descend product descending left adding contents right node context descending right adding contents left node context 
example natural numbers pattern functor unit id trees type bush pattern functor bushf represented char id id obtain context unit id fix context char id id fix data void data void 
generic haskell applications context natural number isomorphic natural number context context bush applied data type bush isomorphic type context bush introduced section 
mcbride defines type indexed zipper data type :10.1.1.22.8611
zipper slightly deviates huet zipper navigation functions mcbride zipper constant time anymore 
observation context data type derivative calculus due mcbride 
navigation functions define generic functions type indexed data types loc context ctx navigating tree 
functions act locations 
basic functions zipper 
function 
function generic function moves leftmost recursive child current node child exists 
current node leaf node returns location unchanged 
loc loc instantiation data type bush section 
function satisfies property function goes tree 
going tree identity function locations possible go 
moves leftmost recursive child current node inverse equality id hold general 
exist natural number right function right goes right tree 
properties completely specify function 
properties satisfy selected subtree leftmost tree child selected subtree context context extended leftmost tree child function defined follows 
case just find leftmost recursive child pattern match pattern functor find occurrence id helper function generic function possibly returns leftmost recursive child node context value type ctx selected child 
function hinze jeuring turns context value type context inserting right non top component sum means applying fixed point constructor 
ctx id return unit char inl cx return inl cx inr cy return inr cy cx return inl cx cy return inr cy return obtained monad operator standard monadic plus called mplus haskell just just function returns value context leftmost id position 
product case tries left component fails tries right component 
definitions functions right left simple definition defined pattern matching context tree 
just define functions right leave function left exercise 
function 
function moves parent current node current node top node 
loc loc case ft insert extract return ft remember denotes empty top context 
navigation function uses helper functions insert extract 
returns context parent current node 
element type ctx component easy inductive argument marks context parent current node 
generic function extract extracts context 
generic haskell applications extract ctx extract id return extract unit extract char extract inl cx extract cx extract inr cy extract cy extract inl cx extract cx extract inr cy extract cy function extract polymorphic function insert takes context tree inserts tree current focus context effectively turning context tree 
insert ctx insert id return insert unit insert char insert inl cx insert cx return inl insert inr cy insert cy return inr insert inl cx insert cx return insert inr cy insert cy return note extraction insertion happening identity case id cases pass results 
id locations possible go expect similar equalities functions extract insert 
computation ft extract ft insert return ft ft returns true locations possible go 
function right 
function right moves focus right sibling tree exists 
context moved accordingly 
instance right data type bush section 
function right satisfies property right left right going right tree left identity function locations possible go right 
course dual equality holds locations possible go left 
furthermore selected subtree right sibling right selected subtree hinze jeuring context right context context replaced selected subtree subtree right context replaced context function right defined pattern matching context 
impossible go right top tree 
try find right sibling current focus 
right loc loc right case case just helper function generic function returns location recursive value right selected value focus 
just exists function left left right id locations possible go right exists function previous previous return returns true locations possible go right 
define function omit definition function previous 
ctx ctx id unit char inl cx cx cx return inl cx inr cy cy cy return inr cy inl cx cx cx return inl cx extract cx insert cx cy return inr cy inr cy cy cy return inr cy lines definition show impossible go right identity constant context 
context argument value sum select element appropriate component sum 
product case interesting 
context right component pair returns value context properly combined generic haskell applications left component tuple 
hand context left component pair value may left component context may right component value 
value left component returned line definition product case 
extracts context context parent left context cx inserts value context cx giving tree value selects component right component pair extracted context new context 
new context obtained combined context selected tree 
exercise 
define function left left loc loc 
exercise 
don want zipper alternatively keep track path current focus 
suppose want path determine name top constructor current focus value data type 
path determines child value selected 
products representations data types binary path structure data dir type path dir 
defined function takes value data type path returns constructor name position denoted path 
example data list nil cons char list list cons cons cons nil nil data tree leaf int node tree int tree tree node leaf node leaf leaf node tree node leaf node leaf leaf leaf 
define generic function kind indexed type 
exercise 
define function left takes location returns location left argument location possible 
exercise 
applications extend data type possible represent place holder 
example data type tree defined data tree tip node tree tree obtain type isomorphic type data hole tip node 
hinze jeuring define type indexed data type hole takes data type returns data type holes specified 
give kind indexed kind type indexed data type 
kind indexed kind defined generic haskell 
define generic function translates value data type value data type hole function inverse values contain holes anymore type hole type hole developed advanced applications generic haskell 
examples generic functions kind indexed kinds type indexed data types dependencies generic abstractions generic functions default constructor cases 
latest developments generic haskell guided requirements applications 
hope develop applications generic haskell develop theory language 
current candidate applications xml tools editors 

andres implemented generic haskell zipper example contributed examples 
paul contributed implementation xml compressor 
dave clarke andres ralf mmel doaitse swierstra jan de wit commented contributed parts previous versions 

michael thorsten altenkirch neil ghani conor mcbride 
derivatives containers 
typed lambda calculi applications tlca 
appear 

backhouse jansson jeuring meertens 
generic programming 
doaitse swierstra pedro jos oliveira editors advanced functional programming volume lncs pages 
springer verlag 

richard bird jeremy gibbons 
arithmetic coding folds unfolds 
johan jeuring simon peyton jones editors advanced functional programming th international summer school oxford uk volume lncs 
springer verlag 
appear 

robert cameron 
source encoding syntactic information source models 
ieee transactions information theory 
generic haskell applications 
mario andrea pugliese domenico 
semantic lossy compression xml data 
knowledge representation meets databases 

james cheney 
compressing xml multiplexed hierarchical models 
proceedings ieee data compression conference dcc pages 

koen claessen colin runciman olaf john hughes malcolm wallace 
testing tracing lazy functional programs quickcheck hat 
johan jeuring simon peyton jones editors advanced functional programming th international summer school oxford uk volume lncs 
springer verlag 
appear 

dave clarke 
gh xml 
talk generic haskell meeting see www generic haskell org talks html 

dave clarke ralf hinze johan jeuring andres jan de wit 
generic haskell user guide 
technical report uu cs utrecht university 
available www generic haskell org 

dave clarke andres generic haskell specifically 
jeremy gibbons johan jeuring editors generic programming volume ifip pages 
kluwer academic publishers january 

richard connelly lockwood morris 
generalization trie data structure 
mathematical structures computer science september 



available www com 

ren de la 
file searching variable length keys 
proc 
western joint computer conference volume pages 
afips press 

william evans christopher fraser 
bytecode compression profiled grammar rewriting 
sigplan conference programming language design implementation pages 

michael franz 
adaptive compression syntax trees iterative dynamic code optimization basic technologies mobile object systems 
mobile object systems programmable internet pages 
springer verlag heidelberg germany 

marc sundaresan 
encoding format efficient representation exchange xml web 
ieee international conference multimedia expo pages 

paul 
framework developing generic xml tools 
master thesis department information computing sciences utrecht university 

ralf hinze 
generalizing generalized tries 
journal functional programming 

ralf hinze 
generic programs proofs 

bonn university 

ralf hinze 
new approach generic functional programming 
conference record popl th acm sigplan sigact symposium principles programming languages pages 
acm press 

ralf hinze 
polytypic values possess types 
science computer programming 

ralf hinze johan jeuring 
generic haskell practice theory 
appear 
hinze jeuring 
ralf hinze johan jeuring andres type indexed data types 
proceedings th mathematics program construction conference mpc volume lncs pages 

rard huet 
zipper 
journal functional programming 

intelligent compression technologies 
xml xpress 
whitepaper available www com products html 

jansson jeuring 
polytypic compact printing parsing 
doaitse swierstra editor esop volume lncs pages 
springer verlag 

patrik jansson 
www home page polytypic programming 
available www cs chalmers se poly 

patrik jansson johan jeuring 
functional pearl polytypic unification 
journal functional programming september 

patrik jansson johan jeuring 
framework polytypic programming terms application rewriting 
jeuring editor workshop generic programming ponte de lima portugal july pages 
utrecht technical report uu cs 

patrik jansson johan jeuring 
polytypic data conversion programs 
science computer programming 

jeuring 
polytypic pattern matching 
conference record fpca sigplan sigarch wg conference functional programming languages computer architecture pages 
acm press 

johan jeuring paul 

available www 
generic haskell org 

donald knuth 
art computer programming volume sorting searching 
addison wesley publishing nd edition 

pieter koopman jan tretmans rinus plasmeijer 
gast generic automated software testing 
submitted publication 

ralf mmel simon peyton jones 
scrap boilerplate practical approach generic programming 
proc acm sigplan workshop types language design implementation 

hartmut dan suciu 
xmill efficient compressor xml data 
proceedings acm sigmod international conference management data pages 

andres dave clarke johan jeuring 
generic haskell naturally language type system 
preparation 

malcolm 
data structures program transformation 
science computer programming 

connor mcbride 
derivative regular type type hole contexts 
unpublished manuscript 

meertens 
paramorphisms 
formal aspects computing 

lambert meertens 
functor pulling 
workshop generic programming sweden june 

meijer fokkinga paterson 
functional programming bananas lenses envelopes barbed wire 
hughes editor fpca functional programming languages computer architecture volume lncs pages 
springer verlag 

chris okasaki 
purely functional data structures 
cambridge university press 

chris okasaki andy gill 
fast mergeable integer maps 
acm sigplan workshop ml baltimore maryland pages 
generic haskell applications 
simon peyton jones editor john hughes editor lennart augustsson dave barton brian boutel warren burton simon fraser joseph fasel kevin hammond ralf hinze paul hudak thomas johnsson mark jones john launchbury erik meijer john peterson alastair reid colin runciman philip wadler 
haskell non strict purely functional language 
available www haskell org definition february 

stork franz 
generic adaptive syntax directed compression mobile code 
technical report department information computer science university california irvine 

axel thue 
ber die gleicher 
af klasse 
reprinted thue selected mathematical papers oslo 

pankaj jayant 
query friendly xml compressor 
icde 


xml 
available www org xml 

wadsworth 
recursive type operators type schemes 
bulletin eatcs 
talk nd international workshop semantics programming languages bad germany march 

malcolm wallace colin runciman 
haskell xml generic combinators type translation 
international conference functional programming pages 

ziv lempel 
universal algorithm sequential data compression 
ieee transactions information theory 
