de nable relations order query languages strings michael benedikt bell labs leonid libkin toronto thomas schwentick marburg luc inria study analogs classical relational calculus context strings 
start studying string logics 
classical model theoretic approach set string operations look resulting collection de nable relations 
form algebra class ary relations closed projection boolean operations 
show choosing string vocabulary carefully get string logics desirable properties computable evaluation normal forms 
identify distinct models study di erences model theory complexity evaluation 
identify subset models additional attractive properties nite vc dimension quanti er elimination 
logic addition free predicate symbols gives string query language 
resulting languages attractive closure properties database point view sql allow full composition string pattern matching expressions relational operators logics yield compositional query languages capture common string matching queries remaining tractable 
logics studied rst part study properties corresponding query languages 
give bounds data complexity queries extend normal form results logics queries show languages corresponding algebras expressing safe queries 
past years various connections logic strings formal languages nite automata explored great detail 
standard setting connecting logical de nability various properties formal languages represent strings nite alphabet fa rst order structures signature string length universe kg usual ordering set positions lth character sentence logic de nes language fs classical results logic language theory state languages de nable monadic second order logic mso precisely regular part done second third authors visited inria second fourth authors visited mainz 
bell laboratories blvd il usa 
mail benedikt research bell labs com 
department computer science university toronto king college road toronto ontario canada 
mail libkin cs toronto edu 
fachbereich mathematik und informatik universit marburg marburg germany 
email tick informatik uni marburg de 
part done mainz 
inria rocquencourt le chesnay cedex france 
mail luc inria fr 
languages languages de nable rst order logic fo precisely star free languages 
survey see 
alternative approach de nability strings classical nite model theory nite model theory dates back 
considers nite structure consisting set functions predicates constants look de nable sets form rst order formula language known result links de nability traditional formal language theory 
reg consist unary functions binary predicates el 
el states length states pre len model reg explain notation 
subsets de nable len precisely regular languages implies decidability rst order theory len :10.1.1.32.9967:10.1.1.32.9967:10.1.1.32.9967
key advantage model theoretic approach immediately gets extension notion recognizability string languages ary string relations arbitrary gets algebra ary string relations algebras automatically closure projection product addition boolean operations 
case model len algebra new fact de nable ary relations exactly ones recognizable natural notion automaton running tuples 
refer nable relations regular relations formal de nition subsection 
show restrictions model len gets new algebras regular relations behave better ways full algebra recognizable relations len introduce models show de nable sets models enjoy superior model theoretic properties relative full algebra recognizable relations associated len key motivation nding closed algebras string relations comes eld databases particular study query languages interpreted operations 
string manipulation facilities long recognized critical component realistic database query language 
sql example clause contain string pattern matching expressions faculty name nen 
expressions seen queries string relations clause example seen selection performed projection faculty relation 
relational calculus gives satisfactory formal model sql queries absence built datatypes far satisfactory model fully accounts string queries 
lack adequate formal model related fact sql restricts interaction string operations relational operations number ad hoc ways apply operator subquery build new query take product string expressions built 
natural way obtain calculus string relations freely compose string operations relational operators start decidable structure strings mentioned extend query languages adding free predicate symbols way traditional relational calculus obtained rst order logic pure equality 
approach see corresponding len restricted models mentioned obtain interesting compositional query languages strings 
main parts 
rst part study de nable algebras string relations model theoretic structures de nability structures 
focus structures model len mentioned richest 
second part deal database applications study corresponding query languages string databases structures 
thought de nability modeltheoretic structures nite relational database 
naturally results rst part form basis reasoning string query languages 
summarize developments parts 
mentioned know exists regular string algebra algebra exactly captures regular sets restricted unary relations :10.1.1.32.9967
obvious question ask new algebras string relations arise model theoretic approach 
particular restrict signature expressive reg get new relation algebras lying recognizable relations 
natural starting point nd signature captures properties star free sets 
simple example leaps consider signature sf sf easily show de nable subsets exactly star free ones 
furthermore show de nable ary relations model exactly de nable regular pre automata cf 
underlying string automata counter free 
just signi cant di erence complexity theoretic behavior regular languages star free languages ac nd model tractable terms model theory complexity len particular show quanti er elimination natural relational extension len 
tempting think len canonical extensions notions regularity star free ary relations 
show fact choices share dimensional de nable sets star free regular 
furthermore algebras de nable sets may identical terms string languages de ne di er considerably ary string relations de nable algebra 
say algebra de nable sets reg regular algebra de nable sets subsets dimensional de nable sets exactly regular sets 
likewise say algebra de nable sets star free algebra de nable sets subsets algebra exactly star free sets 
study new examples regular star free de nable algebras 
give example star free algebra considerably expressive power basic star free algebra model denote left allows add characters left string shares desirable properties particular quanti er elimination natural language membership test algebra low complexity 
surprisingly give examples regular algebras denote reg reg left strictly contained len reg dimensional sets algebras regular sets algebra shares attractive properties languages 
particular give quanti er elimination results algebras 
contrast result giving partial answer open question asks len quanti er elimination reasonable signature 
show quanti relational signature bounded arity quanti er elimination signature containing binary functions 
turn second part studying string query languages formed models 
properties desire string query language 
problem faced combining string pattern matching queries relational calculus pattern matching expressions may return nite number strings 
standard issue safety 
previous proposals combining relational algebra string matching primitives tackle problem identifying safe fragments languages number syntactic restrictions see capture safe fragment language syntactically 
second issue string query language expressive power 
query languages designed prior literature turn turing complete feature turn sorts analysis optimization impossible 
noted adding just concatenation relational calculus yields query language turing complete 
immediately implies ective syntax corresponding safe fragment 
contrast languages ful ll criteria 
query evaluation ecient 
ective syntax capturing safe queries 
algebra equivalent language 
consider query languages respect criteria 
mentioned consider relational calculus rc model de ned rst part weakest model query language obtained adding database relations captures basic sql simple pattern matching lexicographic ordering 
show safe fragment model ectively captured natural way prove complexity bounds queries language match known bounds ordinary relational calculus 
rc unable express certain natural queries select 
xed character 
contrast query language rc len formed richest model 
extension greater expressiveness enables additional operations trimming adding symbols left right string similar pattern matching checking membership regular language 
show language satis es criteria rc len express np complete conp complete problems 
leads consideration intermediate languages rc left rc reg rc reg left 
nd languages satis es required criteria considerably extending expressive power rc 
related motivation approach study automatic structures subclass recursive structures introduced generalization automatic groups :10.1.1.32.9967:10.1.1.32.9967
automatic structure predicate de nable nite automaton 
precisely ary predicate letter letter automaton 
structures studied connection decidability questions rst order theories 
known structure automatic interpreted structure len len sense universal automatic structure :10.1.1.32.9967:10.1.1.32.9967
rst part seen study subclasses automatic structures de nable len signi cantly restrictive stronger model theoretic computational properties rich structure len structure left pre relation useful modeling queues rst appeared veri cation context algorithm deciding existential sentences 
algorithm extended full theory pre relation 
database side approaches unifying string algebras relational algebra developed prior literature 
concatenation operator operations logics undecidable general 
studied consequences adding pattern matching features sql 
papers proposed extension relational calculus alignment logics studied complexity expressive power 
restrictions de ne arbitrary set 
approach proposed considered datalog extended appropriate transducers string operations proved number completeness results 
arbitrary regions substrings queried coupled relational calculus gives power string concatenation 
closer approach study relational calculus algebra extended operation concatenating strings 
studies rst order logic term algebras extends expressive bounds complexity results relational calculus setting 
sql style string pattern matching expressed language language query strings xed symbol 
general approach studying databases interpreted domains closely related eld constraint databases 
theory constraint databases done continuous domains typically various structures reals 
contrast results viewed theory nite constraint databases discrete domains particular strings 
organization organized follows 
section gives notation 
deal de nability models strings particular quanti er elimination bounded vc dimension expressive power 
part contains database applications terms expressiveness data complexity safety corresponding query languages 
earlier presentation appeared conference proceedings 
notation denotes nite alphabet set nite strings 
consider number operations predicates 
concatenation strings pre 
adds ast character 

adds irst character 
length string longest common pre strings string 
exists 
alternative notation concatenation 
note el true jxj jyj 
write refer substring string starting position position rst position string number holds 
write 
write express extends exactly symbol 
pre stand pre closure fs cg 
denote fs jsj js cg 
set strings tree tree partially ordered structure generated closing words tree poset hfx gg 
note set strings indices set strings meet longest string fw sg meet element tree longest pre meet meet smallest element tree meet pre note meet de ned meet meet meet string tree unique smallest extension tree 
complete tree order description vector variables atomic diagram tree language words speci cation relations hold hold tree 
example aba 
aba ab tree ab aba 
complete tree order description consists relations hold elements ab aba relations aba ab aba ab shall consider structures basic structure equivalently unary predicates true strings having symbol 
note presence nable shall 
consider number extensions characters added left right 
structure denoted left def extension denoted len adds length comparisons el predicate note el express various relationships lengths strings jxj jyj constant 
summarize mainly deal structures left len eli 
consider regular algebras introduce structures operations motivated quanti er elimination results left structures de ned 
close connection len extension presburger arithmetic 
assume 
val binary considered string largest power divides de nable hn val val pg de nable len 
de nability left len give simple examples de nability structures 
matching expressed de nable subsets precisely star free languages 
example condition saying rst symbol third expressed formula say pre xes extending rst third penultimate positions string important operation expressible lexicographic ordering lex assume fa ordering 
lexicographic ordering lex expressed graph function de nable len jyj jxj jwj jvj jzj jvj juj de ned el 
strings structures shall classical results de nability strings represented nite rst order structures 
fa string represented structure signature jsj universe kg interpreted usual ordering set fi ith position sentence logic de nes language fs logic mso monadic second order logic languages arise way precisely regular languages 
logic fo rst order languages arise precisely star free languages obtained fa operations union complement concatenation 
databases query languages database schema sc collection relation names arity 
instance sc set interpreted nite subset active domain database adom set elements appear general setting query languages nite database nite underlying structure hu set operations functions predicates basic language consider relational calculus rst order logic schema sc denoted rc sc 
omit sc understood irrelevant 
focus exclusively string datatype example query tests string relation ends 
asks symbol exists pre largest proper pre symbol 
query rc sc write true 
write output say safe nite safe safe safety problem determine query safe known undecidable pure relational calculus 
state safety problem decide safe say safe queries rc ective syntax exists recursively enumerable set safe queries rc sc safe rc sc query equivalent ective syntax rst step algebraic language expressing safe queries 
language exists safe queries ective syntax 
ective syntax exists safe queries pure relational calculus classical relational theory result 
results positive negative proved 
collapse results establish strong expressivity bounds relational calculi 
formulate need important restriction queries quanti cation active domain 
quanti ers adom adom meaning follows adom 

adom opposed case usual quanti er similarly universal quanti er 
restricted quanti ers de nable relational calculus helpful available separately 
relational calculus formula called active domain formula quanti ers form adom adom 
say rc admits natural active collapse rc formula equivalent active domain formula 
say rc admits restricted quanti er collapse rc formula equivalent sc relations appear scope quanti ers adom adom 
note admits quanti er elimination notions coincide 
query generic commutes permutations domain 
active generic collapse states rc formula quanti cation form adom adom expresses generic query expressible linear order active domain predicates functions model theory background nite countably nite rst order signature model fo denote set rst order formulae language complete theory th set sentences fo true models elementary equivalent th th 
say admits quanti er elimination qe formula fo quanti er free formula true case show quanti er elimination model conversion quanti er free formula ective cases theorem give details ective versions 
tuple model tp type set formulae fo satis ed atp atomic type set quanti er free formulae fo satis ed 
subset tp type set fo formulae satis ed 
saturated model model consistent type type consistent witness model nite set fo satis ed known model elementary equivalent saturated model proofs ehrenfeucht fra ss games 
structures vocabulary write duplicator winning strategy round game agree sentences quanti er rank 
assume familiarity monadic second order logic mso 
proofs mso games write mso duplicator winning strategy round mso game similarly means structures distinguished mso sentences quanti er depth isolation vc dimension collapse review model theoretic concepts prove useful establishing bounds expressive power query languages 
theory model subset said pseudo nite unary predicate set formulae fo fpg satis ed nite sets elements model type subset isolates type containing complete theory said strong isolation property model pseudo nite set element nite subset tp isolates tp 
say isolation property countable exists 
isolation interesting property database context implies restricted quanti er collapse 
provide bounds vc dimension de nable families 
family subsets set set say shatters ff cg powerset vc dimension maximum cardinality nite set shattered arbitrarily large nite sets shattered 
concept fundamental learning theory nite vc dimension hypothesis space equivalent learnability pac learnability 
consider structure fo formula 
family sets ranges tuples called de nable family 
say nite vc dimension de nable family nite vc dimension 
particular implies learnability fo de nable families shall see connections isolation vc dimension collapse results 
complexity classes complexity results refer parallel complexity classes ac tc nc ac constant parallel time precisely class languages accepted polynomial size constant depth unbounded fan circuits 
tc additionally majority gates unbounded fan 
nc majority gates depth allowed logarithmic fan bounded 
known ac tc nc parity separates tc ac 
consider uniform versions classes uniform ac nite structures characterized de nability fo bit bit true jth bit binary representation 
capture uniform tc suces add counting quanti ers fo bit ph polynomial hierarchy contains np conp included pspace 
usual data complexity xes query considers complexity enc enc encoding databases tuples xed alphabet typically 
normally pure relational calculus encoding active domain considered kg number represented binary 
deal interpreted elements stored database encoding appropriate needs take account operations interpreted elements 
particular case strings nite alphabet consider encoding string case alphabet di erent may code letters rst 
model theory strings section study logical de nability len left structures de ning regular algebras particularly interested quanti er elimination results model theoretic properties isolation vc dimension give results expressive power relational calculi structures 
start strongest regular algebra len move star free algebra expressive star free algebra left quanti er elimination proof technically involved result section 
show expand left regular algebras losing nice properties 
regular algebra len subsection focus structure len assume alphabet contains letters 
letter alphabet easy see len reduces dealt subsection 
automata de nability letter letter automaton usual dfa alphabet 
tuple strings viewed word length max js alphabet jth letter tuple jth letter js 
say predicate de nable letter letter automaton accepts mentioned len eli canonical automatic structure relations de nable len precisely regular relations ary de nable relations precisely letter letter automata :10.1.1.32.9967
particular gives normal form len formulae 
introduce new type length bounded quanti ers form jxj jyj jxj jyj 
formula jxj jyj meant abbreviation jxj jyj 
nite automaton simulated length bounded fo len formula conclude fo len formula equivalent length bounded fo len formula 
note result shown directly ehrenfeucht fra ss game argument 
quanti er elimination universal property len mentioned indicates len may rich relations applications 
evidence addressing open question len quanti er elimination reasonable signature 
rst needs de ne reasonable means 
clearly structure quanti er elimination suciently large expansion signature add symbols de nable predicates example 
take reasonable mean nite expansion satisfactory example presburger arithmetic quanti er elimination nite signature mod 
note example maximum arity predicates functions 
fact appears common phenomenon proves quanti er elimination nite signature upper bound arity functions predicates 
view condition necessary signature reasonable 
general reasonable signature contain relation symbols function symbols 
rule possibility signature function symbols arity len quanti er elimination 
contrast weaker structures consider quanti er elimination relational signature bounded arity 
len expansion len de nable predicates arity de nable functions arity show theorem len qe 
len expansion len unary predicates binary functions qe 
proof 

assume 
de nable property expressed quanti er free formula de ned follows 
holds tuple strings position ith symbol 
clearly de nable len el assume boolean combination formulae depending variables 
formulae named free variable 
letter letter automaton maximum number states primes 


de ne words mod nite strings denotes kth position consider run kth input symbol 
position equal modulo positions input symbol 
input symbols positions 

consider positions equal modulo states nd numbers depending positions 

automaton state reading 

position 

automaton state reading 
state positions 


reads symbol states 
furthermore notice 



summing constants 
state positions 

max 
automata state positions particular denotes nite word consists rst positions agrees assumption boolean combination gives agrees impossible false position zeros true position symbols 
case suces notice quanti er free formula len equivalent quanti er free formula len instance de nable len relation equivalent len relation de ned 
proof 
assume contains symbols len expansion len de nable functions predicates binary functions bitwise strings respectively non inputs 
length add suciently right shorter string 
length result max juj jvj 
unary function bitwise string unary function fil fil position unary function pat pat length position unary functions obtained deleting rightmost symbol obtained deleting rst leftmost symbol unary predicate de ned 
ary relation de nable len goal nd quanti er free len formula tuple strings len know relations de nable len precisely regular relations precisely letter letter automata :10.1.1.32.9967
automaton alphabet state set qm fq initial state transition function set accepting states 
state behavior function function qm qm state behavior function encoded binary behavior string length follows 
position jm unary predicate holds strings 
encodes state behavior function 

blocks constant length predicates regular 
idea proof map block input length string describes behavior block 
accepts input expressed means predicates tuple minimal lm wj wj max jw jw 
im 
wj 
state reading starting initial state 
sucient nd len term 

construction described steps 
max de ned fil 
boolean operators abbreviations respective terms note max de nes string length ng consisting ones 
fil term max fil fil max fil 
symbol fil position automaton reads th symbol ready nish description 
simplicity describe case jf max multiple general case slightly complicated 
carry position jm tuple consisting strings length set expressed pat max fil fil shorthand jm denotes fold application formula says assume xed block size viewed centered lth position characters left right 
part formula checks blocks size centered equal test separately left right part corresponds variable element corresponds variable 
results tests shifted right left part block left right part order align centered position big bitwise true previous tests true block size centered equals rst part formula lters blocks interested keeping centered jm modulo second bitwise check possibilities jm modulo positions equal corresponding block string desired 
rst bitwise ensures cover positions 
vc dimension result shows model theoretic learning theoretic shortcoming len single formula de ne widely varying collection relations parameter vary 
formalize notion vc dimension 
proposition de nable families len nite vc dimension 
proof 
el 
corresponding de nable family len string ng 
shattered subset string length ith character len arbitrary shows nite vc dimension 
star free algebra turn obvious analog len star free sets 
model basic model studied 
show remarkably nice behavior admits ective qe small extension signature 
immediately tells de nable subsets precisely star free languages 
characterize dimensional de nable relations closure properties automaton model 
note close strings considered term algebras wellknown theory arbitrary term algebras decidable admits qe 
adding pre relation necessarily trivial addition arbitrary term algebras pre subterm existential theory decidable full theory undecidable similar results hold orderings terms 
undecidability result requires binary term constructor results indicate simpler case strings recovers qe pre relation 
normal form start result gives normal form formulae fo 
need predicates introduced 
pl set pairs strings lemma obvious known star free sets rst order de nable string models 
lemma star free language formula fo de nes pl give normal form result fo 
proposition formula fo ectively transformed equivalent formula disjunction formulae form complete tree order description conjunction formulae form star free term form implies immediate successor tree order 
proof 
proof induction structure base case induction handled noting atomic formulae binary basic formulae 
simple cases 
note conjunction formulae form gt negations terms nitely complete tree order descriptions consistent furthermore ectively 
conjunction formulae normal form put form conjunction formulae 
normal form may imply immediate successor tree order 
case choose term 
decomposition argument similar proof theorem exists nite sequence pairs star free languages equivalent 
propagate disjunction repeat process formulae form implies immediate successor 
shows boolean combination formulae normal form put normal form 
nontrivial case 
induction assume required form 
ij tree order descriptions ij form 
suces show eliminate complete tree order description star free term implies immediate successor tree order 
assume loss generality pair terms formula form conjunction take intersection languages formulae terms star free 
furthermore assume sets add extra variable set 
restriction complete tree order description tree implied 
consider cases depending relationship tree implied 
assume implies node tree case term form rewritten term uses variables formula form equivalent disjunction formulas result eliminating equivalent disjunction formulas form 
second case implies pre meet node tree 
case may formula form conjunct case handled just previous need deal formula formula case mentions 
existence satisfying guaranteed exists string rst symbol 
pre string replace conjunction immediate successor uy tree order disjunction symbols 
remaining cases need fact star free languages closed concatenation 
star free languages exists star free language true strings case string proof straightforward fact star free languages precisely rst order de nable string models 
consider case implies pre closure node tree 
nodes tree nodes tree notice term involves rewritten equivalent term variables formulae form terms mention star free equivalent lm big conjunction formulae terms mention claim star free language equivalent shows put required form 
case speci es pre closure meet tree string nodes tree 
consecutive nodes uy uy tree particular formulae uy conjuncts star free languages may assume subformulae form mention conjunction subformulae 
equivalent plays role disjunction ensures rst letters di erent 
fa obtain equivalent eliminated just previous case 
concludes proof 
give illustration normal form 
suppose formula 
words proper pre letter language consists strings pre star free languages de nable fo formula string models 
produce normal form consider di erent possibilities state meet corresponding tree belongs formula quanti er elimination expansion signature contains binary predicate pl star free language note de nable expansion additional functions predicates de nable 
normal form immediately obtain theorem admits quanti er elimination 

mentioned need nest operator 
turned relational signature admits quanti er elimination follows 
star free set tuples strings pl 
note expressed 
straightforward check signature admits quanti er elimination 
way quanti er elimination results remainder turned quanti er elimination results relational signature 
note considered expansion functions predicates signature 
case predicates needed 
corollary normal form language suces bounded quanti cation 
introduce bounded quanti ers form means fo restriction fo formulae quanti ers form qx normal form fact de ned bounded quanti ers obtain corollary fo fo 
characterize de nable subsets subset permutation kg mean set rg 
corollary language de nable star free 
class relations de nable fo minimal class containing empty set fag closed boolean operations cartesian product permutation operation de ned 
proof 
formulae free variable boolean combinations pl star free de ne star free languages 
direction notice fag de nable fo fo closed boolean operations permutation cartesian product 
closure easy consequence lemma corresponds direction follows normal form 
note projection operation needed closure result 
automata give automaton model characterizing de nability fo 
automaton model corresponds exactly counter free variant regular pre automaton de ned 
recall de nition regular pre automata 
nite non deterministic automaton strings state set transition relation initial state construct automaton accepting tuples 
strings way 
subset denotes accepting states pre set pre xes run mapping pre assigns node pre state implies 
run accepting 
tuple accepted accepting run see details 
nite non deterministic automaton corresponding automaton called regular pre automaton rpa 
subset de nes called regular pre relation 
say counter free cf pa counter free 
shows relations de nable fo exactly recognizable cf pa proposition relation de nable fo de nable counter free pre automaton 
proof 
direction follows corollary easy verify counter free pre automata recognize empty set fag vg uu wg closed boolean operations cartesian product permutation 
opposite direction cf pa accepting relation arity show de ned fo formula 
set states states set strings get state state reading counter free star free language 
formula disjunction formulae cycles complete tree order descriptions 
formula disjunction possible assignments states strings tree 
assignment checks vector states accepting states consistent pair successive elements tree path ful lls pl states assignment consideration respectively 
vc dimension isolation de ned notions isolation vc dimension section notions important database part provide strong bounds expressiveness various relational calculi 
notion nite vc dimension coming originally statistics machine learning independent interest states families de nable structures strings learned ectively 
seen len nite vc dimension 
turns structures consider nite vc dimension 
prove introduce new machinery 
show nite vc dimension 
lemma model isolation property 
de nable families nite vc dimension 
proof 
give proofs result complexity theoretic model theoretic 
start complexity theoretic proof 
assume nite vc dimension 
independence property single formula fact independence property set size consider expansion unary predicate binary predicate 
vu rst conjunct says graph nodes set second says assuming subsets edges 
nite subset says connected 
isolation property implies expressed sentence form qz qz nite boolean combination atomic formulae formulae language mapping ng appearing de ne ng contain tuples true 
sentence language form qz qz obtained replacing 
true 
follows graph ng connected 
implies connectivity non uniform ac false 
concludes proof 
second proof 
give model theoretic proof 
formula set type maximal consistent th set formulae form tuple talk type denoted tp 
formula show integers nite set types prove rst claim formula integer nite set vector element subset tp isolated tp 
assume exists nite set vector nite subset size tp isolated tp 
compactness get pseudo nite set vector model th nite set tp isolated tp 
compactness get model th pseudo nite set countable subset tp isolated tp contradicts isolation 
zj easy see 
jaj subsets size xed set size zj formulae form types type vector determined choice set type isolates type follows types 
family de nable 
nite set shattered members number types jaj arbitrarily large nite sets shattered show 
proposition th strong isolation property 
proof 
model th pseudo nite set elements exhibit nite subset tp isolates tp 
note nite set elements meet meet meet described means formulae fo meet largest pre pre closure meet meet nodes tree meets elements closest meet 
elements exist pseudo nite 
meet meet 
take fw know formulae fo put normal form described proposition 
type entirely de ned tree structure paths de nable nodes tree 
conclude paths meet meet meet completely de ne tp 
tp describes paths meet meet meet result follows 
combining proposition lemma conclude model len learnable de nable families 
corollary de nable family nite vc dimension 
star free algebra left study example star free algebra ary relations algebra complex de nable recall left structure add characters right left 
pre relation structure studied model queues 
quanti result proved extending quanti er elimination term algebras fact showed term algebras queues admit qe 
case di ers strings terms algebras pre relation pre relation complicates things considerably 
start easy observation fo left expresses relations fo 
graph 
expressible fo shown simple game argument 
precisely number rounds consider game tuples 
corollary sucient play pre xes participating strings 
duplicator trivial winning strategy strings known winning strategy versus quanti er elimination left extension left de nable functions predicates added constant empty string binary function longest common pre predicate pl star free language unary function 
de nable 
theorem left admits quanti er elimination 
rest section prove theorem 
left rst order signature left respectively 
saturated model left elementary equivalent left suces prove quanti er elimination note nite nite strings 
need standard result claim exists formula admit quanti er elimination exist tuples elements atomic type type 
proof claim 
fo left enumerate quanti er free formulae left realizable type asserting 
show equivalent quanti er free formula satis ed contradiction assume satis ed saturated compactness follows nite set 
holds fi get contradiction show equivalent tuple 
fi tuple satis es 
choice conclude 

hand de nition follows immediately implies 
equivalent desired contradiction 
claim proved 
prove qe show tuples elements atomic type type 
de ne nice term left term form meaning nite strings 
de ne relations tuples length strings follows 
tuples sequences ng sequences nice terms atp atp tuples strings sequences ng sequences nice terms atp atp course implies identity nice term 
show relations coincide 
show lemma stronger result needed claim order prove theorem 
show back forth property 
order simplify strategy game rst show lemma strategy game 
lemma proved rewriting rules atomic formulas get rid nice terms containing lemma 
equivalence established show back forth property quanti er elimination follow 
proof lemma 
start observations 
easy see atomic formula fo left equivalent fo left formula term meet nice terms addition subtraction pushed back multiple meets eliminated adding disjunctions tree ordering formulae considering possible cases 
notice atomic formulae form terms equivalent equivalent 
assume symbols occur 
call nice term empty 
proof lemma done rewriting atomic formulas order get rid nice terms variables 
proceed case analysis rewriting rules claims 
rst claim shows replace single nice terms distinguished variable proof straightforward 
claim 
nite strings star free 
pl true conditions holds 
pl 
notice rst case nite condition expressible fo 

nite strings star free 
pl true conditions holds 
pl 
claim shows get rid terms form distinguished variable claim element nice term left quanti er free fo formula hold proof claim 
nite strings nite expressed fo 


nite jaj jbj 
possible de ne fo formula true maximal jyj jyj 
easy verify holds implies 
quanti er elimination fo quanti er free 
analog preceding claim terms form 
claim nice terms star free 
assume strings pl holds 
fo formula holds implies pl 
proof claim 
pl holds claim 

pl 
consider rst case 
notice implies nite string 
second condition says star free set strings rst condition holds pre nite case easily expressed fo 
consider second case 
conditions easily expressed fo 
remains express pl 
assume rst term nice show pl expressed 
distinguish subcases 
nite corresponding fo formula obtained similarly previous case 
assume nite 
case pre holds sucient express sux relative pre length js jbj jaj clearly expressed fo 
fo formula 
holds call functional de nes partial function holds 
note claim functional 
call term form functional function term left signature obtained left adding function terms 
claim shows attempting eliminate terms distinguished variable suces deal terms particularly simple form 
claim element atomic fo left formula quanti er free fo left formula holds holds 
ensure appears terms form nice terms function terms 
furthermore arrange function terms function terms proof claim 
mentioned assume contains terms form nice rst show atomic formula replaced equivalent formula quanti er free fo formulae nice terms 
prove statement consider cases 
case 
case subcases 
proceed case 

case incomparable 
just consider formulae form 
completely analogous way replace formula form 
claim functional fo formula holds holds 
subformula replaced 
reasoning course transform formulae 
return proof lemma 
assume 
recall theorem strings satisfy exactly atomic formulae agree fo formulae 
claim prove agree atomic left formulae terms form nice terms 
atomic left formula terms terms form 
assume holds case holds completely analogous 
distinguish cases 
case 
term contain forms pl pl pl pl follows claim subcases get rid term adding term 
important nice term fo expressible property 
claim follows assumption 
case 
form pl 
claim fo formula holds implies pl ut assumption follows pl holds 
case 
form pl form pl 
claim assume empty 
recall de nition function terms 
applying claim take term empty get fo formula holds holds holds 
claim follows assumption 
case 
terms form 
case get equivalent fo formula rst applying claim get rid symbol applying claim 
concludes proof lemma 
come back proof theorem 
prove stronger needed quanti er elimination 
lemma back forth property mentioned proof theorem statement theorem follows lemma type form atp atomic type left goal show 
lemma nd 
compactness suces show nite sequences terms sequences atp atp sequences xed 
tree ft kg 
corresponding tree meet meet meet 
note strings meets terms image model corresponding term image notice inductive hypothesis guarantees ordering relation meets terms preserved look image terms inductive hypothesis tells equivalent string models models usual string signature plus extra predicate shorter string terms satisfy atomic formulae include pl pairs elementary equivalent string models 
string exists quanti er elimination theorem implies elementary equivalent language equivalence extends 
clear suces 


obviously elementary equivalent string models 
check want 
show meet meet meet respectively star free language pl pl pl pl pl pl 
easily follow de nition nishes proof lemma theorem 
previous theorem get corollaries 
back forth property gives normal form fo left formulae 
corollary fo left formula fo formula nite set nice left terms holds left corollary empty tuple corollary imply corollary subsets de nable left precisely star free languages 
formulae language left opposed left show bounded quanti cation suces notion bounded quanti cation slightly di erent previous section 
pre closure fs js js pg 
clearly de nable left de ne fo left class fo left formulae quanti cation form free variable arbitrary 
corollary fo left fo left 
isolation vc dimension show results isolation vc dimension extend left proposition th left isolation property 
proof 
model th left pseudo nite set elements tp 
exhibit countable subset tp isolates tp 
nite tuples nite strings fw fg 
elements meet likewise meet take fw union taken nite tuples nite strings 
clearly countable 
claim tp isolates tp 
suppose tp tp 
note construction de nition tp implies meet meet 
implies type meet similarly type meet meet type meet meet 
want show tp tp 
quanti er elimination theorem left suces show atomic types left meets paths meets meet meet follows atom form pl holds nice terms direct predecessor tree de ned holds normal form queries proposition conclude atp atp nite claim get tp tp atomic types left required 
lemma obtain 
corollary de nable family left nite vc dimension 
regular algebra extending previous sections star free algebras attractive properties 
give example regular algebra signi cantly expressive power rich structure len shares nice properties isolation nite vc qe star free algebras previous sections 
algebra obtained considering possible ways extending fo rst adding predicates pl regular languages predicates pl hold regular language 
second extension monadic second order logic rst order logic 
turns extensions de ne exactly algebra 
show show resulting regular algebra shares qe vc dimension properties star free algebras de ned previously 
reg regular de nes arbitrary regular languages proper extension fo reg de nable set de nable len predicates pl de nable len easiest way see characterization len de nable properties letter letter automata 
proposition subsets de nable reg precisely regular languages 
reg extension reg results section straightforwardly lifted reg reg example normal form proposition holds reg replaces star free regular proof section applies verbatim 
fact similar normal form arguments slightly di erent form 
obtain theorem see reg admits quanti er elimination 
normal form result shows functions predicate el de nable reg seen fact reg qe relational signature bounded arity len suces apply normal form results pairs strings form 

impossible check sequences zeros length 
show case bounded quanti cation pre xes sucient 
furthermore close connection fo de nability reg mso de nability shown mso fo reg result show ws de ne relations nite binary tree 
refers monadic second order theory nite binary tree ws weak monadic theory monadic second order quanti cation restricted nite sets 
note follows sets arbitrary relations de nable ws 
result follows subsets de nable mso reg precisely regular languages 
automata model isolation vc dimension proved regular pre relations de nable regular pre automata rpa introduced section exactly de nable mso 
results give characterization fo reg 
corollary relations de nable fo reg exactly relations 
relation de nable fo reg recognizable rpa 
proof isolation property proposition una ected change star free pl regular pl obtain corollary th reg isolation property de nable families reg nite 
regular algebra extending left give nal example regular algebra 
reg left common expansion left reg regular reg express functions left de ne arbitrary regular sets see reg left proper expansion reg left furthermore reg left de nable sets len de nable niteness vc dimension reg left shown implies containment proper 
reg left common expansion left reg expansion reg left techniques previous sections show theorem reg left quanti er elimination 
furthermore th reg left isolation property de nable families reg left nite vc dimension 
proof 
sketch proof qe 
done simply mimicking proof theorem role played reg saturated model de ne equivalence relations proof theorem atomic type respect reg show 
done proving modi cation claims substituting uniformly reg left left reg property star free languages claims just star free strings set star free :10.1.1.32.9967
clearly holds regular substituted uniformly star free 
show back forth property implies qe 
proof elementary equivalence string models rst order logic consider elementary equivalence monadic second order logic 
similarly left derive proof theorem normal form reg left formulae corollary fo reg left formula fo reg formula nite set nice left terms holds reg left seen earlier mso fo reg ask similar result holds insertion left allowed mso left fo reg left 
mso theory left undecidable certainly ective translation 
fact easily see di erent 
function 


fo de nable left easily see weak mso left set quanti cation restricted nite sets de nes non regular set 
conclude section showing arithmetic properties de nable structures left reg reg left weaker de nable len mentioned earlier binary encoding len gives extension presburger arithmetic de nes largest power divides reg left weaker proposition successor order addition de nable reg left reg left 
proof 
order de nable addition successor order suces show successor de nable 
binary encoding successor show de nable reg left assume corollary get set nice terms formula reg true suciently large consists strings form 
depend 



formula reg length true big 
show suciently large depending true xm true 
clearly suce 
normal form reg analogous proposition pl regular 
note suciently large tree 
isomorphic tree tree 

particular predecessor xm tree meet 
say 
meet pre 
string jc depending 
true replaces 
pl formula describing segment xu normal form may assume formula combine intersection languages 
pick follows description meets exist 
immediate normal form result nishes proof 
table summarize results section 
string query languages goal section study relational calculi structures considered previous section 
note previous research string query languages qe relational signature qe relational signature left reg left reg len star free algebras regular algebras relationships left reg reg left len structure signature expansion expansion quanti er elimination name len el unary relations len binary functions star free left left star free reg regular regular reg reg left regular reg left regular de nition pl pl table summary quanti er elimination results concatenation main string operation 
give simple results indicating main goals getting low complexity language adequate notion relational algebra achieved include concatenation primitive 
explain operations left reg reg left len related sql string operations properties relational calculi structures 
model theoretic properties structures established section 
problematic concatenation earlier papers considered relational calculus concatenation rc concat rc sc operation concatenation constant symbols 
language extremely attractive terms compositionality queries returning sets strings substitute regular expressions form new queries 
noticed rc concat expresses computable queries databases containing strings see proof 
fact easy show somewhat stronger result requires letters 
proposition contain letters 
rc concat expresses computable queries databases proof 
rst show computable predicates expressible 
follow lines chapter iii theorem uses extra symbol encode turing machine computation rc concat turing machine :10.1.1.32.9967
fq 
set states initial state 
step execution input con guration represented string tape content left head content current position positions right current position current state 
formula rc concat states existence string represent computation done follows 



substring represents con guration executing step con guration represented 
accepting state points enumerated checked rc concat 
easy see existence string equivalent acceptance order remove extra symbol formula states existence string form strings contains substring 
computation nite string exists easily distinguished formula states existence string form 
condition changed analogously 
computable predicates expressible mapping image addition multiplication expressible fo 

known see chapter relational calculus hn 
expresses computable queries nite databases simply coding nite databases numbers 
coding apply rc concat showing expresses computable queries 
databases accustomed relational calculus having limited expressiveness queries analyzed optimizations discovered 
certainly case hope nding syntax safe queries 
corollary contain letters 
ective syntax safe queries rc concat furthermore state safety problem undecidable rc concat proof 
follows 
proposition rc concat turing complete structure safe syntax safe queries state safety undecidable de nable 
note symbol 
essentially hn exists ective syntax safe queries state safety decidable 
basic string operations sql looking existing sql string operations operation patternmatching 
allows say example string pre string string xed string substring 
patterns built alphabet letters characters matches string including matches single letter 
example pattern ab matches string rst letter second fourth matching expressed rst order logic de ne star free languages fo de nable important sql string operation lexicographic ordering lex saw earlier expressible sql allows trimming adding symbols left right string 
know trimming adding symbols right operation inverse expressible adding trimming left operation inverse 
motivated study structure left corresponds pattern matching lexicographic ordering arbitrary trimming adding operators sql 
operator checks membership star free language 
new sql standard introduces arbitrary regular expression pattern matching new operator called similar 
adding operator corresponds going reg left reg left cases addition means dimensional de nable families regular star free 
sql string length operation called len 
return string turn pure string operation compares lengths strings el true jxj jyj 
len corresponds set sql operations includes lexicographic ordering length comparison 
furthermore len subsumes left reg reg left operator similar trimming adding left expressible len expressive power complexity section study expressiveness complexity relational calculi 
obtain number collapse results isolation property shown rst part establish complexity bounds cases collapse 
relational calculus goal get bounds expressiveness data complexity queries rc 
main tool collapse result theorem spirit produced constraint databases 
recall relational calculus domain rc admits restricted quanti er collapse rc sc formula equivalent formula sc predicates occur scope active domain quanti ers adom adom 
admits natural active collapse formula equivalent active domain quanti ers 
mentioned isolation property implies restricted quanti er collapse 
qe get theorem rc admits restricted quanti er collapse rc admits natural active collapse 
quanti er restriction result corollary 
extend rc sc quanti ers form adom adom meaning follows 
formula interpretation database adom states exists string making true component adom 
bounded quanti cation suces formulae corollary obtain corollary rc sc formula equivalent formula uses quanti ers adom adom 
note straightforward corollary theorem shows data complexity rc matches pure relational calculus 
corollary data complexity rc ac particular parity connectivity test expressible rc 
proof 
corollary assume query form adom wv atomic negated atomic sc formula formula quanti cation restricted pre xes proof follows standard proof ac data complexity relational calculus see example prove formula evaluated ac suppose formula quanti cation restricted pre xes associate structure signature consisting unary predicates binary predicate follows domain mg jz interpretation standard 
rst jz elements belong followed element belongs followed jz elements belong membership determined corresponding symbol show evaluated ac show fo bit done straightforward induction structure encode pre relation de nability fo bit corollary concerns expressive power generic queries 
recall query generic commutes permutations domain words independent speci elements stored database 
query expressible pure relational calculus generic 
examples generic queries parity test graph connectivity test known inexpressible relational calculus 
combining theorem active generic collapse obtain corollary generic query expressible rc expressible rc calculus ordered databases 
respect time complexity corollary gives polynomial upper bound 
show unary databases get stricter complexity result 
call database schema sc unary contains unary relation names 
show queries unary databases evaluated linear time 
unary database transformed tree query transformed rst order sentence tree evaluated tree automaton 
precisely proposition sc unary 
boolean rc sc query evaluated linear time size database 
proof 
sc unary 
de ne representation sc databases nite labeled trees follows 
rm relation names sc 
simplicity 
fx set variables 
nite database sc vector strings nite tree de ned follows 
set vertices pre 
vertex labeled vector vertex labeled subset pointed leaves carry label non zero entry label empty set 
straightforward rc sc formula pre quanti cation rstorder formula labeled trees represented nite structures usual way sc database vector strings case boolean queries equals 
known mso sentences evaluated linear time labeled trees simulation suitable tree automata see conclude desired complexity bound 
lemma results follows safe unary rc sc queries free variable evaluated linear time size database 
combining techniques shown general ary queries evaluated time databases size relational calculus len seen query evaluation relational calculus low complexity 
useful queries low complexity query appends xed string left column expressible examine addition equal length predicate relational calculus len section assume alphabet symbols symbol alphabet equal length simply equality give extra power 
analyze expressive power complexity len normal form result queries 
case longer sucient quantify pre xes strings active domain di erent restricted quanti cation suces 
introduce quanti ers jxj adom jxj adom interpreted follows 
formula database interpretation subformula jxj adom 
satis ed exists string satisfying 
length exceed length longest string adom call length restricted quanti ers 
note just notational convenience expressed rc len 
capture expressiveness rc len proposition rc sc len formula equivalent formula uses quanti ers 
proof 
sc database tuple strings notation fs adom js structure universe language len plus sc relations plus constants elements write len structure language universe maximum arity relation name sc 
write duplicator winning strategy round ss game len len duplicator winning strategy round ehrenfeucht fra ss game 
claim re nes ehrenfeucht fra ss theorem cf 
implies result equivalence relations nite index class de nable quanti ers rc len query quanti er rank union classes 
describe winning strategy duplicator moves game len len 
maximum length string 
response move say len spoiler duplicator produces addition response len extra elements 
done follows 
suppose rounds played spoiler plays len 
cases 
duplicator looks position game selects winning strategy 
sets case ja pre length duplicator looks con guration game selects response note length duplicator play game moves move response string length string length moves spoiler able choose extension strings length witnessed strings duplicator suitable response 
set 
relative sux follows immediately strategy ensures win duplicator round game len len 
pre restricted quanti cation suce rc len 
consider query unary relation true contains single element length 
expressible rc len 
el xu expresses exactly 
note predicates expressed recall de ne star free language len regular language 
query inexpressible just pre quanti cation single element databases contained predicate el replaced equality 
set strings length de nable language star free contradicts fact languages de nable exactly star free languages corollary 
theorem proposition get rough upper bound complexity rc len compared corollary proposition corollary data complexity rc len ph 
proof 
check quantify strings length exceed maximum length string adom see proposition 
alternation depth done polynomial time alternating turing machine alternations ph 
result establishes bounds 
rst complexity generic queries rc len 
complexity language enc generic 
complexity bound useful proving expressibility results 
relational boolean query set isomorphism types sc databases sc relations 
relational query ac ac usual relational encoding enc elements element active domain encoded binary cf 

relational query expressible rc len rc len sentence sc isomorphism type 
theorem data complexity generic queries rc len tc furthermore relational query expressible rc len ac proof 
loss generality consider boolean queries assume 
string number 
binary 

note strings length ranges jsj js implies 
call database nice set fn adom form ng 
note maximum length string database dlog 
claim boolean generic query evaluated ac nice databases 
proposition loss generality quanti ers assumed length restricted 
nice database associate new database schema universe ng fn adom show expressed fo bit nice 
suce prove claim encodings identical fo bit 
recall de nition bit section 
recall usual arithmetic predicates ternary predicates de nable fo bit 
main problems rst quanti cation restricted maximum length string nice databases quanti ers range ng second show operations len expressed 
deal rst problem assume prenex form replace quanti er quanti ers string length exceeding represented uniquely numbers note jsj 
new pair quanti ers add formula stating satisfy conditions done fo bit expressible says largest power exceed expressible bit 
show translate atomic negated atomic subformulae 
subformula form sc translated checking simply bit bit 
el check largest power exceeding 
happens case jsj juj equal case active domain max power ranges comparisons 
conditions expressed fo bit consider predicate cases 
false active domain length 
similarly false 
third case case active domain formula states bit bit formula bit bit expressing length case active domain 
reduce previous case follows immediate predecessor relation note length predecessor active domain state condition previous case applies test check number immediate predecessor consider subcases 
rst subcase odd tested bit 
case test note fo bit test done subcase test done 
shown boolean query evaluated ac nice databases 
boolean relational query expressible rc query family circuits computes nice databases 
relational database enc standard encoding elements active domain size coded integers binary 
arbitrary relational database consider enc input nice database strings obtained replacing ith element active domain string enc enc returns 
genericity implies ac remains show data complexity generic queries rc len tc generic query de nable rc len 
database nice database obtained follows adom fs lex lex nice replaced string note transformation carried tc lex ac corollary counting number elements satisfying formula done tc 
furthermore genericity nice checked ac gives tc upper bound data complexity generic queries 
theorem proved 
draw de nite rst statement theorem tc separated np widely believed properly contained 
second statement known lower bounds ac give corollary parity test connectivity test de nable rc len 
prove lower bounds show complexity len queries ph may prohibitively high 
mso sc class queries sc expressible monadic secondorder logic 
includes queries high complexity level polynomial hierarchy ph complete queries particular np complete conp complete ones colorability complement 
queries expressed arbitrary databases rc len nice ones expressed additional assumptions 
say width active domain sc database maximal size subset adom elements pairwise incomparable pre relation 
noted database transformed database width isomorphic respect sc predicates 
proposition xed mso sc expressible queries expressed databases width rc sc len 
proof 
assume loss generality 
database width set maximal elements fs adom cardinality pre union chains pre pre pre fs sg 
idea proof subset pre modeled string length pre length js ends 
suppose mso sc query 
assume expressed mso sentence quanti ed second order variables distinct 
fresh rst order variables interpreted maximal elements adom 
associate second order quanti er new rst order variables de ne transformation 
subformulae atomic subformula second order variable unchanged 
subformula replaced de ned el rst order variable 
subformula replaced de ned el result transformation open rc len query 
de ne boolean rc len adom adom adom stating list necessarily distinct maximal elements adom holds 
database width means holds list maximal elements adom happens 
computationally complete rc concat rc len express queries normally expected expressible rst order language 
recall linear time bound evaluation boolean rc queries unary databases 
show case rc len 
worse xed polynomial bound 
consider ordered graphs nite structures universe form ng natural order relation binary relation sc database schema unary relation name lemma rst order formula ordered graphs rc sc len formula algorithm computes graph sc database dg dg furthermore algorithm works time log graphs vertices maximum length string dg dlog ne consequently size dg log 
proof 
give proof 
ordered graph vertices dlog ne 
de ne dg follows 
denote lexicographically rst strings length de ne set fa fa 

ng fa 

intuitively strings represent vertices edge vertex vertex 

vertices 

get 

straightforward check dg desired size produced time log assuming suitable representation formula obtained follows 
subformulas form replaced adom 
intuitively quanti cation restricted minimal elements active domain dg note steps introduce new unrestricted quanti ers 
atomic formulas replaced atomic formulas replaced el 
states existence strings form second line formula straightforward check dg follows lemma linear xed polynomial bound evaluation boolean rc len queries unary databases imply xed polynomial bound data complexity rst order sentences ordered graphs 
imply xed polynomial bound evaluation rst order sentences bit structures cf 
turn separate rst order logic xed point logic structures imply validity ordered conjecture various consequences complexity theory see discussion 
conclude connection linear time evaluation rc len queries unary databases impossible 
expect proof simple proposition rc 
relational calculi left reg reg left calculi behave similarly rc complexity bounds slightly di erent 
isolation property shown structures qe results conclude theorem rc left rc reg rc reg left admit restricted quanti er collapse 
furthermore rc left rc reg rc reg left admit natural active collapse 
corollary rc left queries ac data complexity rc reg rc reg left queries nc data complexity 
furthermore generic query expressible rc left rc reg expressible rc proof 
proof ac bound corollary need show xed left formula evaluated ac quanti er elimination result quoted proof theorem suces show xed quanti er free formula left evaluated ac notice left term evaluated ac :10.1.1.32.9967
operations available rest follows proof reg collapse result proof rc queries active domain quanti cation evaluated ac nc 
di erence evaluating pl predicates longer done ac may star free 
regular language nc pl evaluated nc inputs showing data complexity rc reg nc proof reg left combines proofs left reg statement follows collapse result 
note contrast proposition implies relational calculus len contains problems complete level polynomial hierarchy 
theorem key obtaining low data complexity 
follows isolation property underlying structure fails len nite vc dimension recall proposition 
safe queries relational calculi study contain queries produce nite output 
goals syntactically capture safe queries languages able analyze safety properties query example arbitrary query database tell output query database nite 
saw done set operations includes concatenation 
contrast structures syntactically describe safe queries give algebra captures queries extend major decidability results query safety analysis hold pure relational calculus 
ective syntax safe queries de ning niteness simplest way show safe queries rc ective syntax show test query returns nite result database 
ensure niteness de nable rc 
formally niteness de nable rc exists sentence safe language sc expanded single new unary predicate symbol query database safe nite 
example niteness easily de nable rc len el niteness de nable enumeration safe queries easily obtained 
query relational calculus query de nes active domain output 
safe boolean query obtained safe replacing 

safe lists safe queries 
traditional relational calculus analogs order constraints linear constraints polynomial constraints niteness easily shown de nable 
surprising rc approach proposition finiteness de nable rc 
proof 
prove proposition straightforward generalize alphabet 
consider databases unary predicate show ehrenfeucht fra ss game argument databases nite set nite set distinguished rc formula quanti er rank xed 
denote set strings length intuitively full binary tree depth formally 
denote equivalence round ehrenfeucht game structures denote equivalence round ehrenfeucht fra ss game strings 
claim 
claim exist depending holds 
loss generality choose multiple proof claim nitely equivalence class 
number 
pigeon hole principle exists integers show integers implies claim follow prove notice simply copies plus node 
similarly simply copies plus node 
fo strategy mimics strategy copy separately root played soon root played 
kn tm 
de ne nite set distinguished formula depth string homomorphism maps call string normal form 
call semi normal string set de ned set strings form uv normal string string length 
set 
note pre closed maximal strings length multiple strings pre write substructure consists strings pre strict pre analogously mod denote sequence unary relations initial segments natural numbers holds mod need lemma 
lemma semi normal strings normal strings pre pre jwj mod mod 
mod mod mod mod 
holds mod mod 
proof lemma 
intuitively tree tm consists path trees branching strings path 
de nition tree branching string path depth jzj congruent jz vj modulo jvj multiples precisely refer tree rooted child pre analogously string path tree depth jz branching longest normal string pre depth tree congruent jz modulo conclude claim branching trees equivalent jz vj jz congruent modulo combining winning strategy duplicator mod mod winning strategies branching trees get 
rst statement shown standard game argument fact concatenation strings length substrings identically labeled mod round game distinguished concatenation 
strings 
second statement follows directly rst 
shown standard argument 
show tm 
claim duplicator play round ehrenfeucht fra ss game way guarantees holds rounds game 
denote selected elements denote corresponding elements semi normal string normal string pivot strings 
pre pre 


jp denotes substructure strings strict pre omitted distinguished constant analogously 
proof claim 
noted normal contains nite part proof case pre pre condition conclude partial isomorphism game 
claim implies statement theorem 
prove claim induction choose 
guarantees 
assume rounds played hold 
show duplicator play way suitable choices holds 
distinguish cases 
case 
spoiler chooses vertex 
simply set follow directly 
case 
spoiler chooses string pre form 
set 


set 


subcases pre jp jp follows lemma subcases 
duplicator choose string guarantees winning strategy rounds 
combining winning strategy winning strategy obtain round winning strategy 
conclude 
furthermore course hold 
case 
spoiler chooses string pre maximal written 

string choose 



choice guarantees pre lemma follows subcases 
implies existence appropriate holds 
choice induction get 
completes proof proposition 
ective syntax safe queries range restriction post checking niteness way obtain ective syntax safe queries wishes explicit representation safe queries 
turns get natural representations safe queries rc rc len calculi 
technique derives safe languages linear polynomial constraints query effectively construct safe query gives upper bound nite 
explicit constructions prove theorem provide relational algebra extensions 
follow idea range restriction 
formula called algebraic set fa nite 
rc query range restricted form pair arbitrary query algebraic formula semantics adom 
adom fa xg 
clearly query range restricted form safe 
theorem left reg reg left len recursive set algebraic formulae query rc property range restricted query coincides databases safe 
proof 
proof number lemmas show query satis ed element suciently far adom returns nite result de nition suciently far depends particular structure 
need observations 
rst generalized version pumping lemma nite automata 
lemma sequence lm regular languages number string jzj strings uvw jvj string mg xuv proof lemma 
deterministic automaton transition function loss generality assume automata set ng states initial state 
nm string jzj jzj de ned pre length state reading rst symbols starting state jzj chosen uvw pre length length claim string xuv state 
uv uv 
accepted xuv accepted lemma show claim 
operations de nable len exists string jsj nitely strings satisfying 
proof claim 
list formulae quanti er rank de ne types single string de nable len dfa accepts string 
particular set strings true regular language lemma follows string jsj nitely strings contained exactly languages formulas true implies 
proves claim 
jsj length relative sux meet database pre fs adom lemma rc query 
exists number holds 
pre nitely strings 
uses pre restricted quanti cation ectively computed 
proof lemma 
corollary may assume loss generality quanti cation pre restricted 
quanti er rank 
show nd holds 
database string pre string pre fs ug 
nitely strings duplicator winning strategy round ehrenfeucht game partial isomorphism respect operations mapped winning strategy duplicator simply copies spoiler moves pre 
note condition implies nal position sc relations preserved implying lemma 
prove condition claim 
consider pre relative sux meet pre js nitely strings 
take string form new string meet pre 
clear required strategy exists duplicator show note rst conversion query pre bounded quanti cation ective claim ective len formula ectively converted automaton 
lemma proved 
de ne fs jsj js adom lemma rc len query 
exists number holds 
nitely strings 
uses length restricted quanti cation ectively computed 
proof lemma 
proposition may assume loss generality quanti cation length restricted 
quanti er rank 
string len structure el 
claim nd number string jsj exist nitely strings js len len note ectively 
assume maximum length string adom pre length 
string js show nitely strings length greater duplicator winning strategy round ehrenfeucht game len len play identity function restricted strings length exceeding clearly suces prove lemma jxj adom 
consider string len len know nitely 
prove duplicator wins round game len len strategy follows 
duplicator maintains memory separate game len len spoiler plays string length exceeding duplicator response string 
assume spoiler plays jxj 
length pre assume spoiler plays len spoiler plays len proof identical 
duplicator looks current position auxiliary game len len empty spoiler rst move length extends move spoiler move len response string len winning strategy len len having done duplicator returns game len len responds 
len show duplicator wins game 
clearly predicates preserved 
assume len moves game 
corresponding moves played len length juj jvj form 
pre length winning strategy len len fact pre length assume el holds 
case length trivial 
juj jvj 

length pre xes description duplicator strategy 

moves taken auxiliary game len len duplicator wins auxiliary game ju ju jv jv el holds 
completes proof lemma 
set fs js js pg pre pre closure 
note pre nm 
lemma rc left query 
exist numbers holds 
nm pre nitely strings 
proof lemma 
follows normal form left corollary lemma 
lemma rc reg query exists pre nitely strings 
proof lemma 
show assume restricted quanti er collapse quanti reg form qy adom qy adom ij ij atomic negated atomic sc formula reg formula involving variable formula form pl term 
lm regular languages formulae pl appear 
denote quanti er free part ij 
pre apply lemma meet pre meet pre 
uv 
show adom case 
imply see proving result 
prove suces show pl pl fl lm types formulae ij equivalence trivial 
adom consider atomic formula pl 
involves meets components value meet pre meet pre 
involve meets 
case simply case components include term loss generality value pre de nition pl 
meet pre meet pre equals belongs pre 
prove suces show follows immediately lemma 
completes proof lemma 
need lemma reg left proof follows normal form reg left corollary lemma 
lemma rc reg left query 
exist numbers holds 
assume nm pre nitely strings 
proof theorem completed 
prove theorem take arbitrary query form de nes active domain output suces prove theorem safe safe equivalent safe true having reduced problem queries variable simply apply corresponding lemmas 
rc nd number lemma say pre string form 
jsj lemma follows equivalent safe 
clearly algebraic expressible xed rc len get lemma len formula saying length length plus clearly expressible xed coincides safe 
completes proof theorem 
proof left similar gets lemma formula says distance pre string form jej jf proofs reg reg left follow idea 
concludes proof theorem 
corollary rc rc left rc reg rc reg left rc len classes range restricted safe queries coincide safe queries ective syntax 
note queries rc rc len restricted form quanti cation pre length proof gives stronger result formula ectively 
relational algebras classical result relational database theory set safe relational calculus queries precisely set relational algebra queries 
result extends string calculi considered safety theorems proved earlier show safe queries rc rc len captured appropriate extensions relational algebra 
safe rc class safe queries rc 
de ne algebras capturing safe rc previous structures need number operations extending usual relational algebra selection projection cartesian product di erence union constant unary relation formula 
attribute relation returns set tuples holds 
prefix attribute relation returns attribute relation addl attribute relation returns attribute relation 
ag 
attribute relation returns js js jg 
attribute relation returns attribute relation 
trim attribute relation returns attribute relation ag 
pointed formula refer database 
de ne relational algebras ra extends relational algebra ranges fo formulae prefix addl ra len extends relational algebra ranges fo len formulae prefix addl ra left extension relational algebra ranges left formulae prefix trim ra reg extends relational algebra ranges fo reg formulae prefix addl ra reg left extends relational algebra ranges fo reg left formulae prefix addl trim theorem safe rc ra safe rc len ra len safe rc left ra left safe rc reg ra reg safe rc reg left ra reg left 
proof 
start ra 
ra expression produces nite result standard translation algebra calculus extended rules addl prefix shows ra rc 
converse safe rc query 
theorem database active domain output contained set fx pre kg 
rst note de nable ra expression 
active domain de nable relational algebra 
xed string nite set expression addl de nes set 
sg simply composing addl operations 
adom de ne jsj addl note prefix 
extension unary predicate interpreted 
safe element tuple belongs 
know order evaluate suces restrict quanti cation pre closure adom pre closed implies active domain query schema extended unary symbol active domain means quanti cation restricted active domain output considered active domain input 
expressed relational algebra extended ranging formulae 
expressible ra conclude expressible ra 
proof len identical de nes fx jxj jyj adom expressible ra len addl operations operations proof reg identical proof set expressible ra reg 
left proof follows lines needed set adom expressible ra left xed follows fact adom de nable relational algebra prefix trim possible de ne adom 
proof reg left follows expressibility adom 
operations ra len expensive may create sets size exponential size input 
unavoidable expensive np complete safe queries rc len 
deciding safety properties queries query safety undecidable pure relational calculus extension state safety query database nite 
decidable 
state safety known decidable various extensions form rc example natural numbers successor real eld 
rc rc len decidability holds proposition state safety decidable rc left reg reg left len proof 
query database obtain formula replacing occurrence schema predicate disjunction ft interpretation formula de nable structures xed viewed formula len len 
consider sentence de ned el nite len nite len state safety decidable theory len decidable 
query safety undecidable considers restrictions decidability obtained 
look fundamental classes queries conjunctive queries 
take de nition context interpreted operations 
conjunctive query rc query form schema relation arity formula 
datalog notation query 
safety conjunctive queries shown decidable rc various structures reals numerical operations 
show general result decidability results string structures len considered follow 
say niteness de nable parameters formula exists formula set nite 
furthermore computed ectively 
theorem assume expanded theory decidable niteness de nable parameters safety boolean combinations conjunctive queries rc decidable 
proof 
start easy observations boolean combinations conjunctive queries rc 
conjunctive query represented form adom 
query consists appearing atoms 
query rewritten active domain quanti cation lists variables belong note conjunctive query monotone 
boolean combination conjunctive queries equivalent union queries form conjunctive queries 
puts boolean combination dnf observes conjunction conjunctive queries conjunctive query true false de nition conjunctive queries assume conjunctive query negation 
show decidable query form safe 
adom 
show claim exists database nite exists database tuples nite 
turn follows model data complexity data complexity ective syntax relational safety cq generic queries safe queries algebra rc ac fo rc len ph ac decidable rc left ac fo rc reg nc fo rc reg left nc fo rc concat undecidable undecidable undecidable table summary results query languages set databases tuples 
inclusion follows monotonicity inclusion fact witness suces nd holds exists tuples form database 
suppose nite tuples 
antimonotone 
nite nite 
proves claim 
stand number relation symbols sc tuple variables length arity query form formula obtained replacing database interpreted assumptions know expanded model formula set holds nite 
words holds nite 
sentence tq true nite database tuples previous claim means safe 
decidability theory implies decidability safety theorem proved 
know th len decidable 
niteness de nable parameters el 
corollary safety boolean combinations conjunctive queries rc rc left rc len rc reg rc reg left decidable 
table summarizes results section 
signi cant interest theoretical computer science understanding structure regular languages identifying subclasses regular languages special properties 
seen extension program consider subclasses regular ary relations regular sets 
approach focus properties hold particular regular relation look desirable properties algebra relations structure len shown sharp contrast behavior full algebra regular relations len various submodels left reg reg left show tractable respects 
furthermore show behavior algebra relations determined dimensional sets subsets algebra example fairly complex binary relations de nable maintain property de nable subsets star free 
summarizes relationships star free regular algebras considered 
studied extensions standard relational calculus various sets string operations 
interested languages computationally complete shared attractive complexity theoretic static analysis properties relational calculus 
language rc seen nice foundation languages built 
covers rudimentary string operations expressive power quite limited 
extension rc len powerful computationally complete 
considered languages rc left rc reg rc reg left express important operations rc len low data complexity 
calculi ective syntax safe queries corresponding relational algebras 
key question relations add models left reg attractive properties qe nite vc dimension nicely behaved relational calculus 
model maximal respect properties 
know answer question 
natural candidate models amenable approach taken expect results go example allows operation concatenating xed sequence middle string left right resulting model tractable 
acknowledgments wolfgang thomas scott weinstein emmanuel waller jan van den bussche fruitful discussions subject anonymous referees numerous helpful comments 
abiteboul hull vianu 
foundations databases 
addison wesley 
ajtai 
formulae nite structures 
annals pure applied logic 
ajtai fagin stockmeyer 
closure monadic np 
jcss 
angluin hoover 
regular pre relations 
mathematical systems theory 
anthony biggs 
computational learning theory 
cambridge univ press 
ph 
kolaitis 
order logic vs xed point logic nite set theory 
lics pages 
barrington immerman 
uniformity nc jcss 
stolboushkin 
extended order generic queries 
annals pure applied logic 
benedikt dong libkin wong 
relational expressive power constraint query languages 
journal acm 
benedikt libkin 
relational queries interpreted structures 
journal acm 
benedikt libkin 
safe constraint queries 
siam comput 

benedikt libkin schwentick model theoretic approach regular string relations 
lics pages 
benedikt libkin schwentick string operations query languages 
pods pages 
gr adel 
automatic structures 
lics pages 
blumer ehrenfeucht haussler warmuth 
learnability dimension 
journal acm 
bj rner 
integration decision procedures temporal veri cation 
phd thesis stanford university 
bonner mecca 
sequences datalog transducers 
jcss 
bonner mecca 
querying string databases transducers 
dbpl pages 
ere hansel 
logic recognizable sets integers 
bull 
belg 
math 
soc 

uchi 
weak second order arithmetic nite automata 
zeit 
math 
logik 
math 

chang keisler model theory 
north holland 
point 
extensions presburger arithmetic 
proc 
th easter model theory conf humboldt univ berlin 
comon 
rst order theory lexicographic path orderings undecidable 
tcs 
consens milo 
algebras querying text regions expressive power optimization 
jcss 
voronkov 
expressive power data complexity query languages trees lists 
pods pages 
gurevich shelah 
de nability constant depth polynomial size circuits 
information control 

ebbinghaus flum 
finite model theory 
springer verlag 
ehrenfeucht 
application games completeness problem formalized theories 
fund 
math 
elgot 
relations de ned generalized nite automata 
ibm res 
develop 

epstein word processing groups 
jones bartlett publ 
fischer rabin 
super exponential complexity presburger arithmetic 
siam ams proceedings 
flum ziegler 
pseudo nite homogeneity saturation 
symb 
logic 
fra ss sur quelques classi cations des syst emes de relations 
publ 
sci 
univ 
er 


synchronized rational relations nite nite words 
tcs 
furst saxe sipser 
parity circuits polynomial time hierarchy 
math 
systems theory 
ginsburg wang 
pattern matching rs operations uni ed approach querying sequenced data 
pods pages 
gr adel gurevich 
meta nite model theory 
information computation 
grahne 
safety translation evaluation alignment calculus 
proc 
east european symp 
advances databases information systems adbis :10.1.1.32.9967
grahne ukkonen 
reasoning strings databases 
jcss 
grahne waller 
sql stand string query language 
proceedings dbpl springer lncs vol 
pages 

sql complete really 
books 
ukkonen 
implementing declarative string query language string restructuring 
padl pages 
harel 
theory recursive structures 
mfcs pages 
hodges 
model theory 
cambridge 
hodgson 
par automate ni 
ann 
sc 
math 
qu ebec 
ibarra su 
technique proving decidability containment equivalence linear constraint queries 
jcss 
immerman 
descriptive complexity 
springer 
khoussainov nerode 
automatic presentations structures 
lcc pages :10.1.1.32.9967
ph 
kolaitis vardi 
fixpoint logic vs nitary logic nite model theory 
lics pages 
kuper libkin paredaens editors 
constraint databases 
springer 

vapnik chervonenkis classes de nable sets 
london math 
soc :10.1.1.32.9967

monadic second order de nable relations binary tree 
symb 
logic 
ma 
elementary theories locally free universal algebras 
soviet math 
doklady 
mcnaughton papert 
counter free automata 
mit press 

open questions uchi presburger arithmetics 
logic foundations applications oxford univ press pages 
neven van den bussche 
expressiveness structured document query languages attribute grammars 
journal acm 
papadimitriou 
computational complexity addison wesley 
rabin 
weakly de nable relations special automata 
mathematical logic foundations set theory north holland amsterdam pages 
rajasekar 
string oriented databases 
spire pages 
voronkov 
decision procedure term algebras queues 
acm 
salomaa 
formal languages 
academic press 
schwentick 
diving trees 
proceedings rd symposium mathematical foundations computer science mfcs bratislava pages 
shelah 
stability 
ann 
math 
logic 
stolboushkin 
finite queries ective syntax 
information computation 

finite automata formal logic circuit complexity 
birkh auser 
thomas 
nite trees automaton de nable relations words 
tcs 
thomas 
languages automata logic 
handbook formal languages vol 
springer 
venkataraman 
decidability purely existential fragment theory term algebras 
journal acm 

