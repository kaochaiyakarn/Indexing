technical report number cl tr issn computer laboratory mj imperative core calculus java java effects bierman parkinson pitts april jj thomson avenue cambridge cb fd united kingdom phone www cl cam ac uk bierman parkinson pitts technical reports published university cambridge computer laboratory freely available internet www cl cam ac uk techreports series editor markus kuhn issn mj imperative core calculus java java effects bierman parkinson pitts university cambridge computer laboratory thomson avenue cambridge 
cb fd 
uk 
gmb amp cl cam ac uk order study rigorously object oriented languages java common practice define lightweight fragments calculi sufficiently small facilitate formal proofs key properties 
current proposals calculi lack important language features 
propose java mj contender minimal imperative core calculus java 
whilst compact mj models features object identity field assignment constructor methods block structure 
define syntax type system operational semantics mj give proof type safety 
order demonstrate usefulness mj reason operational features consider proposal greenhouse boyland extend java effects system 
effects system intended delimit scope computational effects java program 
define extension mj similar effects system instrument operational semantics 
prove correctness effects system question left open greenhouse boyland 
consider question effect inference extended calculus detail algorithm inferring effects information give proof correctness 
order understand design programming languages develop better verification methods programmers compiler writers common practice develop formal model 
formal model calculus takes form small interesting fragment programming language question 
number proposals core calculus java programming language 
notable featherweight java fj core calculus intended facilitate study various aspects java type system including proposal extending java generic classes 
contrast main motivation fj interested various operational properties java type system 
extent fj oversimplification simply functional fragment java difficulties reasoning java code arise various imperative features 
propose java mj contender minimal imperative core calculus java 
mj seen extension fj big include essential imperative features java small formal proofs feasible 
addition fj model object identity field assignment null pointers constructor methods block structure 
mj intended starting point study various operational features objectoriented programming java 
demonstrate utility consider extending mj type system effects 
effects system delimit scope computational effects program 
effects systems originated gifford lucassen pursued talpin jouvelot 
interestingly systems defined functional languages simple forms state 
greenhouse boyland suggested effects system incorporated java 
key difficulty interaction effects system abstraction facilities mainly notions class subclass java object oriented programming general attractive 
greenhouse boyland give precise description effects system number examples give proof correctness 
having formally defined mj effects system instrumented operational semantics able prove correct 
addition greenhouse boyland leave question effect inference 
formally define algorithm infer effect annotations prove correct 
seen extension formal verification proposal theory underpins computational intuitions 
organised follows 
give syntax type system operational semantics mj 
outline proof type soundness details appendix 
define extension mj effects style greenhouse boyland 
outline proof correctness effects system details appendix 
consider problem effects inference define inference algorithm prove correct 
survey related give indications 
mj imperative core java calculus section define java mj proposal imperative core calculus java 
important note mj entirely valid subset java mj programs literally executable java programs 
clearly attractive feature mj design number places complicated matters 
alternative allow extra language features example classic java uses annotations bindings valid java syntax operational semantics 
rest section syntax type system single step operational semantics mj 
conclude section proof correctness type system 
syntax syntax mj programs 
mj program collection class definitions plus sequence statements evaluated 
sequence corresponds body main method java program 
example typical mj class definitions 
approach lazy functional programming state monads 
wadler shown effects systems easily adapted monads 
program cd 
cd class definition cd class extends fd 
fd cnd md 
md field definition fd constructor definition cnd 
cj xj super 
ek 
sn method definition md 
cn xn 
sk return type void expression variable null null field access cast pe expression expression pe 
ek method invocation new 
ek object creation statement op pe promoted expression 
sk sk 
sn conditional field assignment local variable declaration variable assignment return return 
sn block syntax mj programs class cell extends object class extends cell object contents object undo cell object start object start super super start contents start undo null void set object update void set object update contents update undo contents contents update code defines classes cell subclass object class subclass cell 
cell class field contents 
constructor method simply assigns field value parameter 
cell class defines method set sets field value 
objects inherit contents field superclass field undo 
constructor method calls superclass constructor method assign contents field sets undo field null object 
class definition overrides set method superclass 
featherweight java insist certain amount syntactic regularity class definitions really just definitions compact 
insist class definitions include supertype assume distinguished class object include constructor method currently allow single constructor method class call super statement constructor method return method definition void methods constraint enforced type system write field accesses explicitly receiver 
follows compactness assume mj programs formed insist duplicate definitions classes fields methods currently allow overloaded methods simplicity overloading determined statically overloaded methods simulated faithfully mj fields redefined subclasses allow shadowing fields cyclic class definitions example extends extends 
formalise straightforward conditions 
class definition contains collection field method definitions single constructor definition 
field defined type name 
methods defined return type method name ordered list arguments argument variable name type body 
constructor defined class name ordered list arguments body 
number formedness conditions collection class definitions formalised section 
rest definition defines mj expressions statements 
assume number metavariables ranges field names method names variables 
assume set variables includes distinguished variable permitted occur name argument method left assignment 
follows shall find convenient write denote possibly empty sequence 
en similarly 
write denote sequence 
sn commas similarly fd md 
abbreviate operations pairs sequences obvious way example write sequence 
cn xn length reader note mj classes expressions class expressions pe defines expressions promoted statements semicolon defines expression forms 
slightly awkward division imposed desire mj valid fragment java 
java allows particular expression forms promoted statements semicolon 
leads strange syntactic surprises example valid statement 
mj includes essential imperative features java 
fields accessed assigned variables locally declared assigned 
java mj supports block structure consider valid mj code fragment 
var var object temp temp var var var var temp code compares variables var var 
equal creates new locally scoped variable temp uses swap values variables 
block temp longer scope removed variable stack 
types fj simplicity mj primitive types called base types 
typed expressions class type typed statements type void statement form return type class type 
range valid statement types 
type method pair written sequence argument types return type method return return type void 
range method types 
expression types valid class name including distinguished class object statement types void method types 
cn java mj class definitions contain typing information code 
typing information extracted typecheck code 
presenting typechecking rules need specify typing information induced mj code 
typing information consists parts subclassing relation class table stores types associated classes 
consider subclassing relation 
recall mj restrict class declarations give name class extending class object class 
formed program induces immediate subclassing relation write 
define subclassing relation reflexive transitive closure immediate subclassing relation 
defined formally follows 
tr immediate class extends 
tr extends tr transitive tr reflexive formed program induces class table program fixed simply write 
class table triple provides typing information methods constructors fields respectively 
partial map class name partial map method name method type 
intended denote type method class partial map class name type class constructor method 
partial map class name map field name type 
intended denote type class details formed program induces class table 
method type def md 
md 
md class extends fd cnd md 
md constructor type class extends fd cnd md cnd 
cj xj 
field type def def 
cj fd class extends fd 
fd cnd md assumed class definitions formed 
define formally formedness class definitions 
find useful define type method type statement type formed respect class table 
written judgement ok means valid type class table 
overload judgement form statement types 
define dom domain equal 
ctype ok void ok mtype ok 
cn ok ok 
cn ok dom define formally judgement formed class tables written ok essentially checks things firstly types valid classes defined class table secondly method overridden type 
judgements follows 
ok 
fn ok ok ok 
cn ok ok ok ok ok ok ok 
mn ok ok ok ok ok ok dom 
fn 
cn dom dom 
mn dom define typing rules expressions expressions 
treatment casting fj include case stupid casting target class completely unrelated subject class 
needed handle case expression stupid casts may reduce containing stupid cast 
consider expression taken classes defined subclasses object class unrelated 
object new java language specification typed consider operational behaviour object created dynamically object dynamic effect 
point wish downcast object stupid cast 
wish maintain subject reduction theorem result single step reduction typed program typed program need include te rule 
reason require rules typing statement 
java enforces statically comparing objects object subclass 
preserved dynamics 
consider unrelated classes code fragment typed runtime comparing objects unrelated classes 
object new object new 
reader note valid java mj program occurrences te ts typing derivation 
typing environment map program variables expression types 
write denote map extended maps write ok mean types codomain typing environment formed respect class table 
typing judgement mj expression written class table typing environment 
rules fairly intuitive te null allows null value valid type see 
interesting fact evaluation null object reduce generating exception evaluates null assuming subclass te null te var ok ok ok ok ok null te te te downcast te typing judgement expression pe written pe class table typing environment 
rules forming judgements follows 
te method te new 
en cn 

cn 
en 
en 
cn 
cn new 
en typing judgement statement written class table typing environment 
noted earlier statements java non void type see rule ts return 
rules forming typing judgements follows 
ts ts ts noop ts pe ts ok ok void pe pe void void void void void void void void ts void ts return ts block return 
sn void 
sn void java allows variable declarations occur point block 
handle introduce typing rules sequencing case statement sequence variable declaration cases 
alternative approach force statement return new typing environment 
feel presentation simpler 
typing judgements sequence statements written class table typing environment 
rules forming judgements 
ts intro 
sn 
sn ts seq void 
sn 
sn define typing super call constructor class 
call empty constructor class directly extends object valid valid call constructor parents class 
expressions evaluated call allowed 
valid object parents constructor called 
super void 
en super 
en void object 
cn 
cn give typing rules involving methods define useful auxiliary functions accessing bodies constructors methods 
method body mbody def class extends fd cnd md 
md constructor body md cx mbody md 
md def class extends fd md formalise notion program typed respect class table 
denoted judgement ok informally involves checking method body constructor body typed type deduces matches contained 
introduce new judgement forms mok denotes methods class typed cok denotes constructor method class typed 
rules forming judgements 
mbody ok mbody ok 
mbody mn ok mok super void void cok cok cn cok mok 
cn mok ok mbody dom 
mn super dom 
cn operational semantics define operational semantics mj terms transitions configurations felleisen style evaluation contexts 
reader see style semantics advantage transition rules defined case analysis induction simplifies proofs 
configuration tuple containing information 
heap finite partial function maps oids heap objects heap object pair class name field function 
field function partial finite map field names values 

variable stack essentially maps variable names oids 
handle static scoping implemented list lists partial functions variables values 
explained detail 
denote stack concatenation 

term closed frame evaluated 

frame stack essentially program context term currently evaluated 
defined formally follows 
configuration config vs cf fs frame stack fs fs frame cf closed frame cf return super open frame 
vi ei 
en new 
vi ei 
en super 
vi ei 
en return values null variable stack vs ms vs method scope ms bs ms block scope bs finite partial function variables pairs expression types values heap finite partial function oids heap objects heap objects ho finite partial function field names values cf closed frame hole open frame requires expression substituted hole 
structure representing variable scopes may complicated required correctly model block structure scoping java 
example highlights 
left hand side gives source code right contents variable stack 
arg arg vs vs null vs null vs null null vs null vs create vs vs return vs calling method assume variable scope vs method call affect variables current scopes create new method scope entry method 
scope consists single block scope points argument value type annotation line block scope extended contain new variable line assumed arg enter new block 
effect adding new empty block scope current method scope 
line new scope extended contain variable notice added current outermost scope variable updates occur block scopes current method scope 
seen line updated outer scope 
line block scope disposed accessed statement line 
find useful define operations method scopes addition usual list operations 
eval ms evaluates variable method scope ms partial function defined variable name scope 
second update ms updates method scope ms value variable partial function undefined variable scope 
eval bs ms update bs ms reductions def def bs dom bs eval ms bs ms bs bs update ms section defines transition rules correspond meaningful computation steps 
spite computational complexity mj seventeen rules syntactic constructor 
giving transition rules accessing assigning values declaring variables 
notice side condition rule ensures write variables declared current method scope 
rule follows java restriction variable declaration hide earlier declaration current method scope 
note rule defines binding new variable current sort variable hiding contrast common functional languages sml 
block scope 
ms vs fs ms vs fs eval ms ms vs fs update ms vs fs eval ms bs ms vs fs dom bs ms bs ms vs fs bs bs null consider rules constructing removing scopes 
rule introduces new block scope leaves marker token frame stack 
second removes token outermost block scope 
final rule return leaves scope method removing top scope ms ms vs fs ms vs fs bs ms vs fs ms vs fs return ms vs return fs vs fs give transition rules conditional expression 
note resulting term transition block 
vs fs vs fs vs fs consider rules dealing objects 
define transition rule dealing field access assignment reasonably straightforward 
vs fs vs fs dom vs fs vs fs dom consider rules dealing casting objects 
rule cast simply ensures cast valid program enter error state covered 
rule simply ignores cast null object 
cast vs fs vs fs vs null fs vs null fs consider transition rule involving creation objects 
new rule creates fresh oid places heap heap object consisting class assigns fields null 
executing new method new method scope created added variable stack 
method scope initially consists just block scope consists bindings method parameters binding identifier 
method body term executed importantly continuation return placed frame stack 
result statement oid object method scope removed 
new vs new fs bs vs return fs dom null fields bs consider transition rule super statement occurs inside constructor methods 
super ms vs super fs ms bs ms vs return fs bs give transition rule method invocation 
invocation relatively straightforward note new method scope created consisting just bindings method parameters identifier 
require rules method returning void type requires addition stack clear new method scope method completed 
recall method rule statement sequence return method typed 
method vs fs mbody bs vs fs bs vs fs bs vs return fs void mbody bs reductions rules fully reduced terms 
rule deals completed statements second evaluated expressions 
skip vs fs vs fs sub vs fs vs fs assist reader reduction rules repeated full 
number reduction rules simply decompose terms 
rules essentially embody order evaluation 
error states number expressions lead predictable error state 
errors allowed run time dynamically checked java virtual machine 
java type system capable removing errors statically 
errors generated mj nullpointerexception written 
vs null fs vs null fs vs null 
vn fs vs fs definition terminal configuration configuration said terminal valid error form vs 
example execution help reader understand operational semantics section consider simple code fragment see operational semantics captures dynamic behaviour 
consider mj code effect swap contents variables var var temporary variable temp 
var var object temp temp var var var var temp consider execution configuration ms maps var value say var value say 
ms vs var var 
fs ms vs var var 
fs ms vs var 
fs ms vs var 
fs ms vs var 
fs ms vs 
fs ms vs 
fs point possibilities consider case 
ms vs fs ms vs fs eval ms ms vs fs update ms vs fs eval ms bs ms vs fs dom bs ms bs ms vs fs bs bs null ms vs fs ms vs fs bs ms vs fs ms vs fs return ms vs return fs vs fs vs fs vs fs vs fs vs fs vs fs vs fs dom vs fs vs fs dom cast vs fs vs fs vs null fs vs null fs new vs new fs bs vs return fs dom null fields bs super ms vs super fs ms bs ms vs return fs bs method vs fs mbody bs vs fs bs vs fs bs vs return fs void mbody bs skip vs fs vs fs sub vs fs vs fs mj reduction rules ec seq vs 
sn fs vs 
sn fs ec return ms vs return fs ms vs return fs ec vs fs vs fs ec ec vs fs vs fs vs fs vs fs ec vs fs vs fs ec cast vs fs vs fs ec vs fs vs fs ec vs fs vs fs ec vs fs vs fs ec new ec super vs new 
vi ei 
en fs vs ei new 
vi 
en fs vs super 
vi ei 
en fs vs ei super 
vi 
en fs ec method vs 
en fs 
en fs ec method vs 
vi ei 
en fs vs ei 
vi 
en fs mj decomposition reduction rules ms vs temp 
fs ms vs temp temp var 
fs temp null ms vs temp var 
fs temp null ms vs temp var fs temp null ms vs temp var var var 
fs temp null ms vs var temp var var 
fs temp null ms vs temp var var 
fs temp null ms vs temp var var 
fs point update variable stack note update change type 
temp ms vs var var 
fs temp ms vs var var 
fs temp ms vs var var var temp fs temp ms vs var var var temp fs temp ms vs var var temp fs temp ms vs var var temp fs ms variable scope ms var mapped 
temp ms vs var temp fs temp ms vs var temp fs temp ms vs temp var fs temp ms vs var fs temp ms vs var fs ms variable scope ms var mapped 
fs fs temp ms vs fs temp ms vs fs ms vs fs point execution statement completed temporary variable temp removed scope 
variable stack values var var correctly swapped 
typed configuration prove type soundness mj need extend typing rules configurations 
write vs cf fs mean vs cf fs typed respect result value type valid error state 
break properties ok vs ok vs cf fs void 
ok ensures field points valid object null types mentioned heap 
ok ok null fi fi ok ok 
ok ok dom dom 
fn dom 
second vs ok constrains variable valid object identifier null 

vn cn bs ok ok bs 
xn vn cn vs ok vs ok bs ok ms vs ok bs ms vs ok final property vs fs types frame context formed heap variable stack 
requires define collapsing context form typing environment 
extend typing environment map addition variables object identifiers holes values 
collapsing function defined follows 
context def def context ms vs context ms vs context bs ms vs def context bs ms vs dom bs dom context bs ms vs context vs dom def context vs syntax expressions extended contain object identifiers holes 
require additional expression typing rules 
te oid ok ok te hole ok ok know define frame stack typing follows 
obvious typing empty stack 
require special typing rules frames alter variable scoping 
require rule unrolling sequences sequence contain items alter scoping 
require rules typing rest frames frames require argument frames 
tf bs tf tf tf tf dom bs ms tf return ms vs fs void bs ms vs fs vs fs bs vs return fs context ms vs vs fs ms vs return fs bs null ms vs fs void bs ms vs fs tf sequence vs 
sn fs vs 
sn fs tf context vs vs fs vs fs context vs cf vs fs vs cf fs cf return cf cf 
sn cf type soundness main technical contribution section proof type soundness mj type system 
order prove correctness prove useful propositions style wright felleisen 
proposition states typed non terminal configuration reduction step 
proposition progress vs fs terminal vs fs vs fs vs fs vs fs proof 
case analysis details appendix 
find useful prove lemma states subtyping frame stacks covariant 
lemma covariant subtyping frame stack vs 
vs fs vs fs 
proof 
induction length fs 
note consider open frames closed frames ignore argument 
appendix contains full details 
prove second important proposition states configuration transition resulting configuration appropriate type 
referred subject reduction theorem 
proposition type preservation vs fs vs fs vs fs vs fs 
proof 
case analysis reduction step 
lemma needed reduction rules generate subtypes 
appendix contains full details proof 
combine propositions prove type soundness mj type system 
theorem type soundness vs fs vs fs vs fs vs fs terminal vs fs configuration form 
core java calculus effects usefulness mj imperative core calculus java hinges basis investigations various operational properties java 
section give details investigation formal development analysis effects systems java closely suggestions boyland greenhouse 
describe simple extension mj effects system calling resulting language 
rest section giving overview key features effects system boyland greenhouse 
define formally giving required extension mj type system instrumenting operational semantics 
conclude proving correctness effects system 
question left open greenhouse boyland 
greenhouse boyland effects system effects java computation includes reading writing mutable state 
greenhouse boyland observe simple assumptions knowing read write behaviour code enables number useful optimisations code 
effects systems defined functional languages simple state 
key problem defining effects system object oriented language preserve abstraction facilities style programming attractive 
problem deciding describe effects 
declaring effects method reveal hidden implementation details 
particular private field names mentioned 
solve greenhouse boyland introduce notion region object 
regions object provide covering notional state object 
read write effects method terms regions visible caller 
greenhouse boyland introduce extra notions address simplicity hierarchies regions unique objects 
greenhouse boyland introduce new syntax java define new regions specify region field specify read write behaviour methods 
introduce new syntax insist declarations inserted appropriate place code comments 
similar comments annotations extended static checking 
example class declarations point point objects 
class point extends object class point extends point int position int position point int point int int reads position writes position reads writes position super void scale int void scale int reads position writes position reads position writes position consider class point 
defines field region position method scale clearly read write effect region 
class point subclass point 
inherits field defines new field defined region position 
overrides method scale effects annotation correct 
note case simply expressed effects level fields 
scale method point class effects writes fields method overriding invalid 
demonstrates usefulness regions concept 
definitions section give extensions definitions mj yield 
syntax 
mentioned chosen extend java syntax insist effects annotations contained comments 
ensures nice property valid programs valid executable java programs 
syntax exactly mj exceptions ranges region names 
field definition fd method definition md eff 
cn xn 
sk constructor definition cnd eff 
cj xj super 
ek 
sn effect annotation eff reads writes 
rn effects 
effect empty written source code union effects written read effect write effect 
effect equality effects modulo assumption commutative associative idempotent unit 
relation naturally induced effects clearly relation reflexive transitive definition 
curious subtlety effects method overriding 
clearly overriding method effect information overridden method effect 
consider example dropped constructor methods brevity 
class cell extends object class extends cell object content value object undo value void set object update void set object update reads writes value reads value writes value contents update undo contents contents update stands valid subclass cell set method effects cell 
greenhouse boyland subsequently solve adding regions relation 
keep relation simple especially considering correctness effect inference define effects system writing field read write effect 
effects system 
formally define effects system 
mj initially describe functions extracting typing information program give typing rules 
class table take account effect region information contained annotations 
extended return effects methods constructors extended provide region field 
define function effect translates effect annotation associated effect 
difficulties mentioned function translates write effect annotation writes effect region method type def effect eff md eff 
md 
md class extends fd cnd md 
md constructor type class extends fd cnd md cnd eff field type def def effect eff ri fd ri class extends fd 
fd cnd md effect annotation translation effect reads 
rn 
rn def 
rn rn rn 
rn rn method overridden preserve subtyping new method modify additional regions 
add constraint judgement forming formed methods follows 
ok ok ok ok dom typing rules extended carry effect information 
typing judgements form effect 
rules introduce effects 
ts rule handles method subtyping introducing read write effects 
te method te new extended lookup effects code annotation 
ts te method te new te void 
en cn en 
en 
en 
en en new 
en 
en 

cn 
cn 
cn typing rules require trivial modifications 
axioms introduce empty effect rules simply combine effects premises 
final extension typing rules check effects method constructor bodies valid respect annotations 
mbody ok 
en en super 
en void 
en object super void super void void cok mbody 
cn 
cn super consider dynamics 
shall instrument mj operational semantics trace effectful computations 
demonstrate consistency semantics effects 
single reduction step written vs cf fs vs cf fs trace effects step 
significant instrumentation rules annotated respectively 
rest rules effect annotation 
define transitive reflexive closure relation obvious union annotations 
vs fs vs fs dom vs fs correctness vs fs dom main technical contribution section proof correctness effects system 
mentioned earlier addressed greenhouse boyland 
choice instrumenting mj operational semantics means correctness proof essentially adaptation type soundness proof mj type system 
order prove correctness prove useful propositions 
proposition states typed non terminal configuration reduction step resulting effect contained effects inferred effects system 
proposition progress vs fs terminal vs fs vs fs vs fs vs fs proof 
case analysis frame details appendix 
find useful prove lemma states subtyping frame stacks covariant 
lemma covariant subtyping frame stack effects vs vs fs vs fs 
proof 
induction length frame stack fs 
note consider open frames closed frames ignore argument 
details appendix 
prove second important proposition states configuration transition resulting configuration appropriate type effect 
proposition type preservation vs fs vs fs vs fs vs fs 
proof 
case analysis reduction step 
lemma needed reduction rules generate subtypes 
full details appendix 
combine propositions prove correctness effects system 
theorem correctness vs fs vs fs vs fs vs fs terminal vs fs configuration form 
effect inference previous section defined effects system fields declared regions methods annotated read write behaviour respect regions proved correctness 
obvious question formally addressed greenhouse boyland method effects inferred automatically assuming fields seeded regions 
section show possible give outline algorithm proved correct 
approach automatically generates general annotations method constructor 
extend grammar effects variables ranges effects variables 
extend types system generates series constraints 
constraint written intended mean effect effects constraint set set constraints 
effect constraint sets 
en xn substitution function maps effects variables effects 
extended pointwise effects 
say substitution satisfies constraint 
key inference algorithm generation constraint sets 
arises effects bodies methods constructors second subtyping 
inference algorithm annotations methods describe effects 
generate fresh effect variable represent effects 
write denote substitution effects variables contained suppress routine details 
class extends fd cnd md 
md fresh effect variable 
md 
md 
md extend definitions formed class table ok formed programs ok generate constraints 
give new definition wellformed class table 
checking subtyping requirements methods effects generate constraint check 
rules union constraints 
ok ok 
cn mn nn rn nn 
rn nn ok ok dom dom 
cn dom 

dom cn mn 
mn nn give extension definition formed program 
produce constraints effect variable associated method constructor effects body 
mbody super void void cok mbody super rules generate constraint set program 
methods mbody 
mbody mn rn mok 
rn mok cok mok rn 
cok 
rn dom 
mn ways generating constraints class hierarchy constraints implementations methods constructors 
note immediately constraints need unique solution 
consider excerpt class definition 
int counter void count int counter count assume method count assigned effect variable effects annotation 
typing judgement method body produce constraint clearly infinitely solutions constraint 
minimum solution needed case 
lemma existence minimum solution constraint set 
en xn unique minimal solution 
proof 
proof talpin jouvelot 
give algorithm finding minimum solution set constraints 
main result section inference algorithm correct generates valid effect annotations 
prove couple useful lemmas effect substitution 
states substitution satisfies constraints generated class table applying class table produces formed class table obvious definition 
lemma substitutions satisfy subtyping rs satisfies rs ok proof 
straight definitions 
lemma states effect substitutions preserve typing judgements 
lemma effect substitution preserves typing rs satisfies rs proof 
induction typing relation 
uses fact substitution continuous prove rules compose effects premises 
requires previous lemma prove axioms 
lemmas prove correctness effect inference algorithm 
theorem inference algorithm produces sound annotations rd rs satisfies rs rd ok proof 
follows definitions repeated lemma 
see appendix details 
related works formalising subsets java 
closely related motivated featherweight java 
philosophy keeping mj valid subset java 
fj lacks key features wish model 
concept state object identity feel essential developing usable specification logics 
extended fj contain feel important imperative features java 
related calculus classic java embodies language features mj 
classic java valid subset java uses binding model sequencing locally scoped variables 
features java block structured state unusual syntactic distinction expressions modelled directly 
motivation different interested extending java mixins reasoning features java 
eisenbach drossopoulou developed type soundness proofs various subsets java 
fact consider larger subset java mj model exceptions arrays model block structured scoping 
aims provide imperative core subset java prove soundness large fragment 
related effects systems 
regions greenhouse boyland similar leino data groups 
data groups means encapsulating fields 
key difference regions field uniquely field belong data groups 
leino uses data groups discuss writes updates fields 
clarke drossopoulou defined effects system java language 
system uses ownership types regions delimit scope computational effects 
detailed comparison left 
propose java mj contender imperative core calculus java 
claim captures complicated imperative features java compact rigorous proofs feasible 
justify claim considered extension effects system proposed greenhouse boyland 
formally defined effects system instrumented operational semantics proved correctness effects systems question addressed greenhouse boyland 
considered question effects inference inference effects method constructor bodies 
defined algorithm proved correctness 
surprising problems considering subject reduction java primarily concerning substitution 
discussed detail types forum 
consider method declaration object boolean object object return imagine unfolding method call substitution 
typechecking resulting statement return runs difficulty lost static types object may case dynamic types cast convertible 
mj model parameter passing substitution fact problem arise method invocations create new scopes contain static typing information 
course stupid type rules casting comparison 
clearly remains 
terms effects system currently investigating extending properties suggested greenhouse boyland hierarchies regions alias types 
remains seen proofs correctness easily adapted richer setting 
formalising various generic extensions java generic java gj fj 
part motivation design fj 
alan jeffrey discovered problem type inference gj 
counterexample exploits manipulation state generate runtime exception 
appears adopting functional core calculus java study generics oversimplification 
intend mj basis studying proposals generic extensions java developing logic reasoning mj programs bunched logic approach pioneered hearn reynolds yang 
portions workshop object oriented developments 
grateful referees comments 
grateful discussions andrew kennedy alan lawrence martin odersky 
supported epsrc parkinson eu ii bierman 
bierman parkinson 
effects effect inference core java calculus 
proceedings wood volume entcs 
bracha odersky stoutamire wadler 
making safe past adding genericity java programming language 
proceedings oop sla october 
clarke 
ownership encapsulation disjointness type effect 
proceedings oopsla november 
detlefs leino nelson saxe 
extended static checking 
technical report compaq systems research center 
drossopoulou eisenbach khurshid 
java type system sound 
theory practice object systems 
sophia drossopoulou susan eisenbach 
java type soundness revisited 
url citeseer nj nec com article drossopoulou java html 
flatt krishnamurthi felleisen 
programmer reduction semantics classes mixins 
technical report tr rice university 
corrected june 
gifford lucassen 
integrating functional imperative programming 
proceedings acm lisp functional programming 
gosling joy steele bracha 
java language specification 
addison wesley second edition 
greenhouse boyland 
object oriented effects system 
ecoop volume lecture notes computer science pages 
hosoya pierce turner 
subject reduction fails java 
note sent types mailing list june 
url www cis upenn edu types archives msg html 
igarashi pierce wadler 
featherweight java minimal core calculus java gj 
acm transactions programming languages systems 
jeffrey 
generic java type inference unsound 
note sent types mailing list december 
url www cis upenn edu types archives current msg html 
kennedy syme 
design implementation generics net common language runtime 
proceedings pldi june 
leino 
data groups specifying modification extended state 
proceedings oopsla 
lucassen 
types effects integration functional imperative programming 
phd thesis mit laboratory computer science 
hearn reynolds yang 
local reasoning programs alter data structures 
proceedings csl 
reynolds 
separation logic logic shared mutable data structures 
proceedings lics 

talpin jouvelot 
polymorphic type region effect inference 
journal functional programming 

talpin jouvelot 
type effect discipline 
information computation 
wadler 
essence functional programming 
proceedings principles programming languages 
wadler 
marriage effects monads 
international conference functional programming 
wright felleisen 
syntactic approach type soundness 
information computation 
proofs progress lemma proposition progress vs cf fs terminal vs cf fs vs cf fs vs cf fs vs cf fs proof 
case analysis cf considering typed configurations show term reduce 
ok vs ok vs cf fs void vs cf fs assume typing judgement term provide corresponding reduction rule 
case cf return typed know ms possible cases reducing 
case reduce return 
case reduce ec return 
case cf typed know bs ms reduce block 
case cf typed know bs ms context 
definition context see gives dom bs ms reduce 
case cf know context vs come vs precisely ms vs ms vs reduce 
case cf case reduces sub 
case terminal 
case cf null case reduces sub 
case terminal null 
case cf broken cases 
case null reduces 
case reduces 
case reduces ec 
case cf 
en ec method apply 

en values ec method applied 
case cf 
vn case method applies null 
case cf new 
en reduces ec new ei new 
case cf case reduces ec cast 
case reduces cast depending type case null reduce 
case cf case fs reduces skip 
case fs terminal state 
case cf 
sn reduces ec seq 
case cf case reduces ec case reduces ec case reduce depending test 
case cf case reduce environment 
typing rule tells true context case reduce ec 
case cf case reduces ec 
case reduces ec 
case reduces 
case null reduces 
case cf reduces ec 
case cf super 
en expressions values reduce super reduce ec super 
frame stack sequence typing require lemmas dealing typing sequences added frame stack 
lemma block ms vs fs void context bs ms vs void bs ms vs fs void lemma return vs fs context ms vs 
sn ms vs 
sn fs void sn form return lemmas similar proofs 
proof lemma 
proof 
prove induction size base case ms vs fs void context bs ms vs void bs ms vs fs void trivial proof bs ms vs fs void assumptions 
inductive case assume bs ms vs fs void context bs ms vs 
sn bs ms vs 
sn fs void prove ms vs fs void context bs ms vs 
sn bs ms vs 
sn fs void proceed case analysis 
case cx deduce context bs null ms vs 
sn void 
specialising inductive hypothesis allows deduce bs null ms vs 
sn fs void 
exactly require prove completes case 
case cx deduce context bs ms vs 
sn void context bs ms vs void specialising inductive hypothesis gives bs ms vs 
sn fs void combined gives completes case 
heap extension preserves typing lemma vs fs dom vs fs proof 
induction length fs 
rules typing frame stack follow induction tf tf tf method 
prove suffices prove dom 
see ok ok definition ok prove axioms typing judgement 
rules follow directly induction ts intro 
rule prove different 
true different syntactic categories 
covariant subtyping frame stack lemma covariant subtyping frame stack vs 
vs fs vs fs 
proof 
induction size fs 
base case fs typed tf 
rule covariant constraint argument result types 
inductive step show covariant subtyping holds fs assuming holds fs 
closed trivial closed frames ignore argument 
typing effects depend argument type 
consider open frames 
consider return affects typing environment 
covariantly typed remainder frame stack covariantly typed 
true inductive hypothesis 
remainder cases suffices prove proceed case analysis 
case know need prove void void void void void void clearly contain 
completes case 
case similar previous case 
case assumptions know field types overridden know lets prove required 
case similar previous case 
case 
en similar previous case fact method types overridden 
case know assumptions void sub typing relation transitive see typed result type 
case similar previous case 
case 
vi ei 
en similar previous case 
case new 
vi ei 
en similar previous case 
case super 
vi ei 
en similar previous case 
case result type frame depend argument type 
possible typing rules case combined require typeable 
case trivial 
type preservation proposition vs fs vs fs vs fs vs fs 
proof 
done case analysis relation 
considering possible reductions show program reduce valid state state subtype configuration type reductions 
rules controlling order evaluation defined proved trivially restructuring typing derivations 
show rest cases 
case skip ok assume vs fs prove vs fs vs ok lets deduce prove 
case sub vs fs void context vs void vs fs vs fs void ok vs ok vs fs void vs fs assume vs fs prove vs fs split proof cases 
firstly cf closed frame secondly frame hole 
proof needs split cases 
closed term cf second term requiring expression case cf get ok vs ok context vs vs cf fs void vs cf fs void vs cf fs know cf cf cf holes 
deduce ok vs ok vs cf fs void vs cf fs vs cf fs proves 
case get case return context vs ok deduce ok vs ok vs fs vs ok vs fs context vs vs fs void vs fs context vs vs fs vs fs vs fs void need show 
break cases null trivially true null type required plugging null identifier leave term typeable 
second case looks harder just alpha conversion identifiers 
proved 
assume ms vs return fs prove vs fs proof tree ok ms vs ok need tree 
ok vs ok context ms vs vs fs ms vs return fs void ms vs return fs context vs vs fs vs fs vs fs void definition vs ok see 
know value typing affected variable scope 
proves 
case assume ms vs fs eval ms prove ms vs fs deduce tree 
ok prove ms vs ok context ms vs ms vs fs ms vs fs void ms vs fs context ms vs ms vs fs ms vs fs void ok ms vs ok ms vs fs combining deduce typed proves covariant subtyping stack lemma completes case 
case assume ms vs fs update ms prove ms fs ms update ms 
deduce tree 
context ms vs context ms vs context ms vs void ok ms vs ok ms vs fs void ms vs fs void ms vs fs deduce need proof 
context ms vs void ts skip ms vs fs void ok ms vs fs void ms vs ok ms vs fs know difference ms ms variable blocks contains new value 
typed require gives 
typing information contained ms ms identical 

case assume bs ms vs fs prove bs ms vs fs bs bs null deduce tree 
ok prove dom bs ms bs ms vs ok bs ms vs fs void bs ms vs fs void bs ms vs fs context bs ms vs void ts skip bs ms vs fs void bs ms vs fs void ok bs ms vs ok bs ms vs fs definition vs ok know additional variable valid 
proving case assume vs fs prove vs fs deduce ok vs ok context vs 
void void void vs fs void vs fs void vs fs deduce tree prove 
ok vs ok void vs fs void vs fs void case identical previous 
case know ok need prove vs fs assume ms vs fs prove ms vs fs ms vs ok context ms vs void context ms vs void ms vs fs ms vs fs void ms vs fs void ok ms vs ok ms vs fs void ms vs fs definition context deduce context heap ms vs void 
lemma gives completing case 
case cast deduce ok need prove assume vs fs prove vs fs vs ok ok vs ok context vs vs fs vs fs void vs fs context vs vs fs vs fs void vs fs covariant subtyping lemma gives proving 
case assume vs fs prove vs fs deduce ok vs ok context vs 
need prove tree 
void vs fs void vs fs void vs fs ok vs ok context vs void ts skip vs fs void vs fs void vs fs contain typing information wrt function context 
know need prove ok 
prove required show 
case deduce ok vs ok need prove ok vs ok assume vs fs dom prove vs fs context vs context vs vs fs vs fs void vs fs context vs vs fs vs fs vs fs void definition ok see covariant subtyping stack gives 
proving 
case new assume vs new 
vn fs prove ms vs super return fs deduce dom null dom 
cn 
xn super ms 
xn vn cn ok 
vn vs ok context vs 
prove ok ms vs ok new 
vn 
cn vs fs vs new 
vn fs void vs new 
vn fs ms vs super return fs void ms vs super return fs prove change adding new object 
fields set null know object valid objects valid 
need prove ms valid variable scope wrt know type part okay subtype relation reflexive 
variables bound values known valid 
know 
heap extension preserves typing know vs fs 
know super void 
xn cn 
see definition context context ms vs contains type assignments object ids 
extension property know context ms vs super void 
extend give context ms vs super return allows lemma complete case 
todo case method assume vs 
vn fs prove ms vs return fs 
cn deduce mbody 
xn return ms 
xn vn cn ok context vs 
vs ok prove need tree ok ms vs ok 
vn 
vn vs fs 
cn vs 
vn fs void vs 
vn fs ms vs return fs void ms vs return fs need show ms valid variable scope 
seen true way previous case typing object comes 
know know methods ok return 
xn cn similar reasoning previous case lemma complete case 
todo requires covariant subtyping lemma 
case previous case trivial alteration return case super assume ms vs super 
vn fs prove ms ms vs return fs ms 
cn 
xn ms 
xn vn cn deduce ok 
vn 
cn super 
vn void ms vs ok context vs 
prove need proof ok ms ms vs ok vs fs void ms vs super 
vn fs void ms vs super 
vn fs ms ms vs return fs void ms ms vs return fs need show ms valid variable scope 
true way previous case typing comes ms super requires contain 
know valid know prove way new 
proved final case 
progress effects 
proposition vs fs terminal vs fs vs fs vs fs vs fs proof 
proof lemma identical proof cases 
case typing introduce effect field region broken cases 
case null reduces 
case reduces 
reduction effect typing judgement 
case reduces ec 
case typing introduces effect region case reduces ec 
case reduces ec 
case reduces 
reduction rule effect typing derivation 
case null reduces 
covariant subtyping frame stack effects lemma vs vs fs vs fs 
proof 
proved way lemma effects 
cases need slight extension 
case assumptions know field types regions overridden know lets prove required 
case similar previous case 
case 
en similar previous case fact method types effects overridden 
type effect preservation lemma proposition vs fs vs fs vs fs vs fs 
proof 
proof proceeds exactly way 
majority cases require additional proof follow directly extended covariant lemma 
additional information required prove extended type preservation proof 
cases follow proof rules effect system sub skip return cases follow extending proof trees extended covariant lemma cast remaining cases alter effect type 
show new effect type old 
case assume vs fs prove vs fs consider effects effects fs effects 
see reduction effects clearly 
case identical previous 
case reduction effects reduction reduces effects 
case previous case read effect 
case new reduction effects effect annotation reduction effects actual implementation know implementation effects 
reduction reduces effects 
case super previous case 
case method previous case need property methods 
case previous case 
inference algorithm produce sound annotations 
theorem satisfies 
proof 
assume prove know gives know know satisfies cj ok rj cj mok rj cj cok rj cj mk body lemma deduce cj mk body definition substitution cj mk deduce cj mk ok shown arbitrary assumptions know similar proof allows prove allows prove arbitrary assume cj mok cj cok cj ok 
