programming fixpoint type roy louis crole churchill college cambridge revised version dissertation submitted degree doctor philosophy university cambridge january fl roy louis crole parents university cambridge computer laboratory technical report revised version ph thesis 
report essentially original thesis completed july corrections alterations suggested ph dr hyland department pure mathematics mathematical statistics cambridge england prof moggi dip 
di matematica univ di genova italy 
modifications personally think improves presentation original thesis 
errors remain sole responsibility 
summary contents programming metalogic formal system programming languages translated meaning 
translation reflect structure language easy prove properties programs 
thesis develops certain techniques category theory treats recursion new way 
notion category fixpoint object defined 
corresponding categorical structure type theoretic equational rules considered 
rules define fixpoint type allow interpretation recursive declarations 
core notions fix categories defined 
categorical equivalent equational logic viewed basic programming metalogic 
recursion treated syntactically categorically 
expressive power equational logic increased embedding intuitionistic predicate calculus giving rise fix logic 
contains propositions evaluation computations values induction principle derived definition fixpoint object initial algebra 
categorical structure accompanies fix logic defined called fix hyperdoctrine certain existence disjunction properties fix stated 
particular fix hyperdoctrine constructed proof properties 
pcf style languages translated fix logic computational adequacy results proved 
languages studied similar pcf call value recursive function declarations higher order conditionals 
dependently typed equational logic containing fixpoint type universal type related categorical structure fix category attributes 
representation theorem scott predomains proved gives rise concrete example fix category attributes 
recursive domain equations give rise endofunctions universal type fixpoint type may solve fixpoints endofunctions obtain solution original domain equation type coded fixpoint 
ii expressing andrew pitts thesis supervisor past half years 
am indebted patient guidance support possible 
recall situation willing discuss research encouragement unfailing 
useful conversations andrew gordon 
willing talk computational intuitions invaluable 
additionally time deserve sorting computers 
eike ritter discussed thesis depth general unfailing enthusiasm source inspiration 
due glynn winskel original supervisor 
gave useful directions literature provided funding allowed visit university denmark december 
fruitful discussions people nick benton richard boulton thomas forster martin hyland bart jacobs eugenio moggi valeria de paiva wesley phoa dominic verity michael white 
particular wish members drawn computer laboratory department pure mathematics club cambridge early met regularly discuss categorical logic computer science 
provided stimulating open research environment 
tom melham providing macros thesis layout paul taylor commutative diagram packages 
john van john harrison helped see thesis printing user friendly 
due serc provided form research studentship esprit basic research action 
additionally cambridge university computer laboratory churchill college generous aid conference expenses 
term opportunity deliver lecture course categories equational logic typed lambda calculi 
enlightening experience hope attended lectures learnt 
am grateful roger needham andrew pitts allowing give course 
iii iv contents categorical logic computer science 
thesis summary 
foundation notation 
fix logic strong monads categories 
monads tensorial strengths 
definition category 
categories 
fix logical system review computational calculus 
extensions system ml 
fixpoint objects 
internal logic corresponding fixpoint object 
equational logic fix 
categorical semantics fix logic fix categories 
categorical semantics fix 
interpretations computation types fixpoint type 
categorical logic correspondence 
definability fixpoints 
functional completeness 
results fix categories fix theories 
gluing cartesian closed categories 
ii fix logic fix logical system introduce fix logic 
predicate logic fix 
adjoint style formulation fix logic 
extensions fix 
results fix logic 
categorical semantics fix logic fix hyperdoctrines 
categorical semantics fix 
categorical logic correspondence 
logical relations hyperdoctrine 
proving existence disjunction properties 
proving natural number type 
applications fix logic 
language ql 
translation ql fix logic 
adequacy results ql 
pcf style language hpcf 
translation hpcf fix logic 
adequacy results hpcf 
alternative translation fixpoints 
iii fix logic representations scott predomains scott domains information systems 
scott predomains systems 
equivalence categories ppd 
large cpo 
categorical constructions 
small cpo 
miscellaneous results 
fix logical system vi dependently typed equational logic fix 
recursive types fixpoint objects 
categorical semantics fix logic categories modelling dependent type theories 
fix categories attributes 
categorical semantics fix 
prospects research loose ends tasks 
final 
vii viii chapter categorical logic computer science late early scott strachey researchers university oxford concerned methods define programming languages say lack methods 
time description language essentially operational nature extent language definitions virtually synonymous actual implementations 
little research concerning underlying mathematical theories programming undertaken 
mid landin noted connections calculus formalism developed logicians representing functions certain constructs appear programming languages 
landin formal theory calculus guide construction machine evaluating programs lan 
interesting note landin comments contribution theory activity computers 
landin observed reduction rules calculus resemble certain operational reductions commands expressions programming languages formal treatments theory operational specifications programming languages 
scott strachey wanted move away operational specifications languages attempt develop denotational approach concentrated intended meaning language 
simple example idea illustrated concept natural number 
different languages specify natural numbers example octal decimal roman case really concerned denoted natural number natural number represented 
examples denotational specifications program fragments worked scott strachey see sco sco ss 
pursuing notion mathematical models programming languages question constitutes model calculus arose 
calculus allows syntactic expressions represent functions applied 
clear mathematical model interpret expressions form set theoretic function model self application certain sets contain function space 
scott realised construction possible imposing certain conditions kind function allowed model see sco sco 
examples denotational semantics see sco str sw 
foundations operational denotational semantics laid researchers took task attempting formal treatments programming semantics 
clear formal semantics necessary ensure programs really behaved supposed 
semantics reason programs particular prove program satisfies specification 
plotkin investigated different kinds operational semantics calculus plo connections denotational semantics plo went clarify issues arisen see plo plo 
programs larger intricate task proving programs correct difficult 
solution problem idea programming metalogic formal logical system possible give meaning programming languages 
programming metalogic usually rich type structure powerful rules reasoning give meaning programming language translating source code metalogic 
translation preserve structure original language allowing properties source programs proven showing property holds metalogic 
proof metalogic substantially easier direct proof semantics original language 
thesis presents programming describes simple applications 
deals recursively defined declarations novel way introducing new type called fixpoint type see cp 
simple equational logic extension computational calculus mog formal system programming semantics separates notions computation value 
second metalogic predicate logic subsumes original equational logic equality predicate 
ideally suited reasoning languages natural semantics style kah 
third metalogic dependently typed equational logic containing type universe solve domain equations 
solution domain equation regarded recursively defined type equivalently may regard equation determining type universe 
find fixpoint function fixpoint type solution domain equation type represented fixpoint 
categorical logic study connections formal logical systems category theory 
remarked logics give meaning programming languages 
category theory guide design give uniform presentation semantics 
easier prove property metalogic categorical means translate results statements metalogic 
techniques categorical logic thesis 
thesis summary thesis divides parts 
ffl part simple equational metalogic described builds computational calculus 
system form basic core described part ii part iii 
ffl part ii equational metalogic part strengthened predicate metalogic give simple applications 
ffl part iii dependently typed equational logic containing type universe solve domain equations 
part chapter giving brief review basic category theory thesis aiming set notation monads tensorial strengths categories 
provide elementary examples categories illustrate computer science 
background categorical logic see law 
chapter review computational calculus motivate uses form usually 
leads discussion suitable extensions particular fixpoint type see nps background type theory 
presence fixpoint type certain endofunctions fixpoints 
introduce categorical definition concept fixpoint type fixpoint object category 
categories morphisms certain kinds guaranteed fixpoints 
leads internal logic fixpoint objects describe extension computational calculus things contains logic fixpoint object 
system referred fix logic 
chapter define fix categories prove usual categorical logic correspondence categorical structures fix show fix categories precise sense general structures interpreting fix discuss fixpoints fix fix categories move show fix categories functionally complete 
carry gluing construction categories prove result equality ground terms fix part ii chapter language fix captures certain computational features equational theory increase expressiveness embedding fix predicate logic called fix 
define notion fix theory show pure fix logical system formulation rules assume adjoint form 
chapter finishes number results fix put statements theorems concerning metalogical properties fix 
chapter define fix hyperdoctrine categorical counterpart fix logic give concrete example 
task give formal statement categorical logic correspondence fix hyperdoctrines fix logic 
view correspondence prove metalogical properties stated chapter define logical relations hyperdoctrine proofs internal logic 
chapter investigate suited fix logic analysing small programming languages 
languages plotkin pcf 
give translations static dynamic semantics pure fix logic prove adequacy results show translations give preserve structure properties source languages 
part iii chapter extend notion information system provide representation theorem scott predomains properties similar scott domains necessarily possess element 
effect classical definition information system altered simple way giving rise systems 
canonical constructions products coproducts lifting partial function space category systems 
chapter aim develop logic universal type fixpoint type 
domain equations solved considering endofunctions induced universal type 
fix equational logic forms backbone system introduced fix describe syntax logical rules fix dependently typed equational logic introduce notion fix theory 
chapter general categorical structure dependently typed equational theories reviewed categories attributes 
define fix category attributes structures model fix theories 
having done give concrete example fix category attributes move consider general categorical semantics fix finish chapter basic results semantics 
chapter consider achieved prospects research draw 
foundation notation foundations category theory thesis say category shall mean specified interpretations statements object morphism interpretations identity morphism domain codomain composition 
assumptions collections objects morphisms form set 
shall impose restrictions collections prudent 
cases shall refer notions small locally small categories appropriate think concepts model set theory 
martin lof theory arities expressions shall theory arities expressions due martin lof object level syntax thesis definition definition syntax signature sigma pair sets gar con elements gar called ground arities elements con called constants 
regarding ground arities ground types simply typed calculus refer simple types arities 
constants assumed tagged arity 
data regard syntax signature sigma signature conventional sense type tagged simply typed calculus constants 
definition syntax signature sigma syntax collection equivalence classes terms simply typed calculus generated sigma shall refer calculus meta calculus 
shall call individual classes expressions syntax refer variables simply typed calculus metavariables 
abstraction expression denoted metavariable substitution metavariable application 
multiple application denoted fv set free metavariables roughly shall view syntax object level languages certain expressions syntax 
usually set gar consist elements term type 
constants con consist function symbols arising signature object level language countably infinite set object level variables 
arity function symbols specified particular object level language considered likewise object level variables 
raw syntax object level language defined closed expressions syntax 
variable binding take place meta calculus substitution object level terms application meta calculus 
exposition theory arities expressions cro nps 
notational conventions general convention shall omit typing information morphisms functors example speak natural transformation pair bifunctors components domain theta tb codomain theta shall denote data theta tb theta theta tb theta commutative diagrams shall place just typing information morphisms picture unambiguous 
document shall rules form hypothesis hypothesis syntactic expressions 
rule assume hypothesis formed 
list expressions abbreviate list 
discussing object level languages syntax shall introduce formal syntactic classes distinguish object level variables metavariables rely context usage distinction 
example expressions syntax expression form meaningful metavariable 
part fix logic chapter strong monads categories chapter contains review basic category theory thesis 
account means comprehensive intended 
simply define fundamental concepts relatively new computer science form backbone categorical structures arise 
standard basic category theory mac additional material monads particularly relevant man kel 
readers familiar original works monads strengths enriched category theory see basic notation different 
story unfolds hope choice notation seen appropriate useful 
monads tensorial strengths definition category 
recall monad triple endofunctor id natural transformation called unit monad natural transformation called multiplication monad data satisfy equations id ffi id ffi tj referred ffi ffi referred monad 
shall speak just monad definition category finite products monad monad said possess tensorial strength natural transformation components theta tb gamma 
theta satisfy equational identities represented commutative diagrams denote obvious canonical isomorphisms theta ta theta ta tensor theta id theta theta tb theta tensor theta theta tc theta theta theta theta tc id theta theta theta theta theta tensor theta theta tb theta theta tb id theta theta tensor strong monad monad choice tensorial strength confusion arise refer strong monad definition category definitions category making definition definition category specified category finite products strong monad give alternative definition category prove great value study equational logic categories 
definition category specified category finite products enjoys properties ffl object object ta ffl object morphism ta ffl morphism theta tc morphism lift theta tb tc conditions satisfied lift theta id lift theta id tb lifts theta tc lift id theta theta tc lift theta lift lift fi lift lift lifta theta tc theta td shall refer operation 
lift lifting 
useful derived operation morphisms shall refer operation 
shall write 

take projections theta theta ta ta operation specified gamma 
tb ta gamma gamma 
theta ta lift gamma 
tb definition leads immediately lemmas lemma suppose category sense definition 
morphisms tb tc equational identities hold letb id leth leta proof trivial calculation 
lemma suppose category sense definition 
morphisms tb theta td lift id theta lift lift id theta proof immediate definitions 
equivalence definitions previous definitions categories equivalent way lemma category definition definition structure definition definition 
proof suppose category structure definition 
show structure definition 
definitions operation morphisms clear 
lifting operation defined theta gamma 
tc theta tb gamma 
theta tf gamma 
gamma 
tc check definition lifting satisfies necessary equations 
essentially routine manipulation supply critical details case give recipe transforming left hand side equation right hand side 
lifts follows naturality functoriality follows tensor naturality theta tc psi gamma gamma gamma gamma gamma id theta id theta tb theta tf tc follows functoriality naturality tensor 
show lifta functoriality followed monad naturality need commutativity theta tb theta psi gamma gamma gamma gamma gamma idi theta theta theta theta psi gamma gamma gamma gamma gamma id theta tf id theta theta tf ffi theta tc fi commutativity follows theta tb theta theta theta tb delta theta id theta theta delta theta id theta theta tb id theta theta theta theta theta lower square instance tensor 
apply tensor get result 
conversely suppose category structure definition 
give recipe showing structure definition 
action monad objects components natural transformation clear 
definition monad morphisms gamma 
ta gamma 
tb component natural transformation id ta component lift thetab 
omit routine details verify strong monad 
corollary corollary category monad considered endowed structure objects morphism tb morphisms ta operations 
ta 
operation defined gamma 
tb ta ffit gamma 
tb data satisfy equations letb leth leta 
conversely category endowed structure define monad ta tb components clear component id ta 
operation arising monad category closely allied construction kleisli category kl composition kl 
categories 
motivating ideas fundamental slogan categorical semantics programming languages types interpreted objects category terms interpreted morphisms 
course complicated languages basic idea adapted ways starting point 
known time formal systems correspond precise way certain kinds categorical structure example calculi theoretical backbone functional programming languages internal languages cartesian closed categories cartesian closed categories provide notion syntax independent presentations calculi 
functional languages principles calculus basic reduction strategies calculi fi elegantly distinguish certain kinds operational semantics call name call value 
example notion call value strategy calculi consider values expressions formal system applications 
fi reduction restricted instances operand value 
naive formal system captures notion call value little ad hoc account see plo 
reasonable develop formal system separates notions computation value exactly strong monads world semantics 
category object models type ff object ta models computations values type ff 
clear illustrated example 
examples categories examples category set lifted mog 
partial computations type ff partial computation type ff thought program terminates yielding value type ff terminate 
values type ff denoted set denote partial computations values type ff coproduct fg 
operation objects 
fg 
function def fg left coproduct insertion right insertion 

function theta fg define lift lift def corresponding category strong monad fg fg fg defined def fg tensorial strength theta fg 
theta fg defined def intuitive meaning monad multiplication partial computation partial computation defined result composition undefined 
strength takes pair consisting value partial computation returns partial computation say original partial computation defined expected value 
original computation undefined computations raise exceptions set models certain exceptions 
set models values type say ff consider categorical model 
operation sets 

function def left coproduct insertion 

function theta 
define lift lift def intuitive explanation example similar partial computations 
computations side effects store suppose considering model imperative language set model set states 
model 
operation sets 
theta 
function theta def 
function theta 
theta define lift lift def 
ts ts intuitive meaning corresponding monad multiplication say computation takes state yields computation side effect new state may regarded computation takes state returns value state result computation value strength says value computation may regarded computation takes state yields pair values value arising cs state arising cs non deterministic computations set modeling values type ff model non deterministic computations type ff sets possible results suitable model 
operation sets 

function def fag 

function theta lift defined lift def ff regard denotation non deterministic computation collection possible outputs 
value trivially regarded non deterministic computation 
value non deterministic computation think pair non deterministic computation 
chapter fix logical system review computational calculus computational calculus introduced moggi mog 
roughly formal system embodies idea separating computations values syntactic analogue notion category 
formal distinction elements type ff computations elements type grouped new type ff 
shall refer type form ff computation type 
moggi computational calculus contains formation rules ff type ff type ff val ff ff ff fi fi rules usual rules unit type binary product type constitute term forming rules computational calculus shall denote ml intuitively val value regarded trivial computation immediately evaluates 
term denotes computation firstly tries evaluate value ff proceeds evaluate 
intended meanings captured equational axioms val val extensions system ml basic formal system ml reader may wondering fundamental equational logic discuss ml assumed contain unit binary product types computation types 
considering practical computational issues useful deal algebraic terms terms finite number object level variables 
basic principle categorical semantics calling computational calculus moggi refers computational metalanguage 
account see cro shall need category finite products interpret algebraic terms 
shown pit exactly structure need interpret unit type binary product type 
little sense exclude unit binary product types terms logic gain uniformity considering details correspondence syntax logic corresponding categorical structure 
ml extensions tasks push forward development versatile general purpose metalogic semantics programming computation languages 
view computational calculus extensions formal metalanguage translate syntax rules languages related area reader referred pit 
thesis shall consider various extensions ml extensions worthwhile investigating 
unit binary product types computation types 
additionally notion function type essential interpreting functional programming computation languages 
equational logic ml extended function types usually called computational calculus denoted ml refer reader mog pit 
fundamental datatypes natural numbers booleans coproducts 
discussed chapter shall introduce new type called fixpoint type 
interesting study fixpoint type interacts certain types 
purposes convenient study calculus addition fixpoint type contains null type unit type binary product types function type type natural numbers 
aiming develop constructive logic reasoning programming languages general recursive computations particular logic arising terms equations associated types just listed provides foundation build 
fixpoint objects define notion fixpoint object suitably structured category 
concept due pitts see cp cp 
definition category finite products indexed category gamma specified ffl objects ffl def theta composition hh gi ffl def def theta id note category indexed endofunctor gamma gamma def ta def lift jg definition definition category fixpoint object specified data ffl initial gamma algebra structure map fibre morphism theta omega omega oe omega morphism ta unique morphism omega diagram commutes theta omega id theta oe theta omega theta ta lift ffi ffl global element omega gives rise equaliser diagram form omega joe id omega definition fixpoint object shall abbreviate fpo reminiscent natural numbers object 
recall definition category finite products takes particularly simple form ambient category cartesian closed 
lemma ccc fpo specified ffl initial algebra structure map oe omega omega gamma ffl global element omega equaliser joe id omega exactly definition 
proof see page shall internal logic ccc prove result 
usual category theoretic considerations imply structure constituting fpo determined uniquely isomorphism category properties 
note oe structure morphism initial algebra endofunctor isomorphism 
examples fixpoint objects domain theoretic example ccc fpo category cpo objects posets possessing joins countably infinite chains morphisms scott continuous functions 
refer objects cpos 
operation adjoining element cpo give lifted cpo 
dg gives strong monad cpo 
fpo cpo omega equipped structure map oe omega omega oe continuous function oe def 
def omega monads cpo moggi mog points arising denotational semantics possess fixpoint objects 
example exceptions monad 
fixed discrete cpo exceptions side effects monad theta 
fixed discrete cpo states possess fixpoint objects 
illustrate case exceptions monad terminal object def fg cpo 
fpo underlying set omega def ng order top element structure map oe omega omega oe continuous function oe def 

def omega follows general theory solving recursive domain equations cpo enriched categories sp 
suppose cpo enriched strong monad cpo cpo regarded symmetric monoidal category finite products enriched maps cpos pointed cpos cpos elements 
obtain fixpoint object constructs initial fixed object category pointed cpos embedding projection pairs iterating starting element cpo yielding isomorphism oe omega gamma omega gamma omega oe initial algebra cpo cpo dually omega oe gamma final coalgebra functor follows limit colimit coincidence cpo enriched categories 
initial algebra property gives part definition fixpoint object freyd observed second part definition implied coalgebra property 
record observation lemma 
lemma ccc suppose oe omega omega initial algebra functor particular oe isomorphism 
suppose oe gamma omega omega final coalgebra global element omega making omega oe fixpoint object proof final coalgebra property means ta unique morphism omega satisfying oe gamma define omega oe gamma defining property naturality get oe gamma omega omega oe omega morphism satisfying omega oe see 
omega oe naturality oe gamma oef omega oef oef uniqueness part coalgebra property oef oe gamma argument applies equally 
oe gamma 
internal logic corresponding fixpoint object known natural correspondence categories ml theories mog 
corresponding computational calculus referred equational internal logic category possible extend calculus ml capture syntactically notion fpo 
entail adding type fix called fixpoint type ml certain term forming equality rules 
rules informal natural deduction style fix fix oe fix ff ff fix ff ff val oe val oe ff ff fix ff oe val ff ff ff fix ff fix oe val fix ff type fix called presence able form fixpoints certain terms correspondingly category fpo guaranteed existence fixpoints certain morphisms 
leave precise details defined formal system contains equational rules fixpoint type 
equational logic fix section discussed appropriate extensions ml basic addition function types resulting computational calculus ml adding fixpoint type fix coproduct types ff fi natural number type nat computational calculus ml arrive system fix extends godel system gir 
fix admits sound translations plotkin pcf plo shall return topic pcf translations chapter 
formally define fix signatures fix definition fix signature denoted sg specified ffl collection types 
types built way 
collection basic ground types distinguished ground types unit null nat fix types specified grammar ff fl ff theta ff ff ff ff ff ff fl denotes ground type 
ffl collection basic function symbols distinguished function symbols hi gamma gammai fst snd inl ff inr fi fg ff gamma gammag ff app val suc oe ff ffl sorting basic function symbols list types written ff ff ff case zero shall write ff say ary basic function symbol sorting consists types 
fix signature define syntax signature sigma gar con collection ground arities gar simply element set 
collection constants con consists basic function symbols arity term term sorting consists types countably infinite set object level variables arity term distinguished function symbols 
distinguished function symbols represent simply typed calculus finite products natural numbers usual arities 
remaining distinguished function symbols arities 
term 
fg ff inl ff inr fi val oe term term 
term 
term term term 
ff term term term term 
gamma gammag term term 
term term term term associated fix signature collection raw fix terms 
confusion arise shall refer just raw terms 
raw terms closed expressions syntax generated sigma arity term 
abbreviations write fm app 
terms context fix context gamma finite list variable type pairs written ff ff object level variables distinct 
empty context denoted white space 
self explanatory notation gamma ff gamma gamma concatenation contexts course occur gamma write gamma gamma mean gamma sub list gamma shall write gamma ff judgement context gamma raw fix term formed type ff 
cases raw term referred fix term context 
judgements generated rules variables gamma ff gamma ff basic function symbols gamma ff ff gamma ff function symbol sorting ff ff ff unit terms gamma hi unit null terms gamma null gamma fg ff ff binary product terms gamma ff gamma fi gamma hm ni ff theta fi gamma ff theta fi gamma fst ff gamma ff theta fi gamma snd fi binary coproduct terms gamma ff gamma inl fi ff fi gamma fi gamma inr ff ff fi gamma ff fl gamma fi fl gamma ff fi gamma ff gg fl function terms gamma ff fi gamma ff ff fi gamma ff fi gamma ff gamma fm fi computation terms gamma ff gamma val ff gamma ff gamma ff fi gamma fi natural number terms gamma nat gamma nat gamma suc nat gamma ff gamma ff ff gamma nat gamma ff fixpoint terms gamma fix gamma fix gamma oe fix gamma ff ff gamma fix gamma ff ff usual rules weakening contexts substitution raw terms object level variables derivable rules simple structural induction 
equational theories fix fix equation context takes form gamma ff raw fix terms satisfying gamma ff gamma ff 
fix theory th specified fix signature specific collection equations context called axioms th 
collection theorems th collection equations context contains axioms th closed rules function symbol congruence function symbol required congruence weakening gamma ff gamma ff gamma gamma equational logic gamma ff gamma ff gamma ff gamma ff gamma ff gamma ff gamma ff unit equations gamma unit gamma hi unit null equations gamma null ff gamma null gamma fg ff ff binary product equations gamma ff gamma fi gamma fst hm ni ff gamma ff gamma fi gamma snd hm ni fi gamma ff theta fi gamma hfst snd ff theta fi binary coproduct equations gamma ff fl gamma fi fl gamma ff gamma ff gg inl fi fl gamma ff fl gamma fi fl gamma fi gamma ff gg inr ff fl gamma ff fi fl gamma ff fi gamma fu inl fi inr ff fl function equations gamma ff fi gamma ff gamma ff fi gamma ff fi gamma ff mu ff fi computation equations gamma ff gamma ff fi gamma val fi gamma ff gamma val ff gamma ff gamma ff fi gamma fi fl gamma fl mono condition gamma val val ff gamma ff natural number equations gamma ff gamma ff ff gamma ff gamma ff gamma ff ff gamma nat gamma suc ff ae gamma nat gamma ff gamma ff ff gamma nat suc nat gamma nat ff gamma ff fixpoint equations gamma val oe fix gamma val oe fix gamma fix gamma ff ff gamma fix gamma ff oe val ff ff ae gamma fix gamma ff ff gamma fix oe val ff gamma fix ff gamma ff ff usual rule substitution derivable rules 
precisely lemma rule gamma ff fi gamma ff gamma fi derivable rules page 
proof function symbol congruence deduce gamma ff ff fi 
result follows 
mono condition syntactic requirement captures idea values may trivially regarded computations evaluate immediately 
note side conditions extensionality rules due fact object level variables regarded constants meta calculus 
chapter categorical semantics fix logic fix categories definition fix category ccc endowed finite coproducts fpo components unit monad 
imposing condition unit components monic captures semantically idea value may trivially regarded computation 
note specify fix category take fixed choice strong monad 
syntax fix particular null binary coproduct terms equations interpreted fix categories 
order interpret syntax soundly fix category stable finite coproducts functor theta gamma preserve finite coproducts 
automatic fix category cartesian closed theta gamma right adjoint 
definition fix category morphism monad morphism underlying monads preserves categorical structure isomorphism natural isomorphism 
note operation objects 
ta categorical property fix category noted fixed choice strong monad 
fix category morphism 
means object isomorphism fta compatible remaining structure 
example suppose morphism theta tc morphism fa theta fb theta ff gamma 
gamma 
sfc morphism fa theta theta tb lift gamma 
definition diagram commutes fa theta sfb lift sfc fa theta id theta categorical isomorphisms course canonical ones arising categorical property having specified binary products definition finite product preserving functor 
example fix category cpo 
note forgetful functor cpo set reflects 
categorical semantics fix structures fix signatures sg fix signature 
structure fix category specified data ffl object fl basic ground type fl sg ffl basic function symbol ff ff ff morphism form ff theta theta ff ff interpretation fix types structure shall show interpret syntax fix fix category types interpreted objects category interpretation type ff denoted ff definition definition interpretation type ff ffl unit def terminal object 
ffl null def initial object 
ffl nat def 
ffl fix def omega omega fpo 
ffl ff theta fi def ff theta fi ffl ff fi def ff fi ffl ff fi def ff fi ffl ff def ff interpretation fix terms context context gamma ff ff gamma def ff theta theta ff context gamma raw term type ff gamma ff valid judgement interpret giving morphism gamma ff gamma ff note gamma ff valid judgement type ff uniquely determined gamma abbreviate gamma ff just gamma gamma empty 
definition semantics terms context defined structural induction terms ffl gamma ff gamma def gamma theta ff theta gamma ff 
ffl ff ff ff basic function symbol gamma def gamma gamma ff theta theta ff ff 
ffl gamma hi def gamma 
ffl gamma fg ff def gamma gamma ff 
ffl gamma hm ni def gamma gamma gamma ff theta fi 
ffl gamma fst def gamma gamma ff theta fi ff 
ffl gamma snd def gamma gamma ff theta fi fi 
ffl gamma ff gg def gamma ff gamma fi gamma gamma gamma theta ff fi fl 
ffl gamma inl fi def gamma gamma ff ff fi 
ffl gamma inr ff def gamma gamma fi ff fi 
ffl gamma ff def cur gamma ff gamma 
ff fi 
ffl gamma def gamma gamma gamma 
ff fi theta ff fi 
ffl gamma val def gamma gamma ff ff 
ffl gamma def lift gamma ff hid gamma gamma gamma theta ff fi 
ffl gamma def gamma ffl gamma suc def gamma gamma ffl gamma def hhid gamma gamma gamma theta ff unique morphism arising universal property morphism gamma ff hid gamma gamma gamma theta ff ff ffl gamma def gamma omega gamma ffl gamma oe def oe gamma gamma omega omega gamma ffl gamma ff def hhid gamma gamma gamma theta omega ff unique morphism arising universal property fpo morphism gamma ff gamma theta ff ff completes definition categorical interpretations terms context 
models fix theories structure signature sg satisfies equation context gamma ff gamma gamma equal morphisms fix theory th called model fix theory satisfies axioms th 
substitution lemma lemma categorical semantics interprets substitution term variable term composition category 
precisely gamma ff gamma fi gamma ff ff gamma gamma ffi gamma gamma proof proof routine induction structure note section shall investigate general interpretation syntax fix theory subject requirement substitution syntax modelled composition morphisms essence supplies details proof terms computation fixpoint type 
soundness theorem important property models fix theories theorem theory satisfied theorem fix soundness fix category th fix theory model th satisfies equation context theorem proof check rules deriving equations context closed respect satisfaction details omitted 
interpretations computation types fixpoint type interpretation syntax fix theory perfectly standard understood 
interpretation computation types fixpoint type relatively new 
shall show interpretations general hope proviso substitution terms syntax modelled composition morphisms category theory 
suppose fix signature sg fix category modelling types interpretation computation types ff forced 
noted page operation 
ta categorical property fix category specified part definition 
interpret type ff object ff def ff type fix shall time interpret undefined object omega modelling terms context computation type consider rules gamma ff gamma val ff gamma ff gamma ff fi gamma fi syntax substitution commute term formation 
model substitution terms syntax composition interpreting morphisms category interpret rule need natural transformation gamma gamma ta yoneda lemma bijection op set gamma gamma ta ta particular action components arise post composition morphism ta definition morphism summarise gamma val ff def ff gamma similarly interpret second rule shall need natural transformation components ta theta theta tb tb apply naturality morphism hid gi gamma 
theta ta find theta id hid gi theta ta theta ta ta soundly interpret second rule natural transformation components theta tb theta ta tb morphism theta tb shall denote effect components 
combining results led definition gamma def hid ei structural induction gamma ff gamma modelling equations context computation type proposition order soundly model computation type equations need exactly structure category 
proof recall definition 
established necessity existence function gamma theta tb theta ta tb natural amounts asking theta id theta id theta tb precisely lifts 
computation type equations gamma val gamma val gamma working details order soundly interpret equation need id theta hid mi mi theta tb clearly sufficient ask holds 
necessity take theta theta theta id hid instance theta id id theta hid naturality gamma theta id id theta hid id theta order soundly interpret equation need hid ei ta theta sufficient hold 
necessity take theta ta ta theta ta theta ta theta theta id hid naturality gamma theta id hid hid instance required 
order model equation soundly need ask id theta hid hid eii theta id hid fi hid ei theta theta tb theta td ta consider projection morphisms theta ta theta ta ta theta ta theta 
theta ta naturality gamma equation id theta hid hid eii fi hid ei certainly sufficient equation lifta hold 
necessary show fi fi theta id hid naturality gamma fi theta id hid theta id hid theta id theta id hid equation theta id id theta theta id hid hid ii id theta theta theta id hid hid ii modelling terms context fixpoint type consider rules gamma fix gamma fix gamma oe fix gamma ff ff gamma fix gamma ff ff interpret rule shall need global element omega remember time omega just arbitrary object category 
gamma def gamma omega interpret second rule usual assumptions way shall model substitution shall need natural transformation gamma omega gamma gamma omega gamma yoneda lemma effect components arise post composition morphism oe omega omega gamma oe def oee structural induction gamma interpret third rule shall need natural transformation components theta ta theta omega gamma applying naturality hid ni theta omega get theta id hid ni theta omega theta omega omega soundly model third rule natural transformation components theta ta theta omega shall write 
effect function 
led setting gamma def hid ni gamma ff gamma modelling equations context fixpoint type proposition order soundly model fixpoint type equations shall need exactly category endowed fpo 
proof fixpoint type equations gamma val oe gamma val oe oe gamma 
gamma oe val oe gamma ff gamma ff oe val ff easy see sound modelling necessary sufficient triple oe omega gamma forms part equaliser diagram definition fpo 
note fix logic modulo rules soundness rule equivalent gamma oe val oe gamma ff order soundly model see necessary id theta oe fh lift jg theta ta theta omega theta omega sufficiency uniqueness requirement fpo immediate 
look structure needed soundly model 
put theta omega omega theta omega theta omega omega working details shall need id theta oe hid ei lift theta id hid hid eii appeal deduce theta id theta id reduces id theta oe hid ei lift jf hid eii universal property fpo certainly sufficient ensure holds 
see necessary note fh lift jf theta id hid lift jf theta id hid ii theta id hid lift theta id hid ii instance theta id id theta oe hid theta id id theta oe hid id theta oe note universal property fpo ensures omega oe determined isomorphism 
categorical logic correspondence ingredients describe usual categorical logic correspondence fix theories fix categories 
proposition fix category define certain fix theory denote th proof basic ground types objects morphism theta theta gamma 
basic function symbol gamma 
clearly canonical structure signature terms theory generated rules page 
axioms th specified gamma ff axiom th iff gamma gamma proposition fix theory signature sg construct syntactic fix category denote th proof ffl objects th types signature sg ffl morphisms domain ff codomain fi specified th ff fi def fm ff fi equivalence relation defined iff ff fi composition usual substitution terms tedious straightforward task check define fix category 
theorem fix category equivalence fix categories eq th eq gamma eq eq gamma fix category morphisms 
proof define eq eq gamma setting ffl eq ff def ff eq gamma def objects ffl eq def eq gamma def morphisms 
note eq defined appealing theorem 
equivalence categories inverse fix category morphisms lengthy calculation omitted 
definability fixpoints fixpoints fix fixpoint type called presence define fixpoint terms types form ff fi 
precise proposition proposition fixpoint definability presence fixpoint object may define expressions ff fi meta calculus arity term term fix term context gamma ff fi ff fi may derive gamma ff fi ff fi gamma fy ff fi ff fi ff fi proof define ff fi giving representative ff fi def ff fi ff oe easy see judgement derivable 
second put def ff 
ff fi ff fi ff oe ff val ff fi ff val oe val ff fi ff ff fi oe fy ff fi fixpoints cpo categorical logic correspondence easily see fix category fixpoints certain morphisms exist 
order illustrate apply categorical equivalent proposition fixpoint definability fix category cpo 
suppose cpo 
lifting 
write 
continuous maps 
known continuous map oe 

fixpoint 
categorical version proposition fixpoint definability says fixpoint oe oe 
note cpo case def oe oe arises unique mediating morphism diagram omega oe omega 
oe oe 
oe easy see commutativity diagram omega oe oe 
continuity oe oe 
oe oe 
exactly fixpoint oe respect order 
course argument really proof cpo fpo 
category fixpoint object case concrete category domains fpo morphisms lifted domains may guaranteed fixpoints 
definition category ffl objects posets possessing suprema chains ffl morphisms monotone set functions call maps 
easy see category ccc regard lifting functor giving rise strong monad 
case maps 
fixpoint 
map define ordinal ff element ff 
ff 
ff ff 
ff 
limit ordinal definition 
thing trivial existence set ff ff 
ff chain 
simple transfinite induction shows ff ff implies ff 
ff note ordinal fi fi 
fixpoint suppose case 
appealing lemma find ordinal say fl cardinality strictly greater cardinality domain say jd 
hypothesis case cardinality ff ff 
ff flg strictly greater jd 
contradiction 
proposition ccc possess fixpoint object 
proof cartesian closed may appeal lemma 
suppose fixpoint object omega exists 
write omega omega 
monic component unit lifting monad omega gamma equaliser condition fixpoint object ioe omega omega unique fixpoint bottom say 
omega remarks ordinal fi ioe fi 
note fi 
write oe oe oe ff oe oe ff oe ff 
oe ff note supremum exists 
ordinals objects take def define map 

setting def 

map 

restricted domain 
consider diagram omega oe omega 

commutes universal property fpo trivially 
similarly omega 
making omega oe omega 
commute 
uniqueness shall consider cases fi strictly greater 
case obtain contradiction defining map different commute 
case fi chasing see finite ordinal oe definition fi easy see oe fi 
chasing 
omega get fi 
oe 
fi contradiction 
case fi certainly oe oe finite ordinal oe oe 
oe 
oe fi oe 

define function omega 
def note 


case monotone 
elements omega greater monotone 
omega 

omega greater square commute 

clearly oe oe 
oe 
oe ff 

suppose omega greater 
oe oe 
oe ff 

suppose omega greater 
oe greater oe isomorphism 
oe gamma 

oe oe 
ff 
uniqueness criterion 
fixpoint object claimed 
functional completeness concept closely related correspondence fix theories fix categories functional completeness 
defining notion functional completeness ccc show categories functionally complete 
refer ls similar discussion concerning cartesian closed categories 
definition ccc object polynomial category variable specified data ffl objects just objects ffl morphism equivalence class obtained quotienting collection consisting morphisms indeterminate global element equivalence relation relation satisfying 
fg gf 
vu 
ffi id id ffi 
wv vu 
conditions forcing formal cartesian closure see ls 

lift lift 
lift lift 
conditions forcing category example amounts requiring lift theta id lift theta id corresponding lifts definition similar conditions hold structure equations 
polynomial category variables defined iterating construction just 
prove version functional completeness ccc 
assume categorical logic correspondence ccc may prove theorem internal languages 
alternatively theorem proved bare hands categorical logic developed way lambek scott prove equivalence ccc typed lambda calculus 
theorem functional completeness category polynomial category 
morphism unique morphism theta hx idi particular global element form fx unique morphism note write equality polynomial category 
proof proof result ccc ls just give details proof structure 
take morphisms theta tc lift theta tb tc theta theta theta theta theta theta tb 
theta theta tb obvious isomorphisms 
induction shall assume morphism theta theta tc satisfies functional completeness 
define lift def lift refer reader ls definition ccc structure 
check defined amounts showing respects conditions definition easy verify check detail structure equations condition lift lift hu lift lift definition lift ii lift ii appropriate lift theta id structure lift theta id lift ii lift hu lift hu show 
know defined prove result 
lift hx idi lift idi lift hx idi theta id ccc lift hx idi theta id lift hx idi induction lift proof complete 
proof functional completeness result direct calculation 
remarked result derive categorical logic correspondence 
explanation general ideas see ls 
theorem fix category equivalence fix categories eq th eq fix category morphism 
proof sketch types theory th objects terms theory th type defined global elements object rules inference finite products lambda terms ls 
structure suppose terms ta tb th term defined lift hid ei tb isomorphism theta theta equality terms equality 
category th objects types th morphisms terms th free variable 
define eq recipe ffl set eq def ffl th course put eq def ffi theta theorem 
remainder proof routine calculation 
results fix categories fix theories proof lemma proof suppose ccc triple oe omega gamma fpo satisfying hypotheses lemma 
theta ta shall categorical logic correspondence internal language need find unique morphism theta omega id theta oe fh lift view uniqueness property algebra look morphism say form 
define term context val xc write raw term context 
define term context omega omega rules logic fix get omega oe val definition val val xc val val xc val says exactly equation holds desired uniqueness immediate fix rules 
conversely existence algebra just take get required algebra 
elementary domain theoretic features fix fix certain features close spirit axiomatic domain theory properties categorical semantics similar concrete model cpo 
note certain results concerning fix known analogues cpo lemma lemma arbitrary fix category 
define morphism omega ta unique oe 
proof set def id ta note id id result follows universal property fpo 
corollary fix category morphism tb diagram commutes omega psi gamma gamma gamma gamma gamma ta tb proof note oe result immediate lemma 
object fix category morphism ta defined oe 
concrete fix category cpo morphism omega course continuous function constantly bottom 
morphism just selects bottom element domain 
question remains unanswered just axiomatic domain theory fix logic 
example fixpoints fix relate fixpoints category domains cpo 
shall return issues chapter 
fixpoint objects polynomial categories proposition fix category fpo omega gamma fpo omega gamma 
canonical inclusion functor 
proof show category fpo appealing lemma 
consider diagram omega oe omega hx idi psi gamma gamma gamma gamma gamma hx idi theta omega id theta oe theta omega theta tb oe gamma gamma gamma gamma gamma hx idi tb jh def lift jit set def hx idi morphism defined appealing theorem 
order prove hoe jh inspect diagram 
clear regions commute idi hx jh 
prove show lift jit hx idi jit hx idi appeal theorem note jit hx idi lift jit hx idi lift ih ii lift jit remains prove uniqueness 
suppose goe jg note hx idi hx idi sufficient prove 
show id theta oe lift done universal property fpo omega goe id theta oe sufficient prove lift idi goe lift idi hx lift hx uniqueness gamma hx jg jg done 
equaliser condition simple verify 
completeness models fix theories theorem semantics fix theories th sound complete 
complete mean equation context theorem th just case satisfied models proof proved soundness page 
equation theorem theory th just case satisfied generic model satisfied models particular satisfied possible check fix category model th essentially unique fix category morphism th gamma gamma particular th pure fix theory extralogical axioms th essentially initial object category fix categories fix category morphisms 
gluing cartesian closed categories technique gluing originated freyd neat method proving existence disjunction properties certain intuitionistic type theories 
proof certain topos manufactured toposes called glued topos account see ls 
essence method involves careful application certain theorem topos theory 
simple version theorem just ccc laf 
prove version theorem ccc 
lemma ccc gluing gamma functor ccc ccc 
suppose pullbacks gamma preserves finite products 
write gl gamma category gamma note obvious functor gamma case 
gl gamma ccc 

morphism ccc 
proof known result gl gamma ccc example see laf 
shall denote typical morphism gl gamma 
note property ccc categorical property 
statement gl gamma ccc mean obvious canonical choice structure 
definitions 
def gamma tx 

def id gamma 

theta gamma 
lift def lift theta gamma 
definitions clearly sense 
note third definition theta theta gammax theta gammay oe gamma theta gamma id theta gamma theta ty gammaz gamma gammat gamma oe gammat gamma lift verify equations definition page hold 
just check lifta 
take morphisms theta gamma 
theta gamma 
theta gamma 
consider commutative diagram theta ai theta theta gammaz theta gammat oe id theta gamma gammaz theta gammax gammaz theta gammat theta gamma gamma theta gamma id theta gamma si gamma theta tx gamma lift gamma theta ty gamma lift gammat gamma gamma theta tx gamma lift lift si gammat easy see lift lift ffi lift lift ffi ai si diagram lift ffi ai lift lift ffi lift exactly lifta glued category gl gamma 
immediate morphism ccc 
forgetful functor category locally small ccc category locally small categories 
course free functor category locally small categories category locally small ccc objects write fc left adjoint write unit adjunction locally small canonical functor 
fc 
prove corollary locally small category fc freely generated ccc 
canonical functor 
fc full faithful 
proof consider commutative diagram fc op set phi yoneda embedding topos presheaves functor phi arises essentially mate adjunction op set regarded category identity strong monad 
faithful implying 
gamma composite ffi fc gamma 
fc op set gamma 
op set certainly natural transformation ff gamma gamma 
fc gamma natural transformation ff ha gamma 
gamma ffi gamma 
op set may define functor gamma 
op set gamma setting def ff def gammai defined follows naturality ff op set gamma ccc follows lemma 
op set gamma op set op set gamma fc usual projection functors clearly universal property category fc says diagram commutes natural isomorphism op set gamma fc gamma gamma gamma gamma gamma phi phi phi phi phi phi phi phi phi phi phi phi fc say ki ki uniqueness condition universal property natural isomorphism clearly case take objects morphism ia ib fc consider diagram ha ja gamma hb jb ffi kg ffi gamma oe kg yoneda embedding full set def ffi kg ffi gamma object natural transformation ff ha ja gamma 
gamma ja gammai leads ff ff ffi gamma ffi ffi ff gamma ib ffi kg ffi gamma ffi ff gamma ffi ff gamma ffi ff case ff ffi ia ffi ff applying id get ffi id ffi id ffi id ia ffi id ia says exactly functor full 
result follows adaptation pitts proof corresponding result ccc 
may derive corollary proposition ml theory th term ground type fl containing object level variables provably equal equational logic ml ground term type fl 
ground term simply raw term ml function symbols basic 
proof term corresponds global element denotation fl classifying category theory th 
corollary global element arises global element denotation fl syntactic category arising ground types terms 
says exactly provably equal ground term logic ml presheaves categories monads finish chapter miscellaneous result proposition locally small category monad category presheaves category certain choice monad 
proof define strong monad ffl op set setting ffl sf def ta sf def tf ffl sff def ff ta ffl ffl def ffl def ffl def theta id ta morphism ff morphism op set 
routine check defined strong monad appealing lemma done 
part ii fix logic chapter fix logical system introduce fix logic 
roy definition initial algebra oe omega omega endofunctor contains existence uniqueness clause 
uniqueness requirement amounts form induction principle stated precisely theorem ls 
theorem initial algebra induction principle show subobject omega omega gamma suffices show composition oet ts omega factors 
omega gamma functor gamma category sets object part initial algebra natural numbers theorem equivalent usual principle mathematical induction known fact 
instance initial algebra induction consider case category cpo endofunctor lifting subobjects inclusive subsets 
suppose omega inclusive subset fixpoint object omega 
just inclusive subset omega fe omega omega oe sg 
state theorem way induction principle omega omega oe oe oe omega just fixed points definable universal property initial gamma algebra omega gamma scott induction principle fixed points sco derivable induction rule 
proposition scott induction ae 
inclusive subset 
continuous function 

oe fix proof theorem take def fn omega pg unique mediating morphism arising 
fpo omega gamma omega fix 
order formulate induction principle fixpoint type fix introduce constructive logic bee called fix properties terms fix similarities fix traditional axiomatic domain theory lcf pau plotkin approach denotational semantics partial continuous functions plo 
predicate logic fix fix propositions constitute part predicate logic equality 
rules equality conjunction universal quantification elements type form fragment order intuitionistic predicate calculus dum 
additionally certain predicate constructors implicitly contain forms implication disjunction existential quantification 
order set formal system logic defining extension notion fix signature defined section 
signatures fix definition fix signature sg specified section data ffl collection basic relation symbols distinguished relation symbols ff true false ff 
ffl sorting basic relation symbols list types written ff ff case shall write ff 
say ary basic relation symbol sorting consists types 
signature sg define propositions logic 
sg shall define syntax signature sigma collection ground arities gar set collection constants con consists function symbols relation symbols countably infinite set object level variables 
function symbols arities designated page object level variables arity term 
ary relation symbols considered arity term prop distinguished relation symbols represent truth falsity equality conjunction universal quantification usual arities remaining distinguished relation symbols arities 
term prop 
term prop term prop 
term 
term prop prop 
term 
term prop prop associated fix signature sg collection raw fix terms raw fix propositions 
closed expressions syntax generated sigma arities term prop respectively 
propositions context fix shall write gamma phi prop judgement context gamma raw proposition phi formed 
judgements generated rules case basic relation symbols sorting certain symbol determine form rule 
basic relation symbols gamma ff gamma ff gamma prop basic relation symbol sorting ff ff equality propositions gamma ff gamma ff gamma ff prop truth gamma true prop falsity gamma false prop conjunction propositions gamma phi prop gamma psi prop gamma phi psi prop coproduct propositions gamma ff phi prop gamma fi psi prop gamma ff fi gamma phi psi prop universal quantification propositions gamma ff phi prop gamma ff phi prop universal modality propositions gamma ff phi prop gamma ff gamma phi prop existential modality propositions gamma ff phi prop gamma ff gamma phi prop usual rules weakening contexts substitution raw terms object level variables derivable rules simple structural induction 
propositional theories fix propositional syntax fix logical system rules deducing validity propositions 
rules sequent natural deduction style 
sequent context basic judgement take form gamma phi finite set propositions 
intended meaning judgement deduction phi involves certain number undischarged hypotheses occur set shall write gamma psi phi gamma phi case empty simply omit symbol judgement 
fix theory th specified fix signature specific collection sequents context called axioms th 
collection theorems th consists collection sequents context contains axioms th closed rules weakening gamma phi wk gamma phi gamma gamma identity gamma phi prop gamma prop id gamma phi phi substitution gamma ff phi gamma ff sub gamma phi cut gamma phi gamma phi psi cut gamma psi equations logical rule deducing equations fix rule fix logic judgements form gamma ff judgements form gamma ff null type falsity entailment null null false truth entailment gamma prop gamma true falsity entailment gamma false gamma phi prop gamma phi equality entailment ref ff ff sym ff ff ff ff tran ff ff ff ff ff ff gamma ff fi sub gamma ff ff ff fi gamma ff phi prop sub gamma ff ff ff phi phi conjunction entailment gamma phi gamma psi gamma phi psi gamma phi psi gamma phi gamma phi psi gamma psi universal quantification entailment gamma ff phi gamma ff phi gamma ff phi gamma ff gamma phi universal modality entailment gamma ff val ff phi gamma phi gamma phi gamma val ff gamma phi existential modality entailment gamma val ff gamma phi gamma phi gamma ff val ff phi psi gamma phi gamma psi coproduct entailment gamma phi gamma fi psi prop gamma phi psi inl fi gamma psi gamma ff phi prop gamma phi psi inr ff gamma phi psi gamma ff inl fi ff fi phi theta gamma fi inr ff ff fi psi theta gamma theta ff gg disjoint sum condition gamma inl fi ff fi inr ff false modality condition gamma ff val mod gamma ff val nat induction gamma phi gamma nat phi phi suc gamma nat gamma phi fix induction gamma fix phi phi oe gamma fix gamma phi completes rules deriving sequents 
informal explanation fix propositions fix logic features common intuitionistic predicate calculus see dum 
introduces propositions form phi phi phi psi shall describe informally intended meaning syntax 
universal modality phi intended meaning ff val oe phi read type ff case provably equal value necessarily phi holds 
existential modality phi intended meaning ff val phi read possible provably equal val phi holds 
coproduct propositions phi psi intended meaning ff inl fi phi fi inr ff psi read case provably equal inl fi phi holds case provably equal inr ff psi holds 
terms ff unique provable equality fix logic 
fix necessary impose rules uniqueness explicit 
fix logic uniqueness derivable rules nat fix induction 
consider example uniqueness rule fixpoint type 
set phi def ff fix fix rules may deduce gamma fix fix val phi val val val val implies gamma phi phi oe done 
adjoint style formulation fix logic adjoint rules fix logic rules closely related categorical semantics chapter 
new system substituting rules counterparts fix logic 
equality entailment gamma ff ff ff phi ad gamma ff phi conjunction entailment gamma phi gamma psi ad gamma phi psi universal quantification entailment gamma ff phi ad gamma ff phi universal modality entailment gamma ff val phi ad gamma ff phi existential modality entailment gamma ff val phi psi val ad gamma ff phi psi coproduct entailment gamma ff inl fi phi theta gamma fi inr ff psi theta ad gamma ff fi phi psi theta ff gg equivalence systems lemma derived rules fix logic gamma ff fix term context gamma phi ts gamma phi gamma phi es gamma phi proof omit proof rule ts rule es note backwards direction follows sub 
forwards direction suffices show case single proposition 
hyp gamma theta prop sub gamma theta theta sub gamma theta theta hyp gamma theta phi cut gamma theta phi theorem original fix logic system defined page equivalent 
proof proof equivalence equality conjunction universal quantification known 
give details remaining forms proposition case imply ad hyp gamma phi gamma val phi gamma val val gamma val phi sub gamma val val val phi gamma val phi hyp gamma val phi es gamma val phi gamma phi es established lemma 
case ad implies hyp gamma phi ts gamma phi ad gamma val phi sub gamma val phi hyp gamma val cut gamma phi hyp gamma val phi ad gamma phi gamma phi case imply ad hyp gamma val phi psi val gamma phi val psi gamma phi phi val psi gamma phi phi gamma phi psi rule 
id gamma phi val phi hyp gamma phi psi gamma phi val psi gamma val phi psi val case ad implies hyp gamma val phi psi ad gamma phi psi gamma phi psi hyp gamma phi gamma psi gamma phi phi ad gamma phi val phi hyp gamma phi ts gamma phi gamma val phi ts gamma val phi result follows gamma val 
case imply ad hyp gamma inl phi theta gamma inl phi theta gamma phi psi inl phi theta similarly gamma phi psi phi psi gamma phi psi theta ff gg final rule 
hyp gamma phi psi theta ff gg gamma inl phi psi inl theta gamma inl phi phi gamma inl phi phi psi inl gamma inl phi theta case ad implies gamma phi psi phi psi ad gamma phi phi psi inl gamma phi phi psi inl hyp gamma phi gamma phi psi inl hyp gamma inl phi theta ad gamma phi psi theta ff gg gamma phi psi theta ff gg hyp gamma phi psi gamma theta ff gg extensions fix inconsistent extensions fix logic induction rule nat just usual principle mathematical induction 
induction rule fix rendered informally prove property phi holds elements fix sufficient prove computations element fix phi oe holds evaluates value value satisfies phi 
principle consistent see section fix propositions limited forms 
fact extending fix logic unrestricted intuitionistic negation implication existential quantification renders inconsistent 
proposition extending fix logic intuitionistic implication renders system inconsistent 
proof fix contains falsity false adding implication phi oe psi means negation phi phi oe false 
consider proposition phi def oe 
fix ts deduce gamma fix phi phi proposition see gamma val oe phi phi oe recalling provably equal val oe rules intuitionistic implication easy see gamma fix phi oe 
oe 
false structure map initial algebra isomorphism means fix gamma oe 
oe gamma fix phi oe 
oe false applying gamma fix phi induction principle fix entails phi holds fix particular oe contradiction 
proposition extending fix logic intuitionistic existential quantification renders system inconsistent 
proof proof mimics ideas show category cpo inclusive subsets model standard intuitionistic predicate calculus dum 
recall cpo beck chevalley conditions fail left adjoints projections case deduce left adjoints take inclusive subsets inclusive subsets unravelling beck chevalley global element cpo 
considering cpo theta omega inclusive subset omega mg deduce fn omega gg inclusive omega gamma 
consider term def fix oe fix recall discussion domain theoretic properties fix page 
set phi def nat oe val oe fix usual rules intuitionistic existential quantification fix rules may deduce val phi phi phi oe val fix phi 
particular means nat oe val oe fix oe mono oe isomorphism conclude 
results fix logic modality conditions state prove proposition shall chapter establishing categorical logic correspondence fix logic 
proposition fix logical system derivable gamma phi gamma val phi gamma phi gamma val phi gamma phi gamma fi psi prop gamma phi psi inl ff gamma psi gamma ff phi prop gamma phi psi inr fi proof forward directions easy see omit details 
shall give details backwards directions existential modality coproduct 
existential modality 
mono cut gamma val val phi phi ad gamma val phi phi sub gamma val phi phi result immediate 
move coproduct 
hyp gamma phi psi inl id gamma inl inl phi phi 
gamma inr inl psi phi gamma phi fu mg inl result follows rules coproduct equations 
frobenius reciprocity fix logic prove frobenius reciprocity style rule fix logic convenient lemma lemma fix logic gamma phi psi gamma phi psi proof ad sub 
proposition fix logical system derivable gamma phi val psi fr gamma phi psi proof prove forwards direction 
hypothesis lemma rules ad conjunction deduce phi val psi phi val psi id ad sub val phi val phi id phi val phi val phi val phi result immediate rules ad 
backwards direction note phi psi val phi val psi sake space omit contexts proof 
label sequent 
psi phi psi psi phi psi phi val psi ad cut done 
existence disjunction properties give results witness constructive nature fix logic 
bear resemblance existence disjunction properties standard intuitionistic logic ls pit 
theorem existence property closed term type ff phi derivable fix closed term type ff ff val phi derivable 
words formal proof evaluates value satisfying phi necessitates existence term denoting value 
theorem disjunction property closed term coproduct type ff fi phi psi properties ff fi phi psi derivable fix ff fi inl phi derivable closed term type ff ff fi inr psi derivable closed term type fi 
natural number type existence property enables produce closed terms type nat computation number closed term type nat proof computation converges 
remains possibility closed term type nat value standard numeral 
theorem nat closed term type nat fix provably equal standard numeral suc 
theorems proved chapter 
miscellaneous results lemma modulo remaining rules fix logic modality condition gamma ff val mod gamma ff val equivalent rule gamma phi mod gamma phi proof case mod implies mod applying twice hypothesis mod gamma val val phi mod obtain gamma val val suitable weakening hypotheses derived judgements apply obtain result 
case mod implies mod direction entirely straightforward give full proof tree id gamma val val val id gamma val val val gamma val val val gamma val mod gamma val premiss mod premisses completes proof 
lemma modulo remaining rules fix logic rule gamma val val mono gamma equivalent rule gamma phi mono gamma val phi proof sketch details 
case mono implies mono rule mono yields gamma val val applying ts hypothesis mono cutting cut done 
case mono implies mono rule mono yields gamma val apply hypothesis mono 
chapter categorical semantics fix logic fix hyperdoctrines background hyperdoctrines indexed categories see jp see pit 
definition fix hyperdoctrine specified fix category referred base category indexed poset op poset morphism base category denote corresponding pullback function fibre denoted adopt notational convention 
commuting square right beck chevalley conditions said hold abbreviated rbc right adjoints satisfy identity ffi ffi dual convention left beck chevalley conditions lbc 
indexed poset satisfies conditions 
fibres meet semi lattices element fibre initial object singleton 
top element denoted bottom element meet elements pullback functions preserve meets top bottom elements 

rbc holds squares form theta theta theta id morphisms product projections 

rbc lbc hold squares form theta id theta theta ta theta theta id id theta theta ta theta id hyperdoctrine enjoys form frobenius reciprocity theta ta theta id theta id theta id theta conditions ensure soundness rules universal existential modality entailment 

operation fibres theta theta theta gamma 
theta natural suppose elements theta theta theta theta morphisms theta theta demand id theta fi id theta gi ff ggi 

coproduct insertions theta theta oe gamma 
theta obvious isomorphism theta theta theta product projections 
ff gg def ffi oe gamma arises coproduct structure note exists determined uniquely 
requirements ensure soundness rules coproduct entailment 

lbc holds theta id theta delta theta theta delta theta left adjoint id theta delta satisfies frobenius reciprocity condition id theta delta ffi id theta delta id theta delta ffi 
theta theta theta recall pullback function preserves top element definition 
conditions ensure soundness rules equality entailment 

demand inequalities theta ffi delta 
ta delta 
hi ji ffi delta 
ta ta top elements fibres 

coproduct insertions 
guarantees soundness mono condition disjoint sum condition 

morphism theta ta theta theta tb demand inequality ffi delta 
id theta ffi hf ffi delta 
ta top element fibre theta ta theta theta ta theta ta theta theta product projections 
ensures soundness modality condition 
complete definition fix hyperdoctrine fibrewise induction conditions coherence condition 
induction conditions ensure soundness induction rules logic coherence condition guarantees semantic equality terms coincides derivable equality fix logic 

elements theta demand hid ffi id theta theta product projection part structure base category 

elements theta omega gamma demand id theta id theta oe theta omega theta omega product projections oe omega omega part structure fpo base category 

morphisms diagonal delta theta ask hf gi ffi delta 
completes definition 
morphism fix hyperdoctrines specified fix category morphism base categories referred base functor say indexed collection monotone functions called fibre morphisms fa fa object monotone functions required preserve structure fibres canonical fashion 
example pullback functions preserved fibre morphisms sense morphism square commutes fa fa fb fb structure fibres preserved fibre morphisms example ffl fa 
fa ffl fa fa fa ffl theta theta fc theta fc thetaa fc thetab remaining structure fibres preserved similar way details omitted 
fix hyperdoctrine cpo definition fix hyperdoctrine quite involved give concrete example 
proposition recall category cpo fix category 
cpo indexed poset cpo op poset takes cpo set inclusive subsets ordered inclusion takes continuous function inverse image function gamma restricted inclusive subsets 
gives rise fix hyperdoctrine 
proof trivial check gamma defined monotone functor 
define operations cpo fix hyperdoctrine omit detailed verifications 

meet intersection inclusive subsets clear fibre meet semi lattice element 
easy see pullback function morphism pointed meet semi lattices 

singleton 

right adjoint projection restriction dual image functions inclusive subsets rbc holds trivial 

existence left adjoints known restriction set theoretic direct image functions inclusive subsets 
right adjoint id theta gamma theta 
theta id theta def id theta cg theta easy see definition yields required adjoint 
checking rbc lbc easy frobenius reciprocity virtually immediate 

coproduct insertions 
elements theta theta define theta theta theta theta def id theta id theta note fibrewise induction conditions satisfied inclusive subset cpo cpo 
note existence concrete model implies consistency pure fix logic relative zermelo fraenkel set theory 
categorical semantics fix structures fix signatures fix hyperdoctrine sg fix signature 
structure specified data ffl structure base fix category see section ffl basic relation symbol ff ff element fibre ff theta theta ff interpretation fix propositions context structure show interpret fix logic fix hyperdoctrine 
propositions fix modelled elements fibres hyperdoctrine precisely context gamma proposition phi derive gamma phi prop specify element gamma phi fibre gamma 
gamma empty write phi 
semantics propositions context defined structure propositions ffl gamma true def gamma 
ffl gamma false def gamma 
ffl gamma ff def gamma gamma ffi delta 
ffl gamma phi psi def gamma phi gamma psi 
ffl gamma ff phi def gamma ff phi 
ffl gamma phi def hid gamma ffi id theta gamma ff phi ffl gamma phi def hid gamma ffi id theta gamma ff phi 
ffl gamma phi psi def hid gamma gamma ff phi gamma fi psi 
models fix theories finite set propositions formed context gamma set gamma def theta gamma theta structure fix hyperdoctrine satisfies sequent context gamma phi gamma gamma phi holds fibre gamma 
fix theory th called model theory satisfies axioms th 
substitution lemma lemma tells substitution terms variables propositions modelled 
lemma put gamma ff ff gamma phi prop fix proposition context gamma ff fix terms context 
gamma phi gamma gamma gamma phi proof proof proceeds induction structure propositions illustrate phi phi psi gamma phi gamma phi hid gamma gamma phi hid gamma ffi id theta gamma phi induction hid gamma ffi id theta ffi gamma theta id gamma phi hid gamma ffi gamma theta id ffi id theta gamma phi hid gamma gamma ii ffi gamma theta id gamma phi gamma theta id ffi hid gamma gamma ii gamma phi hh gamma gamma gamma ii gamma phi hid gamma ffi gamma gamma phi gamma hid gamma gamma phi gamma gamma phi gamma phi psi gamma phi psi hid gamma gamma phi psi hid gamma gamma phi gamma psi induction hid gamma gamma theta id gamma phi gamma theta id gamma psi hid gamma ii ffi id theta gamma gamma theta id gamma phi gamma theta id gamma psi gamma ffi hid gamma gamma phi gamma psi gamma gamma phi psi soundness theorem categorical semantics fix logic sound proposition soundness fix theories fix hyperdoctrine th fix theory model th satisfies sequent context theorem th 
proof need check collection sequents context satisfied closed rules generating sequents context 
give just example checking soundness existential modality entailment 
theta gamma theta val gamma phi gamma psi val iff theta id theta gamma theta gamma phi id theta gamma psi pullback functions preserve meet iff id theta gamma gamma phi id theta gamma psi adjointness holds iff id theta id theta gamma gamma phi gamma psi frobenius reciprocity iff gamma id theta gamma phi gamma psi iff gamma gamma phi gamma psi want 
categorical logic correspondence proposition fix theory th fix signature sg may construct syntactic fix hyperdoctrine shall denote th proof objects base fix category types sg 
morphisms equivalence classes terms single variable context 
set ff fi def fm ff fig iff ff fi theorem th 
define indexed poset 
object ff underlying set partial order ff consists equivalence classes propositions single variable context ff phi prop shall omit context convention impose preorder asking phi psi iff phi psi required partial order poset reflection preorder 
morphism ff fi pullback function fi ff defined substitution phi def phi check conditions defining fix hyperdoctrine satisfied 
condition obvious fibres meet semi lattices pullback functions preserve structure 
condition right adjoint fst fl fl theta ff written fl theta ff fl phi def ff phi hy xi required adjoint known rbc simple check 
check condition care 
right adjoint hfst val snd fl theta ff fl theta ff written fl theta ff fl theta ff phi def snd phi hfst xi check definition gives right adjoint phi psi hfst val snd phi psi phi hfst val snd psi sub phi hy val psi hy xi phi hy ei psi hy xi phi hfst snd snd psi hfst xi converse direction equally easy omit remaining details condition 
condition define operation fl theta ff theta fl theta ff fl theta ff ff elements phi fl theta ff psi fl theta ff set phi psi def phi psi isomorphism fl theta ff ff 
fl theta ff fl theta ff see satisfies condition take morphisms fl theta ff ffi fl theta ff ffi elements theta fl theta ffi pi fl theta ff ff 
remains show hfst inl snd pi phi hfst theta hfst inl snd pi psi hfst theta pi phi psi hfst fm ng theta follows careful application rule ad coproduct equations rules 
conditions easy verify 
moving condition left adjoint id theta delta fl theta ff theta ff fl theta ff defined id theta delta phi def phi hfst hfst snd snd snd ii fst snd snd snd structure needed specify remaining details routine omitted 
note condition immediate construction proposition fix hyperdoctrine define fix theory denote th proof basic ground types basic function symbols base fix category exactly defined section 
object theta theta relation symbols copies elements fibre theta theta 
gives data fix signature obvious canonical structure signature denote axioms theory th exactly sequents context satisfied canonical structure theorems th generated usual rules fix logic 
state categorical logic correspondence theorem fix hyperdoctrine equivalence hyperdoctrines equivalence indexed posets eq th eq gamma eq fix hyperdoctrine morphism 
categorical equivalence base categories isomorphism posets eq ff th ff eq ff eq gamma eq ff proof definition eq eq gamma see theorem 
define eq ff phi def phi eq gamma ff def ff omit routine details proof 
logical relations hyperdoctrine formalised correspondence fix theories fix hyperdoctrines define new fix hyperdoctrine corresponding theory logic prove theorems 
shall write fix hyperdoctrine constructed pure fix logic 
definition gamma cpo denote functor assigns object ff set gamma ff global elements equipped discrete partial order 
construct new fix hyperdoctrine denoted lr construction closely allied theory logical relations 
object lr triple ff cpo ff inclusive subset theta gamma ff 
morphism ff 
ff lr pair cpo ff ff satisfying condition gamma ff oe fm remains define lr indexed poset 
shall denote fibre object ff lr ff elements fibre consist triples phi 
runs inclusive subsets cpo 
phi ff 

theta gamma phi ff gamma phi ff def fm gamma ff phi note theta gamma phi ff cpo 
order inclusion second coordinates entailment third 
morphism ff 
ff lr define pullback function lr ff lr ff phi def gamma phi def gamma theta gamma phi ff fmg completes definition logical relations hyperdoctrine lr 
clearly need see lr really fix hyperdoctrine proposition construction lr detailed definition gives rise fix hyperdoctrine 
proof simple exercise verify definition sense 
check monotone 
suppose phi phi fibre lr ff ffl ae gamma ae gamma ffl phi phi phi phi substitution 
ffl see note phi fm phi fm need see ff gamma 
ff gamma 
ff case ffi ff ff details tedious easy omitted 
check definitions objects morphisms yield base fix category lr indexed poset constitute fix hyperdoctrine 
firstly check fix category details simple calculations clear defines various categorical constructs 
terminal object unit unit unit id unit binary product ff theta ff def theta theta ff theta ff putting theta def theta theta iff fst snd clear theta inclusive easy check remaining details 
exponentials objects defined ff ff def ff ff iff gamma ff oe ap ffi hf ap evaluation morphism transpose rule theta theta ff theta ff 
ff cur cur ff 
ff ff evaluation morphism ap ap finite coproducts defined hopefully familiar coordinatewise logical relations manner 
lr specified nat nat nat iff suc zero successor morphisms expected coordinatewise ones 
show particular choice monad category lr category 
action monad objects specified ff def ff iff oe gamma ff ff ff def ff ff 
ff canonical inclusion 
lifting rule theta theta ff theta ff 
ff lift theta theta ff theta ff 
ff course 

show lr possess fpo 
determined isomorphism previous constructs exhibit candidate show satisfies required properties 
expected candidate fpo omega fix fix structure morphism oe oe definition action shall drop sequent symbol equalities suc monad objects relation fix fix gamma fix oe oe preserve relation fix oem hold action monad yields fix oe oe preserves fix general forced fix oej oem considering relation fix certain inclusive subset led definition omega fix fix fpo lr ffl fix iff gamma fix oej ffl fix iff omega fix check relation fix inclusive 
take chain fix say fn fix ng gamma fix need check fn ng fix fn ng done 
omega choose fix get oej nr oej oej nr gamman fix arbitrary done 
check oe oe morphism lr oe oe omega fix fix omega fix fix cases cover 

fix oe 
fix oee 
fix note oej 
suppose 
fix fix omega nf fix particular gamma fix gamma fix oej gamma giving oej omega nf fix fix oee verify definition yields initial algebra lr 
take ff 
ff unique mediating morphism oe oe def coordinates mediating morphisms cpo firstly check morphism lr 
suppose fix get oej definition relation get oe gamma 
oe gamma fm suppose 
oej gamma gamma clearly oej gamma 
oej inductively 
oej fn prove 
fix need 
fn follows omit verify morphisms unit unit omega fix fix oe oe omega fix fix omega fix fix constitute fpo lr 
verify conditions definition 
easy see condition holds 
check condition detail 
firstly define right adjoint fst lr fl lr theta theta fl theta ff denote lr theta theta fl theta ff lr fl set theta phi def ffi theta phi ffi theta def theta gamma phi fl gamma ff oe theta hm nig sense 
certainly phi fl 
see ffi theta theta gamma phi fl 
obvious notation ng chain ffi theta gamma ff hn mi ng theta theta inclusive supremum chain lies theta exactly fc ng ffi theta clear monotone 
verify fst take psi lr fl theta phi lr theta theta fl theta ff need check gamma psi fst theta phi psi ffi theta phi clear third coordinates cpo fix hyperdoctrines 
need examine second coordinates 
suppose theta remains show ffi theta need 

gamma phi hy xi fl 

gamma ff oe theta hm ni check turn 

clearly ae 
psi psi ff phi hy xi ff phi hn xi 
immediate 

definition hn mi gamma theta gamma psi fst fl theta ff theta ng suppose gamma psi implying hn mi gamma psi fst fl theta ff theta hn mi facts see hn mi hypothesis done 
suppose ffi theta remains show theta hn mi supposition get ffi theta means theta hn mi get required right adjoint 
verify rbc holds square lr theta theta fl theta ff lr fl lr theta theta fl theta ff theta id theta id lr fl course know fine third coordinates 
just need check second coordinate 
ffi theta theta gamma phi fl oe theta hn mig theta hn mi theta id gamma theta gamma thetaid phi fl theta ff theta cj theta id theta theta id hn mig ffi theta gamma ffi theta gamma ffi phi fl ffi theta fn theta ffi ffi theta id gamma theta gamma ffi thetaid phi fl oe theta hn mig suppose ffi theta show theta ffi need see implies theta hn mi amounts showing 
theta id gamma 
hn mi gamma phi hf fst snd fl theta ff 
theta hn mi 
theta hfn mi check 
note gamma ffi ffi theta id gamma 
gamma ff phi hf xi phi hf mi 
immediate 
immediate ffi theta fn ffi theta ae theta ffi reverse inclusion similar 
move condition 
right adjoint id theta id theta lr theta 
theta fl theta ff lr theta theta fl theta ff shall write lr theta theta fl theta ff lr theta 
theta fl theta ff defined theta phi def ffi theta phi phi expected meaning ffi theta def hn ei theta gamma phi fl theta ff theta val oe theta hn mig omit check definition sense required adjoint 
shall just check rbc hold square commutes lr theta theta fl theta ff lr theta 
theta fl theta ff lr theta theta fl theta ff theta id theta id lr theta 
theta fl theta ff theta id theta id need check things second coordinate 
ffi theta hn ei theta gamma phi fl theta ff theta val oe theta hn mig theta hn mi theta id gamma theta gamma thetaid phi fl theta ff theta cj theta hfn mig ffi theta hn ei theta id gamma ffi theta gamma thetaid ffi phi fl theta ff theta ffi theta hfn eig theta ffi hn ei ffi theta id gamma theta gamma ffi thetaid phi fl theta ff theta val oe theta hn mig suppose ffi theta hn ei 
remains prove theta ffi hn ei means gamma ff val show 
theta id gamma 
hn mi gamma thetaid phi fl theta ff 
theta hn mi 
theta hfn mi hypothesis ffi theta hfn ei val oe theta hfn mi check 
theta id gamma ffi ffi theta id gamma theta id gamma 
hn ei gamma snd phi hf fst xi fl theta ff means phi hf xi val appealing proposition phi hf mi 
hypothesis 

immediate 
suppose theta ffi hn ei remains prove ffi theta hn ei gamma ff val need show 

hfn ei gamma phi fl theta ff 
theta hfn ei 
theta hfn mi hypothesis get val oe theta hfn mi check 
ffi theta id gamma theta id gamma ffi 
hn ei gamma snd phi hf fst xi fl theta ff phi hf xi val phi hf mi appeal proposition 

trivial 

immediate 
define left adjoint id theta id theta lr theta 
theta fl theta ff lr theta theta fl theta ff denote lr theta theta fl theta ff lr theta 
theta fl theta ff set theta phi def ffi theta phi ffi theta def hn ei theta gamma phi fl theta ff theta val theta hn mi omit check defined lbc satisfied give brief details frobenius reciprocity condition 
take theta psi lr theta 
theta fl theta ff theta phi lr theta theta fl theta ff observe id theta gamma psi hy ei phi hy xi psi hy val phi hy xi require theta theta ffi theta ffi theta suppose theta theta ffi hn ei exist theta theta hn mi unravelling supposition appealing observation conclude psi hn ei phi hn xi proposition may deduce psi hn ei phi hn mi 
conclude theta hn ei ffi theta hn ei suppose theta ffi theta hn ei need find theta hn mi theta hn mi ffi theta hn ei implies val 
observation deduce id theta gamma psi hn val phi hn xi 
id theta gamma appealing proposition deduce psi hn ei phi hn mi supposition done 
condition 
define operation lr theta cc theta fl theta ff theta lr theta cc theta fl theta ff lr theta cc theta fl theta ff ff sending elements phi lr theta cc theta fl theta ff psi lr theta theta fl theta ff phi psi def hn ei theta gamma phi psi fl theta ff ff cc theta inl hn mi inr hn ig omit check condition satisfied move condition 
left adjoint id theta delta id theta delta lr theta theta theta theta fl theta ff theta ff lr theta theta fl theta ff denoted id theta delta lr theta theta fl theta ff lr theta theta theta fl theta ff theta ff defined setting id theta delta theta phi def id theta delta ffi theta id theta delta phi ffi theta def hn ei id theta delta theta gamma id theta delta phi fl theta ff theta ff theta delta deltam theta hn mig check defined required adjoint 
take element theta psi lr theta theta theta fl theta ff theta ff course need check details middle coordinate 
action id theta delta id theta delta element gives theta def hn mi id theta delta gamma theta gamma id theta delta psi fl theta ff theta theta hn mig need verify theta ae theta ffi theta theta check direction 
suppose ffi theta theta take theta hn mi ae id theta delta gamma phi hn mi psi hn mi clear theta hn mi remains show theta hn mi show id theta delta phi hn mi clear hn mi gamma phi fl theta ff frobenius reciprocity write theta 
greatest element lr theta fl theta ff easy see theta ffi hn mi id theta delta ffi id theta delta gamma theta gamma id theta delta ffi id theta delta psi fl theta ff theta ff theta theta hn mig ffi theta shown define adjoints operations needed verify lr fix hyperdoctrine omit remaining details 
proving existence disjunction properties shall soon prove existence property disjunction property nat results stated section 
initial model fix logic proposition fix hyperdoctrine arising pure fix logic essentially initial fix hyperdoctrines 
proof immediate definition fix hyperdoctrine morphism 
shall need observations initiality see fix hyperdoctrine morphisms gamma obvious projections gamma cpo lr cpo lr lr fix hyperdoctrine morphisms satisfy commutative diagrams psi gamma gamma gamma gamma gamma id gamma oe lr cpo ff psi gamma gamma gamma gamma gamma id ff gamma ff ff oe ff lr ff ff ff ff ff ff disjunction property prove theorem 
note closed term ff fi corresponds morphism unit ff fi action base functor component lr morphism commutative diagrams unit unit 
ff fi ff fi ff fi square commutes ff fi ff fi lr ff fi ff fi ff fi unit unit lr unit unit theorem follows observing effect possible routes square 
variable type ff fi consider phi psi ff fi unit phi psi phi psi phi psi unit phi psi phi psi hypothesis unit preserves greatest elements relation unit non empty 
ff fi phi psi phi psi ff fi phi psi gamma phi psi ff fi phi psi ff fi id unit gamma phi psi theta gamma phi psi unit unit ff fi ffi idg relation exactly unit non empty yielding ff fi implies ff fi definition relation ff fi means loss generality global element gamma ff closed term ff fi inl may derive phi proposition 
existence property prove theorem 
take proposition phi ff square ff ff lr ff ff ff unit unit lr unit unit yields unit ff id gamma phi theta gamma phi unit unit ff non empty ff implies ff assumption phi fg gamma phi implying bottom 
closed ff val proposition phi formal adequacy fix logic finish section remarking existence property expresses formal adequacy fix logic 
corollary closed term type ff provably equal value val closed term type ff cpo interpretation ff ff 
proof immediate proof existence property 
proving natural number type prove theorem 
closed term type nat square nat nat lr nat nat unit unit lr unit unit arguing way previous section conclude nat deduce nat suc definition nat relation lr 
chapter applications fix logic chapter shall define syntax operational semantics little programming languages closely allied plotkin pcf 
pcf acronym programming computable functions 
essence syntax pcf simply typed lambda calculus ground types just natural numbers booleans enriched explicit operations arithmetic conditional ground types fixpoint operators 
syntax equipped call name operational semantics giving rise language pcf 
pcf investigated plotkin results appear plo 
languages investigate call ql hpcf resemble pcf syntax consists essentially simply typed lambda calculus extra arithmetical procedural fixpoint features 
differ having conditionals higher types 
syntax ql similar pcf higher order 
ql recursive function declarations fixpoint operators operational semantics call value 
hpcf call name operational semantics apart conditionals higher types identical pcf 
shall specify syntax semantics languages give translation suitable fix theory 
language state adequacy results static semantics dynamic semantics shows translation preserves structure original language 
emphasise ql hpcf simple adaptations plotkin pcf 
intention chapter just investigate suited fix logic interpreting reasoning quite standard languages 
fix logic viewed metalogic interpret ql hpcf account style programming language analysis see plo 
language ql define language ql specifying basic syntax types raw expressions syntax static dynamic semantics 
types expressions ql types ql grammar oe bool nat oe oe raw expressions ql grammar variables tt truth ff falsity natural numbers oe conditional successor predecessor zero test mn application oe function definition oe recursive functions static semantics ql static semantics assigns types expressions context 
judgement takes form gamma oe rules deriving judgements 
context gamma consists list typed variables variables assumed distinct 
variables bound usual way lambda abstractions recursive function declarations 
ql expression context gamma oe easy see free variables occur gamma type oe assigned raw ql term unique 
types nat bool referred ground types 
variables gamma oe gamma oe constants gamma tt bool gamma ff bool gamma nat conditional gamma bool gamma oe gamma oe gamma oe oe arithmetic gamma nat gamma nat gamma nat gamma nat gamma nat gamma bool functions gamma oe gamma oe gamma mn gamma oe gamma oe oe recursive functions gamma oe oe oe oe gamma oe gamma oe oe oe dynamic semantics ql call ql expression closed oe derivable necessarily unique type oe canonical ql expressions comprise subset closed expressions grammar tt ff oe give syntax ql call value dynamic semantics evaluation relation take form closed ql expressions canonical 
rules generating evaluation relation canonical forms canonical conditionals tt oe ff oe arithmetic tt ff functions oe mn recursive functions oe oe oe oe oe easy see dynamic semantics deterministic type 
translation ql fix logic shall give translation ql theory fix 
aim give interpretation language ql preserve structure properties 
fact pure fix logic interpret ql formally fix theory consider consists simply fix signature basic function symbols relation symbols extralogical axioms 
shall formal simply refer fix logic 
step translate static semantics ql suitable judgements fix logic 
interpretation static semantics expression context oe oe give term context fix think process translation ql fix 
static typing judgement oe oe oe translated oe oe oe term context variables fx expression syntax generated pure fix logic arity term fv fu closed ql expression context oe course translated judgement oe note superscript semantic bracket gamma refers fact specifying translation call value language 
shall refer informally call value translation 
order specify translation shall define expressions syntax generated object level signature fix arity term term shall denote pred zero representatives expressions equality meta calculus defined pred def snd fst fst ho oi zero def inr unit hi inl unit hi note judgements nat pred nat nat zero unit unit fix terms context difficult see pred zero properties expect 
definition fix ff def ff fx oe immediate ff ff fix ff ff fix term context 
translation ql fix ffl nat def nat ffl bool def unit unit ffl oe def oe ffl def val meta variable 
ffl tt def val inl unit hi ffl ff def val inr unit hi ffl def val suc ffl oe def fy ffl def val suc ffl def val pred ffl def val zero ffl mn def fx ffl oe def val oe ffl oe oe def oe oe interpretation dynamic semantics clearly minimal requirement interpretation dynamics semantics ql soundness equality holds fix 
pleasing canonical say fix computationally adequate interpreting ql 
shall soon see case order shall need little additional notation 
canonical closed terms ql note interpretation takes form val dce shall take informal definition dce translate dynamic semantics ql judgements fix simply instance evaluation relation judgement adequacy results ql static adequacy ql proposition ql static adequacy interpretation static semantics ql fix adequate sense oe oe formed ql expression context iff oe oe derivable fix 
proof directions proceed structural induction 
give example backwards direction 
case definition fix logic rules induction hypothesis oe oe oe oe oe oe oe oe oe immediate 
dynamic adequacy ql shall require lemma plotkin methods plo 
write gamma composition gamma ffi gamma ql fix cpo gamma standard domain theoretic semantics fix 
define relation oe elements oe canonical forms oe induction structure oe 
definition follows oe relation elements oe closed ql terms oe defined terms oe asking oe iff oe oe oe define ffl bool tt bool ff coproduct insertions 
ffl nat ffl oe oe iff oe oe oe oe oe lemma oe oe oe ql term context suppose oe oe oe continuous function gamma oe theta theta oe oe satisfies gamma oe proof proof proceeds induction structure illustrate proof cases case oe suppose conditions lemma satisfied 
need show gamma oe oe oe 
definition gamma show gamma oe ffi cur gamma oe oe 
oe 
gamma oe cur gamma oe 
definition relation show cur gamma oe oe oe oe remains show cur gamma oe oe induction hypothesis gamma oe provided gamma oe 
oe done 
case mn need show gamma mn say gamma oe gamma oe 
suppose gamma mn 
check gamma gamma write 
induction hypothesis oe oe 
oe leads oe original supposition oe may deduce conclude shall need lemma lemma call value interpretation ql oe oe ql terms context canonical dce def val dce means substitution meta calculus 
proof recall section chapter 
proof trivial structural induction illustrate example 
case induction dce dce theorem ql dynamic adequacy interpretation ql fix logic computationally adequate precisely closed ql terms canonical implies implies canonical proof proof forwards direction proceeds induction derivation give details cases application recursive function terms 
case mn minimality induction hypothesis obtain val val dc val dce mn fx dc dc lemma required 
case minimality induction hypothesis obtain val dc oe val dce put def note oe val val dc dc dc dc dx oe dc lemma done 
converse direction suppose oe val dce case say 
appeal lemma deduce oe canonical definition pcf style language hpcf define language hpcf specifying basic syntax types raw expressions syntax static dynamic semantics 
types expressions hpcf types hpcf grammar oe bool nat oe oe raw expressions hpcf grammar variables tt truth ff falsity natural numbers oe conditional successor predecessor zero test oe fixpoints mn application oe function definition static semantics hpcf variables gamma oe gamma oe constants gamma tt bool gamma ff bool gamma nat conditional gamma oe bool oe oe oe arithmetic gamma nat nat gamma nat nat gamma nat bool fixpoints gamma oe oe oe oe functions gamma oe gamma oe gamma mn gamma oe gamma oe oe dynamic semantics hpcf canonical hpcf expressions consist subset closed expressions grammar tt ff oe oe oe oe oe bm give syntax hpcf call name dynamic semantics 
apart conditionals higher types hpcf respect identical plotkin language pcf 
dynamic semantics evaluation relation just ql canonical forms canonical conditionals oe mb oe oe mn oe bn oe bm tt mn oe bm ff mn oe tt oe ff arithmetic mn mn mn mn tt mn ff fixpoints oe ny oe mn functions oe mn plotkin originally specified operational semantics pcf single step reduction relation form closed terms 
clearly hpcf operational semantics way details original specification plotkin pcf style semantics see plo 
omit details presenting hpcf style lead proposition closed hpcf terms canonical 
iff reflexive transitive closure 
proved succinctly lemma closed canonical implies translation hpcf fix logic interpretation static semantics expression context oe oe hpcf give translation term context fix 
static typing judgement oe oe oe translated oe oe oe translation hpcf fix ffl nat def nat ffl bool def unit unit ffl oe def oe ffl def meta variable 
ffl tt def val inl unit hi ffl ff def val inr unit hi ffl def val suc ffl oe def val bool val oe val oe fy ffl def val nat val suc ffl def val nat val pred ffl def val nat val zero ffl oe def val oe oe fix oe oe fx ffl mn def ffl oe def val oe note interpretation number possibilities 
course syntax hpcf sensible translation 
case fixpoint constants oe reasonable translations shall see quite different properties 
said important requirement translation preserves structure properties original language 
section shall give alternative translation oe investigate properties 
interpretation dynamic semantics ql see page adequacy results hpcf static adequacy hpcf prove proposition establishing translation static semantics hpcf sense precise information preserving 
proposition hpcf static adequacy interpretation static semantics hpcf fix adequate sense oe oe formed hpcf expression context iff oe oe derivable fix 
proof forwards direction induction structure term illustrate case 
case oe induction definition translation oe oe oe fact raw terms represented oe fix oe definition oe done 
clearly reverse direction equally easy 
dynamic adequacy hpcf shall need lemma lemma call name interpretation hpcf oe oe hpcf terms context def proof trivial induction 
theorem hpcf dynamic adequacy translation hpcf fix logic computationally adequate precisely closed hpcf terms canonical implies canonical proof uses rule induction derivation evaluation relation 
shall just give cases application fixpoint terms 
case functions minimality induction hypothesis obtain val get mn def lemma required 
case fixpoints minimality induction hypothesis translation application terms oe oe get mn oe fix fx oe prove 
prove converse direction method similar proof ql dynamic adequacy 
details omitted 
alternative translation fixpoints results sections remain true slightly different translation fixpoint constants oe proof computational adequacy translation straightforward 
proof uses existence property fix logic stated page 
translation fixpoint constants oe takes form oe def val oe oe fix oe order prove computational adequacy result uses new translation shall need lemma suppose gamma ff gamma ff fi gamma fi phi prop formed judgements fix 
gamma phi gamma phi proof labelling steps informal guidance 
gamma ff fi phi val phi gamma fi phi val phi fr gamma fi phi val phi mod ad gamma fi val phi phi val step follows lemma rule fr proved proposition 
applying cut gamma fi val phi phi hypothesis gamma phi done 
prove computational adequacy theorem theorem remains true replace translation constants oe page page 
proof clearly change original proof involve fixpoint constants 
direction case fixpoints applying minimality induction hypothesis translation application terms oe oe oe dce applying lemma obtain oe dce appealing existence property theorem closed term val oe dce oe definition oe see oe fix yielding mn oe fix required 
details converse direction omitted proof uses technique similar adopted proving ql dynamic adequacy 
part iii fix logic chapter representations scott predomains scott domains information systems known class scott domains scott continuous functions form category equivalent category information systems approximable maps 
note scott continuous functions set functions preserve filtered colimits directed suprema 
details see sco wl 
course definition scott domain element 
extend scott results structures just scott domains necessarily possess element shall call scott predomains 
literature describes different kinds domain number definitions non standard 
reason elaborate precisely mean scott predomain 
scott predomains systems category scott predomains definition poset subset bounded iff non empty write bd 
say bounded cocomplete bounded subset supremum 
cocomplete partial order poset possesses suprema colimits diagrams 
refer cpo call diagrams chains 
directed cocomplete partial order poset suprema directed diagrams recall directed diagram functor poset filtered category 
refer dcpo 
image directed diagram referred directed subset directed subset shall write supremum shall suppose part force notation directed 
subsets write supremum 
note dcpo cpo 
element finite iff implies directed set finite elements written ffi dcpo algebraic fe ffi dg note definition element finite element scott predomain bounded cocomplete algebraic dcpo 
shall say set function scott predomains preserves suprema directed subsets scott continuous 
note functor categories coincides categorical notion continuity preservation filtered colimits 
proposition scott predomains scott continuous functions form category ppd definition category 
suppose objects functor gamma theta tc op set represented object shall say exponentials 
proposition category ppd category respect lifting domains finite products stable finite coproducts exponentials fpo 
proof just sketch details 
forgetful functor ppd set creates stable finite products ppd scott predomain define lifted scott predomain 
expected 
obvious inclusion scott continuous function theta theta 
sending 
easy see gives rise category 
show ppd gamma theta 
representable say scott predomain define underlying set set scott continuous functions 
poset ordered pointwise 
dcpo ae directed subset 
setting def yields supremum non empty bounded fb 
bounded cocomplete exists 
show algebraic 
consider set function defined def ffi ffi easy check scott continuous finite finite elements arise way case fg 
omit details essence proof sco 
recall category dcpo scott continuous functions ccc 
course ppd full subcategory natural isomorphism ppd gamma theta 
ppd gamma immediate 
expected candidates fpo easily seen 
note category ppd cartesian closed 
details cartesian closure categories domains see jun 
category systems information systems provide form representation theorem scott domains 
essence domain corresponds natural way set sets ordered inclusion 
shall describe version original information systems may derive similar representation theorem scott predomains 
definition category systems consists objects def triples nonempty set nonempty set finite subsets subset theta coordinates triple respectively known tokens consistent sets entailment relation 
note shall confuse system token set triples satisfy data 


implies denotes non empty finite subset means 

implies fag 

implies fag 

implies 
implies means note part force judgement consistent 
refer objects systems empty system 
morphism sets empty consist ae theta satisfy 

xry xry implies xr 

xry implies ry refer morphism map identity just composition usual composition relations 
definition clearly similar information system sco wl 
scott original token sets contain distinguished element delta plays role element corresponding domain 
requirement removed resulting information systems represent scott domains noted wl consistent empty set plays role bottom element 
wl simply information systems equivalence class represents particular domain case scott sco 
requirement empty set consistent removed resulting structures shall see represent scott predomains 
step taken original definition approximable map altered order category systems equivalent scott predomains 
condition imposes direct total functionality condition maps 
definition approximable map inspected say approximable map fag may case continuous function jrj domains jaj jbj corresponding map working scott predomains means may element absorb inherent partiality definition approximable map proposition definition yield category proof essentially routine 
just look condition composition non empty systems 
maps sz finite fz implying fz details conditions maps essentially sco 
equivalence categories ppd scott families aim prove categories ppd equivalent 
order introduce auxiliary notion scott family sets 
definition scott family sets set non empty sets 
directed 
non empty non empty 
shall refer scott predomains domains scott continuous functions continuous functions systems 
proposition functor gammaj ppd prescription objects jaj empty domain empty consists non empty subsets implies 
ii implies morphisms jrj jaj jbj jrj def fb shall refer element jaj point proof lemma prove useful lemma non empty implies 
ii def fa ag point proof simple induction cardinality finite set 
ii consequence 
show jaj domain checked nonempty 
prove jaj scott family sets show family domain 
construction jaj set non empty sets 
check scott family 
take jaj directed 
certainly non empty subset 
finite 
ii 
take non empty jaj 
hypothesis implies 
ii obviously jaj poset structure ordered inclusion scott family says immediately dcpo 
jaj bounded cocomplete take jaj bounded say jaj set def fv jaj non empty 
hypothesis non empty set element element non empty 
jaj scott family means jaj certainly supremum show dcpo jaj algebraic convenient lemma finite elements dcpo jaj collection fx proof suppose jaj finite clearly fx ug sense consistent finite entailment closed desired 
suppose jaj finite cardinality entailment closure jaj showing finite 
jaj 
certainly fx ug easy see lemma directed set consists precisely finite elements jaj algebraic 
shown jaj domain remains demonstrate gamma defined functorial morphisms 
map 
jrj defined take jaj show jrj jbj 
jrj 
follows properties enjoyed fx fyg implying fx 
arbitrary finite set giving fx immediate fx done 
jrj continuous function see take fu ig jaj directed 
easy see ig directed ig exists jbj 
certainly ig jrj fu ig 
converse take jrj fu ig fu ig 
finite jrj ig gamma functorial morphisms id jaj jaj entailment closed 
take non empty jaj omit check degenerate cases involving empty 
fc xry fc fb take 
finite fx leading fx fx 
reverse inclusion trivial may deduce 
completes proof proposition 
show functorial construction domains 
precisely proposition functor xi ppd prescription objects define xid empty empty xid def ffi 
ffi set finite elements 
iff ffi bd 

iff ffi morphisms xid xie specified relation xid theta xie iff proof show xid just sketch details non empty 
algebraic finite element implying fin ffi 
theta ffi definition 
conditions definition easy verify 
empty set consistent bounded 
suppose immediate need see xi defined functorial continuous functions just sketch 
take continuous function non empty domains 
look condition definition 
xid algebraicity finite 
fdg conditions equally trivial 
confirming functoriality continuous functions routine calculation 
proof equivalence machinery just set prove theorem theorem functors gamma ppd xi ppd give rise equivalence categories 
proof domain 
convenient write xid def ffi 
course simply check isomorphism natural components consider 
isomorphism natural oe def fe ffi dg oe def non empty empty continuous function 
defined def fe ffi dg directed non empty subset ffi see 
bounded 
continuity take directed 
certainly directed easy 
oe defined take show directed 
non empty definition fe fe consistent xid implying bd fe 
def fe exists clearly inherit finiteness showing noting fe oe continuous take directed 
oe inherits directedness clearly oe oe oe need 
pair oe yields isomorphism domains virtually immediate omit verification naturality 
write def def jaj ffi 
show natural isomorphism empty map empty ig iff fx iff fx ig definition sense 
see recall lemma note supremum exists fx ig implying bd fx jaj map condition easy 
condition suppose ig fx jg 
thing clear easy see fx ig map note 
condition easy 
suppose fx jg fx need see fx jg case fx ig fx jg done entailment closure 
checking sr easy 
sketch details rs suppose fx jg fx ig implying fx ig fx jg 
conversely suppose fx ig fx jg 
see fx jg fx jg fx ig jaj implying fx jg 
conclude fx igs fx jg fx jg done 
finish give case naturality map check diagram commutes suppose fx igs fx jg fx jg jmj fx ig 
recall non empty definition jmj see fx ig mfx finite set deduce fy fy fx ig fy mfx collecting see fy fx igs fy fx conversely fx fx deduce jmj fx ig ja definition jmj entailment closure points ja says fx ig course fx gsx done 
large cpo shall little precise set theoretical conventions 
zermelo fraenkel zf set theory assume existence universe sets class meta subset universe precise defining class equivalence class zf formulae identified universally quantified bi implication omit formal details 
show collection forms cocomplete partially ordered class suitable ordering 
definition define order relation class ps element non empty iff 

iff 
iff lemma token set equals theorem class ps ordering cocomplete partially ordered class element 
proof easy see order partial order 
suppose chain fa 
supremum exists fa 
element empty 
definition category cpo objects cocomplete partially ordered classes morphisms scott continuous function classes 
category cpo full subcategory cpo 
proposition category cpo category respect lifting domains finite products stable finite coproducts exponentials fpo 
proof thing doubt existence exponentials possible check cpo closed formation exponentials chosen formulation set theory 
aim see object ps category cpo play role type universe 
precise details done emerge chapter 
clearly essence idea comes fact categories ppd equivalent just seen class seen large cpo 
saw proposition ppd finite products exponentials 

view ps type universe give constructions categorical structures directly show formation continuous respect order ps 
need observations finite ordinal large cpo ps def ps theta theta ps enjoying obvious pointwise order 
easy see morphism ps ps continuous iff coordinate 
observation lemma useful need definition ps ps function class underlying class ps 
said continuous token sets chain fa fa ff containment token sets 
lemma ps ps morphism 
continuous iff monotonic continuous tokens 
proof case immediate 
conversely fa chain 
ff fa lemma done 
categorical constructions give explicit canonical constructions finite products exponentials category 
constructions continuous sense lemma morphisms category cpo ps ps ps ps ps ps ps ps ps ps give rise canonical initial object terminal object liftings binary products exponentials category 
proof proof non empty effect morphisms involve empty clear explicit exponential construction 
omit details concerning definedness continuity put def def fg fg clear definitions 
prescribe ps ps take empty point take 
ffl 
def ffl iff ffl 
iff define ap ffl def theta ffl iff ffl iff projections product theta set define ffl def shall put def theta theta ffl iff theta theta ffl iff theta xc theta morphism ps ps defined 
fg fg 
fg fg 
fg fg 
ffl def bg fg ffl iff fin case fg fg fx ig implies fb ig gamma fg fx ib ng ffl iff fg fb see really 
non empty basic criteria definition satisfied 

definition 

immediate 

fg definition just note fbg 
fg immediate 
write fx ib ng non empty set fg 
suppose fx ig lemma may deduce fx ig fx means fb ig fb note fb deduce fb ig fbg 
write fg fx ib ng trivial fb 
suppose result trivial 
checking definitions may safely put fg fx ib ng fg fx ib deduce fb fb 
note 
obviously fx lemma fx fb fb ae fb deduce fb fb required 
remains show ps ps morphism cpo 
see continuity coordinate appealing lemma may simply verify continuous token sets coordinate 
verify coordinate take ps 
show def ap qb def qb 

note implies need iff clear fg non empty say fg fx ib ng note see fx ig iff fx ig iff 
need show iff non trivial fg fx ib ng 
note implies iff iff take directed set fa ig ps 
need prove fa ig qb ff ig 
take fa ig qb 
certainly okay 
fa ji ig qb ff ig 
definition suppose scott predomains 
continuous function called embedding necessarily unique continuous partial function rm id id referred partial projection 
class scott predomains embeddings specified partial projections forms category denoted ppd ep shall write mean defined lemma functor gamma ps ppd ep effect gamma objects commutes isomorphism ppd functors runs theta proof gamma defined objects points 
jaj ja define embedding partial projection pair jaj ae oe ja setting def fa def non empty undefined omit routine details verifying defined embedding pair 
give definitions isomorphisms check details 
noting clear 
define jaj jp def def define jaj theta jbj jap def theta def define jaj jbj jap def theta theta def fx wg theta fy wg theta definition definedness seen inspection construction ap qb proof lemma 
define jaj jbj jap def fg def fb non empty 
recall jaj jbj def jaj jbj see proposition 
defined take fg 
suppose take fg def fx ib ng fx ig definition monotonicity see fb ig fg ig ae fx ig jbj required 
suppose 
suppose 
fb index note fx ig lemma fx ig course fx ig ae arguing conclude fb ig jbj implying 
defined take jap jaj show jbj 
non trivial case take iy noting fx fx iy definition fy suppose noting fy fx fx iy fx gib implies fx gib 
see continuous function omit simple details 
isomorphism suppose fb fgg fb fg ug final step follows continuity converse note ib fg certainly ae take find fb implies fx completing proof 
note construction product ap quite different usual construction products information systems discussion products information systems see sco 
note full details categorical constructions example maps projections jap 
details easy fill 
small cpo avoid set theoretical complications section restricting cardinality sets underly constructions 
definition scott predomain countably set finite elements countable 
scott predomains give rise full sub category ppd ppd countably token set countable 
give rise full sub category definition difficult verify results put chapter 
theorem functors gamma ppd xi ppd defined section restrict equivalence ppd 
lemma set ps token sets subsets cpo element 
proof suprema ps unions element empty 
details easy verify 
lemma morphisms category cpo ps ps ps ps ps ps ps ps ps ps give rise canonical initial object terminal object liftings binary products exponentials category 
lemma functor gamma ps ppd ep 
effect gamma objects commutes isomorphism ppd functors runs theta miscellaneous results central main concerns note pleasing relationship scott families sets correspondence 
definition scott family sets define af empty empty put 
af def 
iff 
iff implies proposition scott family system 
proposition scott family 
ja proof sketch details 
showing ja easy 
prove converse take assume non empty 
proof goes approximating appropriately chosen sets particular fx ug set def fv clear non empty fx ug note set directed fx showing supremum easy 
proposition 
jaj proof empty case trivial non empty 
need show facts 
jaj jaj 
jaj iff jaj 
jaj iff jaj jaj jaj implies easy details omitted 
chapter fix logical system goal define logic able solve recursive domain equations aid fixpoint type 
approach adopt set logic universal type car 
elements type act codes external observable types 
recursive type realised considering corresponding fixpoint universal type 
order things precise shall define dependently typed equational logic called fix essentially fix exponentials universal type 
dependently typed equational logic fix signatures fix fix signature sg specified ffl collection basic type valued function symbols tagged arity term type 
ffl collection distinguished type valued function symbols denoted unit null nat fix dom el 
ffl collection distinguished type valued type constructor symbols theta ffl collection basic term valued function symbols tagged arity term term 
ffl collection distinguished term valued function symbols consists distinguished function symbols fix signature augmented ip jp ic jc jf ret 
define syntax signature sigma gar con shall set gar ftype con consists function symbols type constructor symbols countable number object level variables arity term 
distinguished symbols arities ffl unit null nat fix dom type 
ffl el term type 
ffl theta type type 
ffl type type 
ffl term 
ffl ip jp ic jc jf ret term term 
ffl term term 
raw fix types closed expressions syntax generated sigma arity type raw fix terms closed expressions arity term 
judgements fix logic fix dependently typed equational logic 
forms judgement involve contexts gamma raw terms raw types ff finite lists raw terms context gamma ff ff finite list variable type pairs variables distinct ov ff ae fx gamma ov ff finite set object level variables ff 
notation len denote length list judgements consider 
gamma ctxt 

gamma ff type ov ff ae ov gamma 

gamma ff ov ov ff ae ov gamma 

gamma gamma ov ae ov gamma 

gamma gamma len gamma len gamma 

gamma ff ff ov ff ov ff ae ov gamma 

gamma ff ov ov ov ff ae ov gamma 

gamma gamma ov ov ae ov gamma len len len gamma 
equational theories fix fix theory th signature sg specified data ffl basic type valued function symbol introductory axiom form gamma type ffl basic term valued function symbol introductory axiom form gamma ff ffl collection judgements form gamma ff called term equality axioms 
ffl collection judgements form gamma ff ff called type equality axioms 
theorems th exactly judgements provable rules equational logic contexts ctxt gamma ff type gamma ff ctxt gamma gamma gamma ff fi gamma ff gamma fi equational logic types gamma ff type gamma ff ff gamma ff ff gamma ff ff gamma ff ff gamma ff ff gamma ff ff gamma gamma gamma ff ff gamma ff ff equational logic terms gamma ff gamma ctxt gamma ff gamma ff gamma ff gamma ff ff gamma ff gamma ff gamma ff ff gamma ff gamma ff gamma ff gamma ff gamma ff gamma ff gamma ff gamma ff gamma gamma gamma ff gamma ff equational logic context morphisms gamma ctxt gamma gamma gamma gamma fi type gamma fi gamma gamma fi gamma ctxt gamma gamma gamma gamma fi type gamma fi gamma gamma fi equational logic axioms gamma gamma gamma type gamma gamma gamma ff type gamma ff provided introductory axiom gamma type introductory axiom gamma ff type equational logic axioms gamma ff gamma ff gamma ff gamma ff type gamma ff type gamma ff ff provided gamma ff term equality axiom gamma ff ff type equality axiom 
elementary external types gamma gamma type types unit null nat fix dom 
external binary product gamma ff type gamma fi type gamma ff theta fi type external binary coproduct gamma ff type gamma fi type gamma ff fi type external exponential gamma ff type gamma fi type gamma ff fi type external computation gamma ff type gamma ff type external decoding gamma dom gamma el type terms context rules term formation fix part fix rule function terms see page replaced rule exponentials 
exponential terms gamma ff fi gamma ff ff fi gamma ff fi gamma fi gamma mn fi internal elementary types gamma dom gamma dom internal binary product gamma dom gamma dom gamma dp dom internal binary coproduct gamma dom gamma dom gamma dp qd dom internal exponential gamma dom gamma dom gamma dp qd dom internal computation gamma dom gamma dom product externalisation terms gamma el dp gamma ip el theta el gamma el theta el gamma jp el dp coproduct externalisation terms gamma el dp qd gamma ic el el gamma el el gamma jc el dp qd exponential externalisation terms gamma el dp qd gamma el el gamma el el gamma jf el dp qd universal type retraction terms gamma tdom gamma ret dom computation externalisation gamma dom gamma el el equations context rules equation formation fix part fix rule function equations see page replaced rule exponential equations 
exponential equations gamma ff fi gamma ff mx ff fi gamma ff fi gamma ff gamma ff fi product externalisation equations gamma el dp gamma jp ip el dp gamma el theta el gamma ip jp el theta el coproduct externalisation equations gamma el dp qd gamma jc ic el dp qd gamma el el gamma ic jc el el exponential externalisation equations gamma el dp qd gamma jf el dp qd gamma el el gamma jf el el universal type retraction equations gamma dom gamma ret val dom substitution weakening particularly useful rules concerning substitution weakening may derived rules deducing theorems fix theories 
lemma lemma rules derivable write expressions type gamma gamma gamma gamma gamma ff type gamma gamma gamma ff gamma gamma ff gamma ff gamma fi gamma gamma fi gamma ff gamma ff gamma fi fi gamma gamma fi fi proof proceeds induction derivation judgements 
recursive types fixpoint objects seen interpret types languages objects categories 
known type natural numbers represented recursive type unit 
interpreting formal typing statements say category sensible denotation recursive type solution equation 
generally recursive types thought fixpoints assignments 
objects type denoted object operation usually functor satisfying properties ensure exists sp 
basic categorical notion type types category category object externally equivalent indexed equivalence gamma gamma 
endofunctor give rise internal functor interpretation recursive types fixed point endofunctors may equivalently solve fixed point motivation prove proposition proposition expression syntax fix recursive typing judgement form gamma dom dom may derive judgements gamma fix dom gamma fix dom proof set fix def dom ret oe 
claim immediate fix rules 
chapter categorical semantics fix logic categories modelling dependent type theories review categorical structure model dependent type theories 
earliest area undertaken cartmell car additional taylor tay 
shall give presentation categories attributes pitts account pit 
useful information str hp cgw ben 
categories attributes definition category attributes specified category terminal object called base category equipped structure ffl object collection fibrations fib write fflf projection total object base object ffl morphism fibration fibration called pullback pullback square form fflf fflf fflf id id fflf id fflf fg fflf ffi fg fflf notation categories attributes convenient adopt notational conventions useful presenting categorical semantics dependent type theories 
fibration fib shall write indicate section note section arising universal property pullbacks 
fibration lists associated total objects defined inductively 
empty list fibration list def 
fibration list fib fibration list def section lists associated morphisms defined inductively 
empty list section list fibration list def 
section list fib section list def gamma 
gamma 
fflf fibration list associated projection morphism defined induction length put def id gamma 
def fflf gamma 
gamma 
complete notational conventions definition generic sections 
fibration list generic section ffi defined appealing universal property pullback square ffl fflf ffi observation fix categories attributes seen logical systems fix fix correspond precise way fix categories fix hyperdoctrines respectively 
shall define categorical structure corresponds fix structures called fix categories attributes 
useful background information pit joh 
definition category attributes object fib regarded category objects fibrations morphisms fib def fix attributes satisfies conditions ffl fib category finite products stable finite coproducts exponentials 
fibration morphism tf tf pullback functions preserve categorical structure categories fib 
ffl distinguished fibrations omega fibrations obtained pulling back unique morphism object canonical terminal object initial object natural numbers object fixpoint object category fib 
ffl specified distinguished fibration terminal object retract fib 
specified distinguished fibration ffl gives rise specified internal type constructor morphisms ffl ffl ffl ffl ffl theta ffl ffl ffl theta ffl ffl ffl theta ffl ffl certain specified canonical type decoding isomorphisms write pr ffl theta ffl ffl projection 
fib 
fib 
fib ffl 

pr theta pr fib ffl theta ffl 
pr pr fib ffl theta ffl 
pr pr ffl theta ffl fix category attributes cpo results chapter enable give concrete example fix category attributes 
convenient lemmas lemma continuous functor cpo ep cpo cpo ep category embedding partial projection pairs cpo applying covariant grothendieck construction yields morphism cpo 
proof definition def sigma xg partial order structure iff embedding determined functor omit details check cpo order suprema chains def fx fi xn fxn jn trivial continuous 
lemma filtered category cocomplete category theta functor 
lim gamma 
lim gamma 
lim gamma 
lim gamma 
lim gamma 
proof routine application definition colimit filtered category 
lemma cpo ep continuous functor 
fx chain write supremum chain 
id ax fi xn xn proof result follows unravelling construction filtered colimits category cpo ep details similar result category embedding projection pairs full subcategory cpo pointed cpo sp proof embedding partial projection pairs cpo virtually identical 
lemma lemma 
cpo corresponds indexed family continuous functions chain fx fj xn xn xn def fx write embeddings partial projection 
example proof note underlying set theoretic function cpo corresponds family set theoretic functions required form 
easy see monotone just case monotone holds 
take arbitrary directed set form assume continuity monotonicity leads requirement fj xn xn fi xn def fx set left hand side equation chain due equation consequence monotonicity 
instance equation see continuous 
see implies take chain fx case xn xn chain apply instance equation directed set deduce fj xn xn xn xn fi xn xn xn lemma conversely suppose family continuous functions satisfy 
remains prove corresponding morphism continuous holds 
fi xn fj xm xm xm fi xn fj xm xm xm xn lemma fj xn xn xn xn fj xn xn prove main result section proposition category cpo fix category attributes 
proof base category course cpo certainly terminal object 
collection fibrations scott predomain collection continuous functors form cpo ep recall lemma fibration total object projection morphism cpo set def af simple check def sigma af theta get pullback square cpo required form ffla ffla def 
functoriality conditions satisfied shown cpo category attributes 
need see fib category finite products stable finite coproducts exponentials 
structure arises pointwise 
example fibrations product object theta defined setting theta def theta theta theta theta example projection morphism specified family projections theta easily checked satisfy lemma 
sketch details category structure arises pointwise application properties category cpo lifting monad operation objects 
defined def 
morphisms specified continuous family 
def 
theta define lift theta 
specifying family lift theta 

omit remaining details note structure preserving conditions immediate 
need define fibrations omega write fg terminal object cpo set def def def omega gamma def omega omega fpo cpo 
consider details fpo fib 
need see existence 
omega oe omega gamma omega give rise fpo omega gamma fib lemma need define family 


omega 
omega oe omega omega oe omega omega 
take constant families fpo omega oe cpo 
omit check equaliser diagram requirement shall give necessary details universal property fpo 
morphism fib need unique omega 
jh hoe lemma amounts defining unique continuous family satisfies equations diagram commutes omega oe omega 
existence candidate family immediate existence fpo omega cpo 
need check satisfy conditions 
satisfaction take consider diagram omega id omega 

condition demands id oeoe gamma oe gamma oe gamma 
oe gamma oe gamma satisfaction take chain fx set fx put xn xn xn xn 
xn 
xn 
fj xn xn oe fj xn xn oe fj xn xn xn fj xn xn xn xn xn lemma fj xn xn xn fj xn xn xn 
xn xn xn fj xn xn 
appealing universal property fpo cpo case fj xn xn id wanted prove 
define fibration cpo ep setting def ps retract condition fib immediate lemma 
course ffl theta ps shall take just ps remainder proof 
continuous functor ps cpo ep lemma regarding ppd ep full subcategory cpo ep remains verify existence certain canonical isomorphisms verify pr pr fib ps theta ps pr ps theta ps ps unravelling definitions see diagram form sigma psn jap sigma psn jaj jbj psi gamma gamma gamma gamma gamma pr pr ps define family isomorphisms cpo satisfy lemma jap jaj jbj ps lemma lemma 
shall check morphism satisfies equation 
take chain ps set supremum 
unravelling details write jap ja qb ja qb ja jb jaj ja jb 
jbj obvious morphisms set def qb explicitly def non empty undefined def fb non empty 
ffi ffi def undefined non empty fb bg need prove fi order show introduce notation 
put def ap qb def ffi ffi def def fe need show undefined fb def fb fb bg noting suppose 



suppose 
suppose contradiction say implies data imply contradictory 

follows bottom just case bottom 
remains show bottom fw implies trivially fbg conversely suppose fy xg bn implies fn leave remaining details type coding isomorphisms reader proof complete 
categorical semantics fix structures fix signatures structure fix signature sg fix category attributes specified ffl basic type valued function symbol fibration list fibration fib ffl basic term valued function symbol fibration list fibration fib section assumed length fibration lists match arities function symbols 
interpretation fix expressions suppose structure fix category attributes fix signature sg 
define relations forms judgement page appropriate structure relations kinds assumed fix judgements formed 
gamma ctxt fibration list len len gamma 
gamma ff type len len gamma fib 

gamma ff len len gamma fib 
gamma gamma len len gamma section list len len relations defined inductively rules ffl contexts ctxt gamma ctxt gamma ff type gamma ff ctxt ffl types gamma gamma gamma type ffl terms gamma ff gamma ff type gamma ctxt gamma ff type gamma ff gamma ctxt gamma ff gamma ff ffi gamma gamma gamma ff type gamma ff ffl term lists gamma ctxt il gamma gamma ff il gamma gamma gamma ff type il gamma gamma ff ffl elementary external types gamma gamma unit type 
gamma gamma null type 
gamma gamma nat type 
gamma gamma fix type 
omega gamma gamma dom type 

ffl external binary products gamma ff type gamma fi type gamma ff theta fi type theta ffl external binary coproducts gamma ff type gamma fi type gamma ff fi type ffl external exponentials gamma ff type gamma fi type gamma ff fi type ffl external computations gamma ff type gamma ff type tf ffl external decoding gamma dom hid di gamma el type ffl ffl unit null terms gamma ctxt gamma hi unit hid gamma gamma fg ff ff ffl ffl ffl binary product terms gamma ff gamma fi gamma hm ni ff theta fi ha theta gamma ff theta fi theta gamma fst ff gamma ff theta fi theta gamma snd fi projections arising product theta category fib ffl binary coproduct terms gamma ff gamma inl fi ff fi ia gamma fi gamma inl ff ff fi ja gamma ff fl gamma fi fl gamma ff fi gamma ff gg fl fflf ffi fflf ffi note 
ffl 
ffl gamma denotes abstraction unique mediating morphisms arising coproduct fib ffl exponential terms gamma ff fi gamma ff gamma fm fi tf gamma ff fi gamma ff ff fi cur fflt ffi ffi pr recall tf definition 
pr 
theta ffl computation terms gamma ff gamma val ff ja tf gamma ff tf gamma ff fi gamma fi fflt ffi ffi tf ffl natural number terms gamma gamma nat 
gamma nat hid ni gamma suc nat hid sni gamma ff gamma ff ff gamma nat hid ni gamma ff ni ffl ffl ffl unique morphism arising universal property fib 
id theta 
id theta 
pr ffl fixpoint terms gamma gamma fix 
omega gamma fix hid ei omega gamma oe fix hid omega gamma fix hid ni omega gamma ff ff tf tf gamma ff ff ni unique morphism arising universal property fpo omega fib omega id theta oe 
omega jg jg 
omega ffl internal elementary types gamma gamma dom 
gamma gamma dom 
ffl internal binary product gamma dom hid di gamma dom hid gamma dp dom hid ii ffl internal binary coproduct gamma dom hid di gamma dom hid gamma dp qd dom hid ii ffl internal exponential gamma dom hid di gamma dom hid gamma dp qd dom hid ii ffl internal computation gamma dom hid di gamma dom hid ffl product externalisation gamma el dp gamma ip el theta el aea theta gamma el theta el theta gamma jp el dp ae gamma ae theta ffl coproduct externalisation gamma el dp qd gamma ic el el aea gamma el el gamma jc el dp qd ae gamma ae ffl exponential externalisation gamma el dp qd gamma el el aea gamma el el gamma jf el dp qd ae gamma ae ffl universal type retraction gamma tdom hid ei gamma ret dom hid ret ei ret retraction morphism fib 
inspecting relations see give rise partial functions way 
judgement semantic sequents structure sg assignments gamma 
gamma ctxt gamma ff 
gamma ff type gamma ff 
gamma ff gamma gamma 
gamma gamma give rise partial functions 
partial functions defined argument write 
models fix theories notion satisfaction judgements arising fix signatures complicated type dependency 
give definition judgement satisfaction noted instance satisfied iff categorical structure unique 

gamma ctxt satisfied iff gamma ctxt 

gamma ff type satisfied iff gamma ff type 
gamma ff satisfied iff gamma ff 

gamma gamma satisfied iff gamma ctxt gamma ctxt 

gamma gamma satisfied iff gamma ctxt gamma ctxt 
gamma ff ff satisfied iff gamma ff type gamma ff type 
gamma ff satisfied iff gamma ff gamma ff 
gamma gamma satisfied iff gamma gamma gamma gamma fix theory th structure say model th satisfies rules introducing th axioms rules page 
substitution lemma lemma describes substitution types terms syntax fix theory modelled categorical structure fix category attributes 
lemma suppose gamma gamma case ffl gamma ff type implies gamma ff type ffl gamma ff implies gamma ff ffl gamma gamma implies ffi gamma gamma ffi proof proof proceeds induction derivation various judgements 
soundness theorem theorem fix soundness suppose fix theory th fix signature sg 
collection judgements theory th satisfied structure fix category attributes closed rules see page derivation judgements th 
consequently model th satisfies judgements theorems proof proof proceeds induction derivation various judgement forms previous lemma proof 
chapter prospects research loose ends tasks give concise review achieved particular highlight loose ends indicate possible lines research 
comments coincide roughly order presentation material thesis 
modular approaches program semantics logics fix fix fix builds computational calculus 
fundamental notion underlying calculus separation computations values 
extensions considered provide expressive logics allow reason particular notion computation 
development combine different kinds computation clearly important issue related area see mog mog 
date concerns combining various monads representing different forms computation chapter equational level level predicates 
investigation monadic predicate logics able vary underlying monad undertaken 
domain theoretic properties fix fix theory fixpoints terms higher order type ff fi ff fi concrete models thesis domain theoretic definition objects morphisms associated order 
consider fixpoints arising properties fpo categories delivered 
saw chapter fix categories fix theories properties reminiscent concrete categories domains axiomatic domain theory 
precise relationship fix axiomatic approaches domains needs established 
line investigation consider formal orders imposed fix connection formal fixpoints 
example formal order give sketch details 
shall need notion canonical non canonical terms 
arise elimination rules fix logic 
precisely raw canonical terms grammar hi hm ni inl ff inr ff ff val suc oe non canonical terms nc fst snd ff gg fm define operational reduction scheme fst hm ni 
write cl substitution closed terms cl object level variables ordered list subterms subterm hm ni 
define simulation ordering fixpoint say iff cl cl implies cl sigman lines carried smith simply typed calculus augmented surjective pairing natural numbers 
smi smith shows formal fixpoint obtained iterating term def coincides arising usual fixpoint combinator coincidence defined equivalence generated simulation ordering sketched 
proof techniques little unwieldy 
possible obtain similar results fix logic logical relations argument 
ordering terms fix partial order imposed collection global elements type ff 
definition category lr changed relation object ff satisfies oe relation possible see selection fixpoint fpo coordinate force proof fact third coordinate 
categorical semantics fix semantics fix unsatisfactory state 
definition fix hyperdoctrine complex prefer properties deducible 
originally semantics mimics domain theoretic model fix pursued modelling fix propositions distinguished class subobjects suitable category hyperdoctrine model fibres composed inclusive subsets cpo 
order set categorical logic correspondence manufacture fix category distinguished class subobjects fix logic essentially grothendieck construction applied initial fix hyperdoctrine 
category arising construction cartesian closed clear alter fix logical system consistent way ensure cartesian closure 
achieved hope conditions ensuring fix soundness come free consider fibrewise induction conditions fix hyperdoctrine imposed result shows peano axioms hold topos toposes model predicates subobjects 
existence disjunction properties results existence disjunction fix logic closed terms 
possible envisage relativised versions theorems example investigate propositions phi judgement gamma ff phi psi fix logic entails term context gamma ff gamma ff val gamma ff phi psi computational adequacy results pcf results chapter concerning computationally adequate translations pcf fix logic proved technique due plotkin plo 
nice see results proven gluing argument 
skeleton ideas proof follows define operational semantics terms fix logic judgements form gamma ff gamma ff 
defined inductively rules gamma im ff gamma ff fi gamma im fi gamma im fi operational semantics fix set ensure iff dce gamma dc unique 
idea equality deduce dc way logical relations gluing argument 
example recall category lr chapter 
definition relation object ff clause form ff iff oe ff im formal adequacy fix logic shows val dce cpo interpretation bottom show dc major obstacle terms equivalence classes fix logic equality 
problem working categorical level 
initial fix category replaced initial fix category 
types objects pure fix terms morphisms cells suitable reductions fix logic example val 

notion fix category morphism formulated carefully proof category similar lr defined clause fix category 
semantics pcf full abstraction problem pcf investigated number researchers plo sto 
fix logic semantics pcf chapter may throw light intricacies full abstraction possibly simplify known results just speculation time writing 
adequacy results languages recursive types applications fix logic 
step state prove adequacy results pcf style programming language recursive types 
example oe type context programming language translated judgement form dom oe dom 
particular recursive type oe translated dom fix oe dom 
synthetic domain theory little known exact links thesis similar ideas synthetic domain theory 
case complete sigma spaces form constructive model fix logic material relevant synthetic domain theory see hyl pho 
perform routine inter translation systems gain relate 
final logical systems interpret programming languages 
logics give meaning call name call value languages uniform way 
logic clean categorical semantics domain theoretic model 
seen logics give computationally adequate interpretations small programming languages 
essence immediate consists trying simplify categorical semantics giving extensive examples illustrating logical systems program logics particular extending applications languages recursive types 
bibliography bee beeson 
foundations constructive mathematics 
springer verlag 
ben 
fibred category theory foundations naive category theory 
journal symbolic logic march 
car cardelli 
polymorphic lambda calculus type type 
technical report systems research center lytton avenue palo alto ca 
car cartmell 
generalised algebraic theories contextual categories 
annals pure applied logic 
cgw coquand gunter winskel 
domain theoretic models polymorphism 
information computation 
cp crole pitts 
new foundations fixpoint computations 
th annual symposium logic computer science pages 
computer society press 
cp crole pitts 
new foundations fixpoint computations fix hyperdoctrines fix logic 
information computation 
lics special edition information computation 
cro crole 
categories equational logic typed lambda calculi 
hand written notes graduate lecture course university cambridge computer laboratory pages september 
dum dummett 
elements intuitionism 
oxford university press 
gir 
girard 
proofs types 
cambridge tracts theoretical computer science 
cambridge university press 
translated appendices taylor lafont 
hp hyland pitts 
theory constructions categorical semantics topos theoretic models 
categories computer science logic volume contemp 
math pages 
hyl hyland 
effective topos 
troelstra van dalen editors brouwer symposium studies logic foundation mathematics 
north holland 
joh johnstone 
topos theory 
academic press 
jp johnstone par editors 
indexed categories applications volume lecture notes mathematics 
springer verlag 
jun jung 
cartesian closed categories algebraic cpo 
technical report technische hochschule darmstadt january 
kah kahn 
natural semantics 
nivat editors programming generation computers pages 
elsevier science publishers north holland 
kel kelly 
basic concepts enriched category theory 
cambridge university press 
laf lafont 
logiques cat egories machines 
phd thesis univ paris vii 
lan landin 
mechanical evaluation expressions 
computer journal 
law lawvere 
adjointness foundations 
dialectica 
ls lambek scott 
type theory free topos 
journal pure applied algebra 
ls lehmann smyth 
algebraic specification data types synthetic approach 
mathematical systems theory 
ls lambek scott 
higher order categorical logic 
cambridge studies advanced mathematics 
cambridge university press 
mac mac lane 
categories working mathematician volume graduate texts mathematics 
springer verlag 
man manes 
algebraic theories volume graduate texts mathematics 
springer verlag 
mog moggi 
computational lambda calculus monads 
fourth annual symposium logic computer science pages 
computer society press 
mog moggi 
notions computation monads 
theoretical computer science 
mog moggi 
category theoretic account program modules 
draft project september 
mog moggi 
modular approach denotational semantics september 
working draft 
makkai reyes 
order categorical logic 
lecture notes mathematics 
springer verlag 
nps nordstrom petersson smith 
programming type theory volume monographs computer science 
oxford university press 
pau paulson 
logic computation 
cambridge tracts theoretical computer science 
cambridge university press 
pho 
phoa 
domain theory realizability toposes 
phd thesis university cambridge 
pit pitts 
polymorphism set theoretic constructively 
summer conference category theory computer science 
university edinburgh scotland september 
pit pitts 
notes categorical logic 
graduate lecture course cambridge university computer laboratory 
pit pitts 
evaluation logic 
birtwistle editor higher order workshop banff workshops computing pages 
springer verlag berlin 
pit pitts 
categorical logic 
technical report cambridge university computer laboratory 
appear handbook logic computer science oxford university press 
plo plotkin 
call name call value calculus 
theoretical computer science 
plo plotkin 
considered programming language 
theoretical computer science 
plo plotkin 
post graduate lecture notes advanced domain theory incorporating pisa notes 
dept computer science univ edinburgh 
plo plotkin 
structural approach operational semantics 
technical report daimi fn department computer science university aarhus denmark 
plo plotkin 
denotational semantics partial functions 
unpublished lecture notes csli summer school 
sco scott 
models lambda calculus 
unpublished script 
sco scott 
type theoretic alternative cuch iswim 
unpublished manuscript university oxford 
sco scott 
lattice flow diagrams 
technical report programming research group oxford university computing laboratory 
sco scott 
mathematical theory computation 
th annual princeton conference information sciences systems 
sco scott 
continuous lattices 
technical report programming research group oxford university computing laboratory 
sco scott 
domains denotational semantics 
icalp volume lecture notes computer science pages 
springer verlag 
see seely 
hyperdoctrines natural deduction beck condition 

math 
logik und grundlagen math 
smi smith 
operational denotational semantics 
technical report johns hopkins university 
sp smyth plotkin 
category theoretic solution recursive domain equations 
siam journal computing 
ss scott strachey 
mathematical semantics computer languages 
technical report programming research group oxford university computing laboratory 
sto stoughton 
fully models programming languages 
research notes theoretical computer science 
pitman john wiley 
str strachey 
varieties programming languages 
technical report programming research group oxford university computing laboratory 
str streicher 
correctness completeness categorical semantics calculus constructions 
phd thesis universitat passau 
mip 
sw strachey wadsworth 
continuations mathematical theory handling full jumps 
technical report programming research group oxford university computing laboratory 
tay taylor 
recursive domains indexed category theory polymorphism 
phd thesis university cambridge 
wl winskel larsen 
information systems solve recursive domain equations effectively 
technical report university cambridge computer laboratory 

