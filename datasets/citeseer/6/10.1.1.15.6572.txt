fundamental concepts object oriented databases klaus dieter schewe bernhard thalheim cottbus technical university computer science institute box cottbus 
claimed object oriented databases oodbs overcome limitations relational model 
formal foundation oodb concepts open problem 
worse relational databases commonly accepted datamodel existed early oodbs unification concepts missing 
reported contains results investigations formally founded object oriented datamodel oodm intended contribute development uniform mathematical theory oodbs 
clear distinction objects values turns essential oodm 
types classes structure values objects 
problem unique object identification occurs 
show problem solved classes extents completely representable values 
classes called value representable 
advantage relational approach existence structurally determined generic update operations 
show property carried object oriented classes 
case database consistency respect implicitly specified referential inclusion constraints automatically preserved 
result generalized respect distinguished classes explicitly stated static constraints 
arbitrary method integrity constraint exists greatest consistent specialization gcs behaves nice compatible conjunction constraints 
algorithm gcs construction user defined methods describe gcss generic update operations required 
shortcomings relational database approach encouraged research aimed achieving appropriate data models 
claimed object oriented approach key technology database systems languages 
systems arose efforts 
contrast research relational area common formal agreement constitutes object oriented database 
basic question object trivial variety answers large 
object oriented programming notion object intended generalization data type concept additional feature inheritance 
sense object orientation involves isolation data semi independent modules order promote high software development productivity 
development object oriented databases regarded object basic unit persistent data view heavily influenced existing semantic sdms 
object oriented databases composed independent objects provide maintenance inter object consistency demand degree basic style object orientation 
view common oodb research objects abstractions real world entities identity 
leads distinction values objects 
value identified object identity independent value 
object identity usually encoded object identifiers 
abstracting pure physical level identifier object regarded immutable object lifetime 
identifiers ease sharing update data 
identifiers relieve task provide unique identification mechanisms objects 
object oriented programming object names sufficient retrieving mass data name 
approaches oodbs object coupled value fixed structure 
point view contradicts goal objects abstractions reality 
real situations object changing aspects captured object model 
object model object consists unique identifier id set type value pairs set object pairs ref set methods published acta cybernetica vol 
types structure values 
classes serve structuring primitive objects having structure behaviour 
obvious multiple aspects view object allows simultaneously members class change class memberships 
setting discussion object migration migration specific form value change 
model class structure uniformly combines aspects object values 
extent classes varies time types immutable 
relationships classes represented referential constraints object identifiers involved 
class accompanied collection methods 
schema collection class definitions explicit integrity constraints 
identification problem 
important concept object oriented databases object identity immutable identity object encoded concept object identifiers 
advantages approach sharing mutability values cyclic structures represented easily 
hand object identifiers meaning user hidden 
study equality identifiers derived equality values 
literature notion deep equality introduced objects equal values objects deeply equal 
recursive definition interesting case cyclic 
introduce uniqueness constraints express equality identifiers consequence equality values 
basis address problem characterize classes completely representable identifiable values 
generic update operations 
success relational data model due certainly existence simple query update languages 
preserving advantages relational oodbs serious goal 
generic querying objects approached 
querying se set oriented operation necessary select just single object raise specific problems object identifiers things change completely case updates 
object value updated deleted defined exist object value 
object exists value generally value objects user decide update delete operation applied objects objects selected nondeterministically reject operation 
possible specify priori operation works way objects situations 
applies insert operations 
problem cases operations insertion deletion update objects defined generically 
authors chosen solution abandon generic operations 
identifying values represent object identity embody strict concept surrogate keys avoid problem 
approach different solutions concept hidden identifiers time formally characterize classes unique generic operations insertion deletion update single objects derived automatically 
turns exactly value representable ones 
consistency problem 
primary benefits database systems offer automatic enforcement database integrity 
type integrity maintained automatic concurrency control recovery mechanisms automatic enforcement user specified integrity constraints 
commercial database systems especially relational database management systems enforce bare minimum constraints largely performance overhead associated updates 
maintenance problem problem ensure database satisfies constraints certain actions 
approaches maintenance problem 
classical modification methods accordance specified integrity 
second approach uses generation mechanisms specified events 
occurrence certain database events update operations management component activated integrity maintenance 
research direction succeed limitations approach 
second active database research areas 
objectives show approach extended object oriented databases stronger mathematical fundamentals 
accuracy obviously important desirable feature database 
integrity constraints conditions data satisfy database updated commonly employed means helping maintain consistency 
relational databases specification enforcement integrity constraints long tradition oodbs integrity problem drawn attention 
object oriented databases integrity maintenance different approaches 
uses blind update operations 
case update allowed system organizes maintenance 
second approach methods rewriting 
approach effective 
assuming consistent database state modified method lead inconsistent state 
relational databases distinguished classes static integrity constraints discussed inclusion exclusion functional key multi valued dependencies 
constraints generalized object oriented case 
result existence integrity preserving methods generalized capture constraints 
shall describe resulting methods 
organization 
start motivating example section introduce section core oodm formalize concepts intuitively example 
section notions weak value representability introduced order handle identification problem 
genericity problem approached section 
show relationship value representability unique existence generic update operations 
consistency problem dealt section 
outline operational approach computation greatest consistent specializations gcss 
algorithm allows problem reduced basic update operations describe gcss 
summarize results describe open problems section 
motivating example section start giving completely informal oodm basis simple university example 
introduce types classes show example database instance content database timepoint 
representation instance requires object identifiers 
extend example introducing user defined constraints 
shall see enables alternative representations identifiers leads notion value representability indicate definition methods means model database dynamics 
sake simplicity describe generic update method generated system 
said distinguish values objects main difference defined values identifying objects require additional external identification mechanism 
types structure values 
give examples types 
example 
basically type built predefined basic types bool nat string predefined type constructors records finite sets lists unions type definition personname uses set constructor deltag tagged record constructor delta type personname firstname string string titles string personname definition type person uses type personname 
type person nat name personname person defines student subtype person naturally project value type student value type person type student nat nat name personname student definitions types sets values may define new type constructors follows ff parameter new constructor type ff nat spouse ff ut types build structural part oodm schema 
define schema collection classes class variable collection objects 
example 
object class structure combines aspects values associated object objects 
structure type definition involve nameless type definition 
class definitions involve isa relations order model objects class 
ffi indicate concatenation record types 
schema university class structure person class isa structure nat spouse class isa structure student ffi supervisor major minor class isa structure nat age nat salary nat faculty class isa structure string ut principle able describe content database timepoint 
database instances need type id object identifiers purposes unique efficient internal identification mechanism objects second modelling objects different classes objects 
case class associated representation type directly storing objects 
example 
name instance 
john denver professor dr mary stuart dr john stuart laura james dave ford john stuart laura james computer science philosophy music ut note conditions satisfied instance object identifiers unique class isa relations schema give rise set inclusion relationships underlying sets identifiers inclusion integrity identifiers occurring object value place corresponding occur object identifier referenced class referential integrity 
shall refer conditions model inherent constraints satisfied instance 
integrity constraints defined user added schema order capture application semantics shown example 
example 
express persons students departments name 
order formulate xp xs xd refer content classes cp person 
nat cs student theta id 
nat functions arise natural projection components person student respectively 
gives uniqueness constraints 
id person xp xp cp cp id student theta id xs xs cs cs id string xd xd assume salary professor determined age 
purpose age salary nat natural projections age salary values respectively 
functional constraint class id age age salary salary assume want guarantee spouse person spouse person gives abbreviations understood formula id tmp xmp xmp spouse spouse note constraints satisfied instance 
ut added uniqueness constraints object identifiers instances correspond values types associated classes 
called value identification types vc remove identifiers represent information purely value fashion 
example value representation type class simply person class need recursive type vmp person ffi spouse vmp values rational trees 
far structural aspects types classes constraints considered 
add methods classes order model dynamics database 
oodm methods modelled simple procedural style 
example 
describe insert method class 
person id value ident newid endif insertion class need complex input type recursively defined person ffi id person projection person corresponding subtype relation person id ident substitute spouse id endif ffi endif global method newid denote selection new identifier 
expression substitute denotes result replacing value expression shall syntax oriented guarded commands 
ut shall see methods described example canonical automatically derived schema 
corresponding generic update methods look quite similar difference output 
generic update methods exist value representable classes case enforce integrity respect model inherent constraints 
generic update methods need consistent respect user defined constraints 
achieve apply gcs algorithm user defined methods 
sections formally define concepts proof main results value representation generic updates integrity enforcement 
core object oriented datamodel section slightly modified version object oriented datamodel oodm 
observe object real world identity 
system provided object identifiers introduced capture identity 
real world object basis abstraction identifier identification object 
contrast existing object oriented object coupled unique type 
contrast observe real world objects different aspects may change time 
primary decision taken object associated type types change object lifetime 
applies objects 
np nt nc nr nf nm denote arbitrary pairwise disjoint denumerable sets representing parameter type class function method variable names respectively 
simple type system relational approaches data modelling called value oriented models real world entities completely represented values 
object oriented approach distinguish objects values 
values types 
general type may regarded immutable set values uniform structure operations defined values 
subtyping relate values different types 
algebraic type specifications allow open type systems 
sake simplicity deviate approach follow classical view type system consists basic types bool natural integer string type constructors records finite sets bags lists subtyping relation 
assume existence recursive types types defined system domain equations 
principle type systems defined 
addition suppose existence identifier type id non trivial supertype 
arbitrary types defined nesting 
type occurrence id called value type 
shall proceed giving formal definition types 
definition 
base type bool nat int float string id 
ii nf ff fi ff np 
type constructor ff ff record fffg finite set ff list hffi bag ff fi union 
iii type base type type constructor generalized constructor results replacing parameters type constructor types recursive type defined equation fff tg generalized constructor parameters ff replaced nt cases remaining parameters type constructor parameters replacing types yield parameters ff ff 
iv type called proper iff number parameters 
called value type iff occurrence id 
type form consists type name nt type possibly parameters replaced type names 
vi type specification finite collection type forms tn type names occurring names tn semantics types sets values defined usual 
assume standard operators base types records sets bags 
omit details 
proper type occurring type exists corresponding occurrence relation theta bool introduce subtypes 
detailed types see 
definition 
subtype relation types rules type subtype subtype 
nat int float 
gamma ff gamma ff ff gamma ff gamma ff ff ff 
fffg ffig ff fi hffi iff ff fi 
fffg hffi ff hffi 
ff fi ff fi 
ii subtype function function subtype supertype defined 
class concept structural primitive class concept provides grouping objects having structure uniformly combines aspects object values 
generic operations objects object creation deletion update values associated classes provided operations defined 
objects belong different classes guarantees object object model captured collection possible classes 
values defined types objects defined classes 
object class consists identifier collection values objects classes 
identifiers represented unique identifier type id values combined representation type occurence id denotes classes 
may define structure class parameterized types 
definition 
value type parameters ff ff distinct names rn nr class names cn nc expression derived replacing ff called structure expression 
ii structural class consists class name nc structure expression set class names dm nc called set superclasses 
call named class class type derived replacing type id called representation type tc class type uc ident id value tc called class type 
iii structural schema finite collection structural classes cn closed superclasses 
iv instance structural schema assigns class value type uc conditions satisfied uniqueness identifiers class id tc inclusion integrity subclass id dom dom tc subtype subtype function tc id tc referential integrity corresponding occurrence relation id tc dom user defined integrity constraints extend notion schema explicit user defined integrity constraints 
define notion constraint schema general restrict distinguished classes constraints arise generalizations constraints known relational model functional key constraints inclusion exclusion constraints 
definition 
fc cng structural schema 
integrity constraint formula underlying type system free variables fr xc variable type call xc class variable 
ii constrained schema consists structural schema finite set integrity constraints 
iii instance constrained schema instance underlying structural schema 
instance said consistent respect integrity constraint iff substituting class variable xc evaluates true interpreted usual way 
note conditions instance definition correspond model inherent integrity constraints 
refer constraints implicit identifier isa referential constraints schema define distinguished classes user defined constraints 
definition 
classes schema tc tc subtype functions 
functional constraint constraint form id tc xc xc ii uniqueness constraint constraint form id tc xc xc uniqueness constraint called trivial iff tc id hold 
iii inclusion constraint constraint form id tc xc id tc xc iv exclusion constraint constraint form id tc tc xc xc methods basis behaviour modelling far static aspects considered 
structural schema simply collection data structures called classes 
turn adding dynamics picture 
required object oriented approach operations associated classes 
gives notion method 
shall distinguish visible hidden methods emphasize methods invoked user 
intended define interface class moment methods class including hidden ones accessed methods 
justification weak hiding concept due reasons 
visible methods serve means specify nested transactions 
order build sequences database instances regard transactions assuming linear invocation order 
hidden methods handle identifiers 
identifiers meaning user occur input output transaction 
definition 
structural schema 
tn types nm om 
method signature consists method name set input parameter input type pairs set output parameter output type pairs write om tn ii structural class method consists method signature name body recursively built constructs assignment class variable xc local variable term type skip fail loop sequential composition choice uts projection guard restricted choice ut thetas formed formula variable type instantiation method class input parameters output parameters variables type term type variable 
iii method class signature om tn called value defined iff proper value types 
mentioned oodm distinguishes transactions methods visible user hidden methods 
require transaction value defined 
subclasses inherit methods superclasses overriding allowed long new method specialization corresponding methods superclasses 
overriding mandatory case multiple inheritance name conflicts 
method overrides hidden method superclass hidden 
definition 
structural schema structural class definition superclasses dk method specification consists sets methods fm mng called transactions fm called hidden methods properties hold value defined 
ii transaction superclass exists ng specializes 
iii hidden method superclass exists mg specializes briefly discuss specialization means input output types 
required input type overriding method subtype original covariance rule opposite contravariance rule required 
rule applies want override insert method 
case inherited method effect subclass simply calls old method 
second rule applies input types required superclass omitted subclass 
rules captured formal notion specialization 
omit details 
prepared generalize definition classes schemata 
definition 
class consists class name nc structure expression set class names dm nc called set superclasses method specification fm mng fm 
ii behavioural schema finite collection classes fc cn closed superclasses method call collection integrity constraints 
iii instance behavioural schema instance underlying structural schema 
database history sequence instances transition gamma due transaction class note relation database histories semantics object bases 
queries views roughly speaking querying database operation database changing state 
emphasis query output 
general view queries subsumed transactions methods oodm query languages particular intended declarative order support ad hoc querying database need write new transactions 
querying relational database expressed terms relational algebra 
view easily generalized oodm type system 
terms types occur naturally 
type specifications type specifications constructors selectors functions 
allows arbitrary terms involving class variable xc built 
query turns represented term type free variables class variables 
approach accordance algebraic approach called universal traversal combinators 
relational algebra view may regarded simply stored query derived relation 
shall try generalize view oodm 
things change dramatically object identifiers come play distinguish queries result values result collections objects 
distinguish oodm value queries general access expressions 
value query schema represented term value type fr sg 
ad hoc querying database restricted value queries 
loss generality type involving identifiers exists corresponding type allowing multiple occurrences 
take class want get objects class matter values corresponding term xc value query tc value type may take natural projection subtype functions ident id value ff ident id value ff hffi case arbitrary access expressions problem occurs 
far build terms involve identifiers existing database 
queries called object preserving want result query represent new objects want object generating queries apply mechanism create new object identifiers 
achieved object creating functions type id arity id theta theta id id 
idea view stored query carries easily 
structure view compatible structure schema view may regarded derived class 
summarizing get formal definition 
definition 
fc cng schema 
value query term proper value type fr 
ii access expression term proper type fr 
iii view consists view name nc class name structure expression containing classes views defining access expression type tv representation type corresponding 
iv complete schema behavioural schema finite set views 
instance complete schema instance underlying structural schema view replacing class variable xc access expressions yields value type satisfying uniqueness property identifiers 
object identification problem object oriented point view database may considered huge collection objects arbitrary complex structure 
problem uniquely identify retrieve objects collections 
object database abstraction real world object unique identity representation objects oodm uses identifier type id encode identity 
identifier may considered immutable 
systems oriented view permutations collapses identifiers changing affect behaviour database 
user identifier object meaning 
different access identification problem required 
show unique identification object class leads notion weak weak value representability capture objects exists depend objects 
related weak entities entity relationship models :10.1.1.8.769
stronger notion value representability required unique definition generic update operations 
notion value representability definitions objects class identical iff identifier 
constraints especially uniqueness constraints restrict notion equality 
address characterization classes objects completely representable values drop object identifiers replace values referred object 
shall see section case value representable classes able preserve important advantage relational databases existence structurally determined update operations 
definition 
class schema representation type tc 
called value identifiable iff exists proper value type ic instances function tc ic uniqueness constraint defined holds 
ii called value representable iff exists proper value type vc instances function tc vc uniqueness constraint defined holds uniqueness constraint defined function tc proper value type exists function vc unique codom ffi easy see value representable class value identifiable 
value representation type vc definition unique isomorphism 
value representability case acyclic graphs value representability defined existence certain proper value type hard decide arbitrary class value representable 
case simple classes problem easier deal uniqueness value constraints 
case helpful analyse structure class 
graph theoretic definitions 
definition 
graph class schema smallest labelled graph grep satisfying exists vertex vc vc ft cg top level type structure expression 
ii proper occurrence type id tc exists unique vertex ftg 
iii structure expression graph ref subgraph ref 
iv vertex vc corresponding xn exist unique edges vc respectively case type vc case case fs corresponding selector name case label fs definition 
fc cng schema 
fc schema exists uniqueness constraint defined tc identification graph id class obtained graph changing label 
ii identification graph id resulting trivial uniqueness constraints called standard identification graph 
clearly need exist identification graph existence identification graph imply existence standard 
standard identification graph exist equal graph 
proposition 
class schema acyclic graph ref exist uniqueness constraints occurs label ref value representable 
proof 
induction maximum length path ref structure expression type tc proper value type 
exists uniqueness constraint identity function id tc defines uniqueness constraint 
vc tc satisfies requirements definition 
structure expression induction hypothesis holds ref acyclic 
vc result replacing vc vc satisfies requirements definition 
ut corollary 
class schema exist acyclic identification graph id uniqueness constraints occuring label id value identifiable 
computation value representation types want address general case cyclic may occur schema fc cng 
case simple induction argument proof proposition applicable 
take approach 
define algorithms compute types vc ic turn proper value types certain conditions 
subsection show types value representation type value identification type required definition 
algorithm 
provided exists uniqueness constraint defined tc undefined 
id occurs corresponding write id iterate long possible rules proper value type id occurs replace corresponding id 
ii id occurs recursively defined result replacing id type name 
iteration terminates exists finite collection classes 
rules longer applicable replace remaining occurrence id type name provided defined 
ut note algorithm computes mutually recursive types 
give sufficient condition result algorithm proper value type 
lemma 
class schema exists uniqueness constraint classes occurring label identification graph id ic type computed algorithm respect uniqueness constraints definition id ic proper value type 
proof 
suppose ic proper value type 
exists occurrence id ic corresponds class uniqueness constraint occurring label id contradicts assumption lemma 
ut finiteness property address general case 
basic idea finite number objects database 
assuming database consistent respect inclusion referential constraints yields exist infinite cyclic 
expressed finiteness property show property allows computation value representation types 
definition 
class schema gk denote path ref vc vc provided structure expression ck cycle ref sequence delta delta delta gn gamma cn ck 
note paths edges edges ref correspond 
definition class exists referential constraint ck defined ok tc theta id bool corresponding gk cycle exists corresponding sequence functions delta delta delta gamma follows define function cyc id theta id bool corresponding cycle ref definition 
class schema delta delta delta gn gamma cycle ref corresponding cycle relation cyc id theta id bool defined cyc true iff exists sequence true gamma 
cycle relation cyc cyc th power cyc 
lemma 
class schema satisfies finiteness property instance cycle ref corresponding cycle relation cyc satisfies dom dom cyc true cyc true proof 
suppose finiteness property satisfied 
exist instance cycle relation cyc object identifier dom cyc true cyc false holds 
corresponding elements pairwise distinct 
infinitely objects contradicting finiteness database 
ut lemma 
instance schema fc cng 
satisfies stage algorithm uniqueness constraints defined tc 
proof 
sufficient show rule applied replacing defines uniqueness constraint suppose holds possible apply rule exists value id occurring 
replacing id corresponds replacing value 
finiteness property value exist 
due uniqueness constraint defined function representing replacement injective 
ffi defines uniqueness constraint ut assume trivial uniqueness constraints algorithm 
order distinguish situation general case write refer special case 
lemma 
instance schema fc cng 
stage algorithm applied arbitrary uniqueness constraints parallel trivial ones exists function unique codom ffi proof 
proof lemma sufficient show required property preserved application rule versions algorithm 
satisfy required property functions corresponding application rule respectively 
functions constructed proofs lemma lemma respectively 
ffi satisfies required property respect application case applying know injective codom 
continuation gamma codom 
ffi satisfies required property 
ut theorem 
class schema exists uniqueness constraint classes occurring label graph ref vc type computed algorithm respect trivial uniqueness constraints ic type computed algorithm respect arbitrary uniqueness constraints 
value representable value representation type vc ic value identification type 
proof 
vc proper value type lemma 
lemma follows instance exists function tc vc uniqueness constraint defined holds applies ic proper value type satisfies uniqueness constraint defined tc value identification type ic lemma exists function vc unique codom ffi proves theorem 
ut corollary 
schema classes value identifiable 
classes value representable 
ut weak value representability ask exist weaker identification mechanisms value representability 
papers navigational approach basis structure favoured 
leads dependent classes similar weak entities entity relationship model :10.1.1.8.769
shall show approach requires value identifiable entrance path hard restriction representable surjective functions 
definition 
schema 
class tc theta id bool function definition expressing corresponding referential constraint satisfies sf condition iff dom xd tc codom xc hold id tc 
ii sf chain class sequence classes cn subclass gamma exists gamma satisfying sf condition 
iii class called weakly value identifiable iff exists value identifiable class sf chain notation sf condition chosen emphasize represents surjective function 
easy see value identifiable class weakly value identifiable 
lemma 
weakly value identifiable class schema exists proper value type ic instance exists function id ic injective dom 
call ic weak value identification type class proof 
cn sf chain value identifiable class corresponding 
satisfies sf condition exists function id id dom xc gamma just take inverse image surjective function 
defines function clearly injective 
subclass gamma take id id id function defined uniqueness constraint id id concatenation ffi ffi cn ffi satisfies required property 
ut definition 
class schema called weakly value representable iff exists proper value type vc instance properties hold 
function id vc injective dom 
ii proper value type function id injective dom exists function vc unique dom ffi call vc weak value representation type class note weak value representation type unique provided exists 
easy see value representability implies weak value representability 
due lemma weakly value representable class weakly 
shall see converse fact true 
want compute weak value representation types 
done slight modification algorithm completely ignores uniqueness constraints 
refer algorithm blind version algorithm emphasize write 
analogous lemmata results holds 
lemma 
class schema ic type computed blind version algorithm 
ic proper value type 
lemma 
instance schema fc cng 
classes weakly value identifiable exists sf chain id ic function lemma corresponding chain 
id function corresponding uniqueness constraint instance stage blind version algorithm exists function ic unique domd ffi lemmata state main result weak value representability 
theorem 
weakly value identifiable class schema andlet vc product types leading value identifiable class maximal sf chain corresponding result blind version algorithm 
weakly value representable weak value representation type vc proof 
vc proper value type lemma 
lemmata follows exists function id vc injective domd 
lemma follows exists function vc ic unique dom ffi proves theorem 
ut genericity problem preservation advantages relational databases requires generic operations querying insertion deletion update single objects 
querying se set oriented operation necessary select just single object raise specific problems object identifiers things change completely case updates 
object value updated deleted defined exist object value 
object exists value generally value objects user decide update delete operation applied objects objects selected non deterministically reject operation 
possible specify priori operation works way objects situations 
applies insert operations 
problem cases operations insertion deletion update objects defined generically 
authors chosen solution abandon generic operations 
identifying values represent object identity embody strict concept surrogate keys avoid problem 
approach different solutions concept hidden identifiers time formally characterize classes unique generic methods insertion deletion update single objects exist 
time inclusion referential integrity enforced 
show classes value representable ones 
generic update methods requirement object identifiers hidden user imposes restriction canonical update operations value defined sense identifier new object chosen system input output data values proper value types 
formally define mean generic update methods 
purpose regard instance schema set objects 
recursively defined type denote replacing occurrence recursive type union id 
definition 
class schema generic update methods satisfying properties input types proper value types output type trivial type 
ii case insert applied instance exists uc result instance hold instance 
iii case delete applied instance exists uc result instance hold instance 
iv case update applied instance delta fog exist uc result instance delta instance canonical update methods insert delete update defined analogously difference output type id input type value type note definition genericity includes consistency respect implicit constraints show value representability necessary sufficient existence uniqueness operations 
lemma 
class schema exist canonical update methods generic update methods exist proof 
case insert define vc insert call corresponding canonical operation ignore output 
argument applies delete update 
ut theorem 
class schema exist generic update methods 
super subclasses value representable 
proof 
consider delete method input type ic definition proper value type 
show value identification type 
instances functions tc ic exist id tc take 
exist distinct instances satisfying conditions definition iii respect respectively contradict assumption unique generic delete method argument applies input type vc insertion requires values referenced object provided derive algorithm theorem vc value representation type 
value representable 
value representability superclasses implied insert update involve corresponding method superclass 
value representability subclasses follows propagation update 
omit technical details 
ut generic updates case value representability goal reduce existence problem canonical update operations schemata isa relations 
lemma 
value representable classes schema subclass subtype function tc td exists function vc vd instance corresponding functions tc vc td vd codom 
proof 
definition injective codom continuation ffi ffi gamma satisfies required property 
remains show depend suppose instances vc correspond correspond exists permutation id 
may extend permutation type 
id non trivial supertype permutes 
definition follows 
ut schema derived schema omitting isa relations 
lemma 
value representable class superclasses subclasses dn value representable 
canonical update operations exist iff exist proof 
theorem value representation type vc result algorithm vc depend inclusion constraints id insert vc insert insert dn hn insert vc vd function lemma insert denotes canonical insert case result insert follows structural induction isa hierarchy 
subtype function required lemma exist superclass simply add vd input type 
omit details case 
arguments delete update analogous 
value representability subclasses required update case 
ut global operation newid produces fresh identifier id represented method projection 
lemma 
value representable class exist unique quasi canonical update operations proof 
denote structure expression value type vc exist values vc occurring fv denote value type tc results replacing id id ae fv ig occurs canonical insert operation defined follows id insert vc id tc air ut theta tc newid xc xc ut theta newid insert jn kn insert cn kn xc xc remains show operation canonical 
apply method instance exists result requirements definition trivially satisfied 

instance dom satisfies referential constraints 
contains distinguished objects corresponding involved quasi canonical operations insert induction length call sequences result insert 
fog uniqueness follows uniqueness vc definitions proofs delete update analogous 
ut theorem 
value representable class schema super subclasses 
exist unique generic update operations proof 
lemma lemma sufficient show existence canonical update operations super subclasses schema follows lemma 
ut shown linguistic reflection exploited generate generic update operations value representable classes oodm schema 
consistency problem general database may considered triplet defines structure denotes collection state changing operations set constraints 
consistency problem guarantee specified operation violate constraint integrity enforcement aims derivation new set operations satisfies property 
suppose database schema static integrity constraint schema 
regard logical formula defined consistency requires instances allowed satisfy call set instances sat 
transaction database transformation 
database transformation takes arbitrary instance possibly input values vn produces new instance possibly output values consistent respect iff sat sat 
classically consistency maintained run time transaction monitors 
inconsistent instance produced transaction caused inconsistency rolled back 
approach causes enormous run time overhead consistency checking rollback 
leaves burden writing consistent transactions user 
principle problem vanishes verification techniques design time second remains 
alternative lot attention paid integrity enforcement 
cases envisioned solution active database production rules repair inconsistencies rolling back 
coupled design time run time analysis rules approach 
satisfying theory rule triggering systems respect integrity enforcement problem missing 
favour operational approach aims replacing inconsistent database transactions consistent specializations 
greatest consistent specializations general non deterministic partial state transitions method language described subset theta 
denotes set possible states 
special symbol indicate non termination 
shown equivalent defining predicate transformers wp wlp associated satisfying pairing condition wp wlp wp true universal wlp wlp wlp predicate transformers assign postcondition weakest liberal precondition establish clearly pre postconditions constraints 
informally conditions characterized follows wlp characterizes initial states terminating executions reach final state characterized provided defined initial state wp characterizes initial states executions terminate reach final state characterized provided defined 
predicate transformers definition language semantics usually called axiomatic semantics 
consistency specialization formally defined formal description consistency problem 
purpose define extended operations need know operation set classes read change class variables xc case call operation 
omit formal definition 
definition 
schema constraint methods defined respectively 
consistent respect iff wlp holds 
ii specializes iff wp true wp true wlp wlp hold constraints free variables xc denoted 
definition greatest consistent specialization definition 
schema constraint method defined method si greatest consistent specialization gcs respect iff si ii si consistent respect iii method satisfying properties ii si si properties ii satisfied simply talk consistent specialization 
state main results 
theorem 
schema constraints method defined 
exists greatest consistent specialization si respect si uniquely determined semantic equivalence 
ii gcss si ij coincide initial states satisfying proof results heavily uses predicate transformers omitted 
shown gcs general non deterministic written finite choice maximal quasi deterministic specializations quasi determinism means determinism selection values 
cases value selection shifted input selection object identifiers left system 
formally define quasi determinism main result algorithm computation 
definition 
method called quasi deterministic iff exist types tn semantically equivalent yn tn deterministic method 
algorithm 
operation constraints defined extensions yn list constraints 
long nil proceed follows 
set 
choose remove constraint 

check reduced 
result continue 

ut theta free replacing occurring ut thetas false 
replace basic assignment subsumption free respect 
compute si si fz zn xng wlp fx xn si wlp zn xn class variables occurring disjoint copy 

set si set operation subsumption free original respect conjunction constraints 
ut extension gcs algorithm compute subsumption free easy 
shown algorithm correct 
depends checking technical condition 
omit condition 
enforcing integrity oodm algorithm allows integrity enforcement reduced case assignments may restrict case single explicit constraint addition trivial uniqueness constraints required assure construct generic update operations 
describe respect constraints introduced definition 
inclusion constraints 
inclusion constraint defined tc 
insertion requires additional insertion deletion requires deletion update requires additional update class 
concentrate insert operation insert 
insertion requires input value type vc additional insert requires input value type vc input values independent corresponding values type tc tc satisfy general inclusion constraint 
show constraint lifted constraint value representation types 
note similar handling isa constraints lemma 
lemma 
classes tc functions vc value representation type 
exist functions vc database instances codom xc holds 
tc vc denotes function uniqueness constraint respect proof 
due definition may define ffi gamma codom xc 
show definition independent instance suppose different instances 
exists permutation id ffi extended tc ffi gamma ffi gamma ffi gamma gamma ffi ffi gamma permutes gamma stated equality follows 
ut vc vc theta vc define new insert operation vc functions lemma 
note need require delete update operations defined analogously 
functional uniqueness constraints 
functional constraint defined tc tc case required delete operation inserts updates add postcondition 
tc vc denote function associated value representability database instance notations 
concentrate insert operation 
insert denote canonical insert define vc id insert tc xc 
id tc xc skip note case change input type 
delete update operations analogous definitions 
uniqueness constraint defined tc equivalent functional constraint defined id tc tc plus trivial uniqueness constraint 
trivial uniqueness constraints enforced canonical update operations need handle separately arbitrary uniqueness constraints 
exclusion constraints 
handling exclusion constraints analogous handling inclusion constraints 
means insert update class may cause delete delete operations remain unchanged 
concentrate insert operation 
exclusion constraint defined tc 
vc denote functions lemma 
define new insert operation vc id tc xc ut theta skip delete update operations analogous result holds 
theorem 
methods si generic insert methods respect inclusion functional exclusion constraints respectively 
proof involves detailed predicate transformers omitted 
analogous results hold delete update 
describe results concerning formal foundations object oriented database concepts 
purpose introduced formal object oriented datamodel oodm characteristics 
objects considered abstractions real world entities immutable identity 
identity encoded identifiers assumed form type id identifier concept eases modelling shared data cyclic relieve problem provide unique identification mechanisms objects database 
approach value type associated object 
contrast allow values possibly different types belong object collection types may change 
classes structure objects 
time class corresponds collection objects values type objects fixed set classes 
inheritance isa relations express inclusion time sets objects 
referential integrity supported 
associate class collection methods 
methods specified guarded commands method language computationally complete 
order allow handling identifiers hidden user user accessible transactions hiding operator methods introduced 
generic update operations insert delete update class assumed automatically derived possible 
associate integrity constraints schemata 
certain kinds constraints obtained generalizing corresponding constraints relational model 
assume methods automatically changed order enforce integrity 
basis formal oodm study problems identification genericity integrity 
show unique identification objects class requires class value representable 
advantage database systems provide generic update operations 
show unique existence generic methods requires value representability 
case referential inclusion integrity enforced automatically 
result generalized respect distinguished classes user defined integrity constraints 
arbitrary method constraint exists greatest consistent specialization gcs si respect gcs behaves nice compatible conjunction constraints 
gcs construction user defined transaction apply gcs algorithm developped 
mathematical foundations oodb concepts completed 
lot problems left open matter current investigations research 
approach classes sets 
bulk types 
sense classes way 
problem updatable views open 
approach genericity handles worst case expressed value representation type 
assume polymorphism help generalize results general case 
integrate communication aspects respect user 
usual axiomatic semantics guarded commands abstracts execution model 
results true semantic equivalence classes 
need optimization especially respect derived gcss 
formal oodm looking methodological aspects characterization designs 
express hope contribute solve open problems oodb foundation implementation sophisticated object oriented database languages sound mathematical basis 
beeri joachim schmidt ingrid wetzel stimulating discussions especially concerning object identification 
want david stemple questioning theme engineering point view 

abiteboul deductive object oriented database language data knowledge engineering vol 
pp 

abiteboul hull ifo formal semantic database model acm tods vol 
december pp 

abiteboul kanellakis object identity query language primitive proc 
sigmod portland oregon pp 

albano ghelli orsini types databases galileo experience type systems database programming languages university st andrews dept mathematical computational sciences research report cs 
albano dearle ghelli marlin morrison orsini stemple framework comparing type systems database programming languages type systems database programming languages university st andrews dept mathematical computational sciences research report cs 
albano ghelli orsini objects classes database programming language fide technical report 
albano ghelli orsini relationship mechanism strongly typed object oriented database programming language sernadas ed proc 
vldb barcelona 
atkinson bancilhon dewitt dittrich maier zdonik object oriented database system manifesto proc 
st dood kyoto 
bancilhon benzaken delobel pfeffer richard velez design implementation object oriented database system proc 
oodbs ii workshop bad frg september 
beeri formal models object oriented databases proc 
st dood pp 

beeri formal approach object oriented databases data knowledge engineering vol 
pp 

beeri algebraic optimization object oriented query languages abiteboul kanellakis eds proc 
icdt springer lncs pp 

beeri new data models languages proc 
pods 
cardelli wegner understanding types data abstraction polymorphism acm computing pp 
cardelli typeful programming digital systems research center reports dec src palo alto may 
carey dewitt data model query language exodus proc 
acm sigmod 
vision object oriented database management system proc 
workshop database programming languages france september 
ceri widom deriving production rules constraint maintenance proc 
th conf 
vldb brisbane australia august pp 

dearle connor brown morrison napier database programming language type systems database programming languages university st andrews dept mathematical computational sciences research report cs 
dijkstra scholten predicate calculus program semantics springer verlag 

ehrich gogolla teubner verlag 

ehrich sernadas fundamental object concepts constructors saake sernadas eds information systems correctness reusability tu braunschweig informatik berichte 
ehrig mahr fundamentals algebraic specification vol springer 
fegaras sheard stemple type system type systems database programming languages university st andrews dept mathematical computational sciences research report cs 
fegaras sheard stemple uniform traversal combinators definition properties university massachusetts 
beech cate chow iris object oriented database management system acm tois vol 
january 
fraternali paraboschi tanca automatic rule generation constraint enforcement active databases ed proc 
th int 
workshop foundations models languages data objects modelling database dynamics germany october 
gottlob kappel semantics object oriented data models evolving algebra approach schmidt eds proc 
generation information systems technology springer lncs vol 

hammer mcleod database description sdm semantic database model acm vol 
pp 

heuer sander classifying object oriented results class type lattice thalheim 
ed proceedings springer lncs pp 

hull king semantic database modeling survey applications research issues acm computing surveys vol 
september 
hull yoshikawa ilog declarative creation manipulation object identifiers proc 
th vldb brisbane australia pp 

urban diagnosing anomalous rule behaviour databases integrity maintenance production rules proc 
rd int 
workshop foundations models languages data objects austria september pp 

khoshafian copeland object identity proc 
st int 
conf 
oopsla portland oregon 
kifer wu logic object oriented logic programming maier logic revisited pods pp 

kim banerjee chou woelk integrating object oriented programming system database system proc 
oopsla 
maier stein development object oriented dbms oopsla september 
matthes schmidt bulk types add built proc 
dbpl iii 
mylopoulos bernstein wong language facility designing interactive database intensive applications acm tods vol 
april pp 

mylopoulos borgida jarke koubarakis telos representing knowledge information systems acm tois vol 
october pp 

nelson generalization dijkstra calculus acm toplas vol 
october pp 

ohori representing object identity pure functional language proc 
icdt springer lncs pp 

saake specification database applications troll language proc 
int 
workshop specification database systems glasgow 

schewe wetzel schmidt structured specification language database applications harper norrie eds proc 
int 
workshop specification database systems springer pp 
extended version appeared fide technical report october 

schewe thalheim wetzel schmidt extensible safe object oriented design database applications university rostock preprint cs september 

schewe german lecture manuscript university hamburg winter 

schewe schmidt wetzel identification genericity consistency object oriented databases biskup hull eds proc 
icdt springer lncs pp 


schewe thalheim schmidt wetzel integrity enforcement object oriented databases thalheim eds proc 
th int 
workshop foundations models languages data objects modelling database dynamics germany october 

schewe thalheim wetzel foundations object oriented database concepts university hamburg report fbi hh october 

schewe schmidt stemple thalheim wetzel reflective approach method generation object oriented databases university rostock informatik berichte 

schewe thalheim computing consistent transactions university rostock preprint cs december 

schewe thalheim wetzel integrity preserving updates object oriented databases orlowska papazoglou eds 
proc 
th australian database conference brisbane february world scientific pp 


schewe thalheim exceeding limits rule triggering systems achieve consistent transactions submitted publication 
scholl 
schek relational object model proc 
icdt springer lncs pp 

shaw zdonik object oriented query algebra ieee data engineering vol 
pp 

stemple sheard fegaras reflection bridge programming database languages proc 
hicss 
stemple sheard modes meaning feedback transaction designer proc 
sigmod pp 

stemple sheard automatic verification database transaction safety acm tods vol 
september 
stonebraker goh rules procedures caching views database systems proc 
pp 

su sam semantic association model corporate scientific statistical databases inf 
sci vol 
pp 

thalheim dependencies relational databases teubner leipzig 
thalheim higher order entity relationship model schmidt eds proc 
generation information systems technology springer lncs vol 

urban delcambre constraint analysis design process specifying operations objects ieee trans 
knowledge data engineering vol 
december 
widom finkelstein set oriented production rules relational database systems proc 
sigmod pp 

zhou hsu theory rule triggering systems proc 
edbt springer lncs pp 

