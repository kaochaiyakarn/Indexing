software construction analysis tools space missions michael lowry computational sciences division nasa ames research center moffett field ca usa mail arc nasa gov 
nasa international partners increasingly depend software systems implement advanced functions space missions martian rovers autonomously navigate long distances exploring geographic features formed surface water early planet history 
software functions missions need robust highly reliable raising significant challenges context mars mission failures attributed software faults 
reviewing challenges describes tools developed nasa ames contribute meeting challenges program synthesis tools automated inference generate documentation manual review annotations automated certification 
model checking tools concurrent object oriented software achieve scalability synergy program abstraction static analysis tools 
consists sections 
section describes advanced capabilities needed nasa missions expected implemented software 
second section describes risk factors associated complex software aerospace missions 
risk factors concrete mission failures summarized 
considerable gap current technology addressing risk factors associated complex software needs nasa 
third section develops model gap suggests approaches close gap software tool development 
fourth section summarizes research nasa ames program synthesis tools generate code 
fifth section summarizes research nasa ames software model checking tools 

software enabling technology nasa missions nasa strategic plan envisions ambitious missions years project major human presence space 
missions studied planned include sample returns planets detection earth planets stars search existence life outside earth intensive study earth ecosystems human exploration mars 
major enabling factor missions expected advanced software computing systems 
section describes requirements mission capabilities 
autonomous spacecraft rovers 
nasa mission deep space exploration provided requirement stressing applications facing computer science research community designing building operating progressively capable autonomous spacecraft rovers airplanes 
nasa planning fill space robotic craft explore universe ways possible 
surrogate explorers need adaptable self reliant harsh unpredictable environments 
uncertainty hazardous terrain great distances earth require rovers able navigate maneuver autonomously wide variety surfaces independently perform science tasks 
robotic vehicles need progressively smarter independent continue explore mars 
essence robust autonomy software needs highly responsive environment robotic vehicle constant intervention guidance earth human controllers 
case martian rovers past earth controllers link commands martian day limited maneuvers roll meters forward northeast executed blindly rover 
commands extensive maneuvers navigate kilometer rock formation horizon require complex navigation skills executed autonomously rover constant adaptation terrain factors 
autonomy software running conjunction unknown environment orders magnitude possible execution paths behaviors today software 
addition autonomy commanding self diagnosis increasing need autonomous semi autonomous board science capability 
deep space probes rovers send data back earth slow rate limiting ability space science community fully exploit presence machines distant planets 
strong need spacecraft capacity science processing board autonomous semi autonomous fashion 
human exploration space 
human mission mars qualitatively complex apollo missions moon 
orbital dynamics mars earth combination means low energy reasonable cost mars missions orders magnitude longer moon missions sixties seventies specifically order days 
achieve science returns commensurate cost human mars mission scientist need freed usual role lab technician 
need robotic assistants support scientific aspects mission maintain equipment habitat 
particularly interesting issue arises spacecraft systems increasingly capable independent initiative problem human crew autonomous systems interact mixed initiative environments central importance 
emerging area human centered computing represents significant shift thinking information technology general smart machines particular 
embodies systems view interplay human thought action technological systems understood inextricably linked equally important aspects analysis design evaluation 
developing verifying software mixed initiative systems challenging completely autonomous software 
contrast current human command software executes blindly paradigm mixed initiative software far potential execution paths depend continuous stream human inputs 
paradigm human complex aspect environment software executing complex terrain encountered martian rover 
furthermore human viewpoint software needs understandable predictable humans interacting 
today methods developing verifying high assurance mixed initiative software inadequate 
example aviation autopilot flight management systems behave ways bewildering unpredictable human pilots 
decrease manual workload human pilots increase cognitive workload 
automation surprises implicated number aviation 
mixed human robotic mission mars robotic assistants need smart behaved 

aerospace software risk factors advances software technology enable mission capabilities substantially reduced operational cost concerns able design implement complex software systems reliable cost effective matter 
traditional space missions advanced software technology inherently risky 
charles book identifies risk dimensions technologies interactions coupling 
complex interactions unfamiliar unexpected sequences immediately comprehensible 
systems tightly coupled multiple time dependent processes delayed extended 
identifies space missions having characteristics space missions category 
risks software errors pose space missions considerable 
peter neumann book catalogues computer related problems occurred unmanned space missions 
risks inherent today software technology flight project managers understandably reluctant risk science mission new information technologies promise cost savings enhanced mission capabilities 
creates hurdle deploying new technologies difficult get incorporated flight flight qualification 
nasa addressing hurdle flight qualification programs new technology new millennium 
flight project managers need convinced information technology verified validated specific context mission 
poses special challenge advanced software technology traditional testing approaches scale 
section reviews software errors significant impact space missions order draw historical lessons difference software failures hardware failures 
ariane 
launch ariane flight ended disaster caused chain events originating inappropriate reuse component ariane inertial frame software lack sufficient documentation describing operating constraints software 
approximately seconds launch initiation error occurred unprotected conversion bit floating point bit signed integer value overflowed 
error occurred active backup system 
overflow value related horizontal velocity due greater horizontal velocity ariane trajectory compared ariane trajectory 
error interpreted flight data led extreme position shortly 
full configuration flight control system analyzed tested adequately ariane development program 
horizontal velocity value critical prior launch software considered flight critical rocket left launch pad 
case launch delayed near time zero take significant period measurements calculations converge needed restarted 
avoid potential situation delayed launch delayed due need recompute value calculation value continued early stages flight 
accidents interest particular chain events failure prevent accident levels chain intercepted development organization perform adequate software reuse seen means cutting costs ensuring safety software proven 
software works adequately context fail context 
stated accident review report culture ariane programme addressing random hardware failures duplicate back systems seen adequate failure handling mechanisms 
software failures due design errors failure active system highly correlated failure duplicate backup system 
real time performance concerns particularly slower flight qualified computers lead removal software protection mechanisms known case protection floating point conversion 
board inquiry concluded software expression highly detailed design fail sense mechanical system 
software flexible expressive encourages highly demanding requirements turn lead complex implementations difficult access fact software worked error ariane critical rocket left launch pad contributed overlooking problem 
mars pathfinder 
today aerospace software increasingly complex processes active concurrently 
subtle interactions concurrent software particularly difficult debug extensive testing fail expose subtle timing bugs arise mission 
july mars pathfinder mission anomaly manifested infrequent mysterious unexplained system resets experienced rover caused loss science data 
problem ultimately determined priority inversion bug simultaneously executing processes 
specifically interrupt wake communications process occur high priority bus management process waiting low priority meteorological process complete 
communication process blocked high priority bus management process running duration exceeding period watchdog timer leading system reset 
judged fact anomaly impossible detect black box testing 
noteworthy decision perform proper priority inheritance algorithm high priority bus management process executed frequently time critical engineer wanted optimize performance 
situations correctness particularly essential cost additional cycles 
mars climate mars polar lander 
nasa launched mars missions 
unfortunately lost software related reasons 
mars climate lost due navigation problem error physical units resulting spacecraft burning martian atmosphere inserting orbit mars 
onboard calculation measured engine thrust foot pounds specified engine manufacturer 
thrust interpreted program ground newton meters specified requirements document 
similar ariane onboard software sufficient scrutiny part previous mission particular onboard calculations informational purposes 
appreciated mission calculations critical inputs navigation process 
ground navigation team overloaded unfortunate alignment geometry hid accumulating navigation error late 
mars polar lander probably lost due premature shutdown descent engine unanticipated premature signal sensors 
spacecraft different sequential control modes leading landing martian surface entry descent landing 
entry phase driven timing rockets firings actions performed specific time intervals get spacecraft atmosphere 
descent phase driven radar altimeter spacecraft descends rocket control 
meters surface altimeter longer reliable spacecraft transitions landing phase spacecraft awaits ground legs sets sensor signals engines turn 
unfortunately spacecraft designers realize legs bounce unfolded altitude km set sensors latch software variable 
spacecraft enters landing phase software starts polling flag find set shut engines point 
resulting fall damage spacecraft 
lessons software failures space missions 
software failures latent design errors different hardware failures 
strategies mitigating hardware failures redundancy software 
complexity aerospace software today precludes approaching complete testing coverage software system 
especially difficult test subtle interactions multiple processes different subsystems 
performance optimizations resulting removal mechanisms runtime protection software faults removal ariane arithmetic overflow handler horizontal velocity variable done carefully led failures fault arises unanticipated ways 
reuse qualified software components slightly different contexts necessarily safe 
safe performance mechanical components predicted defined envelope encompassing parameters component successfully operated previous space missions 
software components behave linearly convex function notion safe operating envelope fundamentally mistaken 
missions years conceptual plans years reasonably defined 
decade nasa plans launch robot mission capture sample martian soil rocks atmosphere return earth 
software mission times complex mars climate 
software missions mars sample return requiring capabilities described section complex 
section presents framework assessing likelihood success missions current trends continue potential software construction analysis tools reverse trends 

model software reliability versus software complexity aerospace industry industries seeing increasing importance role played software amount software mission steadily increasing time 
delivered substantial benefits mission capabilities 
software comparatively easy change adapt changing requirements software changed launch making especially versatile means achieving mission goals 
table provides historical data small number space missions gives flight software thousands lines source code 
note cassini mission saturn orbit saturn mars pathfinder launched year development cassini started years earlier 
data clearly indicates exponential growth time size flight software 
exponential growth consistent sectors aerospace including civilian aviation military aerospace 
subsequent graph log scale thousands line source code versus log scale expected number mission critical software errors extrapolate model expected software reliability potential impact various kinds tools 
mission launch year thousands sloc voyager galileo cassini mars path finder shuttle iss qualitative data software reliability lack thereof abundant empirical quantitative data difficult find 
graph take advantage tradeoffs reliability cost schedule 
fortunately empirical data software development cost schedule analyzed providing basis extrapolating reliability cost schedule 
stage maturity software engineering tools process multiple criteria reliability cost schedule traded limits 
example software manager choose compress development schedule increasing manpower empirical data indicates increases total man years cost 
example manager limit number design code reviews incur greater risk overlooking mission critical software error 
empirical data software development cost schedule relates increasing size complexity extensively studied barry boehm developed mathematical models cost schedule drivers statistically validated calibrated 
models indicate super linear growth cost schedule increasing size software expect accelerated exponential growth cost schedule mission software years changes technology methods 
boehm model primary factor contributing super linear growth cost time fix unintended non local interactions unintended interactions separate software components unintended interactions software systems 
quantitative cost schedule data qualitative record failures readily understandable size software systems increase number elements interact increases proportionally number potential interactions elements grows quadratically 
tracking interactions complex difficult fixing bad interactions introducing new errors takes time money consequences fixing unintended interactions fatal 
extrapolate barry boehm schedule cost model analogous model software reliability 
model proportional factors expected interactions components software size increases 
components interacted interactions 
fortunately interactions sparser best calibration projects gives exponent indicated growth cost schedule 
data indicates improvements software process reduce total number errors growth errors software size increases 
software projects high levels process maturity exponent 
sense better engineering management gives handle unintended interactions better communication coordination development organization better documentation 
show number predicted mission critical errors versus size mission software loc lines source code log log scale 
assume number errors proportional number components modules computed number source lines code divided lines module 
baseline model take number lines code module 
baseline model exponent assumed 
model calibrated assumption probability critical software error sloc deep space missions 
specifically vertical axis interpreted mean number expected critical software errors 
conservative estimate missions including mars polar lander mars climate mars pathfinder 
model indicates probability critical errors small systems sloc grows super linearly size grows expected missions incorporating advanced software technology 
improvements software tools methods model predicts low chance space mission free critical software errors sloc level 
course examples commercially viable software systems larger sloc 
commercial viability lower standard reliability fact deployment commercial system seldom fewer critical errors crash system predicted graph 
tolerate errors manage complexity sw construction tools lines code sw analysis tools graph model validated provides conceptual basis understanding past trends making predictions 
enables visualize potential impact tools software construction analysis 
graph annotated indicate potential strategies achieving complex highly reliable software 
managing complexity means reducing slope line reducing factor scaling se software construction tools means shifting line right enabling developers produce software manual process prevalent today 
detecting errors means shifting line software analysis tools detect errors possible testing 
tolerate errors means able detect recover errors occur runtime errors lead mission failure recognized handled 
simple example runtime overflow exception handling 
clearly strategies need combined synergistically achieve complex reliable software 
managing complexity focus software process community 
tolerate errors focus fault tolerant computing community 
rest describe nasa ames strategies topics tacas software construction tools software analysis tools 

software construction technology software software construction technology rapid development environments matlab potential magnifying effort individual developers raising level software development 
studies shown number lines code generated individual day remains roughly constant matter level program 
example team developers cassini software coding level conventional programming languages theory generate software mars pathfinder mission amount time technology 
graphs software cost schedule versus size software system shifted right log expansion factor size spec size generated code 
furthermore theory organizational factors non local interactions lead superlinear growth software errors increased software size held constant matter level software coding done 
graph software errors versus size software system shifted right factor 
simple analysis breaks mission critical safety critical software particularly software needs run efficiently limited computational platforms typical space applications computer needs radiation hardened 
mission critical software certification costs dominate development costs 
certification done higher level translated certification lower level cost schedule savings realized 
similarly produce efficient code non local interactions introduced just optimizing compilers introduce nonlocal interactions object code level 
non local interactions introduced guaranteed lead software faults 
aerospace domain automated generation code needs done technology ensures reliability addresses certification issues achieve potential benefits shifting graph right 
current generation aerospace tools traditional compiler technology subject limitations compilers 
major limitation today aerospace perform process code generation black box manner 
leaves major gap certification means exceptions verification done source specification level count certification 
past years automated software engineering group nasa ames developing program synthesis technology address certification problem 
specifically technology generates code process iterated fine grained refinement step justified automated reasoning combination deductive synthesis program transformations 
sources error precluded method generating software 
record justifications step provides documentation artifacts needed certification 
code generation process longer opaque fact process potentially better documented manual code development 
part research nasa ames realize potential methodology respect certification described 
demonstrations automated construction verifiably correct software focused small examples relevant computer science programs sorted lists 
ambitious demonstrations showed sophisticated programs generated 
involved representations knowledge low level programming knowledge including algorithm knowledge design knowledge domain knowledge 
demonstrations included demonstrated generation programs calculating space observation geometries kids planware generated planning scheduling programs military logistics support applications 
automated software engineering group nasa ames demonstrated scaling technology avionics domain demonstrated technology generate artifacts certification 
guidance navigation primary control functions avionics aerospace vehicles 
unfortunately documented section faulty geometric state estimation software gn systems factor numerous aerospace disasters including mars polar lander mars climate ariane contributing near misses 
domain verifiably correct software critical 
nav program synthesis system generates geometric state estimation programs iterative refinement 
generated programs iteratively estimate values state variables position velocity attitude noisy data multiple sensor sources 
standard technique integrating multiple sensor data kalman filter 
kalman filter estimates state linear dynamic system perturbed gaussian white noise measurements linearly related state corrupted gaussian white noise 
kalman filter algorithm essentially recursive version linear squares incremental updates 
specifically kalman filter iterative algorithm returns time sequence estimates state vector fusing measurements estimates state variables process model optimal fashion 
estimates minimize mean square estimation error 
nav takes input specification process model typical model description drift ins system time specification sensor characteristics specification geometric constraints aerospace vehicle physical locations associated sensors position radio navigation aids 
input specification provides architectural constraints target program integrated kalman filter federation separate kalman filters 
nav produces output code instantiates kalman filters 
rapid prototyping environments nav supports iterative design cycle user simulate generated code determine lacking simulated estimate altitude sufficiently accurate reiterate design adding radio altimeter sensor specification rerun simulation 
nav produces artifacts support certification 
nav system theorem prover negated specification axioms domain theory generates refutation proof vector witness terms output variables case applicative terms comprising synthesized program 
terms subsequently transformed set program transformations produce code target programming language subroutine calls octave library matlab clone 
nav produces extensive documentation printed document html document indexed links generated program 
derived common xml document generated algorithm described 
documentation system developers test code review purposes system integration maintenance 
supports code reviews certification process providing trace code back specification 
process code generated documented mapping derivation tree english language text 
technology generating documentation consists components algorithm generation explanation equalities proof traces instantiation templates associated axioms domain theory translators 
focus components 
intuitively explanation statement generated program description connections variables functions subroutines statement objects relations functions problem specification domain theory 
words explanation traces back statement program parts specification domain theory originated 
explanations constructed templates explanation equalities 
algorithm generating explanation equalities works proof derivation synthesized program 
proof derivation tree nodes sets formulas substitutions existentially quantified variables arcs steps proof encode derived relation 
syntax tree ast synthesized program empty clause root derivation tree recall nav generates resolution refutation proofs 
leaves domain theory axioms problem specification 
ast formulas represented tree structured terms derivation tree essentially tree trees 
position syntax tree explanation equality generation procedure traces back derivation tree extracting explanation equalities way 
equalities record links positions different terms derivation 
explanation equality logical consequence semantics inference rule applied point derivation tree 
example resolution rule induce set equalities disjuncts parent clauses disjuncts child clause 
transitive closure equalities goal explanation equalities derived relate positions generated program terms specification formulas domain theory 
second ingredient constructing explanations understandable engineers domain explanation templates 
domain theory axioms annotated explanation templates consist strings words variables linked variables axiom 
multiple templates axiom template indexed particular position axiom 
position generated program explanation constructed instantiation templates linked explanation equalities 
chain equalities constructed linking position generated program back derivation tree specification domain theory 
second corresponding chain templates constructed extracting template associated node chain template associated position axiom term derived 
third templates instantiated replacing variables corresponding variables axioms corresponding terms problem specification correspondence defined goal explanation equalities originating variable position 
templates concatenated order defined derivation tree 
extensive mathematical description algorithm terms equivalence classes terms 
current research program synthesis focuses generating artifacts documentation support certification process 
developed prototype algorithms generate test cases exercise code 
developing capability generate formal annotations synthesized code support independent certification algorithms extended static checking 
algorithms provide independent check code conforms safety properties consistent physical units ordinate frames 
early results research 

software analysis technology mathematical verification technology profound effect commercial digital hardware engineering finding errors prior initial fabrication runs orders magnitude cost effective discovering errors 
technology includes equivalence checkers combinatorial aspects digital circuits model checkers sequential concurrent aspects digital hardware systems 
software verification technology similar effect software systems finding error prior system deployment orders magnitude cost effective finding error caused mission critical failure 
viewpoint graphical model software errors versus software size section software analysis technology shifts line downward finding substantial fraction software errors subsequently remedied 
downward shift log log graph log fraction errors analysis tools percent errors graph shifted constant factor negative 
software analysis technology faces greater technical challenges digital hardware analysis technology lack regularity non local interactions scale 
digital hardware highly regular repetitive layout feature implicitly exploited analysis technology bdd model checkers 
regularity digital hardware appears keep bdd representations sets states tractable size model checkers 
contrast software compactly encapsulates regularity constructs iteration recursion 
line line basis software denser digital hardware circuits compact representation state space system 
partially lack regularity digital hardware analysis techniques hit combinatorial explosions quickly applied software 
similarly physical constraints nonlocal interactions digital hardware costly power wiring layout 
non local interactions dominate software exception handling interrupts asynchronous interleaving multiple threads 
reachable state space needs analyzed software system usually larger complex digital hardware systems microprocessor 
software executes hardware state space exponential function just microprocessor memory program data stored 
section provide overview research nasa ames develop model checking technology suitable software 
model checking thoroughly explores graph reachable states precision needed find subtle errors arising concurrent software shift graph downward substantially 
automated nature model checking potentially attractive outside formal methods research community 
factors described paragraph combinatorics model checking software worse combinatorics similarly analyzing hardware 
addition semantics object oriented software fundamentally mismatches assumptions previous model checking algorithms 
meet challenges increase size software systems analyzed research evolved case studies previous model checking technology spin prototypes translated software artifacts modeling language previously existing model checkers promela new model checking technology built ground semantics object oriented software 
meet challenge scale synergy technologies cut combinatorics reachable state space 
fact java pathfinder system incorporates static analysis algorithms predicate abstraction algorithms automated theorem proving data abstraction algorithms interpretation guided search techniques 
result years steady increase number source lines code analyzed measured size programs analyzed running main memory limiting factor explicit state model checking measured human productivity technology 
source lines code analyzed person day gone lines code lines code 
java pathfinder henceforth jpf java model checker built java virtual machine jvm takes input java bytecode 
java language chosen initial research target streamlined modern object oriented language complicating factors arbitrary pointer arithmetic 
developing custom jvm solved problems handling semantics object oriented language awkward translations model checker mismatched semantics 
jpf introduced number novel features model checking support dynamic object creation class loading support garbage collection support floating point numbers jpf explicit state model checker enumerates reachable system state initial state 
order redo able terminate required store state reached graph states 
analyzing java program state large require significant memory store reducing size systems checked 
jpf state compression techniques reduce memory requirements model checker order magnitude 
novel feature jpf symmetry reduction techniques allow states modulo object stored memory considered equal 
object oriented programs typically objects symmetry reduction allows order magnitude states analyzed typical program 
jpf supports distributed memory model checking memory required model checking distributed number workstations enlarging size state space explored number workstations 
experiments partitioning state space different workstations showed dynamic partitioning works best partitions change model checking run statically fixed initialization 
jpf analyze program adherence properties including properties specified temporal logic user works collection tools analyze manipulate program synergy core model checking algorithm 
tools program slicing abstraction invoked user prior submitting program model checker 
heuristics guide search model checker selected user parameters model checker 
brief summary tools synergistic algorithms interested reader find detail cited papers 
program abstraction 
program abstraction supports simplification reduction programs enable focused tractable verification resulting dramatic reductions state space 
tools support abstraction approximations practice approximations preserve concrete errors abstraction mapping potentially introduce additional spurious errors 
abstractions done data type abstraction interpretation predicate abstraction 
data type abstractions calculated offline pvs 
predicate abstraction technology invokes stanford validity checker svc calculate program statements predicate definition 
object oriented programs particularly challenging predicate abstraction predicates relate variables different classes multiple dynamic instantiations run time 
static program analysis 
static program analysis technology consists classes algorithms construct analyze graphs represent static dependencies programs 
applications technology program slicing control flow analysis concurrency analysis points alias analysis 
static analysis information useful optimizing refining model checking program abstraction techniques 
applications static analysis incorporated jpf associated tools 
environment modeling generation 
steps behavioral verification constructing model environment software reacts 
model checking applies closed system 
order check reactive system autonomous controller system completed simulated environment interact way testing requires test harness suitable test cases 
environment reproduce different possible stimuli system possibly meet operation alternative choices model checker explore 
technology developed support modeling complex non deterministic environments 
environment models constructed combination special object oriented methods support non deterministic choice generic reusable environment components environmental constraints specified linear temporal logic 
course research leading jpf software model checking technology done series case studies demonstrate increasing power technology address nasa needs reliable software provided feedback inform direction research 
highlight case studies related strategic nasa requirements described section 
case studies address verification autonomy software verification generation aerospace operating systems verification mixed initiative human machine systems 
autonomy software 
starting ase group analyzed parts remote agent formed part deep space mission new millennium mission dedicated flight validating new technology space missions 
remote agent integrated set ai autonomy software planning scheduling robust execution model diagnosis prototype autonomy software control spacecraft rovers minimal ground intervention 
remote agent software tested space deep space mission 
remote agent team asked ase group analyze portions lisp code prior going operational may 
analysis performed manual development model promela parts code 
spin model checker developed bell labs analyze model 
model checking successful uncovered previously undiscovered bugs source code 
bugs concurrency errors data race conditions led deadlock 
launch remote agent run experiment week may 
soon experiment began remote agent software deadlocked due missing critical section part code analyzed prior launch model checking 
dump program trace downloaded earth remote agent team able find error 
challenge ase group telling specific nature error asked analyze subsystem deadlock occurred lines lisp code gave weekend find error 
able find error combination inspection model checking turned nearly identical previously model checking different subsystem prior launch 
generation aerospace operating system 
honeywell technology center approached ase group request investigate techniques able uncover errors testing suited find 
generation avionics platforms shift federated system architectures integrated modular avionics ima software runs single computer operating system ensuring time space partitioning different processes 
certification critical flight software faa requires software testing achieve coverage structural coverage measure called modified condition decision coverage mc dc 
honeywell concerned structural coverage able ensure behavioral properties time partitioning satisfied 
particular honeywell real time operating system called deos error time partitioning uncovered testing 
similar challenge remote agent team honeywell asked determine model checking uncover error knowing specifics error 
point developed translator spin modeling done directly programming language java 
considerably speeded developing abstracted model deos 
technology able find subtle error algorithm deos manage time budgets threads 
analysis deos system received honeywell led honeywell creating model checking team analyze deos enhancements applications run top deos 
human computer interactions 
environment generation technology critical part ongoing research human computer system analysis 
described section human machine interactions common source critical software related errors 
technology environment modeling extended modeling incorporation human actors system models containing actual software 
technology consists specialized static analysis program abstraction techniques 
applied summer summer student model interactions autopilot pilot successfully uncovering automation surprise scenarios 
scenario autopilot fails level altitude specified pilot continues climb descend resulting potentially hazardous situation 
summary complex software essential enabling mission capabilities required nasa years 
unfortunately nasa software systems evolved tens thousands source lines code typical nineteen eighties deep space missions hundreds thousands source lines code typical nineteen nineties software faults led number serious mission failures 
model software errors versus size software systems indicates new software development technology trend accelerate 
model reasonable extrapolation models software cost schedule calibrated analysis underlying causes 
graphical model see software engineering tools mitigate trend super linear error growth orthogonal directions shifting graph right software construction technology shifting graph downwards software analysis technology 
research nasa ames software construction tools software software model checking tools overviewed 
colleagues automated software engineering group nasa ames compiled research track record working meet nasa strategic goals challenges described sections 
sections essentially overviews research group 
detailed descriptions cited papers 
graphical model software reliability section developed conjunction green kestrel institute input encouragement barry boehm peter norvig 

normal accidents living high risk technologies university press 
neumann computer related risks addison wesley press 
lions report inquiry board ariane flight failure joint communication esa paris france 
boehm software cost estimation ii prentice hall ptr 
green application theorem proving problem solving 
proceedings intl 
joint conf 
artificial intelligence 
smith lowry algorithm theories design tactics 
lecture notes computer science vol 
springer verlag 

stickel waldinger lowry underwood deductive composition astronomical software subroutine libraries 
lecture notes computer science vol 

springer verlag 

smith kids semiautomatic program development system 
ieee trans 
software engineering 

brat lowry oh penix robinson schumann subramaniam whittle synthesis verifiably correct programs avionics 
aiaa space conference exposition long beach ca 
brat lowry oh penix robinson schumann subramaniam van whittle nav deductive synthesis state estimation software 
ieee automated software engineering conference san diego ca 
stickel theorem prover 
www ai sri com stickel html 

van robinson lowry explaining synthesized software 
ieee automated software engineering conference honolulu hawaii 
lowry rosu certifying domain specific policies 
ieee automated software engineering conference san diego ca 
holzmann peled state spin 
lecture notes computer science vol 
springer verlag 

corbett dwyer hatcliff pasareanu robby laubach zheng bandera extracting finite state models java source code 
proceedings nd international conference software engineering ireland 

visser park penix predicate abstraction reduce object oriented programs model checking 
proceedings rd acm sigsoft workshop formal methods software practice 

dwyer hatcliff laubach pasareanu robby visser zheng tool supported program abstraction finite state verification 
proceedings rd international conference software engineering 

visser havelund brat park model checking programs 
ieee international conference automated software engineering grenoble france 

visser addressing dynamic issues program model checking 
lecture notes computer science vol 
springer verlag 

owre rushby shankar pvs prototype verification system 
lecture notes computer science vol 
springer verlag 

barrett dill levitt validity checking combinations theories equality 
lecture notes computer science vol 
springer verlag 

hatcliff corbett dwyer sokolowski zheng formal study slicing multi threaded programs jvm concurrency primitives 
proc 
int 
symposium static analysis 

pasareanu deos kernel environment modeling ltl assumptions 
technical report nasa arc ic nasa ames 

havelund lowry penix formal analysis spacecraft controller spin 
proceedings th spin workshop paris france 

havelund lowry park penix visser white formal analysis remote agent flight 
proceedings th nasa langley formal methods workshop 
penix visser larson verification time partitioning deos scheduler kernel 
proceedings nd international conference software engineering ireland 
