software practice experience vol 
february rewriting executable files measure program behavior james larus thomas ball computer sciences department university wisconsin madison west dayton street madison wi 
email larus cs wisc edu summary inserting instrumentation code program effective technique detecting recording measuring aspects program performance 
instrumentation code added stage compilation process specially modified system tools compiler linker new tools measurement system 
reasons adding instrumentation code compilation process rewriting executable file presents fewer complications leads complete measurements 
describes difficulties adding code executable files arose developing profiling tracing tools qp qpt 
techniques tools instrument programs mips sparc processors applicable instrumentation systems running processors operating systems 
addition difficulties avoided minor changes compilers executable file formats 
changes simplify approach measuring program performance generally useful 
key words performance measurement instrumentation control flow graph executable file 
program behavior performance complex understood assistance tools execution time profiler memory leak detector cache performance profiler 
parallel programs performance typically incomprehensible aid specialized tools 
performance tools base results measurements collected hardware monitors code incorporated operating system code inserted program 
choice measurement technique depends nature desired data acceptable level program perturbation availability hardware software resources 
discusses techniques implementing alternative widely requires hardware operating system modifications proved flexible effective systems 
measure program tool modifies program adding small bits code ccc received july john wiley sons revised july larus ball known instrumentation code record program events collect data code added stage compilation process 
adding code executable files process requires changes system tools compilers linkers exposes complete program including libraries 
instrumenting executables permits complete detailed measurements simplifies measurement tool programs need compiled recompiled different manner measure 
rewriting executable file stages 
measurement tool independent stage analyzes original program find control structure identify data 
second stage measurement tool uses analysis select instrumentation code decide insert 
third stage program instrumented inserting measurement code modifying existing instruction data preserve program behavior 
analyzing instrumenting executables straight forward 
machine instruction sets executable file formats designed executed analyzed modified 
systems described johnson compiler linker developed conjunction measurement tools minor changes parts system considerably facilitated instrumentation 
opportunity start afresh unfortunately rare tools manipulate executables produced unmodified compilers existing formats 
discusses techniques implementing third stages 
techniques general 
instrumentation systems running different processors operating systems analyze modify executables 
developed techniques program profiler qp program tracer qpt 
qp basic block execution profiler similar mip pixie 
addition na approach placing counters basic block implements sophisticated algorithm placing counting code reduces profiling overhead factor 
qpt improved version qp uses execution efficiently trace program instruction data 
execution dramatically reduces cost program tracing size trace files factors simple techniques record 
qpt second generation tracing system 
earlier version ae modification gnu compiler gcc inserted tracing code compiling program 
note qpt operates executable files relatively language independent extensively unoptimized optimized modula fortran programs 
discussion mentions qpt techniques originated qp 
divides parts 
part sections discusses related provides general overview adding code executables 
second part section details problems caused existing executable files compilers linkers outlines solutions 
section suggests simple changes compilers executables simplify technique program instrumentation 
approach dynamically check program properties 
example purify adds instrumentation code detects memory leaks 
second stage techniques profiling tracing described 
rewriting executable files 
related code modification widely technique measuring program performance 
tools add instrumentation code stage compilation process see 
compilation source source program transformation add measurement code directly program text 
type instrumentation measure source level characteristics type statements executed estimate potential parallelism monitor program behavior functional languages 
high level language source program far removed instructions executed computer approach unable measure details instruction memory patterns 
applied code libraries source text unavailable 
compilation specially modified compiler insert instrumentation code program compiled 
prof gprof profilers approach measurement systems 
compiler source available approach enables measurement system exploit compiler analyses reduce cost measurement intelligently placing instrumentation code 
addition compiler mappings syntactic semantic structures aid placing instrumentation code reporting measurements understandable terms procedure variable names line numbers 
modifying compilers disadvantages 
commercial compilers source code unavailable 
addition programs written different languages compiler linked libraries 
options inserting instrumentation code computer program 
code inserted stage compilation process 
adding code executables process permits complete detailed measurements simplifies tools programs need compiled recompiled different manner measure larus ball supplied precompiled 
problem compilers typically defer code generation final stage instrumentation code manipulates compiler intermediate representation blurs association instrumentation particular instructions 
program recompiled measure increases time effort study program prevents measurement precompiled programs 
compilation effects compiler optimization code generation visible directly measured 
possibility addresses problems previous approach change assembly language produced compiler passing assembler 
systems generating assembly language changes compiler behavior 
example mips systems assembly code contains debugging information 
addition mips assembly language correspond directly binary instructions 
mips assembler generates instructions translate assembler pseudo instructions machine instructions reorganizes instructions minimize pipeline delays 
similarly sources assembler linker available tool insert instrumentation code 
linker processes entire program including libraries ensure modules measured compute interprocedural information 
contrast program instrumented earlier compilation process requires specially instrumented libraries 
linker relocation information binds addresses greatly simplifies process inserting additional code 
clever approach effectively uses relocation information modify object files steps assembly linking 
approach requires relinking entire program measure applied programs object files unavailable 
different approach dynamically measure programs process control mechanism debuggers faster breakpoints 
cost debugger process control mechanism entails context switches interaction far high approach competitive 
kessler fast breakpoints dynamically patch running executable jump instrumentation code 
overhead comparable approach described 
final alternative advocated insert instrumentation code rewriting executable file incorporate code 
mip profiling tracing tool pixie long approach 
addition johnson process called measure optimize programs 
system described johnson operated conjunction specially modified compiler linker simplified process difficult optimizations passing additional information 
wall approach called late code modification systems measure optimize programs 
related application requires techniques translate executable files run different architecture operating system 
convenience call technique adding code executable rewriting executable file portion measurement tool performs exec editor 
rest tool chooses instrumentation code called measurement driver code 
alternative advantages 
exec editor largely independent earlier stages compilation process 
requires sources rewriting executable files modifications compilers assemblers linkers 
works programs written different source languages compiled non standard gcc compilers 
addition executable rewriting manipulates entire programs including precompiled libraries source unavailable 

overview exec editing section overview instrumentation process qpt 
outlines major steps process describe complications explored section 
shows process 
step program analysis constructs control flow graph procedure executable 
graphs identify potential paths procedure basic program representation measurement driver code exec editor 
measurement driver code qpt computes best locations instrumentation passes location instructions instrumentation sequence exec editor portion qpt 
part program decides modify program adjust jump branch offsets accommodate profiling tracing code 
exec editor writes new executable file containing instrumented routines updated symbol table 
producing new executable exec editor modify program instructions data 
described jumps branches analyzed 
data difficult track accurately indirect data modified program remain place 
constraint fortunately prevent exec editor adding new data existing data 
qpt processes routine executable separately 
interprocedural analysis aid program analysis simplify instrumentation cases described avoided potentially large cost time space 
retrospect bad choice problems caused lack information interprocedural jumps branches avoided quick initial examination program collected limited interprocedural information 

overview instrumentation process 
program analysis constructs control flow graph cfg measurement driver code decide place instrumentation code exec editor update instruction addresses reflect additional code larus ball executable file typically contains major parts see 
header records sizes locations pieces 
text segment primarily contains program executable code 
data segment contains statically allocated data composed initialized data uninitialized data known bss 
explicitly represented executable 
file header records size bss segment zero filled space allocated program loaded memory 
program optional symbol table maps names line numbers source program instruction data addresses 
detail quality information table varies widely depending format executable optimization debugging level program compiled 
qpt reads executable file header symbol table 
analyze program qpt needs starting address procedure extracts additional information measurement driver code avoid second pass table 
file stripped symbol table removed save space qpt quits 
discussed qpt process stripped files control flow analysis identify procedures 
lack routine names difficult meaningfully report profiling information qpt reflecting origins analyze files 
qpt processes procedure individually building control flow graph cfg common compiler data structure concisely represents flow control procedure 
nodes cfg called basic blocks 
delimit straight line single entry single exit sequences instructions 
edges represent jumps blocks fall throughs consecutive blocks 
qpt constructs cfg passes routine instructions 
pass examines instruction identify control transfers branches jumps determines instruction basic block 
second pass records edges connecting blocks 
code build cfg machine independent relies small collection machine specific routines categorize instruction determine destination addresses jumps 
measurement driver code qpt uses cfg place instrumentation code optimal locations 
step computes weighting assigns execution frequency cfg edge 
weighting computed heuristic structure cfg derived previous profile program 
computing weighting qpt computes maximum weight spanning tree cfg 
set edges largest frequently 
organization unix tm executable file 
file header identifies pieces file 
text segment primarily contains program instructions 
data segment divided initialized uninitialized data 
file may contain symbol table aid debugging rewriting executable files executed subgraph cfg need instrumented 
edges tree instrumented record number times execute sequence execute depending program profiled traced 
information recorded edges sufficient reconstruct full profile trace 
instrumenting edges opposed basic blocks qpt innovations 
show instrumentation code edges frequently better code limited blocks 
practical terms placing code edges slightly complex 
instrumentation code target block placed immediately block code see 
difficulty comes redirecting control flow land appropriate instrumentation code introducing unnecessary jumps 
describes algorithm laying instrumentation code block 
instruction predecessor block jumps target block falls target block 
case jump redirected land instrumentation code edge measured bypass instrumentation go directly target block 
case control falls instrumentation code fall edge code placed block sequence instrumentation code 
fall edge instrumented edges requires additional jump avoid instrumentation code 
best case measured fall edge edges uninstrumented algorithm introduces additional jumps 
qpt approximately half measured edges fall category 
qpt inserts instrumentation code blocks trace address 
memory arise explicit load store instructions implicit memory resident operands 
set instructions compute address memory called address slice 
qpt finds address slice computing transitive closure instructions value compute address 
instructions results recomputed trace regenerated require instrumentation code record value 
memory 
instrumenting edges 
instrumentation code edge prepended edge target block 
putting code edges may require additional jumps source blocks instrumentation code larus ball 
algorithm laying instrumentation code incoming edges block outputs instrumentation fall edge exists avoid introducing unnecessary jump 
produces instrumentation edges require jump instrumentation code instrumentation code similar control tracing code code contained block require additional jumps 
inserting form instrumentation code changes distance instructions requires adjustment conditional branches unconditional jumps 
direct branches jumps specify address offset target easily modified accommodate instrumentation code 
indirect jumps go jump table difficult target address unknown run time 
exec editor qpt adds code translate target address immediately indirect jump executes 
code uses complete map original new addresses instruction see section stored instrumented executable 
final stage processing routine write modified code new executable file 
point qpt direct representation instrumented routine 
annotations flow graph edges blocks auxiliary tables describe instrumentation code changes existing instructions 
qpt writes instrumented routine temporary file 
processing routines qpt goes back copies code new executable file 
step process necessary order patch forward calls routine executable eventual address unknown call encountered 
creating new executable file qpt updates symbol table information reflect new memory locations routines 
fixing information permits source level debugging instrumented executables 
feature particularly useful developer instrumentation tool 
general updating symbol table information entails straightforward replacement addresses original executable addresses new executable 
certain compact information rewriting executable files encodings example mips systems line number table complicate process mapping old new information may 

complications exec editing rewriting executable simple description suggests 
quirks computer instruction sets missing information executable file formats complicate analysis insertion new code 
problem mitigated simple changes file formats discussed section 
changes widespread exec editors live existing machines file formats 
techniques discussed section developed instrument programs popular risc architecture mips sparc useful systems 
computers operating systems share similar problems resolved techniques 
mips sparc processors reduced instruction set computers 
type processor instruction set offers advantages exec editing 
important small instruction set fixed length instructions simplify decoding binary instructions constructing cfg 
hand characteristics notably exposed pipeline delayed loads branches complicate exec editing discussed 
mips sparc systems different executable file formats 
mips uses proprietary format called extension format sunos uses derivative bsd format complex form contains significantly precise debugging information 
additional complexity provides benefits qpt extracts pieces information mips symbol table procedure starting address procedure comes assembly language file register holds procedure return address 
sparc system register conventions aggressive compilers second third pieces information unnecessary machine 
complexity adversely affect qpt mainly mips library hides details data structures 
discussion organized problem 
subsection describes hardware software decision complicates analysis instrumentation explains qpt handles difficulties 
problems caused branch instructions complicate program analysis modification 
third problem comes condition codes sparc processors 
problems caused compiler conventions complicate tasks 
final group problems primarily due shortcomings information contained executable 

delayed transfers delayed control transfer instructions delayed branches jumps subroutine calls cause problems constructing flow graphs adding instrumentation code 
delayed instruction execute immediately 
effect delayed instruction executes 
delayed branch executes sun new operating system solaris uses different format resolves problems discussed 
larus ball stages performs conditional test second jumps target 
second stage overlaps execution instruction immediately branch 
delayed branch executes instruction delay slot test succeeds prevents execution test fails 
delayed instructions cause difficulties instrumenting programs 
occurs instruction delay slot belongs basic blocks 
arises necessary add code immediately instruction delay slot 
branches complicate construction control flow graph cfg 
cfg poorly suited represent order instruction execution 
conventional cfg basic block straight line executed order code sequence commonly ends branch jump 
non branch slightly complicates representation block ends branch delay slot instructions execute serial order 
branch instruction delay slot executes conditionally block longer straight line code 
qpt currently builds conventional cfg representation branches provides predicates distinguish blocks type branch 
solution works complicates measurement driver code aware different branches 
better representation cfg instruction branch delay slot put block true edge conditional branch block see 
approach measurement driver code sees conventional cfg straight line code block 
change representation imply change program instructions 
exec editor easily retain branch instrumented executable code 
problem caused instruction scheduling optimization puts instruction basic blocks 
instruction delay slot part 
representation branches cfg 
part shows cfg block branch 
delayed instruction executes control passes block labeled true successor 
part shows better representation delayed instruction moved block correct control flow edge rewriting executable files blocks target jump see 
instruction instruction block instruction subsequent block 
overlap complicate adding instrumentation code code fit blocks 
obvious solution works practice undo minor optimization duplicating instruction block copy 
delayed branches cause serious instrumentation problems instruction delay slot produces value recorded see 
instrumentation code records value added instruction branch transfers control immediately instruction executes 
qpt traced values originate load instructions function calls 
call delay slot qpt encounters memory loads delay slots 
alternative move load instrumentation code immediately delayed branch 
moved load may modify register subsequent conditional branch 
general solution execute load part instrumentation code records value conditional branch 
code sequence masks load effect saving restoring target register affect subsequent branch original load executes delay slot modifies program state 
solution move delayed instruction block shown 

indirect jumps indirect jumps commonly perceived serious impediment constructing cfgs instrumenting programs 
perception incorrect compiled code uses jumps stylized manner analyzed 
hand written assembly code indirect jumps uncontrolled manner control flow analysis impossible 
fortunately problem rare 
aside 
complications caused delayed branches 
part shows problem occurs basic blocks overlap instruction block delay slot instruction block 
part shows load instruction delay slot traced 
tracing code placed delayed branch save restore state avoid affecting outcome conditional branch larus ball threads packages procedure returns indirect jumps occur switch statements alternative targets collected jump table 
commonly constructs higher level languages obvious analogue implementation indirect jumps opposed indirect calls indirect jumps jump tables innocuous table see section contains jump destination addresses 
locations demarcate cfg edges 
addition table entries easily updated redirect jump new locations target blocks 
hand jump table indirect jump part switch statement instrumented code ensure jump lands relocated original address target block 
complication arises rare hand written switch statement control transfers setjmp routine threads packages 
exec editor redirect jumps target address data value difficult detect translate statically 
special attention instrumented code fail indirect jumps destination address uninstrumented program 
avoid error qpt uses program original text segment translation table dynamically maps addresses original program addresses new program see 
location old text segment contains address modified program instruction originally stored indirect jump unknown destination small amount exec editing code compares jump address old text segment 
address lower jump original address space code dereferences translation table find new target jump 
mechanism enables qpt trace programs signals mips pixie permit 
system call establishes signal handler requires address function invoke signal 
address literal value 
translation table indirect jumps 
qpt stores addresses program original text segment dynamically translate unknown address indirect jump 
jump target address old text segment old dereferenced obtain new location target instruction exceptions rule continuations scheme ml functional languages just indirect jumps larger scale assigned goto fortran 
constructs difficult analyze precisely problem prevented qpt ported trace ml programs 
rewriting executable files difficult recognize translate program 
qpt easily recognizes sys system call modifies translate function address 
drawback translation table extra memory 
table doubles size original text segment instrumentation code expands cent translation table requires third instrumented text space 

condition codes sparc processor uses condition code registers conjunction conditional branch instructions 
variants arithmetic instructions set condition code flags affect subsequent conditional branches 
condition codes complicate instrumentation additional code affect live condition code value subsequently 
hand arithmetic instruction sparc instruction set variant affect condition codes computers vax arithmetic instruction affects condition codes 
hand sparc instruction set include instruction allows user mode program save restore condition codes 
qpt profiling tracing instrumentation code effect condition codes 
exception check full trace buffer needs flushed disk 
qpt works inability save restore condition codes ways 
tries place buffer checks places condition codes live 
general successful value typically tested immediately branch condition codes dead program 
small highly optimized loops loop ld add add bne loop branch condition codes cmp set condition codes iteration condition codes live loop 
qpt insert buffer check loop uses expensive code sequence effect condition codes 
code subtracts current buffer pointer buffer adds scaled sign bit difference current pc compute different instruction addresses depending buffer full 
code executes twice instructions change condition codes 
expensive general solution unnecessary qpt save restore condition codes sequence branch arithmetic operations indirectly access modify condition codes 
example bit indicates alu operation produced result zero 
tested bne instructions set add 
larus ball 
code data compilers store read data program text space 
benefits shares single copy data multiple concurrently executing processes text segments usually shared reduces distance instructions data permitting efficient addressing ensures values modified text segments usually read 
mixing code data greatly complicates constructing cfgs distinguishing data instructions difficult 
compiler puts data text segment reasons see 
jump tables switch statements 
mips compilers store tables data segment 
hand sparc compilers store text segment immediately indirect jump uses 
approach consistently applied enables exec editor find locations jump table easily 
sparc systems jump table usually starts immediately indirect jump instruction delay slot 
mips compilers base address jump table examining instructions immediately indirect jump 
instructions load address determined linker register added offset table 
jump table extent ways 
examine instructions indirect jump find comparison checks index expression table bounds 
comparison contains table size 
test compiler generates stylized code switch statements instruction scheduler greatly reorder code 
approach consistently works mips systems 
way find table text space scan 
entry containing invalid address program text space instruction table see 
compiled code restriction addresses tightened legal addresses current procedure 
call table way preliminary table 
entry table legal instruction legal address 
distinguished table determined finding jump address table jump branch instruction procedure lands preliminary table entry see 
entry block table 

data text segment 
data text segment occurs places 
jump tables switch statements 
second literal constants rewriting executable files 
finding jump table 
address jump table determined examining instructions examining table entries 
entry valid instruction address clearly marks table 
conversely valid addresses table point instructions outside table form data text segment literal constants 
typically appear immediately routine instructions 
values may difficult distinguish instructions cause control flow analyzer append incorrect basic blocks cfg 
constants segregated instructions building cfg 
analyzer constructing cfg detects instruction routine typically return stops scanning point 
routine contain return instruction unconditional backward branch analyzer examine cfg determine control passes instruction return unconditional jump 
instruction marks routine follows data 
special case routine consisting entirely data frequently table constants 
confusion arises symbol tables record identifiers text segment distinguish procedures tables 
case analyzer constructing cfg previous technique 
control flow analyzer identify tables name known words invalid instructions lack essential attribute routine return interprocedural jump 
second test facilitated instruction set encodings sparc small integers correspond invalid instructions 

register allocation high optimization levels compilers allocate registers interprocedurally violates normal register conventions 
general qpt register conventions instrumentation code saves restores registers affect program state 
cost pushing popping registers stack frequently exceeds cost instrumentation 
qpt reduces overhead mips systems register scavenging scanning instructions construct cfg qpt notes unused caller saved registers procedure 
register scavenging unnecessary sparc global registers deliberately left unused sparc abi application binary interface 
qpt checks program follows sparc register convention registers 
larus ball registers instrumentation code preserving values procedure callers expect registers modified register scavenging depends program obeying caller save register convention 
interprocedural register allocated code hand written routines violate convention keeping live value caller saved register call callee modify register 
qpt detect violations fall back general code sequences save restore state 
mips symbol table provides part information necessary detect violations 
records source language file containing procedure assembly code identified treated suspect 
symbol table record file optimization level interprocedurally optimized code difficult detect 
omission particularly frustrating symbol table records file debugging level 
qpt resolves problem command line argument indicate program compiled interprocedurally register allocated 

hidden procedures multiple entries symbol tables frequently record procedure program 
local procedures typically omitted 
omission complicates exec editing symbol table entries identify points start constructing cfgs 
hidden routines discovered ways 
call routine symbol table 
procedure cfg account space instruction followed valid instructions 
qpt adds hidden routines internal symbol table instruments conventional routines 
lack meaningful names assigned names complicate process reporting measurements 
hand written routines fortran code entry statements contain multiple entry points 
practice common complementary numeric routines sine cosine routine short stub transforms arguments jumps routine 
symbol tables record alternative entry point qpt instrumentation code typically slightly inaccurate routines 
problem corrected additional pass program detect multiple entry points 
qpt currently 

shared libraries position independent code sunos operating systems shared libraries reduce size executable files amount memory consumed multiple copies library routines 
program begins execution dynamically loads shared libraries address space 
unresolved missing code program prevent qpt instrumenting 
conceptually difficult instrument dynamically linked program statically linking libraries lib ld rewriting resulting complete program 
shared libraries rely position independent code pic reduce required dynamic linking 
qpt processes code sophisticated version technique look caller saved registers dead instrumentation point 
rewriting executable files instrument dynamically linked programs pic libraries programs 
pic introduces complications 
frequently invokes call instruction compute absolute address 
call return address determines address call instruction compute addresses 
fortunately calls stylized form call easily recognized 
qpt disregards alter control flow 

sparc systems code switch tables look different code contains pc relative address jump table 
solution modify qpt look alternative code sequence parse correctly 

pic code uses trampolines invoke dynamic linked routines 
trampoline short code sequence containing relocatable jump routine 
application calls trampoline address known static link time turn jumps dynamic routine 
trampolines stored data segment easily distinguished true procedures 
addition constructing call graph report profile statistics generate trace regeneration code qpt follow calls trampolines find routines invoked 

abutting text data mips systems text data segments widely separated program address space qpt extend program text space running data segment addresses 
sparc processors segments abut text segment expand 
machines instrumented code placed part address space 
logical place immediately data segment 
format sunos executable files complicates placement files data segment divided initialized data directly represented file bss uninitialized data see 
bss implicitly represented length executable file 
qpt places new code initialized data minimizes size resulting executable file resides addresses previously occupied uninitialized data requires substantial impossible relocation program data addresses 
hand qpt places new code uninitialized data forces bss data represented explicitly executable increase size order magnitude 
practical solution combines approaches 
qpt places instrumented code initialized data executable soon program starts executing copies new code locations bss data clears memory previously occupied 
process works greatly complicates debugging breakpoints set code bss segments flip 
problem solaris os uses elf file format allows number segments stored executable file order mapped memory locations 
larus ball 
location instrumented text segment 
instrumented program text placed existing data 
placement requires bss segment explicitly represented executable file 
placing new text initialized data minimizes file size requires relocating uninitialized data 
qpt solution approach executable file swap new text bss segments program begins appears program approach 
start termination qpt adds instrumentation code performs actions immediately program starts executing just finishes running 
qpt start code allocates buffer top stack moving program arguments environment stack 
code jumps normal start routine invokes program 
new start code easy add executable files explicitly identify program entry point 
qpt simply changes entry point new routine 
qpt termination code writes instrumentation buffer program finishes difficult install 
program terminates exception exit system call 
unix tm provide exception handling mechanism permit qpt gain control reliably errors 
consequently programs terminate abnormally fully profiled traced 
normally terminating programs invoke exit system call 
qpt installs call termination routine immediately exit system call 
qpt statically determine system call exit examining instructions call find system call number loaded argument register 
calls test ambiguous qpt inserts short code sequence check dynamically call exit 

back tracing program measurements quick program profiling require backtrace routines active point program execution 
qpt backtrace identifies basic blocks satisfy kirchhoff flow law count entry arcs greater exit arcs 
imbalance affects quick profiling algorithm easily rectified list call sites active exit back trace 
sparc systems short code sequence invoked rewriting executable files immediately exit system call collects records back trace walking stack 
mips systems extremely difficult produce back trace running program procedure stores return address different offset stack frame 
symbol table records offsets table unavailable program execution 
qpt exit code sequence dumps active stack tools examine conjunction symbol table compute back trace 
general approach works exit rarely invoked deeply nested procedures normally terminating program 
routines large local variables frequently happens fortran programs cause extraneous information dumped large cost time disk space 
better alternative include return address stack offset information instrumented program pcs run time 

recommendations qpt number exec editing tools demonstrate rewriting executables practical effective means measuring program behavior 
discussion shows choices operating systems compilers inadvertently complicate process 
fortunately simple changes compiler executable file formats greatly simplify process rewriting executables little cost rest system 
rest section briefly lists important changes type 

separate code data change separate instructions clearly data ensure clearly distinguishable 
perspective exec editor instructions belong text segment data data segment 
distinction practical reasons discussed 
case data distinguished instructions labeling symbol table entry clearly identifies data instructions 

executable file library mips systems provide library routines access information executable file 
library hides complexity file format compactly stores detailed debugging information collection interlinked symbol tables 
vendors emulate library provide higher level interface executable files common standard providing description data structures 
exec editing shortcomings 
easily correctable problem provides access line number data information executable file 
fundamental issue library oriented programs extract information file create copy file modified information 
iterators guarantee objects traversed order appear file exec editor traverse symbol tables ensure record processed correct order 
larus ball promising step supporting exec editing gnu project library machine operating system independent library reading writing executable files 
library gnu project assemblers linkers debuggers provides functionality exec editor 

executable file improvements minor changes executable file symbol table eliminate problems little cost 
text data segments separated memory text segment expand running data 
alternatively approach taken elf allowing segment stored non contiguous pieces alleviates problem 
symbol table record indirect jump part switch statement location jump table 
addition authors compilers libraries ensure procedures recorded symbol table 
symbol table identify multiple entry points procedure 
symbol tables record optimization level file 
changes require minor expansion quantity information symbol table 

instrumenting program small pieces code effective way monitoring program behavior measuring program performance 
instrumentation code added points compilation waiting process rewriting executable file reduces cost measuring program exposes entire code instrumentation 
tools including mip pixie authors qp qpt successfully approach profile trace programs 
cost instrumenting executable inconsequential seconds modern workstation executables 
run time overhead dominated instrumentation code additional checks branches inserted exec editor 
rewriting executable file requires exec editor find procedures file build accurate control flow graphs 
design decisions operating systems compilers inadvertently complicate process 
choices include code data identifying jump tables switch statements omitting procedure entries symbol table violating register conventions recording fact stack formats prevent run time back tracing placing data segment immediately text segment 
decisions changed way simplifies exec editing affecting programs execution cost significantly increasing size executables 
measurement tools deal executables problems 
described number techniques permit exec editing existing programs 
workarounds complex properly vast majority cases complicate exec editor heuristics guaranteed compilers 
making changes executable file formats compilers encourage widespread approach program measurement lead new tools provide deeper insight program performance 
rewriting executable files tony profiling program bbp identified problems discussed provided idea old text segment indirect jump table 
jeff hollingsworth brian johnson provided helpful comments 
supported part national science foundation ccr ccr wisconsin research foundation 

reed hastings bob joyce purify easy detection memory leaks access errors proc 
winter usenix conference january pp 


johnson fun profit proc 
winter usenix conference january pp 


thomas ball james larus optimally profiling tracing programs conference record nineteenth annual acm symposium principles programming languages january pp 


james larus execution technique efficiently tracing programs software practice experience 

james larus efficient program tracing ieee computer 

donald knuth empirical study fortran programs software practice experience 

kumar measuring parallelism computation intensive scientific engineering applications ieee trans 
computers 

amir paul hudak charles consel monitoring semantics formal framework specifying implementing reasoning execution monitors 
proc 
sigplan conference programming language design implementation june pp 


susan graham peter kessler marshall mckusick execution profiler modular programs software practice experience 

barton miller morgan clark jeff hollingsworth steven sek see lim timothy ips second generation parallel program measurement system ieee trans 
parallel distributed systems 

david wall global register allocation link time proc 
acm sigplan symposium compiler construction june pp 


david wall michael powell mahler experience intermediate language machine description proc 
second international conference architectural support programming languages operating systems asplos ii october pp 


matt bishop profiling unix patching software practice experience 

peter kessler fast breakpoints design implementation proc 
sigplan conference programming language design implementation june pp 


mips computer systems languages programmer guide december 

david wall systems late code modification technical report wrl technical note tn digital equipment western research laboratory 

gabriel kemal lu architectural framework supporting heterogeneous instruction set architectures ieee computer 

richard sites anton chernoff matthew kirk maurice marks scott robinson binary translation communications acm 

gerry kane joe heinrich mips risc architecture prentice hall 

ben ed sparc technical papers springer verlag 

john hennessy david patterson computer architecture quantitative approach morgan kaufmann 

olin shivers control flow analysis scheme proc 
sigplan conference programming language design implementation june pp 

larus ball 
robert meng lee dang mark weeks shared libraries sunos 
steve chamberlain binary file descriptor library unpublished documentation binary utilities april 
