report dresden university technology institute theoretical computer science chair automata theory keys nominals concrete domains carsten lutz carlos ian horrocks ulrike sattler lehrstuhl institut theoretische informatik tu dresden lat inf tu dresden de report hans str 
dresden germany keys nominals concrete domains carsten lutz carlos ian horrocks ulrike sattler description logics dls combine knowledge representation logical level interface concrete domains numbers strings built predicates prefix 
hybrid dls turned quite useful reasoning conceptual models information systems basis expressive ontology languages 
propose extend dls key constraints allow expression statements citizens uniquely identified social security number 
idea introduce number natural description logics perform detailed analysis decidability computational complexity 
turns naive extensions key constraints easily lead undecidability careful extensions yield nexptime complete dls variety useful concrete domains 
motivation description logics dls family formalisms allow representation reasoning conceptual knowledge structured semantically understood manner 
central entities representing knowledge concepts constructed atomic concept names unary predicates role names binary relations means concept role constructors offered particular dl 
example basic propositionally closed description logic alc describe part time employees full time managers concept employee employee manager 
example uppercase words denote concept names lowercase employee denotes role name 
viewed conceptual entities knowledge base concepts generally understood central notion various kinds formalisms 
decade observation rise various new exciting applications description logics reasoning database conceptual models expressed entity relationship diagrams object oriented schemas reasoning ontologies semantic web see respectively 
new applications turn stimulated research description logics expressive power existing dls insufficient new tasks 
important extension classical description logics concerns called concrete domains assume want continue example equipping companies founding year employees hiring year 
may want describe companies founded state hiring year employees prior founding year employing 
obviously need way talk natural numbers comparisons natural numbers 
nowadays standard approach integrate numbers datatypes description logics extend dls called concrete domains proposed baader hanschke see survey 
precisely concrete domain consists set natural numbers predicates associated fixed extension set unary binary ternary 
integration concrete domains say description logic alc achieved adding 
called features functional relations 
called concrete features partial functions associating values concrete domain natural numbers logical objects 
concrete domain concept constructor 
dl obtained extending alc way called alc denotes concrete domain viewed parameter logic 
example suitable concrete domain describe constraints formulated concept employee employer employer describes employee employed founded hiring year prior founding year 
term inside parenthesis third conjunct instances concrete domain concept constructor confused existential value restriction employee employer feature concrete features 
concrete domains considered important modern applications dls mentioned standard way description logics reasoning conceptual database models translate model dl representation description logic reasoning procedure detecting inconsistencies inferring consequences information provided explicitly model additional implicit containments entities classes 
databases store concrete data numbers strings constraints concerning data usually part conceptual model captured description logic reasoning 
example concepts viewed dl encoding constraints database companies employees 
discussed description logics concrete domains suited conceptual modelling applications involving concrete datatypes 
fixed extension predicates called built 
construction ontologies semantic web called concrete datatypes play prominent role 
say example want construct ontology describing car dealers web pages web services 
ontology concrete datatypes prices manufacturing years names car models important 
formulate ontology dl need way represent concrete datatypes 
consequently dls proposed ontology language semantic web equipped form concrete domain 
propose extend expressive power description logics concrete domains way useful knowledge representation applications sketched 
describe basic idea concrete features defining key constraints examples 
suppose knowledge representation application represent concept names german citizens store social security number concrete feature ssn 
natural state citizens uniquely identified social security number distinct instances human nationality different values ssn feature 
extension dls concrete domains expressed key definition ssn keyfor human nationality 

returning database companies employees useful equip employee concrete feature branch storing branch id working ii concrete feature id storing personnel id natural enforce personnel ids unique branch id personnel id uniquely identifies employees 
ary key definition branch id keyfor employee 

car dealers ontology may assume cars manufacturers equipped identification numbers car uniquely identified combination identification number manufacturers 
express employ ary key definition referring sequences features id manufacturer id keyfor car 
formally propose extend dls provide concrete domains key boxes sets key definitions form 
un keyfor ui sequences fng features 
fn followed single concrete feature concept 
examples illustrate idea key constraints natural 
keys play important role databases mentioned reasoning database conceptual models important challenging application description logics approaches extend description logics keys investigated 
distinguishes approach existing ones idea concrete domains constructing key constraints defining keys logical level 
goal provide comprehensive analysis effects decidability computational complexity adding key boxes description logics concrete domains 
extend description logics concrete domains alc shoq key boxes way obtaining alck shoqk respectively 
alc viewed basic dl concrete domains discussed shoq proposed ontology language 
provides wealth expressive possibilities general concept inclusion axioms gcis transitive roles role hierarchies nominals qualifying number restrictions 
offers restricted variant concrete domain constructor disallows sequences features order avoid undecidability reasoning 
main outcome investigations key constraints dramatic impact decidability complexity reasoning example satisfiability alc concepts known pspace complete able show satisfiability alck concepts key boxes general undecidable 
decidability recovered restrict concepts key boxes boolean combinations concept names obtaining boolean key boxes 
interestingly satisfiability alck concepts boolean key boxes nexptime complete simple concrete domains 
case shoq shoqk leap complexity somewhat dramatic shoq concept satisfiability exptime complete addition key boxes results nexptime complete reasoning problems details 
interesting note exists close connection key definitions called nominals concept names instance pope 
nominals standard means expressivity description logics appear disguise operator 
hard see key boxes simulate nominals example concrete domain natural numbers providing unary predicates equality key definition keyfor stands logical truth obviously concept behave nominal 
reason consider extension alc nominals alcok extension alck nominals 
main result concerning nominals general lower expressive power key boxes nominals lead nexptime hardness reasoning combined concrete domains exist concrete domains note logic shoq provides nominals 
concept satisfiability nexptime complete 
stress nexptime hardness results obtained accordance observation pspace upper bound reasoning alc robust extensions logic exist seemingly harmless extensions alc example acyclic tboxes inverse roles complexity reasoning leap pspace completeness nexptime completeness natural concrete domains 
remainder organized follows section formally introduce concrete domains key boxes description logic alcok fragments alck 
define boolean key boxes called path free key boxes prohibit sequences features inside key definitions 
introduce unary key boxes ary key boxes analogy ary key definitions examples 
section devoted establishing lower bounds description logics concrete domains key boxes nominals 
section reduction post correspondence problem prove alck concept satisfiability 
non boolean key boxes undecidable concrete domain provides natural numbers unary predicate equality zero binary equality inequality binary incrementation predicate 
shift attention boolean key boxes section show restriction recovers decidability 
section introduce nexptime complete variant domino problem concrete domains useful reduction problem concept satisfiability dls providing boolean key boxes nominals 
section concrete domains prove alck concept satisfiability boolean path free key boxes nexptime hard provides unary predicates denoting disjoint singleton sets 
strengthen result unary key boxes compensate weaker key box formalism expressive concrete domains 
example suffices concrete domain provides natural numbers unary predicate ternary addition 
section prove concept satisfiability key boxes nexptime hard 
result strongest requirements concrete domain adopted additionally need predicates multiplication exponentiation 
able show exist concrete domains computationally simple ptime considered isolation lead nexptime hardness dl 
purpose section develop reasoning procedures description logics key boxes prove upper complexity bounds matching nexptime lower bounds established previous section 
start section tableau algorithm capable deciding alcok concept satisfiability boolean key boxes concrete domain key admissible 
intuitively concrete domain key admissible exists algorithm takes finite conjunction predicates set variables decides conjunction satisfiable additionally returns information variables take values solutions chosen tableau algorithm type reasoning procedure potential implemented efficient reasoners shown behave practice 
algorithm provides upper bound alcok concept satisfiability boolean key boxes nexptime algorithm mentioned explanation key admissible runs non deterministic polynomial time 
section devise tableau algorithm shoqk concept satisfiability path free key boxes involve non boolean concepts 
restriction boolean concepts key boxes necessary alcok order avoid undecidability 
shoqk restriction necessary shoqk concrete domain constructor weaker provided alcok admit sequences features arguments 
product correctness proof algorithm obtain bounded model property shoqk implies shoqk concept satisfiability path free key boxes nexptime key admissible corresponding algorithm runs non deterministic polynomial time 
section summarize results obtained give outlook possible research 
description logics concrete domains introduce description logic alcok 
start defining concrete domains definition concrete domain 
concrete domain pair set set predicate names 
predicate name associated arity ary predicate concrete domains define alcok concepts key boxes 
definition alcok syntax 
nc nr pairwise disjoint countably infinite sets concept names nominals role names concrete features 
furthermore assume nr contains countably infinite subset naf features 
path composition fng features 
fn concrete feature concrete domain 
set alcok concepts smallest set concept name nominal concept concepts role name concrete feature 
un paths predicate arity expressions concepts key definition expression 
un 

uk keyfor 
uk paths concept 
finite set key definitions called key box 
usual abbreviation arbitrary propositional tautology abbreviation abbreviation abbreviation 
consider fragments description logic alcok 
dl obtained alcok admitting empty key boxes 
particular set concepts just set alcok concepts 
furthermore disallowing nominals obtain fragment alc alck alcok 
description logic alcok equipped tarski style set theoretic semantics 
semantics introduce standard inference problems concept satisfiability concept subsumption 
definition alcok semantics 
interpretation pair non empty set called domain interpretation function 
interpretation function maps concept name subset nominal singleton subset role name subset feature partial function concrete feature partial function fng path defined tation function extended arbitrary concepts follows 

un 
xn xi 
xn undefined 
interpretation 
model concept iff 
satisfies key definition 
un keyfor ui model key box iff satisfies key definitions concept satisfiable key box iff common model 
subsumed concept key box written iff models known description logics providing negation subsumption reduced un satisfiability vice versa iff unsatisfiable satisfiable iff 
allows concentrate concept satisfiability devising complexity bounds reasoning description logics lower upper complexity bounds concept satisfiability imply corresponding bounds concept subsumption complementary complexity class 
decision procedures description logics concrete domains devised committing particular concrete domain defined interface decision procedure concrete domain reasoner needed 
usually concrete domain required admissible definition conjunction admissibility 
concrete domain set variables 
conjunction finite predicate conjunction form 
ni pi pi ni ary predicate variables conjunction satisfiable iff exists function mapping variables elements 
ni function called solution say concrete domain admissible iff 
contains name 
closed negation ary predicate predicate arity 
satisfiability conjunctions decidable 
refer satisfiability conjunctions satisfiability 
shall see considerable difference complexity decidability restrict key boxes various ways example admit concept right hand side key definitions disallow paths length greater 
introduce useful notions 
definition boolean path free simple 
key box called boolean concepts appearing key definitions boolean combinations concept names path free key definitions form 
gn keyfor 
gn simple path free boolean unary key box key definitions unary key definitions form keyfor 
concept called path free subconcepts form 
un 
un concrete features 
emphasize key box necessarily boolean path free call key box general 
similarly emphasize key box necessarily unary key box call key box ary key box 
lower bounds section prove lower bounds description logics concrete domains provide key boxes nominals 
section start showing satisfiability alck concepts 
general key boxes undecidable interesting concrete domains 
discouraging result relativized fact section shall prove restriction boolean key boxes recovers decidability 
interesting look lower complexity bounds apply restriction 
preparation introduce section variant domino problem concrete domains wellsuited reductions problem 
section prove satisfiability path free alck concepts simple key boxes nexptime hard large class concrete domains concrete domains hold restrict unary key boxes 
consider description logic section identify concrete domains concept satisfiability key boxes 
nexptime hard 
explain key boxes nominals closely related key boxes express nominals powerful 
intuitively key boxes define concepts behaves nominals number nominals defined way bounded advance simple syntactic test 
undecidability alck general key boxes prove satisfiability alck concepts key boxes undecidable large class concrete domains allow complex alck concepts occur key definitions 
proof reduction known undecidable post correspondence problem 
definition pcp 
instance post correspondence problem finite non empty list 
rk pairs words alphabet 
sequence integers 
im called solution iff im ri rim 
post correspondence problem pcp decide instance solution 
reducing pcp need appropriate concrete domain 
obviously natural concrete domain words concatenation 
see step fi fi conc fir cp step step kp keyfor step alck reduction concept cp key box kp results obtained concrete domain carry natural concrete domains numbers arithmetics 
concrete domain introduced 
definition concrete domain 
alphabet 
concrete domain defined setting defining smallest set containing predicates unary predicates word word unary predicates binary equality predicate binary inequality predicate obvious interpretation binary predicates conc uw uw 
readily checked satisfies properties admissibility 
complexity satisfiability investigated 
theorem 
satisfiability ptime 
admissible 
important aim demonstrate undecidability alck concept satisfiability due presence keys due undecidability satisfiability 
discuss reduction pcp 
instance 
rk translated alck concept key box shown 

fk denote features denote concrete features 
definition concept step just serves abbreviation 
idea reduction common model cp kp encodes potential solutions conc fk conc fk example model cp kp 
sequences completed solution pcp existence model guarantees potential solution solution 
models cp kp displayed form infinite ary tree root connected extra node role intuitively node tree represents sequence indices 
successor represents corresponding left concatenation successor corresponding right concatenation ri rin 
enforce existence infinite tree employ key box kp consider example root node successor call node due line cp line step due line cp step extra node mentioned 
view key box kp implies ii step easy see impossible line cp line step imply step line step appropriate fi successors way construction tree continued ad infinitum 
second line definition step enforces ri rin fi fin successor root node 
concept line step implies holds nodes tree root implies potential solution solution 
size cp kp clearly polynomial key box kp unary key box obtain proposition 
proposition 
satisfiability alck concepts 
general unary key boxes undecidable 
emphasize undecidability result obtained simple concrete domain combine theorem proposition 
theorem 
exists concrete domain satisfiability ptime satisfiability alck concepts 
general unary key boxes undecidable 
fk sight concrete domain look artificial may question relevance lower bounds obtained straightforward encode words natural numbers define concatenation words simple operations natural numbers words alphabet cardinality interpreted numbers written base symbol digit occur 
corresponding natural number base represent word number represent empty word 
concatenation words expressed vw denotes length word exponentiation expressed multiple multiplications multiplication multiple additions addition multiple incrementation see details 
observation gives rise theorem theorem 
concrete domain contains unary predicate binary equality inequality predicates binary predicate incr 
satisfiability alck concepts 
general unary key boxes undecidable 
subsumption reduced satisfiability described section obtain corresponding undecidability results concept subsumption 
domino problems concrete domains section introduce nexptime complete variant known undecidable domino problem define concrete domains 
concrete domains sections establish lower bounds reasoning alck boolean key boxes reasoning 
general domino problem finite set tile types 
tile types size type having square shape colored edges 
unlimited number tiles type available 
nexptime hard variant domino problem task tile torus rectangle borders glued neighboring edges color 
definition domino system 
domino system triple finite set tile types represent horizontal vertical matching conditions 
domino system 
initial condition tuple tiles 
mapping 

solution iff holds ai denotes addition modulo shown corollary follows results variant domino problem nexptime complete 
define concrete domain reduction nexptime complete domino problem alck concept satisfiability boolean key boxes 
definition concrete domain 
concrete domain defined setting smallest set containing predicates unary predicate unary predicates 
unary predicate readily checked concrete domain admissible satisfiability ptime 
proposition 
satisfiability ptime 
second concrete domain reduction nexptime complete domino problem alck concept satisfiability boolean unary key boxes 
reduction need store vectors bits single concrete domain elements 
definition concrete domain 
function 
called bit vector dimension denote set bit vectors dimension concrete domain defined setting smallest set containing predicates unary predicate unary predicate unary predicates bit bit 
unary predicates bit bit obvious satisfies conditions admissibility see algorithm satisfiability easily devised 
proposition 
satisfiability ptime 
proof 
conjunction 
show satisfiable iff conditions applies 
contains conjunct 
contains conjuncts bit bit 
contains conjuncts 
contains conjuncts 
contains conjuncts bit bit 
easily seen unsatisfiable conditions applies 
assume conditions apply set variables set set appearing index predicate mapping defined finite condition apply predicates available 
define solution follows set bit vector bvt th bit bit bit 
remains prove solution bit 
condition apply bit non applicability condition implies bit definition th bit 
bit 
definition th bit 
bit 
bit done 
th bit definition bit bit done 
condition apply bit non applicability condition yields bit ik definition th bit 
obvious listed properties checked polynomial time 
abbreviation conjunct 
concrete domain reduction nexptime complete domino problem concept satisfiability 
reduction concrete domain serves main purposes firstly store torus single element secondly positions torus addressed elements set contains different types elements domino arrays representing tori vectors addressing positions domino arrays 
intuitively vectors length understood bit vectors representing binary coding numbers positions positions torus 
domino arrays functions mapping pairs vectors natural numbers representing tile types 
discussed advisable define slightly general way admitting vectors natural numbers bit vectors 
definition concrete domain 
function 
called vector dimension denote set vectors dimension function called domino array dimension denote set domino arrays dimension concrete domain defined setting vei dai smallest set containing predicates unary predicates unary predicates pos pos unary predicates pos pos predicate tile arity tile vx vy vx vy vx vy predicate tile arity tile reason vectors natural numbers bit vectors definition want satisfiability low complexity preferably ptime consider conjunction pos pos pos pos pos tile tile tile 
bit vectors vectors natural numbers variables take value conjunction unsatisfiable 
kind inconsistency detected polynomial time 
problem eliminated vectors natural numbers definition enforcing bit vectors reduction case conjunction clearly satisfiable 
proposition proved proposition 
satisfiability ptime 
nexptime hardness alck boolean key boxes section prove nexptime lower bounds alck concept satisfiability boolean key boxes reducing nexptime complete domino problem introduced previous section 
reduction uses simple concrete domain depends ary key definitions 
second reduction uses slightly complex unnatural concrete domain needs unary key definitions 
see reductions yield different incomparable results 
reduce nexptime complete domino problem alck concept satisfiability boolean key boxes admitting ary key definitions 
domino system initial condition 
translated alck concept cd displayed 
names abbreviations confused called tboxes see section definition tboxes 
abbreviation fold nesting names xpos ypos denote concrete features 
definition init concept supposed denote th bit binary representation claim cd satisfiable key box xpos 
xpos ypos 
ypos keyfor iff exists solution substantiate claim walk reduction explain various parts concept cd step understanding structure models cd key understanding reduction note purpose line cd enforce tree structure depth leaves correspond positions torus 
precisely concept guarantees model cd exists binary tree depth 
concepts exists 
ensure leaves tree numbered concept names 
xn 
precisely domain object set 
concepts ensure exist leaves tree 
di intuitively numbering represents horizontal positions torus 
vertical positions coded similar way 
yn concept names 
specifically concepts ensure di root tree node 
xn configuration root node ii leaves numbered concept names 
yn note concept appears cd inside value restriction 
define 
xi xi ri yi yi xi xi xi xi yi yi yi yi xi xpos xi xpos yi ypos yi ypos succs rx ry yi rx yi yi rx yi xj xk rx xk xk rx xk xj xk rx xk xk rx xk xi ry xi xi ry xi yj yk ry yk yk ry yk yj yk ry yk yk ry yk label di di dj di rx dj di ry dj init cd xj xj yj dai succs label init alck reduction concept cd set leave nodes trees enforced concept exists object ei ei ei ei represents position torus 
step translate individual bits numbering ei concepts far care object 
represented concept names concrete domain values 
done concepts ensure xpos ei ei xpos ei ei similar ypos 
model key box xpos 
xpos ypos 
ypos keyfor grid positions uniquely represented domain elements fact concepts succs enforce roles rx ry holds ei ei ei ei 
succs concept ensures ei exists rx successor rx successor ei concept ensures explain note ei grid positions uniquely represented elements implies shows upper line hold 
consider concept detail 
essentially dl formulation known propositional formula xj xk xj xk encodes incrementation modulo number encoded propositional variables 
xn number encoded propositional variables 
modulo 
account rx quantifiers readily checked concept just desired effect ensure rx successor ei 
explanation enforces lower line omitted analogous case 
remains ensure grid position labeled precisely tile initial condition horizontal vertical matching conditions satisfied 
tiles represented concept names di set tiles described tasks accomplished standard way concepts label init 
interesting note reduction concept path free key box simple path free boolean 
path freeness concepts tame complexity description logics concrete domains largely sacrifices expressive power 
example alc augmented called general tboxes reasoning arbitrary concepts undecidable reasoning path free concepts exptime complete admissible satisfiability exptime 
taming approach presence key boxes just seen reasoning arbitrary path free alck concepts natural assumptions nexptime hard 
size cd key box clearly polynomial obtain proposition 
proposition 
satisfiability path free alck concepts simple key boxes nexptime hard 
proved non path free alc concept satisfiability pspacecomplete satisfiability pspace 
particular follows proposition alc concept satisfiability pspace complete 
dramatic increase complexity key boxes added alc 
stress increase due key boxes complexity satisfiability reformulate proposition theorem 
exists concrete domain satisfiability ptime satisfiability path free alck concepts simple key boxes 
concept satisfiability reduced concept non subsumption noted section obtain corresponding nexptime hardness bound subsumption path free alck concepts simple key boxes 
due low expressivity concrete domain natural knowledge representation fragment concrete domains proposed literature 
reduction strategy adapted quite standard concrete domains 
formulate weak condition concrete domain satisfy order reduction strategy applicable 
theorem 
concrete domain 
exist satisfiability path free alck concepts simple key boxes nexptime hard 
corresponding nexptime hardness result concept subsumption easily obtained 
second nexptime hardness result alck concept satisfiability 
time reduce nexptime complete domino problem satisfiability path free alck concepts simple unary key boxes 
reduction similar previous discuss differences 
reduction represented individual bits grid positions individual concrete features xpos ypos approach led ary key box 
replace unary key box second reduction represent entire positions torus bit vectors provided concrete domain 
modified reduction concept cd bv denotes concrete feature concepts label init defined succs rx ry xi bv bit xi bv bit yi bv bit yi bv bit cd succs label init alck reduction concept cd 
translation position torus encoded 
xn 
yn bit vector done concept straightforward manner 
said reduction hard see cd satisfiable key box bv keyfor iff exists solution obtain proposition 
proposition 
satisfiability path free alck concepts simple unary key boxes nexptime hard 
relate nexptime lower bound complexity complexity determined theorem 
theorem 
exists concrete domain satisfiability ptime satisfiability path free alck concepts simple unary key boxes nexptime hard 
previous lower bounds obtain corresponding nexptime hardness bound concept subsumption 
elements bit vectors concrete domain considered natural choice application areas 
reduction replaced natural concrete domains 
central observation bit vectors translate sequences bits values concrete domain translate sequences bits represented concept names 
xn 
yn elements distinct sequences results translation distinct 
due restricted bit vectors ways replace natural numbers 
example define new concept follows zero tn yi sn zero sn yi sn tn sn ti xi si zero si xi si ti si zero si ti denote concrete features denotes unary predicate obvious extension denotes ternary addition predicate 
easy check objects agree interpretation 
xn 
yn si si key box keyfor reduction 
size obviously polynomial numbers appearing predicates coded binary 
obtain theorem theorem 
concrete domain 

contains predicate size representation logarithmic 
contains predicate 
satisfiability path free alck concepts simple unary key boxes nexptime hard 
example theorem yields nexptime lower bounds alck instantiated concrete domains proposed 
alternative adding addition predicate multiplication translate sequences bits natural numbers 
precisely fix sequence distinct prime numbers 
define version follows ti pi xi si si xi si ti si tn pn yi sn sn yi sn tn sn ternary multiplication predicate 
factorization natural numbers prime numbers unique key box keyfor reduction 
known th prime polynomial size concept polynomial numbers predicates coded 
obtain theorem concerning quite natural concrete domains theorem 
concrete domain 

contains predicate 
contains predicate 
satisfiability path free alck concepts simple unary key boxes nexptime hard 
nexptime hardness pointed section relationship concrete domain keys nominals close simulated concrete domain provides predicates uniquely describe elements example concept behaves nominal key definition keyfor 
define nominals single concrete feature unary key definitions 
logics single concrete feature unary key definitions sufficient simulate arbitrary number nominals example alck concept bit bit uniquely describes bit vector bv ci implies 
obviously bit vector length 
described similar way 
illustrates non trivial concrete domains logic alck expressive 
converse hold expressive power sufficient prove nexptime hardness concept satisfiability provided suitable concrete domain 
section reduce nexptime complete domino problem concept satisfiability 
domino system 
initial condition 
reduction concept cd defined denote concrete features denotes nominal concepts defined 
previous reductions give detailed explanation reduction strategy show cd satisfiable iff exists solution model cd explain structure key understanding reduction strategy convenient start line cd previous reductions concepts ensure contains tree shaped substructure depth leaf nodes roots additional trees depth set leafs trees correspond positions torus position nominal xj xk xj xk yj yk yj yk xi pos xi pos yi pos yi pos xi pos xi pos yi pos yi pos pos pos yi pos yi pos xi pos xi pos pos pos tile init tile xj xj yj tile ai cd nominal init reduction concept cd leaf node representing 
torus positions encoded concept names 
xn 
yn ei refer leaf ei ei section 
previous reduction numbers coded 
xn 
yn translated concrete domain values done concepts 
note contrast alck reduction position position stored bit vector distinct ones 
contrast previous reduction actual tiling 

structure models cd torus represented leaf nodes ei domino array conjunct line cd ensures leaf ei connected feature unique element extension nominal domain element associated domino array concrete feature shall see guaranteed concepts 
domino array represents tiling torus 
summing structure roughly shown 
tiling stored domino array purpose leaf node ei needed enforce initial condition horizontal vertical matching condition 
discuss horizontal matching condition vertical matching condition enforced analogously concept dl reformulation propositional logic formula incrementation modulo discussed page ensures ei concept names 
encode number horizontal position ei horizontal neighbor 
horizontal vertical position ei stored ei ei store horizontal position ei js horizontal successor ei vertical position 
translation 
realized concept 
verifies tiles positions stored domino array compatible horizontal matching condition 
note ensures domain element domino array attached concrete feature position torus unique 
tile stored domino array set initial condition ensured init concept similar way 
denote th bit binary encoding natural number considerations correctness reduction readily checked 
size cd polynomial note cd path free paths length appear concepts label 
summing reduction described yields result proposition 
satisfiability concepts nexptime hard 
relate nexptime lower bound complexity complexity determined theorem 
theorem 
exists concrete domain satisfiability ptime satisfiability concepts nexptime hard 
note reduction uses single nominal single nominal sufficient hardness result 
dramatic increase complexity shown satisfiability alc concepts nominals key boxes pspace complete concrete domains satisfiability pspace 
note obtain corresponding nexptime hardness bound concept subsumption 
previous sections note replaced natural concrete domains nexptime hardness proof 
idea represent domino array single natural number arithmetic operations access individual positions natural number viewed domino array partitioning binary representation sections length log denotes cardinality section describes tile single position torus 
access sections need ternary predicates div integer division mod computing remainder division 
precisely replace concept section translate numbers encoded 
xn 
yn single natural number stored concrete feature 
devise new concept tile enforcing position identified feature labeled tile tile log torus div tile mod tile torus tile concrete features binary predicate expressing exponentiation basis 
torus feature counterpart feature original reduction stores natural number represents torus 
somewhat succinctly tile concept states elements extension satisfy equation torus div si log mod log tile concept obvious way inside init concepts 
size resulting reduction concept polynomial numbers appearing predicates coded binary 
obtain theorem theorem 
concrete domain contains predicates 
unary tion logarithmic 
ternary 

ternary 

binary 
ternary div div 

ternary mod mod mod 
size representa 
satisfiability concepts nexptime hard 
reasoning procedures div section devoted developing reasoning procedures description logics concrete domains nominals keys 
start devising tableau algorithm decides satisfiability alcok concepts boolean key boxes 
algorithm yields nexptime upper complexity bound matching lower bounds established section 
consider powerful description logic shoqk 
dl extension shoq introduced provides wealth expressive means transitive roles role hierarchies nominals qualifying number restrictions 
shoqk equipped restricted variant concrete domain constructor key boxes 
develop tableau algorithm deciding satisfiability shoqk concepts key boxes 
due shoqk concrete domain constructor admit general boolean key boxes 
algorithm yields tight nexptime upper complexity bound 
tableau algorithm alcok boolean key boxes tableau algorithms decide satisfiability input concept case input key box attempting construct model 
precisely tableau algorithm starts initial data structure induced input concept repeatedly applies called completion rules 
rule application thought attempting construct model input concept 
algorithm find obvious contradiction encounter situation completions rules applicable 
case input concept unsatisfiable satisfiable case 
goal devise tableau algorithm description logic concrete domains committing particular concrete domain interface tableau algorithm concrete domain reasoner needed 
usually suffices assume concrete domain admissible implies exists procedure tell tableau algorithm conjunction satisfiable 
presence keys need know conjunction satisfiable vari ables take value solutions 
example consider concrete domain conjunction obviously solution satisfies 

information passed concrete domain reasoner tableau algorithm presence key boxes may impact structure constructed model 
example information transfer reveals unsatisfiability 
keyfor 
formalize requirement strengthen notion admissibility 
tableau algorithm developed section non deterministic formulate key admissibility non deterministic way 
definition key admissible 
concrete domain key admissible iff satisfies properties 
contains name 
closed negation 
exists algorithm takes input conjunction returns clash unsatisfiable non deterministically outputs equivalence relation set variables exists solution property iff equivalence relations described point henceforth called concrete equivalences 
say extended satisfiability np exists algorithm running polynomial time 

un 
un un nnf rewrite rules 
note property esoteric concrete domain admissible provides equality predicate key admissible 
due admissibility presence equality predicate implies inequality predicate available 
construct algorithm extended satisfiability algorithm satisfiability predicate conjunction simply guess equivalence relation set variables decide non extended satisfiability conjunction return clash unsatisfiable 
weak condition equality predicate satisfied concrete domains proposed literature see 
chapter assume concrete domain equipped equality predicate 
done conjunction equality translated equivalent equality identifying variables stated equalities 
assumption confused discussed previous paragraph concrete domain admissible set predicates closed negation assumption imply presence inequality predicate 
need prerequisites start presentation tableau algorithm concept negation normal form nnf negation occurs front concept names nominals 
easily seen concrete domain admissible alcok concept converted equivalent nnf exhaustively applying rewrite rules displayed 
denote result converting nnf 
key box nnf concepts occurring key definitions nnf 
follows generally assume input concepts key boxes nnf 
alcok concept key box 
sub denote set subconcepts including con denote set concepts appearing right hand side key definitions set concepts sub denotes set sub 
write cl abbreviation set sub sub con sub con 
start presentation tableau algorithm introducing underlying data structure 
definition completion system 
oa oc disjoint countably infinite sets concrete nodes 
completion tree alcok concept key box finite labeled tree va vc nodes va vc va oa vc oc nodes vc leaves 
tree labeled follows 
node va labeled subset cl 
edge va labeled role name occurring 
edge va vc labeled concrete feature occurring va denote depth occurs starting root node depth 
completion system alcok concept key box tuple va vc completion tree function mapping arity subset linear ordering va implies equivalence relation vc 
va vc completion tree 
node va successor node va node vc successor path notion successor defined obvious way 
intuitively relation records equalities concrete nodes model construction process 
relation induces equivalence relation nodes turn yields equivalence relation concrete nodes 
definition relations 
completion system concept key box va vc equivalence relation va nr node va neighbor node va exists node va successor similarly node vc neighbor exists node va successor paths notion neighbor defined obvious way 
define sequence equivalence relations va follows va naf neighbors 
un keyfor ui neighbors xi ui neighbors yi xi yi set define va neighbors 
key admissible concrete domain 
decide satisfiability alcok concept boolean key box nnf tableau algorithm started initial completion tree initial completion system tc sc tc maps occurring 
introduce operation completion rules add new nodes completion trees 
definition operation 
concrete node called fresh completion tree appear completion system va vc 
notions va oa fresh nr 
write arb denote completion system obtained adding va setting 
inserted implies 
va oc fresh 
write denote completion system obtained adding vc setting nesting operation omit brackets writing ar br ar br 
fng path 
aux va oc fresh denote completion system obtained distinct nodes 
bn oa fresh setting af bn 
strictly speaking arb operation non deterministic specify precisely node inserted don care nondeterminism view operation deterministic 
completion rules 
note rch rules non deterministic possible outcome true don know non determinism 
remarks completion rules order upper rules known existing tableau algorithms alc concept satisfiability example 
deserves comment considers neighbor set arb fresh oa neighbor set 
un exist 
xn vc xi ui successor 
xn set au 
xn oc fresh 
xn rch 
un keyfor exist 
xn vc xi ui neighbor set rp va minimal set completion rules alcok 
neighbors successors usual 
intuitively nodes completion tree describe domain element constructed model similarly relation concrete nodes 
successor successor want completion tree tree explicit 
compensate rule talks neighbors successors 
lower rules necessary dealing key boxes 
rch rule called choose rule intuitively guesses node satisfies exists key definition 
un keyfor neighbors paths ui 
necessary possibilities may ramifications satisfies taken account construction relation satisfy deal consequences satisfying imagine 
rp rule dealing equalities nodes recorded relation means describe node constructed model node labels identical 
suffices choose representative equivalence class sure representative node label contains labels equivalent nodes 
representative node minimal ordering introduced solely reason 
rp rule appropriate copying node labels 
define procedure sat contains clash return unsatisfiable check compute compute contains clash return unsatisfiable complete return satisfiable application completion rule return sat alcok tableau algorithm 
formalize means completion system contain contradiction 
definition clash 
completion system concept key box va vc 
say completion system concrete domain satisfiable iff conjunction xn satisfiable 
said contain clash iff 
xn cy 
va nc 
va vc neighbor 
concrete domain satisfiable 
contain clash called clash free 
called complete iff completion rule applicable tableau algorithm described pseudo code notation 
check refers algorithm computing concrete equivalence conjunction described definition 
spend words loop 
obviously exist close relationships relations predicate conjunction note depend recomputed step loop result check yields relation containing 
facts may check step loop new tuples added relation deleted see proof lemma 
presence loop leads tight coupling concrete domain reasoner tableau algorithm concrete domain reasoner finds concrete nodes equal tableau algorithm may deduce computation equalities concrete nodes 
new equalities may concrete domain reasoner find additional ones forth 
similar interplay takes place course recursion steps equalities concrete nodes provided concrete domain reasoner may new rules applicable example rp changes may subsequently lead detection equalities concrete nodes concrete domain reasoner forth 
considerations show presence keys exists close interplay concrete domain reasoner tableau algorithm needed keys case suffices apply concrete domain satisfiability check completion rules exhaustively applied 
prove termination soundness completeness tableau algorithm starting termination 
need establish notions technical lemmas 
concept key box 
denote length number symbols write denote uk keyfor 
role depth concepts defined inductively follows rd rd rd rd 
un max ui rd rd max rd rd rd rd rd series lemmas eventually allow prove termination 
lemma 
constant tableau algorithm started input va vc completion tree constructed run algorithm va vc proof 
induction number rule applications case distinction applied rule straightforward show implies rd constructed completion trees omit details note treating rch rule needs employ fact boolean adds concepts role depth node labels treating rp rule implies 
implies upper bound depth constructed completion trees rules generate new nodes application rules node va implies 
second new concrete node generated application rules node va clearly satisfies max mpl mpl denotes maximum length paths note concepts may contain paths boolean 
mpl observations imply depth constructed completion trees bounded 
degree 
node generated due application rule initially successor 
analyze number successors generated applications rules rules applied concept 
un appearing node label 
definition cl boolean number concepts node label bounded sub 
rule application creates successors 
degree constructed completion trees bounded 
lemma 
constant tableau algorithm started recursion step loop terminates steps 
proof 
fix argument va vc passed sat function 
sequence concrete equivalences computed loop 
corresponding relations 
show implies lemma lemma exists constant vc implies number steps performed loop bounded proof 
loop reaches th step step 
definition implies definition easy see 
lemma 
constant tableau algorithm started number recursion calls bounded proof 
obviously suffices establish appropriate upper bound number rule applications 
rules applied concept node label 
lemma number nodes exponential 
nodes concepts node labels deleted fact node labels subsets cl implies number applications rules exponential 
holds rules rp applied concept cl pair nodes 
number rch applications exponential rule applied node key definition termination obvious consequence lemmas 
corollary termination 
tableau algorithm terminates input 
prove soundness algorithm 
lemma soundness 
tableau algorithm returns satisfiable input concept satisfiable input key box proof 
tableau algorithm returns satisfiable exists complete clash free completion system 
va vc 
definition tableau algorithm completion system call check returned 
exists solution iff 
clearly solution second component identical solution part xn 
xn conjunct second part definition 
construct interpretation setting va va va successor neighbor nc nr 
show defined singleton 
assume exist 
definition implies yields contradiction 
functional naf 
assume exist exist va successor successor 
definition implying yields contradiction 
functional 
assume exist vc 
neighbors definition implying contradiction 
claim central showing model claim cl label root node claim clearly implies model 
prove satisfies key definitions 
un keyfor fix ci ui uii non applicability rch yields 
claim implies contradiction ci obtain 
analogous way argue 
construction fact ui uii defined readily checked ui neighbor xi ui neighbor yi construction imply xi yi xi yi observations obviously imply obtain definition remains prove claim done structural induction concept name nominal 
easy construction cl nnf concept name 
clash free implies 
construction yields 
un rule applicable exist 
xn vc xi ui successor 
xn 
construction induction length paths reader may check implies xi careful deal nodes encountered paths 

xn solution 
xn 
clash free exists vc neighbor construction straightforward completeness induction hypothesis 
rule applicable neighbor 
minimal definition non applicability rp rule yields 
induction get definition implies exist va minimal minimal successor clearly neighbor non applicability yields implies due rp 
induction get holds independently choice obtain lemma completeness 
input concept satisfiable input key box tableau algorithm returns satisfiable 
proof 
model guide non deterministic parts algorithm constructs complete clash free completion system 
completion system va vc called compatible exist mappings va vc ca cb successor cc successor cd 
xn 
xn ce establish claim claim completion system compatible implies ii implies 
proof show induction implies definition yields 
start 
exists nominal 
ca obtain yields definition semantics 
step 
distinguish cases 
induction 

va naf neighbors exist va successor successor 
induction 
cb yields implies definition semantics 

exist 
un keyfor ui neighbors xi ui neighbors yi xi yi 
ca yields ci induction cb cc straightforward show ui xi ui yi ce implies ui model key box yields definition semantics 
part ii claim 
va neighbors case ce yields 
case part claim cc yields implies 
finishes proof claim 
show completion rules applied compatibility preserved 
claim completion system compatible rule applicable applied compatible completion system obtained 
proof compatible completion system functions satisfying ca ce completion rule applicable case distinction type rule applied concept 
ca implies ci ci rule adds yields completion system compatible 
rule applied 
implies rule adds applied yields completion system compatible 
rule applied concept generates new successor sets 
ca exists set 
readily checked resulting completion system compatible 
rule applied concept adds label existing neighbor exists successor part claim 
ca cb yields definition semantics obtain resulting completion system compatible 
rule applied concept 
un ui ki gi rule application generates new nodes xj ki successor successor ki xi gi successor ki 
xn 
ca 
un exist ki 
set ki ki 
ki resulting completion system compatible xi 
rch rule applied node key definition 
un keyfor non deterministically adds definition semantics rch applied resulting completion system compatible 
rp rule applied concept adds label node ca claim yields clear resulting completion system compatible 
show compatibility implies clash freeness 
claim compatible completion system clash free 
proof compatible completion system 
show clash free case distinction assume exists va concept name due ca contradiction 
assume va vc exists va successor claim yields 
ca give obtain contradiction cc yields properties cd ce part ii claim easy check solution concrete domain satisfiable 
describe guidance tableau algorithm model detail ensure times considered completion systems compatible 
obviously hold initial completion system sc tc tc 
guide non deterministic check function predicate conjunction set variables vc oc input returns relation defined setting iff relation concrete equivalence solution see 
guidance ce obviously satisfied call check properties affected call 
claim apply completion rules compatibility preserved 
corollary algorithm terminates guided way 
claim find clash algorithm returns satisfiable 
tableau algorithm yields decidability tight upper complexity bound alcok concept satisfiability key boxes 
theorem 
concrete domain key admissible 
extended np alcok concept satisfiability boolean key boxes nexptime 
proof 
corollary lemmas yield decidability alcok concept satisfiability boolean key boxes 
complexity lemma provides exponential bound number recursion calls 
remains show single recursion step needs exponential time 
lemma loop terminates exponentially steps 
step compute relations needed constructing predicate conjunction checking termination loop 
lemma exists exponential bound number concrete nodes completion system obviously done exponential time 
lemma implies size exponential 
fact extended satisfiability np implies call check needs exponential time 
remaining tasks checking clashes completeness rule applicability clearly performed exponential time 
note way algorithm leaves quite room optimizations 
possible optimization concerns re successors features example applying rule concept successor simply add adding new successor recording candidate optimizations check function 
recall function takes predicate conjunction set variables non deterministically returns concrete equivalence relation exists solution vi vj iff vi vj see definition 
hard devise alc concept enforces completion systems exponentially concrete nodes slightly adapting known alc concepts enforce models exponential size 
size input conjunctions check exponential size input concept 
note trivial conjunctions vk exist 
factorial distinct concrete equivalences 
number possible outcomes call check function may double exponential size input concept 
considering example natural approach attack problem require check return minimal concrete equivalences intuitively equivalence minimal variables equivalent equality enforced conjunction 
precisely called minimal exists concrete equivalence implies ii conjecture restricting check way destroy soundness completeness tableau algorithm 
definitely worthwhile optimization help overcome existence double exponentially outcomes check worst case concrete domains consider concrete domain page conjunctions form ci 
readily checked number minimal concrete equivalences ci exponential hard devise concept ci size logarithmic enforces completion systems ci 
double exponentially outcomes check function 
example just discussed exponential branching check clearly due discreteness natural numbers 
dense infinite 
structure defining concrete domains restriction minimal concrete equivalences desired effect number check possible outcomes polynomial size input exponential size input concept 
example consider concrete domain defined follows set rational numbers provides unary predicates negation unary predicates binary comparison predicates ternary addition predicate negation obvious semantics 
readily checked key admissible note provides binary equality predicate falls framework 
conjecture exists minimal concrete equivalence predicate conjunction intuitively possible inductively determine relation set variables implies solution ii exists solution implies 
clearly minimal concrete equivalence 
due 
tableau algorithm shoqk alcok quite powerful dl lacks expressive means state art description logic systems fact racer 
section consider expressive description logic shoqk provides concrete domains key boxes nominals means expressivity transitive roles role hierarchies qualifying number restrictions general tboxes 
modulo details shoqk viewed extension dl shoq key boxes 
shoqk proposed extended tool ontology reasoning context semantic web 
important feature shoqk called tboxes concept equations form background theory reasoning 
known combining general tboxes concrete domain constructor easily leads undecidability shoqk offers path free variant concrete domain constructor concrete features admitted inside constructor paths arbitrary length 
show restriction decidability 
path freeness concrete domain constructor obviously renders features unnecessary syntactic type available shoqk 
section restrict path free key boxes 
description logic shoqk define shoqk formal way starting syntax 
definition shoqk syntax 
role axiom role inclusion form nr transitivity axiom trans nr 
role box finite set role axioms 
role name called simple reflexive transitive closure role inclusions implies trans role names concrete domain 
set shoqk concepts smallest set concept name nominal concept concepts role name simple role name natural numbers 
gn concrete feature predicate arity expressions concepts 
gn 
concept equation expression concepts 
tbox finite set concept equations 
shoqk consider key boxes differ aspect ones considered alcok assume key boxes path free admit complex concepts occur key definitions 
note features paths occur syntax shoqk clear semantics defined simulated general number restrictions 
usual description logics shiq shoq family require role names number restrictions simple admitting arbitrary roles yields undecidability reasoning 
role box clear context usually write trans trans introduce semantics shoqk relevant reasoning problems 
definition shoqk semantics 
interpretations defined definition 
interpretation function extended shoqk concepts follows 
gn 
xn xi 
xn undefined 
interpretation 
satisfies concept equation model tbox satisfies concept equations similarly satisfies role inclusion transitivity axiom trans transitive relation 
model role box satisfies role inclusions transitivity axioms tbox role box key box 
concept satisfiable iff common model 
subsumed concept written iff common models note due requirement role names inside number restrictions simple existential universal value restrictions syntactic sugar contrast number restrictions roles 
known expressive description logics reasoning tboxes reduced reasoning shoqk deciding satisfiability concept equivalent deciding satisfiability concept nominal empty tbox fresh role appearing trans 
role name subsumption reduced satisfiability described section consider satisfiability concepts role boxes key boxes tboxes 
generally assume role boxes acyclic satisfy condition role name role names 
rk rk ri ri hard see restriction cycles eliminated 
rk cycle ri ri interpretations simply remove cycle replace occurrence 
rk 
possibly add trans cycle elimination trans ri turn attention construction tableau algorithm shoqk comment minor differences shoqk introduced original version shoq described 
main difference logic extension investigated allows ary predicates horrocks sattler restrict unary predicates 
shoq introduced uses concrete roles concrete features difference concrete roles necessary functional 
due non functionality original shoq admits variants concrete domain constructor concrete role unary predicate 
shoqk simulate universal variant writing concrete features interpreted partial functions contrast horrocks sattler undefinedness constructor available 
ary predicates provide important additional expressivity view deviations minor ones easily seen affect decidability complexity reasoning 
tableau shoqk similar tableau algorithm alcok concept satisfiability shoqk algorithm completion systems completion trees underlying data structure 
simplify dealing transitive roles role hierarchies correctness proofs establish direct correspondence existence complete clash free completion systems existence models employ intermediate step involving abstraction models called tableau 
intuitively main difference completion systems tableaux completion systems constructed tableau algorithm finite objects tableau potentially infinite 
main difference tableaux interpretations tableaux roles declared transitive necessarily described transitive relations 
section introduce tableaux 
start discussing preliminaries 
alcok assume concepts key boxes negation normal form nnf denote nnf nnf rewrite rules shoqk 
concept role box key box define cl sub sub con sub sub con cl cl cl denotes reflexive transitive closure role inclusions obviously cardinality cl linear size follows write denote set role names occurring cf denote sets concrete features occurring ready define tableaux 

gn 
gn gn shoqk nnf rewrite rules 
definition tableau 
shoqk concept nnf role box path free key box nnf 
tableau tuple sa sc sa sc sets concrete individuals sa cl maps individual subset cl sa sa nd maps pairs individuals sets roles sa cf sc maps pairs individuals concrete features concrete individuals maps ary concrete predicate occurring cl set tuples sc individual sa sa cl holds sa sa trans 
gn keyfor gi defined 
gn 
xn sc gi xi 
xn xn 
xn satisfiable 
gn keyfor gi gi undefined 
note predicate conjunction uses binary inequality predicate 
general require concrete domain equipped predicate predicate conjunction necessarily conjunction 
safe form tableaux proofs need concrete domain reasoner capable deciding satisfiability listed predicate conjunction 
show tableaux adequate abstraction models 
lemma 
shoqk concept nnf role box key box nnf 
satisfiable iff tableau proof 
concentrate properties standard tableaux shiq shoq see 
direction construct tableau common model follows sa sc sa cl gi gi defined 
xn 
xn 
easily verified tableau proof satisfies identical corresponding cases holds definition definition fact nominals interpreted singleton sets definition semantics concepts 
gn identity function sc clearly solution listed predicate conjunction definition semantics key constraints definition semantics concepts 
direction sa sc tableau solution predicate conjunction 
construct model follows sa nr trans nr trans undefined undefined 
due interpretation nominals singleton 
interpretation roles defined role boxes acyclic 
claim central proving model claim cl implies proof proceed induction structure concept names nominals claim follows definition negation concept names nominals note nnf may definition 
concepts form treated induction hypothesis 
existential universal number restrictions proof analogous shiq 
concepts form 
gn immediate consequence definition fact 
xn implies 
xn 
concepts immediate consequence definition 
finishes proof claim 
definition tableaux exists sa 
claim model show model definition obvious trans implies transitive relation 
trans definition trans implies trans implies trans implies remains show model 
gn keyfor di gi gi predicate conjunction contains explicit inequalities distinct concrete individuals implies gi gi 
implies 
claim yields contradicting di obtain similar way 
implies satisfies tableau algorithm shoqk lemma shows order decide satisfiability shoqk concepts role key boxes may tableau algorithm tries construct tableau input 
describe algorithm detail 
previous section algorithm works completion systems 
case shoqk core component completion systems completion forest completion tree 
reason completion rules remove nodes completion system way disconnect tree subtrees 
definition completion system 
shoqk concept nnf role box path free key box nnf 
concept cl reserve concept name appearing cl define extended closure cl cl nrc 
nrc cl oa oc disjoint countably infinite sets concrete nodes 
completion forest structure va vc va oa vc oc node va sa cl maps node subset cl edge va labeled non empty set role names occurring edge va vc labeled concrete feature occurring completion system structure va vc completion forest maps ary concrete predicate occurring cl set tuples vc equivalence relation vc linear ordering va node va called successor node va 
node vc called successor node va write successors node nrc nrc remarks order 
firstly contrast alcok case relation longer required respect level node 
due fact enforce termination artificially anyway property prove termination level node change anyway node root node completion rules remove edges 
secondly relation returned concrete domain solver compute relation tableau algorithm 
need compute relation contrast alcok case concepts key boxes assumed path free 
thirdly new concept names introduced ensure successors node introduced merged completion rules construct tableau 
intuitively construct finite cyclic tableau complete clash free completion system re nodes having edge successor edge node similar 
node similar successor successors satisfy restriction 
shoqk provides transitive roles need cycle detection mechanism order guarantee termination algorithm roughly spoken encounter node similar existing node need explored 
speaking terms employ mechanism called subset blocking 
definition blocked 
reflexive closure node va blocked node va 
note done blocking node necessarily ancestor blocked node forest 
modification design nexptime algorithm 
blocked nodes may unblocked successors 
decide satisfiability alcok concept role box path free key box nnf tableau algorithm started initial completion system sd fd fd maps occurring 
algorithm repeatedly applies completion rules 
actual rules introduce new notions denote set sa successor 
sa write conditions satisfied nominal 
gn keyfor xi yi gi xi yi xi yi intuitively nodes related relation describe individual tableau label 
note change rule application 
mentioned relation compute relation intuitively need keep smaller care successor concrete feature ready formulate completion rules 
abbreviations formulation rules written italics meaning remove node incoming outgoing edges remove va va vc 
adding successor node means doing exists successor vc adding vc occur completion forest 
update relation concrete domain solver asked decide satisfiability conjunction 
xn ind xn returns case conjunction satisfiable updated concrete equivalence defined definition 
explanation rules order 
rules rch nondeterministic application possible outcome 
rule true due update operation performed concrete domain reasoner discussed section computing concrete equivalence conjunction may result high degree non determinism 
please note contrast alcok need call concrete domain rule rule application 
rule simply takes care similar nodes label possibly block blocked nodes added 
rule removes surplus successor node 
subtree removed successor new additional root nodes 
behavior reason completion forest 
rule removes nodes edges yield new root nodes 
previous section tableau algorithm stops applying rules finds obvious contradiction clash completion rules applicable 
definition clash 
completion system va vc 
said contain clash conditions applies cy blocked blocked blocked successor create new node sa set blocked successors 
tn ti ti tj create new nodes 
tn ti sa set ti ti nsc blocked successors 
tn ti choose ti tj set ti ti tj remove tj incoming outgoing edges 
gn blocked gi successors xi 
xn add gi successor yi gi successor add 
yn update blocked successor blocked trans successor rch successor gi successors xi 
gn keyfor blocked blocked set completion rules shoqk 
concept name nc node va conjunction ind xn 
xn cy satisfiable va va successor 
completion system containing clash called clash free 
completion system complete contains clash completion rules applicable 
due simplicity algorithm refrain describing pseudo code notation algorithm starts initial completion system repeatedly applies completion rules 
clash detected returns unsatisfiable 
complete clash free completion system algorithm returns satisfiable 
note completion rules non deterministic algorithm non deterministic 
ready proving termination soundness completeness tableau algorithm starting termination 
denote cl 
recall number polynomial size lemma termination 
started shoqk concept nnf role box path free key box nnf tableau algorithm terminates 
proof 
assume tableau algorithm terminate 
means infinite sequence 
completion systems initial completion system sd si result applying completion rule si 
possible rules applied infinitely easily seen rules rch applied finitely completion systems set nodes va increase add concepts node labels size bound add concrete nodes number bound linearly number nodes remove nodes tree 
sub sequence si si 
sij result applying rule sij 
si node rule applied si 
sk implies generated sk number successor nodes node bound find sub sequence sj sj 
satisfying sjk sjk lj labeling function sj 
node labeled subset lj cl nodes sjk sj sjk lj sj 
node labels increase node removed label conjoined label node node completion system sj sj lj sj lj 
definition sj blocked sj contradicting assumption rule applied sj sj lemma soundness 
expansion rules applied shoqk concept nnf role box path free key box yield complete clash free completion forest tableau proof 
va vc complete clash free completion system 
clash freeness implies existence solution concrete predicates satisfying iff definition 
define finite tableau sa sc follows sa va occurs blocked sc sa cl successor blocks successor successor undefined successor restriction sc 
remains show satisfies basically consequence clash free complete 
satisfied contain clash 
satisfied rule applied implies 
satisfied rule applied implies 
consider sa implies blocks successor definition successor blocks successor 

successor blocked implies rule applied 
blocks successor blocked fact rule applied yields blocking condition implies 
cases 
satisfied reasons replaced 
consider 
completeness implies existence successors 
tn ti ti tj implies existence ti ki nrc kj tj ki kj 
satisfied remains verify ti block tj case blocking condition imply ki nrc ti 
kj block ti tj similarly implies ki nrc 
kj case clash contradiction clash free 
consider 
rule applied successors ti ti blocked blocked exactly node ui sa ui ui 

blocks successor case non applicability rch rule implies 
second case successor blocked blocking condition yields 
cases implies 
consider 
gn keyfor gi defined gi successor blocked non applicability rch imply 
consider 
definition totality implies assume loss generality non applicability rule implies blocked implies satisfied rule applied 
clash freeness implies satisfiability xn 
xn 
choice iff satisfied 

gn keyfor gi gi choice xi yi gi xi yi 
loss generality assume non applicability rule implies blocked implies satisfied definition contain clash 
lemma completeness 
shoqk concept nnf tableau expansion rules applied yield complete clash free completion forest 
proof 
tableau sa sc steer non deterministic rules rch way rule application preserves clash freeness 
termination lemma finishes proof 
inductively generation new nodes define mapping nodes completion tree individuals tableau concrete values way cl sa successor successor 
mapping satisfying conditions called correct 
due property encounter clash 
third property ensure clash occur 
clash occur due property 
third property ensure clash occur 
total mapping inductively defined follows solution equation 
choose node set root node completion tree 
obviously correct 
show completion rule applied way correct extended correct mapping 
application rule preserves correctness due 
due rule applied correctness preserved 
rule adds new node correctness implies implies existence sa 
extending obviously yields correct mapping 
rule adds nodes ti correctness implies implies existence 
tn sa ti tj ti ti 
extending ti ti obviously yields correct mapping 
assume rule applicable node successors ti ti 
correctness implies ti ti 
ti tj 
correctness implies ti tj loss generality assume ti tj 
applying rule merging tj ti preserves correctness 
rule extended similar way new gi successor xi added extending xi gi yields correct 
rule need extended definition successors imply correctness preserved 
rule similar difference takes place 
due rule rch applied violating correctness 
consider reasons applicable 
correctness imply 

gn keyfor gi xi yi xi yi correctness implies gi gi property correctness imply 
cases applying preserves correctness 
immediate consequence lemmas tableau algorithm terminates answers satisfiable input concept satisfiable input role box input key box concept satisfiability tboxes reduced concept satisfiability tboxes obtain result theorem 
tableau algorithm decides satisfiability shoqk concepts tboxes role boxes path free key boxes 
concept subsumption reduced concept un satisfiability algorithm decide subsumption shoqk concepts tboxes role boxes path free key boxes 
hard see proof lemma lemmas yield bounded model property shoqk shoqk concept satisfiable role box path free key box lemma implies tableau algorithm constructs complete clash free completion forest definition blocking number nodes completion forest blocked bounded cl polynomial size va nodes completion forest blocks blocks blocked node easily seen number concrete successors node bounded number concrete features proof lemma nodes tableau constructed complete clash free completion forest coincide nodes blocked completion forest 
proof lemma interpretation domain model constructed tableau coincides nodes tableau 
summing shoqk concept satisfiable model size cl 
guessing interpretation nodes checking model alternative algorithm deciding satisfiability shoq concepts role boxes key boxes 
algorithm clearly implemented nexptime theorem implies tight complexity bound 
theorem 
satisfiability shoqk concepts tboxes role boxes path free key boxes nexptime complete 
standard reduction concept subsumption concept un satisfiability vice versa obtain nexptime completeness shoqk concept subsumption tboxes role boxes path free key boxes 
identified key constraints interesting extension description logics concrete domains 
starting observation introduced number natural description logics provided comprehensive analysis decidability complexity reasoning 
main observation investigations key boxes may dramatic consequences complexity reasoning example pspace complete dl alc nexptime complete extended boolean key boxes undecidable extended general key boxes 
various properties concrete domains key boxes imply decidability alc shoq key boxes satisfying property 
selected alc shoq basis analysis opinion fundamental description logics concrete domains 
going step interesting combine key boxes extensions concrete domains ones 
name possibility extension alcok shoq inverse roles natural idea 
note inverse roles interact available means expressivity alc inverse roles pspace complete inverse roles exptime complete alc inverse roles 
options research closely related material 
example shoqk concept satisfiability decidable drop requirement key boxes path free 
know time complexity tableau algorithm shoqk concept satisfiability 
runs non deterministic exponential time directly yield theorem bounded model property 
blackburn marx 
road map complexity hybrid logics 
flum rodr guez artalejo editors computer science logic number lecture notes computer science pages 
springer verlag 
baader 
logic knowledge representation 
wooldridge veloso editors artificial intelligence today trends developments number lecture notes computer science pages 
springer verlag 
baader hanschke 
scheme integrating concrete domains concept languages 
proceedings twelfth international joint conference artificial intelligence ijcai pages sydney australia 
baader hanschke 
scheme integrating concrete domains concept languages 
dfki research report rr german research center artificial intelligence dfki 
baader hanschke 
extensions concept languages mechanical engineering application 
proceedings th german ai conference volume lecture notes computer science pages 
springer verlag 
baader horrocks sattler 
description logics semantic web 
ki nstliche intelligenz 
appear 
baader lutz sturm wolter 
fusions description logics description systems 
journal artificial intelligence research jair 
baader nardi patel schneider 
description logic handbook theory implementation applications 
cambridge university press 
appear 
baader sattler 
description logics concrete domains aggregation 
prade editor proceedings thirteenth european conference artificial intelligence ecai pages 
john wiley sons 
baader sattler 
tableau algorithms description logics 
dyckhoff editor proceedings international conference automated reasoning tableaux related methods tableaux volume lecture notes artificial intelligence pages 
springer verlag 
berger 
undecidability problem 
memoirs american mathematical society 
berners lee hendler lassila 
semantic web 
scientific american 
rger gr del gurevich 
classical decision problem 
perspectives mathematical logic 
springer verlag 
borgida patel schneider 
semantics complete algorithm subsumption classic description logic 
journal artificial intelligence research pages 
borgida 
adding uniqueness constraints description logics preliminary report 
bry ramakrishnan ramamohanarao editors proceedings th international conference deductive object oriented databases dood volume lncs pages 
springer 
calvanese de giacomo lenzerini 
decidability query containment constraints 
proceedings th acm sigact sigmod sigart symposium principles database systems pods pages 
calvanese de giacomo lenzerini 
keys free description logics 
baader sattler editors proceedings international workshop description logics dl number ceur ws org pages 
calvanese lenzerini nardi 
description logics conceptual data modeling 
chomicki saake editors logics databases information systems pages 
kluwer academic publisher 
dean connolly van harmelen hendler horrocks mcguinness patel schneider stein 
web ontology language owl version 
working draft 
fensel van harmelen horrocks mcguinness patel schneider 
oil ontology infrastructure semantic web 
ieee intelligent systems 
graham knuth patashnik 
concrete mathematics 
addison wesley publ 
reading massachussetts 
haarslev lutz ller 
foundations spatioterminological reasoning description logics 
cohn schubert shapiro editors proceedings sixth international conference principles knowledge representation reasoning kr pages 
morgan kaufman 
haarslev ller 
racer system description 
gor nipkow editors proceedings international joint conference automated reasoning number lecture notes artifical intelligence pages 
springer verlag 
haarslev ller wessel 
description logic alcn extended concrete domains practically motivated approach 
gor nipkow editors proceedings international joint conference automated reasoning number lecture notes artifical intelligence pages 
springer verlag 
halpern moses 
guide completeness complexity modal logics knowledge belief 
artificial intelligence 
hollunder baader 
qualifying number restrictions concept languages 
proceedings second international conference principles knowledge representation reasoning kr pages boston ma usa 
hopcroft ullman 
automata theory languages computation 
addison wesley 
horrocks 
expressive description logic fact fiction 
proceedings sixth international conference principles knowledge representation reasoning kr pages 
horrocks 
reasoning expressive description logics theory practice 
voronkov editor proceedings th international conference automated deduction cade number lecture notes artificial intelligence pages 
springer 
horrocks patel schneider van harmelen 
reviewing design daml oil ontology language semantic web 
proceedings th national conference artificial intelligence aaai 
horrocks sattler 
ontology reasoning shoq description logic 
nebel editor proceedings seventeenth international joint conference artificial intelligence ijcai pages 
morgan kaufmann 
horrocks sattler tobies 
practical reasoning expressive description logics 
ganzinger mcallester voronkov editors proceedings th international conference logic programming automated reasoning lpar number lecture notes artificial intelligence pages 
springer verlag 
horrocks sattler tobies 
practical reasoning expressive description logics 
logic journal igpl 
kamp wache 
ctl description logic expressive concrete domains 
technical report laboratory artificial intelligence hamburg germany 
toman 
decidability complexity description logics uniqueness constraints 
den bussche vianu editors proceedings th international conference database theory icdt volume lncs pages 
springer 
knuth 
art computer programming volume 
addison wesley 
lutz 
complexity reasoning concrete domains 
phd thesis theoretical computer science rwth aachen germany 
lutz 
description logics concrete domains survey 
advances modal logics 
lutz 
nexptime complete description logics concrete domains 
acm transactions computational logic 
appear 
lutz 
pspace reasoning description logic 
logic journal igpl 
lutz 
reasoning entity relationship diagrams complex attribute dependencies 
horrocks tessaris editors proceedings international workshop description logics dl number ceur ws ceur ws org pages 
pan horrocks 
reasoning shoq dn description logic 
horrocks tessaris editors proceedings international workshop description logics dl number ceur ws ceur ws org pages 
post 
variant recursively unsolvable problem 
bulletin american mathematical society 
schild 
correspondence theory terminological logics preliminary report 
mylopoulos reiter editors proceedings twelfth international joint conference artificial intelligence ijcai pages 
morgan kaufmann 

