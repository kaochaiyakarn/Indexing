software practice experience vol 
june debugging dynamic slicing backtracking agrawal bellcore south street morristown nj richard demillo eugene spafford software engineering research center purdue university lafayette summary programmers spend considerable time debugging code 
symbolic debuggers provide help task remains complex difficult 
breakpoints tracing tools provide little high level help 
programmers perform tasks manually tools perform automatically finding statements program affect value output variable test case value variable control reached program location 
debugging tools provided explicit support tasks debugging process automated significant extent 
debugging model dynamic program slicing execution backtracking techniques easily lends automation 
model experience techniques debug software 
prototype debugging tool spyder explicitly supports proposed model performing debugging research 
key words program debugging execution backtracking reverse program execution program slicing dynamic program slicing 
importance debugging tools 
average programmers may spend considerable amounts program development time debugging 
tools available help task varying hexadecimal dumps program state time failure window interactive debuggers bit mapped displays 
interactive debuggers provide breakpoints traces facilities examine program state main debugging aids 
unfortunately traditional mechanisms inadequate task quickly isolating specific program faults 
approach address problem provide users control actions may take breakpoint reached provide explicit mechanisms construct high level abstractions correlating low level events 
propose different approach new received may john wiley sons revised december agrawal demillo spafford debugging model 
importance model lies fact step largely automated removing tedium debugging process 
provides systematic approach debugging attempting introduce element science largely considered art 
debug 
program failed produce desired output go finding went wrong 
program source important information usually available programmer input data erroneous output produced program 
program sufficiently simple analyzed manually output 
large programs analysis difficult perform 
logical way proceed situations think backwards deduce conditions program produces incorrect output 
consider example program main window panel ignore fact lines program highlighted 
program computes sum areas triangles 
reads value followed lengths sides triangles 
values classifies triangle equilateral isosceles right scalene triangle 
computes area appropriate formula 
program prints sum areas 
bug displayed program assignment line mistakenly computes sqr sides sides sides sides suppose program executed test case sides triangles respectively 
sum areas triangles test case incorrectly printed implying presence fault program 
go locating bug 
looking backwards printf statement line find sum updated properly formulas computing area triangle incorrect triangle classified incorrectly values sides triangle read correctly 
statement line adds area sum thing may want examine program state point 
set breakpoint line re execute program statement examine values variables sum area point 
suppose find area computed correctly loop iteration computed incorrectly second iteration 
discover may wish examine values class second triangle determine formula computing area 
discover class incorrect examine values sides triangle check read correctly 
examine statements lines determine class triangle 
distinct tasks repeatedly performed analysis figures window system window dumps prototype debugging tool spyder operation 
test case consists specific set run time input values 
refer test case test case sections 
debugging dynamic slicing backtracking 
dynamic program slice respect area line second loop iteration test case agrawal demillo spafford 
determine statements code influence value variable observed location 

select statements examine program state 

recreate program state selected statement examine specific variables 
example performed tasks examining code assistance debugger 
third task set breakpoint re execute code control stopped breakpoint 
debugging job easier debugger provided direct assistance performing tasks 
explicit support activities easily able pursue software debugging systematic fashion 
built prototype debugger named spyder provides user exactly assistance 
task variable program location determining statements program affected value variable location program executed test case referred dynamic program slicing 
spyder find dynamic slices automatically 
restore program state desired location backtracking program execution having re execute program 
discuss functions slicing backtracking combined prototype debugging tool 
depicts proposed debugging model 
may thought 
debugging model debugging dynamic slicing backtracking specialization general model debugging process proposed araki furukawa cheng 
step model detection program failure translate external symptoms program failure corresponding internal symptoms terms data control problems program 
internal symptoms selected slicing criterion corresponding dynamic slice obtained 
examining slice statement selected examine program state program state restored state control reached statement 
examining values variables restored state may reveal fault 
user may choose examine restored state guess new fault select new slicing criterion repeat cycle fault localized 
section examine various notions dynamic slices show spyder supports 
section discuss execution backtracking facility spyder 
section example debugging session spyder slicing backtracking facilities 
section briefly discuss implementation issues 
section concludes discussion limitations techniques described outlining lessons learned experience 

dynamic slicing concept program slicing proposed weiser 
original notion program slice envisioned static slice obtained irrespective values input variables 
static program slice respect variable occurrence evaluates variable occurence identically original program executed test case 
weiser algorithm compute static slices iterative solution data flow equations 
ottenstein ottenstein algorithm find static program slices graph reachability program dependence graph considered intra procedural case 
horwitz reps proposed extending program dependence graph representation call system dependence graph find interprocedural static slices graph reachability framework 
carr defined information flow relations somewhat similar data control dependence relations obtain static program slices referred partial statements 
studies investigating semantic basis program slicing reported 
uses program slicing suggested applications program verification maintenance automatic parallelization program execution automatic integration program versions software metrics primarily concerned debugging 
debugging value variable var program statement observed incorrect 
static program slice respect var identifies relevant subset program examine determine cause error 
mentioned earlier static notion program slice input values reveal error 
concerned finding statements affect value variable occurrence input statements affect value specific input 
debugging programmers generally analyse program behavior test case revealed agrawal demillo spafford error generic test case 
concrete test case exercises bug helps focus attention cross section program contains fault korel laski extended static notion program slice dynamic case takes consideration test case reveals fault 
define dynamic slice respect variable occurrence test case subset program evaluates variable occurrence identically original program executed test case 
unfortunately requirement dynamic slice executable test case may cause statements really affect value variable occurrence question included dynamic slice 
extra statements included solely purpose making dynamic slice executable may add considerable noise cases may larger statements really needed simple dynamic slice 
believe debugging perspective value dynamic slice lies fact execute fact isolates statements affect value particular variable particular program location 
example program loop iteration computes value variable area 
note computation area iteration totally independent computation performed iteration 
value area incorrect obtain dynamic slice respect area iteration statements included slice affected value iteration previous iterations 
hand find value variable sum incorrect iteration obtain corresponding dynamic slice want see statements affected iteration affected previous iterations 
value area value sum iteration affected computations performed previous iterations 
korel laski definition dynamic slice fails important distinction 
agrawal horgan independently proposed notion dynamic slice mentioned behavior 
example shows dynamic slice respect area second loop iteration test case definition 
note statements affect area second triangle included slice 
korel laski definition hand required statements lines affect area triangle included slice way affect area second triangle 
dynamic program slice presents summary computation simply showing relevant statements involved 
underlying reasons selecting statements apparent looking slice 
fact large programs looking complete program slice may overwhelming 
knowing analysis performed arrive program slice say slice contains fault necessarily mean fault textually contained slice fault correspond absence slice missing statement statement outside slice inside discover missing slice slice 
debugging dynamic slicing backtracking crucial determining fault 
prototype tool spyder lets see global view relevant computation terms dynamic program slice lets obtain various local views terms data control slices finer views terms reaching definitions controlling predicates 
local views enable see rationale arriving global view 
remainder section derives notion dynamic program slice bottom manner shows spyder provides explicit support derivation visible 
analysis useful understanding purpose usefulness various functions provided spyder 

local analysis program fault usually manifests directly indirectly ways case 
value expression exp program location observed incorrect 
case 
control incorrectly reached location reached 
case 
control reach desired location examine cases detail 
case value exp location incorrect possibilities 
function computed exp incorrect exp determined localized fault 

value variable var exp incorrect value expression incorrect value incorrect 
case find statement assigned value var find dynamic reaching definition note may static reaching definitions exp corresponding dynamic reaching definition having unique reaching definition erroneous variable var atl possibilities 
value expression exp computed incorrect 
case back case respect value exp computed 
wrong reaching definition var 
case possibilities 
control reached case back case respect location 
correct definition var missing missing assignment var path var composite variable array record find reaching definition scalar component var wrong value 
agrawal demillo spafford assignments path incorrectly assigned value wrong variable 
determined localized fault 

control correctly reached reach correct definition var took wrong path case back case respect location 

included program 
case discovered extraneous assignment localized fault 
case control reached location possibilities immediately enclosed predicate pred predicate enclosing 
immediately enclosed predicate pred predicate 
possibilities 
control reached pred 
back case respect location pred 

control reached pred case possibilities 
pred evaluated incorrectly case back case respect value pred 

missing predicate path pred localized fault 

enclosed predicate 
control reached enclosed predicate prevented control reaching 
means missing predicate enclosing case localized fault 
case control reach desired location immediately enclosed predicate pred prevented control reaching possibilities case 
control reach pred 
case back case respect location pred 

control correctly reached pred case pred evaluated incorrectly back case respect value pred 

pred included program 
extraneous predicate case localized fault 
missing goto 
simplicity analysis assume program unconditional flow operations 
debugging dynamic slicing backtracking 
global analysis large programs step step analysis may tedious perform 
fault far removed location manifests may take long time find fault 
notice analysis need recursively follow cases 
basis situations imply completion inductive search 
assignment statement compute incorrect function 

predicate expression compute incorrect function 

assignment statement assign value wrong variable 

desired assignment variable missing 

desired predicate expression guarding statement missing 

extraneous assignment program 

extraneous predicate program 
inductive steps require recursive applications cases 
find dynamic reaching definition variable location 

find predicate immediately encloses location 
fault localization may expedited analysis combine successive recursive steps 
mind revisit cases discussed 
case revisited value expression exp location incorrect possibilities 
exists incorrect assignment wrong value computed propagated value exp transitive closure reaching definitions 

assignment computation propagated value exp got executed 

assignment computation propagated value exp missing program 

assignment computation propagate value exp included program 

assignment computation propagates value exp got executed incorrect number times necessary 
case revisited control incorrectly reached location possibilities 
predicates enclosing location evaluated incorrectly 

missing predicate enclose location necessarily enclosing immediately may missing outside nesting level 
agrawal demillo spafford case revisited control reach location possibilities 
predicates enclosing evaluated incorrectly 

predicates enclosing included program 
dynamic data slice case global analysis need find assignments computations propagated current value exp done transitive closure dynamic reaching definitions variables exp location 
call set assignments belong closure dynamic data slice respect expression location test case 
know current value exp incorrect examining dynamic data slice find assignment missing program assignments computes incorrect function 
similarly examining dynamic data slice check assignments slice vice versa 
case missing incorrect assignment localized fault 
case wrong assignment reached correct assignment reached step closer finding fault continue search cases global analysis respect new location 
hand examining data slice suggest cases indicates error caused assignment data slice executed incorrect number times 
fault lies execution frequency assignment assignment 
means loop predicates enclosing assignments data slice faulty 
resort local analysis described localize faults 
shows dynamic data slice respect sum line test case 
note assignment line computes area right triangle data slice triangles test case right triangles 
suggests pursue case respect line 
dynamic control slice cases global analysis need find predicates enclose location 
done transitive closure enclosing predicates starting location 
call set predicates belong closure dynamic control slice respect location 
know control incorrectly reached location examine control slice check relevant predicate missing predicates evaluated incorrectly 
case localized fault 
case step closer finding fault predicate incorrectly computes incorrect function arguments function wrong value 
case fault case continue search case global analysis respect incorrect argument 
debugging dynamic slicing backtracking 
dynamic data slice respect sum line test case example consider program 
executed test case find second loop iteration control incorrectly reaches statement line 
corresponding control slice contains predicates lines 
examining slice reveals statement incorrectly reached second predicate evaluates incorrectly agrawal demillo spafford evaluates true false value class examined predicate incorrect instance 
suggests pursue case respect class line 
dynamic program slice note global analysis discussed alternate data control slices localized fault 
fault manifests levels indirection away fault 
situations may possible localize fault quickly knew sum relevant data control slices 
give set statements assignments predicates effect variable location question 
find value expression location incorrect find dynamic data slice 
assignment data slice find dynamic control slice 
predicate control slice find dynamic data slice reach situation new statements added set 
call set statements obtained dynamic program slice respect expression location test case 
similarly find control reached location reach desired location repeat analysis time starting control slice relevant location 
call resulting set dynamic program slice respect location 
dynamic program slice closure data control slices respect expressions locations constituent dynamic data control slices 
described earlier shows dynamic program slice respect area line execution stopped second loop iteration test case 
note erroneous assignment line included slice 
note assignment line computes area triangle included slice computation area loop iteration affect iteration case 
obtained dynamic program slice respect sum line assignments lines included slice computation area iteration affects final value sum 
discussion suggests depending size complexity program extent person debugging program familiar program code may efficient perform local step step analysis times examining data control program slice may expedite fault localization 
spyder provides mechanisms allow local global dynamic analysis performed 
program written usually run input data sets designed test specific aspects program behavior 
program works correctly test case fails may helpful analyze program behavior test cases 
inclusion exclusion statement dynamic slices respect test cases may provide valuable debugging clues 
idea may generalized examining dynamic program behavior test cases 
spyder allows user save test cases select test case dynamic analysis time 
currently building experimental version spyder debugging dynamic slicing backtracking supports facilities show differences dynamic slices respect test cases 
version provides support dynamic analogue static program dicing technique proposed 
dynamic program slice uses fact value variable program location incorrect test case narrow search fault 
information value variable location may correct test case 
dynamic program dice attempts narrow search fault removing statements belong dynamic slice respect correct variable belong dynamic slice respect incorrect variable 
experimental version provides facilities save currently displayed slice obtain slice perform operations difference intersection saved slice 
results operations displayed aid narrowing search program faults 
effect give user ability obtain dynamic program 
interested reader referred details extensions program dicing approach 

execution backtracking described earlier section obtained dynamic slice respect erroneous variable location able identify fault choose statements slice examine program state 
case debugging conventional debugger need set breakpoint selected statement re execute program 
execution suspended breakpoint program state examined 
examining variable values may discover error occurred earlier location 
may decide set breakpoint earlier statement restart program execution 
may need repeat process setting breakpoints backward order program times able localize fault 
large programs repeated program execution may cumbersome 
spyder provides execution backtracking facility program state restored earlier location having re execute entire program 
just forward program execution suspended breakpoint encountered spyder execute program reverse direction continue executing backwards breakpoint reached 
way stopped breakpoint wish examine program state earlier location simply need set breakpoint execute backwards 
backward execution stops breakpoint spyder restored program state execution reached point forward execution 
example consider program test case 
program execution stopped line discover value sum incorrect may set breakpoint line start backward execution 
loop iterated twice test case second iteration reached backward execution 
execution stops line program state exactly execution stopped forward execution 
examine value sum get value agrawal demillo spafford 
tool screen backtracking line line just assignment executed shown 
notice value sum backup command displayed bottom output window 
find previous value sum correct may conclude current value area incorrect 
wanted backup location previous iteration simply need continue debugging dynamic slicing backtracking backward execution 
breakpoint encountered iteration backward execution suspended reaches breakpoint line previous iteration 
debuggers provide facilities user step forward program execution line time 
debugging described earlier think backwards location fault manifested helpful debugger lets user step back program execution statement statement 
spyder provides back stepping facility 
execution stopped breakpoint issuing step back command undoes effect statement executed execution backtracking easily implemented tool mechanisms dynamic slicing 
recording execution path program enable dynamic slicing discuss section spyder records previous values variables modified statement 
backtracking statement simply requires restoring previously saved values variables modified statement 
spyder currently support restoration activation records completed procedure calls 
allow backtracking procedure outside 
may serious problem backtrack completely procedure call forward execute desired location 
execution backtracking approach similar execution replay facility interactive debugging tool fortran developed late 
system complete history tape program debugged test case saved 
program executed playback tape 
point program execution backtracked earlier location information saved history tape 
approach control stopped program location possible change values variables executing forward simply replays program behavior recorded earlier 
miller choi ppd performs flow back analysis uses notion incremental tracing 
approach saving values changed variables statement level saved start program segments called emulation blocks 
debugging finer traces execution emulation blocks obtained demand corresponding blocks values variables saved start blocks 
approach implicitly assumes memory location referenced value expression change program execution block 
presence pointer variables dynamic memory allocations assumption may hold true 
approach may situations 
wilson moher memory approach involves hierarchical checkpointing allow regeneration program history multiple levels resolution 
miller choi approach relies static analysis determine variables may changed execution approach relies dynamic detection changes process memory 
able handle pointers spyder indicates statement executed arrow left margin code window 
see 
agrawal demillo spafford dynamic memory allocations approach 
clear suitable context fine grained backtracking required support features reverse single stepping facility described 
alternatively possible structured backtracking approach described 
approach provides user capabilities requires storage 
additionally storage requirements may bounded compile time cases 
structured backtracking example able backtrack second iteration loop 
backtrack loop execute forwards statement 
may implemented manner transparent user 
approaches backtracking proposed different contexts 
zelkowitz incorporated backtracking facility programming language pl adding retrace statement language 
approach provide interactive control backtracking debugging 
interlisp cornell program synthesizer provide facilities undo operations 
systems maintain fixed length history side effects caused operations 
new events occur existing events list aged oldest events forgotten 
backtracking locations arbitrarily far back execution may possible systems 
igor cope provide execution backtracking performing periodic checkpointing memory pages file blocks respectively modified program execution 
approach suitable undoing effects complete programs may inefficient support backtracking 

example debugging session spyder illustrate usage spyder proposed model presenting small debugging session 
program test case sides triangles respectively discussion 
program executed test case final value sum printed correct value area triangle second 
enable exact dynamic analysis clicking toggle button labeled exact dynamic analysis set breakpoint line run program test case 
execution stops breakpoint select variable sum mouse print value clicking print button 
incorrect value printed 
click reaching defs button find definition sum find assignment line assigned value sum 
set breakpoint line click backup button restore program state just assignment line executed 
print spyder provides support obtain static approximate dynamic slices 
approximate dynamic slices computationally expensive obtain compared exact dynamic slices may contain extraneous statements really affect value variable question 
interested reader referred detailed discussion various approaches computing exact approximate dynamic slices relative trade offs involved 
represented little sign 
see 
debugging dynamic slicing backtracking value sum location find correct value point printed 
far sum contains area computed previous iteration 
implies area correctly computed triangle wrong second triangle 
print current value area find incorrect 
click program slice button obtain dynamic program slice current value area shown 
surprise find assignment line computes area right triangle belongs slice line computes area scalene triangle 
find assignment line assigns right class slice 
check values sides triangle read correctly print sides find current values sides triangle correct 
looking program slice notice statement line determines triangle right triangle sets value class accordingly 
set breakpoint line backup execution point 
print values sqr sqr sqr find value sqr printed incorrectly 
examining data slice sqr reveals error line 

implementation comprised modified version gcc gnu compiler gdb gnu source level debugger 
chose gnu tools easy availability ability run different hardware platforms 
choice led problems see section allowed rapidly develop prototype experiment techniques described earlier 
gives high level view structure spyder shows modified gnu tools fit 
subsections briefly discuss changes tools changes help spyder provide functions 

high level view structure spyder agrawal demillo spafford 
modifications compiler modified gcc produce program dependence graph object code program 
simply required making changes parser 
modified parser apart normal functions builds control flow graph program syntax directed manner 
node graph annotated def sets terms valued expressions defined respectively node 
expressions debugger determine actual memory cells defined corresponding node execution see subsection 
parsing complete flow graph traversed compute data control dependencies nodes sets edges belonging data control dependence graphs respectively created 
graphs flow graph data dependence graph control dependence graph share nodes edges 
aggregate graph consisting graphs written file 
read debugger determine static slices 
reader referred details algorithms compute data control dependencies 

modifications debugger gdb modified read aggregate graph consisting flow control data dependence subgraphs produced modified gcc 
code added traverse aggregate graph find static reaching definitions static data control program slices 
support dynamic slicing execution backtracking gdb modified record execution history program executes 
execution history consists list nodes aggregate graph appended order visited program execution 
entry list constitutes node dynamic dependence graph 
node annotated dynamic def sets 
sets saved terms memory cells length tuples defined respectively node 
start addresses memory cells obtained evaluating addresses expressions constitute def sets node 
valued expressions mentioned earlier determined compiler parsing available debugger form annotations nodes program dependence graph 
lengths memory cells easily determined types expressions 
enable execution backtracking debugger reads contents def memory cells node saves node dynamic dependence graph 
modified gdb captures information setting numerous transparent breakpoints program user see 
associates callback functions transparent breakpoints perform recording execution history determining starting memory addresses def memory cells saving contents def memory cells 
gdb provides facility lets associate callback list debug commands breakpoint 
extended facility addition debug commands arbitrary functions may included callback list 
program execution transparent breakpoint reached execution interrupted control debugging dynamic slicing backtracking transferred debugger 
debugger invokes callback functions associated breakpoint turn update execution history record memory cells defined node save contents def memory cells 
callback functions associated transparent breakpoint performed program execution resumed 
program execution normally stops user defined breakpoint opposed transparent breakpoint described reached dynamic data control dependence edges nodes added execution history normal determined added dynamic dependence graph 
updated dynamic dependence graph may traversed find dynamic reaching definitions dynamic data control program slices 
reader referred details algorithms compute data control dependencies 
main benefits making def sets consist memory cells start address length tuples enables perform precise analysis presence pointers dynamic memory allocations 
presence program dependencies hard visualize manual examination program text 
main difficulty static analysis presence indirect pointer memory location referenced expression may vary course program execution scalar variable fixed 
difficulty compounded language strongly typed permits integer arithmetic pointer variables programming language case analyze program statically forced conservative assumption indirect assignment pointer potentially define variable 
outcome assumption static slices programs involving pointers tend large instances include program 
hand approach defining dynamic def sets terms start address length tuples memory cells enables perform precise dynamic analysis presence unconstrained pointers 
usual problems associated static analysis presence pointers detection aliases automatically taken care approach ambiguity determining memory cells overlap 
example consider simple program 
initializes elements array prompts user values increments ith jth kth elements array prints new values elements 
pointer variables point ith jth kth elements array respectively 
consider test case program executed input values 
shows dynamic slice respect line test case 
indirect assignments lines included dynamic slice values test case making aliases array element 
corresponding static slice contains entire program 
shows variant program loop initialize array having separate assignment array element 
execute program test case get output 
printing value prints 
implies value got corrupted agrawal demillo spafford 
dynamic slice respect line program execution 
obtained dynamic slice line expect line slice place program modified 
find loop lines included dynamic slice shown 
suggests variable clobbered execution loop 
examination reveals fault lies loop predicate iterates times array declared elements long 
alternatively implies fault lies array declaration declared elements long 
shows memory allocation compiler variables contents program execution test case note memory location corresponds overlaps 
precise dynamic analysis enabled approach invaluable revealing subtle faults 
approach enables precise interprocedural dynamic slices obtained 
consider example program 
program segment code determines class triangle moved procedure called find class 
shows dynamic program slice respect area line second loop iteration main program test case sides triangles 
approach resolving def sets statements terms memory cells implies need determine memory allocation vary compiler compiler 
debugging dynamic slicing backtracking 
dynamic slice respect line global variables referenced inside procedure parameters may aliases global variables need eliminate name conflicts variables different procedures 
approach enables easily implement execution backtracking 
recording def memory cells nodes execution history forward execution detailed earlier previous contents def cells saved modified 
backtrack execution saved contents def cells restored corresponding memory locations traversing execution history backwards 
addresses memory locations restored obtained corresponding memory cells 
backwards traversal restoration saved values continues user defined breakpoint encountered execution history reached 
case execution history truncated breakpoint location case reinitialized empty 
note segments execution history may correspond execution inside procedures 
def sets nodes segments may contain memory cells belonged activation records old procedure cells longer accessible 
contents memory cells restored backtracking indicated earlier spyder currently support backtracking procedure outside 
example program spyder allow backtracking statement line line 
may agrawal demillo spafford 
storage layout program program execution test case backtrack line line procedure call line resume forward execution procedure call statement 
major change gdb provide window mouse user interface slices displayed highlighting corresponding source lines 
added hooks system traditional debugging functions supported spyder setting breakpoints performed simply selecting appropriate text source window mouse clicking appropriate command buttons 
intention simply show slicing backtracking usefully combined standard debugging functions breakpoints single stepping examining values included common debugging functions windowed interface provide hooks function gdb supports 
interface written athena widget set xt toolkit window system version release 
concluding remarks debugging complex difficult activity 
person debugging program determine cause location program failure 
failure may manifested far fault textually terms source lines temporally terms execution time 
providing facilities increase debugging dynamic slicing backtracking 
interprocedural dynamic program slice respect area line second loop iteration agrawal demillo spafford ability programmer identify location nature fault involved leads efficient debugging 
debugging model prototype tool attempts provide precisely facilities 
experience model tool far convinced quite useful applied properly result significant savings debugging time 
panacea 
provide useful mechanisms user employ effectively 
conclude discussion limitations techniques outlining lessons learned experience 
limitations model mentioned fault manifests directly indirectly terms data control discrepancy 
true requires programmer translate externally visible symptoms fault internal program symptom terms data control problem techniques described may 
translation may easy 
example external symptom value program output incorrect corresponding internal symptom value variable expression incorrect print statement may easily determined 
external symptom complex missing value list programmer may traditional debugging facilities find corresponding internal symptom techniques described may 
slices dependences multiple occurrences statement explicit 
example statement inside loop body included slice value computes iteration depends value computes previous iteration dependence explicit slice occurrences grouped displaying slice 
spyder attempts partially overcome problem providing local analysis facilities described earlier 
execution backtracking limitations 
backtracking statement requires side effects executing statement undone 
system undo things control 
executing statement effects outside boundaries program operating system outside agents affected cooperate debugging tool enable execution backtracking 
situations executing statement may effects outside controlling environment may feasible undo 
situations may accept partial backtracking resort program 
programmer techniques aware limitations 
limitations restrictive preclude techniques 
contrary experience shown despite limitations techniques extremely useful quickly isolating program faults 
limitations current implementation mentioned built prototype tool top existing computer debugger 
choice enabled quickly build working debugging dynamic slicing backtracking system experiment proposed techniques gain insight usefulness introduced limitations supported 
example gdb debugger know associate breakpoints expressions statements associate source lines 
transparent breakpoints capture information required dynamic slicing backtracking limitation requires correspondence smallest syntactic units slicing backtracking assignments predicates source lines 
current implementation requires source line contains assignment predicates assignments appear different lines 
easy provide preprocessor converts program canonical form acceptable tool 
limitation current implementation described permit backtracking procedure outside 
may noted limitations current implementation techniques 
arose largely compiler debugger originally written support techniques 
arise implemented context interpreter wrote compiler debugger 
lessons learned implementation question faced implementation effort modify compiler gcc produce instrumented code gathers run time information necessary dynamic slicing backtracking debugger gdb probe program execution collect information 
approaches advantages disadvantages 
decided approach believed easier implement experiment 
benefit approach delaying instrumentation probes debugging time possible interactively control parts program instrument instrument 
approach possible start instrumentation static slicing techniques narrow search extent possible relatively smaller region program 
successively increase program instrumentation approximate exact dynamic slicing techniques successively smaller smaller program regions 
way need pay cost associated instrumentation time 
debugged particular region procedure module program segment may possible instruct debugger region 
alternative approach hand require having pay cost instrumentation entire program execution require repeated recompilations program instrumentation 
consequence decision debugger perform instrumentation collect necessary run time information great deal time spent system context switching debugger processes 
processes heavyweight processes unix context switch process costly operation notice significant slow agrawal demillo spafford program execution long running programs constant context switching 
systems provide lightweight processes fast context switches overhead substantially smaller 
may approach discussed paragraph restrict context switching small regions program 
promising approach reduce context switching overhead debugger patch object code debugging process instructions necessary logging information required 
possible approach combined lightweight thread processes support fast debugger single thread programs 
intend examine approaches run experiments quantify compare relative overheads 
bob horgan venkatesh discussions ed help implementation ryan hsin pan nok anonymous referees comments earlier drafts 
research supported part software engineering research center purdue university national science foundation industry university cooperative research center nsf ecd national science foundation ccr 

agrawal eugene spafford bibliography debugging backtracking acm software engineering notes 

charles mcdowell david helmbold debugging concurrent programs acm computing surveys 

evan adams steven muchnick window symbolic debugger sun workstations software practice experience 

thomas pi case study object oriented programming oopsla conference proceedings portland oregon september 
acm press 
sigplan notices 

sdb symbolic debugger unix programmer manual 

bourne tutorial adb unix programmers manual 

kevin dunlap debugging dbx unix programmers manual supplementary documents berkeley software distribution computer science division university california berkeley california april 

ronald olsson richard crawford wilson ho christopher wee sequential debugging high level abstraction ieee software may pp 


jacob schwartz overview bugs randall ed debugging techniques large systems prentice hall englewood cliffs new jersey pp 


gould psychological evidence people debug computer programs international journal man machine studies 

understanding debugging programs international journal man machine studies 

agrawal joseph horgan dynamic program slicing proc 
sigplan conference programming language design implementation white plains new york june 
acm press 
sigplan notices 

agrawal richard demillo eugene spafford dynamic slicing presence unconstrained pointers proc 
fourth symposium testing analysis verification tav acm press october pp 


agrawal richard demillo eugene spafford execution backtracking approach program debugging ieee software may pp 

debugging dynamic slicing backtracking 
araki furukawa cheng general framework debugging ieee software may pp 


mark weiser programmers slices debugging communications acm 

mark weiser program slicing ieee trans 
software engineering se 

karl ottenstein linda ottenstein program dependence graph software development environment proc 
acm sigsoft sigplan symposium practical software development environments pittsburgh pennsylvania april acm press 
sigplan notices 

susan horwitz thomas reps david interprocedural slicing dependence graphs acm trans 
programming languages systems 

jean francois bernard carr information flow data flow analysis programs acm trans 
programming languages systems 

thomas reps yang semantics program slicing technical report tr computer science department university wisconsin madison wisconsin june 

robert cartwright matthias felleisen semantics program dependence proc 
acm sig plan conference programming language design implementation portland oregon june 
acm press 
sigplan notices 

rewriting semantics program dependence graphs conference record sixteenth acm symposium principles programming languages acm press january 

venkatesh semantic approach program slicing proc 
sigplan conference programming language design implementation toronto ontario canada june 
acm press 
sigplan notices 

susan horwitz jan prins thomas reps integrating noninterfering versions programs acm trans 
programming languages systems 

keith brian gallagher james lyle program slicing software maintenance ieee trans 
software engineering 

ott relationship slices module cohesion proc 
eleventh international conference software engineering ieee computer society press may 

ott smith relationship program complexity slice complexity debugging tasks proc 
compsac ieee computer society press 

bogdan korel janusz laski dynamic slicing computer programs systems software 

james lyle mark weiser automatic program bug location program slicing proc 
second international conference computers applications beijing china july 

agrawal automatic debugging computer programs ph thesis department computer sciences purdue university west lafayette 

hsin pan eugene spafford automatic localization software faults proc 
th pacific northwest software quality conference october pp 


balzer extendible debugging monitoring system afips proceedings spring joint computer conference vol afips press new jersey pp 


barton miller jong deok choi mechanism efficient debugging parallel programs proc 
sigplan conference programming language design implementation atlanta georgia june 
acm press 
sigplan notices 

paul wilson thomas moher memory process histories proc 
sigplan conference programming language design implementation portland oregon june 
acm press 
sigplan notices 

zelkowitz reversible execution diagnostic tool ph thesis dept computer science cornell university january 

warren teitelman interlisp manual fourth edition xerox palo alto research center palo alto california 

tim teitelbaum thomas reps cornell program synthesizer syntax directed programming environment communications acm 

stuart feldman brown igor system program debugging reversible execution proc 
workshop parallel distributed debugging madison wisconsin may 
acm press 
sigplan notices 
agrawal demillo spafford 
james archer jr richard conway fred schneider user recovery reversal interactive systems acm trans 
programming languages systems 

richard stallman porting gnu cc version free software foundation cambridge massachusetts january 

richard stallman gdb manual third edition version free software foundation cambridge massachusetts october 

jeanne ferrante karl ottenstein joe warren program dependence graph uses optimization acm trans 
programming languages systems 

edward compiler integrated software testing phd thesis department computer sciences purdue university west lafayette 

richard demillo edward aditya mathur compiler integrated program mutation proc 
fifteenth annual computer software applications conference compsac ieee computer society press september 
