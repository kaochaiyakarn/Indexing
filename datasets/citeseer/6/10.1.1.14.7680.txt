querying internet pier ryan huebsch joseph hellerstein nick lanham boon loo scott shenker ion stoica eecs computer science division uc berkeley cs berkeley edu huebsch db database research community scalable technologies 
database systems traditionally excel important scalability dimension degree distribution 
limitation hampered impact database technologies massively distributed systems internet 
initial design pier massively distributed query engine overlay networks intended bring database query processing facilities new widely distributed environments 
motivate need massively distributed queries argue relaxation certain traditional database research goals pursuit scalability widespread adoption 
simulation results showing pier gracefully running relational queries thousands machines show results software base actual deployment large experimental cluster 
database research community scalability technologies 
challenge supporting large data bases core community identity ongoing research scalability continuously moved field forward 
database systems excel important scalability dimension degree distribution 
key scalability metric global networked systems internet estimated nodes 
contrast largest database systems world scale nodes 
surprising lack scalability may help explain database community technology integral part fabric massively distributed systems internet 
pier stands peerto peer information exchange retrieval query engine comfortably scales thousands participating nodes 
pier built top distributed hash table permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings th vldb conference berlin germany international computer science institute shenker icsi berkeley edu dht peer peer inspired overlay network technology subject networking os communities 
simulation results showing pier gracefully running relational queries thousands machines initial empirical results software base actual deployment department largest active cluster computers 
agenda initial pier twofold 
show system pier presents technology push viable massively distributed query processing significantly larger scale previously demonstrated 
addition believe important viable application pull massive distribution querying internet data situ need database design maintenance integration 
team network database researchers believe need feasibility technology arenas network monitoring 
primary technical contributions architectural evaluative algorithmic 
argue certain standard database system design requirements best relaxed order achieve extreme scalability 
novel architecture traditional database query processing peer peer networking technologies provide detailed performance study demonstrating need feasibility design 
describe architecture tradeoffs raise number new research questions architectural algorithmic ripe exploration 
querying internet section motivating applications massively distributed database functionality extract design principles reusable system address applications 
applications design principles peer peer filesharing probably best known internet scale query application today today post napster post era tools truly run queries internet centralized servers 
reason particularly noble decentralized data spreads responsibility tracking copyright violation motivating situ processing file data metadata filenames sizes id tags wide distribution data comes massive deployment normal non expert users 
systems perfect useful widely 
sense echo rise web query functionality richer point point closer home database research 
believe natural legal applications situ distributed querying data generated standard way locations amenable centralized warehouse type solutions 
warehousing unattractive reasons 
warehouses best suited historical analysis applications prefer live data 
second warehouses expensive administer requiring data center sufficient storage bandwidth scale 
socio political concerns may discourage warehouses centralized control responsibility distributed query solutions available 
application category particular interest widespread network monitoring 
network protocols ip smtp tend standard data representations widespread server implementations plausibly participate wrapping data useful distributed query processing 
concrete example discuss problem network intrusion detection 
network behaviors categorized fingerprints may kinds data sequences port accesses detect port scanners port numbers packet contents buffer overrun attacks web robots application level information content email spam 
intrusion hard detect quickly comparing fingerprint experienced attacks 
believe standard network servers mail servers web servers remote shells applications mail clients calendar programs web browsers bundle fingerprint generating wrappers optionally participate distributed intrusion detection 
pier provides way flexibly scalably share query fingerprint information 
attacked node publish fingerprint attack pier distributed index persist period aging section 
determine threat level organizations periodically query system see fingerprints similar reports exist example order find compromised nodes network may useful multiple identify multiple kinds intrusions single domain identify unrestricted email gateways channel spam running subnet web robot may crawling email addresses select source robots general environment summary widespread attacks simple aggregation query single fingerprint table select fingerprint count cnt intrusions group fingerprint having cnt organizations may treat reporters useful reliable may want weigh results stored judgment reputations 
easily accomplished query select fingerprint count sum weight intrusions reputation address address group fingerprint having choose intrusion detection examples expect people willingly set servers opt communal system improve security analogous examples constructed standard network tools available today 
example network tools tcpdump generate traces packet headers supporting queries bandwidth utilization source port analysis packet headers arguably metadata intrusion detection tools snort take packet stream generate signatures described examining packet headers data payloads carry 
tools support queries deployment different software versions reports tcp implementations useful doing public health risk assessment treatment planning security holes identified certain software packages 
query applications outside networking plausible including resource discovery deep web crawling searching text search intend pier flexible framework wide variety applications especially experimental settings development tuning application specific system 
interested design utility general purpose system goal develop improve pier networking research 
relaxed design principles scaling notion database system carries number traditional assumptions significant insurmountable barriers massive distribution 
key scalability pier willingness relax adherence database tradition order overcome barriers 
discussion identify design principles guide attempt scale significantly relaxed consistency transactional consistency cornerstone database functionality conventional wisdom states acid transactions severely limit scalability availability distributed databases 
acid transactions certainly massively distributed systems internet today 
brewer neatly issue cap conjecture states distributed data system enjoy properties consistency availability tolerance network partitions 
notes distributed databases choose sacrifice face 
contrast want system part integral fabric internet highly available subset network reachable 
absence transactional consistency provide best effort results measure looser notions correctness precision recall 
organic scaling internet applications want system scalability grow degree deployment degree vary time differ applications underlying technology 
means avoid sharing data attractive integrating anonymization technologies surveyed 
architectures require priori allocation data center financial plans equip staff facility 
need organic scaling intersect current enthusiasm systems 
specifically target usual environment user pcs connected modems believe widely distributed technology intended run fairly robust gateway machines needs scale organic fashion 
natural habitats data main barrier widespread databases need load data database accessed database interfaces tools 
widespread adoption require data remain natural habitat typically file system live feed process 
wrappers gateways provided extract information data structured query system 
extracted information may temporarily copied query system storage space data record expected remain natural habitat 
standard schemas software additional challenge databases structured data wrappers need thousands users design integrate disparate schemas 
daunting semantic problems easily prevent average users adopting database technology frustrating database community hopes woven fabric internet 
certainly networking researchers sidestep issues 
fortunately quite natural pathway structured queries infect internet technology information produced popular software 
argued local network monitoring tools snort tcpdump provide ready schemas nature relatively widespread de facto standards 
thousands millions users deploy copies application server software packages expect software increasingly open reporting properties especially wake events sql slammer sapphire attack january 
ability local analysis tools reporting mechanisms shared global monitoring facility semantically feasible extremely desirable 
course suggest research widespread peer peer schema design data integration incompatible research agenda contrary solutions challenges increase potential impact 
argue massively distributed database research proceed waiting breakthroughs semantic front 
pier architecture motivation design implementation study pier database style query engine intended querying internet 
pier tier system shown 
applications interact pier query processor qp utilizes underlying dht 
instance dht pier component run participating node 
distributed hash tables dhts term dht catch set schemes sharing certain design goals see ex query optimizer storage manager network monitoring catalog manager user apps provider overlay routing core relational execution engine pier architecture applications pier dht ample shortly section 
name implies dht provides hash table abstraction multiple distributed compute nodes 
node dht store data items data item identified unique key 
heart dht overlay routing scheme delivers requests key node currently responsible key 
done global knowledge permanent assignment mapping keys machines 
routing proceeds multi hop fashion node maintains small set neighbors routes messages neighbor sense nearest correct destination 
dhts provide strong theoretical bounds number hops required route key request correct destination number maintenance messages required manage arrival departure node network 
contrast early routing unstructured heuristic schemes gnutella kazaa provide guarantees high routing costs fail locate key available network 
addition having attractive formal properties dhts increasingly practical serious 
received intense engineering scrutiny significant effort expended theoretical designs practical robust 
content addressable network pier currently implements particular realization dhts called content addressable network 
logical dimensional cartesian coordinate space partitioned hyper rectangles called zones 
node system responsible zone node identified boundaries zone 
key hashed point coordinate space stored node zone contains point coordinates shows dimensional nodes 
node maintains routing table neighbors coordinate space 
nodes neighbors plane zones share hyper plane dimension 
lookup operation implemented forwarding message path approximates straight line coordinate space sender node storing key 
map unidimensional key identifier space typically separate hash functions dimension 
key dimensional nodes zone owned node represented top right coordinates 
example lookup key initiated node owning zone lookup key join landmark leave table routing layer api shows path followed lookup key node maintains state average number hops traversed message number nodes system see details 
chosen simulations experiments leading growth behavior growth reduced logarithmic setting different dht design 
scalability results show improved dht 
dht design active debate dht research community best factor dht functionality subsidiary components 
chosen particular split 
expect adapt design conventional wisdom accrues dht community 
validation exercise deployed pier competing dht design called chord required fairly minimal integration effort 
routing layer mentioned section core dht dynamic content routing layer maps key ip address node currently responsible key 
api layer small simple providing just functions callback shown table 
lookup asynchronous function issue callback node located mapping keys nodes constantly changing nodes enter leave network 
callback provided notify higher levels asynchronously set keys mapped locally changed 
join leave calls provide creating new overlay network attaching existing network grace key maps local node call synchronous returning true immediately callback 
store key item retrieve key item remove key table storage manager api get namespace item put namespace item lifetime renew namespace item lifetime bool multicast namespace item scan namespace iterator namespace item table provider api fully leaving network 
pre existing networks join method simply requires socket address node network start new network 
popular networks assumed list landmarks known location 
com 
important note locality key space guarantee locality network proposed algorithms try minimize network distance nearby keys 
return issue section 
storage manager storage manager responsible temporary storage dht data node connected network 
api layer shown table 
api designed easily realized standard main memory data structures disk indexing package berkeley db simply filesystem 
expect storage manager provide performance reasonably efficient relative network bottlenecks 
data dht distributed machines applications machine store relatively small amount information 
true filesharing example respect index filenames gets queried 
simplicity early mainmemory storage manager 
modularity design allows complex scalable storage managers required 
provider provider responsible tying routing layer storage manager providing useful interface applications 
complete api shown table 
describing api notes dht naming scheme appropriate 
object dht namespace 
namespace calculate dht key hash function 
namespace identifies application group object belongs query processing namespace corresponds relation 
namespaces need predefined created implicitly item destroyed item expires described 
generally intended value carries semantic meaning object 
query processor default assigns value primary key base tuples attribute combination purpose 
items namespace key map node 
integer randomly assigned user application serves allow storage manager separate items namespace occur items stored primary key 
put get calls directly naming scheme 
note indexes get key instance may return multiple items 
order adhere principle relaxed consistency pier uses common internet approach soft state achieve reliability limit overheads face frequent failures disconnections 
purpose lifetime argument put call gives dht bound long store item receipt 
producer data periodically invoke renew call keep information live long 
data item refreshed lifetime item deleted dht responsible node 
node fails disconnected dht entries lost 
entries restored system soon node re sends information 
run query pier attempts contact nodes hold data particular namespace 
multicast communication primitive provider purpose 
provider supports scan access data stored locally node scan iterator 
run parallel nodes serving particular namespace serves purpose scanning relation 
provider supports callback application inform new data item arrived particular namespace 
qp overview pier query processor boxes arrows dataflow engine supporting simultaneous execution multiple operators pipelined form traditional query plans 
initial prototype started implementing operators selection projection distributed joins grouping aggregation 
traditional databases employ iterator model link operators 
operators produce results quickly possible push enqueue data operator pull 
intermediate queue capable hiding network latency data moved site 
networking fundamental aspect design chose encapsulate away volcano 
intend add additional functionality pier query processor including system catalogs extensible operator interface declarative query parsing optimization 
note additional modules complementary query processor parser optimizer layered existing query processor case choose continuously adaptive scheme operates query plan 
discuss section 
catalog facility reuse dht query processor 
natural habitat design principle currently provide facilities pier modifying data managed wrappers 
currently expect wrappers insert update delete items items tables namespaces directly dht interface 
add query parser fairly simple provide ddl facilities pier drive dht data modifications 
updates go soft state dht wrappers 
need provide data modification callbacks updatable wrappers important facilities added 
data semantics pier queries relaxed consistency design principle provide best effort data semantics pier call snapshot 
define reachable snapshot set data published reachable nodes time query sent client node 
practical matter forced relax reachable snapshot semantics accommodate difficulty global synchronization clocks query processing 
define correct behavior pier arrival query multicast message reachable nodes correct data set slightly time dilated union local snapshots data published reachable nodes local snapshot time query message arrival node 
applications considering pragmatic asynchrony snapshots acceptable 
course actual query answers may provide level consistency failures partitions published data reachable node may transiently indexed dht node soft state dht may transiently index data reachable node published node 
dht distributed joins join algorithms adaptations textbook parallel distributed schemes leverage dhts possible 
done software elegance afforded reuse dhts provide underlying scalability desire 
dhts senses literature content addressable networks routing tuples value hash tables storing tuples 
database terms dhts serve exchange mechanisms hash indexes hash tables underlie parallel join algorithms 
dhts provide features face volatile set participating nodes critical feature available earlier database 
see dhts route messages tuples including bloom filters 
implemented different binary equi join algorithms bandwidth reducing rewrite schemes 
discuss respect relations assume tuples stored dht separate namespaces note pier provides dht temporary table facility materializing operator output query plans 
core join algorithms general purpose equi join algorithm version pipelining symmetric hash join building probing hash tables input relation 
dht context data hashed speak rehashing table join key 
rehashing node performs scan locate tuple 
tuple satisfies local selection predicates copied relevant columns remaining new unique dht namespace values join attributes concatenated form copy copies tagged source table name 
probing hash tables local operation occurs nodes parallel building 
node registers dht receive callback new data inserted local partition 
tuple arrives issued find matches table get expected stay local 
local dht key space remapped interim get return correct matches expense additional round trip 
matches concatenated probe tuple generate output tuples sent stage query dht namespace output tuples initiating site query 
second join algorithm fetch matches variant traditional distributed join algorithm works tables say hashed join attributes 
case scanned tuple issued corresponding tuple 
note local selections improve performance tuple gets done dht layer pier query processor opportunity filter tuples remote site recall 
short selections non dht attributes pushed dht 
potential avenue streamlining improvements come expense dht apis pier specific features design approach tried avoid initial implementation 
tuples arrive corresponding tuple site predicates applied concatenation performed results passed 
join rewriting symmetric hash join requires rehashing tables consume great deal bandwidth 
alleviate possible implemented dht versions traditional distributed query rewrite strategies try lower bandwidth symmetric hash join 
symmetric semi join 
scheme minimize initial communication locally projecting join keys performing symmetric hash join projections 
resulting tuples pipelined fetch matches joins tables 
implementation issue joins fetches parallel know fetches succeed concatenate results generate appropriate number duplicates 
rewrite strategy uses bloom joins 
bloom filters created node local fragments published small temporary dht namespace table 
sites bloom namespaces filters ed multicast nodes storing opposite table 
receipt bloom filter node begins scanning corresponding ta ble fragment rehashing tuples match bloom filter 
validation performance evaluation section analysis simulations experiments real network demonstrate pier 
traditionally database scalability measured terms database sizes 
internet context important take account network characteristics number nodes system 
plenty computation storage resources performance system degrade due network latency overheads limited network capacity 
adding nodes system increases available resources increase latencies 
increase latency artifact dht scheme route data pier described section 
particular dht scheme system data item sent arbitrary nodes system traverse intermediate nodes average recall increase reduced logarithmic changing dht parameters 
illustrate impacts system performance variety metrics including maximum inbound traffic node aggregate traffic system time receive th result tuple 
system answers queries partial failures need quantify effects failures query results 
load network characteristics evaluate pier 
workload tests simple query workload select pkey pkey pad num pkey num constant num constant num num constant tables synthetically generated 
specified times tuples attributes uniformly distributed 
constants predicates chosen produce selectivity 
addition predicate uses functionf query plan evaluate equi join 
chose distribution join columns tuples matching join tuple ins predicates evaluated remaining matching tuple ins 
ther pad attribute ensure result tuples kb size 
specified symmetric hash join strategy implement join operation 
simulation experimental setup simulator implementation code base 
simulator allows scale nodes simulation longer fits ram limitation simulation pier architecture 
simulator scalability comes expense ignoring cross traffic network cpu memory utilizations 
topologies simulations 
fully connected network latency nodes ms inbound link capacity node mbps 
setup corresponds system consisting homogeneous nodes spread internet network congestion occurs hop 
addition gt itm package generate realistic transit stub network topology 
topology allows simulate larger systems simulation results topologies qualitatively similar ll see section topology simulations 
addition simplifying assumptions 
evaluation focus bandwidth latency bottlenecks ignore computation memory overheads query processing 
second implicitly assume data changes rate higher rate incoming queries 
result data needs shipped source nodes computation nodes query operation 
run experiments pier deployed simulated 
largest set machines available shared cluster pcs connected gbps network 
measurements reported section performed routing stabilizes tables loaded dht 
centralized vs distributed query processing standard database practice centralized data warehouses preferred traditional distributed databases 
section performance case distributed query processing scales interest 
consider join operation section assume distributed nodes join executed computation nodes bytes data toto passed selection predicates computation nodes need receive data average 
second term accounts small portion data remain local 
case selectivity predicates result value approximately gb database gb 
computation node node network need provision high link capacity order obtain response times 
instance willing wait minute results needs reserve mbps downlink bandwidth expensive practice 
validated calculation simulator data due space limitations 
scalability important properties distributed system ability scale performance number nodes increases 
section evaluate scalability system proportionally increasing load number nodes 
consider query node responsible mb source data 
plots response time th tuple 
value chosen bit tuple received 
avoid response metric chance produced locally reflect network limitations 
scalability experiment interested time receive result increase time th tuple secs computation node computation nodes computation nodes computation nodes computation nodes number nodes average time receive th result tuple size network load scaled 
data point averaged independent simulations 
load network size increase number results point exercise simply measuring constant network capacity query site results arrive 
shown nodes participate computation performance system degrades factor network size load increase nodes 
unable obtain perfect scaling number overlay hops lookup increases network size increases 
ultimately leads increase lookup latency 
particular implementation lookup length increases number nodes system 
number nodes increases lookup length increases factor reason observe factor degradation measurements lookup operation fixed overhead associated join operation discuss overheads detail section 
note increase lookup length reduced choosing different value different dht design 
number computation nodes kept small constraining join namespace bottleneck moves inbound links computation nodes result performance system degrades significantly total number nodes load computation node increases 
summary system scales long number computation nodes large avoid network congestion nodes 
join algorithms rewrite strategies section evaluate join strategies described section symmetric hash join fetch matches symmetric semi join rewriting bloom filter rewriting 
consider simulation scenarios bottleneck latency network capacity 
note case equivalent system network capacity infinite 
example time takes send result tuple back join initiator doesn change network size increases 
symmetric fetch symmetric bloom hash matches semi join filter sec sec sec sec table average time receive result tuple 
infinite bandwidth quantify impact propagation delay strategies ignore bandwidth limitations consider propagation delay 
strategy requires distributing query instructions nodes multicast message delivery results direct ip communication nodes 
table shows average time measured simulator receive result tuple query node network nodes 
proceed explain values analytically 
recall lookup takes hops average 
latency hop ms average lookup latency sec 
contrast latency direct communication nodes ms describes multicast operation distribute query processing detail 
note particular case takes multicast roughly sec reach nodes system 
detail analysis join strategy symmetric hash join rehash tuples dht lookup node responsible key send put message directly node 
adding multicast latency delivering results join initiator obtain sec close simulator value table 
fetch matches 
find possible matching tuple nodes lookup address node responsible tuple send request node wait reply deliver results 
scenario lookup direct communications 
adding costs operations yields sec 
symmetric semi join rewrite 
case projected tuples inserted network lookup plus direct communication fetch matches join performed indexes lookup direct communication 
total lookup operations direct communications including delivery results 
operations account bloom filter rewrite 
node creates local bloom filters sends collectors lookup direct communication 
turn collectors distribute filters back source nodes multicast source nodes perform rehash symmetric hash join lookup direct communication 
addition multicast operation required distribute query processing multicast op sec 
dht operations consist lookup followed direct communication 
operations atomic case node continuously fails contact node responsible certain key node mapping key changes lookup performed 
problem practice 
bandwidth savings having large message hop overlay network outweighs small chance problem 
aggregate network traffic mb sym 
hash join fetch matches sym 
semi join bloom filter selectivity predicate relation aggregate network traffic generated join strategy 
eration lookup operations direct communications 
adding gives sec 
reason value larger reported table derivations assumed node experiences worst case delays waiting multicasts 
happen practice 
limited bandwidth section evaluate performance join strategies baseline simulation setup inbound capacity node mbps 
measure network overhead incurred join strategy measure time receive result tuple 
plots bandwidth requirements strategy function selectivity predicate ons 
total size approximately gb system nodes 
expected symmetric hash join uses network resources tables 
increase total inbound traffic due fact number tuples number results increase selectivity selection ons 
contrast fetch matches strategy basically uses constant amount network resources selection pushed query plan 
means regardless selective predicate tuple retrieved evaluated predicate computation node 
symmetric semi join rewrite second join transfers tuples match 
result total inbound traffic increases linearly selectivity predicate bloom filter case long selection low selectivity bloom filters able significantly reduce rehashing onr join 
selectivity selection ons increases bloom filters longer effective eliminating rehashing algorithm starts perform similar symmetric join algorithm 
evaluate performance algorithms plot average time receive result tuple 
time tuple secs sym 
hash join fetch matches sym 
semi join bloom filter selectivity predicate relation time receive result tuple strategy 
reason tuple th illustrate different bottlenecks system 
selectivity predicate lower bottleneck inbound capacity computation nodes 
result plots follow trend similar total inbound traffic shown 
predicate selectivity number results increases bottleneck switches inbound capacity query site 
effects soft state section evaluate robustness system face node failures 
typical algorithm dhts detect node failures node send periodic keepalive messages neighbors 
certain number keepalive messages remain unanswered node conclude neighbor failed 
node fails take neighbors time learn node failed 
time packets sent failed node simply dropped 
section assume somewhat arbitrarily takes seconds detect node failure 
node detects neighbor failure assume node route immediately failure 
node fails tuples stored node lost nodes published reachable 
simple scheme counteract problem periodically renew refresh tuples 
evaluate scheme plot average recall function node failure rate different refresh periods nodes system see 
refresh period sec means tuple refreshed sec 
node fails tuples stored node unavailable sec average 
expected average recall decreases failure rate increases increases refresh period decreases 
illustration consider case refresh period sec failure rate nodes minute 
means nodes fail minute 
takes sec average lost tuple reinserted system expect sec sec live tuples system unavailable 
result recall close value 
note recall average recall time th tuple secs sec refresh sec refresh sec refresh sec refresh failure rate failures min average recall different refresh periods 
computation node computation nodes number nodes average time receive th result tuple size network load scaled transit stub topology compare plot 
data point averaged simulations 
respect reachable snapshot semantics section 
transit stub topology far simulations fully connected network topology 
natural question complex realistic network topology change results 
section try answer question gt itm package generate transit stub network topology 
network consists transit domains 
nodes transit domain stub domains transit node 
number nodes system distributed uniformly stub domains 
transit transit latency ms transit stub latency ms latency nodes stub ms inbound link node mbps 
shows results scalability experiments section transit stub topology 
results exhibit trends results obtained fully connected topology see 
time th tuple secs number nodes real nodes average time receive th result tuple prototype implementation 
nodes system computation nodes 
data point averaged independent runs 
significant difference absolute values receive th result tuple larger 
average endto delay nodes transit stub topology ms ms case fully connected graph 
note plot results nodes nodes 
maximum network size allowed current simulator transit stub topology 
limitation fact observe qualitative different results topologies main reasons fully connected topology 
experimental results section experimental results running prototype implementation cluster pcs connected gbps network 
plots time receive th result tuple number nodes increases load scales accordingly 
expected time receive th result tuple practically remains unchanged system size load scaled 
reason plot smooth cluster run experiments typically shared competing applications particularly heavily loaded period ran tests 
believe peak response time nodes due artifact implementation 
related pier inspired informed number research traditions 
attempt provide rough overview related 
widely deployed distributed systems leading example massively distributed system internet 
soft state consistency internet internal data chief models 
schema standardization front note significant effort expended standardizing protocols ip tcp smtp ensure schema messages globally agreed standards driven pop deployed software 
rarely stored persistently number bytes generated schemas annually enormous 
prevalent distributed query systems filesharing dns 
examples globally standardized schemas significant sacrifices data consistency order scale provides transactional guarantees 
filesharing systems today necessarily provide full recall relevant results provide poor precision returning currently inaccessible 
dns better job recall keeps stale data period time sacrifice precision 
scalability adoption model systems model 
database systems query processing traditional distributed databases focused developing bandwidth reduction schemes including semi joins bloom joins incorporated techniques traditional frameworks query optimization 
mariposa ambitious attempt geographic scaling query processing attempting scale thousands sites 
mariposa focused overcoming cross administrative barriers employing economic feedback mechanisms cost estimation query optimizer 
knowledge mariposa deployed simulated dozen machines offered new techniques query execution query optimization storage replication 
contrast postpone query optimization geographic scalability agenda preferring design validate scalability query execution infrastructure 
techniques adaptations query execution strategies parallel database systems 
distributed databases parallel databases significant technical commercial impact 
parallelism se explicit motivation algorithms parallel query processing form natural starting point systems processing queries multiple machines 
database ir proposals databases growing area investigation 
early workshop focused storage issues intentionally sidestep design principles scalability lead consider soft state storage pier 
related body investigating semantic data integration challenges autonomous databases 
solutions problems prerequisite impact nicely complement 
builds initial workshop proposal pier 
knowledge presents serious treatment scalability issues style relational query engine 
emerging set text search proposals intended provide traditional ir functionality 
analogous workload specific relational query engine focusing bloom filter intersections inverted index posting lists 
network monitoring number systems proposed distributed network monitoring 
closest proposal discussion astrolabe sql query system focused specif ically aggregation queries network monitoring 
astrolabe provides ability define materialized aggregation views sub nets run queries hierarchically compose views coarser aggregates 
astrolabe provides constrained subset sql sacrifices general query facilities favor family queries exploit hierarchy efficiently 
contrasts flat topology general platform provided pier 
workshop proposal peer peer network monitoring software including simple query architecture ideas trust verification measurement reports 
continuous queries streams final related body flurry activity processing continuous queries data streams proposals network monitoring driving application 
certainly continuous queries natural network monitoring body may especially relevant focus data compression synopses adaptive query optimization 
date querying streams targeted centralized systems 
somewhat tangential proposals query processing wireless sensor networks 
systems share focus peer peer architectures minimizing network costs typically focus different issues power management extremely low bandwidths lossy communication channels 
initial design implementation pier structured query system intended run internet scale 
pier targeted situ querying data wide area 
knowledge demonstration scalability pier nodes unique database literature simulated networks 
experiments actual hardware far limited machines available give reason doubt scalability shown simulation results 
currently deploying pier planetlab testbed afford experience large collection nodes distributed internet 
scalability pier derives small set relaxed design principles led key decisions including adoption soft state dilated reachable snapshot semantics dhts core scalability mechanism indexing routing query state management recall quality metric applications network monitoring 
initial focused query execution aspects pier believe initial design thrust sound 
scalability results hand wired queries encourage pursue number additional research thrusts 
include network monitoring applications existing pier implementation nearly sufficient support simple useful network monitoring applications topic particular interest networking researchers 
implementing handful applications help prioritize system design topics discuss 
recursive queries network graphs computer networks form complex graphs quite natural recursively query graph properties 
simple example gnutella filesharing network useful compute set nodes reachable hops node 
twist data network graph queried fact communication network execution 
practical recursive query setting presents interesting new challenges efficiency robustness 
hierarchical aggregation dhts 
focused implementation analysis distributed joins 
implemented dht hash grouping aggregation pier straightforward fashion analogous done parallel databases 
parallel databases designed bus network topologies techniques aggregation necessarily appropriate multi hop overlay network 
network aggregation schemes astrolabe tag perform hierarchical aggregation network providing reduced bandwidth utilization better load balancing result 
clear leverage ideas system pier 
possible direction leverage application callbacks supported intermediate routing hops dhts data aggregated routed somewhat scheme tag 
clear effectively 
alternative superimpose explicit hierarchy dht undercuts basic dht approach robustness scalability 
efficient range predicates dhts hashing mechanism focused equality predicates particular equi joins 
important pier efficiently support predicates 
foremost standard unidimensional range predicates typically supported database systems trees 
important predicates include regular expressions string matching predicates multidimensional ranges near neighbor queries 
catalogs query optimization seen existing boxes arrows query engine scales usability robustness purposes prefer support declarative queries 
necessitates design catalog manager query optimizer 
catalog typically small stringent availability consistency requirements data discussed stress design principles 
query optimization front approach start classic parallel distributed database approaches simply enhance cost models reflect properties dhts 
may heterogeneity shifting workloads wide area internet 
considering mid query adaptive optimization approaches eddies capture changes performance adaptivity especially attractive focus continuous queries discuss 
continuous queries streams noted section concur prior assertions continuous queries natural network traces may wrapped unbounded data streams 
pier provides pipelining query engine asynchronous threading model process queries wrapped distributed streams introducing windowing schemes join aggregation code 
step interesting see proposed stream techniques synopses adaptivity sharing adapted massively distributed environment 
routing storage layering number potential optimizations center pier dht layer 
include efficient routing schemes provide better physical locality network pushdown selections dht batch routing tuples call dht caching replication dht data loadbalancing dht especially face heterogeneous nodes links 
topics active research growing dht design community 
interesting question watch dht community efforts useful needs query processing system better designing query specific techniques 
case subsidiary question unique needs addressed dht layer need specialized dht support increased performance 
acknowledgments research funded nsf ani ani ani ani eia iis iis itr itr itr 
avnur hellerstein 
eddies continuously adaptive query processing 
proc 
acm sigmod international conference management data pages dallas may 
babcock babu datar motwani widom 
models issues data stream systems 
proc 
acm sigact sigmod sigart symposium principles database systems madison june 
acm 
bernstein giunchiglia kementsietsidis mylopoulos serafini 
data management peer peer computing vision 
fifth international workshop web databases webdb june 
bernstein brodie ceri dewitt franklin garcia molina gray held hellerstein jagadish lesk maier naughton pirahesh stonebraker ullman 
asilomar report database research 
sigmod record 
bonnet gehrke seshadri 
sensor database systems 
proc 
mobile data management volume lecture notes computer science hong kong jan 
springer 
calvert zegura 
gt internetwork topology models gt itm 
www cc gatech edu projects gt itm readme 
preneel vandewalle 
solutions anonymous communication internet 
ieee 
clark 
design philosophy darpa internet protocols 
proceedings sigcomm aug 
consortium 
network wizards internet domain survey 
www isc org ds host count history html 
dewitt gray 
parallel database systems high performance database systems 
cacm 
gilbert lynch 
brewer conjecture feasibility consistent available partition tolerant web services 
acm sigact news june 
graefe 
encapsulation parallelism volcano query processing system 
proc 
acm sigmod international conference management data pages atlantic city may 
acm press 
graefe 
query evaluation techniques large databases 
acm computing surveys june 
gribble halevy ives suciu 
database peer peer 
proc 
fourth international workshop web databases webdb santa barbara may 
halevy ives suciu tatarinov 
schema mediation peer data management systems 
th international conference data engineering bangalore india 
harren hellerstein huebsch loo shenker stoica 
complex queries dht peer peer networks 
st international workshop peer peer systems iptps march 
hasan 
optimization sql queries parallel machines 
phd thesis stanford university 
huebsch 
content multicast comparison implementation options 
technical report ucb csd uc berkeley feb 
lohman 
optimizer validation performance evaluation distributed queries 
proc 
twelfth international conference large data bases vldb pages kyoto aug 
madden franklin hellerstein hong 
tag tiny aggregation service ad hoc sensor networks 
fifth symposium operating systems design implementation osdi boston dec 
mockapetris 
domain names implementation specification nov 
olson bostic seltzer 
berkeley db 
proc 
summer usenix technical conference monterey june 
ozsu valduriez 
principles distributed database systems nd edition 
prentice hall 
padhye floyd 
identifying tcp behavior web servers 
proceedings sigcomm june 
peterson anderson culler roscoe 
blueprint introducing disruptive technology internet 
proc 
acm hotnets workshop princeton oct 
ratnasamy francis handley karp shenker 
scalable content addressable network 
proc 
acm conference berkeley ca august 
reynolds vahdat 
efficient peer peer keyword searching 
cs duke edu search june 

snort lightweight intrusion detection networks 
th usenix systems administration conference lisa seattle wa nov 
rowstron druschel 
pastry scalable decentralized object location routing large scale peer peer systems 
lecture notes computer science 
srinivasan zegura 
network measurement cooperative enterprise 
proc 
international workshop peer peer systems iptps cambridge ma mar 
stoica morris karger kaashoek balakrishnan 
chord scalable peer peer lookup service internet applications 
proc 
acm sigcomm conference pages 
stonebraker aoki litwin pfeffer sah staelin yu 
mariposa wide area distributed database system 
vldb journal 
tang xu mahalingam 
psearch information retrieval structured overlays 
hotnets october 
van renesse birman vogel 
scalable management data mining astrolabe 
proc 
international workshop peer peer systems iptps cambridge ma mar 
wilschut apers 
dataflow query execution parallel main memory environment 
proc 
international conference parallel distributed info 
sys 
pdis pages 
zhao kubiatowicz joseph 
tapestry infrastructure fault tolerant wide area location routing 
technical report ucb csd uc berkeley apr 
