www lsv ens cachan fr appear formal aspects computing version edinburgh report ecs lfcs consideration publication formal aspects computing architectural specifications casl michel bidoit donald sannella andrzej tarlecki laboratoire specification verification cnrs ens de cachan france laboratory foundations computer science university edinburgh uk institute informatics warsaw university institute computer science polish academy sciences warsaw poland 
novel features casl common algebraic specification language provision called architectural specifications describing modular structure software systems 
brief discussion refinement casl specifications provides setting presentation rationale architectural specifications 
followed details features provided casl architectural specifications hints concerning semantics simple results justifying usefulness development process 

common feature day algebraic specification languages see sw em gh cofi sw provision specification building operations building large specifications structured fashion smaller simpler ones 
pioneered burstall goguen seminal clear specification language bg bg 
usual specification languages features describing modular structure software systems development 
facilities provided casl new common algebraic specification language cofi developed auspices common framework initiative mos cofi attempt create focal point joint algebraic specifications platform exploitation past methodology support tools earlier practical experiences fj fac foundational bid st sst bh argue mechanisms structuring specifications su ce describing modular structure software development 
casl provides separate kind specifications called architectural specifications purpose 
architectural specification consists list unit declarations indicating component modules required specifications unit term describes way modules combined 
architectural specifications aimed implementation modular structure system style features programming large generic modules modern programming languages standard ml pau cf 
burstall lampson pebble bl 
related software architecture sense ag deals organization software components connectors focusing interaction relationships modules considered specifications reactive modules introduced casl extension cf 
fl 
aim motivation intuition technicalities related concept 
correspondence print requests michel bidoit michel bidoit lsv ens cachan fr donald sannella dts dcs ed 
ac uk andrzej tarlecki tarlecki edu pl 
revised expanded version bst 
bidoit sannella tarlecki provide basic information casl section discuss development programs specifications stepwise refinement section introduce architectural specifications section 
stress generic components arise naturally desire allow separate related modules developed independently 
semantics correctness aspects architectural specifications simplest ways combining modules discussed sections 
operators combining modules section 
development process presence architectural specifications briefly discussed section 
architectural specifications context casl 
ideas technicalities applicable specification development framework explain section 
venture briefly advanced features architectural specification development bringing ideas behavioural refinement 

casl preliminaries casl formalism describe casl structures sorted algebras subsorts partial operations predicates 
structures classified signatures give sort names subsorting relation partial total operation names predicate names profiles operations predicates 
casl structures subsorts linked implicit subsort embeddings required compose compatible operations predicates names 
signature class structures denoted mod 
basic level casl includes declarations introduce components signatures axioms give properties structures considered models specification 
logic write axioms essentially order logic quantification usual logical connectives built atomic formulae include strong existential equalities definedness formulae predicate applications generation constraints added special non order sentences 
basic casl specification sp amounts definition signature set axioms 
denotes class sp mod models structures satisfy axioms sp mod 
apart basic specifications casl provides ways building complex specifications simpler ones means various structuring constructs 
include translation hiding union free loose forms extension 
generic specifications instantiations pushout style semantics bg em provided 
structured specifications built constructs compositional semantics specification sp determines signature sig sp class sp mod sig sp models 
say sp consistent sp non empty 

example sequence definitions casl specifications 
comments clarify meaning particular casl constructs notations 
example small contrived sense way specifications build quite natural 
spec monoid sort thing ops null thing thing thing thing assoc unit null usual specification monoid sort elements constant binary operation associative constant neutral element 
spec num sort num ops num succ num num signature natural numbers starting point specifications 
architectural specifications casl spec num op plus num num num vars num axiom plus succ succ plus monoid thing num null plus enriches num binary operation requires num plus form monoid 
union specifications employed re specification monoid introduced earlier 
extremely simple incorporate requirements monoid directly axioms plus complex cases lot conceptual structure specification lost 
spec num pred num num axiom num succ extension num loosely specified binary predicate 
spec op code num num axiom num code put previous extensions num add unary operation num simple axiom 
spec elem sort elem spec elem generated type cont empty add elem cont 
pred addable elem cont vars elem cont axiom def add addable pred elem cont axioms empty add addable generic elem specification partial containers introduces datatype cont generated constant empty partial constructor add adds element container 
element may added container addable satisfied 
addable left unspecified stage 
usual membership predicate provided 
spec fit elem num instantiate generic specification appropriate fitting parameter 
result contains operations predicates added profiles adjusted accordingly 
spec vars num cont axiom addable code constrain condition requiring number addable container code included 
bidoit sannella tarlecki 
program development refinement intended casl specification formalism specify programs 
casl specification determine class programs correctly realize specified requirements 
fit formal view casl specifications programs written programming language having semantics assigns program denotation casl structure 
program determines signature sig structure mod sig 
denotation sp specification sp description admissible realizations program correct realization sp sig sig sp sp 
idealized view program development start initial loose requirements specification sp refine step step easily realizable specification sp obtained sp sp sp stepwise refinement sense chain refinements guarantees correct realization sp correct realization sp sp sp 
ensured definition refinement sp sp signature define sp sp sp sp 
construction program realize sp outside scope casl 
casl provides means building specifications sense wide spectrum language bw 
furthermore construct casl explicitly express refinement specifications 
part meta level firmly formal semantics casl specifications 
satisfactory model refinement allows modular decomposition development task tasks refining specification sequence specifications refined independently 
course development may branch giving tree structure 
sp br sp sp 
sp sp realizations 
pn specifications sp 
sp able put extra ort obtain realization sp branching point need operation combine arbitrary realizations sp 
sp realization sp may thought linking procedure link br attached branching point br 
pn realizing sp 
sp link br 
pn realizes sp sp 
sp link br 
pn sp 
crucially means want replace realization component specification sp new realization sp need re link realizations component specifications need modify way 
link br 

pn guaranteed correct realization sp just link br 

pn 
words interaction components happens link br components may developed entirely independently 
nature link br depends nature programs considered 
instance just program texts programming language pascal case link br may simple textual operation say re grouping declarations definitions provided component programs actual pieces compiled code case link br really linking usual sense word 
preferred view programming language reasonably powerful flexible modularization facilities standard ml pau ada ada 

pn program modules structures standard ml packages ada link br module expression generic module formal parameters actual modules 
pn may substituted 
note replace module recompilation link br 

pn required case necessary modify modules 
may indirect general involves non trivial abstraction step 
attempted real programming language 
architectural specifications casl expect br just specification building operation op specification construct expressible casl branching viewed ordinary refinement sp op sp 
sp 
refinement op sp 
sp consist separate refinements sp 
sp 
requires op monotonic respect inclusion model classes 
refinement rule sound sp sp sp sp op sp 
sp op sp 
sp view possible provided specification building operation op constructive sense realizations 
pn sp 
sp able construct realization link op 
pn op sp 
sp 
case op sp 
sp consistent sp 
sp 
simple examples show standard specification building operations union specifications property 
follows refining sp op sp 
sp op arbitrary specification building operation ensure provide realization sp realizations sp 
sp 
see hn di erent approach problem 
problem refinement step sp op sp 
sp explicitly indicate subsequent refinement proceed independently refining sp 
sp preserving structure imposed operation op structure specification op sp 
sp way prescribes structure final program 
necessarily preserving structure subsequent development convenient natural refinements break structure allowed 
early stages development process fix final structure resulting program decision structuring specification amount decision structure final program 
hardly practical aims structuring specifications early development phases requirements engineering phase quite distinct structuring final programs 
simple examples mentioned cf 
fj 
hand certain stages program development need fix structure system development design modular structure system important design decisions development process 
casl role architectural specifications see section 

example consider task realizing section 
structure provide useful guidance structure realization 
instance obvious trouble union attempt implement structurally providing independent realizations num appropriate extension plus monoid appropriate renaming succeed pure chance 
furthermore extension axiom addable directive realize ensure predicate addable satisfy axiom 
realizing means things choosing realization addable change specification realization required choice addable quite di erent specification quite di erent structure 
enable implementor take advantage fact axiom addable ensures element need added container 
re structure specification introducing new constructive compositions exposing existing ones 
instance specification building operations derived specification constructs monotonic constructs casl specification languages 
exceptions imposing requirement freeness viewed operations add constraints specifications fully fledged specification building operations cf 
data constraints clear bg 
bidoit sannella tarlecki spec fit elem num vars num cont axiom addable code spec fact specifications equivalent instantiation specification constructive indicates possible split development part realization developed part implemented 
see section details 

architectural specifications section need distinguish carefully kinds structuring mechanisms needed specification development process 
hand need standard mechanisms structure specifications facilitate construction reading understanding re 
provided specification building operations casl disregarding operations constructive 
general viewed fixing shape development tree determining modular structure final program 
hand certain stage program development need design structure final program consider decisions binding subsequent development process 
design refining specification constructive combination specified components 
essence constructive specification building operation specific construction linking procedure builds realization original specification realizations component specifications 
structuring facility quite standard modular programming languages rarely explicitly provided specification formalisms 
approaches structure specification regarded determining structure final program examples section notwithstanding see gb ma 
ad hoc informal mechanisms indicate certain part structure specification constructive specification building operation remain fixed rest development 
consider unsatisfactory confusing 
casl provides explicit notation specifies components required way combine build resulting program 
architectural specifications alternative terminology organizational specifications refine ordinary specifications structured explicitly introducing branching development process structure final program sp br sp 
sp corresponding architectural specification written follows units sp 
sp result link br 
un notice provide names program units implemented component specifications give linking procedure link br combine units operation combine specifications 
component specifications sp 
sp ordinary casl specifications 
linking procedure link br un just unit term involve units named 
un builds new unit actual units 
un correctly realize specifications sp 
sp typically sp 
sp units realize contain shared parts rely 
instance start implementing simple specification sp architectural specifications casl implementation sp build implementation larger specification sp stage build implementation un sp un final result un corresponding architectural specification units sp sp 
sp result linking procedure un trivial linking done build course just simplest case 
particular cover multiple dependencies unit units sharing various units flexible way just having unit previous reusability unit may 
illustrates idea splitting development task subtasks clearly indicating interfaces flow information 
extreme split may done step step time splitting just parts sp units sp sp result task providing realization sp independent task providing realization sp follows properties may exploited development explicitly ensured specification sp requires realization sp realization sp tantamount requiring generic realization sp takes particular realization sp parameter 
obtain simply feeding genericity arises independence developments desire build multiple realizations sp di erent realizations sp reflected fact named architectural specification 
desired indicate potential re explicitly may give class status called generic unit specification sp sp indicates realize sp realization sp units sp sp sp result called unit definition 
earlier specification equivalent version sole exception anonymous 
shows explain architectural specifications involving translation architectural specifications involving explicit generic units 
key insight genericity control flow information developments independent units multiple instantiation 
despite useful retain notations convey di erent pragmatic intuitions 
specification arising translation specifications involving generic unit instantiated general may applied argument demonstrated section 
programming languages su ciently powerful modularisation facilities generic units correspond form generic modules functors standard ml generic packages ada 
contrast units simply programs realizing ordinary structured specifications correspond closed modules structures standard ml non generic packages ada 
components closed unit available program imports 
way generic units instantiate components ready 
generic unit specifications correspond functor headings extended ml st restricted form specifications sst cf 
spectral ks 
hand generic unit specifications generic specifications coincide act em discussion argues inappropriate 
bidoit sannella tarlecki 
example recall specifications built section comments section 
ended specification spec suggests way decomposing task implementing 
may turned design decision refining specification architectural specification captures decomposition meant arch spec units result fully formal semantics architectural specifications precisely 
bit clever design require realization containers specified uniqueness property arbitrary elements equipped operations allow express property 
instance spec sort elem op transform elem elem spec vars elem cont axiom addable transform arch spec units auc result auc fit elem num transform code 
required generic unit auc general anonymous unit build required 
auc arbitrary structures fitting specification re arguments anonymous generic unit required structures fitting considerably richer specification 
life easier implementor extra structure implementation unit general 
system designer choose follow general specific line design choose di erent architectural specification refinement 
key point choice architectural specification prescribes modular structure system 

semantics unit specifications provide formal framework covering ideas advanced aspects architectural specifications take closer look underlying semantics generic units specifications 
consider unit specification form sp sp respective signatures sp reader kindly asked rely intuition obvious analogy instantiation generic specifications grasp meaning instantiation generic units non trivial fitting arguments 
details section 
architectural specifications casl sp casl sp implicitly viewed extension sp loss generality assume specification form sp sp sp extends sp sp sp 
indicated realize specification sp sp provide program fragment sp sp extends realization sp realization sp write 
basic semantic property required programs sp program extends realizes sp semantically sp 
amounts requiring determine partial function mod mod preserves argument defined defined structures sp yields result sp applied structure sp 
consequently sp sp mod mod dom sp defined sp definition easily restated form closer definition semantics specifications section 
generalize notion casl structures generic structures follows mod mod mod dom sp sp equivalently defined sp sp mod sp defined sp note set empty model sp extended model sp say sp sp inconsistent 
semantic view program fragments partial functions naturally leads generalisations 
obvious admit multi argument functions providing possibility realization specification depend realizations sub specification 
specifications multiply dependent units form sp 
sp sp singly dependent units assume sp extends sp 
sp equivalently union 

respective signatures sp 
sp sp sp 
sp sp mod 

sp 
sp 
defined 
sp mod 
sp 
sp defined explained 
general tuples 
structures sp 
sp extended structures sp symbol sp inherited sp 
sp interpretation resulting structure corresponding argument structure 
symbol occurs arguments impossible expand tuple arguments result relevant arguments interpret symbol way 
tuple 
structures mod 
mod compatible structure mod 
union signatures 

easy see structure exists unique call amalgamation 
write 
necessary condition compatibility mod 
mod symbol occurs interpreted way turns su cient structures signatures subsorts discrete subsort ordering 
presence non trivial subsorts compatibility implicit subsort embeddings compositions ensured precise condition compatibility tuple structures considerably involved see smt 
casl denotes set partial functions intuitively statically formed soon right signature needs defined arguments realize sp bidoit sannella tarlecki take mod 
class compatible tuples structures mod 
mod respectively define semantics tuples specifications mod 

mod 
sp 
sp 
mod 
sp 
sp mod 
defined follows mod 
mod 
mod 
dom 


sharing formedness spite somewhat technical motivation definitions previous section convey important methodological concepts 
way require number units fed unit dependent share parts 
developed independently certain parts argument units identical 
casl requirement imposed names argument signatures symbols shared argument units 
application generic unit tuple arguments formed arguments share commonly named parts 
programming language standard ml part type discipline required sharing type checked statically 
principle applies casl technicalities involved 
various compatibility conditions casl stated non static semantic requirements structures classes structures 
addition recommended static sharing analysis su cient ensure required compatibility properties instance formedness unit applications 
sharing analysis computable specifications non trivial subsorts 
arbitrary casl specifications subsorts compatibility properties undecidable general 
undecidable properties clearly identified practically useful approximate decision procedures proposed see cofi smt full details 
consider simple example spec sp sort spec sp sort op spec sp sort op spec sp sort op spec sp sort op axiom generic unit specification sp sp sp imposes constraint arguments generic unit required share common realization sort constant consequently unit declarations units sp sp sp sp sp instantiation allowed ensures units share easy provide units realize sp sp respectively fulfilling sharing requirement 
hand consider unit declarations units sp sp sp sp sp sp sp sp unit term formed context declarations 
required sharing arguments ensured 
sort constant come 
follows simply fact generic units expand arguments preserving modification result 
architectural specifications casl situation bit clear components instantiations generic units involved 
instance consider units sp sp sp declarations 
formed 
expect sort arguments traced unit constant occurrences 
sharing raise objections just requires slightly longer chain instantiations followed 
argument occurrences share constant carried far 
general decide instantiations say share constant check argument units identical 
clearly complicated static analysis trivial cases seen hold immediately 
programming languages flexible modularisation facilities new items introduced instantiation generic modules distinct instantiation 
instance functors generic modules standard ml generative semantics time functor instantiated argument new types builds generated anew kept distinct built instantiations arguments time 
similar phenomenon occurs ada generic packages 
safety sharing analysis casl assumes new symbols introduced generic unit shared instantiations arguments case 
programming languages applicative generative modules treatment sound albeit marginally awkward necessary 
auxiliary unit definitions may casl avoid repetition unit instantiation 
instance rewrite previous example units sp sp sp sp sp sp sp sp sp sp context unit declarations definitions formed captures intention 
alternative way example definition local unit instantiation local legal context previous unit declarations 
sum context sequence unit declarations definitions symbols units share traced common symbol non generic unit 
tracing procedure chases symbols diagram signatures connected signature morphisms capture dependencies units current context 
construction sharing diagram follows structure unit term analysed 
applications generic units arguments new node result signature added parameter signatures linked hand result signature inclusions hand argument signatures fitting morphisms symbols result come parameters new traced corresponding symbols arguments transitively symbols traced 
newly declared units signatures added new nodes diagram symbols declared unit traced 
unit definitions extend current context diagram built definitional term 
instance specifications consider units sp sp sp sp sp sp term formed sort arguments required share cases traced sort bidoit sannella tarlecki 
semantics unit terms indicated architectural specification comprises sequence unit declarations unit definitions followed unit term shows named units put build result 
obviously possible put units completely arbitrary ways fit properly modular programming languages 
environment maps declared unit names particular possibly generic structures result term denotes structure 
static analysis unit terms sharing analysis just checking correctness 
crucial step check unit tuple units fed generic unit interfaces match making sure requirements imposed parameter generic unit specification fulfilled argument tuple 
take simple example units sp sp sp feed unit generic unit words unit term correct 
order formed signatures argument coincide sig sp sig sp 
multiply dependent symbols common di erent arguments sharing checked 
required arguments realize sp including requirements imposed axioms sp may contain 
correct sure know su cient establish required argument clearly know recorded sp information available 
unit developed point declaration decomposes development task developing separately limit knowledge level provided sp know unit denotes structure sp 
argument required denote structure sp 
consequently term correct provided sp sp 
di erent words describe di erent aspects unit terms 
formedness static property typically expected decidable checked automatically case sharing analysis casl 
sketched section check unit term formed need information signatures units available non available unit formed course sharing information 
static context static semantics sharing analysis determine formedness term 
correctness requires verification expect decidable general 
check unit term correct need full semantic information units explained 
example misleadingly simple argument came equipped explicit specification sp provided information available general argument may complex able gather information available 
instance know context unit declarations course assuming sig sp sig sp sp sp 
clearly know result realizes specification sp 
quite know reduct sig sp realizes sp may carry information sp 
environment maps unit names particular possibly generic structures unit term denotes structure defined inductively follows unit name 
instantiation 
tn ary generic unit 
tn unit terms 
tn 

unit terms denote 
trivial reason application generic unit wrong number arguments arguments wrong signatures unbound unit name 
trivially attempt apply generic unit non compatible tuple structures 
cases arise term formed sense discussed 
term denote involves application generic unit structure outside domain happen term correct 
correctness defined context unit names associated specifications particular structures realizing specifications 
say environment matches context context carries semantic information available units 
convenient think information unit architectural specifications casl bind unit names unit name domain structure realizes specification 
unit term formed context write class structures denotes environments match 
intuitively captures properties unit built unit declarations definitions determine 
correctness formed unit term defined induction structure follows unit name correct 
formedness declared 
follows 
instantiation 
tn correct sp 
sp sp 
tn sp 
sp 
follows 
tn sp sig sp 
sig spn 
omits defined units unit terms treated obvious way information units extracted definitional terms stored context 
constructs unit terms discussed section 
statements defining correctness unit terms provide direct way compute referring class environments match 
proved induction structure unit terms directly calculate ensured properties validate correctness 
theorem 
context unit term formed correct 
environment matches defined 
means finished development process provided realizations units declared correct result term successfully combine realizations give structure 
structure satisfies properties calculate directly architectural specification 
correctness result term architectural specification checked realizations component units provided 
posteriori checking necessary ensure independent successful developments components fit give correct result 

operators apart direct declared units instantiation generic units actual arguments number constructs build units useful typically provided form programming languages advanced modularisation facilities 
sense produces new unit customize defined instance fit required signature 
constructs generic unit expressions section relates directly specification structuring constructs casl 
instance amalgamation units relates union specifications 
draw attention relationship syntax deliberately 
crucial confuse levels explained section 

amalgamation need way putting developed units build larger unit contains components 
semantic counterpart operation amalgamation 
unit terms 
tn amalgamation denoted tn consider example num section 
form unit specification formal semantics casl uses slightly complex semantic objects 
specifications declared units directly declarations 
defined units semantic information relevant sharing information determined semantics unit term definition explained 
units share components indicated sharing information context structures stored mutually compatible morphisms sharing diagram constructed sketched section 
bidoit sannella tarlecki spec char sort char ops char spec num char arch spec split units num char result split describes natural way realize specification simply realizing totally independent parts separately putting units realizing parts split just feeding number required arguments generic unit amalgamating number units sure share components having common names 
trivial example spec num num preds divisible num divisible num spec num num pred divisible num spec num num pred divisible num arch spec split units num num num num num result num split attempted arch spec split 
units num num result formed unit term ensured realization num shared formally context formed unit terms 
tn amalgamation tn formed unit term signature union signatures 
tn provided compatibility condition necessary ensure structures signatures 
tn derived sharing information available current context 
signatures non trivial subsorts amounts requiring common symbol signatures shared traced sharing diagrams built symbol non generic unit corresponding condition arbitrary casl signatures subsorts additionally requires compatibility properties compositions subsort embeddings derived see cofi smt 
case environment matching tn follows 
tn 


compatible formed amalgamation tn correct 
tn correct 
sharing requirement ensures compatibility structures 
result developments units described context 
words environment matches 
compatible 
architectural specifications casl instance recall example split 
unit term describing result bound specific structures resp 
generic structures environment compatible 
holds may structures respectively compatible context determined unit declarations split 
normal structures compatible clearly specific structure bound structure compatible 
amalgamation construct sense redundant 
specifications sp sp specification sp sp sp sp unambiguously specifies generic unit produces amalgamation compatible arguments 
adding syntax amalgamation simply specify amalgamation units needed 
feel appropriate simplification mislead reader thinking specification carries non trivial implementation requirements 

reduct renaming construct necessary reduct 
allows user design realizations contain auxiliary components exported clients 
example spec sp sort spec sp ab sort op spec sp bc sort op arch spec sp units sp ab sp sp ab bc sp sp bc result ab hide bc reveal result term architectural specification sp forms reduct want provide just casl structured specifications 
ab hide lists symbols hidden 
formedness conditions simply require hidden symbols 
semantics simple reduct defined casl structures taken 
sharing information obvious result signature included signature unit hiding applied symbols remaining reduct traced signature 
second form hiding reveal similar dual 
similarly casl structured specifications rename components units 
wellformedness conditions little complicated renamed symbols signature unit rename di erent symbols name share unit term apply renaming 
sharing diagram expanded adding target signature morphism induced renaming new symbol traced origin obvious way 
renamed unit denotes structure target signature interpretation symbol interpretation original name original structure 
casl structured specifications revealing renaming may combined 
formedness hiding renaming impose additional correctness conditions 

instantiation fitting morphisms hiding renaming may adjust names unit components required 
instance consider specification conditions complex presence subsorts see cofi smt 
bidoit sannella tarlecki spec sorts num stack ops num succ num num empty stack push num stack stack pop stack stack top stack num axioms 
natural refinement architectural specification spec elem sort elem spec sorts elem stack ops empty stack push elem stack stack pop stack stack top stack elem axioms 
arch spec units num st elem result st reveal num elem elem num neutral names parameter st indicate potential re usability 
easy come situations instantiate unit number di erent ways 
application particular unit involve renaming names match renaming application recover original names 
furthermore st depend sort elements num extra operations available num absent result application 
want able push empty stack say resulting unit need put back additional operations 
pattern extracting part unit renaming components appropriately reveal num elem feed argument generic unit st renaming components result back elem num combine original unit occurs frequently deserves special construct 
analogy instantiation generic specifications casl provide application generic unit argument fitting morphism 
example written arch spec units num st elem result st fit elem num symbol map expands signature morphism exactly way instantiation generic specifications 
particular allow compound identifiers treated just 
spec sorts elem stack elem ops empty stack elem push elem stack elem stack elem pop stack elem stack elem top stack elem elem axioms 
architectural specifications casl arch spec units char num st elem result st fit elem char st fit elem num result unit term builds unit includes units char num distinct stack sorts stack char stack num separate sets operations names overloaded profiles distinct distinguish 
instantiation fitting morphism just abbreviation expanded form explicit reduction renaming amalgamation 
particular instantiation formed component names introduced generic unit part parameter occur actual parameter 
sharing occurrences symbol ensured amalgamation implicit instantiation formed 
requirement separation body generic specification actual parameters imposed extra static condition case structured specifications 

generic unit expressions far provided means building generic units 
usual simply notation 
restrict functions non generic units higher order generic units available 
example arch spec decompose units sp sp sp sp result sp builds unit realizes specification sp sp expression sp correct context correct expansion sp similarly formedness 
environment matches sp sp show simple example construct recall specifications sections 
architectural specification contained anonymous generic unit specification section indicated may replaced general unit auc architectural specification formally captured forming architectural specification arch spec unit auc result auc fit elem num transform code refinement see section discussion refinement specifications generic units fitting morphism injective expansion bit involved indicated principle applies 
symbol generic unit originates import unit shares actual parameter 
bidoit sannella tarlecki 
refinements architectural specifications section indicated specification may refined architectural specification 
semantic notation introduced subsequent sections related semantic correctness condition expressed follows sp units 

result sp context built declarations units 
un definition views class result units denote context unit declarations definitions visible external meaning architectural specification 

architectural specifications refined 
simple refining specifications declared units separately 
specifications generic units 
form sp sp omitting possibility multi argument generic units 
clearly refinement preserve genericity question sp sp sp sp need signatures agree sig sp sig sp sig sp sig sp 
furthermore specifications closed structures need generic unit realizes sp sp correctly realize sp sp consistent specifications sp sp amounts requiring sp sp sp sp sp 
notice condition slightly weaker obvious sp sp take advantage fact applying unit arguments realize sp refinement specifications generic units fact special case refinement introduced section sp sp sp sp sp sp sp sp modeled generic units partial functions required defined models argument specification explained section 
allows linear development individual units declared architectural specification 
allow decomposition refine unit specifications architectural specifications 
closed units covered 
specifications generic units may refined architectural specifications 
di erence architectural specifications generic result units introduced section 
semantics generic result unit term defined context unit declarations yields class functions included class functions denoted generic unit specification refined 
ect development tree just sequence refinement steps 
target 
leaf tree may developed independently full machinery decomposition architectural design development subtree node may replaced development tree ecting parts long new development subtree correct respect specification root 
discussion implicit architectural specifications need refined 
specifications declared units architectural specification subject refinement architectural specification merely prescription separate independent development units description combine resulting individual pieces desired result 
quite satisfactory methodological point view refinement concept necessary achieve goals 
argue specifications units architectural specification refined refinement architectural specification obtained textually replacing unit specifications respective refinements 
theorem theorem 
asn architectural specification architectural specifications casl arch spec asn units sp sp sp sp result assume asn implicit generic specifications involved unit specifications imports consistent 
context built unit declarations asn assume unit terms involved particular result unit term formed correct 
asn architectural specification obtained asn textually replacing unit specifications refinements 
sp sp sp sp sp sp sp sp arch spec asn units sp sp sp sp result context built unit declarations asn unit terms involved particular result unit term formed correct asn asn theorem shows refinements entire architectural specifications expected provided implicit generic specifications involved unit specifications imports consistent 
assumption dropped shown counterexample assume int usual specification integers equipped predicate specified usual way arch spec units int op int axiom op int axiom result arch spec units int op int axiom op int axiom result architectural specification inconsistent built unit consistent 
specification unit correct refinement specification semantically correct refinement 
important note problem arises inconsistency implicit generic specification involved declaration 
replaced explicit generic specification consistency condition required refinement inconsistent specification generic inconsistent specification 

comments discussed issue designing structure system developed specification 
apart usual mechanisms structuring requirements specifications bidoit sannella tarlecki need separate mechanism describe modular structure system developed 
casl provides form architectural specifications 
basic ideas concept full design architectural specifications casl 
semantics architectural specifications sketched see cofi details 
level detail presentation su cient state basic facts semantics argue properties architectural specifications ensure basic goals design achieved 
architectural specifications possible describe structure system developed listing units built providing specifications indicating way combined form complex unit 
units correspond generic non generic modules possibilities adequately specify provided 
architectural specification internal correctness checked ensured properties resulting module calculated check original requirements specification fulfilled design 
developments units required may proceed independently need check results compatible brings benefits modular development 
ideas specific context casl 
idea constructs architectural specifications largely independent details underlying casl logical system 
fact context arbitrary institution gb equipped extra structure handle specific presentations signature morphisms reducts renamings deal issues sharing structures amalgamated 
details notion institution appropriate full semantics institution independent casl structured specification architectural specification mechanisms mos cofi 
issue omitted behavioural implementation sch st nos st bh 
idea realizing specification really necessary provide model su cient provide structure behaviourally equivalent model 
intuitively structures behaviourally equivalent distinguished computations involving predicates operations provide 
casl structures formally captured requiring structures satisfy exactly definedness sentences predicate applications general form equations terms distinguished observable sorts taken account may reduced introducing extra predicate symbols general form needed local analysis specifications generic units parameter sorts taken potentially observable 
generic units behaviourally equivalent yield behaviourally equivalent structures argument 
structure built realize specification behavioural equivalence convenient pretend true model specification 
instance generic unit behaviourally satisfy specification require applied arguments model parameter specifications result application models result specification behavioural equivalence 
pretend arguments truly satisfies specification ensure built result satisfies specification behavioural equivalence 
sound provided available constructions structures generic units developed map behaviourally equivalent arguments behaviourally equivalent results 
precisely generic unit stable behaviourally equivalent arguments provided fitting morphism results instantiations unit behaviourally equivalent 
important formulation arguments considered may built larger signature just argument signature unit models fact unit may richer contexts 
units stable su cient check local behavioural correctness unit terms defined correctness section allows arguments generic units fit corresponding parameter specifications behavioural equivalence 
ensured properties formed locally behaviourally correct unit term context calculated exactly section justified theorem theorem 
context unit term formed locally behaviourally correct 
environment matches behavioural equivalence generic units stable behavioural equivalence 
cofi particular language design task group discussions opportunities improve ideas architectural specifi architectural specifications casl cations 
till mossakowski comments draft 
partially supported crit funded esprit french polish project cnrs pas cooperation programme mb epsrc gr ds cofi esprit working group mb ds 
theme structure modularity 
rod burstall fundamental contributions topic deep impact 
apparent 
issue modular structure algebraic specification development surfaced joseph goguen clear cat 
idea imposing modular structure design semantics language abstracting away details small language features originated institutions 
rod influential design innovative modularization facilities programming languages pebble butler lampson contribution design standard ml 
ds indebted rod years inspiring unconventional leadership collaboration stimulation friendship 
ada ada manual language standard libraries version 
international standard iso iec 
www com rm 
astesiano bidoit kirchner krieg bruckner mosses sannella tarlecki 
casl common algebraic specification language 
appear theoretical computer science 
ag allen garlan 
formal basis architectural connection 
acm transactions software engineering methodology july 
bw bauer 
algorithmic language program development 
springer 
bid bidoit 
stratified loose approach generalization initial loose semantics 
selected papers th workshop specification data types 
springer lncs 
bh bidoit 
general framework modular implementations modular systems 
proc 
th joint conf 
theory practice software development orsay 
springer lncs 
bh bidoit 
modular correctness proofs behavioural implementations 
acta informatica 
bst bidoit sannella tarlecki 
architectural specifications casl 
proc 
th intl 
conf 
algebraic methodology software technology amast 
springer lncs 
bg burstall goguen 
putting theories specifications 
proc 
th intl 
joint conf 
artificial intelligence cambridge 
bg burstall goguen 
semantics clear specification language 
proc 
advanced course software specifications copenhagen 
springer lncs 
bl burstall lampson 
kernel language data types modules 
information computation 
cofi common framework initiative 
catalogue existing frameworks 
www brics dk projects cofi catalogue 
cofi common framework initiative 
cofi common framework initiative algebraic specification development www pages 
www brics dk projects cofi 
cofi cofi task group language design 
casl common algebraic specification language summary version 
www brics dk projects cofi documents casl summary 
cofi cofi task group semantics 
casl common algebraic specification language semantics 
appear 
em ehrig mahr 
fundamentals algebraic specification equations initial semantics 
springer 
fac formal aspects computing 
special issue module facilities specification languages 
fl fiadeiro lopes 
semantics architectural connectors 
proc 
colloq 
formal approaches software engineering joint conf 
theory practice software development tapsoft lille 
springer lncs 
fj fitzgerald jones 
formal description database system 
proc 
vdm conference kiel 
springer lncs 
gb goguen burstall 
cat system structured elaboration correct programs structured specifications 
technical report csl sri international 
gb goguen burstall 
institutions model theory specification programming 
journal assoc 
computing machinery 
gh guttag horning 
larch languages tools formal specification 
springer 
guttag horning wing 
notes putting formal specifications productive 
science computer programming 
bidoit sannella tarlecki hn 
behavioural algebraic framework modular system design reuse 
selected papers th workshop specification data types de 
springer lncs 
klin ho man tarlecki schroder mossakowski 
checking conditions casl architectural specifications 
proc 
international symposium mathematical foundations computer science mfcs 
springer lncs 
ks krieg bruckner sannella 
structuring specifications large small higher order functions dependent types inheritance spectral 
proc 
colloq 
combining paradigms software development joint conf 
theory practice software development tapsoft brighton 
springer lncs 
ma morris ahmed 
designing refining specifications modules 
proc 
rd refinement workshop park 
springer workshops computing 
mos mosses 
cofi common framework initiative algebraic specification development 
proc 
th intl 
joint conf 
theory practice software development lille 
springer lncs 
mos till mossakowski 
specifications arbitrary institution symbols 
developments algebraic development techniques th international workshop wadt chateau de bonas france 
springer lncs 
nos navarro orejas sanchez 
correctness modular systems 
theoretical computer science 
pau paulson 
ml working programmer nd edition 
cambridge univ press 
smt schroder mossakowski tarlecki ho man klin 
semantics architectural specifications casl 
proc 
fundamental approaches software engineering fase genova 
springer lncs 
sst sannella tarlecki 
formal development programs algebraic specifications parameterisation revisited 
acta informatica 
st sannella tarlecki 
formal development ml programs foundations methodology 
proc 
rd joint conf 
theory practice software development barcelona 
springer lncs 
st sannella tarlecki 
essential concepts algebraic specification program development 
formal aspects computing 
sw sannella wirsing 
kernel language algebraic specification implementation 
proc 
intl 
conf 
foundations computation theory 
springer lncs 
sw sannella wirsing 
specification languages 
chapter algebraic foundations systems specification eds 
astesiano 
kreowski krieg bruckner 
springer 
sch 
data abstraction correctness modular programming 
ph thesis report cst dept computer science univ edinburgh 
