consistency management optimistic replication algorithms optimistic replication algorithms allow replica contents stale controlled way 
return far efficient available traditional replication algorithms keep replicas consistent especially network computers unreliable 
optimistic replication grown due proliferation internet mobile computing devices systematic study begun 
report surveys optimistic replication algorithms 
particular focuses mechanisms propagating updates replicas studies affect functional characteristics systems including data consistency guarantees performance 
distributed computing systems replicate objects multiple nodes improve availability performance 
replication improves availability allowing access objects nodes functional 
replication improves performance letting users access data nearby node avoid remote network access idle site achieve better load balance 
replication algorithm core replicated service responsible reading updating replicas physical copies object 
important design issue replication replicas users 
traditional pessimistic replication algorithms offer single copy semantics give users illusion having single highly available copy object keeping replicas identical time 
called pessimistic algorithms prohibit accesses replica replica contents provably date 
algorithms essential class applications banking give correct answers time cost ma yasushi saito june jor drawback stringent hardware requirements 
example primary copy fail algorithm popular pessimistic replication algorithms assumes accurately distinguish crashed node live unresponsive node reliably re elect primary replica fail 
distinction theoretically impossible probabilistically possible investing redundant network hardware capacity computers 
optimistic replication algorithms allow data users stale controlled way 
key feature separates optimistic replication algorithms pessimistic counterparts way updates objects handled pessimistic algorithms update replicas possibly block read requests users update application optimistic algorithms propagate updates background allow replica read directly time 
feature optimistic algorithms available efficient unreliable network media inexpensive computers 
optimistic replication new idea example magnetic tape backup decades crude form optimistic replication grown due proliferation internet mobile computing devices 
systematic treatments optimistic algorithms including study efficient update transfer replica consistency management mechanisms begun 
report surveys optimistic replication algorithms 
particular focuses update propagation mechanisms invented optimistic replication study mechanisms affect functional characteristics system including data consistency guarantees performance 
remainder section overview advantages applications optimistic replication 
classify optimistic replication algorithms update propagation strategies update issued transferred update trans update discuss choices strategy affect systems usability functional characteristics 
introduce challenges optimistic replication algorithms face replica consistency management performance scaling 
advantages optimistic replication optimistic replication algorithms advantages pessimistic algorithms letting replica contents diverge 
key advantage fault tolerance 
optimistic algorithms slow unreliable network links propagate updates replicas background blocking accesses replicas 
contrast pessimistic counterparts disallow accesses replicas stores newest content 
related advantage networking flexibility 
optimistic algorithms intermittent incomplete network links allowing updates exchanged pair nodes 
property essential mobile environment nodes communicate occasionally unpredictably 
services deploy optimistic replication algorithms fault tolerance networking flexibility lets system built inexpensive failure prone hardware maintain consistency data :10.1.1.116.6208
optimistic algorithms improve site autonomy requiring coordination sites 
example services ftp mirroring allow replica added administrative change existing replicas 
applications optimistic replication optimistic replication particularly attractive environments communication sites slow unreliable 
usenet wide area bulletin board system deployed oldest popular optimistically replicated service 
usenet consists thousands servers connected ad hoc way 
server replicates news articles user read article nearest server 
news incomplete links allow replica communicate subset peer replicas 
practice usenet server stores subset newsgroups conserve network bandwidth storage space 
articles specific newsgroup replicated servers subscribe newsgroup 
articles propagated servers periodic flooding inter server links 
periodic article propagation creates delay article posted server reaches long week 
delay confuses users accept reasonable cost pay usenet excellent availability 
optimistic replication improve performance availability wide area distributed data services www ftp directory services xerox clearinghouse dns active directory grapevine :10.1.1.156.7859:10.1.1.21.1584
optimistic replication attractive reasons 
replicate data unreliable network links 
second operate tight budget 
data inconsistency inherent services dns explicitly allow stale data users replication algorithm loose consistency guarantee degrade service quality 
optimistic replication key enabling technology mobile computing systems need replicate data portable devices 
allow users read update data disconnected merging modifications nodes reconnect 
applications similar demands include mobile file systems coda roam mobile mail systems bayou lotus notes :10.1.1.12.448
taxonomy optimistic replication algorithms report focus optimistic algorithms keep replicas consistent 
admittedly legitimate approaches study optimistic replication algorithms including type consistency guarantees resolution update conflicts 
chose focus mechanical aspects algorithms broad impact systems performance consistency guarantees sections classify optimistic replication algorithms broadly axes update issued transferred update transfers update 
update issued update transfer model update transfer model determines update issued propagated 
single master systems statically designate replica master stores authoritative copy object 
updates accepted master propagated replicas slaves 
multi master systems replica issue update time exchange merge updates replicas background 
main advantage single master systems simplicity 
updates accepted place single master systems detect report update conflicts users immediately making system confusing users 
simpler algorithmically updates flow way master slaves 
disadvantage single master systems master single point failure 
multi master systems move available systems 
sides addition algorithmic complexity lost update problem may lose effects updates update conflicts detected updates accepted replicas users issued long logged system 
transferred update unit transfer change object expressed new object contents semantic description log 
systems exchange contents called systems systems exchange log called log transfer systems 
consider bibliography database example 
author field updated replica contents transfer system transfer entire database contents replicas log transfer system transfer description update 
update bibliography set author herman melville title moby dick log transfer owns advantages 
log transfer handle update conflicts flexibly especially multi master systems 
example updates modify authors different books merged trivially log transfer systems choice asking user resolution discarding update contents transfer systems 
second evident example log transfer reduces computational networking overhead especially object size large update small 
side log transfer systems tend complex contents transfer systems reasons 
replica remember history updates addition replica contents 
needs complex disk data structures maintaining log algorithm trimming log entries conserving space section 
second maintain replica consistency system determine set updates sent replicas order updates applied 
third updates described semantically log transfer difficult implemented transparently applications systems attempt separate application dependent logic replication algorithm reusable 
transfers update direction transfer direction transfer determines replica responsible transferring updates 
pull algorithms replica responsible polling replicas downloading new updates push algorithms replica pending update responsible delivering update replicas 
pull systems send update replica twice set updates received determined precisely polling 
pull systems suited environments network bandwidth scarce 
addition replica needs keep track state pull systems set update received state replica obtained polling 
property pull systems attractive internet environments replicas managed autonomously ftp mirroring usenet article caching 
hand systems computationally efficient obviate periodic polling replicas communicate object updated 
furthermore reduce update propagation delay especially fully connected networks pushing updates immediately issued 
push transfer attractive sys tems fully connected environments examples include nis usenet relational database systems 
summary classifying existing optimistic replication systems shows existing optimistic replication systems classified 
general systems left side simpler inefficient systems right versatile complex 
challenges optimistic replication algorithms face main challenges keeping replicas consistent scaling performance 
challenges unique optimistic replication complicated algorithms updates issued multiple replicas time optimistic algorithms discover update conflicts long updates issued 
maintaining replica consistency maintaining consistency replica controlling quality replica contents crucial function replication service 
definition optimistic replication algorithms guarantee strict single copy consistency 
challenge define type replica consistency algorithm guarantee implementation follows naturally type guarantee 
distinguish types replica consistency guarantees system provide report eventual consistency view consistency 
eventual consistency eventual consistency demands consistency replicas quiescent environment 
words guarantees current state replicas new update issued replicas communicate freely long period contents replicas identical eventually 
eventual consistency important reasons 
minimal requisite replication algorithm guarantee replica contents may remain corrupted forever making system practically useless 
second eventually consistent coda transfers contents ordinary files log directories 
service usually best effort disseminate updates quickly replicas best effort strong practical applications 
design choices exist eventual consistency achieved updates may issued concurrently example order updates totally partially user specify ordering system determine ordering automatically 
discuss issues section 
view consistency eventual consistency provides little guarantee quality data replica contents eventually converge give means little users 
goal view consistency guarantees control quality data intervening replica read update requests 
guarantee optional fact systems serve arbitrarily stale data users 
view consistency includes causal consistency preserves partial orderings read write requests bounded inconsistency explicitly limits degree replica inconsistency 
example causal consistency consider replicated password database 
user may change password replica fail log replica new password change reached replica 
problem avoided having causal read guarantee read request honor past updates user 
airline seat reservation system example bounded inconsistency guarantee useful 
airline companies allow overbooking streamline reservation system airline operations limit degree overbooking avoid hurting reputation 
discuss view consistency maintenance detail section 
scalability optimistic replication algorithms perform efficiently large workload practically useful 
size workload grows axes object size number replicas number objects 
axes orthogonal example algorithms scale replicas large objects 
optimistic replication single master multi master contents log 
simple efficient versatile contents log pull push pull push pull push pull push ftp nis oracle roam usenet bayou agrawal www sybase palm active golding wuu mirror coda directory dns porcupine :10.1.1.156.7859:10.1.1.116.6208

systems wide area data directory wide area directory database mobile db file system wide area data service mobile db file system wide area appl 
directory area service 
classification existing optimistic replication systems 
space efficiency system important performance 
replication algorithms maintain data structures object contents log updates names replicas data structures small able trimmed necessary leave maximum amount space users want object contents 
structure report section surveys optimistic algorithms handle challenge maintaining replica consistency 
particular decompose problem sub problems distributing updates ordering updates detecting reconciling updates describe various classes algorithms solve problems 
section discusses optimistic algorithms handle challenge scaling performance 
study issue dimensions scaling large objects scaling replicas scaling objects survey techniques proposed helping system scale large workload 
argue performance optimistic replication algorithms largely determined update propagation strategy 
show system performance requirements supporting replicas unreliable links determine type algorithm uses 
section concludes report discussing open issues satisfactory solutions 
maintaining replica consistency section surveys techniques maintaining types replica consistency guarantees eventual consistency guarantee view guarantee 
maintaining eventual consistency section discusses methodologies maintaining eventual replica consistency various classes update propagation strategies introduced section 
start pull transfer systems 
section show push transfer algorithms derived pull transfer systems techniques blind pushing state estimation 
problem maintaining eventual replica consistency broken set subproblems 
algorithms introduced section breakdown 

distributing updates replicas 

determining order update application 

detecting reconciling conflicts updates 
pull single master systems single master systems designate replica master responsible accepting applying changes 
replicas slaves receive changes master 
replica consistency management trivial systems 
contents transfer update propagation usually implemented simplified variation thomas write rule section 
replica stores timestamp shows time contents modified 
slave replica obtains master timestamp periodically downloads master replica contents timestamp older master log transfer equally easily implemented remembering update applied replica 
updates accepted master update ordering conflict detection handled master replica common database concurrency control techniques phase locking optimistic concurrency control 
pull multi master log transfer systems multi master log transfer algorithms versatile complicated optimistic replication algorithms 
maintaining eventual consistency systems complicated multiple updates may issued simultaneously different replicas may reach replicas arbitrary order 
distributing updates replicas timestamp vectors multi master replication algorithms ensure replica receives updates issued replicas original issuers updates directly reachable 
requirement called update transfer essential mobile environments network links usually incomplete important fully connected environments avoid node failure stalling update propagation entire system 
naive algorithm achieving update transfer replica log updates receives send entire log replicas periodically demand 
time replicas communicate indirectly replicas receive updates 
notice concerned replicas communicate 
example mobile environment replica communication topology determined users meet synchronize devices 
internet services replica communication topology set ad hoc semi static way human negotiation 
far replicas communicate indirectly algorithm distribute updates replicas 
naive algorithm obvious downside slower consumes disk space accumulates updates 
timestamp vector technique pull systems minimize number updates exchanged replicas 
replica keeps disk timestamp vector tv element array timestamps summarizes state replica 
total number replicas system timestamp number increases monotonically logical clock wall clock counter increments update issuance may suffice :10.1.1.113.3013
tv replica shows time update issued replica tv called replica timestamp 
update exchanged replicas associated issuer timestamp moment issuance 
elements tv meaning tv replica replica received updates issued replica timestamps shows update propagation procedure timestamp vectors 
propagate updates replica replica replica sends timestamp vector tvi replica replica compares tvi timestamp vector element element 
tvi replica sends replica updates issued replica stored timestamps larger tvi 
process ensures replica receives updates stored replica absent replica replica receive update received 
updates sent tvi replica set pair wise maxima tvi 
swapping roles replica receive updates replica replicas set updates 
timestamp vector useful just update propagation 
efficient mechanism estimating state remote node number degree events happened node 
applications timestamp vectors include write conflict detection section update ordering section update log truncation section 
replicas assumed named numbers 
ordering updates having replicas receive set updates achieve eventual consistency multi master systems replicas may receive updates different order 
replicas sort apply updates defined order 
describe approaches update ordering distributed protocols informing replicas progress update propagation order updates totally semantic relationships updates order updates partially 
total update ordering eventual consistency achieved naturally forcing replicas apply updates order 
overview techniques developed replicas agree total update ordering 
approach proposed golding uses ack vectors learn status replicas 
ack vector av element array timestamps exchanged replicas updated just timestamp vectors 
av replica defined min tv received updates newer av regardless issuers 
likewise av replica represents conservative estimate newest update received replica updates timestamps older min av guaranteed received replicas sorted timestamps applied replica 
technique requires replicas timestamps advance roughly speed 
replica slow timestamp may stall progress ack vectors replicas keeping min tv increasing 
golding algorithm uses loosely synchronized wall clocks timestamps :10.1.1.113.3013
second approach proposed bayou designates replica home 
home replica unilaterally totally orders updates order chooses 
home replica assigns monotonically increasing commit sequence number csn ordered update 
mappings updates timestamps propagated back replicas piggybacking ordinary update messages 
notice difference bayou home node master node single master replication systems 
bayou home replica responsible update ordering updates transferred pair nodes single master systems master node responsible update issuance ordering propagation 
third approach proposed deno adapts quorum consensus protocol optimistic environment 
administrator deno ballot certain weight replica sum ballots held replicas 
update associated vote increases replica ballot received replica 
application update deferred vote exceeds 
multiple updates circulate replicas simultaneously win vote discarded silently 
update circulates replicas twice deno collect votes inform replicas vote passage 
protocol totally orders updates order acquire majority votes 
approaches trade offs 
advantage approach decentralized aborts updates 
downside single dead replica may hamper progress replicas problem worsens number replicas increases 
bayou home algorithm alleviates livelock problem long home replica functional order updates 
flexible home replica resolve update conflicts way regard replicas 
hand bayou algorithm complicated golding deno supports spectrum degree centralization assigning entire ballot single replica deno behave bayou assigning equal weight replica deno behave traditional voting scheme 
downside deno allows update outstanding time updates fail win majority votes aborted 
suited applications experience large communication delay high update frequency 
partial update ordering intuitive total update ordering disadvantages 
may delay update application unnecessarily ignores semantic relationships updates update commutativity 
second total ordering preserve dependencies updates issued different replicas 
example consider source code management database library module modified replica application program modified replica way depends new library module 
case want library update applied application update replicas may mix updates unrelated modules 
constraint expressed total update ordering mechanisms 
systems address shortcomings total ordering advantage update commutativity 
example additions subtractions numeric value file creations directory applied order produce result 
idea commutative updates extended concept causality 
causality partial ordering defined updates specifies conditions form update applied update 
systems user specify causality explicitly 
systems introduce session persistent record encapsulates history object accesses particular user new update issued user considered depend causally previous updates recorded user session 
earliest implementation causality attached update set names timestamps causally preceding updates delayed update application causally preceding updates applied 
naive solution disadvantage size update grows unboundedly depends preceding updates 
systems solve problem compressing preceding updates set grouping updates issuers picking newest update group 
system guarantees updates issued replica propagated order issuance case timestamp vectors dependency compression algorithm achieves effect earlier naive solution 
detecting reconciling conflicting updates updates conflict replica issues update receives update circulating replicas situation easily detected timestamp vectors follows 
remember replica timestamp vector dominates replica strictly newer sense received updates 
detect update conflicts sys report defines update conflicts syntactically 
example room reservation example concurrent reservation requests different rooms conflict definition common sense 
timestamp dominates element timestamp older tem attaches update issuer timestamp vector moment issuance notice original timestamp vector algorithm described section system attaches issuer timestamp update 
update timestamp vector dominates updates conflict issued issuer received update 
updates conflict 
update conflicts affect eventual consistency object conflict detection purely user convenience 
consider conference room reservation system example 
people submit reservation requests room time slot system easily maintain eventual consistency accepting request ignoring 
people informed conflict able negotiate schedule 
resolving conflicts fundamentally 
conflicts creating different files directory resolved simply merging previous room reservation example need resolved manually 
pull multi master contents transfer systems section discusses multi master contents transfer systems maintain eventual consistency 
propagate order updates contents transfer systems need agree replica newest transferring contents newest replica bring replicas date 
introduce thomas write rule simple protocol determine newest replica contents 
describe algorithms applications detect update conflicts 
thomas write rule thomas write rule gets name seminal introduced algorithm pessimistic voting replication widely optimistic replication systems 
associates replica timestamp usually loosely synchronized wall clock counter lotus notes shows time replica modified :10.1.1.113.3013
replica obtains peer replica timestamp periodically demand downloads peer contents timestamp older peer time replicas communicate indirectly replicas converge newest contents 
object deletion requires special treatment thomas write rule timestamp read deleted replica 
solutions proposed solve problem 
solution simply require human intervention delete objects dns nis 
second solution keep timestamps contents deleted replicas disk 
timestamps called death certificates 
third solution proposed porcupine mail server propagates update phases :10.1.1.116.6208
phase update disseminated replicas 
update record logged disk separately replica contents acts update deletes object 
replicas confirm reception update separate retirement notices circulated replicas delete update record 
detecting update conflicts thomas write rule shortcoming conflicting updates silently discarded newest 
systems designed multi user collaboration coda roam locus need know updates conflict notify users :10.1.1.12.448
applications combine timestamp vectors contents transfer 
systems thomas write rule associate replica timestamp vector tv timestamp 
tv replica shows time update issued elements tv updated merging replicas timestamp vectors section 
timestamp vectors defined way detect update conflicts technique introduced section 
systems offer alternative solution naturally extending thomas write rule 
scheme update associated issuing node timestamp just update issuance 
receiver side replica timestamp differs attached update update considered conflict previously applied receiver side replica 
simpler technique timestamp vectors technique may report conflict receiver side replica misses older updates 
push transfer systems push transfer systems derivatives counterparts 
pull push systems differ way updates distributed 
issues including update ordering conflict detection reconciliation addressed techniques developed pull systems 
pull transfer algorithms discussed far associate replica timestamp similar timestamp vector represent state replica 
replica retrieve peer replica timestamp discover set updates contents downloaded 
hand push transfer systems identify set updates sent replica contact 
achieved ways blindly pushing new updates estimating state replicas 
blind pushing blind pushing scheme replica update blindly delivers update replicas communicable 
approach simple effective services connect replicas way update flows fixed path received replica twice 
single master systems usenet relational database systems porcupine mail server examples services blind pushing 
receiver side replica uses pull transfer mechanisms thomas write rule usenet porcupine filter duplicate updates 
state estimation techniques blind pushing obvious downside sends duplicate updates replica communicates replicas 
problem alleviated letting replica estimate state push updates missing remote replica 
example state estimating techniques timestamp matrices multi master log transfer systems 
timestamp matrix tm stored replica matrix timestamps number replicas timestamp defined section 
tm replica holds timestamp vector rows tm shows replica conservative estimate timestamp vectors replicas 
put way tm replica knows replica received updates issued replica timestamps update propagation process similar timestamp vectors 
difference sending updates replica sender uses tm estimate replica timestamp vector receiving vector replica receiver side replica timestamp matrix updated computing pairwise maxima sender matrix piggybacked update message 
timestamp matrix reduces number duplicate updates totally eliminate duplicate updates completely replicas receive update simultaneously may send update replica twice 
thomas write rule extended naturally push algorithm similar technique node maintain vector timestamps tmv conservatively estimates timestamp replicas 
replica sends contents replica tmv tmv replica active directory replicated hierarchical directory service provided windows uses algorithm similar 
difference active directory replicates objects site node name space tree object vector estimates largest timestamp objects replicated site 
trading replica consistency update application delay algorithms described far delay applying updates final application order determined 
slower communication replicas replicas longer update application delayed 
problem alleviated applying updates tentatively soon arrive 
tentative order turns different final order updates undone re applied correct order necessary 
tentative updates allow user see date contents price occasional confusion undone re applied 
tentative updates single master systems user update slave replica disconnected master :10.1.1.116.1182
tentative updates pose implementation challenges 
updates need able undone possible especially interact real world firing missile paying money 
second problem applicable multi master systems number increases number replicas resulting large computational cost section 
managing view consistency optimistic replication algorithms definition ensure strict replica consistency 
eventual consistency guarantees replica consistency hypothetical quiescent state offers little clue users regarding quality replica contents 
replicated data services fine just eventual consistency guarantee semantic limitations network protocols 
porcupine mail server usenet examples services replica inconsistency worse potential problems caused smtp email nntp usenet delay delivery duplicate messages :10.1.1.116.6208
hand services replicated password database example illustrated section weaker forms data guarantees provide visible benefit users 
section overviews proposals weaker replica consistency guarantees implementations 
causal consistency preserving causal orderings accesses especially helpful avoiding consistency anomalies confuse users 
types causal consistency guarantees proposed depending reads writes interact read writes monotonic reads writes follow reads monotonic writes 
writes follow reads monotonic writes forms causal write consistencies covered section 
read writes guarantees contents read replica incorporate previous writes user 
password example illustrated section example writes guarantee beneficial 
monotonic reads guarantees successive reads user return increasingly date contents 
guarantees trivial provide user accesses single replica tricky user roams multiple replicas 
view consistency roaming environments implemented technique maintaining causal update consistency section 
read request associated compressed representation set causally preceding read update requests 
request satisfy causality constraint ei ther rejected outright delayed replica receives updates satisfy constraint 
bounded consistency systems user specify maximum degree inconsistency allowed replica access 
systems quasi copies dns www measure inconsistency real time guarantee newest object contents propagated replicas fixed period :10.1.1.21.1584
advantage approach simplicity combination single master replication periodic polling pushing naturally achieves guarantee 
downside practical single master replication systems highly reliable network links 
different line studies suggests specifying amount inconsistency terms number updates read overlap terms semantic metrics example dollars amount bank account 
improve performance non replicated database systems increasing locking concurrency studies suggest applying replication improve performance enrich consistency semantics 
earlier area implemented relaxed phase locking reads writes datum granted certain conditions applicable mobile wide applications designed intermittent network links 
study suggests forced pushing pulling updates replicas ensure degree inconsistency replicas bounded 
scaling optimistic replication systems section studies performance space efficiency optimistic replication algorithms 
discuss computational networking overhead systems axes workload scaling large objects large number replicas large number objects 
discuss storage requirement systems efforts curtail storage consumption 
scaling large objects scaling large objects determined transferred update section 
log transfer systems support large objects better cost depends frequency size updates size object 
hand cost contents transfer systems increases linearly object size 
techniques proposed alleviate problem losing simplicity contents transfer systems 
optimistic delta technique originally developed www latency reduction speculatively sends difference new old object contents falls back full contents transfer remote replica contents match sender technique saves network bandwidth computational cost 
technique divide object hierarchically structured set subobjects thomas write rule level hierarchy rabinovich algorithm lotus notes active directory 
technique extended allow site replicate just sub tree hierarchy reduce cost replication roam 
scaling large number replicas system ability support replicas determined update transfer model described section 
supporting replicas presents different problems single master multi master systems 
propagation delay load imbalance having replicas increases update propagation delay creates load imbalance replicas 
problem especially serious systems master replica propagates updates slaves 
problem fortunately alleviated easily 
solution organize replicas tree form place master root updates ripple tree root 
cuts propagation delay logn number replicas reduces load master replicas constant level 
multi master systems roam usenet active directory push idea connect replicas tree structure supplemented short cut paths improve availability update propagation speed 
technique employs unreliable multicast protocol digital fountain distribute updates efficiently common case back slower reliable algorithm described section 
increased update conflicts gray argues multi master replication algorithms scale large number replicas experience update conflicts section single master systems experience update conflicts number replicas :10.1.1.116.1182
addition confusing users increased update conflicts leads increased updates larger computational overhead system supports tentative update application section 
gray important assumption derive data item updated replicas 
assumption hold universally example write sharing unix file systems known rare clear severe scalability problem practice 
assuming equiprobable data access problem inherent multi master systems satisfactory solution 
proposed remedies include single master replication support tentative updates contents transfer mechanism resolve update conflicts efficiently simple overwriting 
scaling large number objects existing optimistic replication systems designed manage single object node reasons exist replicating objects node 
reason replicate just portion large database conserve disk space natural solution divide database small pieces replicate selectively 
reason demonstrated porcupine mail server mix match replicas objects node mask system heterogeneity differences disk capacity cpu speed achieve better load balance :10.1.1.116.6208
theory single object replication algorithm described far support multiple objects simply running instances algorithm parallel 
technique cheap single object may prohibitively expensive objects 
periodic polling performed pull systems example 
number polls node pull systems increases nx mean number replicas object number replicas stored node pull systems expensive node replicates objects 
systems support objects active directory usenet porcupine mail server push algorithms :10.1.1.116.6208
controlling space overhead replication algorithms keep types data structures disk addition object contents maintain replica consistency 
examples include timestamp vectors matrices keep track state replicas sections keep track deleted objects section update log section 
section examines space overhead data structures overviews strategies reducing overhead 
timestamp overhead table summarizes amount space occupied timestamp related data structures replica various optimistic replication algorithms 
overhead due timestamps usually negligible timestamp matrices timestamp occupies just bits disk space 
study proposes reducing overhead timestamp matrices collapsing rows corresponding remote replicas column wise minimum 
scheme reduces accuracy estimation state remote nodes potentially resulting duplicate update transfers 
controlling size update log log transfer systems keep log updates grows indefinitely updates accumulate time 
techniques proposed trim size update log 
technique deletes updates older predefined period month uses fixed size update log rolls old updates log fills 
second technique observation log trimming problem total update ordering problem solved discovering update received replicas 
systems variant ack vector algorithm section trim update log 
algorithm types space notes single master pull single master push master slaves 
multi master pull contents transfer thomas write rule multi master push contents transfer blind pushing porcupine usenet state estimation active directory multi master pull log transfer timestamp vector multi master push log transfer blind pushing timestamp matrix table 
amount disk space occupied timestamps various replication algorithms 
unit number timestamps 
represents total number replicas system 
contents transfer systems keep deleted objects section accumulate objects deleted 
just timestamp takes far space update log contains entire history changes replica 
reason keep system simple systems delete old simply waiting fixed period 
porcupine email server exchanges retire messages replicas immediately update propagation finished delete quickly 
summary table summarizes design optimistic replication algorithm affects scalability 
table shows axis update propagation strategy affects scalability space overhead different way 
words performance demand application dictate replication algorithm application 
example mobile database system replicates single large database replicas pick log transfer pull algorithms case 
open issues improving performance optimistic replication algorithms optimistic replication algorithms traditionally mobile widely distributed environments network bandwidth primary bottleneck 
consequently focused minimizing networking overhead ignored cpu disk overheads 
systems optimistic replication local area network environments system highly fault tolerant inexpensive hardware porcupine active directory :10.1.1.116.6208
systems save cpu cycles disk accesses network bandwidth 
issue addressed ways 
approach combine algorithms efficient algorithm common case slower fault tolerant algorithm emergency case 
examples include unreliable multicast protocols section combination distributed transactions optimistic replication 
line algorithms failed gain popularity due complexity 
second approach see investigation optimizing existing optimistic algorithms 
example algorithms timestamp vectors update log support complicated set operations retrieve updates issuer sort timestamp delete arbitrary set updates 
example tentative updates section require complex supports system undo redo operations 
efficient implementation operations issue largely ignored 
final approach design new optimistic algorithms focus cpu disk cost reduction 
seen activities area rabinovich hierarchical object decomposition porcupine selective replication :10.1.1.116.6208
scaling space large object replicas objects overhead single master multi master push dup update pull contents transfer log transfer update log table 
table shows architecture systems affect performance 
shaded entries show comparatively better choices 
tolerating wider varieties failures optimistic replication algorithms implicit assumptions failures failure quickly cause permanent damage replica state 
practice assumptions hold 
disk fill disk crash theft examples failures handled existing systems 
example algorithms timestamp vectors timestamp matrices offer way delete vector matrix entry replica corresponding entry explicitly circulating retirement notices replicas 
replica crashes recovers replicas timestamp vectors matrices contain garbage entry removed manually 
example update log log transfer systems fill replica remains long 
problem weaker variation byzantine consensus problem active area study 
existing solutions byzantine consensus applicable purpose fast fully connected network perform lock step replica synchronization 
systems solved part problem ad hoc ways 
example bayou allows update log erased time save disk space contain limited types corrupt replicas 
example porcupine allows node retire suddenly announcement 

management replicated data large scale systems 
phd thesis corpus college university cambridge august 
agrawal amr el abbadi 
epidemic algorithms replicated databases 
th acm symp 
princ 
database systems pods pages tucson az may 
alonso barbara garcia molina 
data caching issues information retrieval systems 
acm trans 
database systems tods september 
mary baker john hartman michael kupfer ken shirriff john ousterhout 
measurements distributed file system 
th symp 
operating systems principles sosp pages pacific grove ca october 
gaurav banga fred douglis michael rabinovich 
optimistic deltas www latency reduction 
usenix annual technical conference anaheim ca 
phillip bernstein hadzilacos nathan goodman 
concurrency control recovery database systems 
addison wesley 
birman joseph 
reliable communication presence failures 
acm trans 
computer systems tocs february 
birman schiper stephenson 
lightweight causal atomic group multicast 
acm trans 
computer systems tocs august 
andrew birrell roy levin roger needham michael schroeder 
grapevine exercise distributed computing 
communications acm february 
john byers michael luby michael mitzenmacher 
digital fountain approach reliable distribution bulk data 
acm sigcomm pages vancouver bc august 
john carter anand ranganathan sai 
infrastructure building distributed services 
th international conference distributed computing systems icdcs may 
miguel castro barbara liskov 
practical byzantine fault tolerance 
symposium operating system design implementation osdi new orleans la february 
tushar deepak chandra sam toueg 
unreliable failure detectors reliable distributed systems 
journal acm march 
chandy lamport 
distributed snapshots determining global states distributed systems 
acm trans 
computer systems tocs 
chankhunthod peter danzig chuck neerdaels michael schwartz kurt worrell 
hierarchical internet object cache 
usenix winter technical conference january 
dean daniels lip boon alan downing curtis gary hallmark sandeep jain bob jenkins peter lim gordon smith benny jim stamos 
oracle symmetric replication technology implications application design 
acm sigmod international conference management data page minneapolis mn may 
susan davidson hector garcia molina dale skeen 
consistency partitioned networks 
acm computing surveys 
alan demers daniel greene carl hauser wes irish john larson 
epidemic algorithms replicated database maintenance 
th acm symp 
princ 
distr 
computing podc pages santa barbara ca august 
daniel dietterich 
dec data distributor data replication data warehousing 
acm sigmod international conference management data page minneapolis mn may 
acm 
alan fekete david gupta victor nancy lynch alex shvartsman 
eventually serializable data services 
th acm symp 
princ 
distr 
computing podc philadelphia pa may 
fielding gettys mogul frystyk masinter leach berners lee 
rfc hypertext transfer protocol 
info internet isi edu rfc files rfc txt june 
fischer lynch paterson 
impossibility distributed consensus faulty process 
journal acm 
david gifford 
weighted voting replicated data 
th symp 
operating systems principles sosp pages pacific grove ca 
goel calton pu gerald popek 
view consistency optimistic replication 
th ieee symposium reliable distributed systems october 
richard golding 
weak consistency group communication membership 
phd thesis uc santa cruz december 
richard golding 
modeling replica divergence weak consistency protocol global scale distributed data bases 
technical report ucsc crl uc santa cruz february 
alex wang mark 
sybase replication server 
acm sigmod international conference management data page minneapolis mn may 
jim gray pat patrick neil dennis shasha :10.1.1.116.1182
dangers replication solution 
acm sigmod international conference management data pages montreal canada june 
jim gray andreas reuter 
transaction processing concepts techniques 
morgan kaufmann 
james gwertzman margo seltzer 
case 
workshop hot topics operating systems hotos 
james gwertzman margo seltzer 
world wide web cache consistency 
usenix winter technical conference february 
brad hammond 
merge replication microsoft sql server 
acm sigmod international conference management data philadelphia pa may 
hsu william weihl 
phase gossip managing distributed event histories 
information sciences 
johnson jeong 
hierarchical matrix timestamps scalable update propagation 
lns cornell edu jeong index directory ps june 
brian kantor phil 
rfc network news transfer protocol 
info internet isi edu notes rfc files rfc txt february 
peter keleher 
decentralized replicated object protocols 
th acm symp 
princ 
distr 
computing podc april 
anne marie kermarrec van steen andrew tanenbaum 
framework consistent replicated web objects 
technical report ir vrije may 
james kistler satyanarayanan 
disconnected operation coda file system 
acm trans 
computer systems tocs february 

nntp server small sites 
www org 
kumar michael stonebraker 
semantic transaction management techniques replicated data 
acm sigmod international conference management data chicago il june 
kumar michael stonebraker 
analysis borrowing policies escrow transactions replicated environment 
ieee sixth international conference data engineering pages 
kumar 
effects optimistic replication distributed file system 
phd thesis carnegie mellon university december 
cmu cs 
kumar satyanarayanan 
log directory resolution coda file system 
second international conference parallel distributed information systems january 
kumar satyanarayanan 
flexible safe resolution file conflicts 
usenix winter technical conference new orleans la january 
ladin barbara liskov shrira sanjay ghemawat 
providing high availability lazy replication 
acm trans 
computer systems tocs 
leslie lamport 
time clocks ordering events distributed system 
communications acm july 
kurt josh osborne joseph malcolm 
drinking multicast usenet news 
usenix winter technical conference 
ftp ftp uu net networking news muse ps gz 
mattern 
virtual time global states distributed systems 
international workshop parallel distributed algorithms pages 
microsoft 
windows server resource kit 
microsoft press 
david mills 
rfc network time protocol version 
info internet isi edu notes rfc files rfc txt march 
david mills 
improved algorithms synchronizing computer network clocks 
acm sigcomm pages london uk september 
mockapetris 
rfc domain names implementation specification 
info internet isi edu rfc files rfc txt november 
mockapetris dunlap 
development domain name system 
acm sigcomm stanford ca august 
mohan 
database perspective lotus domino notes 
acm sigmod international conference management data page philadelphia pa may 
lily maria ebling satyanarayanan 
exploiting weak connectivity mobile file access 
th symp 
operating systems principles sosp pages copper mountain december 
nakagawa 
mirroring directory hierarchy ftp 
noc jp html november 
patrick neil 
escrow transactional method 
acm trans 
database systems tods 
oracle 
oracle server distributed systems manual vol 

john ousterhout herv da costa david harrison john kunze michael kupfer james thompson 
trace driven analysis unix bsd file system 
th symp 
operating systems principles sosp pages 
scott parker gerald popek gerard allen stoughton bruce walker evelyn walton johanna chow david edwards stephen charles kline 
detection mutual inconsistency distributed systems 
ieee trans 
software engineering se 
karin petersen mike spreitzer douglas terry marvin theimer alan demers 
flexible update propagation weakly consistent replication 
th symp 
operating systems principles sosp pages st malo france october 
calton pu gail kaiser kun lung wu philip yu 
divergence control distributed database systems 
distributed parallel databases january 
calton pu avraham leff 
replica control distributed systems asynchronous approach 
acm sigmod international conference management data pages denver may 
michael rabinovich gehani alex 
efficient update propagation epidemic replicated databases 
international conference extending database technology edbt pages avignon france march 
david ratner 
roam scalable replication system mobile distributed computing 
phd thesis uc los angeles 
ucla csd 
neil rhodes julie 
palm programming developer guide 
reilly december 
yasushi saito brian bershad henry levy :10.1.1.116.6208
manageability availability performance porcupine highly scalable cluster mail service 
th symp 
operating systems principles sosp kiawah island sc december 
yasushi saito henry levy 
optimistic replication internet data services 
th international conference distributed computing disc toledo spain october 
yasushi saito jeffrey mogul ben verghese 
usenet performance study 
www research digital com wrl projects september 
sarin lynch 
discarding obsolete information replicated database system 
ieee transactions software engineering 
marc shapiro antony rowstron anne marie kermarrec 
application independent reconciliation nomadic applications 
proc 
sigops european workshop pc new challenges operating system denmark september 
mike spreitzer marvin theimer karin petersen alan demers douglas terry 
dealing server corruption weakly consistent replicated data systems 
mobicom budapest hungary september 
sun microsystems 
sun directory services administration guide 
www sun com sims docs html admin july 
terry demers petersen spreitzer theimer welch 
session guarantees weakly consistent replicated data 
proceedings international conference parallel distributed information systems pdis pages austin tx september 
douglas terry marvin theimer karin petersen alan demers mike spreitzer carl hauser 
managing update conflicts bayou weakly connected replicated storage system 
th symp 
operating systems principles sosp pages copper mountain december 
robert thomas 
majority consensus approach concurrency control multiple copy databases 
acm trans 
database systems tods june 
duane wessels claffy 
rfc internet cache protocol 
info internet isi edu notes rfc files rfc txt september 
alastair wolman geoff voelker nitin sharma neil cardwell anna karlin henry levy 
scale performance cooperative web proxy caching 
th symp 
operating systems principles sosp kiawah island sc december 
gene wuu arthur bernstein 
efficient solutions replicated log dictionary problems 
rd acm symp 
princ 
distr 
computing podc pages vancouver canada august 
jian yin lorenzo alvisi mike dahlin calvin lin 
hierarchical cache consistency wan 
nd usenix symp 
internet technologies systems pages boulder october 
yu amin vahdat 
design evaluation continuous consistency model replicated services 
th symposium operating system design implementation osdi pages san diego ca october 
description basic algorithms type update record replica issued update 
issuer timestamp moment issuance 
ts timestamp update contents stuff set update replica received 
var log set update replica timestamp vector 
var tv array 
timestamp proc reconcile peer send updates peer receive peer tv 

tv upd log issuer timestamp tv peer send upd peer 
tv tv proc receive update upd called reconcile 
foreach upd apply replica tv max tv issuer ts log log upd 
replica reconciliation timestamp vectors set update replica received 
var log set update replica timestamp matrix 
var tm array 

timestamp proc peer send updates peer 
entries tm larger tm peer return 
tm peer tm upd log issuer timestamp tm peer send upd peer 
tm peer tm send tm peer 
receive tm peer 
tm tm called proc upd foreach upd apply replica tm issuer max tm issuer ts log log upd 
replica reconciliation timestamp matrices 
