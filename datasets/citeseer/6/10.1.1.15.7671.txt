hybrid cc interval constraints bjorn carlson vineet gupta xerox palo alto research center palo alto ca parc xerox com june hybrid cc constraint programming language suited modeling controlling simulating hybrid systems systems continuous discrete state changes 
language extends concurrent constraint programming framework default reasoning combinators programming continuous behavior 
important constraint systems hybrid cc nonlinear equations ordinary differential equations intervals 
interval constraints crucial modeling problems partially specified 
describe implementation hybrid cc interpreter constraint solvers evaluate performance example programs 
embedded micro processors integral component modern devices 
devices evolve continuously discretely digital circuitry interacts moving parts temperature gradients continuous physical phenomena 
example modern cars microprocessor monitor control running engine 
engine behavior changes software able adapt appropriately 
hybrid systems complex high level development design tools necessary modeling simulation 
example software model new design catch design flaws earlier design cycle prototyping hardware 
toolkit hybrid systems design provide means modeling simulation internal external behaviors system properly analyzed 
traditionally simulators implemented low level imperative languages suffer lack formal foundations unpredictable side effects 
gap mechanical engineer component design program simulates quite large 
tools verify parts high level specifications specifications little relation simulators 
engineers manually try match simulation data specification laborious error prone process 
hybrid cc gjs compositional declarative language constraint programming enables modeling simulation hybrid systems framework 
hybrid cc hybrid system specified set constraints temporal behavior 
constraint describes internal relationship system heat loss container function authors partly funded project arpa 
time acceleration depends mass constraints standard formalisms physics engineering differential equations algebraic equations 
discrete events state changes turning heater ambient temperature drops low specified combinators concurrent constraint programming sar default logic rei 
formal operational semantics hybrid cc described gjs 
presents implementation hybrid cc 
important classes constraints implementation nonlinear algebraic ordinary differential equations 
numerical variables range real intervals 
algebraic constraints solved interval propagation indexicals interval splitting newton raphson method simplex algorithm 
differential equations integrated version fourth order runge kutta method adaptive stepsize modified interval variables 
constraint propagation solve simultaneous equations 
interval constraints provide hybrid cc expressive power required modeling problems gss inequalities express physical constraints bounds force magnitudes addition physical systems imprecise nature construct perfectly accurate model 
imprecision captured interval constraints 
constraint propagation inside numerical integrator able strengthen precision integration adding redundant constraints narrow divergence see example section follows imprecise initial conditions 
implementation interpreter compiler written yacc 
compiler translates program graph expressions interpreted combinator combinator 
interpreter keeps constraint store similar store traditional constraint programming languages 
memory managed conservative garbage collector implementation easily embeddable systems 
example integrated hybrid cc java win dynamic library api compiling running hybrid cc windows windows nt remote procedure call interface compiling running hybrid cc remotely 
currently developing modeling client java support visual hybrid cc programming graphical output graph plots animations generated sampling variables execution hybrid cc program 
performance hybrid cc interval constraint benchmarks shows interval propagation competitive clp newton 
clearly interval version runge kutta method fast standard libraries integration real valued variables 
interval variables constraint propagation inside numerical solver get flexible robust system modeling differential equations 
structured follows 
section define hybrid cc give operational semantics 
give description constraint solvers section 
conclude comparison related evaluation performance interpreter 
hybrid cc language hybrid cc extends concurrent constraint programming defaults continuous combinators objects 
basic set combinators hybrid cc follows tell constraint holds reduce reduce holds parallel composition new local forall instance class execute instant execute parameters constraints hybrid cc classified 
arithmetic constraints 
arithmetic constraints form terms generated grammar var number decimal notation gammat exp log sin cos prev var refers numeric variable convention lowercase names numeric variables 
derivative respect implicit variable time 
term prev refers limiting value left useful discrete state change continuous period 
string atomic constraints 
string constraints represented 
atomic constraints written variable name consisting string alphanumeric characters starts uppercase letter 
closure constraints 
form constraint defines behave exception fi reduced arguments 
higher order unification 
factorial function defined recursively follows new fq gamma ng call computes 
class constraints 
form constraint defines class constructor takes arguments properties named note property point closure methods defined 
property treated variable inside functor optional constrained base class inherits properties 
code defining instance see 
allowed override method definition ancestor classes 
object creation 
object created combinator bound class 
gets bound new instance constrained executing definition definition ancestor context bound self example definition class method constrains variables ask constraints 
constraints conjunction disjunction constraints 
computational model hybrid cc 
computational model reductions statements 
oe denote variable store set interval constraints string atom closure class constraints 
hybrid cc system consists store set hybrid cc statements auxiliary structures 
hybrid cc system alternates point phase interval phase 
initial phase point 
initial statement reduced 
semantics operators defined stable point eventually reached assume infinite sequence closure reductions occurs constraints propagated reductions statements completed 
stable store oe inconsistent computation aborted consistent 
case computation enters interval phase conjunction subexpressions reduced 
conjunction consists reduced point phase statement remember means reduced continuously forever 
similar point phase statements conjunction reduced stable point reached 
determines set constraints continuously true current phase set statements reduced point phase 
length interval phase longest interval constraint set unchanged 
example consider program fx interval phase evolves continuously interval true 
point set constraints may stable point phase started 
describe reduction rules operator hybrid cc provide algorithm interpreter 
reduction rules apply phase 
gamma denotes set hybrid cc program fragments oe denotes store set program fragments run phase set suspended statements 
expression oe denotes entailment checking incomplete 
tell gamma oe gamma oe fcg ask oe gamma oe gamma oe gamma oe gamma oe par gamma oe gamma oe forall oe instances gamma forall oe gamma oe new gamma new oe gamma oe new call oe gamma oe gamma oe rule differs point interval phases 
point gamma oe gamma oe interval gamma oe gamma oe tell rule propagates effects constraints algorithms described section 
combinator forall suspends instance created current phase combinator adds gamma 
similarly oe detected true false current store statement contains suspended reconsidered variables changes value pruned 
algorithm interpreter phases integration interval phase 
involves steps 
run reduction rules current gamma oe till reductions take place 

oe inconsistent return 
empty return 
remove statement oe go step 
add gamma 
run interpreter current state 
result oe return 
undo effects previous step backtracking 
run interpreter current state 
result oe return 
return 
note effect steps maximal set defaults chosen executed similar maximal extensions rei 
similar causal loops synchronous languages hal bb har 
different maximal sets interpreter chooses randomly 
example reduce 
maximal set exists statement computation aborted 
hybrid cc program run follows 

run interpreter gamma empty oe point phase 
result abort 

run interpreter interval phase gamma returned point phase 
oe empty 
result abort 
record tells ask constraints checked phase 

integrate arithmetic constraints told previous step ask constraints changes status goes false true unknown 
go step 
hybrid cc contains constructs synchronous programming watching behavior derived behavior constructs omit 
addition added known constructs constraint programming support enumeration inside hybrid cc part basic hybrid cc particular labeling computes solution reduction fails computes solutions 
domain shorthand implementation 
interpreter implements essentially algorithm changes 
example interpreter recursive uses stacks managing backtracking 
compiler hybrid cc straightforwardly translates statement expression graph node corresponds operator language 
optimize memory sharing code far possible 
interpreter dispatches node tree runs versions dispatcher points intervals 
main difference versions terminates calling integrator runs breakpoint see reached 
omit detailed description implementation standard techniques concurrent constraint language reductions implemented borrowed akl cc fd hsd jan constraints suspensions treated memory managed conservative garbage collector backtracking implemented trail stacks 
constraint solvers exclude closure class string atomic constraints solvers trivial 
compiler generates graph constraint 
identify common expressions arithmetic terms 
constraints normalized rewriting form normalizing variable ordering 
improves efficiency linearization nonlinear constraints see 
graph representation cases fairly obvious 
example constraint stored graph top node left edge points graph right edge 
graph term closure operator top node list left argument graph right argument 
derivative variable uniformly unique variable 
nonlinear equations consider constraints form constraints reduced form introducing slack variables 
interval pruning basic means constraint solving 
implemented pruning operators indexicals interval splitting newton raphson method simplex method 
pruning stated interval constraint apply operators compute new interval fails constraint deemed inconsistent 
indexical fastest way update interval hsd car 
try rewriting constraint explicit form term set holds current store evaluated intervals 
example consider gamma gamma 
indexical gammay set 
splitting intervals narrow interval splitting recursively smallest number 
similarly computed 
example gamma follows gamma gamma gamma say determined gamma 
eventually determined gamma 
third pruning method newton raphson method adapted intervals ah 
splitting leftmost rightmost zeros computed separately 
df dx guarantees zero number zero computed follows 
define gamma 
iterate follows 
practice combine splitting newton raphson method quick results just done clp newton 
splitting useful reducing size interval inefficient pinning roots exactly 
newton raphson method finds roots quickly known lie small interval 
example gamma split recursively split gamma gamma 
setting applying newton raphson method gamma gamma produced 
similarly produced rightmost zero 
final interval returned pruning operator gamma 
note interval clearly approximation set solutions gamma solutions equation 
simplex method global pruning method applied certain times due high cost previous lightweight methods applied incrementally 
useful detecting inconsistent conjunctions lead slow convergence propagator known problem inequalities 
example consider conjunction fx gamma ffl gamma fflg small ffl inconsistent forces pruning algorithm nibble tiny parts interval time inconsistency detected 
expensive floating numbers high resolution 
set constraints fc linearize set linear constraints fl replacing nonlinear term xy new variable uniformly set linear terms kept detection common subexpressions useful 
form delta delta delta constants variables note consistent implies consistent 
apply simplex method check inconsistent 
done minimizing replaced succeeding 
successful simplex algorithm pruning original variables variable new minimum value computed minimizing new maximum maximizing applying conjunction gamma produces interval constraints immediately operators produce pruning 
conjunction gamma ffl gamma ffl consequently fails 
interpreter apply simplex method dispatcher completes new statement popped 
dispatching propagate partially list constraint pairs suffer infinite anomaly 
internally constraint decomposed set pairs variable indexical prunes derived 
splitting newton raphson 
variable points pairs pruned pairs reapplied 
prunings propagated variant arc consistency algorithm 
optimization fact decomposing constraint produces equivalent variants variant true true car 
dequeued marked entailed pair ignored pruning generated pair enqueued list variables checked 
slack variables bounded interval marked entailed 
pairs generated constraint share entailment mark marked marked 
int propagate queue queue empty var constraint dequeue queue constraint marked entailed continue constraint indexical interval intersect var constraint interval project var constraint splitting interval empty return interval strict subset var trail var var interval enqueue var constraints queue variables constraint determined trail constraint mark constraint entailed return pseudo code propagator telling point interval phase 
point phase constrain variable addition propagation described infer continuous set value limiting value previous interval phase exists 
interval phase arithmetic constraint defined arithmetic constraint added done recursively derivatives variables defined 
example added added defined current state 
sound improves propagation entailment checking adding redundant constraints 
labeling 
labeling set variables fx interval splitting circulate list repeatedly round robin manner variables determined 
assigned lower half assigned lower half failure backtrack assignment try upper half 
complete effective enumeration schemes dense intervals 
entailment checking 
current store oe 
atomic constraint entailed store oe 
string constraint entailed oe 
closure class object constraint entailed store 
point phase constraint entailed evaluates oe operator evaluated intervals points variable replaced belongs oe 
similar reasoning applied 
assume arithmetic constraint normalized forms 
interval phase true previous point store holds oe integrate checklist initial step size dependent variables allocate set initial values store point phase propagate integrate constraint checklist backtrack shrink constraint checklist changes state go integrate th order runge kutta error control compute current undo trail update compute ki propagate compute ki current undo trail set new old propagate overview integration procedure holds oe 
similarly positive natural number defined true oe true oe 
constraint consequently true interval phase ruled true defined 
ordinary differential equations 
version runge kutta integration adaptive step size integrating differential equations numerically 
initial conditions integration store point phase 
pseudo code integrator shown give simpler fourth order runge kutta error checking illustrate interplay propagation integration 
changes basic runge kutta algorithm 
interval arithmetic 
system flexible require specific initial conditions variable constrained start integration 
interval arithmetic introduces divergence problem 
examples solution interval variable grows size integration proceeds lose precision 
exploring methods improving automatically rely redundant constraints contain divergence see example 
second step integration includes propagation simplex algorithm solve simultaneous equations arbitrary form 
standard runge kutta procedure computed previous value considering explicit equation computing sigma defined hf hf delta delta delta gamma gamma ij constants runge kutta formulas 
hybrid cc necessarily equation equations 
compute setting dependent variable constrained delta delta delta gamma gamma previous interval propagating initially empty store oe consequences differential equations 
quiescence set constrained oe oe discarded 
example system equations describes tank temperature concentration substance tank parameters constants kay 
ca gammac gamma gammae gammat gamma gammae system highly nonlinear due exponential containing diverges quickly initial state steps 
adding constraints set differential equations keeps intervals considerably narrower width order gamma 
qualitative methods useful automatically narrowing intervals kay 
third integration interrupt soon constraint list constraints checked changes initial state defined initial conditions integration 
program false integrator reaches switch point phase 
point integrator stops called breakpoint 
standard runge kutta procedure know breakpoints may overshoot program go step depending current integration stepsize 
force integrator consider important point 
detect overshooting recording constraint checked initially true false 
integration step check status constraint changes goes true false 
detect overshooting backtrack undo integration step try smaller step size find point break happen exactly program force integrator reach 
currently simple linear interpolation technique computing smaller step size sophisticated techniques possible 
examples evaluation give idea performance hybrid cc representative benchmarks picked 
show runtimes hybrid cc computing solutions problem sparcstation system 
example banded functions computed constraints gamma sigma fj max gamma min written hybrid cc domain problems solver hybrid cc finds unique solution gamma backtracking 
examples considered mor cosnard nonlinear integral equations interval arithmetic problem combustion problem 
give runtimes different case banded mor cosnard equations 
example run time sec example run time sec mor cosnard mor cosnard interval mor cosnard combustion numbers compare numbers published clp newton follows 
mor cosnard problems hybrid cc times fast difference hardware account 
interval example hybrid cc twice fast clp newton combustion example slower 
program implements simple predator prey example lotka volterra equations population biology adds discontinuity times replacing growth equation predators ratio prey predators small 
py prey pd predator py py py pd prev pd py pd pd py pd prev pd py pd pd py pd runtime simulating equations simulated time units ms comparison provide behavior system discontinuity pd gamma pd py pd 
runtime system ms faster testing breakpoints done 
behavior generated case prey predator prey predator appendix longer example hybrid cc program 
related shift programming language developed uc berkeley dgs sdg intended simulation hybrid systems 
programs shift synchronous collections concurrent hybrid automata ach 
computations proceed alternating point interval phases hybrid cc 
shift object oriented framework constructing models constructs side effects useful writing state machines 
declarative language transitions states explicitly programmed 
interaction concurrency side effects causes semantic problems maintaining determinism 
current implementation shift fixed step size runge kutta integration supported breakpoints occur step 
differential equations intervals active field research attempt provide survey 
research concerned intervals provide validated solutions differential equations statement form solution lie certain interval 
starting point field see tutorial george corliss cor 
field interval reasoning larger 
systems interval constraint solving built ones clp newton uses similar propagation methods exploits multiple representations constraints 
naturally leads better pruning intervals problems 
comparison shows problem instances performance system comparable clp newton 
implementation programming language hybrid systems hybrid cc 
key feature language reflected implementation constraintbased interval constraints 
interval constraints necessity hybrid cc applicable modeling problems interval propagation inside numerical solver differential equations improves accuracy integration 
hybrid cc construct real life models engineering educational purposes 
started direction see example model gss 
order hybrid cc versatile need improve programming environment hybrid cc adding support debugging execution profiling 
ach alur courcoubetis halbwachs henzinger 
ho nicollin olivero sifakis yovine 
algorithmic analysis hybrid systems 
theoretical computer science 
ah jurgen 
interval computations 
academic press 
bb benveniste berry 
synchronous approach reactive real time systems 
proceedings ieee september 
car bjorn carlson 
compiling executing finite domain constraints 
phd thesis uppsala university 
cor corliss 
guaranteed error bounds ordinary differential equations 
light editors theory numerics ordinary partial differential equa tions volume iv advances numerical analysis pages 
oxford university press 
dgs deshpande luigi 
shift programming language run time system dynamic networks hybrid automata 
technical report uc berkeley path project 
www path eecs berkeley edu shift doc ps 
gjs vineet gupta radha jagadeesan vijay saraswat 
computing continuous change 
science computer programming 
appear 
vineet gupta radha jagadeesan vijay saraswat daniel bobrow 
programming hybrid constraint languages 
panos antsaklis wolf kohn anil nerode sankar sastry editors hybrid systems ii volume lecture notes computer science 
springer verlag november 
gss vineet gupta vijay saraswat peter struss 
model path 
proceedings nd ijcai workshop engineering problems qualitative reasoning august 
hal halbwachs 
synchronous programming reactive systems 
kluwer international series engineering computer science 
kluwer academic publishers 
har harel 
statecharts visual approach complex systems 
science computer programming 
hsd pascal van hentenryck vijay saraswat yves deville 
constraint processing cc fd 
technical report computer science department brown university 
jan janson 
akl multiparadigm programming language 
phd thesis uppsala university 
kay herbert kay 
refining imprecise models behaviors 
phd thesis university texas austin 
press teukolsky vetterling flannery 
numerical recipes cambridge university press 
rei ray reiter 
logic default reasoning 
artificial intelligence 
sar vijay saraswat 
concurrent constraint programming 
doctoral dissertation award logic programming series 
mit press 
sdg luigi deshpande 
shift manual 
technical report uc berkeley path project 
www path eecs berkeley edu shift doc shift ps gz 
saraswat jagadeesan gupta 
timed default concurrent constraint programming 
journal symbolic computation november december 
extended appeared proceedings nd acm symposium principles programming languages san francisco january 
pascal van hentenryck michel laurent frederic benhamou 
newton constraint programming non linear constraints 
science programming 
appear 
pascal van hentenryck david mcallester kapur 
solving polynomial systems branch prune approach 
siam journal numerical analysis 
accepted 
available brown university technical report cs 
example hybrid cc program longer example illustrating hybrid cc modeling hybrid system 
scenario modeled pool table balls rolling various initial velocities 
balls keep rolling straight line hit ball edge table fall pocket come rest due friction 
class ball defines ball initial parameters giving position velocity 
properties position velocity signals notify changes velocities initial velocity position set 
direction motion ball computed cos direction motion ball 
ball active falls pocket indicated trap 
moment program fragments associated ball terminated 
ball rolling velocity decreases friction 
true program issuing change signal computes new velocity 
asserts variable left continuous asserts variable right continuous 
closures edge collisions keep checking balls collide edge table 
case new velocity computed ball involved standard laws kinematics 
closure checks ball fallen pocket issues appropriate signal terminate ball existence 
ball px py vx vy px py vx vy new direction direction vx vx vy trap px py vx vy direction vx vx vy direction px vx py vy vx vx vx direction vx vx direction vx vx vy vy vy direction vy vy direction vy vy edges forall ball px radius px xmax radius vx prev vx py radius py ymax radius vy prev vy collisions forall ball forall ball ball px px py py radius px px vy prev vy vy prev vy px px new new ix py py px px ix prev vx vx prev vy vy vx prev vx ix vy prev vy ix vx vx prev vx vx momentum vy vy prev vy vy momentum pockets forall ball px py pocket px py ymax pocket px py ymax pocket px xmax py pocket px xmax py ymax pocket px xmax py ymax pocket radius xmax ymax pocket ball ball ball edges collisions pockets lines set initial configuration 
ran program simulated time units balls rest total time execution seconds sparcstation 

