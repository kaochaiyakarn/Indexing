software practice experience vol 
july decompilation binary programs cristina cifuentes john gough email fit qut edu au gough fit qut edu au school computing science queensland university technology gpo box brisbane qld australia summary structure decompiler thorough description different modules form part decompiler type analyses performed machine code regenerate high level language code 
phases decompiler grouped main modules front universal decompiling machine back 
front machine dependent module performs loading parsing semantic analysis input program generating intermediate representation program 
universal decompiling machine machine language independent module performs data control flow analysis program intermediate representation program control flow graph 
back language dependent module deals details target high level language 
order increase readability generated programs decompiling system implemented integrates decompiler dcc automatic signature generator 
signatures libraries compilers stored database read decompiler generated programs known library names writeln printf 
dcc decompiler intel architecture dos operating system 
dcc takes input binary programs dos environment generates programs output 
sample code produced decompiler 
key words decompiler reverse compiler compiler signature library signature language decompiler reverse compiler program attempts perform inverse process compiler executable program compiled high level language aim produce high level language program performs function executable program 
input machine dependent output language dependent 
practical problems faced writing decompiler 
main problem derives representation data instructions von neumann architecture indistinguishable 
data located instructions implementations indexed jump case tables 
representation self modifying code practices hard decompile binary program 
problem great number subroutines introduced compiler linker 
compiler include start subroutines set environment address department computer science university gpo box hobart tas australia 
email cifuentes cs edu au ccc received april john wiley sons revised january cifuentes gough runtime support routines required 
routines normally written assembler cases higher level representation 
operating systems provide mechanism share libraries consequently binary programs self contained library routines bound binary image 
library routines written language compiler written assembler 
means binary program contains routines written programmer great number routines linked linker 
example amount extra subroutines available binary program hello world program compiled generates different procedures 
program compiled pascal generates procedures 
really interested procedure main 
despite mentioned limitations uses decompiler including major software areas maintenance code software security 
maintenance point view decompiler aid recovery lost source code migration applications new hardware platform translation code written obsolete language newer language structuring old code written unstructured way spaghetti code debugger tool helps finding correcting bugs existing binary program 
security point view binary program checked existence malicious code viruses run time computer safety critical systems compiler trusted binary program validated exactly original high level language program intended output compiler verified way 
different attempts writing decompilers years 
due amount information lost compilation process able regenerate high level language hll code experimental decompilers limitations way including decompilation assembly files object files symbolic debugging information simplified high level language requirement compiler specification 
assembly programs helpful data information form symbolic text data segments data type declarations subroutine names subroutine entry point subroutine exit statement 
information collected symbol table decompiler need address problem separating data instructions naming variables subroutines 
object files debugging information contain program symbol table constructed compiler 
symbol table easy determine memory locations instructions certainty memory locations represent data 
general object files contain information binary files 
requirement access compiler specifications impractical specifications normally disclosed compiler manufacturers exist 
decompiler dcc differs previous decompilation projects ways analyses binary programs assembler object files performs idiom analysis capture essence sequence instructions special meaning performs data flow analysis registers condition codes eliminate structures program control flow graph generic set high level structures accommodated different high level languages eliminating possible goto statement 
rest structured way thorough description structure decompiler followed description implementation idiom sequence instruction forms logical entity meaning derived considering primary meanings individual instructions decompilation binary programs binary program front machine dependent udm analysis back language dependent hll program 
decompiler modules automatic decompiling system 
followed definitions graph theoretical concepts appendix sample output different phases decompilation program appendix ii 
decompiler structure decompiler structured similar way compiler series modules deal machine language dependent features 
main modules required machine dependent module reads program loads virtual memory parses front machine language independent module analyses program memory universal decompiling machine language dependent module writes formatted output target language back see 
modular representation easier write decompilers different machine target language pairs writing different front ends different machines different back ends different target languages 
result true theory practical applications limited generality intermediate language 
front front module deals machine dependent features produces machineindependent representation 
takes input binary program specific machine loads virtual memory parses produces intermediate representation program program control flow graph see 
parser code starting entry point loader follows cifuentes gough binary program loader parser semantic analysis low level intermediate code control flow graph 
front phases instructions sequentially change flow control met 
flow control changed due conditional unconditional indexed branch procedure call case target branch label start new instruction paths disassembled 
path finished return instruction program termination 
instruction paths followed recursive manner 
problems introduced machine instructions indexed indirect addressing modes 
handle heuristic methods implemented 
example disassembling code parser check sequences instructions represent multiway branch switch statement normally implemented index jump jump table 
intermediate code generated control flow graph built 
levels intermediate code required low level representation resembles assembler machine higher level representation resembles statements high level language 
initial level low level intermediate code simple mapping machine instructions assembler mnemonics 
compound instructions rep represented unique low level intermediate rep 
second level high level intermediate code generated interprocedural data flow analysis explained maps low level high level instructions 
front generates low level representation 
semantic analysis phase performs idiom analysis type propagation 
idioms replaced appropriate functionally equivalent intermediate instruction 
example illustrates different idioms left hand side negation long variable represented case registers dx ax 
idiom right hand side prologue code high level language procedure 
case space bytes reserved stack local variables 
number different idioms decompilation binary programs neg dx push bp neg ax mov bp sp sbb dx sub bp neg dx ax enter 
sample idioms transformation widely known compiler community decompiler code order generate clearer high level code 
type information propagated idioms recognized 
example long local variable stack offsets bp bp merged long variable bp bp 
type information propagated way fields offsets record 
optimization phase performed control flow graph 
due nature machine code instructions compiler need introduce intermediate branches executable program machine instruction capable branching certain maximum distance bytes architecture dependent 
optimization pass control flow graph removes redundancy replacing target branch location conditional unconditional jumps branch unconditional jump recursive branches format final target basic block 
performing process basic blocks going referenced intermediate branches 
nodes eliminated graph 
universal decompiling machine universal decompiling machine udm intermediate module totally machine language independent 
deals flow graphs intermediate representation program performs flow analysis input program needs see 
data flow analysis aim data flow analysis phase transform low level intermediate representation higher level representation resembles hll statement 
necessary eliminate concept condition codes flags registers concepts exist high level languages introduce concept expressions hll program 
purpose technology compiler optimization appropriated 
analysis concerned condition codes 
condition codes hand crafted assembly code instructions translatable highlevel representation 
condition codes classified groups set condition codes generated compiler overflow carry set condition codes generated assembly code trap interrupt 
set cifuentes gough control flow graph low level intermediate code data flow analysis control flow analysis high level intermediate code structured control flow graph 
udm phases analysed 
instructions condition codes set mean subroutine non high level flagged assembler generated subroutines 
definition reaching definition analysis performed condition codes 
way condition code instruction definition chain ud cc determines instruction defined condition 
practical cases instruction defined condition instruction ud cc 
set computed forward flow path algorithm 
set defined instructions known 
low level instructions replaced unique conditional high level instruction semantically equivalent instructions 
consider example illustrates point 
instruction uses sign sf zero zf condition codes 
flags previously defined instruction defines carry flag cf 
instruction defines flags conditional jump merged high level instruction compares registers greater condition jcond ax bx 
second analysis concerned registers 
elimination temporary registers leads elimination intermediate instructions replacing low level instructions high level instruction intermediate register 
condition codes machine instructions hand crafted assembler programmers higher representation 
classify low level instructions sets hli set instructions representable high level language mov add set instructions generated assembly code cli ins 
analysis concerned instructions hli set 
instructions set belong subroutines decompilation binary programs cmp ax bx def sf zf cf jg sf zf ud cc sf zf jcond ax bx 
condition code example written assembler flagged assembler generated 
preliminary analyses required elimination registers 
definition analysis registers needed determine uses definition register 
note register variables eliminated analysis represent local variables required final output program 
analysis solved backward flow path problem 
interprocedural live register analysis required ascertain registers live entrance exit basic block 
analysis solved known algorithms 
method eliminate registers named forward substitution performing forward substitution symbolic contents defined register instruction uses temporary register eliminated temporary instruction defined register eliminated final instruction register defined terms expression 
consider modulo example described 
registers si di register variables example 
register tmp virtual register introduced parser div instruction div equivalent low level instructions division modulus 
registers operands redefine registers tmp register introduced 
code mov ax di asgn ax di du ax mov bx ah asgn bx ah du bx cwd asgn dx ax ax du ax du dx mov tmp dx ax asgn tmp dx ax du tmp div bx asgn ax tmp bx du ax mod bx asgn dx tmp bx du dx mov si dx asgn si dx 
code ax asgn si di ah 
simple expression example cifuentes gough hold initial value dx ax 
substitution instruction illustrated code mov ax di asgn ax di mov bx ah asgn bx ah cwd asgn dx ax di substitute mov tmp dx ax asgn tmp di substitute div bx asgn ax tmp bx eliminate instruction instruction defines register going instruction redundant eliminated 
uses registers right hand side instruction redundant need reflect non existence instruction 
step code look mov bx ah asgn bx ah du bx mov tmp dx ax asgn tmp di mod bx asgn dx tmp bx mov si dx asgn si dx final substitutions give final result instruction mov bx ah asgn bx ah mov tmp dx ax asgn tmp di mod bx asgn dx di ah substitute substitute mov si dx asgn si di ah substitute complete algorithm describes data flow analysis 
control flow analysis control flow analyser structures control flow graph generic high level control structures available languages 
conditional multiway branch case different types loops repeat endless loop 
different methods specified literature structure graphs dealing elimination goto statements graph new variables code replication multilevel exit new variables code replication modify apparent semantics program desirable decompiling binary programs want decompile code 
multilevel exit statements supported commonly languages pascal part generic set high level control constructs generated 
developed algorithm structures graph set generic high level control structures determines particular subgraph generic constructs uses goto 
note minimum number gotos 
algorithm described 
jcond di si decompilation binary programs jcond si printf jcond si di si 
short circuit evaluation graph printf second structuring phase implemented check short circuit evaluation graphs 
graphs transformed simpler graphs hold compound conditions basic block requiring generate high level code uses nested statements 
illustrates example compound condition 
top basic block checks equality si 
false printf node reached 
hand equality true second condition checked di si 
condition true printf basic block reached code reached 
generating code conditions require goto conditions properly nested merged compound negates condition printf node reached condition false leaves second condition condition reaches printf true 
intermediate basic block edges removed graph 
complete structuring algorithm described 
back back module language dependent deals target high level language 
module optionally restructures graph control constructs available particular target language generates code language see 
restructuring phase optional aims structuring graph control structures available target language generic set control structures structuring algorithm previously described utilized 
instance target language ada multilevel exits allowed 
graph structured multilevel exits look loop abnormal goto exits 
restructuring phase check target destination goto determine exit statement suitable 
example loop loop equivalent cifuentes gough structured control flow graph high level intermediate code restructuring hll code generation hll program 
back phases loop induction variable 
case induction variable needs 
final phase hll code generation generates code target hll control flow graph associated high level intermediate code 
phase defines global variables emits code procedure function depth traversal call graph program 
procedure comments information collected analysis procedure procedure low level case assembler produced procedure register arguments registers returned function return value 
generating code goto instruction required unique label identifier created placed instruction takes label 
variables procedures names form loc proc information concerning initial high level name 
user interface built allow user name variables procedures significant names 
decompiling system mentioned compiler start code linked executable program library routines invoked program 
start code library routines written assembler may contain low level machine instructions making routines difficult translate hll representation 
order get information possible program decompiled developed decompiling system integrates decompiler dcc automatic signature generator illustrated 
signature generator front module generates signatures compilers library functions compilers 
signatures stored database decompilation binary programs libraries generate signatures signatures binary program decompiler hll program 
decompiling system user asm program accessed dcc check subroutine library function case function analysed dcc replaced library name printf 
module completely automatic takes input library functions library signature unique series instructions identifies library function particular compiler 
compiler signature unique series instructions identifies particular version compiler 
practice different compiler signatures required different memory models intel architecture 
determining compiler signatures helps decompiler determine real entry program main knowing names libraries functions final program readable 
tested borland turbo versions microsoft versions borland turbo pascal version 
start code compilers different easily differentiate 
borland microsoft provide source code start code part compiler distribution matter finding instruction invokes main determine entry point original high level program 
process eliminates need analyse procedures set environment particular compiler depend heavily low level machine instructions 
dcc experimental decompiler dos operating system intel architecture 
input dcc reads com exe files produces programs output see structure decompiler 
disassembler part dcc user option generating assembler files files 
seen dcc implement restructuring phase back 
due choice target language instance dcc generates code need restructuring control structures 
signature checker module dcc 
module determines known compiler returns main program 
scans procedure entry bytes instructions pattern matching algorithm see instructions correspond library routines compiler 
correspondence exists rest procedure disregarded hll analysis code generation name offset placed symbol table procedure replaced procedure name 
decompilation sample program appendix ii 
intermediate representation final program 
cifuentes gough binary program loader parser semantic analysis data flow analysis control flow analysis hll code generation hll program 
structure dcc assembler code generation assembler program summary presents methodology decompilation binary programs describes current development state dcc decompiler intel architecture 
decompiler structure resembles compiler main modules distinguished front machine dependent universal decompiling machine udm machine language independent back language dependent 
front deals loading binary program parsing producing intermediate representation program program control flow graph 
udm performs data flow analysis order eliminate non high level language concepts condition codes registers intermediate representation introduce concept expressions 
udm structures control flow graph determining high level structures program 
back optionally performs restructuring needed accommodate structures program structures available target high level language generates high level code procedure 
module compiler library signature detection reduced number routines decompiled making decompilation process faster providing better documentation output programs 
binary programs match compiler signatures dcc decompiled entirely compiler start code runtime support routines library subroutines decompiled analysed 
decompilation binary programs ec ec fc eb fe ff fe ff fe fc cb ec fe ec ff fe ff ff eb eb eb cb 
machine code hexadecimal format project proven feasibility writing decompiler contemporary machine architecture 
uses envisaged decompiler including software maintenance security 
michael van emmerik jeff coding modules involved project 
research partly funded australian research council arc 
appendix graph theoretical definitions basic block sequence instructions single entry point single exit point 
requirements give basic block property instruction executed instructions executed 
control flow graph tuple set nodes file type exe signature file size file size pages relocation items offset load image paras minimum allocation paras maximum allocation ffff paras load image size initial ss sp initial cs ip 
information provided loader cifuentes gough proc proc far push bp bec mov bp sp push si mov si bp fe cmp si bc mov ax si dec ax push ax push cs call near ptr proc pop cx push ax bc mov ax si add ax push ax push cs ff call near ptr proc pop cx bd mov dx ax pop ax add ax dx pop si pop bp cb mov ax eb jmp proc endp main proc far push bp bec mov bp sp ec sub sp push si push di ca push ds cb mov ax ce push ax cf call far ptr printf pop cx pop cx push ss fc lea ax bp da push ax db push ds 
low level intermediate code decompilation binary programs dc mov ax df push ax call far ptr scanf add sp mov si fc cmp si bp ec xor ax ax push ax call far ptr exit pop cx pop di pop si mov sp bp pop bp cb ed push ds ee mov ax push ax call far ptr printf pop cx pop cx push ss fa fe lea ax bp fd push ax fe push ds ff mov ax push ax call far ptr scanf add sp ff fe push word ptr bp call far ptr proc pop cx bf mov di ax push di ff fe push word ptr bp push ds mov ax push ax call far ptr printf add sp si jmp synthetic inst main endp 
low level intermediate code cont cifuentes gough input file fibo exe file type exe int proc int arg takes bytes parameters 
high level language prologue code 
calling convention 
int loc int loc ax loc arg loc loc proc loc proc loc loc return loc void main takes parameters 
high level language prologue code 
int loc int loc int loc int loc printf input number iterations scanf loc loc loc loc printf input number scanf loc loc proc loc printf fibonacci loc loc loc loc exit 
final program include stdio int main int number unsigned value fib decompilation binary programs printf input number iterations scanf printf input number scanf number value fib number printf fibonacci number value exit unsigned fib compute fibonacci number recursively int return fib fib return 
initial program set directed edges root graph 
node represents basic block 
path nm represented nm sequence edges nm nm 

finite set procedures program 
call graph tuple set procedures ni represents pi eis set edges ni nj represents pi pj main procedure 
du chain register statement set statements defined statement ud chain register statement set statements defined 
appendix 
example decompilation simple program sample program see calculates fibonacci number input number 
illustrates relevant machine code binary 
library compiler start code included 
shows information gathered loader 
figures disassembly binary program 
calls library routines cifuentes gough detected included analysis 
final output dcc 
program compared original program 
decompiled program functionally equivalent original program differences noticed 
recursive procedure proc uses local variables copy parameter hold final result function 
local avoided data flow analysis done basic blocks 
second local deleted way compiler compiled program 
second unsigned identifiers proc able know result unsigned integer signed integer 
main procedure 
program lowlevel instructions converted high level instructions reduction number instructions cent 

study decompiling machine languages high level machine independent languages phd dissertation purdue university computer science august 

friedman decompilation transfer mini computer operating systems phd dissertation purdue university computer science august 

language design decompilation technical report university central florida december 

decompilation phd dissertation university california irvine computer science 

transportation assembly language software decompilation technical report naval underwater systems center october 

reuter url ftp cs washington edu pub decomp tar public domain software 

demonstrating equivalence source code prom contents computer language 

bowen breuer decompilation techniques internal esprit redo project tn prg version oxford university computing laboratory road oxford ox qd march 

breuer bowen decompilation enumeration types grammars appear transaction programming languages systems 
technical report prg tr oxford university computing laboratory may 

cifuentes gough methodology decompilation proceedings xix de inform tica buenos aires argentina august pp 

centro de en inform tica 

larus ball rewriting executable files measure program behavior software practice experience 

fischer leblanc jr crafting compiler chapter benjamin cummings sand hill road menlo park california pp 


aho ullman theory parsing translation compiling volume ii compiling chapter prentice hall pp 


cifuentes interprocedural data flow decompilation technical report faculty information technology queensland university technology gpo box brisbane australia april 

cifuentes reverse compilation techniques phd dissertation queensland university technology school computing science july 

williams chen restructuring pascal programs containing goto statements computer journal 

hendren taming control flow structured approach eliminating goto statements technical report acaps technical memo school computer science mcgill university university st montreal canada september 

knuth floyd notes avoiding go statements information processing letters 
decompilation binary programs 
williams generating structured flow diagrams nature computer journal 

baker zweben comparison measures control flow complexity ieee transactions software engineering se 

baker algorithm structuring flowgraphs journal acm 

ramshaw eliminating go preserving program structure journal acm 

cifuentes structuring algorithm decompilation proceedings xix de inform tica buenos aires argentina august pp 

centro de en inform tica 

cifuentes structuring decompiled graphs technical report faculty information technology queensland university technology gpo box brisbane australia april 

van emmerik signatures library functions executable files technical report faculty information technology queensland university technology gpo box brisbane australia april 
