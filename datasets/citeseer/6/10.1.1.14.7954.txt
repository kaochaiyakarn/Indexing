partial constraint satisfaction eugene freuder richard wallace computer science department kingsbury hall university new hampshire durham nh usa 
constraint satisfaction problem involves finding values variables subject constraints combinations values allowed 
cases may impossible impractical solve problems completely 
may seek partially solve problem particular satisfying maximal number constraints 
standard backtracking local consistency techniques solving constraint satisfaction problems adapted cope take advantage differences partial complete constraint satisfaction 
extensive experimentation maximal satisfaction problems illuminates relative absolute effectiveness methods 
general model partial constraint satisfaction proposed 
constraint satisfaction involves finding values problem variables subject constraints acceptable combinations values 
constraint satisfaction wide application artificial intelligence areas ranging temporal reasoning machine vision 
partial constraint satisfaction involves finding values subset variables satisfy subset constraints 
viewed way willing weaken constraints permit additional acceptable value combinations 
partial constraint satisfaction problems arise contexts ffl problem overconstrained admits complete solution 
ffl problem difficult solve completely willing settle solution 
ffl seeking best solution obtainable fixed resource bounds 
ffl real time demands require anytime algorithm report partial solution immediately improving time allows 
utility form partial constraint satisfaction repeatedly recognized 
variety applications motivated variety approaches 
reprinted minor changes intelligence volume numbers freuder wallace partial constraint satisfaction pages kind permission elsevier science nl sara kv amsterdam netherlands 
volume special issue reprinted mit press book constraint reasoning 
ai increasingly confronts real world problems expert systems robotics example increasingly encounter situations searching solution problem sense search problem solve 
conflicting constraints arisen variety domains 
latombe compromises antagonist constraints planner machining problems 
borning constraint hierarchies deal situations set requirements preferences graphical display physical simulation satisfied hierarchies imbedded constraint logic programming language 
sensitive relaxation resolve conflicts floor planning 
scheduling problems natural source constraint satisfaction problems schedule conflicts natural source partial satisfaction problems 
fox added concepts constraint relaxation selection constraint alternatives preferences relaxations constraint importance constraint representations cope conflicting constraints job shop scheduling 
feldman golumbic priorities looking optimal student schedules 
machine vision provided motivation partial constraint satisfaction 
shapiro haralick treated inexact matching structural descriptions extension constraint satisfaction called inexact consistent labeling problem sought solution error bound 
mohr masini suggested modification local consistency processing deal errors permitting values fail satisfy constraints order cope noise domains computer vision cooper defined alternative generalization constraint satisfaction errors 
related problem approximate constraint satisfaction weights assigned individual combinations values motivated machine vision 
expression preferences database queries related problem 
note concept optimization play role constraint satisfaction problems constraints satisfied may additional criterion optimize alternative solutions 
focus methods maximal constraint satisfaction seek solution satisfies constraints possible 
systematically reviewed basic backtracking local consistency methods constraint satisfaction developed analogous methods maximal satisfaction 
maximal satisfaction context provided new challenges new opportunities 
algorithms formulated subjected carefully designed experiments shed light relative absolute performance function basic structural problem parameters 
algorithms allow sufficient satisfaction terminate search find solution sufficiently sense number constraint violations exceed predetermined bound 
methods easily extend resource bounded satisfaction report best shoes shirt slacks cordovans sneakers green white denims dress blue dress gray cordovans white sneakers denims cordovans gray green dress gray white denims white dress blue fig 

robot clothing problem 
solution hand resource bound reached naturally support anytime algorithms 
maximal satisfaction provides form optimization 
sufficient satisfaction incorporates concept acceptable error 
methods clearly generalize complex metrics evaluate proposed solutions simple count number violated constraints 
manner preferences introduced distinguish conflicting constraints 
simple metric counting constraint violations facilitates presentation algorithms provides suitable context initial evaluation performance 
develop general model partial constraint satisfaction compare alternative problems alternative solutions :10.1.1.14.7954
suggest viewing partial satisfaction problem search space alternative problems solvable problem close argue full theory partial satisfaction consider merely partial solution requires violate constraints entire solution set problem altered constraints differs solution set problem started 
pedagogical purposes simple toy problem involving fashion conscious robot seeking choose matching clothes getting dressed morning 
regarded seriously simple version configuration problem 
problem pictured fig 

robot minimal sneakers cordovans footwear white dark green shirt pairs slacks denim dress blue dress gray 
robot told sneakers go denim slacks cordovans go gray slacks white shirt white shirt go denim blue slacks green shirt goes gray slacks 
constraints operate 
section discusses methods achieving maximal constraint satisfaction 
branch bound maximal constraint satisfaction natural extension backtracking constraint satisfaction 
retrospective prospective back track techniques constraint satisfaction shown analogues branch bound setting maximal satisfaction 
local consistency methods constraint satisfaction analogues maximal satisfaction methods 
ordering techniques important branch bound backtracking 
section describes extensive testing maximal constraint satisfaction methods corresponding successful constraint satisfaction methods 
results demonstrate effectiveness maximal satisfaction analogues 
illustrate importance advantage additional information available partial satisfaction domain world just black white consistency inconsistency shades grey 
furthermore experimental design permits insights relationship problem structure performance different methods 
section generalizes forms partial satisfaction 
metrics briefly discussed 
partially ordered problem spaces introduced 
partial constraint satisfaction problem defined search space alternative problems 
section contains brief concluding remarks 
methods constraint satisfaction problem csp involves set problem variables domain potential values variable set constraints specifying combinations values acceptable 
solution specifies assignment value variable violate constraints 
consider binary finite csps constraints involve variables time domains finite sets values 
constraint represented explicitly set permitted pairs values 
pairs values allowed variables effectively constraint say variables share constraint 
running example variables shoes slacks shirt values shoes cordovans sneakers constraint shoes shirt specifies allowable combination values cordovans white shirt 
values cordovans white shirt satisfy relevant constraint consistent 
pair values violates constraint inconsistency 
define partial constraint satisfaction problem pcsp csp willing accept solution violates constraints 
formal approach developed sect 

backtracking classic algorithm solving csps 
number variations refinements backtracking developed 
algorithms including classical backtracking utilize retrospective techniques new value selected try extend incomplete solution tested looking back previously chosen values incomplete solution see new value consistent previously chosen values 
remembering course search process variations reduce redundant testing 
algorithms employ prospective strategies 
values tested domains variables represented incomplete solution inconsistencies dealt values domains considered inclusion 
ordering techniques direct order variables values constraints considered search 
strategy studying pcsp algorithms look analogues successful csp techniques focusing backtrack variations 
branch bound widely optimization technique may viewed variation backtracking 
natural choice seeking analogue backtracking find optimal partial solutions 
applying branch bound constraint satisfaction problems 
set finding analogues various csp retrospective prospective ordering techniques partial specifically maximal constraint satisfaction algorithms 
finding appropriate analogues presents challenges opportunities 
presenting algorithms generally review csp version move pcsp version highlighting differences 
examples discussions algorithms 
retrospective techniques 
basic branch bound 
branch bound maximal constraint satisfaction natural analogue backtracking constraint satisfaction 
briefly review backtrack search context running example 
backtrack search find solutions problem overconstrained 
basic branch bound algorithm find way dress robot violating minimal number requirements 
cordovans sneakers denims green white dress blue dress gray denims dress blue dress gray green white cc cc cc cc cc cc cc cc fig 

backtracking example 
depth traversal tree fig 
traces progress backtrack search running example 
try cordovans shoes denims slacks 
constraints denim slacks consistent cordovans try blue slacks 
try gray 
gray move try find consistent shirt 
green shirt go cordovans try white shirt 
consistent cordovans gray slacks assume consistency checked top chosen values 
point need back 
find tried values slacks back try value shoes 
ultimately possibilities fail 
backtrack search tries value combinations exhaustively necessary avoid considering combinations observing subset values extended full solution pruning subtree search space 
standard measure effort csp algorithms number constraint checks 
constraint check occurs time ask basic question form value variable consistent value variable example ask cordovans consistent denims constraint check 
total number constraint checks cc accumulated search reached leaf node search tree shown 
total search required constraint checks find solution 
discussing way different algorithms search tree need suitable vocabulary 
talk levels search tree level search tree corresponds problem variable 
assume levels numbered top higher levels smaller numbers 
shirt value lower level deeper search tree slacks value 
branching corresponds variable values choice denim slacks 
nodes search tree represent assignments values variables search 
green shirt value considered level considered twice search 
second time green shirt encountered search backed interim shoe level 
set assigned values branch tree top level sneakers denims search path 
search path leading chosen value current search path 
represents current set choices values variables 
represents proposed incomplete solution includes values variables 
theme recur deriving pcsp analogues different definition local failure csp pcsp search 
csp search path fails soon single inconsistency encountered 
pcsp search path fail inconsistencies accumulate reach cutoff bound 
retrospective techniques excel determining inconsistencies implied past choices 
prospective techniques excel estimating inconsistencies implied choices 
branch bound operates similar fashion backtracking context seeking maximal solution satisfies constraints possible 
branch bound basically keeps track best solution far abandons line search clear lead better solution 
version backtracking searches solutions solution naturally compares branch bound extension find maximal solution 
cordovans sneakers denims green white dress blue dress gray denims green white dress blue dress gray green white cc cc cc cc cc cc cc cc cc fig 

branch bound example 
traces branch bound search maximally satisfying solution sample problem 
branch bound applied context evaluation function count number violated constraints inconsistencies 
backtrack search looking perfect solution violates constraints said denims inconsistent cordovans proceeded blue slacks branch bound looking maximal partial solution observes partial solution containing cordovans denims violate constraint proceeds consider shirts 
specifically noted partial solution containing cordovans denims distance perfect solution 
distance measures number constraints violated chosen values 
time add green shirt violated constraints 
say green shirt extension search path cordovans denims 
talk extending search path adding values particular extending search path complete solution contains value variable 
search path leading cordovans denims green shirt contains inconsistencies giving associated distance perfect solution 
inconsistent value search path denims 
value search path inconsistent value search path 
inconsistent value green shirt 
cordovans denims green shirt provide partial solution distance perfect solution 
distance taken value search store number inconsistencies best solution point search 
necessary bound simply refer bound sense better necessary find solution fewer inconsistencies 
necessary bound set initially priori knowledge solution available violates fewer constraints priori requirement interested solutions violate gamma constraints 
branch bound proceeds solution violates constraints replaced branch bound search proceeds example finds better partial solution single constraint violation cordovans denims white shirt 
updates 
tries cordovans blue slacks hoping better case perfect solution recognizes solution involving cordovans blue slacks better solution 
consider matching shirt cordovans blue slacks proceeds immediately try gray slacks 
backtrack search basic idea recognizing defeat early permits pruning search space 
search concludes find perfect solution available case run things try 
quit reach preset sufficient bound specifies satisfied find partial solution violates constraints 
may know example exact solution possible able set 
may willing settle close sufficient solution 
obviously larger set easier problem 
circumstances may impose resource bounds 
particular real time processing may require immediate answers refined time allows 
branch bound process suited providing resource bounded solutions 
simply report best solution available example time bound exceeded 
branch bound process clearly suited support anytime algorithm repeatedly provide best far answer queried 
quickly provide answer better follow time allows 
provides basic branch bound algorithm maximal constraint satisfaction 
provides priori sufficient necessary bounds acceptable solution 
priori bounds initially infinity 
parameters bb procedure appear algorithms 
parameter search path carries current search path 
distance carries number constraints violated values current search path number inconsistencies proposed incomplete solution 
variables carries list variables assigned values current search path variables lower levels search tree 
values carries list values previously tried extensions current search path value values value tried instantiation variable variables 
subsequent algorithms employing best solution global variables containing necessary sufficient bounds bb search path distance variables values variables nil fall problem variables assigned values search best solution search path distance return finished solution sufficiently return keep searching values nil values extending search return keep searching back see try value variable assigned value search distance extended search path assign values remaining variables violating additional return keep searching see better backing try value variable assigned value search extend search current value value values new distance distance try choices search path new distance choice inconsistent current value new distance new distance new distance bb search path plus current value new distance variables minus variable values second variable variables finished return finished path extended sufficient see better return bb search path distance variables values minus current value fig 

branch bound algorithm 
best solution far 
variables algorithms local exception arrays indicated sect 

basic recursive structure bb common algorithms 
bb works sideways search tree recursing set values variable deeper search tree recursing variables 
backing implemented unwinding recursion 
algorithm retrospective procedures value considered inclusion solution compared values chosen determine constraints instantiated variables current satisfied 
comparison values constraint check 
total number constraint checks standard measure csp algorithm efficiency wish minimize quantity 
new distance compared constraint failure bound reached value checked 
subtle point involves test see distance trying new value 
implementation checked distance equality test appears sufficient 
wonder number inconsistencies chosen values stored search path equals bound algorithm doing trying extend search path variable algorithm began trying extend solution may larger 
complete assignment values variables extending search path requiring current constraint violations may interim value reaching chosen depth implementation branch bound paradigm 
branch bound control structures notably best approach possible 
depth direct analogue backtrack facilitates development analogues backtrack variations 
depth supports anytime algorithm immediately best far solution report 
limited experimentation best approach encouraging respect efficiency preclude study 
fig 
total number constraint checks cc accumulated time leaf node search tree processed bottom 
note due procedures minimizing constraint checks checks avoided points search tree including lowest level nodes 
cases subtrees pruned cases value need checked entire preceeding search path 
general worst case bound algorithm course exponential 
worse backtrack algorithm finding perfect solution 
worst case trying possible combinations values testing constraints 
hand exponential worst case bound bad 
want consider techniques may help avoid achieving bound 
indicated strategy look analogues methods proven successful finding perfect solutions 

backjumping 
backjumping remembers information previous failures reduce need redundant constraint checks rediscover 
consider happens test shirts branch backtrack search tree begins sneakers denims fig 

shirts fail immediately tested sneakers need see consistent denims 
classical called chronological backtracking blindly backs tries dress blue slacks 
point doing blue slacks went sneakers obviously fail reached shirt level 
backjumping recognizes shirts fail match sneakers immediately backtracks shoe level 
tries consider type shoe search terminates 
final constraint checks avoided 
backjumping generalizes insight 
need recognize values tried variable may fail previous value 
processing variable backjumping remembers deepest level search tree values fails 
values discarded backtracking proceed directly level 
algorithm jump directly level 
recursive calls unwind return depth recursion unwinds level reached trying consider values 
extend search paths ultimately reach levels value choices extending search path fail consistent previous choices successfully proceed way solution 
course deepest level failure may simply previous level real jumping back need result 
cordovans sneakers denims green white denims green white dress blue dress gray green white cc cc cc cc cc cc cc fig 

backjumping example 
backjumping analogue partial constraint satisfaction failure necessarily occur inconsistency 
failure occurs inconsistency pushes far away perfect solution accumulated number inconsistencies reaches necessary bound example search reached seventh variable sequence checking value domain value fourth variable causes distance increase bound depth failure variable 
shows trace backjumping maximal solution running example 
numbers arrows show values returned bj notice returned depth bottom right search tree supports jump back shoes level considering additional slacks 
contains backjumping algorithm partial satisfaction 
aside different definition failure major difference conventional backjumping algorithm 
jump back way deepest level failure 
values level inconsistent chosen required increase distance chosen jump back level deepest inconsistent values 
minimum distance solutions missed values tried level alternative values level may involve fewer inconsistencies adding distance search proceed level encountering bound point search 
bj search path distance variables values current depth return depth inconsistency depth variables nil new best best solution search path distance return finished return current depth gamma values nil distance return return depth lead extend search current value value values new distance distance try choices search path new distance tried choice inconsistent current value new distance new distance fail depth level choice new distance fail depth current depth new distance value fail depth bj search path plus current value new distance variables minus variable values second variable variables current depth current depth new distance distance inconsistency depth finished sufficient current depth return fail depth return bj search path distance variables values minus value current depth max fail depth return depth inconsistency depth inconsistency depth fig 

backjumping algorithm 
example phenomenon adapt matching clothes problem supposing values tested giving bound fig 

change order examine variables variable search order indicated numbers nodes 
domain checked left right vertical lines appear right values currently considered 
current inconsistencies indicated lines joining nodes 
search reached dead third variable number inconsistencies equals bound deepest level failure total number inconsistencies equal bound level variable 
csp search jump back variable value gray slacks selected 
problem value associated variable white shirt compatible value variable blue slacks case inconsistency variables 
search backs variable value chosen leaves distance zero 
addition cordovans variable compatible white shirt blue pants possible find solution including blue slacks white shirt gives total distance 
currently better solution 
overlooked followed ordinary backjumping procedure csps 
dress gray denims slacks cordovans sneakers shirt shoes 
white green dress blue inconsistency fig 

backjumping level inconsistent choice 
handle situation backjumping analogue keep track deepest level associated inconsistency inconsistency depth addition tracking depth failure 
implementation passed search proceeds updated current depth level currently trying extend search path failure level testing 
obviously addition procedure tend lessen efficiency form backjumping 

backmarking 
backmarking potential avoid redundant successful constraint checking redundant discoveries inconsistencies 
trying extend search path choosing value variable backmarking marks individual level mark search tree inconsistency detected value example value variable consistent value search path inconsistent second value mark value 
inconsistency detected value mark set level level value 
assuming successfully extend search path complete solution back backmarking remembers highest level backto search backed time considered 
backmarking considers value mark backto levels compared 
cases mark backto 
level failed level backtracked know constraint checking fail 
value failed 
backto mark 
failed backed level encountered failure test start testing values level backto 
values level unchanged successfully tested contains backmarking algorithm partial constraint satisfaction 
partial satisfaction failure value necessarily occur inconsistency 
occurs level inconsistency causes reach bound terminates search path 
call level mark shall see moment need keep track level inconsistency 
mark range opposed single failure point 
store level backto highest level search backed trying assign value backto inconsistencies arrays global rows associated variables columns backto values 
elements initialized inconsistencies backto 
cases backto 
level failed level backtracked know testing fail 
values failed 
backto 
failed backed level encountered failure test start new testing values level backto csp case 
csp case knew inconsistencies level failure 
know inconsistencies level inconsistency 
cases backto 
backed level inconsistency know unchanged values bmk search path distance variables values current depth value index variables nil best solution search path distance return finished return keep searching values nil set array backto current variable current depth gamma return keep searching current depth value index backto current depth backed level inconsistency marked previous encounter adding distance number inconsistencies values previous values search path starting level min backto current depth current depth value index updating arrays appropriately produces new distance values search path push number inconsistencies distance inconsistencies current depth value index distance recorded inconsistencies adding distance inconsistencies current depth value index number inconsistencies values previous values search path starting level current depth value index arrays produces new distance values search path push number inconsistencies bmk search path plus current value new distance variables minus variable values second variable variables current depth finished return finished return bmk search path distance variables values minus value current depth value index fig 

backmarking algorithm 
level consistent start new testing level backto 
backto 
need start testing level inconsistency 
level unchanged values consistent situation bit subtler distinct csp backjumping 
may fact mark failure point 
previous time considered inconsistency may pushed bound csp case may inconsistency case set level level 
hand inconsistencies induce failure may distance current number known inconsistencies bound may changed interim 
accordingly save piece information number inconsistencies values search path level 
case really backto 
current distance plus inconsistencies know fail testing 
values produced inconsistencies 
add inconsistencies current distance commence testing level 
values caused inconsistencies 
feel may possible commence testing level backto subtle bookkeeping issues need resolved 
snapshots search backmarking analogue clothes matching problem shown fig 

copy arrays shows values portion search left changed values shown 
array rows associated level search omitted entries change 
example consider cells associated value green shirt portion search represented far left fig 

green shirt value associated row column arrays 
value green shirt match cordovans level 
value due mismatch green shirt denims 
mismatches constraint failures associated green shirt inconsistencies 
note column arrays cells associated green shirt white shirt row value comparisons sneakers level resulted constraint failure sufficient attain bound 
addition backto value 
search proceeds value variable pants dress blue shown failure current distance zero 
green shirt tested inconsistencies backto row inconsistencies backto row cordovans denims dress blue green white cc cc cc cordovans green white cc cc dress gray sneakers denims green white cc cc inconsistencies backto row row row row fig 

backmarking example 
value backto greater case value inconsistencies case green shirt fails constraint checking 
situation white shirt 
search returns level gray pants tested fail match sneakers search ends total constraint checks 
version backmarking experiments described sect 
enhancement minimize number constraint checks turned difference 
second algorithm described fig 
distance checked reached exceeded need constraint checking 
unfortunately tactic entailed checking possible revision values inconsistencies bound reached algorithm backed recorded range constraint failures 
example value backto corresponding values set inconsistencies set 
various refinements pcsp backmarking possible implemented 
observe running example second time encounter green shirt inconsistencies machinery help value 
occurs level backto level bound point infer constraint checks green shirt bring bound 
fact consider storing levels values encountered inconsistencies additional information pruning constraint checking 
prospective techniques prospective techniques look ahead establish form local consistency continuing search global solution 
prospective techniques prune consideration values meet local consistency criteria 
consistency techniques preprocessing methods prior search situations leaving little subsequent search 
interleaved backtracking form hybrid algorithms 
methods applying local consistency techniques repeatedly subproblems achieve global solutions 
commonly form local consistency arc consistency 
problem fully arc consistent value domain variable consistent say supported value variable domain 
arc consistency preprocessing eliminates unsupported values 
familiar hybrid algorithm forward checking 
forward checking assignment value variable followed limited amount arc consistency checking domains variables share constraint tested standard branch bound strategy discussed terms lower bounds increase pruning estimating implications proceeding current search point 
prospective methods provide means implementing strategy partial constraint satisfaction 
search path number inconsistencies path distance bound way determining matter sought continue path encounter additional inconsistencies search failed prospective methods permit obtain values 

pruning arc consistency counts 
csp context arc consistency permits eliminate values arc consistency processing determines participate complete solution 
running example sneakers eliminated consistent shirt 
furthermore dark green shirt dress blue slacks eliminated consistent shoes 
notice denim slacks originally supported sneakers sneakers eliminated support denims eliminated turn 
longer support white shirt 
having eliminated shirt possibilities arc consistency problem discovered global solution search necessary 
pcsp context possible discard values way initial value necessary bound know example priori solution violated constraint solution violate constraint unacceptable eliminate value variable consistent value variables 
possible perform prior calculations regarding increments distance associated specific values 
particular value number domains supporting values tallied number arc consistency count lower bound increment distance incurred value added solution 
algorithm computing arc consistency counts fig 

course subsequent search arc consistency count proposed search path extension added distance associated search path sum compared current bound sum know complete solution starting current search path involving violate constraints 
fail point testing 
course tested preprocessing may encounter times subsequent search number occasions preprocessing may save testing forward checking algorithm uses similar strategy involving limited dynamic form arc consistency count 
acc variables domains counts belonging variables constraint value domain value domain pair allowed constraint increment count value fig 

algorithm computing arc consistency counts 
arc consistency checking tally number domains support value constraint failure may counted twice value belong acceptable pair 
problem subsequent search consistency count incorporated distance check bound considering value extending search path 
value accepted adjustment distance consistency checking done way basic branch bound 
suppose particular value included value considered arc consistency count depends part constraint affected value arc consistency count 
current distance retrospective checking include constraint second count modification computing projected distance compare upper bound 
arc consistency counts advantage need computed search done cd time number constraints maximum domain size variables 
stored appropriate form testing current distance 
contrast retrospective hybrid techniques require extensive calculation retain update information related distance specific values 
values discarded propagation failure manner arc consistency algorithms csps removal sneakers led turn removal denim 
may possible propagate counts manner analogous ordinary constraint propagation 
hybrid analogues idea may possible suggested shapiro haralick inexact matching 
involve retaining information conditions failure employing conditional counts supporting values solution 
arc consistency count algorithm contrast takes pass variables assured consistency counts unconditional 

forward checking 
forward checking hybrid algorithm uses limited amount arc consistency checking 
time value assigned variable algorithm looks ahead variables currently assigned value share constraint removes domains variables values inconsistent example cordovans proposed shoes denim dress blue slacks removed green shirt 
change mind pruned values restored 
move consider sneakers denim dress blue slacks green shirt reappear 
implementation recursion handle bookkeeping variable domains backup 
course sneakers consistent shirt forward checking sneakers reduce shirt domain empty set signaling failure point 
notice despite fact viewed integration consistency processing backtracking forward checking really complement standard backtracking 
standard backtracking checks value consistency previously chosen values 
forward checking propose value know consistent previously chosen values consistency processing pruned away 
test domains remaining uninstantiated variables 
partial satisfaction forward checking type looking ahead ordinary forward checking 
differing definition failure comes play 
inconsistency value rejected total number currently chosen values inconsistent large difference current distance bound means algorithm dynamically keep track number times value inconsistent currently chosen values 
number form dynamic arc consistency count call inconsistency count value 
example forward checking operate matching clothes problem shown fig 

counts associated values variables share constraint variable shown point search calculated 
example cordovans chosen inconsistency count green shirt increases denims chosen 
cordovans denims green white cc denims dress blue dress gray green white blue cc dress cordovans gray dress green white cc green white fig 

forward checking example 
see constraint checks performed early stages example saw straightforward branch bound counts derived early checks avoid constraint checks putting forward checking ahead stage 
value proposed inconsistency count added current distance total manner similar proposed arc consistency counts previous section total equal greater bound fails immediately 
example cordovans tried blue slacks bound set cordovans denim slacks white shirt combination inconsistency count blue slacks set cordovans chosen 
tells hope choose shirt permit better current best solution 
blue slacks fail testing 
notice gray slacks tried cordovans consistent eliminate shirt values 
cordovans raises inconsistency count green shirt eliminating bound 
gray slacks raises inconsistency count white shirt eliminating leaving empty domain shirts 
reducing domain uninstantiated variable empty course signals failure point 
shapiro haralick generalized csp look ahead technique study inexact matching problem 
algorithm call forward checking looking ahead employs extended forward checking discussed sect 
defined inexact consistent labeling problem involves searching solutions error bound 
count violated constraints viewed error 
shapiro haralick algorithms seek optimal solutions full branch bound algorithms sense store compare best far solutions comparisons error bound 
fc search path distance variables domains inconsistency counts holds values variables assigned value search path consistent values search variables nil best solution search path distance return finished return keep searching domains nil return keep searching distance count inconsistency counts count inconsistency counts number inconsistencies value domains values search computing new inconsistency counts new domains consistency needed value domains details determined version fc new domains retain value domain fc search path plus value domains distance count inconsistency counts variables minus variable new domains new inconsistency counts finished return finished return fc search path distance variables domains removing value domains inconsistency counts minus count value domains fig 

forward checking algorithm 
different variants forward checking devised depending manner counts value minimize constraint checks 
contrast shapiro haralick stored counts tables discard values corresponding lists domain values associated counts values discarded counts high raise distance bound 
straightforward version referred fc values domain checked latest value proposed inconsistency counts associated values inconsistent incremented 
revision domain count value incremented incremented count added distance search path sum tested bound 
sum equals exceeds bound means search path extended solution including reaching bound 
removed checked lower levels recursion 
second version fc counts tested manner bound revision just incremented counts 
eliminates values counts large count increased bound lowered values considered elimination 
third version fc take step 
counts tested doing constraint checking see counts incremented 
values may deleted simply bound lowered consistency checking determine counts need incremented 
course incremented counts values survived test fail consistency test tested revision list values 
summarize fc constraint checks done values count checks failures fc constraint checks count checks done values fc count checks done values constraint checks done viable values count checks done values failed consistency test 
general fc algorithm specify details constraint count checking shown fig 


tree structured problems 
local consistency methods support polynomial algorithms csps tree tree structure 
problems structure may useful view containing contained structures 
problem tree structured graph results viewing variables vertices constraints variables edges vertices constraint graph tree structured 
idea utilizing tree represents subproblem particularly attractive pcsp domain constraints need removed reduce problem desired structure eventually satisfied may written unsatisfied constraints partial constraint satisfaction process 
algorithm fig 
obtains efficient solution tree structured maximal constraint satisfaction problems 
tree structured csps solved time linear number variables quadratic size blush suppose tree structured maximal constraint satisfaction problems admit small bound 
fact algorithm achieve bound 
algorithm variable leaf node constraint tree value set cost level tree starting level leaves working upwards variable level value variable child variable value child consistent set cost cost set cost cost link cost minimum set cost minimum cost delete minimal cost return minimal solution value root minimal cost tree values linked variables 
fig 

linear algorithm tree structured maximal constraint satisfaction problem 
theorem 
algorithm finds maximal solution tree structured maximal constraint satisfaction problem nd complexity bound number variables maximum number values variable domain 
proof 
process tree variables associate costs values 
cost represents total number constraints violated choose value values linked descendant variables 
retain minimal cost values variable 
claim cost value variable represents fact minimal number constraints need violate order instantiate variable descendants variable tree value descendant values represent fact optimal solution subtree 
root variable minimal cost instantiation optimal solution complete tree structured problem 
claim trivially true leaves 
way inductively tree root 
assume claim true children variable constraint tree 
algorithm keeps values minimize additional cost vis vis previously retained values children minimize number constraints violated 
changing previously retained values improve matters changing value child avoid inconsistency parent value means replacing child value additional cost offsets additional consistency 
note constraints descendants children 
furthermore constraints variables different subtrees cost value represents minimal number constraints need violate order instantiate variable descendants variable tree value descendant values represents optimal solution subtree rooted working leaves algorithm builds optimal solutions subtrees way root 
essentially gamma edges tree processed processing requiring consistency checks 
emphasized results powerful results obtained closely related context 
context csp multiple solutions objective choose solution maximizes value criterion function 
superficially context appears quite distinct pcsp context may single solution presumably criterion function simulate maximal satisfaction problem 
ordering usual branch bound advantageous order search heuristically increase likelihood ideally optimal solution early 
counts produced arc consistency method described sect 
order search 
done ordering values domain individual counts ordering variables basis statistic derived counts domain 
tests carried values ordered increasing counts 
allows values produce solution tested minimum near minimum distance solution quickly average yielding better bound early search 
statistic variable ordering mean counts associated values domain 
minimum count considered problems zero counts statistic sufficiently discriminating 
addition variables ordered decreasing mean count 
premise bound checking domains support early search increase likelihood bound reached higher levels search tree 
argument supported tests ordering opposite direction results appreciably worse cases worse basic branch bound especially sets harder problems 
variety variable ordering techniques studied csps considered pcsp context 
sophisticated cost estimates associated variables support additional pcsp specific techniques 
forms ordering arc consistency counts pruning arc consistency counts described sect 
course combined different ways 
extensions basic techniques discussed extended variety directions techniques considered 
obviously research program requires recapitulation entire history progress csps 
obvious line inquiry involves combining basic techniques 
emphasize development analysis basic atomic techniques 
conducted experiments algorithm combines retrospective technique backmarking prospective technique arc consistency count pruning ordering technique value ordering 
call algorithm rpo 
branch bound context suggests looking tighter lower bounds distance minimal distance solution includes set value choices 
obtain quicker pruning choices chance doing better solution 
arc consistency count pruning described sort thing simple efficient manner arc consistency counts computed preprocessing step 
forward checking analogues utilize kind dynamic arc consistency count 
shapiro haralick suggest elaborate lower bound computations dynamically utilizing complete arc path consistency analogue value choice inexact matching problems 
course tradeoffs consistency check savings bound computation costs 
tested analogue call extended forward checking partial constraint satisfaction successful algorithm implemented 
forward checking maximal constraint satisfaction described assigns inconsistency count value inconsistencies incurred adding choices 
extended forward checking goes forming lower bound estimate number inconsistencies accrue course choosing values remaining variables 
variables finds minimum inconsistency count assigned values variable 
adds counts inconsistencies incurred choosing sum lower bound estimate number constraints violated maximal solution contains turn fc algorithm extended forward checking algorithm efc changing test distance count inconsistency counts test distance count inconsistency counts sum minimum counts variable remaining variables version extended forward checking tested included forward checking refinements implemented fc algorithm called efc 
essentially playing game 
added chosen values best hope 
best done prune consideration time may change choices 
experiments overview algorithms described sect 
tested series experiments random problems 
experiments examined relative efficiency algorithms relation efficiency problem structure 
experiments algorithm run completion find maximal solution 
preliminary studies compared efficiency related algorithms 
included retrospective algorithms bj bmk basic branch bound bb 
second compared versions fc differed number placement tests distance plus counts bound 
third compared procedures arc consistency algorithm acc 
fourth main experiment tested promising algorithms experiments extensive set problems basic problem parameters domain size varied systematically 
fifth experiment best algorithms tested problems varying size number variables experiment included algorithms rpo efc 
sixth experiment obtained data efficiency time measure problems selected main experiment different levels difficulty algorithms 
problems finding maximal solution may feasible problem hard solve completely 
cases solution may acceptable 
branch bound techniques useful situation anytime feature initial solution algorithm time completion best solution far 
experiments examined efficiency different algorithms find solutions distances increasingly close maximal solution 
problems experiments larger versions random problems previous experiments addition set large coloring problems believed hard solve 
experiments resource bounds established placing limit number constraint checks performed program terminated limit reached 
random problem generation generating random problems features consider number variables number constraints domain size number value pairs included constraint fixed set problems 
values features determined constant probability inclusion method best explained example 
consider choice number constraints 
problems variables connected constraint graph constraints added 
generating random problem probability inclusion fixed say possible constraints considered inclusion random methods simulate probability 
probability set problems obtained expected value number constraints equal 
similar procedures determine domain constraint respectively 
limitation cases value 
element included zero value procedure repeated element non zero value obtained 
method advantages parameter value varied way easily characterized single probability value element probability inclusion sampling properties possible set elements relatively easy characterize 
experiments problems solutions required 
limited range probability values considered increases problems solutions produced 
values determine values maximum domain size equal twice number variables 
values determine number constraints added spanning tree derived choosing pairs variables random 
remainder probability values designated probability constraint domain constraint pair inclusion respectively 
called density problem relative satisfiability complement referred tightness constraint 
values chosen covered range possible values allowing similar degree variation case 
generation problem tested solutions 
solution strategy obtain insoluble problem identical parameter values constraint pair included values solution chosen random discarded pair values domains chosen random new constraint pair procedure repeated problem solutions 
experimental design experiments 
experiments set variable problems probabilities domain value pair inclusion took values mentioned section density 
gave categories problems 
problems generated category total problems 
experiment algorithms tested bb retrospective algorithms backjumping backmarking analogues bj bmk 
experiment compared variants fc described sect 

experiment compared variants bb incorporated different forms information derived arc consistency counts singly combination 
pruning count value ordering values domain increasing count ordering variables decreasing mean count values domains combination value variable ordering strategies combination pruning value ordering combination pruning value variable ordering 
experiment 
experiment compared promising algorithms experiments 
bmk fc varieties branch bound incorporated information counts obtained acc 
bb included 
experiment problem set expanded include probabilities constraint inclusion 
fully crossed design probabilities inclusion associated parameter described sect 

gave categories problems generated category total problems 
included problems experiments 
experiment 
experiment best retrospective prospective algorithms experiment bmk fc bb compared problems number variables varied 
addition extensions rpo efc included 
number variables ranged problems problem size 
preliminary tests feasibility higher values chosen respectively 
experiments problems category relatively easy solve 
experiment 
experiment algorithms compared respect run time bb bj bmk fc fc 
problems selected experiment order magnitude constraint checks branch bound 
similar ranges terms order magnitude obtained algorithms tested 
problems chosen level difficulty density total problems 
problems chosen parameter values probabilities inclusion varied 
run times obtained lisp time function 
experiments 
experiment problems variables problems group 
values experiment fact variable problems experiments 
consequence distance associated best solution known 
variable problems optimal solution obtained efc 
allowed complete evaluation suboptimal solutions obtained number constraint checks limited 
results variable problems large optimal solution number constraint checks limited 
algorithms tested variable problems bb bmk fc rpo efc fc tested variable problems 
fc efc discussed 
experiment similar procedure large really hard coloring problems 
classic graph coloring problems objective color vertex graph color chosen fixed number colors vertices joined edge color 
vertices correspond csp variables edges csp constraints 
problems involved colors variables constraints giving densities 
algorithms tested bb bmk efc 
rpo included arc consistency counts zero values coloring problems sort 
experiments sixth basic measure number constraint checks recorded number nodes searched 
experiment measures execution time time constraint checks 
garbage collection time basic set time subtracted total time calculating measures 
experiments analysis variance anova test statistical significance differences due algorithm variation problem parameter interactions factors 
tests statistical factors problem parameters 
factor appeared experiment fully crossed combination factors forming single experimental group 
algorithm solve problem separate factor problem groups repeated 
simple fixed effects design different problems chosen category algorithm introduce variation independence different treatments algorithms issue domain 
example consider design experiment 
factors crossed form separate categories problems repeated factor related algorithms tested 
factors second order theta theta algorithm interactions tested statistical significance standard null hypothesis differences groups related effect 
analyses done log transformed data reduce differences variance groups 
effect algorithms anova statistically significant algorithms compared mean performance tukey test nonorthogonal pairwise comparisons 
experiment performed analyses better understand performance characteristics relation problem parameters 
standard deviations obtained algorithm problem set measures skew asymmetry distributions performance scores 
pearson product moment correlations bb algorithms derived original scores 
algorithm multiple regression analysis respect problem parameters carried scores zero intercept 
experiments statistical analysis consisted paired comparison tests algorithms constraint checks including successive powers highest power response bound 
value constraint checks tested variable problems 
constraint checks required arc consistency checking added total case 
results 
experiments preliminary comparisons similar algorithms 
experiments algorithms clearly superior tested set problems 
experiment bmk markedly superior bb bj 
experiment fc efficient terms constraint checks variants fc better bb 
experiment versions bb variable value ordering pruning value ordering combination strategies generally superior variations bb 
results borne statistical analysis 
experiments effect due algorithms statistically significant experiment experiment experiment 
addition factors related problem parameters specifically differences highly significant statistically interaction factors 
exception experiment interactions algorithms factors statistically significant 
meaning significant effects related problem parameters understood fig 
gives main results experiment 
bmk bj bb domain size satisfiability mean constraint checks fig 

mean constraint checks branch bound bb backjumping bj backmarking bmk experiment function parameters domain size pd satisfiability pp shows problems harder average domain size increases effect greater increasing tightness constraints decreasing 
intuitively plausible 
greater importance relatively rapid change difficulty extreme values really difficult problems small part parameter space 
results consistent dechter pearl demonstration average random problems fairly easy solve 
experiment bj slightly superior bb stated bmk markedly superior fig 

importantly bmk showed substantial improvement basic branch bound difficult parts parameter space points associated larger domain size greater tightness constraints 
hand appeared bmk bj average relative improvement greatest larger values satisfiability domain size problems easier solve interaction detected anova probably overshadowed corresponding changes occurred algorithms 
observed differences performance supported individual comparisons means 
analysis difference bmk algorithms statistically significant comparisons difference bj bb 
experiment methods forward checking employed count checks fc fc superior algorithm depended directly constraint checks fc 
individual comparisons differences statistically significant related fc comparisons fc fc respectively 
versions markedly superior bb 
experiment improvement performance due strategies arc consistency counts depended part domain size reflected statistically significant interaction algorithms factor 
consider individual strategies pruning counts ordering values ordering variables basis counts 
pruning value ordering reduced number constraint checks relative basic bb algorithm variable ordering resulted increases marked 
strategies improved mean performance consistently fig 

interaction comparisons individual strategies statistically significant variable ordering pruning approached significance 
branch bound prune value order variable order var val order prune val ord fig 

mean constraint checks required algorithm bb combined strategies arc consistency counts obtained acc 
constraint checks shown function constraint satisfiability pp slice parameter space pd 
results basic branch bound included 
combining strategies arc consistency counts resulted greater improvement performance fig 
reflected individual comparisons 
pruning value ordering combined performance algorithm better strategy comparisons 
value variable ordering combined better strategy comparison statistically significant part superiority combination 
combination strategies showed best performance comparisons combinations strategies difference double ordering variables values statistically significant 
superiority larger domain sizes 

experiment comparing best algorithms experiments 
indicated algorithms tested experiment addition basic branch bound bb bmk fc branch bound algorithms arc consistency counts pruning value ordering strategies 
algorithms arc consistency counts included results experiment altogether conclusive concerning best algorithm group 
procedure combined arc consistency count strategies best perform problems small domain sizes comparison algorithms arc consistency counts considerable variability performance mean algorithm better means 
algorithm pruning value ordering differ statistically full combination algorithm combination algorithms incorporate variable ordering counts strategies result inferior performance respect bb individual problems 
experiment factor anova constraint checks associated algorithms highly significant statistically table pattern statistically significant results anova number nodes checked 
fact fairly consistent ordering portions parameter space tested fig 

bmk bb incorporating arc consistency strategies generally reduced number consistency checks basic bb algorithm factor 
fc reduced number factor 
terms means ranking performance worst best basic branch bound bb bb arc consistency strategies bb pruning consistency counts value ordering bmk fc 
comparisons mean performance anova showed statistically significant differences pair algorithms including arc consistency counts 
anova constraint checks showed statistically significant effects related problem parameter table 
addition interactions factors statistically significant 
effects domain size satisfiability interaction observed fig 
fig 

algorithms problem difficulty increased increasing domain size diminishing satisfiability 
hardest problems largest domains smallest number acceptable pairs constraint 
effects enhanced density constraint graph increased accounts interactions involve factor 
interactions algorithms algorithms statistically significant table 
contrast interaction algorithms significant higher order interactions involved algorithms factor 
perusal performance means suggests statistically significant interactions due large part acc combination algorithm 
algorithm average number consistency checks increased dramatically increases table 
statistically significant effects anova experiment factor df algorithm pd pp pc pd theta pp pd theta pc pp theta pc pd theta pp theta pc alg theta pd alg theta pc error note df degrees freedom associated factor value test statistic upper limit probability obtaining greater equal value differences associated factor 
algorithm 
interest apparent relation average difference fc bmk problems higher performance algorithms equal superior algorithms relative satisfiability decreased fc markedly superior cf 
fig 

reflected interaction anova algorithms amount increased dramatically decrease differences variability performance problem sets followed patterns similar differences means 
sets problems standard deviation bb greater algorithm remaining problem sets full combination acc algorithm variable 
fc smallest standard deviation performance sets 
distributions showed strong positive skew tail distribution right side median value longer tail left side 
correlations number constraint checks performed algorithm high exception acc algorithm incorporated variable ordering correlations 
correlation measure linear relation variables suggests algorithms similar performance characteristics respect problem parameters 
multiple regression analyses successful terms accounting variance 
adjusted value case contrast original untransformed scores 
examination residuals normalized plots measures influence individual scores domain size density repeated satisfiability fig 

mean constraint checks problem set algorithms experiment 
combination domain size satisfiability density values algorithms represented order branch bound bb arc consistency counts value variable ordering pruning arc consistency counts value ordering pruning backmarking bmk forward checking fc 
indicated residual values approximately normally distributed outliers 
multiple regression model algorithm coefficients ranged different algorithms range range 
size coefficients indicates size effect parameter assumptions regression model 
clearly domain size greatest influence followed density constraint satisfiability 
fundamental similarity performance different algorithms borne 

experiment effect number variables 
expected differences algorithm performance previous experiments maintained range problem sizes tested fig 

perspective appeared bmk fc similar performance characteristics reducing number constraint checks done branch bound factor range 
combining best retrospective technique bmk prospective ordering techniques pruning value ordering arc consistency counts materially affect result rpo reduced effort required bmk range 
may noted exceptions combination outperformed fc cases easiest outperformed fastest algorithm 
rpo efc variables fc bmk bb mean constraint checks fig 

effect number variables mean performance 
best algorithm clearly efc computed lower bound current counts inconsistencies 
consideration mean performance successively greater problem sizes indicated showed exponential growth increasing problem size problems parameters fig 
shows rate growth appreciably smaller 
variable problems reduced number constraint checks order magnitude comparison algorithms 

experiment evaluation overhead time 
total corrected time solve problem ranking algorithms resembled number constraint checks 
longest shortest time ranking bj bmk fc fc 
give idea actual differences time required means hardest problems tested experiment order constraint checks order seconds 
anova effect due algorithms statistically significant 
individual comparisons means differences bb bmk forward checking algorithms statistically significant case 
difference bmk fc statistically significant difference bmk fc 
difference forward checking variants statistically significant 
average time constraint checks ranking considerably different 
mean values bb sec bj bmk fc fc anova effect due algorithms statistically significant effect number constraints reflecting increased efficiency problems denser graphs 
measure bb bj clearly superior bmk fc individual comparisons 
fc superior bmk fc 
results indicate bmk fc incur relatively large overhead comparison algorithms 
case backmarking similar evidence csp version 
obvious decrease number constraint checks elaborate algorithms yields greater efficiency basic bb algorithm reflected total time required solve problems 

experiments finding solutions hard problems 
results increasing amount effort applied problem analyzed ways considering number constraint checks required reduce distance proportion total change possible difference number constraints best distance ii minimum distance constraint checks 
indicated measure derived variable problems 
algorithms initial drop due difference number constraints initial bound distance solution relation effort goodness solution approximated simple logarithmic function figs 

efc especially rpo required constraint checks find initial solution bb bmk algorithms effective initially constraint checks 
search phase se rpo solutions suboptimal distance faster algorithm terms constraint checks overwhelmed cost preprocessing 
bb rpo efc bmk distance reduction mean constraint checks fig 

mean constraint checks required reduce distance proportion difference number constraints best distance variable problems 
constraint checks best solutions rpo comparisons bb comparisons bmk constraint checks comparison efc bmk constraint checks 
differences rpo efc statistically significant 
checks algorithms bb maximal solutions problems 
bb rpo efc bmk best distance mean constraint checks fig 

best distance function number constraint checks problems variables 
variable problems fig 
effects similar superiority efc noticeable statistically signifi cant order magnitude checks 
addition difference rpo bmk statistically significant 
general trends smaller problems appear hold problem size scaled 
results variable problems consistent results 
bb rpo efc bmk best distance mean constraint checks fig 

best distance function number constraint checks problems variables 
results hard coloring problems similar fig 

retrospective algorithm bmk achieved better solution small number constraint checks efc eventually surpassed 
difference bmk efc great eventually attained statistical significance constraint checks 
case degree local consistency problems may responsible impressive performance efc relative bmk 
summary experimental results general analogues algorithms perform csps performed maximal constraint satisfaction problems 
basic set strategies range parameter values tested measures constraint checks total time obtain optimal solution analogue forward checking generally superior 
superiority evident parts parameter space problems difficult 
extensive testing elaborate algorithms reduced required extension forward checking performed better algorithm 
set variable problems example best algorithm reduced average number constraint checks approximately approximately 
bb bmk efc best distance mean constraint checks fig 

best distance function number constraint checks hard coloring problems 
despite general superiority type prospective strategy forward checking techniques local consistency arc consistency count preprocessing sophisticated retrospective algorithms bmk improved basic branch bound algorithm factor 
addition parts parameter space bmk comparable performance fc 
conclude techniques merit study especially efficiently combined forward checking methods 
data experiment suggest sparse problems combining arc consistency counts variable ordering puts high counts search sequence efficient average 
key factor appears size counts comparison best distance distance small putting higher counts effective pruning search tree 
strategy incorporated rpo algorithm preliminary data suggest may extremely effective technique problems low densities 
problems tested 
main result anytime experiments solutions percent optimum terms total distance reduction obtained reduction effort equal greater order magnitude 
earlier experiments efc best algorithm range effort 
bb bmk efficient criterion goodness relaxed sufficiently 
experiments show random problem generation parameterized straightforward manner produce subpopulations problems vary statistically basic features number constraints domain size satisfiability 
allowed examine algorithm performance terms space problems defined parameters 
regions space delineated typical problem easy difficult solve data population characteristics algorithm performance regions obtained 
data aid potential user deciding algorithms consider indicating costs decisions 
partial constraint satisfaction focused maximal satisfaction facilitate presentation testing algorithms 
forms partial satisfaction large extent algorithms generalize obvious ways 
section general model partial satisfaction 
metrics branch bound algorithms sought solution violates minimal number constraints 
difference perfect solution partial solution measured different subtle ways 
term distance suggests branch bound technique requires metric compare values considered stage search best solution far 
preferences expressed ordering constraints representing importance organizing constraints hierarchies introducing priorities 
preferences reflected branch bound metric assigning weights constraints 
preferences associated subsets domains constraints individual values pairs values opposed entire constraints 
wearing striped tie polka dot shirt bad wearing bow tie 
constraint deviations combined local global fashion 
branch bound metric sum weights violated constraints maximum weight compute average appropriate 
initial constraints may viewed ideal points seek approximate measure 
may hidden agenda embodied metric 
example may wish drive problem weaker version easily solvable removing constraints yield tree structured problem 
problem spaces measuring success partial solution evaluating number importance violated constraints 
criterion believe directly considered 
weakening constraints effect creates different problem 
alternatives weakening constraints provide alternative problems 
may wish solve problem close original sense having solution set similar original 
removing set constraints problem allowing thousands new solutions removing set allow single new solution 
consideration arises example viewing constraint knowledge base debugging partial constraint satisfaction problem 
knowledge base erroneously overconstrained change allows small number new solutions keeping occam razor allows 
formally consider space problems ordering solution sets 
problem space partially ordered set 
ps set constraint satisfaction problems partial order ps defined follows iff set solutions subset set solutions set solutions subset set solutions sets equal write say weaker natural problem space partial constraint satisfaction problem initial problem consists problems set obtained considering ways weakening constraints allowing additional consistent combinations values 
general ps contain problems stronger problems partial order 
collect constraints problems ps single problem problems ps regarded weakenings may natural consider space include may wish specify problem weakened 
weaker problems may semantic sense 
may possible desirable violate constraints arbitrarily allowing individual pairs values violate associated constraint done 
example dressing domain decide fashion emergency burst avant creativity eschew prohibition mixing stripes checks opposed making individual exception striped tie checked shirt 
may establish levels informality fashion constraints corresponding informality occasion dressing 
may semantic sense preset hierarchy constraints weakening constraint requires moving upward hierarchy opposed making arbitrary individual exceptions 
constraint hierarchy reminiscent concept hierarchies provide initial bias machine learning settings intriguing think constraint satisfaction process form concept learning synthesizing relationship positive negative information 
specification problem space ps clearly affect efficiency search process 
way specify problem space specify generators operators take problem permitted set problems may global restrictions generators choose constraint column column try move problem space search solvable problem may prove desirable take consideration opportunities opened altering problem way removing fashion restriction may removing 
process weakening csp naturally viewed involving options enlarging variable domain buying new shirt enlarging constraint domain deciding old shirt old tie worn removing variable deciding wear tie removing constraint deciding worry socks match 
turn expressed terms basic process enlarging constraint domains 
view variable domains unary constraints 
enlarging binary constraint contains pairs values specified domains variables tantamount removing constraint time variable domains may enlarged 
removing constraints variable way tantamount removing variable 
partial constraint satisfaction problems partial constraint satisfaction problem specified formally supplying initial constraint satisfaction problem problem space ps containing metric space necessary sufficient solution distances solution partial constraint satisfaction problem defined problem problem space ps solution problem metric distance solution sufficient distance equal optimal solution metric distance minimal problem space 
optimal solution dominant optimal solution involves problem metric evaluates solution compares problems counting evaluating violated constraints 
course way compare problems compare constraints 
ideally define metric terms partial order defining distance number solutions shared metric measures number solutions added weakening natural measure partial solution course computing metric easy 
finding set optimal solutions metric wish distinguish considering different problems induced solutions 
problem induced partial solution problem problem obtained adding constraints inconsistent pairs values partial solution compute full solution sets induced problems look dominant optimal solutions metric operates solution sets 
may wish consider alternative metric tend reflect natural metric natural metric count number permitted value combinations shared constraints extent metric reflect metric partial order 
obtained weakening constraints monotonic nature constraint satisfaction problems 
words constraint ij associated constraint ij associated ij subset ij particular simple metric maximality studies counts number violated constraints metric form 
viewing partial constraint satisfaction search problem space facilitates consideration integrating branch bound different levels search process produce different algorithms 
natural points perform integration failure points standard backtracking algorithm 
basic branch bound partial constraint satisfaction algorithm integrates branch bound lowest level backtrack failure 
value variable rejected normal backtracking view algorithm determining constraints violated weakening problem adding precisely constraint elements needed permit searching problem space solvable problem desirable avoid changing problem ways facilitate progress 
example problems equivalent need considered 
nice feature basic branch bound algorithm type partial constraint satisfaction problem designed able minimally different problem required proceed problem choice point 
simpler choice integrating branch bound add backtracking top level failure backtracking solution 
branch bound loop added outside backtracking algorithm 
loop run problems problem space keeping track closest problem solved far 
problems closer rejected immediately 
alternative problems generated order reflects distance original problem closest furthest generation point necessary bound reached 
top level integration branch bound point marks termination pcsp algorithm 
branch bound integrated failure points extremes 
natural compromise occur points values variable exhausted standard backtrack search 
times options alternative problems may explored 
tradeoff involved choice integrate branch bound 
integrating lower level take greater advantage backtrack pruning avoid unnecessary effort 
hand integrating higher level allow greater flexibility heuristically guiding search space alternative problems 
preliminary experiments comparing high level low level approach partial satisfaction domain debugging constraint knowledge bases reflect tradeoff 
summary generalized view reached partial constraint satisfaction search space alternative problems number potential advantages area 
facilitates consideration global concerns suitability single solution 
specifically encourages consider partial solution weakening problem manner permits solutions 
naturally incorporates practical concerns available constraint modifications 
facilitates generation alternate problem solving strategies take global view effective means modifying problem 
standard constraint satisfaction problem csp solution techniques analogues solving partial constraint satisfaction problems cope take advantage differences csp pcsp 
branch bound natural analogue backtrack search 
local consistency count analogue local consistency 
pcsp analogues retrospective prospective ordering techniques csps 
extensive experimentation random problems different structural parameters revealed effectiveness set pcsp techniques function parameters 
general model developed involving standard csp partially ordered space alternative problems metric measure distances problems original csp 
summary firm algorithmic experimental theoretical foundation laid study problems impractical impossible satisfy fully set constraints 
material supported national science foundation 
iri 
iri 
part done author visiting scientist mit artificial intelligence laboratory 
portions taken copyright international joint conferences artificial intelligence permission :10.1.1.14.7954
peter cheeseman bob kanefsky supplying really hard coloring problems 

kuh 
regression diagnostics 
wiley new york ny 

borning freeman benson kramer woolf 
constraint hierarchies 
proceedings acm conference object oriented programming systems languages applications pages 

borning maher wilson 
constraint hierarchies logic programming 
proceedings sixth international conference logic programming pages 

kanefsky taylor 
really hard problems 
proceedings ijcai pages 

cooper 
visual occlusion interpretation ambiguous pictures 
ellis horwood 

dechter 
enhancement schemes constraint processing backjumping learning cutset decomposition 
artif 
intell 

dechter dechter pearl 
optimization constraint networks 
oliver smith editors influence diagrams belief nets decision analysis pages 
wiley 

dechter pearl 
network heuristics constraint satisfaction problems 
artif 
intell 

dechter pearl 
tree schemes constraint processing 
artif 
intell 

latombe 
making compromises antagonistic constraints planner 
artif 
intell 

feldman golumbic 
optimization algorithms student scheduling constraint satisfiability 
comput 


fox 
constraint directed search case study job shop scheduling 
morgan kaufmann los altos ca 

freuder 
backtrack free backtrack bounded search 
kanal kumar editors search artificial intelligence pages 
springer new york ny 

freuder 
partial constraint satisfaction 
proceedings ijcai pages 

freuder 
complexity tree structured constraint satisfaction problems 
proceedings aaai pages 

gaschnig 
general backtrack algorithm redundant checks 
proceedings ijcai page 

gaschnig 
experimental case studies backtrack vs waltz type vs new algorithms satisficing assignment problems 
proceedings second national conference canadian society computational studies intelligence pages 


backtrack programming 
acm 

haralick elliott 
increasing tree search efficiency constraint satisfaction problems 
artificial intelligence 


sensitive relaxation overspecified constraint network 
proceedings second international symposium artificial intelligence 

freuder 
debugging assistant incompletely specified constraint network knowledge bases 
int 
expert syst res 
appl pages 

kirk 
experimental design 
brooks cole pacific grove ca nd edition 

kumar 
algorithms constraint satisfaction problems survey 
ai mag 

lacroix 
preferences putting knowledge queries 
proceedings th international conference large data bases pages 

lawler wood 
branch bound methods survey 
oper 
res 

mackworth 
consistency networks relations 
artif 
intell 

mackworth freuder 
complexity polynomial network consistency algorithms constraint satisfaction problems 
artif 
intell 

meiri dechter pearl 
tree decomposition applications constraint processing 
proceedings aaai pages 

meseguer 
constraint satisfaction problems overview 
ai commun 

mittal falkenhainer 
dynamic constraint satisfaction problems 
proceedings aaai pages 

mohr masini 
old discrete relaxation 
proceedings european conference artificial intelligence pages 

nadel 
constraint satisfaction algorithms 
comput 
intell 

reingold nievergelt deo 
combinatorial algorithms theory practice 
prentice hall englewood cliffs nj 

rosenfeld hummel zucker 
scene labeling relaxation operations 
ieee trans 
syst 
man cybern 

shapiro haralick 
structural descriptions inexact matching 
ieee trans 
patt 
anal 
mach 
intell 

snow freuder 
improved relaxation search methods approximate constraint satisfaction maximin criterion 
proceedings eighth biennial conference canadian society computational studies intelligence pages 

van hentenryck 
constraint satisfaction logic programming 
mit cambridge ma 
article processed macro package llncs style 
