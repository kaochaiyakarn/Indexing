parsing constrained grammar formalisms vijay shanker university delaware david weir university sussex scheme extend recognition algorithm context free gram mars cfg derive polynomial time recognition algorithms set generate superset languages generated cfg 
describe scheme developing cocke kasami younger cky pure bottom recognition algorithm lin ear indexed grammars show adapted give algorithms tree adjoining grammars combinatory categorial grammars 
polynomial time recognition algorithm combinatory categorial grammars aware 
main contribution general scheme propose parsing variety formalisms derivation process controlled explicit implicit stack 
ideas pre sented suitably modified parsing styles generalized framework set lang 

presents scheme extend known recognition algorithms context free grammars cfg order obtain recognition algorithms class grammatical formalisms generate strict superset set languages generated cfg 
particular scheme give recognition algorithms linear indexed grammars lig tree adjoining grammars tag version combinatory categorial grammars ccg 
formalisms belong class mildly context sensitive grammar formalisms identified joshi basis properties generative capacity 
parsing strategy propose applied formalisms listed similar characteristics outlined derivational process 
main ideas underlying scheme influenced observations constructions proofs equivalence formalisms head grammars hg vijay shanker weir vijay shanker weir 
similarities tag hg derivation processes context free grammars cfg 
reflected common features parsing algorithms hg pollard tag vijay shanker joshi cky algorithm cfg kasami younger 
particular happen step derivation depend finite set states derivation cfg states considered nonterminal symbols 
property refer context freeness property important allows keep limited amount context recognition process department computer information sciences university delaware newark de 
mail vijay udel edu 
school cognitive computing sciences university sussex brighton bn qh mail cogs susx ac uk 
association computational linguistics computational linguistics volume number results polynomial time algorithms 
recognition algorithms mentioned cfg hg tag reflected fact recognizer encode intermediate stages derivation bounded number states 
array entries associated component input 
case cky algorithm presence particular nonterminal array entry encode fact nonterminal derives associated substring input 
context freeness cfg consequence need encode way ways nonterminal came placed array entry 
respect derivation processes ccg lig appear differ cfg 
systems unbounded structures replace role played nonterminals controlling derivation choices 
suggest context freeness property cfg hg tag derivations longer holds 
unbounded stacks encode unbounded number earlier derivation choices 
fact path sets cfg hg tag derivation trees regular languages path sets ccg lig context free languages 
respect recognition algorithms suggests array entries contain nonterminals case cfg need contain complete encodings unbounded stacks giving exponential time algorithm 
lig ccg stacks control derivations limited different branches derivation share stacks 
despite observations context freeness property fact hold 
detailed explanation 
propose method extend cky algorithm handle limited stacks ccg lig 
chosen adapt cky algorithm simplest form bottom parsing 
similar approach earley algorithm possible considered 
stacks explicit lig formalism describe approach detail developing recognition algorithm lig sections 
show general approach suggested parser lig tailored ccg section 
discussion tag grouped hg 
tag viewed making stacks way lig ccg 
section show lig algorithm section adapted tag 

linear indexed grammars indexed grammar aho viewed cfg objects associated stack symbols 
addition rewriting nonterminals rules grammar effect pushing popping symbols top stacks associated nonterminal 
gazdar discussed restricted form indexed grammars stack associated nonterminal left production associated occurrences non terminals right production 
stacks bounded size associated occurrences nonterminals right production 
call linear indexed grammars lig 
path set tree set strings labeling paths root frontier tree 
path set tree set union path sets trees set 
name linear indexed grammars refer different restriction indexed grammars production restricted single nonterminal right hand side 
vijay shanker david weir parsing constrained grammar formalisms definition lig denoted vn vt vi vn finite set nonterminals vt finite set terminals vi finite set indices stack symbols vn start symbol finite set productions 
adopt convention fl subscripts primes de note members denotes stack symbol 
usual denote nonterminals denote terminals denote members 
definition pair consisting nonterminal say string stack symbols say called object grammar written 
grammar define set objects vc vn 
denote strings vc vt 
write denote non terminal associated arbitrary stack string top 
denote empty stack associated general form pro duction lig 
ol ai oq 
oq wi lai oq 
wn wl members 
definition derivation relation defined 
production fl vc wv rico 
ai oq tic wi lai oq 
wn 
reflexive transitive closure 
result linearity general form rules observe stack flc associated object left hand side derivation flc associated object right hand side initial part fl common 
derivation say object distinguished child flo 
deriva tion distinguished descendant relation reflexive transitive closure distinguished child relation 
language generated lig 
example lig yb generates wcw contains productions 
bs 
derivation tree string 
computational linguistics volume number derivation tree lig 
sf av adopting general form rules restrict attention grammars rules form 
fact easily seen constitute normal form lig 

vt length len 


ap 
vp 

ym ols ap 


ap 

allow symbols right hand side productions intend develop cky style algorithms 
rules say af 
yp primary constituent secondary constituent 
notice derivation rule primary constituent yields distinguished child 
grammatical theories stack arguments top stack primary constituent determines secondary constituent combine 
terminators consider may extend cky algorithm recognition lig 
fixed grammar input 
recognition algorithm complete array encoding stored oq ai ai 
algorithm operate bottom 
example contains rule 
ym ap 
find encoding ap yp ii dp encoding ii dp ds encoding yl 
ym stored vijay shanker david weir parsing constrained grammar formalisms ii dp dsl 
encoding scheme 
straightforward possibility store complete encoding 
dp ds 
general object derives string length length 
objects derive substring input length constant space time complexity algorithm exponential worst case 
inefficiency approach seen drawing analogy algorithm cfg 
suppose storing sets nonterminals array entry store set trees containing derivation subtrees yield corresponding substring 
problem number derivation trees exponential respect length string spanned 
need store derivation trees considering combination subderivation trees cfg nonterminals root tree relevant determining production licenses combination 
likewise behavior manipulation stacks lig argue necessary store entire stack 
instance consider derivation depicted tree shown point view recording derivation bottom parser cky 
node labeled fl 

distinguished descendant node labeled fl 
shown 
viewing tree bottom node labeled fl 
node node labeled fl 
gets exposed top stack 
behavior distinguished descendant label form fl 
len 
order record derivation fl 
sufficient store 
access entry records derivation fl 
entry pointer entry fl enable recovery stack top symbols 
yk 
scheme works 
instance suppose recorded pointer entry fl 
suppose looking symbol top ft possible similar way entry record just pointer entry retrieve ft situation occur arbitrarily times 
consider derivation depicted 
derivation indicated branch containing distinguished descendants 
assume node labeled 
closest distinguished descendant fl node label form fl yl len 
node labeled fl fl rn label form fl fen 
entries representing derivations fl 
fl 
point back entry derivation fl entry fl point back entry shall formalize notions defining terminator 
instance consider grammar example derivation 
general derivations form cab exists productions form length stack objects bounded length strings derive 
ccg parsing algorithms proposed far follow strategy pareschi steedman tomita 
computational linguistics volume number recovering rest stack 
recovering rest stack 
definition terminator 
vijay shanker david weir parsing constrained grammar formalisms definition suppose derivation tree depicts deriva tion similarly conditions hold fl 
ub fl ya lq flq uvw flq lq ub flq lq uas ols flq nodes labeled flq 
lq 
flq distinguished descendants node labeled flq lq respective trees 
distinguished descendent labeled nodes labeled flq 
lq flq 
lq form flq kc len 
note nodes labeled flq lq flq lq need different 
node labeled flq terminator node labeled flq lq 
clear context saying node terminator assume terminators defined objects participate derivation 
instance derivations say flq terminator fl 

derivation clear context omit mention derivation derivation tree 
additionally say node object terminator terminator state properties terminators influence design recognition algorithm 
definition grammar define mcl maximum change length mcl max 

ap production henceforth write mcl grammar question known context 
observation derivation tree node say terminator say dis descendant 
node labeled flc len node labeled flq vn ff vi 
furthermore mcl 
observation derivation tree node terminator unique terminator 
computational linguistics volume number node question claiming unique terminator exist 
see case node 
terminator say observation assume labeled fl 
flq respectively 
definition terminators assume parent terminator node say label form fl 

ym 
definition terminators node inclusive label form fl yl 
la len immediately follows tit closest distinguished descendant length stack object labeling strictly length stack object labeling 
uniqueness terminators follows 
observation consider derivation fl yl 
yk fl yt uvw fl terminator fl tk 
fl fl derivation fl 
fl yt uv fl terminator fl 

follows fact derivation fl yt fl yl 
yk independent ft replace fl fl 
important property crucial obtaining polynomial time algorithm 
note nodes terminators 
example node labeled parent node labeled corresponding production terminal symbol obviously node terminator 
definition grammar define mtl maximum length terminal production mtl max len production vt 
case mcl mtl mtl 
observation derivation len mtl terminator 
steps derivation len mtl 
assume node say question labeled object distinguished descendant say label fl fl 
len fl mtl may rewrite fen len fl find closest distinguished descendant labeled len fen 
node terminator arguments observation 
observations sections explain way represent derivations parsing table 
conclude section observation bearing steps recognition algorithm 
vijay shanker david weir parsing constrained grammar formalisms observation consider derivation 
fl tia 
fl 
yk fl 
ul vl fl ul vl wv ap 
yk yk distinguished child 
terminator ap fl yk 
fl terminator fl 
fl terminator fl tt 
fact case fl tt terminator terminator 
seen considering derivation shown noting sharing terminator fl 
fl 

recognition algorithms cky algorithm dimensional array ai 
ai representation derivation recorded encoding 
assume input 
start discussion considering data structures record objects derivations 
anatomy entry mentioned earlier stack object unboundedly large 
find compact way store encodings objects size bounded grammar 
section provide motivation encoding scheme recognition algorithm considering bottom application rule encoding primary constituent 
ap head 
object nonterminal ap top stack tp match primary category rule 
requirement object included entry needed determine rule apply 
component denoted lap vp called head entry 
general entry ii head encodes derivations ai ai cl object form fl fl 
terminator pointer 
encoding object ap fl tp primary constituent derives substring ai dp input string 
stored array element dp cky style recognition algorithms 
consider encoding ap fl yp sufficiently long fl yp 
head lap entry sufficient determine object question match primary category rule need store information order determine content rest stack 
production combination ap fl results fl 
order record derivation fl need know top symbol stack fl symbol top stack associated primary constituent 
need recover identity computational linguistics volume number symbol encoding primary category 
introduced notion terminators 
mentioned section terminators access information rest stack 
encoding ap fl yp store information allows access encoding terminator 
part entry encoding terminator called terminator pointer 
middle 
note object ap fl yp derivation ap fl ai ai dp terminator mcl 
observa tion follows terminator pointer determine st symbol top 
assuming fl fl yl 
yk terminator pointer allow access fl 
recall definition terminator fl yl 
yk form fl yt 
st symbol top fl yp symbol top stack terminator 
need record string yl yk encoding ap fl 

part entry called middle 
summarize entry stored dp fl yl 
yk yp assumed sufficiently long know fl 
yp guaranteed tor head ap yp tail comprised middle yl yk terminator pointer 
note length middle mcl observation know mcl 
call entry kind terminator type entry 
discuss need store order point tor 
suppose record derivation ai ai fl yl 
shown 
assume fl yt terminator derivation 
fl yk ai 
lat fl dt 
ai ai dt dt ai ai 
ai observation follows sufficient dt terminator pointer 
entry head tl dt represent general derivation fl yt dr 
matches case fl fl observation fl 
yk lq ai lat fl dr ai ai 
head information plus indices terminator pointer captures essence observation 
structure sharing allows achieve polynomial bounds space time 
note string derived terminator dr substring ai ai 
case dr say dt dl 
define dt dl dtl dl dtl dl 
terminator type entry terminator pointers form dtl dtl dl number terminator type entries 
definition grammar define msl maximum secondary constituent stack length msl max len secondary constituent production henceforth msl msl 
vijay shanker david weir parsing constrained grammar formalisms consider question terminator type entry appropriate 
course ai ai store entry ii dpl terminator derivation 
observation know len mtl exists terminator derivation 
possible grammar msl mtl 
len mtl object terminator match secondary category rule len msl 
order verify object matches secondary category rule need consider entire stack object 
ai ai length exceed msl convenient store entire stack object potentially match secondary category rule 
certain object stored entirety len msl terminator type entry len max msl mtl 
prefer terminator type entry representing derivation terminator say fl len fl max msl mtl len max msl mtl 
point choice convenience feel leads simpler algorithm 
alternate choice lead slightly different algorithm 
definition define constant ttc terminal type case ttc max msl mtl 
deriva tion fl 
say fly 
vk tc property iff terminator say len ttc 
fl 
ai ai fl 
tc property record object entirety ii 
order entry format terminator type entry say entry head tail middle 
nil terminator pointer 
note case middle empty string instance encode ai 
ai 
general say top rest ft say top rest 
summarize structure entry ii described rules 
entry consists head tail 
head consists nonterminal stack symbol 
tail consists middle terminator pointer 
exact nature middle terminator pointer 
terminator pointer may form iat tl dtl vn dtl li 
case middle string stack symbols length 
form terminator pointer encoding derivation object terminator stack length greater equal ttc 
recall called type entry terminator type entry 
terminator pointer nil 
middle possibly empty string stack symbols 
length middle ttc mcl 
form terminator pointer encoding derivation object satisfy tc property computational linguistics volume number terminator terminator exists stack length ttc 
recognition algorithms lig full algorithm involves number cases develop stages restrict ing forms productions 
algorithm considers restricted form productions introduces lies core approach 
relax restrictions degree 
giving algorithm stage switch discuss algorithm adapted yield ccg 
section consider relaxation restrictions form lig productions help produce algorithm tag 
regardless set restrictions consider algorithm shall establish proposition holds 
proposition 
yk dt fl fl 
yk ai la fl dt ai ai 
ai fl terminator fl yk len fl yt ttc 
yk tk nil lq ai ai derivation 
yk yk tc property 
algorithm 
recall general form rules considered follows 

vt len 

rm ap 
ym ap fp 

ap 
stage assume restrictions hold rules 
type production assume vt len 
mtl 
len productions type type msl 
productions type 
give rules specify entries get added parsing array 
control structure algorithm cky style dynamic program ming structure added 
assume input vijay shanker david weir parsing constrained grammar formalisms initialization phase initialization phase algorithm store lexical objects objects deriving terminal symbol step entirely single entry 
words rule ai top rest ee nil inductive phase productions type type considered 
assume presence production grammar 
yl 
ap 

suppose considering entries included find dp ds dp ds entry ap ypl flp tpp dp 
consistent rule primary constituent 
regardless tpp nil fl ap yp ai ai dp 
tpp nil entry top rest nil dp ds 
consistent rule secondary object 
dp ds may assume ols ai dp 
ai 
presence entries specified derivations rep resent yl 
ap yp ai ai 
derivation recorded entry 
content entry depends sev eral factors value terminator pointer entry primary constituent tpp nil length middle entry tip 
determine new entry terminator type entry 
cases 
case new object stored 
top stack object obtained stack associated primary constituent 
done depends entry encoding primary constituent terminator type 
tpp nil means primary constituent represented entirety primary constituent ap 
tpp nil primary constituent satisfy tc property terminator stack length greater equal ttc new constituent encoded terminator type entry 
rule ps lap pl tip nil dp top rest nil dp dp ia flp rest flp nil similar arguments consider production 

ap 
computational linguistics volume number rule counterpart rule ps corresponds production 
ap 

rule sp top rest nil ds ap vp tip nil ds ds top tip rest tip nil tpp nil entry primary constituent ap tip dr 
primary constituent ap assume terminator fl yt len ttc 
note len flp yp 
entry new object determined len tip len tip 
case len terminator primary constituent len terminator new object 
case noted observation 
considering case len tip may write tip yk 
case new object primary constituent terminator primary constituent tc property tpp nil new object encoded terminator type entry 
rule rule ps ap tpp dp tpp vt dt top rest nil dp dp tk tpp cp henceforth shall give ps versions rules omit sp versions 
consider case len tip 
rewriting tip entries represent derivation fl len fl yl len fl ttc 
ti ap ti ai 
ai ap ai 
lat 
lat dt 
ai dp ai ti yt terminator ap ti yp observation follows terminator terminator ti yl derivation terminator fl yt fl yt terminator ti yl 
additionally derivation ti yl satisfies tc property ti yt tc property 
terminator type entry record derivation ti yl terminator type entry 
objects share terminator exists terminator pointer record derivations 
fore suppose terminator pointer ap tip yt dt lo cate entry yt tit dr 
suggest addition entry indicates rule lig parsing ps indicates primary constituent appears secondary constituent 
similarly sp indicate secondary constituent appears primary constituent 
vijay shanker david weir parsing constrained grammar formalisms ia tit regardless nil 
give cases nil iar dr dr form different rules 
shall see rules appear different points control structure parsing algorithm 
rule ps ap dt top rest nil cp dp dp dp fit nil rule ps ap vp dt top rest nil dp dp flt tt fit nil dt fit ar yr jr dr case length stack new object equal primary object 
fact terminator primary object exists terminator new object primary object terminator new object 
encoding new object easily derived primary object simply modifying head change top stack symbol 
rule ps ap tp tip nil dp top rest nil dp dp tip nil rule ps ap tip dt dp top rest nil dp dp case primary constituent ap new constituent yl 

fact case primary constituent terminator 
ym 
course mean derivation new object recorded terminator type entry 
terminator type entry len tip ttc 
order determine length stack entry primary constituent tp tip tpp le pii dp consider terminator type entry tpp nil 
computational linguistics volume number tpp nil length stack terminator primary constituent greater equal ttc 
means stack length primary constituent terminator new object exceeds ttc 
rule rule ps ap tp tip tpp dp tpp iat dr top rest nil dp dpl 
ap yp dp tpp nil primary constituent terminator new object repre sented entirety 
order determine encode new object terminator type entry look entry primary constituent 
obtain rules rule ps len tip yp ttc pl tip nil dp top rest nil dp dp 
tm nil rule ps len tip yp ttc ap tip nil dp ias top rest nil dp dp ym yl 
lap dp discussions follow find convenient refer entries mentioned rules antecedent entries entries appear antecedent rule consequent entry entry appears consequent rule 
ex ample lap pl tip nil pii dpl ias top rest nil pii dp dpl antecedent entries rule ps ia ym ap dp added entry consequent rule ps control structure start giving simple control structure recognition algorithm follows dynamic programming style cky algorithm 
vijay shanker david weir parsing constrained grammar formalisms section modify notation entries slightly 
discussion terminator pointer terminator type entry contains pair indices repre senting input positions 
effect dimensional array 
alter native saying fl ca say fl dt 
alternative saying oe fl nil say fl nil 
considered array size 
specification algorithm restate rules discussed previous section 
indicate control structure rule fits 
example state rule ps dp loops mean current values dp ds consider production form 
yl 
ap 

production look entries form ap tip nil dp tip top rest nil dp dp 
event find entries add top tip rest flp nil 
entries form fl cat dt dt form ca fl nil entries 
space complexity algorithm nd 
note body loop attempted possible values dt dr range loop time complexity 
asymptotic complexity algorithm improved simple rearrangement control structure 
key point steps involving rules ps sp split parts 
consider example rule ps repeated 
rule ps ap dt top rest nil ep dp gp dp dp fit ar yr dr fit ar dr rule corresponds production 
ap 

values necessary determine span substrings derived primary constituent secondary constituent values dt dr needed locate entry terminator cat fit car dr place new entry appropriate parsing table element 
values dr required part value need known second part 
indicates second part need done loop dq modify control structure way 
loop appears loops dt find entries primary secondary constituents 
having relevant entries record head new entry tip terminator pointer primary constituent cat dt 
dimensional array called temp store ca 
outside loop outside loops dt loops loops vary dt dr note dr dr order locate entry terminator information recorded temp 
having entry computational linguistics volume number algorithm initialization phase rule loop fori ford loop rule ps ps ps ps dp 
dt dt loop dt loop rule ps ps ps ps dp dr dt dt dr rule ps dp dr loop loop loop dt loop dt dt loop dr loop rule ps ps ps ps ds dr dt dt dr rule sp ds loop dr loop loop dt loop loop loop loop algorithm 
vijay shanker david weir parsing constrained grammar formalisms terminator store resulting entry 
steps captured rules 
specific value rule ps rule ii ps ap dr top rest nil dp clp cl temp dt temp dt fit ar dr dt fit ar dr similarly assume pair rule sp rule ii sp corresponding rule sp leads algorithm 
algorithm drop sp rules specify ps rules sake simplicity 
correctness algorithm established correctness algo rithm established appendix lemma 
lemma grammar input entry fl tp added algorithm fl tp added algorithm 
outline proof induction base case corresponding initialization step algorithms 
difference algorithms apart control structure rule ps rule sp algorithm versus rule ps rule ii ps rule sp rule sp algorithm 
rule ps add entries form yl fit ar jr dr 
establish fit ar dr added due application rule ps exist entries form ap dt dp top rest nil dp dp flt ar dr dt production 
ap 

induction entries exist added temp dt rule ps rule sp fit ar jr dr added rule ii ps 
combinatory categorial grammars combinatory categorial grammars ccg steedman extensions classical categorial grammars function composition function ap plication allowed 
addition forward backward slashes place conditions concerning relative ordering adjacent categories com 
definition set categories generated set vn atomic categories defined smallest set members vn categories cl categories cl el 
computational linguistics volume number algorithm initialization phase rule ford loop initialize temp dt dt rule ps ps ps ps dt dp dt loop dp dt loop rule ps ps ps ps ps loop dt loop dp loop dt dt loop dt loop dr dt dt dr rule ii ps loop dr loop dt loop loop loop loop algorithm 
definition ccg denoted vt vn vt finite set terminals lexical items vn finite set nonterminals atomic categories distinguished member vn function maps element vt finite set categories finite set combinatory rules combinatory rules form 

forward rule form 




backward rule form 
zl 

vijay shanker david weir parsing constrained grammar formalisms zl 
zm meta variables 
rules correspond function application function composition 
note set contains finite subset possible forward backward rules ccg combinatory rules available 
definition forward backward rules say resp 
primary constituent forward resp 
backward rules zl 
secondary constituent rule 
notion distinguished child defined case lig category distinguished child parent corresponds primary constituent rule 
distinguished descendant reflexive transitive closure distinguished child relation 
discussing ccg notational conventions variables primes subscripts range forward backward slashes categories respectively 
meta variables fl strings directional categories string form cl 
non atomic categories members vn 
derivations ccg vt vn involve combinatory rules defined follows strings categories terminal symbols 
clc instance rule clc vt category 
string languages generated ccg 
example ccg generates wcw 
set rules includes rules 
zl zl zl zl rules target category matched shows derivation string 
find convenient represent categories minimally parenthesized form parentheses needed override left associativity slashes minimally parenthesized form defined follows 
steedman allow certain limited restrictions substitutions variables combinatory rules 
discussion restrictions vijay shanker weir press 
included formal definition significant impact algorithm 
computational linguistics volume number ccg example derivation tree 
jf sit odr definition minimally parenthesized form vn 
cl minimally parenthesized forms categories respectively 
minimally parenthesized form 
category minimally parenthesized form minimally parenthesized form 
definition category 
ncn minimally parenthesized vn cl cn minimally parenthesized categories 
target category 
denoted tar arity 
denoted arity argument categories 
inch denoted args ci 
ccg lig showing general parsing scheme illustrated lig recognition algorithm instantiated recognition algorithm ccg show ccg lig closely related 
details examination relationship ccg lig may weir joshi weir 
minimally parenthesized category 
viewed atomic category associated stack directional argument categories ilc 

rule 
xi 
instance apiece 
inch 
apiece 


asl ai 
cm 
ll 
vijay shanker david weir parsing constrained grammar formalisms instance 
matches category apl 
ncn matches atomic category example nonatomic category second zi matches ci derivation involving second instance viewed bottom seen popping top directional argument asl primary category pushing directional arguments 
instance combinatory rule appears closely resemble lig production 
example case second instance ap 
ilc 
ap 
show set stack symbols lig set directional argu ment categories need concerned finite 
definition useful category respect grammar 
set argument categories args ccg vt vn defined args uc args 
observation useful category args args finite set determined gram mar observation shown induction length derivation string base case corresponds lexical assignment trivially args args 
inductive step corresponds combination rule form 

inductive hypothesis useful category matching 
take arguments args finite set resulting useful category shares property 
property possible adapt lig algorithm ccg 
note cky style ccg recognition need record derivations useful categories 
observation follows lexical category assignment determines number stack symbols need concerned 
variables combinatory rule essential sense number categories usefully match bound grammar 
fore possible map combinatory rule equivalent finite set instances ground categories args substituted variables zl zm combinatory rule 
result grammar slight notational variant lig ccg variable lig notation perform similar roles 
purpose constructing recognition algorithm unnecessary undesirable expand number rules way 
adapt lig algorithm effect constructs appropriate instances combinatory rules needed recognition process 
computational linguistics volume number recognition ccg step modifying lig algorithm define constants msl mtl case ccg 
vt vn ccg 
definitions follow im similarities ccg combinatory rules lig productions 
observation express combinatory rule terms lig production iz ap yp correspondences ym 

ap 

direct correspondence combinatory rules lig productions define constants ccg algorithm minimal explanation 
mtl maximum arity lexical category 
mtl max arity vt 
msl maximum arity useful category match secondary category rule 
note category matching lz 
arity sum arity category matching furthermore note argument primary category bound member args 
msl max lz 
secondary category rule max arity args 
note case ccg mcl need defined independently msl 
define ttc ttc max msl mtl 
directional categories play role stack symbols lig revise notions length top rest follows 
say string direc tional arguments categories lcl inch length len 
ncn note arity 
len cl 
ncn define top 
ncn rest 
ncn cl 
additionally top rest 
terminators ccg 
define terminator essentially way case lig 
note category shares target category distinguished descendants 
vijay shanker david weir parsing constrained grammar formalisms definition suppose derivation similarly 
ik lck llc 
lck 
afl cp 

ik lck llc ik lck imc kck aft conditions hold uvw fl string direction categories fl args 

ik lck 
afl distinguished descendents 
ik lck distinguished descendent afl cp 
lck llc expressed form cl 
ik lck le len say aft len cl 
ik lck llc terminator 
ik lck note cp need atomic 
write secondary category 
necessarily expressing minimal parenthesis form 
anatomy ccg entry 
ccg algorithm entries form similar entries lig algorithm 
choices observation 
derivation 
ai input entry ii head ia vn ij cj args 
consider case terminator type entry 
terminator type entry applicable 
ik lck terminator say len ttc 
say case 
lck satisfies tc property 
assuming terminator derives substring terminator pointer dtl middle 
ik lck notice target category lcl 
ik lck target terminator noted head recorded terminator pointer 
entries terminator pointer entire category noted entry 
entry form ia cl 
ij nil assuming 
possible 
case category represented entry written ia nil 
general non terminator type entry recording derivation terminator terminator say rewriting 
ik lck len ttc category satisfy tc property 
ccg algorithm 
straightforward derive rules ccg recognition algorithm lig algorithm 
observation give rules ccg algorithm explanation 
computational linguistics volume number rule assume combinatory rule tpp nil rule ps ac cf ai ap top rest nil 


asc cp ap cp tip nil dp top rest nil de dp ap top tip rest tip nil tpp nil rule ps rule ps tp asc cp top rest nil de de ap 
ik lck tpp asc cp ap ep lie tct dt top cts rest nil dp de de ap tit nil rule ps ae ce ltc de rule ps asc cp top rest nil cp dp de tir tct tit nil dt dr ae ti tp asc ap cp tip nil dp top rest nil dp tie nil vijay shanker david weir parsing constrained grammar formalisms rule ps ap cp flp dt pfi dp tpp nil rule ps tpp dt cp tip tpp pii dp tpp nil rule ps cp lcl top rest nil dp dp ap tip dt 
ia top rest nil dp dp ap cl 
im lcm cp dp len tip ttc 
mcm ap cp tip nil pii dp ias top rest nil dp dp lap tip lcl 
im lcm nil rule ps len tip ep ttc ap cp tip nil dp aso 
mcm top rest nil dp dp ap cl 
lcm cp ii dp proposition ccg recognition algorithm seen establish 
lap ic dt ac ai ai len terminator ac derives string dr len ttc 
ap top rest nil ac ai ai ac terminator terminator say ac len ttc 

tag recognition section considering extend algorithm lig handle unary productions 
needed show instantiate scheme give recognition algorithm tag 
handling unary productions epsilon productions show lig algorithm earlier extended consider unary productions form 

ym ap 
productions computational linguistics volume number form assume productions form 
ap 
henceforth mcl 
note refers unary binary productions 
additional restriction change generative power 
introduced restrictions order reduce number cases consider restrict attention productions tag lig construction 
consider processing binary production 

ap 
yp 
cky style parsers bottom check see primary secondary categories derive adjacent strings say ai ai dp ai dp ai dp respectively store encoding new object results combination 
processing unary productions similar consider secondary constituent 
rules express processing productions similar binary productions 
example consider rule ps binary production 
ap 

rule ps ap yp tip nil dp top rest nil dp dp top tip rest tip nil unary production 
ap 
rule stands unary 
rule ap tip nil dp top rest nil addition productions consider derivations strings length 
shall assume encoding stored 
consider possibility primary constituent secondary constituent derive empty string dp ds 
processing cases similar unary productions 
indicate additional processing required due unary productions possibility derivation empty string consider rule ps rule ps paraphrased follows 
exists production 

el ap flp tt belongs dt top rest nil belongs dp dp add ym ap dp array element 
allow productions possible ds dp 
consider case expect entry 
means resulting entry added dp note addition yl zz encodes derivation fl yl 
fl result entries added array element instance production 

ym 
similar prediction phase earley algorithm state construction lr parsing 
analogy define vijay shanker david weir parsing constrained grammar formalisms notion closure 
closure dt add entries pii dr pii ii result inclusion entry ii dt considering unary productions binary productions primary secondary constituent derives empty string 
define closure note occurrence algorithm rule replaced closure rule 
example closure rule ps stands production 
ap 
el pl flp belongs pii dt ias top rest nil belongs ii dp dp io 
ym ap yp belong ii dp add pii ii dp invoke closure dp 
closure defined follows closure il dl dr closure rule ps ps ps ps ps ps dp entry primary constituent antecedent 
closure rule sp sp sp sp sp sp ds entry secondary constituent antecedent 
closure rule dp entry primary constituent antecedent 

note rule apply assume mcl ter terminator length middle terminator type entry 
included rule rule computing closure 
correspond directly step earley algorithm pop ping stack elements considered part closure 
applied control structure 
consider effect including unary rules control structure algorithm 
il dl lid dd il dl il dl dd 
simplicity loop structure algorithms seen far stems fact parsing rule entry consequent added ii iid dd existence antecedent entry dl dll lid ili lid dd longer holds consider rule rule ps secondary constituent derives empty string 
consider derivation presence productions assumed sufficiently long fl flo fl fl fl ai ai consider addition entry dr dtl record derivation fl 
closure dr invoked resulting addition corresponding fl ii 
rule presence entry add el corresponding fl ii dt 
result need add entries ii ii turn cause new entries added back pii dt 
situation computational linguistics volume number initialization phase loops consider closure rules rule set dt dt repeat consider closure rules rule set ii dr dt dt dr consider closure rules ps rule new entries added dt control structure unary productions 
antecedent entry dr dt causes entry added acting antecedent entry causes new entry added dr 
simple strategy take care situation add loop loop shown partial control structure repeated new entries added dt 
straightforward prove correctness algorithm additional loop asymptotic complexity remains 
case bounded number entries belong dr fixed value dr repeat loop iterated bounded number times determined grammar 
partially specified control structure considered sp rules 
consider changes need algorithm changes algorithm similar fashion 
purposes abbreviation grouped rules ps ps ps ps called rule set rules ps ps ps ps rule set ii 
repeat loop shown needed situations 
consider derivation sequence addition entries el discussed 
viewing derivation bottom recognizer prediction entry followed completion results entry el 
case entries encode objects stack length 
generalize situation call derivations auxiliary derivations named auxiliary trees tag 
fl yl tia fl fl tt wt fl yt fl tt terminator fl 
say auxiliary deriva tion spans terminal len 
notice particular gram mar auxiliary derivation spans terminal extra repeat loop added unnecessary 
assumption pars ing rule entry consequent added dd tence antecedent entry dl il dl dd 
vijay shanker david weir parsing constrained grammar formalisms section noting case lexicalized tag verify auxiliary derivation spans terminal tag algorithm include additional repeat loop 
tree adjoining grammars tree adjoining grammars tag tree generating formalism introduced joshi levy takahashi 
tag defined finite set trees composed means operation tree adjunction 
definition tag denoted vn vt iv vn finite set nonterminals symbols vt finite set terminal symbols vn start symbol finite set initial trees finite set auxiliary trees 
initial tree tree root labeled internal nodes leaf nodes labeled nonterminal terminal symbols respectively 
auxiliary tree tree leaf node foot node labeled nonterminal labels root node 
remaining leaf nodes labeled terminals internal nodes labeled nonterminals 
path root node foot node auxiliary tree called spine auxiliary tree 
elementary tree initial tree auxiliary tree 
refer initial tree fl refer auxiliary tree 
may refer elementary tree tree derived elementary tree 
call node elementary tree elementary node 
give unique name elementary node elementary node address 
elementary node address pair composed name elementary tree node belongs address node tree 
assume standard addressing scheme root node address node addressed children children left right order addresses dv set natural numbers 
section refer addresses refer elementary node addresses 
general write iv elementary tree domain 
domain set addresses nodes definition tree internal node labeled nonterminal fl auxiliary tree root foot node labeled nonterminal tree results adjunction fl node labeled shown formed removing subtree rooted node inserting fl place substituting foot node ft elementary node associated selective adjoining sa constraint determines set auxiliary trees adjoined node 
addition adjunction mandatory node said obligatory adjoining oa constraint 
shows constraints associated nodes trees derived adjunctions 
fl adjoined node labeled determined sa constraint node 
nodes contributed fl computational linguistics volume number operation adjoining 
constraints associated corresponding nodes ft remaining nodes constraints corresponding nodes 
domain label refer label node addressed 
tree question clear context simply 
similarly sa sa oa oa refer sa oa constraints node addressed tree 
ft refer address foot node auxiliary tree 
precise define adjunction node address follows 
operation defined included sa constraints node addressed 
operation defined refer tree results 
ad 
nodes labels adjoining constraints defined follows 
domain domain af domain fl 
ft fl domain domain node address equal dominated node addressed label label sa sa oa oa domain domain fl label 
label fl sa sa fl oa oa fl ft fl domain domain label ft 
label xl acl vijay shanker david weir parsing constrained grammar formalisms ib example tag sa ft fl sa oa ft fl 
oa 
general address node refer elementary node address node contributes presence label constraints 
tree language generated tag set trees derived starting initial tree node resulting tree oa constraint 
string language generated tag set strings appear frontier trees 
example gives tag generates language wcw 
constraints associated root foot fl specify auxiliary trees adjoined nodes 
indicated associating empty set nodes 
example derivation strings aca shown 
tag lig section examine bottom recognition tag 
doing construct lig simulates derivations tag 
construction derive recognizer tag algorithms earlier 
consider bottom tag recognition 
having recognized substring dominated elementary node possible actions move tree combin ing node siblings consider adjunction node 
bottom recognition second action adjunction considered 
phases involved consideration node 
enter ing bottom phase node having just combined derivations children predict adjunction 
entering top phase having just finished adjunction node combine siblings order move tree 
note bottom phase may predict adjunction node oa constraint node move top phase directly 
shows nature adjoining operation tag seen involve stacking 
suppose recognition bottom phase node computational linguistics volume number sample derivations stacking tag 
soo sq reached 
adjunction auxiliary tree fl predicted control shifts bottom phase fl foot node 
move spine fl necessary remember fl adjoined 
reaching top phase fl root return top phase 
adjunction point propagated spine ft general may need propagate stack adjunction points move spine shown obtained adjoining node spine ft seen information adjunction points propagated spine auxiliary tree follows stack discipline 
notice nodes spine participate propagation adjunction points 
consider lig simulates process constructed 
details equivalence lig tag vijay shanker 
vijay shanker david weir parsing constrained grammar formalisms lig nonterminals capture differences top bottom phases associated node 
stack holds appropriate sequence adjunction points form elementary node addresses 
top stack elementary node address node currently visited objects element stack 
nodes spine belong initial tree participate propagation adjunction points 
objects nodes stacks contain elementary node address 
set lig productions determined follows 
assume internal elementary nodes single child labeled terminal symbol exactly children labeled nonterminals 
discussion node elementary node address interchangeably 

node labeled include 
tp qs children node left sibling spine holds object corresponding unboundedly large stack object stack size top stack objects tp ts combination sibling nodes possible top parts nodes reached stack object propagated object top symbol replaced sibling nodes combined reach bottom part 
include production 

tp 

children previous case right sibling spine include production ns qp 

tp qs sibling spine auxiliary tree include production 


child 


node fl adjoined bottom predicting adjunction fl control moves bottom part foot node fl 
illustrated 
case add production 


oa constraint predict adjunction takes place 
captured production 


suppose reached top part root node auxiliary tree ft corresponding object nonterminal top stack node fl adjoined immediately 
having reached top root node fl return top node fl adjoined 
accomplished production 

see 
captures essence connection tag lig par ticular way adjoining operation tag simulated lig 
useful order understand notion terminators 
case ccg construction lig equivalent grammar unnecessary 
case ccg discussion connection tag lig computational linguistics volume number tag lig relationship 
motivate choices form entries tag parser rules algorithm 
recognition tag give cky style recognition algorithm tag 
shall consider lig constructed tag described section 
lig grammar consider objects derived form entries lig algorithm 
elementary node address node spine auxiliary tree say fl object top symbol stack form 
elementary node address node fl adjoined 
furthermore derivation terminator rlt 
lig msl mtl ttc mcl 
follows terminator terminator 
discussion object len terminator elementary node address node spine auxiliary tree 
consider forms entries lig form 
length middle terminator type entry terminator terminator 
note terminator 
terminator type entry parsing array entry say form lt dt dr li 
note tt terminator pointer redundant 
discussion non terminator type entry record derivations elementary node address node belongs initial tree node vijay shanker david weir parsing constrained grammar formalisms spine auxiliary tree 
record object entry nil 
discussion sense terminator type entries tag parser form dt elementary node address node spine auxiliary tree say fl elementary node address node fl adjoined 
non terminator type entry form nil elementary node address node spine auxiliary tree 
consider auxiliary derivation lig obtained tag de scribed section 
recall auxiliary derivation form case yt tia yt wt root auxiliary tree adjoined node elementary node address auxiliary tree lexicalized tag terminal node frontier auxiliary derivation spans terminal lig constructed 
recognition algorithm description cases involved tag recognition algorithm 
predicting adjunction recognition phase reaching bottom part node predict adjunction auxiliary tree fl adjoined determined sa constraints 
case construction section prediction captured lig production 

foot node auxiliary tree ft depending spine auxiliary tree counterparts rule rule rule rule fl ft fl fl sa dt fl ft fl fl sa nil computational linguistics volume number second part case lig construction oa constraint node counterparts rule rule rule rule oa rl false dt dt oa false nil rl nil left sibling spine corresponds case lig construction 
rule captures situation corresponds rule ps rule ps left child spine auxiliary tree right child dt dp nil dp dp dt covers case lig construction siblings spine belong initial tree corresponds rule ps rule sp 
rule ps left child spine auxiliary tree right child nil dp rls nil dp dp rl nil right sibling spine corresponding case lig construction rule sp rule sp right child rls left child wp spine auxiliary tree nil ds dt ds ds rl rlt dt single child case corresponding case lig construction rule rule rule ii child rlp ison spine auxiliary tree rlt dt rlt dt vijay shanker david weir parsing constrained grammar formalisms rule ii child spine auxiliary tree nil nil completing adjunction corresponding case construction depending node adjunction spine auxiliary tree counterparts rule rule rule lp dt rule spine auxiliary tree nil pit dr nil dt spine auxiliary tree gdr dt lr dr nature entries created follow fl auxiliary tree fl fl similarly fl auxiliary tree fl fl jr scanning terminal symbol node labeled terminal matching th input symbol ai corresponding rule rule label ai nil scanning empty string node labeled corresponding rule lx rule label nil concludes discussion parsing rules tag 
correspon dences lig parsing rules numbering rules rules may placed control structure suggested section 
noted earlier case lexicalized tag auxiliary derivation spans terminal require repeat loop discussed section 
computational linguistics volume number 
general scheme parsing set grammar derivation process controlled explicit implicit stacking ma 
shown scheme instantiated give polynomial time algorithms lig ccg tag 
case ccg provides polynomial parsing algorithm apart slight variant scheme vijay shanker weir aware 
main contribution general recognition scheme defi nitions notions terminators data structures sharing stacks crucial scheme 
believe ideas suitably adapted order produce parsing schemes cfg parsing algorithms earley algorithm 
instance definition terminator tailored pure bottom parsing 
case earley algorithm bottom parser top predic tion additional notion terminator top prediction component obtained straightforward manner 
introduced new method representing derivations tag believe appropriate capturing stacking occurs tag derivation 
derivations represented tag call derivation grammar see vijay shanker weir 
discussed extraction parses recognition complete space considerations 
algorithm extract parses build shared forest representation parses ccg proposed vijay shanker weir 
scheme approach taken general scheme 
method extracting parses representing shared forest vijay shanker weir generalized straightforward manner compatible generalized recognition scheme 
acknowledgments partially supported nsf iri iri 
joshi lang schabes shieber steedman discussions 
grateful anonymous reviewers numerous suggestions 
aho 

indexed grammars extension context free grammars 
acm 


linear indexed languages 
theoretical comput 
sci 
gazdar 

applicability indexed grammars natural languages 
natural language parsing linguistic theories edited reyle rohrer 
reidel 
joshi 

context sensitivity necessary characterizing structural descriptions tree adjoining grammars 
natural language processing theoretical computational psychological perspective edited dowty karttunen 
cambridge university press 
joshi levy takahashi 

tree adjunct grammars 
comput 
syst 
sci 
kasami 

efficient recognition syntax algorithm context free languages 
technical report af crl air force cambridge research laboratory bedford ma 
lang 

uniform formal framework parsing 
current issues parsing technology edited tomita 
kluwer academic publishers 
pareschi steedman 

lazy way chart parse categorial grammars 
proceedings th meeting association computational linguistics 
pollard 

generalized phrase structure grammars head grammars natural language 
doctoral dissertation stanford university 
steedman 

combinators grammars 
categorial grammars vijay shanker david weir parsing constrained grammar formalisms natural language structures edited bach wheeler 
foris 
steedman 

dependency coordination grammar dutch english 
language 
tomita 

graph structured stack natural language parsing 
proceedings th meeting association computational linguistics 
vijay shanker 

study tree adjoining grammars 
doctoral dissertation university pennsylvania philadelphia pa vijay shanker joshi 

computational properties tree adjoining grammars 
proceedings rd meeting association computational linguistics 
vijay shanker weir 
press 
equivalence extensions context free grammars 
mathematical systems theory 
vijay shanker weir 

appendix correctness algorithm polynomial parsing combinatory categorial grammars 
proceedings th meeting association computational linguistics pittsburgh pa 
vijay shanker weir 

shared forests tag parsing 
proceedings th meeting european association computational linguistics utrecht netherlands 
weir 

characterizing mildly context sensitive grammar formalisms 
doctoral dissertation university pennsylvania philadelphia pa weir joshi 

combinatory categorial grammars generative power relationship linear context free rewriting systems 
proceedings th meeting association computational linguistics 
younger 

recognition parsing context free languages time 
inf 
control 
prove correctness algorithm 
doing start observing properties rules control structure 
firstly input note entry added rule consequents rules satisfies requirements terminator type non terminator type entries viz yt dr added array ele ment vn fl len fl mcl dt li 
note fl nil added len fl mcl 
verified noting form rules simple induction 
observe control structure entries il dl added entries added pii id dd il dll dl dd 
observation show computational linguistics volume number rule considered purposes adding entry il dl array elements specified antecedent rule filled 
verifying properties algorithm enables establish correctness algorithm easily 
theorem dt flo ai 
lat fl 
ai ai ai fl fl len terminator fla derivation len ttc 
nil oc ai ai tc property terminator derivation terminator say fl len ttc 
proof soundness prove soundness base case corresponds 
consider entries form nil 
entries added application rule 
ai 
ai required 
inductive step 
entry tp added due rule rule means production 

ap 


ym 
assume production 
discuss cases separately 

case production 
ap 

entry tp added rules ps ps take rule ps representative 
yl fit nil added result rule show fit ai ai fit meet tc property 
dp dp ds tit inductive hypothesis applies entries antecedent 
derivations fit dt ai dp 
ai ai 
lat oz dr ai dp ai 
ai dp vijay shanker david weir parsing constrained grammar formalisms meet tc property 
ap ol satisfies tc property furthermore terminator ap 
observation infer existence derivation 
ap flt ai 
lat flt dt ai dp ai ai dp combining derivation derivation flt ai 
flt tt dr ai dp ai dp ai ai observation know terminator fit derivation terminator fit fit terminator fit 
fit satisfy tc property terminator stack length greater equal ttc fit satisfy tc property 
shown existence required derivation 

production may written 
ap 
oes 
time take rule ps representative 
assume entry added form tip nil 
dp dp ds inductive hypothesis applies entries antecedent 
derivations derivation ap gp ai oes ai ai tip ap tip ai ai dp ai dp ai ai 
ai note terminator ap tip terminator tip ap tip terminator 
ap tip meet tc property derivation inductive hypothesis tip 
shown existence required derivation 

consider application rule ps representative 
applying inductive hypothesis derivations ap tip ai ai dp ai dp ai computational linguistics volume number len ttc 
combining derivations tip 
ym ap yp ai 
li dp ai bdp 
ai ai ap tip terminator flp yl 
ym derivation 
fen flp yp ttc shown existence required derivation tip ym satisfies tc property 
similar manner consider rules including assume pro duction form 
yl 
ym ap 

proof completeness show completeness algorithm 
time induction number steps derivation 
suppose fl ai ai show corresponding entry specified theorem 
base case corresponds 
form productions considered assume exists production ai 
rule apply required entry 
fl ai ai 
production derivation form 
rl 
ym ap 
zl 
ym ees ap 
yp 
assume production ap 

argu ments similar production form 

ap 
involved step derivation 
case considering case 
production fl ai 
ai 
ap 
yp write derivation fl ap yp ai ai dp las ai 
ai dp lai 
ai dp lp ls applying inductive hypothesis derivation ai clp ai assume existence entry ias top rest nil dp dp 
order show existence appropriate type entry corresponding derivation ai ai cl fl need consider fl satisfies tc property derivation 
depend primary constituent 
inductive hypothesis applies derivation ap ai ai dp 
start assuming fl satisfies tc property 
means say terminator stack length greater equal ttc 
expressing fl flt 
rewrite derivation fl follows 
flt yl 
ap 
yp ai 
flt yt ai dr ai ai ai lat 
dt lat 
ai vijay shanker david weir parsing constrained grammar formalisms terminator ap kq 
len ttc 
terminator observa tion 

terminator len fit ttc 
satisfies tc property 
show entry dt belongs 
inductive hypothesis may assume ap 
dt belongs dp 
conditions antecedent rule ps met shown existence appropriate entry record derivation ai ai fl 

observation follows terminator exists terminator terminator 
fl flt yl satisfies tc property fit 
suppose satisfies tc property conditions stated antecedent rule ps met appropriate entry added record derivation fl 
hand fit satisfy tc property conditions stated antecedent rule ps met appropriate entry added record derivation fl 
case concerned situation 
ap production derivation ai ai fl 
rewriting fl ap applying inductive hypothesis ai dp lai dp 
ai top rest nil dp dp terminator ap terminator ap terminator 
satisfies wc property derivation ap fl 
ap satisfy tc property inductive hypothesis am tip nil dp 
entries corresponding antecedents rule ps exist algo rithm added entry tip nil desired 
satisfy tc property rule ps add required entry record derivation fl 
case consider case 
derivation may expressed ap ai ai dp ai dp ai ai ai applying inductive hypothesis top rest nil dp dp 
computational linguistics volume number ap flp terminator tip 
consider length order know flp yl 
satisfies tc property represented 
suppose len flp ttc inductive hypothesis en try ap tip nil dp 
antecedents rule ps 
terminator tip 
stack length ttc required entry nil added algorithm application rule ps suppose len flp ttc ap flp may may represented terminator type entry 
take case ap flp satisfy wc property 
inductive hypothesis entry ap tip nil dp 
len flp ttc antecedents entries rule ps exist gorithm add 
ap pl dp desired 
assumed ap flp satisfies tc property applying inductive hy guarantee existence entries corresponding antecedent rule ps algorithm added desired 
ap dp 
