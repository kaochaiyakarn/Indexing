separate compilation standard ml andrew appel princeton university appel princeton edu languages support abstraction modular structure standard ml modula ada may deeply nested depen dency hierarchies source files 
ml prob lem particularly severe ml powerful pa module functor facility ent depend en cies implementation modules just interfaces 
efficiently compile individual modules lan guages useful ml necessary infer digest cache static environment resulting compilation module 
system provides simple model compilation linkage supports incremental recompilation restricted form separate compilation type safe linkage 
model available user programs form set internal compiler modules fea ture call visible compiler chief client interface irm incremental recompilation manager cmu 
interfaces implementa ions modular languages ada modula distin interface modules implementation modules 
weaker sense support distinction organizing source code files 
compilers languages support separate compilation compilation imple mentation module requires examination supp part nsf xl 
permission fee part material granted copies distributed direct commercial advantage acm copyright notice title publication date appear notice copying permission association computing machinery 
copy republish requires fee specific permission 
orlando florida usa acm david macqueen bell laboratories macqueen research 
att com modules imports exports rarely examination implementation mod ule 
dependency graph interfaces shallow reasonable re parse interfaces imported compilation unit imported interface modified compilers unix 
problems dependent dag just interface mod ules quite deep files library known library building user interfaces bring lines header files time consuming process 
files depend particular mod ule want avoid unnecessary tion module changed 
languages may various reasons allow depen implementation modules 
having implementation module dependent implementations leads deeper dependency dag causing timestamp algorithms large amounts unnecessary recompilation 
standard ml example modular language allows inter implement ation dependencies case support powerful functor parameterized module facility see section 
ada modula limited forms parame modules called generics 
explain section ada generics nontrivial inter implement ation dependencies 
modula generics restrictions avoid problem yield powerful convenient module system 
func facility standard ml powerful heavily heavy duty approach separate compilation justified 
source inter implementation cies line expansion functions module boundaries performed response line pragma ada automatically op compiler language 
system describe deal dependencies sort principle 
separate compilation issues ated addressed adams review measure replacements timestamp recompilation interface hashed stamp trivial modifications source code don necessarily change hash un necessary recompilation avoided 
modula compilers create digested ver sions interface files speed importing process 
ml export interface derived semantic anal ysis interface implementation modules making especially necessary digested inter face descriptions just re elaborate source code imported files 
implementation modules just big re elaborate client im ports 
give compiler eye view separate compilation mechanism set primitives system describe im ation primitives 
section give overview major client primitives recompilation manager source dependence analyzer library manager called irm 
ion gives full description utility 
new separate compilation mechanism stan dard ml implemented standard ml new jersey compiler allows incremental recompilation language wit inter implement ion dependencies provides uniform compilation linkage envi ronment interactive compile execute commands compatible separately com modules uses static environments analogous symbol ta dynamic environments playing role similar linkage tables class values composed elegant side effect free manner infers exact export interface implemen tation module hashes intrinsic stamp precise recompilation see section enforces type safe dynamic linkage ing link time type checking provides architecture type safe usage components interactive system clients see section generalized support cross module opti mization language leads inter implement ation dependencies 
infer full interface descriptions language separately compiled higher order modules trivial thing believe 
existing ada modula systems gener ics fully compiled separately ar 
cutoff recompilation achieved better termed incremental recompilation system 
pos sible system compile module seeing modules imports 
module recompiled changing export inter face avoid recompilation dependent modules 
set interfaces lln corre sponding implementations ml 
mn classical sepa rat compilation allows compilation mod ule examination subset hj interfaces examining text implementations 
classical separate compilation possible ml language inter implement ation dependence 
having compiled set implementations mj recompilation allows module mi dependent implement ations mj compiled session compiling mj 
modules mj altered way affect exported interface recompiled recompilation adams terminology allows previously compiled dependent mj recompilation 
recompilation allows mi compiled examination mj hj linker smarter verify hypotheses hj mj compilation mi :10.1.1.34.3197
tion demonstrated feasible higher order funct ors 
describe recompilation system classical system 
standard ml modules module system ml modula ada distinguishes interfaces called signa tures ml implementations called structures ml user decouple implementations functors 
helpful user true separate compilation desire example client module compiled independently modules imports 

ml interface struc ture partially described explicit signature 
signature partial 
order ig type elem val elem elem bool signature sort ig type val sort list list functor partial omer sort struct type elem fun sort 

structure factors partial order struct type elem int fun mod structure sort factors transparent signatures signature ml specifies type elements structure visible client structures un interface render ele merits opaque 
ml transparent signature matching designed support parameterized structures func tors parameter signature partial interface description actual param eter structures containing different types propagated functor 
forexample structure known 
thisis specified signature sort apply partial orders types consequently compile client inspect implementation module structure sort factors merely partial interface sort 
fact optional specified 
nec exp constraint sort top rt include elem breaks higher order 
seealso section 
generally compile implementation mod ule necessary inspect implementations modules imports directly indirectly types fully described signatures 
contrasts situation modula modula necessary inspect transitive closure inter face specifications imported modules 
generic interfaces modules modula change situation inst top level 
im plementation module instance generic module example inter implementation dependency implementation module depend implementation nontrivial chain dependencies 
restriction limit utility convenience modula generics 
ada instance generic package occur submodule package body causes de package body generic package instantiates 
package exports inline procedures depend package implementation 
ada subject inter implementation dependencies arise different mechanisms applying stan dard ml 
solution ada modula view generic instantiation kind source language ex 
really separate compilation generic modules instances truly compiled 
ml functor type checked compiled machine code independently applications 
significant advantage ml module system come cost inter implementation dependence 
section discuss alternative module systems programming styles ml avoid dependence 
alternatives significantly weaken original standard ml module system separate compilation system deals di rectly inter implementation dependence 
ml compilation model original idea ml compilation unit single closed signature structure functor defini tion having free external structures 
various reasons approach proved inadequate patched describe section years agreed tion separate compilation 
ml compilers interactive systems successive declarations evaluated relative top level environment augmenting environ ment new bindings ml module system signatures structures functors way 
separate compilation critical requirement design module system mainly addressed issues parameterization program composition name spaces 
ml programs broken compilation units taken liberal ap proach compilation unit single source file containing sequence ml declarations signa tures structures functors values types special syntax delineates compilation units module language described defi nition standard ml 
existing ml programs automatically upward compatible new separate tion system 
evaluation interface ml source code evaluated environment map ping names types values produces new bindings names types values new envi ronment env name type evaluate source env env distinguish compilation execution factor evaluate compile execute time factor env static dynamic parts 
persistent identifiers pids form inter mediate name 
compile env name type pid pid value source code unit code unit evaluate appropriate composition com pile execute 
note having decoupled phases perform chain compiles time corresponding chain executes done 
values exported ml modules dynamic run time values function closures run time construct ed dat ot merely static linkage addresses 
necessary execute ml module pro duce export fields 
conventional model linking ada modula imports exports exist static addresses prior execution module conventional model requires recommend irm compilation manager requires separately compiled units contain structures top level values types 
variables initialized constant values may subsequently re initialized start code module 
ml kinds values function closures created application higher order functions reasonable stat ic default init ion 
furthermore variables ml really vary re initialized 
maps internal names pids runtime addresses 
serves purpose link editor table conventional model 
produced modules execute exported fields module produced exist prior execution module machine code 
note precludes cyclic dependencies modules ml 
compile function returns pair code unit call compiled 
code unit breaks components code machine code unit imports list pids des imported values exports list pids designating exported values 
compiled unit code unit code unit code imports exports processing external described section compiled unit written incremental recompilation manager binary file 
linkage execution code tion unit implements fully closed function mapping vector import values vector export val ues 
external require link editing external obtained imports passed arguments ma chine code executed 
individual functions export ed code generally con structed execution phase run time created closures hold imported external refer ences 
case standard ml new jersey current pids cat ed previous lvar numbers persist ent lvar numbers re tain meaning ml process useless separate compilation 
interactive read eval print loop maintains global environment env comprised 
compiling compilation unit yielding compiled unit interactive loop looks imports pids producing vector values 
applies code vector pro duc ing vector export values 
export values bound corresponding elements exports pid list form new matching exported 
coordinated pair static dynamic environments constitutes exported environment compilation unit 
increment exported envi ronment layered global environment 
separate compilation system eager execute unit right compiling 
stead save compiled unit bin fine retaining just input compilations 
interactive loop uses compiled unit interface aa separate compilation sys tem separately compiled modules loaded interactive system 
simple example illustrates com linkage process value declarations module declarations source val val compilation environment sc dc static dynamic compilation results execution sc int int int dc int int pid code imports pid pi exports ida pid pid va code dc pid dc dc making binary files compilation unit compiler produces compiled unit tuple code pids import export increment static environment 
sepa rate compilation recompilation parts written binary file com 
easy write machine code binary file machine defined representation machine instructions sequences bits 
pids bit integers easy write files 
static environments complex pointer data structures easy representation aa bit strings 
representation static environments structures functors signatures functor signatures types datatypes values symbol tables uses different dat sev eral variants total variants types total record fields 
triv ial matter write linked structure types file 
program integrated garbage collector system writes version arbitrary data structure file read back page 
internal representation static environments suitable pickling modifications static environments self contained portable 
means pointers global data structures contain function closures complicate cross compilation different archi tecture 
export environments affected types structures de scribe problem solution section 
static environment compilation unit may contain pointers static environment units depends 
managing sharing exported static environment unit points right middle static environments units 
happily traverse point ers binary file contain private copy shared entity 
static environment read binary file include new copy previously shared entity 
worst case dag environment components converted tree leading exponential blowup binary files core memory 
solve problem exported environment writing file iden tify external pointers replace stubs 
reading binary file environment turning stubs back pointers 
static linkage process 
problems solve designing de hydration algorithm 
tell things ex pointers structures shared bin files pointers core look 

stub find real core pointer replace 
significant object static environment module structure functor signature type con stamp composed persistent identifier pid small integer 
objects created compilation unit pid dif ferent integers 
traverses static en vironment exported current compilation unit stamped object pid belongs compilation unit object external replaced stub containing stamp 
solution problem 
environment read bin file replace stub real pointer 
source file compiled context en vironment combination export environments imported modules 
ex object live context environment 
environments indexed stamp mappings source language symbols objects cent stamps 
exhaustive search context environment find object containing stamp principle context environment sufficient efficient constructing environment index mapping stamps objects 
environment comprises map pings symbols objects stamps ob jects 
static environment type compiler operations construction layering lookup indexed static environment matches specification supports lookups stamp 
possible coerce kind environ ment constructing index throwing away 
elaboration single compilation unit non indexed environments efficiency lookups stamp needed irm uses indexed environments ap plies coercions appropriate points 
con text environment cent external stamps current compilation unit 
fortunately context simply indexed version static environment originally tion unit 
compilation irm constructs cent ext environments layering exported stat imported units just reproduces equivalent layering 
indexed environments layered symbol mappings stamp mappings combined separately effi cient layering symbol mappings re indexing 
processes ex similar traverse static environment replacing certain leaf nodes external pointers come stubs vice versa 
single program parameter accomplishes tasks 
done tive functional style environment copied 
copy ing quite efficient sml nj fast allo cation fast garbage collection problem dag structures turn tree structures big blowup memory care ful 
trivial ml notion pointer identity matter language copying garbage collection pointers hash table indices 
stamps internal objects objects significant st amps serve indices tempo tables ensure sharing pointer structure preserved 
ha sh consing better don 
troublesome time consuming part implementation detailed identify ing external sharing stubs preserving inter nal sharing da structure 
part cases handle set mutually re cursive functions traverse preserve sharing variants data types 
summary compile source file context environment built compiler produces compiled unit described earlier 
static environment part compiled unit saved compilations copy written binary file code unit compilations tomorrow 
day equivalent context environment built binary file read back context environment 
environment combined exported environments modules form contexts loading binary files ing source files 
type safe linkage modules compiled recompiled linked 
classical linker re solves names refer machine code addresses global data addresses link time static allocation 
classical linker maintain type informa tion part programming environment typically programmer ensure modules linked compatible 
example programmer may neglect include file dependent makefile 
file altered change parameters procedure client module calling old arguments recompiled 
error detected linker 
type safe linker hand ensures compiled implementations linking consistent view interfaces 
natu rally implemented type safe linker 
implemented automatic dependency analyzer output control order evaluation preventing makefile bugs 
dependency fail linker detect inconsistency 
recall section linkage dynamic values names pids label iim ported exported values 
exported pid con structed ways 
pid simple timestamp aug 
mented host process identifiers ensure uniqueness 
lead unnecessary recom module edited recompiled changing interface new pid generated dependent mod ules recompiled 
pid hashing source code ex comments module pids imported interfaces 
approach taken cedar mesa system 
trivial changes source code editing comments example cause pid change dependent modules need recom 
pid hash exported static 
modification im plementation module affect ex port interface yield pid 
bugs fixed algorithms changed causing cascade recompilation 
kinds pid called intrinsic independent time place context 
alternative obviously preferable 
intrinsic pids system ac amps 
system intrinsic pids naturally recompilation avoiding unnecessary tion 
cutoff recompilation implemented comparing new compiler output describing export interface previous intrinsic pids unnecessary save compare previously compiled version compare hash values full environments 
possibility collision ferent hash value 
cause hash function crc bits happen pairs 
large software system pids pairs probability collision 
irm intrinsic hash pids software development switch timestamp pids pre production verification 
intrinsic pids precisely intrinsic pids express exported interface dependent aspects implementation modules fewer unnecessary recompilation done 
intrinsic pids computed hashing ex ported static environment 
prefix order sal stat env 
node datatype variants emit integer de pending variant 
take appropriate care avoid doing tree traversal dag 
come pid internal imported re exported emit pid integer 
produces sequence integers hash crc algorithm produce export static pid compilation unit 
export pids dynamic objects produced unit derived static pid adding respectively export static pid 
note static environment contains entities exported entities cent ain pids pids derived result hash entities traversed order compute hash 
paradox resolved having elaboration semantic analysis phase compiler give ties provisional pids 
replaced real pids crc computed 
course compilation substructures types created provisional pids exported 
hash provisional pids directly hash value dependent number hidden internal structures types implementation module 
alpha convert keeps record provisional pids seen uses value nth distinct pid seen far 
hashing provisional pids done phase described sec tion 
performance look passes export environments 
hash environment compute intrinsic pids replace external stubs replace stubs external ref erences 
measured time taken phases minute compilation lines mea time hashing seconds modulo clock tick resolution second tion seconds overhead 
believe seconds substantially reduced replacing linear searches identify previously seen nodes preserve dag structure 
static pids imports pid list unit expresses dynamic dependence unit imported values re quired execution 
nice list com pletely completely summarized dependence unit environment 
dependence dynamic component type signatures static effect 
implement proper cutoff re compilation irm needs information 
characterize unit exported static information sufficient hash exported single st pid 
binary file unit irm system writes st pids imported units exported static pid 
static exports compilation unit change new static pid dif ferent 
examining dependent binary file currency irm able detect imports st pid longer exported 
irm responsibility manage static pids 
irm compiler calculates list imported units assembles corresponding list static pids 
compiler keep track imported units greatly complicate lookup functions types values compiler 
contrast compiler produce dynamic imports list 
turns easy lambda expression intermediate representation pro duced front compiler explicitly con pids free variables 
dynamic pids suffice type safe linkage 
inconsistency static imports exports ef fect dynamic imports exports cause execu tion go wrong 
decstation recompile unit tit changes type real 
unit recompile execution go wrong 

type int 
local type val compilation interface previous systems sml nj accessed compiler procedure takes file name compiles file side effects global envi ronment extending static dynamic bindings 
primitives described intended separate compilation manager understands source files binary files dates ries file dependency dags version makefiles li 
irm summarized section system 
sml nj compiler available interface component phase compilation parsing elaboration semantic analysis hashing code generation code execution 
provided static environment manipulation primitives layering index mapping 
compiler know format bi nary file 
irm takes compiled unit writes reads code imports exports import static pids export static pid binary files format 
interactive top level development irm mechanisms described interface sml nj compiler interactive read eval print loop provision compiling units files command 
course provided separate compilation whatsoever 
re engineered read eval print loop command call compilation prim described 
interface compiler proper 
consequently units compiled irm compatible units com top level loop 
course irm analyze static dependence source code typed interactively 
easy implemented interactive loop load binary files dragging full irm tion management system 
visible compiler lisp community long enjoyed access internal functions interactive system eval big ball mud paradigm 
show cleanly strongly typed modular system model compilation linkage en described 
selectively expose internal modules compiler simply adding static interfaces user level environment 
standard ml new jersey compiles ml code machine code segments 
ml process ex segments putting memory heap jumping 
linkage achieved explained looking imported values dynamic environment passing values ar machine code function 
interactive system user program exe process compiler 
usual way building interactive compilation environment true stand ml applications 
compiler course compiled sepa rate compilation system described 
compiled compiler consists set binary files machine code static environment pids link compiler runtime system primitive bootstrap loader implemented stands machine code import export binary files 
bootstrap loader reads static environment component files 
compilation unit succession loader looks val ues simple dynamic environment applies ma chine code functions 
compiler running wants shared library modules list string internal modules accessible user program type safe way 
accomplish ml function initializes environment interactive top level loop re reads binary files time loading static environments ignoring machine code 
incremental static environ ments composed build static environment matching dynamic environment con structed bootstrap loader passed argument ml startup function 
result ing combined environment contains internal modules compiler normally filtered provide limited selection modules compiler user programs 
shared modules libraries providing built types operating system interfaces provide access compiler control flags internal compiler types operations syntax trees environments compilation phases 
tions window compiler applica supports shared fundamental libraries ist string separate compilation manager runs user program calls certain phases compiler 
example uses parser implement file dependent analysis 
easy implement compiler hacker testbed add replacement modules running interactive compiler module compiler visible usable 
provides convenient basis various forms metaprogramming including synthesis evaluation ml code user programs 
irm gene rollins carnegie mellon university imple mented incremental recompilation manager irm client low level tools described 
irm runs aa ordinary application pro gram sml nj interactive system calling compiler visible compiler interface 
briefly summarize capabilities irm system 
user irm specifies groups source files 
group may refer groups uses libraries 
source files may ml files programs languages lex yacc processed compilers sml nj 
irm automatically analyzes dependencies tween compilation units 
ml source files calls parser sml nj compiler scan files free variables imported names 
file foo sml irm keeps cached version dependency information foo 
sml uses timestamps de termine dependent information date 
intrinsic timestamps ensure files recompiled 
irm performs cutoff recompilation cascading recompilation 
irm provides interfaces levels 
simplest highest level interface simple file listing source files file name names imported libraries mentioning name li file 
dependencies automat ically computed irm makefile contains unordered list file names 
system simple convenient 
lower level interface ml structures sig natures components irm system 
users special needs example theorem prover sources kept files different style li manager customize irm system implemented modular style specifically support users 
cross compilation visible compiler requires compiled code compiler representation environments compiler produced 
irm system calls functions compile top level interactive commands telling irm perform example generating binary files 
restrictions mean cross compilation production new version compiler old version running compiler architecture generate code architecture 
impossible 
compiler unable forms cross compilation evolutionary dead 
sup port cross compilation ways 
gen erating code different target architecture architecture different parameter passing conventions garbage collector interface visible compiler paradox 
old compiler loads binary files new compiler user program fundamental libraries buffered shared 
old compiler phases accessible irm standard structure compiler signature compiler 
new compiler loaded structure new compiler matching signature 
irm sys tem takes compiler aa functor parameter applied 
commands irm compiled old compiler irm self calls new compiler generate binary files 
course old interactive system execute files 
constraints old new compilers cross compilation difficult stand simple axiomatization things manageable 
alternatives dependencies bet implementations arise implementation module mentioning directly 
interfaces fully expressive modula matter standard ml information identity types leak signatures words signa tures enforce abstraction 
necessary explained introductory sections support definition higher order modules single notion signature mat thing 
difficulties address stem dependencies im ation modules 
describe alterna tive solutions avoid dependencies 
fully style solution adopt programming style called fully style nal opaque making external modules funct parameters 
done existing standard ml language order ab functors structures necessary higher order functors described tofte macqueen 
problem approach cumbersome programmer funct parame ters complex express deeply nested dependency dags handled au anyway 
dags explicitly redundantly expressed implementation module 
eliminate transparent signature mat thing approach signature matching opaque information identity types leaks interface export ed types 
practical way override abstraction want export concrete ype overriding explicit signature dependencies inter faces 
versions standard ml module system opaque signature matching proposed 
appears true higher order module systems dependencies ex pressed order expressed higher orders 
ml community currently debating issue 
see proposed framework 
similar effect achieved standard ml adding type abbreviations signatures ab opaque interfaces struc tures partially transparent interfaces 
powerful proposals mentioned previous paragraph 
separate compilation irm mechanism described system implemented rollins regularly students un compiler course princeton 
com irm visible compiler system robust rely compile sml nj compiler large system comprising compilation units 
interfaces express compilation linkage architecture remarkably simple easy 
due functional style environment ma fact executable code linkage expressed function application 
ml module language long recognized powerful shows practical organizing software systems 
fact ml support incremental recompilation true separate compilation unfortunate want solve problem limiting power pa modules done modula research summarized section eventually provide better solution 
rolf adams walter tichy annette weiner 
cost selective recompilation environment pro cessing 
acm 
appear 
andrew appel 
axiomatic bootstrapping guide compiler hacker 
technical report cs tr princeton university march 
andrew appel david macqueen 
han dard ml compiler 
gilles kahn editor functional programming languages computer architecture lncs pages new york 
springer verlag 
barnes 
programming ada plus language manual 
addison wesley new york 
amber benson gary aitken 
programmer guide june 
luca cardelli 
program fragments linking april 

feldman 
program maintaining com puter programs unit programmer manual sev edition volume 
bell laboratories 
gutknecht 
separate compilation approach efficient symbol files 
ieee software pages november 
samuel harbison 
modula 
prentice hall engle wood cliffs nj 
robert harper peter lee frank pfenning eu gene rollins 
incremental recompilation standard ml new jersey 
technical report cmu cs department computer science carnegie mellon university february 
robert harper mark lillibridge 
type theoretic approach higher order modules sharing 
annual acm symp 
principles prog 
languages pages new york jan 
acm press 
bill kalsow eric muller 
src modula version manual february 
andrew koenig 
personal communication 
butler lampson eric schmidt 
ing soft ware distributed environment 
acm sigplan symposium programming language issues software systems pages june 
peter lee gene rollins robert harper 
recompilation standard ml 
technical report preparation carnegie mellon 
xavier leroy :10.1.1.34.3197
manifest types modules separate compilation 
annual acm symp 
principles prog 
languages pages new york jan 
acm press 
david macqueen 
implementation standard ml modules 
acm conf 
lisp functional programming pages new york 
acm press 
david macqueen mads tofte 
semantics higher order functors 
proc 
european symposium programming esop page appear april 
robin milner mads tofte robert harper 
definition standard ml 
mit press cambridge ma 
greg nelson editor 
systems programming modula 
prentice hall englewood cliffs nj 
mark rain 
avoiding trickle recompilation mary implementation 
practice experience 
ed satterthwaite 
mail october 
personal com munication describing done cedar system xerox parc butler lampson eric schmidt satterthwaite published 
zhong shao andrew appel 
recom 
proc 
twentieth annual cm sigplan ct symp 
principles programming lan guages pages 
acm press 
mads tofte 
principal signatures higher order pro gram modules 
nineteenth annual cm symp 
principles prog 
pages new york jan 
acm press 
john von neumann 
draft report 
william arthur burks edi tors papers john won neumann computing computer theory pages 
mit press cam bridge massachusetts 
