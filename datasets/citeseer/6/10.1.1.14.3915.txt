applying traits smalltalk collection classes andrew black ogi school science engineering oregon health science university usa black cse ogi edu traits programming language technology modeled mixins avoiding problems 
reports refactoring smalltalk collections classes traits 
observed original collection classes contained duplication code traits remove 
places protocols collections lacked uniformity traits allow correct non uniformities code duplication 
addition traits possible general reuse collection code outside existing hierarchy example easy convert collection things true collections 
refactoring reduced number methods collection classes approximately cent 
importantly understandability reusability code significantly improved 
keywords reuse mixins traits smalltalk collection hierarchy refactoring inheritance multiple inheritance 
long believed classes responsibilities object oriented programming 
languages classes conceptual classification 
provide reuse different ways factories instantiate similar objects superclasses incorporated new subclasses 
kinds reuse conflicting requirements 
factories classes complete creating new subclasses convenient able incorporate small fragments behavior 
developed new programming construct call trait address problem 
traits intended fine grained units code reuse 
essence traits class collections methods reused classes inheritance hierarchy 
research partially supported national science foundation united states award ccr swiss national foundation 
sch rli software composition group university bern switzerland iam unibe ch contributions st phane ducasse software composition group university bern switzerland ducasse iam unibe ch study internal structure existing smalltalk collections classes particular attention code duplication unnecessary inheritance super method redefinition inheritance chains report experience traits help remove problems description organization new classes resulted refactoring 

problem 
single inheritance popular programming technology adopted widely simula 
inheritance powerful basis major success stories including smalltalk java 
success power blind fact single inheritance just task supporting wide range abstractions expect find modern object oriented framework 
illustrate point small example 
class squeak smalltalk represents rectangular block color manipulated display 
subclass inherits reuses methods turn subclass morph 
squeak defines class rectangle inherits object 
rectangle implement protocol understood rectangle objects 
rectangle adds messages protocol object 
messages understood missing protocol 
say missing client clearly rectangle state includes field bounds defines rectangle occupies 
programmer wishes fix problem faced number unpleasant alternatives 
option copy missing methods rectangle paste 
clear violation dry don repeat principle 
option provide conversion method expect client re notation name refers method name class member conversion method need send message understand 
example saying area client say area 
moves burden morph client feel borne morph 
third option delegate missing methods 
simplest way doing implement line method converts receiver rectangle resends message 
area method implemented follows 
area self area best choice hard achieve tool support burdens code lot noise making harder understand inefficient increases size object code 
multiple inheritance proposed solution problem multiple inheritance allow rectangle superclasses inherit methods 
multiple inheritance complex may introduce problems solves 
example multiple inheritance inherit sets state variables represent information position rectangle sets methods access change variables 
literature developed resolve problems taivalsaari provides starting point 
traits provide solution problem giving behavior rectangle retaining simplicity single inheritance 
trait solution avoids duplication source object code eliminates indirection improves modularity making classes easier understand 

traits 
trait class collection named methods 
methods trait pure behavior directly instance variables 
purpose trait composed traits eventually classes 
trait superclass keyword super trait treated parameter bound trait eventually class 
major difference traits mixins traits richer set composition operators 
illustrates sum overriding inheritance operations 
sum trait contains non conflicting methods conflict define method name name bound distinguished conflict method 
sum associative commutative 
overriding operation creates new trait extending existing trait explicit local definitions local definitions override methods name trait local definitions explicit clear overridden 
traits incorporated classes means extended form inheritance 
conventional inheritance new subclass extends constructed local definitions instance variables methods superclass extended form inheritance new subclass extends uses addition trait call extends structured class 
methods defined locally replace methods obtained trait conventional inheritance methods override inherited superclass overriding methods access superclass method super 
practice trait build structured class composed primitive traits 
aliasing operator creates new trait providing additional name existing method 
example 
body aliased method changed way example alias recursive method recursive 
aliases conflicting methods available name match requirements trait 
trait constructed excluding methods existing trait exclusion operator 

exclusion useful avoid conflicts needs reuse trait big application 
associated trait set methods called requires set 
concrete class uses trait provide required methods 
example methods trait expression self size trait define method size size requires set trait 
trait eventually incorporated class intended concrete size defined method fetches value instance variable method calculates size 
way define operations traits semantics method independent defined trait class trait uses component 
consequently possible flatten structure compound trait structured class level changing methods 
believe flattening property crucial making traits easy critical differences traits mixins 
reader interested deeper understanding traits composition operators traits avoid difficulties multiple inheritance mixins referred companion papers 

applying traits rectangle morph reader superficial understanding traits return example show traits understand rectangle methods missing protocol 
illustrating way traits example shows class transformed trait illustrates difficulties may encountered trait gives glimpse tool support built 
step construct trait contains missing methods 
easy appropriate code exists class rectangle 
traits browser extension standard smalltalk browser understands traits new trait class menu item create new trait class rectangle 
call new trait initial local definitions trait overriding trait trait trait conflict local definitions var var inheritance class subclass extends var var major operations traits overriding sum inheritance 
note local definitions classes extends contain instance variables methods refer traits 
traits classes show boxes indicate reusable contrast local definitions shown enclosing box 
name trait convention follow 
contains methods rectangle variable refactoring applied method accesses instance class variable directly 
example rectangle instance variables origin corner represent top left bottom right coordinates 
method converted rectangle width answer width receiver corner origin width answer width receiver self corner self origin refactoring completed new trait rectangle methods methods depended instance variables rectangle depend existence methods origin corner 
traits browser lets examine methods trait shows requires set comprises messages origin corner species 
browser construct new subclass 
process similar creating new subclass ordinary smalltalk browser uses refactoring different names different authors 
opdyke calls access member variable fowler calls encapsulate field 
follow lead refactoring browser name variable 
extended form inheritance lets specify trait trait valued expression component 
declarative syntax section define 
extends ellipsis denotes methods instance variables local new subclass 
result definition new class immediately methods needs rectangle 
incomplete browser shows requires definitions origin corner 
define methods directly new class 
origin self bounds origin corner self bounds corner requirement species satisfied species method provided superclass 
browser shows list overridden methods places new class defines method inherited 
example center trait defined 
overridden method examined see appropriate keep version keep version superclass write new method 
buttons browser examine alternatives choice quickly 
browser supports different imperative syntax analogous define conventional subclasses 
programmer examines list overrides created uses trait component 
method inappropriate excluded 
case center overrides methods appropriate self origin self corner access rectangle coordinates 
methods hash inappropriate 
browser menu exclude methods 
choose setting exclusion see effect modify definition certain methods equivalent declaration 

hash 
extends process traits browser helps focus just methods require attention 
examined overrides satisfied requirements task complete created new class functionality rectangle 
methods needed write glue methods origin corner express state rectangle extracted 
small examples fun compelling test language extension intended improve structure large class libraries 
evaluate traits realistic setting applied framework significant size 
chose smalltalk collections classes target evaluation 

smalltalk collection classes collection classes loosely defined group general purpose subclasses collection stream 
group classes appears blue book contains sub classes collection sub classes stream total classes redesigned times smalltalk system released 
group classes considered paradigmatic example object oriented design 
squeak class collection subclasses class stream subclasses bitmap special purpose classes crafted parts system applications categorized collections system organization 
purposes study term collection hierarchy mean collection subclasses system category collections 
term stream hierarchy mean stream subclasses system category collections 
full list shown 
classes respond messages define total methods 
varieties collection understand challenge refactoring collection hierarchy reader needs superficial knowledge wide variety collections classes commonalities differences 
familiar smalltalk collection classes may safely skip section 
programming aggregates individual elements important way level abstraction program 
suppose collection bag array array string symbol text heap interval linkedlist set dictionary skiplist stream collection classes squeak 
indentation indicates subclassing italicized classes bold classes refactored 
data structure containing collection student records wish perform action students meet criterion 
programmers raised imperative language immediately reach loop 
smalltalk programmer write students select gpa threshold evaluates new collection containing precisely elements students bracketed function returns true important note message select understood collections smalltalk 
need find student data structure array linked list select message understood 
note quite different expression brackets thought expression defining anonymous function gpa threshold 
loop know students array linked list loop set 
smalltalk speaks collection specific kind collection means object supports defined protocols testing membership enumerating elements 
collections understand testing messages includes isempty 
collections understand enumeration messages select reject opposite select collect lisp map detect inject performs left fold 
ubiquity protocol variety powerful 
basic uniformity different kinds collection 
shows categorization collection classes enumeration collection starts element proceeds defined order element 
array familiar indexable data structure fixed size retrieves th element put changes th element indexable understand 
class general array size grows demand methods put 
interval immutable collection defined computational rule created 
example interval contains elements 
indexable changed put 
differences various kinds collection manifest different dimensions 

order established 
sorted collections supplied total ordering function intervals implicitly ordered arrays ordered collections ordered explicitly elements inserted 

size fixed intervals arrays variable sorted collections ordered collections linked lists 

collection immutable page interval symbol mutable 

collection constrained hold particular kind object completely general 
example constrained hold elements conform link protocol strings symbols contain characters 
non collections sets bags dictionaries categorized different set dimensions 

duplicates allowed dictionary bag disallowed set 

elements accessed key dictionaries sets bags 

keys dictionary values set bag compared test ascertain elements added set equal 
accessible index indexable accessible key keyed interval array string interval symbol array string symbol implementation linkedlist dictionary set skiplist bag accessible index indexable accessible key keyed collections categorized clearly defined elements 
ordered collections hashed linked lists indexed integer key 
collections dictionaries implementation accessed arbitrary key string sets bags 
array string symbol implementation array string symbol linkedlist skiplist text implementation text heap set bag hashed implementation dictionary set bag dictionary dictionary set bag linked interval implementation implementation linkedlist skiplist linked implementation linkedlist skiplist interval interval implementation interval collection classes categorized implementation technique 
categorizations functionality concern re implementors collection hierarchy understand collection classes implemented 
shown main implementation techniques employed 

arrays store elements indexable instance variables collection object consequence arrays fixed size created single memory allocation 

store elements array referenced instance variables collection 
consequently internal array replaced larger collection grows storage capacity 

various kinds set dictionary subsidiary array storage array hash table 
bags subsidiary dictionary elements bag keys number occurrences values 

standard singly linked representation 

intervals represented integers record bounds step size 
readers interested learning smalltalk collections referred lalonde pugh excellent book 
streams collection protocol supports storage removal enumeration elements collection allow operations intermingled 
example elements processed method possible add remove elements inside block 
collection protocol allow perform merge sort sequencing repeatedly removing smallest element 
procedures require traversal index position maintained outside collection exactly role stream 
stream objects defined stream collection 
example 

prints 
prints 
prints false analogous string new 
contents 
prints ab possible create support reading writing protocols defining class challenge single inheritance 
squeak chooses subclass shown 
analysis collection classes section presents results analysis collection hierarchy existed refactoring 
see collection hierarchy contains unnecessary inheritance duplicated code shortcomings 
dimensions smalltalk collection classes categorized inevitable attempt organize single inheritance hierarchy run severe redefinition put add superclasses difficulties 
cook showed hierarchy attempts maximize reuse expense conceptual categorization consequence example dictionary subclass set shares implementation different interface 
way designers hierarchy attempted maximize reuse move methods high possible classes chance inherit 
example collect implemented collection implementation appropriate collections understand add 
consequently implementation overridden class favor implementation put 
second implementation inherited appropriate override 
told implementations collect collections hierarchy 
subsections examine effects systematically 
unnecessary inheritance inheritance quite heavily collection classes sharing implementation classification 
measure complexity inheritance relationships counted number inheritance chains message methods defined 
illustrates examples methods put add inheritance chains terminating class 
inheritance chains 
intrinsically wrong re defining method inherited superclass 
contrary ability super call inherited definition new method gives inheritance power people consider adding behavior super send inheritance oriented programming 
part redefinition super going 
total methods involved method redefinition chains mentioned 
methods top chain methods opportunity sending super 
redefinitions examples hook methods parameterize behavior template method redefined methods part functional interface 
deduce part redefinitions correcting augmenting behavior inherited method appropriate new subclass 
words identified places method inherited unnecessarily 
problem unnecessary inheritance 
cost execution time code space lost development time 
task understanding class inherits methods complicated necessary 
inheritance considered aid understanding complex class programmer inheritance chain comprehending differences subclass superclass having comprehend entirety final subclass single step 
extent methods inherited unnecessarily process difficult inheritance begins hinder assist understanding legacy code 
code duplication new subclass want re method existing class may unable nature single inheritance 
example share methods place classes inherit 
subclass dictionary subclass set appropriate common superclass methods shared pluggable classes placed 
inappropriate superclass set 
programmer left choice placing method high hierarchy set duplicating 
stream classes provide classic example methods implemented high 
conceptually accessor sequence objects named external indices characters string file 
protocol includes messages set reset position index 
lowest common superclass 
subclass see methods support reading example reader reader 
implemented terms self 
method explicitly disabled re enabled duplicated 
reading methods explicitly disabled inherited 
avoid code duplication methods specific reading implemented superclass 
tactic succeeds case price high polluted methods noting positioning appears implement reading methods fail 
easy way ascertain duplication caused fact methods inherited superclass 
superficial check looking methods decompile strings identical 
detected duplicates methods differed formatting comments names temporary variables 
excluded error methods self cancel inherited method 
way pairs duplicated methods triples 
cases duplication method part hierarchy consequently inherited method defined superclass superclass 
example dictionary collection implement identically dictionary subclass collection intervening definition set prevents dictionary reusing method collection 
duplication counts just tip iceberg 
primitive duplicate detection technique certainly misses methods differ structure semantics 
example methods compare equality expresses uses duplication revealed search 
refactoring collections classes noticed deeper examples code duplication method clearly copied established class newly created class single crucial statement changed obtain different semantics 
conceptual shortcomings addition implementation problems collection classes suffer conceptual shortcomings 
reasons collection classes designers attempted compensate fact classes hard reuse providing possible combinations features 
example sets bags dictionaries compare elements keys equality 
structure needs variants uses equality elements uses identity uses equality function plugged structure created 
classes set true dictionary bag missing 
similar situation exists weak variants collection classes hold elements weakly way prevent garbage collected 
nice characteristics captured reusable components programmers combine say build data structure suits application 
simultaneously simplify collection hierarchy eliminating combinatorial explosion features give programmer flexibility choose wider range collections 
immutability feature provided current hierarchy special cases 
symbols intervals currently immutable collections immutable collections useful contexts 
strings immutable literal arrays captured current set classes 
stream classes exhibit orthogonal features read vs write binary vs text 
necessary combinations implemented duplicating code combinations simply unavailable 
problem collection hierarchy observed cook interfaces classes expect certain methods missing 
classes string text provided example 
string adds new methods protocol superclass class 
methods related parsing converting html searching substrings regular expressions operations specific character strings inevitably methods defined specifically class string 
squeak defines class text representing character strings attributed font changes string messages ought understood text objects standard squeak system 
remaining missing 

text subclass string missing methods inherited situation similar problem rectangle described section 
fixing problem squeak require code duplication delegation methods 
mention collection behavior desired objects primarily collections 
example class path subclass able inherit collection 
path represents ordered sequence points arcs curves lines splines implemented subclasses path 
path implements basic kinds collection behavior example methods put collect 
path attempt implement full range collection behavior example path provide methods select simply methods viable re implement existing implementation reused 
section discusses traits collection behavior available outside collection hierarchy 

results section collection hierarchy emerged refactoring efforts 
start describing distributed behavior pre existing classes traits traits construct new set classes 
analyze new hierarchy respect code duplication possibilities reuse issues 
source code hierarchy tools produced available web www iam unibe ch smalltalk traits zip new collections hierarchy shows new hierarchy common concrete collection classes re implemented superclasses 
addition name class shows traits class composed 
classes divided layers 
top hierarchy class collection composed traits provides small amount behavior collections 
layer classes represent different combinations externally visible properties collections 
call properties functional distinguish implementation properties 
inheriting form functional classes concrete classes uses traits specifies implementation 
describe functional properties implementation traits turn 
functional traits 
kind collection characterized properties explicitly ordered array implicitly refactored collection hierarchy 
classes italicized names class name show top level trait class composed 
traits turn composed shown figures 
unordered set extensible bag immutable interval keyed dictionary see section discussion 
various combinations properties easily represented combining respective traits 
necessary create trait property see combine build classes 
order achieve maximal flexibility ensured combinations property traits available forms composite traits reused outside collection hierarchy superclasses inherited 
modularized primitive properties finely necessary goal avoid code duplication 
fine structure gives programmers freedom extend modify reuse parts new hierarchy 
addition property traits contain methods creating corresponding individual sub properties gives internal structure easier understand 
flattening property cost fine grained structure possible flatten code structured view 
shows composite property traits built primitive traits 
naming convention 
names suffix consisting letters sets 
letter indicates methods trait require collection sequenced means methods trait requires collection sequenced 
similarly means methods require collection mutable means method requires collection mutable 
suffix contain letter sets trait contains methods characteristic 
example trait contains part enumeration behavior require sequencing uses contains methods require methods require sequencing 
furthermore methods traits treat target object immutable 
implementation traits 
functional property traits visible client collection class characterized implementation usually relevant client 
functional implementation traits largely independent 
refactored hierarchy separates traits specifying implementation collection traits specifying functional properties 
allowed freely combine different functional property traits suitable implementations linked array 
place extended functionality concrete class indexable understand 
figures show structure implementation traits 
implementation traits shown common sense components implementations 
example behavior creating new instances new collected trait implementa traits build stream classes 
tion traits 
traits captures behavior specific concrete class built combination local methods common implementation traits 
trait contains default implementations methods includes hash 
defaults written independent implementation underlying collection may unnecessarily slow certain implementations 
example includes implemented correct hashed collections includes 
specific implementation traits decided root class collection hierarchy methods inherited possibly overridden various implementations 
example implementations includes 
new stream hierarchy refactored version stream hierarchy retains class standard squeak hierarchy uses capture notion place put methods just shared subclasses 
protocol reduced messages 
subclass direct subclass shares traits shown 
traits build stream classes simple structure shown 
obvious names add different sets methods means different things readers writers 
measurements refactored classes refactored part collection class hierarchy shown contains concrete classes classes 
classes built total traits 
stream hierarchy shown contains concrete classes classes composed traits 
average number traits build class maximum class 
statistics 
string anomaly containing methods appear hierarchy explained section initially excluded string text measurements see column 
numbers self explanatory 
methods saved difference number methods original trait versions subject code 
source code saved difference size versions measured bytes traits corresponding functional properties built primitive traits 
boxes represent larger composite traits relationships shown arrows 
remaining listed bottom part box indentation show sub 
common implementation traits 
traits provides behavior common specific implementation traits shown 
specific implementation traits 
traits supplies implementation methods particular concrete class 
classes refactored stream hierarchy 
collection collection stream totals classes classes classes string text string text string text string text number concrete classes number methods original version number methods trait version methods saved methods saved ratio source code saved source code saved ratio methods high methods high percentage original methods high explicitly disabled total savings total savings ratio table summary refactoring computed decompiling methods 
excludes comments automatically adjusts differences formatting naming variables 
phenomenon methods implemented high mentioned briefly section 
suppose needs method classes subclass relationship 
single inheritance language way duplicating code promote method common superclass instance method implemented high represents method duplicated implemented logically correct place 
fact methods duplicated times 
total savings row table simply sum number methods implemented high number duplicated 
duplication known problem implementing methods high may obvious 
implementing methods high means inherited behavior inappropriate cancelled 
example part collections hierarchy refactored messages explicitly disabled subclasses typically defining self 
problematic methods implicitly disabled directly indirectly call explicitly disabled methods 
implementing methods high may better code duplication hierarchy harder understand 
example method collection sends self add element argument 
consequently appears collection understands attempt method say array cause runtime error 
trait implementation need resort tactic method exactly classes need 
classes easier programmer understand browsing protocol class tells exactly methods 
second column table includes refactored string text classes 
comparison refactored classes version collection hierarchy containing augmented text class defines methods string missing standard text class 
regularity interfaces objects important object oriented programming argue augmented text class really ought provided standard squeak feasible existing technology 
refactored version uses traits provide text methods string achieves interfaces far fewer methods 
third column shows situation stream classes 
note hierarchy fewer duplicated methods reduction number methods achieved traits slightly lower 
reason duplication enormous number methods implemented high precisely shared 
methods explicitly disabled 
stream classes hard understand appears methods ought fact break call method explicitly disabled 
final columns totals collections streams excluding including string text classes 
assessment refactored classes quantitative improvements refactored part collection classes noted trait implementation advantages impact inside outside collection hierarchy 
undertook refactoring phases 
phase refactored concrete collection classes stream classes 
phase set basic structure functional traits implementation traits developed traits 
need exclusion aliasing free split trait large needs 
continued refactoring collection hierarchy increasing percentage reduction code size applied reusable traits remove code classes 
returning refactoring months able reuse traits extended refactoring parts hierarchy 
traits split smaller pieces recombined change semantics classes refactored affected 
places exclusion avoid disturbing existing trait 
traits written allow construct new kinds collection simply composing necessary traits implementing glue methods 
example build class trait subclass bag create immutable variants collections omitting mutable interface traits 
addition availability traits frees implementors collections framework need ship pre built collection classes rarely special cases 
main responsibilities implementor provision basic class hierarchy contains common collection classes set designed set traits composed classes 
basis programmer easily traits order build special purpose collections 
advantage new framework traits outside collection classes 
example trait requires size provides isempty notempty class defines size 
similarly trait provide class methods enumeration protocol provided implements 
important 
believe power object oriented paradigm comes having different objects understand protocol corresponding ways 
example quite frustrating find understands size isempty understand 
availability finegrained traits possible protocols uniform classes system cost code size maintainability reduction effort required find way system 
design decisions availability trait composition single inheritance gave lot freedom designing new collection classes 
choose particular combination trait reuse inheritance described 
alternative approach trait composition exclusively minimize eliminate inheritance 
done concrete collection classes built trait composition collection class direct subclass object empty common superclass collection 
decided approach primarily reasons familiarity 
inheritance trait composition new hierarchy easier programmers familiar single inheritance code especially programmers know old collection classes understand extend new ones 
flattened view new collection classes exhibits structure quite similar old ones superclasses correspond 
single inheritance turns suited explicitly representing functional property layer classes implementation layer concrete classes 
particularly true separation functional methods implementation methods clear 
example case particular implementation trait defines optimized variant method generically defined functional trait 
concrete classes composed implementation traits inherit functional traits sure situations implementation methods override functional methods 

discussion section discuss things learned traits refactorings 
examine places theoretical benefits traits practical importance argue similarly fine grained decomposition harder accomplish mixins multiple inheritance 
lessons learned refactoring learned number things traits programming tools general things refactoring 
traits simplify refactoring 
traits refactoring major hierarchy smalltalk collections hard task think 
wizards clear plan started 
just started pair programming doing simplest thing possibly didn point just slightly sophisticated 
started dragging methods existing classes dropping traits quite easy identity necessary traits 
superficial familiarity smalltalk collection classes re read cook study 
expected find traits related different implementations major categories functionality described section 
method fit traits defined simply created new trait 
hardest part finding appropriate names traits important difficult naming scheme surely improved represents third fourth attempt 
tools important 
refactoring project standard smalltalk programming tools allow look just classes implementors senders particular message trait specific tools abstracting away instance variables viewing unsatisfied requirements able move method instance variable accesses automatically turn message sends turned enormous help 
particularly useful know layer introduced eliminated changing semantics methods 
consider refactoring task simply grouping existing collection behavior coherent traits 
newly constructed traits requires category browser showed methods missing order trait complete 
naturally missing methods belonged logically traits simply continued adding methods trait unsatisfied requirements belonged traits 
fine grained components 
refactoring progressed realized methods collection hierarchy grouped traits finer granularity initially thought 
tools traits impose cost finer grained structure didn trade elegance implementation understandability usability functional interface characterizes mixins multiple inheritance 
defer design class hierarchy 
getting class hierarchy right known hard 
problem usually forced decisions early known implementation 
response put making decisions long possible turned phase refactoring 
theoretical properties traits confident things turn provided collected behavior logically coherent traits 
traits eventually combined complete classes build deep hierarchy concrete classes matter knew trait composition inheritance freely combined 
built implementation interface traits obvious combine 
combined traits important flattening property 
realized importance structured view shows traits class composed interconnected 
summarize able put hard decisions knew system correctly 
combination language technology right properties flattening set tools exploited properties provide multiple views program 
comparison mixins arguing traits valuable contribution language designers arsenal address question obtained equally impressive results mixins multiple inheritance 
convinced answer section attempt explain 
previously theoretical arguments traits mixins multiple inheritance 
focus experience theory 
compare traits mixins multiple inheritance considered stylized application mixins 
refactored collection classes built traits average class contains traits 
feasible sum operation lets build subclass group traits parallel 
contrast mixins applied time result huge hard understand inheritance chains levels 
worse places exclusion avoid method conflict way simulated mixins 
example traits ta tb define methods expression ta tb denotes trait containing method tb method ta 
ta tb mixins traits way mix obtain effect 
mixins solution modify ta introduce new intermediate mixin corresponding ta 
choice desirable 
modifying components bad may break places components 
introducing intermediate components inheritance chains longer harder understand 
particularly problematic super mixins means support flattening property 
traits problem arise sum exclusion allowed obtain right composite behavior quite easily 
example trait conflicts collect single takes precedence 
exactly situation exclusion designed obtained desired behavior excluding collect 
aliasing provides way access overridden behavior compromising flattening property reducing understandability composite traits 
aliasing way traits class 
process refactoring encountered situations adding new method component caused conflict component distant code 
requirement explicit conflict resolution places immediately detected able reestablish correct semantics making appropriate adjustment appropriate trait composition clause 
necessary modify components situation resolving conflict created 
mixins case 
detected conflicting methods easily order mixins automatically resolves conflict necessarily way programmer intend 
second noticed conflict resolved incorrect way harder re establish correct behavior 
comparison refactored collection classes collection framework strongtalk smalltalk provides data effectiveness mixins traits 
frameworks classes smalltalk quite comparable 
strongtalk collection classes uses different mixins compared traits hierarchy 
particular strongtalk doesn factor characteristics extensible implicitly sequenced explicitly sequenced aspects enumeration reusable outside collection framework 
course fact designers strongtalk decided pursue fine grained decomposition mixins mean doing impossible 
indication strongtalk designers decided disadvantages finer structure outweighed advantages 
contrast traits fine grained decomposition advantages 

related inspired part cook study conformance inheritance smalltalk collection classes 
cook extracts interface hierarchy conformance sets public methods various classes :10.1.1.116.1298
solve problems raised messages interpreted differently different classes writes formal specifications methods corrects method names 
cook results show wide divergence inheritance mechanism build hierarchy conformance relationship interfaces 
complementary cook attempt merge implementation conformance hierarchies 
moved implementation traits widely reused frees inheritance hierarchy capture conformance 
workers reported measurements impact mixin abstractions non trivial class hierarchies 
moore reports self improvement tool called guru automatically restructures inheritance hierarchies methods self programs 
moore applies guru fragment self library includes strings vectors sequences contains objects play role classes 
restructured version hierarchy reduced number methods number overridden methods 
method level refactoring introduced additional methods 
moore analysis finds problems inheritance described notes necessary manually move method higher hierarchy obtain maximal reuse 
differs moore uses tool automatically restructure refactor inheritance hierarchies developed new language concept associated tools support programmer writing better reusable code place 
focus improving understandability moore approach may negative impact understandability introduces methods generated names 
interesting adapt techniques guru help programmer identify traits example identifying duplication existing hierarchy 
shares similarity research efforts hierarchy reorganization refactoring 
proposes algorithms automatically reorganizing class hierarchies 
algorithms help handling modifications libraries software components provide guidance detecting correcting improper class modeling 
dick propose new algorithm insert classes hierarchy takes account overridden overloaded methods 
key difference results hierarchy reorganization focuses transforming hierarchies inheritance tool 
contrast interested exploring mechanisms composition context mixin language abstractions 
refactorings behavior preserving program transformations important topic object oriented reengineering community 
research refactoring originates seminal opdyke defined refactorings 
context tokuda batory evaluate impact refactoring engine 
rajlich report reengineering experience dedicated tools refactoring developed 
analyze versions code compare degree reuse 
programing languages constructs similar traits differ important details believe limit reuse compared traits 
study issue available companion 
language self uses name traits self traits basically objects play role method dictionaries shared prototypes 
mentioned section strongtalk typed version smalltalk uses mixins deep level 
best knowledge scientific study evaluating level code reuse engendered approaches 
larch family specification languages construct called trait relationship turns name deep 
larch traits fragments specifications freely reused fine granularity 
example possible define larch trait isempty adds single operation existing container data type 
course significant differences traits intended prove properties programs adding trait class formally constrain behavior existing methods 

feel refactoring collections classes reached natural complete dealt wide variety classes believe learn filling remaining corners 
conduct sophisticated analysis code duplication tool duploc guru see section 
squeak foundation expressed interest incorporating traits main development stream smalltalk systems 
happens motivated inclusion remaining classes refactored framework 
thorough testing new collection classes necessary 
believe accomplished random test generator existing classes test oracle 
pleased tools built support process programming traits 
missing features tools quite usable available download hope hear reports application domains 
widening base influence evolving design traits plan study traits incorporated typed languages languages instance variables part object interface 
wider view see traits just programming construct enabling technologies vision called multi view programming 
vision gradually realized perspectives project 
thinking refactoring program creating new equivalent program idea perspectives treat original refactored programs different views entity 
views database raise level abstraction user works 
new language technology traits greatly extends range possible refactorings defines new set views permits programming powerful level 
fuller discussion possibilities outside scope 

undertook refactoring primarily obtain practical experience traits 
believed theoretical properties traits especially flattening retention explicit conflicts sum operation right ones 
programing languages tools theoretical elegance substitute usability 
extensive realistic codebase validate beliefs 

designed surprised tools trait concepts worked practice 
theoretical characteristics really practical benefits designed 
wonderful language technology may new language features real obstacle previously met 
pleasant properties traits took great care change method level syntax smalltalk 
ordinary smalltalk programmer open ordinary smalltalk browser new hierarchy understand sees 
concrete classes methods 
methods appear defined directly subclass inherited superclass exactly ordinary smalltalk semantics exactly 
method modified conventional class view method defined shared trait effect define customized version shared method local class 
exactly semantics ordinary smalltalk 
property critically important believe reasons previous technologies mixins multiple inheritance popular complexity force programmer 
example rules linearizing multiple inheritance chains understood programmer looks modifies multiple inheritance hierarchy 
results validated expectations surprises 
example turned fine grained trait structure disadvantages allow better code reuse assists program understanding easier see built 
true long flattened view available 
experts human perception evidence seen indicates humans grasp things quickly accurately observe different views 
surprise refactoring process turned quite enjoyable straightforward 
trait refactoring compatible extreme programming style development require design front knows system lets start identifying related methods putting traits 
shape inheritance hierarchy emerge 
tool support proved critical tremendous impact efficiency refactoring task 
hard imagine undertaking refactoring ordinary smalltalk browser show requires supplies sets support instance variable refactoring 
performing task traditional file tool emacs 
incremental nature smalltalk environment played important role current state composition instantly visible times 
summarize successfully refactored significant subset smalltalk collections classes 
process removed code duplication increased uniformity improved understandability provided reusable traits easier write new collection classes possible reuse collection code outside collection hierarchy 
third claim improved understandability necessarily subjective 
argue objective features refactored hierarchy support 
discrepancy apparent actual interfaces class 
words needed resort implementing method high hierarchy just enable reuse 
consequence browsing hierarchy see get public methods class available 
second structured view fine grained traits provides lot insight functional properties methods mutate object require enumeration 
structured view containing extra information optional tradeoff supplying programmers find useful simply 
acknowledgments 
initiated sabbatical visit andrew black university bern continued visit sch rli ogi 
oscar nierstrasz members software composition group bern making sabbatical possible intellectually stimulating hosts 
national science foundation late professor paul clayton provost oregon graduate institute financial support visits possible 

sherman alpert kyle brown bobby woolf 
design patterns smalltalk companion 
addison wesley 
birtwistle ole johan dahl nygaard 
simula 
auerbach press philadelphia 
andrew black norman hutchinson eric jul henry levy larry carter 
distribution data types emerald 
ieee transactions software engineering se january 
andrew black mark jones 
perspectives software 
oopsla workshop advanced separation concerns object oriented systems 
luca cardelli 
semantics multiple inheritance 
information computation 
eduardo 
managing evolution object oriented environments algorithmic approach 
ph thesis centre universitaire informatique university geneva may 
eduardo 
incremental class reorganization approach 
lehrmann madsen editor proceedings ecoop volume lncs pages utrecht netherlands june 
springer verlag 
william cook 
interfaces specifications smalltalk collection classes 
proceedings oopsla acm sigplan notices pages october 
published proceedings oopsla acm sigplan notices volume number 
dony 
automatic class insertion overloading 
proceedings oopsla pages 
st phane ducasse matthias rieger serge demeyer 
language independent approach detecting duplicated code 
yang lee white editors proceedings icsm international conference software maintenance pages 
ieee september 
richard rajlich 
reengineering object oriented code 
proceedings international conference software maintenance 
martin fowler kent beck john brant william opdyke don roberts 
refactoring improving design existing code 
addison wesley 
adele goldberg david robson 
smalltalk language implementation 
addison wesley reading mass may 
john guttag jim horning jeannette wing 
larch easy pieces 
technical report dec systems research center palo alto california july 
andrew hunt david thomas 
pragmatic programmer 
addison wesley 
ralph johnson william opdyke 
refactoring aggregation 
object technologies advanced software international symposium volume lecture notes computer science pages 
springer verlag november 
wilf lalonde john pugh 
inside smalltalk volume 
prentice hall 
ivan moore 
automatic inheritance hierarchy restructuring method refactoring 
proceedings oopsla conference pages 
acm press 
william opdyke 
refactoring object oriented frameworks 
ph thesis university illinois 
william opdyke ralph johnson 
creating superclasses refactoring 
proceedings acm conference computer science pages 
acm press 
don roberts john brant ralph johnson 
refactoring tool smalltalk 
theory practice object systems 
sch rli st phane ducasse oscar nierstrasz andrew black 
traits composable units behavior 
proceedings european conference object oriented programming appear july 
preliminary version available technical report cse ogi school science engineering beaverton oregon usa 
sch rli oscar nierstrasz st phane ducasse wuyts andrew black 
traits formal model 
technical report iam institut informatik universit bern switzerland november 
available technical report cse ogi school science engineering beaverton oregon usa 
taivalsaari 
notion inheritance 
acm computing surveys september 
sander tichelaar st phane ducasse serge demeyer oscar nierstrasz 
meta model language independent refactoring 
proceedings pages 
ieee 
lance tokuda don batory 
automating modes evolution object oriented software architecture 
proceedings coots may 
david ungar randall smith 
self power simplicity 
proceedings oopsla acm sigplan notices volume pages december 

