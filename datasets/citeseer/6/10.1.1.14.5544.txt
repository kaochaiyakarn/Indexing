impala middleware system managing autonomic parallel sensor systems ting liu cs princeton edu department computer science princeton university margaret martonosi mrm ee princeton edu department electrical engineering princeton university sensor networks long running computer systems sensing compute nodes working gather information environment process fuse information cases actuate control mechanisms response 
traditional parallel systems communication nodes fundamental importance typically accomplished wireless transceivers 
key attribute sensor networks long running systems intended operate situ minimal direct human intervention months years 
requirement long running autonomy mandates careful design runtime system manages applications node ensure reliability ease upgrades life system 
describes impala middleware architecture enables application modularity adaptivity wireless sensor networks 
impala allows software updates received node wireless transceiver applied running system dynamically 
addition impala provides interface fly application adaptation order improve performance energy ciency reliability software system 
impala designed part zebranet mobile sensor network prototyping hp compaq ipaq pocket pc handhelds 
performance data real system measurements pocket pc version simulations full mobile sensor system deployment 
impala lightweight runtime system greatly improve system reliability performance energy ciency 
ideas introduced sensor networks applicability broadly long running autonomous parallel systems 
categories subject descriptors computer systems organization special purpose application systems real time embedded systems software engineering design tools permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
ppopp june san diego california usa 
copyright acm 
techniques modules interfaces software engineering software architectures domain specific architectures operating systems organization design distributed systems real time systems embedded systems general terms design experimentation performance keywords sensor networks middleware system software adaptation software update 
years wireless sensor networks emerged computing communication domain significant research interest 
comprised sensor nodes distributed environment wireless sensor networks represent domain parallel distributed computing heightened interest importance years 
sensors may capture data position temperature images auditory information inputs relevant specific intended 
sensor nodes modest compute communication resources process data example compress encode fuse data collected local remote sources communicate nodes network 
scale sensor network systems typically tens hundreds thousands nodes coordinating communication computation nodes complex 
depending node topology network connectivity node mobility communication protocol computations perform vary widely 
nearly impossible single protocol appropriate time single sensor network application 
amount adaptivity crucial protocols properly handle interesting range possible parameter values 
reasons sensor networks need adaptive application software automatically discern needed parameter settings software usages adjust automatically 
motivation adaptation comes fact sensor nodes typically operating tight computation energy constraints highly tuned operation may way solve problem energy budget 
sensor networks long running systems device failures overwhelmingly occur 
adaptation failed devices pressing feature 
adaptation application software accomplished di erent ways 
example build monolithic piece application software written adapt various scenarios envisioned time written 
di culties monolithic adaptive software 
large adaptive systems hard program properly bugs 
second addition pre programmed adaptivity inevitable software updates required months years designed lifetime sensor network deployment 
sensors typically deployed large numbers places inaccessible system managers update adaptation strategy needs broadcasting updates wireless transceiver 
impala non monolithic application structure aids wireless software updates allowing application updates arrive modular pieces requiring successful transmissions large new code 
describes impala middleware system api sensor application adaptivity updates 
essentially propose runtime system acts lightweight event device manager mobile wireless sensor node system 
impala built part zebranet ort sensing nodes placed wildlife perform long term migration studies collection animals ecosystem 
zebranet ort ers clear motivation remote software updates adaptivity clearly want re capture collection animals time software update apply 
fly software updates impala novel examining software architecture best suited minimal performance energy impact code running sensor node performance energy constrained 
designed handle fact mobile networks incomplete connectivity heterogeneous collection protocol versions may installed various nodes point time 
middleware encourages interoperability distinct protocols long safe 
feel middleware features valuable range distributed grid computing environments results fairly broad applicability 
shows impala middleware layer introduces little new overhead monolithic approaches 
built impala prototype hp compaq ipaq pocket pc handhelds running linux report overhead 
addition simulation studies larger deployments show ciency reprogramming network application update mechanism application adaptivity help communication protocols discern higher performing lower energy approaches managing data zebranet system 
remainder structured follows 
section gives context impala presenting brief overview zebranet system 
section describes impala system 
sections focus impala application adaptation application update functionality 
section ers evaluation impala system combining real system simulation measurements 
section sketches related section ers 

zebranet project overview impala system part zebranet project mobile sensor network system aimed improving tracking technology energy cient tracking nodes peerto peer communication techniques 
zebranet immediate focus wildlife tracking large regions little communications infrastructure broader goals concern deployment management communications issues large numbers static mobile sensors 
sensor networks zebranet form parallel system involve coordination tens hundreds compute devices 
autonomic adaptive computing common research theme systems today motivation impala comes quite directly anticipated usage zebranet 
aim deploy zebranet nodes tracking long term operation 
course study software upgrades adaptation needed 
manual upgrades di cult compute nodes wild animals need retrieve nodes change software manually 
zebranet hardware node includes global positioning system gps simple microcontroller cpu wireless transceiver mb non volatile storage hold logged data transmitted 
zebranet count constant communication access base station uses periodic node discovery peer topeer communication communicate data base station peer nodes store forward routing 
connection oriented scheme node identifies full route base data transmitted base hop hop nodes heuristics guide data base seen 
version zebranet main application software running node communication protocol software trying get data back base station 
sensor systems complex application software filtering fusing sensor data addition communicating 
impala designed support range applications 

impala zebranet energy constrained systems sensor node tempting build monolithic lean software hardcoded handle exactly envisioned compute needs node 
monolithic approaches appealing glance best meager compute resources available smallest possible energy consumption 
typically making case modular code long term view important 
particular sensor networks deployed harsh surroundings intended run user intervention months years time 
sensor networks designed hundreds thousands nodes 
sensor networks distributed huge geographical areas 
reasons designers consider long term management sensor application software integral part design process 
adopting middleware layer update adapt applications dynamically new protocols plugged time switches pro performed 
impala approach outline uses middleware layer intended act operating system resource manager event filter top specific applications installed run 
major contributions explore implementation non vm middleware layer intended infrequent code updates 
link functionality application adaptivity application updates ering framework works 
evaluate full system prototype approach addition simulating large scale sensor deployments impala 
design rationale combining multiple application protocols large adaptive self updating protocol possible layered approach advantages monolithic approach 
modularity middleware layer care switching decisions applications independent need coordinate 
middleware layer handling update issues applications focus objectives disregard need contemporaneous software execution update 
correctness impala application correctness easier achieve programming individual applications simpler programming super application interacting updating components 
ease updates software changes adding deleting modifying application simpler involve local code changes module 
contrast monolithic approach small changes may global repercussions code 
energy ciency transmitting entire monolithic program software updates transmitted granularity smaller program module 
network transmitter component energy constrained sensor network ers significant energy savings 
system architecture shows system architecture impala 
upper layer contains application protocols programs zebranet 
applications various strategies achieve common task gathering environment information routing centralized base station peer peer transmission 
application running time 
lower layer contains middleware agents application adapter application updater event filter 
application adapter adapts application protocols di erent runtime conditions improve performance energy ciency robustness 
application updater receives propagates software updates layered system architecture 
wireless transceiver installs node 
adapter updater described detail section 
event filter captures dispatches events system units initiates chains processing 
impala types events 
timer event signals timer gone 
impala timers owned respectively current active application application adapter application updater 
owner timer handles events 
packet event signals network packet arrived 
impala types packets application application packets updater updater packets 
intended receiver packet handles events 
send done event signals network packet sent failed send 
allows asynchronous network transmission 
original sender packet handles events 
data event signals data sample sensing device ready read 
current active application handles events 
device event signals device failure detected 
application adapter handles events 
multiple events arrive time processed sequentially 
eliminates programming complexity synchronizing di erent event handlers 
prevent significant delay processing subsequent events event handlers required complete limited amount time 
blocking operation network transmission handed system components performed asynchronously 
application programming model illustrates event programming model impala 
applications application adapter application updater programmed set event handlers invoked event filter associated events received 
particular applications implement event handlers timer handler packet handler send done handler data handler 
addition help adapter query applications switch applications required implement routines application query application terminate application initialize 
impala user library contains number general programming utilities 
networking utilities allow applications send asynchronous messages encapsulating packets completion generate send done event event filter 
timer utilities allow applications set timer various purposes example send messages certain time regular intervals 
timer set reset canceled 
device utilities allow applications certain degree control hardware devices example turn network transceiver 
programming utilities available adapter updater 
global data structures include uniform storage image sensed data execution frame save application execution states 
storage sensed data stateful resource applications changes storage application passed 
applications agree basic storage organization 
specifics storage utilization individual applications 
uniform storage image defined impala list data generated local sensing device list data received nodes log data successfully routed base station 
second application needs execution frame shared event handlers save execution states network communication memory management impala defines single execution frame applications 
format application specific 
sum shows timeline example event application programming model 
timelines show series events event handler actions communicating sensor nodes hour data communication cycle zebranet 
arrows indicate things happen text planes show happens layer 
application event handlers respond application events perform routing operations peer discovery data transfer application routines called impala event handler help query switch applications 

application adapter zebranet sensor nodes loaded multiple applications routing data back base station different applications applicable di erent conditions 
adaptation desirable scenarios 
performance energy ciency attributes protocol depend heavily number factors adapter handles interesting range parameters adapts sensitive changes values 
second device critical protocols critical adapter adapts protocol choice hardware failures improve robustness 
adaptation implemented impala event programming model occurs response range events 
events timer events signal time passed status check adapter may choose query application system states order determine adaptation performed 
events device events sources external impala timeline example event application programming model 
signal external event impala respond failure particular radio transceiver adapter examine impact failure determine dispatch application 
adapter best overview runtime states design choice adapter applications switching decisions alternative yield restrictive programming model flexibility application design 
currently adaptation mainly local states individual sensor nodes eventually plan adapt global coordination best sensor network 
adapter functionality set application parameters system parameters defined represent runtime states 
application parameters comprise information known particular running application system parameters represent information known impala 
application parameters include histories averages totals number direct network neighbors encountered ii amount sensor data successfully transferred peer sensor nodes iii amount free storage application data 
system parameters include battery level ii transmitter range power iii geographic position node 
application specialized tracking subset application parameters responsible reporting values 
adapter application parameter table records application tracks parameters 
current implementation allows application parameters table size quite reasonable 
table application query switch 
order catch sensitive parameter changes periodically adapter queries current active application parameter values claims track fetches system parameter values examines switching rules 
switching rule satisfied application switch performed 
application parameters histories attributes average number direct network neighbors cycles adapter passes 
rule associated current active application 
parameter rule unknown value 
parameter application parameter 
query application parameter value 

get parameter value system call 
rule satisfied parameter values 
query application unknown parameter values 
terminate current active application 
pass parameter values application 
initialize application 
return pseudo code application query switch 
adaptation finite state machine 
parameters application switch 
shows pseudo code application query switch 
sensor node zebranet active network communication half hour hours choose conduct application query network activity period shown 
adapter interfere application communications reduce network bandwidth precious sensor network 
having queried parameter values adapter adaptation decisions examining adaptation finite state machine shown 
states correspond di erent applications 
arrows represent adaptive transitions application parameter expression arrow condition switch happens 
example assume protocol selective protocol uses short range radio transmit single neighbor protocol indiscriminate flooding protocol uses long range radio transmit 
protocol consumes energy generates network tra performs nodes encounter transfers fairly frequently 
contrast sensor node isolated remote location energy spend protocol may allow connect ectively 
adopt adaptive switching rule says switch protocol protocol average number direct neighbors cycles battery level full charge 
likewise switching rule says switch protocol protocol battery level full charge 
device adaptation adaptation device failures accomplished method similar parameter adaptation described 
device failures cause device events responded 
device failures discovered periodic queries discover non responding piece hardware 
order respond ectively device failure impala application device table records application relies hardware devices 
prototype size table allow devices tracked currently instantiated results short range radio long range radio node gps transceiver 
device failure adapter respond disabling protocols requires failed device 
current active application disabled switch application require failed device 

application updater similar software update problem previously studied mate zebranet sensor networks distinctive characteristics change design tradeo high node mobility sensor networks targeted mate comprised static nodes 
zebranet nodes fairly high mobility move clustered patterns 
constrained network bandwidth zebranet data frequently collected sensing devices eventually transmitted base station 
generates significant network tra network bandwidth available software transmission constrained 
wide range updates zebranet software updated wide range small bug fixes major application enhancements adding deleting complete applications 
characteristics implications issues application updater handle 
incomplete updates network bandwidth low network connectivity broken nodes moving take attempts node gather elements complete update network 
incomplete updates common 
update vs execution impractical halt execution wait update complete mate may take long 
progress software updates processed parallel software execution 
contemporaneous updates network infection time update potentially long 
updates issued close nodes may receive multiple incomplete updates may order 
inconsistent updates mate application module updated independently assuming update compatible existing modules 
zebranet potentially dramatic software changes mean modules associated correct version software 
propagation protocol updater find ective communication protocol propagates software rapidly consumes minimal network bandwidth 
persistent broadcasting method mate zebranet 
code memory management zebranet sensor nodes loaded applications contains program modules 
large amount software existing sensor system code memory management challenging 
goal application updater achieve ective software update mechanism mobile wireless sensor networks resource constraints 
designed software management transmission mechanism dynamic software updates summarized 
software management store complete incomplete update versions code memory 
complete updates logged execution 
incomplete updates logged able resume time update available 
software transmission adopt demand transmission strategy 
sensor nodes periodically exchange software version information exchanging actual code requested 
frequency version information exchange automatically adjusted estimate sensor nodes updates 
sections describe design detail 
software compilation linking layout injected network program module compiled binary instructions 
linking performed updater sensor node 
module linked main program modules update received 
allow cross modules 
means module linking independent modules 
modules linked re versions re linked 
linking new application considered installed node 
code memory stores complete incomplete applications 
application complete modules received 
time keep highest complete version higher incomplete versions application 
memory space dynamically allocated incoming module deallocated relinquished 
target size module kb average kb maximum 
module occupies consecutive memory space aligned kb 
means smallest memory block kb biggest allocation request blocks 
shows code memory layout 
software version numbers impala adopts module version system facilitate long term software development update 
module version number application version number 
version numbers increase monotonically 
module version system allows selective software transmission 
exchanging software updates nodes exchange index application modules request changed modules transmission 
prevents code memory layout 
transmission unchanged modules saves network bandwidth 
software transmission adopt demand software transmission strategy stages 
shows pseudo code 
node advertises software version information knows versions 
software version information includes version numbers complete applications highest application version numbers known far 
nodes newer applications information implicit offer software updates 
nodes older applications information implicit request software updates 
want propagate software updates quickly possible preserve network bandwidth software version information advertised nodes complete updates 
receiving software version information network neighbors node determine highest complete version available application send requests modules 
node may modules newer version making explicit requests saves unnecessary software transmission 
final stage node highest complete version transmit actual code requested neighbors 
ties broken node id unique network 
stage procedure repeat node finds stage network neighborhood complete applications known far indication population new software converged 
exponentially back repeat timer 
timing control automatically maximize software propagation speed initial propagation phase automatically slow 
saves unnecessary broadcasts software version information population new software converged propagated local area network 
software reception installation application update received network logged application update lists aul shown 
node lists application update record format shown 
entry pointers locate program modules code memory 
null corresponding modules received 
list sorted application version numbers 

stage 
send software version information 
stage 
application 
check version information collected stage 
higher version 
check modules need 
send request modules needed 
stage 
application 
check requests collected stage 
application requested 
send packet requested module pseudo code demand software transmission stages 
may take long time receive update completely updater tries keep records incomplete update software improvement intermediate applied possible 
save network bandwidth update show 
keeping incomplete update expensive terms memory energy consumption 
insufficient memory space due incomplete updates released space 
release goes lower versions higher versions application applications 
system receives update added aul 
software reception interrupted record modules missing need re transmitted time available 
modules considered missing received entirety 
software reception complete updater install new application node 
guard unexpected programming errors updater performs simple security checks 
errors include invalid memory accesses absence return statement module causes execution step boundary 
attempt protect malicious programs 
eventually proves desirable consider methods proof carrying code 
second linking performed unlinked modules 
updater copies application activation table aat 
format entry aat shown 
similar entry pointers defined 
aat serves application link table links applications launch main program 
event filter invoke application event handlers adapter call application routines 
aat serves software version information table advertised software transmission stage 
copied aat lower application version numbers removed aul 
memory copy software needed aat pointers memory location actual code 
current active application updated updater terminate old version overwrite aat entry initialize new version 
application updater implemented impala event programming model illustrated 
example shows performing software transmission reception installation software communication cycle zebranet 
application update lists 
application update record 

system evaluation system implementation overhead addition achieving middleware functionalities impala aimed lightweight system layer 
help evaluate overhead real sensor networks prototyped impala modern mobile computing devices hp compaq ipaq pocket pc handhelds measured overhead event delivery processing 
implementation details mobile devices impala prototypes attributes 
pair ipaq handhelds mhz cpus running linux familiar gui 
handheld included mb flash ram main memory mb flash rom file system 
impala middleware layer implemented application adapter application updater event filter networking timer utilities 
application layer implemented application protocols selective history protocol indiscriminate flooding protocol 
table shows memory footprint application programs 
experiment performed ipaq nodes ran impala minute cycles 
experiment cycle equivalent hour data software communication cycle zebranet 
nodes loaded protocols 
flooding protocols version history protocol node newer version packet handler node 
nodes start history protocol 
cycle newer packet handler transmitted node installed node 
sensor data transmitted node considers appropriate transmission target history protocol 
second cycle nodes switch flooding protocol previous cycle direct network neighbors history protocol perform 
data exchange happen 
see consistent application versions time software transmission happen timer back cycle 
cycle application activation table 
event software transmission reception installation 
nodes switch back history protocol flooding achieved data distribution 
time node run newer version history protocol 
stay idle 
overhead measurement measurement focused impala overhead event delivery processing 
opposed monolithic approach hands application events directly application layer impala delivers events checking destinations delays processing 
turns event delivery latency packet events send done events timer events involves branch compare instruction 
data events handled current active application destination check latency involved 
impala processes events 
event processing time inherent impala applicable monolithic approach example time application query switch 
event processing time commonly required example time software transmission reception installation 
table lists processing time impala events application events show relative values 
general impala events occur frequently application events 
table time receive process code packet updater longer 
prototype implementation received code packets written files flash rom ipaq extraordinarily slow 
fact write operation takes total time 
table memory footprint application programs 
efficient network reprogramming important design goal impala achieve optimal software propagation speed consuming minimal network bandwidth 
demonstrate ciency impala demand software transmission strategy conducted simulations reprogram entire sensor network 
experiments sensor nodes move km km square map software updates broadcasted base station node range propagated peer peer transmission 
radio range nodes meters 
nodes wake hours exchange software updates 
update strategies evaluated 
broadcast updates nodes probability time updater wakes 
updates discarded received nodes updates 
second demand software transmission strategy 
shows time update infect network 
time represents point base station shows network update 
probability equals probabilistic broadcasting strategy achieves maximal propagation speed ideal case 
shows demand software transmission strategy network infection rate increases rapidly slows 
closely follows ideal curve outperforms probabilistic broadcasting lower probability 
cases strategy misses immediate update opportunities 
example node cluster updated nodes encounters node cluster nodes nodes think updating procedure converged back timers software version information advertising seen homogeneous population updates 
case nodes discover back interval delays update 
shows number software transmissions performed infect network 
demand transmission increases approximately number updated nodes 
probabilistic broadcasting higher increases linearly time 
di erence actual network bandwidth consumed strategies larger 
strategy selects updated modules transmit strategy discrimination 
strategy communication overhead software version information software request messages 
net table impala event processing time 
network infection rate 
software transmission volume 
reprogramming complete version messages request messages transmitted addition actual software transmissions 
potential benefits adaptation important design goal impala achieve intelligent scheduling various protocols adapt di erent conditions ultimately improve system performance 
demonstrate ectiveness protocol adaptation conducted experiments focusing improvements system aspects routing performance energy ciency robustness 
simulation methodology experiments conducted upgraded version sensor network simulator 
details original simulator 
briefly sensor nodes move km km square map 
sensor node radios short range radio long range radio 
routing protocols programmed network 
direct transmission protocol baseline protocol involve peer peer transfer 
node transfers data base station range 
flooding protocol sends data network neighbor 
history protocol encodes likelihood node range base station assigning node hierarchy level past success transferring data base station selects neighbor highest hierarchy level send data 
simulation simulates sensors activities days computes routing success rate percentage data ultimately received base station 
example improving routing performance experiment demonstrates protocol scheduling tune sensor communication pattern di erent network connectivities achieve optimal routing success rate 
experiment sensor node schedule protocols flooding protocol protocol radio device radio range varied meters meters 
dotted curves show base scenarios sensor nodes run protocol 
radio range low network connectivity poor sensors hardly find neighbor 
case flooding protocol better history protocol sending data neighbor maximizes chance finding data path base station 
radio range high network connectivity sensors transmit sensors vicinity 
case flooding outperformed history injecting data network constrained limited network bandwidth 
fact apply switching strategy sensor adapt routing performance improvement protocol switching 
protocol switching frequency 
network connectivity bandwidth availability run history protocol history protocol average number direct network neighbors encountered half hour protocol communication window average number indirect network neighbors switch flooding protocol flooding protocol average number direct network neighbors average number indirect network neighbors switch history protocol 
stay protocol solid curve shows outcome switching strategy 
radio ranges low high follows better non switching curves 
medium radio ranges switching curve better non switching curves 
demonstrates network connectivity hybrid nodes clustered remote distances protocol scheduling able pick appropriate routing protocol specific local network condition 
shows frequency protocol switching experiment 
meters protocol switching frequent performance improvement achieved switching cost average twice day sensor node 
example improving energy efficiency experiment sensor node schedules protocols improve energy ciency 
proto energy ciency improvement protocol switching 
cols considered history protocol meter short range radio transmit flooding protocol meter long range radio transmit 
protocol low power radio conservative data transmission sensors send data nodes better track records delivering data base 
contrast second protocol employs powerful radio aggressive data transmission robust routing performance poor energy ciency 
clearly protocols complementary attributes desirable protocol energy reasons adapt second protocol supplement data delivery success rates dropped low 
sensor node adopt switching strategy run history protocol history protocol average number direct network neighbors encountered hours adjustable parameter sensor node transmitted peer sensor node base station hours switch flooding protocol flooding protocol transmitted peer sensor node base station switch history protocol 
stay protocol shows result switching strategy 
set strategy strategy 
clear protocol scheduling improve routing performance power saving protocol power hungry protocol time 
note previous experiment assume network bandwidth unlimited constraint protocol 
example improving robustness experiment tries demonstrate protocol scheduling circumvent device failures improve system robustness 
experiment sensor node schedule protocols history protocol meter short range radio transmit flooding protocol meter long range radio transmit direct transmission protocol short long switching short radio failures infinite battery charge 
switching short radio failures limited battery charge 
range radio transmit 
randomly select number sensor nodes encounter radio device failure failures occur random time 
radio fails sensor node switch protocol radio 
failed radio able receive transmit data 
implies data exchange pair sensor nodes sender transmitting radio fails receiver side receiver radio listening 
tend power saving protocol major protocol power hungry protocol supplement investigate typical scenario sensor nodes run history protocol switch protocol long range radio short radio failure 
shown routing success rate increases number failures 
protocol switching increases network connectivity communication frequency expense energy cost 
limit battery charge rate sensors run battery sensors switch flooding protocol 
result shown 

related sensor network studies salient related impala mate tiny virtual machine sensor nodes 
mate bytecode interpreter runs tinyos specialized operating system designed motes 
mate helps sensor network programmers build expressive concise applications protects system crashed applications 
performs infection small program capsules network broadcasting 
impala resemblance mate software update key di erences 
sensor system model software update problem impala deal quite di erent mate 
second mate integrates propagation installation software updates programming applications 
separate system layer performing tasks impala lowers complexity enhances modularity application programming 
second mate energy savings software update fairly frequent days 
zebranet envision software update happen frequency couple months 
third mate prevent applications crashing system impala security check oriented unfortunate programming errors malicious attacks 
impala manages system resources events acts similarly operating system sensor nodes 
studies sensor network operating systems tinyos micro amps magnet os studies sensor network architectures smart dust pico radio wins projects provide design paradigms system architecture programming model 
particular event programming model motivated tinyos 
key difference impala tinyos event model impala specially tailored development management update applications eventbased model tinyos generalized interactions system components di erent system levels 
impala envisioned support broad range applications zebranet 
requires understanding programming methodologies needs real sensor network applications 
design guided studies sensor network applications routing protocols 

presents impala middleware architecture enables application modularity adaptivity wireless sensor networks 
impala supports multiple applications adopting event modular programming model providing friendly programming interface 
impala uses lightweight system layer perform dynamic application adaptation parameters device failures automatic application updates specialized software management transmission mechanism 
prototype implementation hp compaq ipaq pocket pc handhelds simulations full deployed mobile sensor network show impala middleware architecture low overhead achieves cient network reprogramming er ective improvements performance energy ciency robustness long running sensor systems 
broadly feel impala ers insights improve behavior long running autonomic parallel systems 

barr need system level support ad hoc sensor networks 
operating systems review apr 
carter bennett zwaenepoel 
implementation performance munin 
proceedings th acm symposium operating systems principles oct 
cerpa elson habitat monitoring application driver wireless communication technology 
acm sigcomm workshop data communications apr 
clark ammar calvert 
multi protocol architecture paradigm achieving inter operability 
proceedings ieee infocom apr 
familiar project 
familiar handhelds org 
heidemann silva intanagonwiwat building cient wireless sensor networks low level naming 
proceedings th acm symposium operating systems principles oct 
hill szewczyk system architecture directions networked sensors 
proceedings th international conference architectural support programming languages operating systems apr 
intanagonwiwat govindan estrin 
directed di usion scalable robust communication paradigm sensor networks 
proceedings sixth annual international conference mobile computing networking mobicom aug 
johnson maltz 
dynamic source routing ad hoc wireless networks 
imielinski korth editors mobile computing pages 
kluwer academic publishers 
juang oki wang energy cient computing wildlife tracking design tradeo early experiences zebranet 
proceedings th international conference architectural support programming languages operating systems asplos oct 
kahn katz pister 
century challenges mobile networking smart dust 
proceedings fifth annual international conference mobile computing networking mobicom aug 
levis culler 
mate tiny virtual machine sensor networks 
proceedings th international conference architectural support programming languages operating systems asplos oct 

li sutton rabaey 
low power operating system heterogeneous wireless communication systems 
pact conference sept 
microsoft microsoft windows ce 
www microsoft com embedded 
palm palm os development overview 
www palmos com dev support docs palmos 
perkins royer 
ad hoc demand distance vector routing 
proceedings nd ieee workshop mobile computing systems applications feb 
pottie kaiser 
wireless integrated network sensors 
communications acm may 
architecture overview qnx 
www qnx 
com literature whitepapers html 
sinha chandrakasan 
operating system algorithmic techniques energy scalable wireless sensor networks 
nd international conference mobile data management mdm jan 
tennenhouse wetherall 
active network architecture 
computer communication review apr 
vxworks datasheet 
www com products html ds html 
wetherall guttag tennenhouse 
ants toolkit building dynamically deploying network protocols 
ieee apr 
