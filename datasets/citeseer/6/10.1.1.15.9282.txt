class modules haskell mark shields simon peyton jones microsoft research cambridge microsoft com haskell module language quite weak core language highly expressive 
close able express structure traditionally delegated seperate module language 
encodings awkward situations encoded 
re ne haskell core language support rst class modules features ml style modules 
proposal cleanly encodes signatures structures functors appropriate type abstraction type sharing supports recursive modules 
features compilation units interact haskell class system 
coupled support staged computation believe proposal elegant approach run time dynamic linking structured code 
builds directly jones parameterised signatures odersky system higher ranked type annotations russo semantics ml modules ordinary existential universal quanti cation odersky zenger nested types 
motivate system examples 
formal presentation included appendix 
competing techniques expressing largescale structure programs 
brand leader twolevel approach language layers core language module language 
sophisticated example structure ml variants languages haskell modula take form weaker module languages 
years core language extended versions haskell rich point close able compete largescale structure league 
possible course highly desirable remove need second language automatically mean modules rst class citizens functors ordinary functions 
purpose show bringing separate pieces existing bridge nal gap 
speci cally propose orthogonal extensions haskell goal 
record types elds polymorphic type dot notation ability single eld name distinct record types section 
nested type declarations inside records section 
nested declarations purely syntactic sugar complicated 
class universal existential quanti cation section 
record types allows conveniently express types generative functors 
declaration oriented construct opening existentially quanti ed value section notation allow opened types appear type annotations section 
standard approach expression oriented clumsy practice construct works ne top level section 
taken individually ideas proposed 
contribution put coherent design core language reasonably claim compete ways improve ml brand leader 
particular system treats module structures rst class values supports type inference interacts haskell constrained polymorphism 
module point view separates signatures structures ers type abstraction generative functors type sharing separate compilation recursive nested signatures structures 
proposal top level fairly compatible haskell existing module system clarity shall bend syntax somewhat 
system series worked examples 
formal presentation may appendix 
time writing just begun establish formal properties system 
implemented prototype compiler hope merge extensions ghc production haskell compiler 
concrete modules records jones encode interfaces parameterised record types implementations records 
haskell record syntax data constructors named arguments haskell implementations allow elds assigned polymorphic type 
requirements demanding wish share eld names records allow nested type declarations 
introducing new form type declaration 
parameterised records record types introduced explicit declaration may parameterised record set empty add union note kind type type 
equality record types nominal structural 
haskell single eld name may re di erent record types 
record terms constructed applying record constructor set possibly mutually recursive bindings set int inferred set empty add int xs filter xs union foldr add id record terms may patterns support usual dot notation eld projection int inferred add empty haskell type signature binding int optional system infer type programmer may constrain type type signature 
regarding module record allows ml functor replaced ordinary function 
example record eq bool forall set eq set empty add xs filter eq eq xs id cosmetic important di erence haskell records 
functors ordinary functions integrate smoothly haskell type class mechanism forall eq set set empty add xs filter xs id overloaded operator replaced explicit parameterisation record implicit parameterisation class eq record elds may polymorphic types record monad fmap forall 
unit forall bind forall records may constructed taken apart way monad inferred monad fmap map unit bind ma concat map ma singleton singleton unit permit subtyping extensibility records deferring extensions 
type inference type inference system problematic 
example consider fmap unit fmap may eld name records type fmap depends type know 
avoid diculties relating higher ranked polymorphism placing imposing binder rule programmer supply type annotation letrec bound variable type mentions record type constructor 
binder rule place easy share eld names distinct record types 
binder rule somewhat conservative clever inference engine annotation ensures typability program depend inference algorithm 
discuss alternative approaches section 
practice may tricky give type annotation 
example type monad type polymorphic 
provide ways solve validated practical experience ghc 
type signature forall monad fmap unit rely type checker propagate type annotation annotation obvious way statement precise 
alternatively argument may annotated directly free monad fmap unit term free introduces fresh type variable standing type scope term 
type checking may instantiated kinded type 
rst argument may assigned type form monad type 
notice stand type argument 
type inference simply replaced fresh uni cation variable 
inferred principal type 
nested type declarations modules typically contain mix term level type level declarations 
odersky zenger allow record declarations contain nested type declarations record data bintree leaf node bintree bintree empty bintree add bintree bintree nested type may projected type way eld may projected term 
various syntactical reasons write usual denote type projection 
example may write set bintree set set add set empty binds type application 
notice way writing signature add record declaration add set bintree set bintree ways writing add type signature equivalent referring type relatively relying type declarations currently scope equivalent referring absolutely path top level record type 
records just type declaration may nested records record graph ver record edge ver ver data rep rep ver edge ver edge rep rep rep may nested data record constructors terms similar projection syntax leaf forall 
set bintree inferred leaf set leaf edge graph int edge inferred edge graph edge notice type inference supplies necessary type arguments set graph 
record terms types contain nested types constructed usual way graph inferred graph vs es rep edge types data record constructors may referred relatively absolutely 
approach nested types diverges usual treatment ml style nested modules critical ways 
firstly allow record terms contain type declarations 
allow type declarations toplevel implementations merely syntactical convenience 
consequence system avoids entirely need dependent types manifestly respects phase distinction type checking evaluation 
odersky zenger takes similar approach 
secondly allow record types contain types types named definition hidden 
allow type declarations top level interfaces syntactical convenience 
restrictions mean nested type declarations may attened non nested declarations 
example declaration may rewritten data bintree leaf node bintree bintree record empty bintree cmp cmp add bintree bintree jones advocates supporting nested types grounds may translated away manner 
support system convenient subsume usual namespace mechanism turn easily implemented 
modules existentials turn attention essential properties module language ability hide implementation types 
mentioned main approaches implementation hiding brie review section 
classic approach existential types section approach far successful practice exempli ed ml uses dependent sums section 
type abstraction haskell example section representation type sets lists exposed 
bad client module pass list add operation implementation add expect set passed obey invariants maintained module list duplicates 
long recognised existential quanti cation provides appropriate mechanism hiding representation type 
haskell implementations support existential types allowing write data exists set intset int inferred intset consider typing binding intset 
body data constructor bound application typed 
outside constructor existential quanti er hides binding programs wishing operations intset rst open existential quanti cation case expression int inferred case intset add empty somewhat confusingly implementations require keyword forall situation exists 
alert reader may existential quanti cation higher kinded type variables 
haskell uses simple incomplete uni cation algorithm higher kinded types turns practice 
typing arm case involves checking term add empty typed assumption set int type constructor equivalently check term add empty polymorphic type forall set int type containing wish manipulate implementations containing equal types known diamond import problem literature 
example assume function implementation sets generates additional helper functions record forall set set foldr set union set empty consider constructing set helpers intset 
clearly simply write intset error type int incompatible type set int way avoid mismatch set write version works sets directly data exists forall case set set notice introduce datatype hide representation sets 
function may write int inferred intset intset may mixed defeating purpose main case intset add empty add empty error arm case insufficiently polymorphic convey information particular set helpers share representation exposing representation 
solution problem haskell carefully structure program intset opened scope containing de nition uses terms need share representation types intset forall set int int int add empty add empty main case intset examples illustrate serious drawbacks existential type approach type abstraction haskell forced introduce entirely spurious datatype instance type abstraction 
datatype simply tell type inference system expect existential types 
ii seriously spurious datatype stripped away scope covers terms need share particular implementation type 
awkward large programs impossible uses type split compilation units 
type abstraction ml ocaml drawbacks led module language designers abandon simple minded approach type abstraction existential quanti cation preference strong translucent dependent sums known manifest types 
example ocaml set described signature module type set sig type type val empty val add val union val list type constructor nested type set left 
ml module languages signatures parameterised nested types default 
binding supplied structure implementing signature set module set struct type int type list empty add fun xs filter fun xs union fun xs ys fold right add xs ys fun xs xs binding list hidden explicit signature coercion 
course binding int hidden probably intended 
sharing types expressed manifest types module type sig type type list module type functor set type type module functor set struct type type fold right union sharing types argument result functor explicit clause functor type 
sum ocaml nested types explicitly manifest haskell type parameters concrete explicitly hidden existential quanti cation 
putting existentials dependent sum approach modular structure proved fruitful practice 
strong reasons continuing search alternatives 
ml style module systems extended support rst class recursive modules details extensions worked resulting system complicated 
furthermore dicult adopt system haskell interaction haskell system type classes entirely unclear 
attempted details ml style module system supporting type classes 
lastly uncomfortable duplication functionality rich core language rich module language things equal clearly better single layer 
abandoning existentials dependent sums shall tackle head problems identi ed existentials need spurious datatypes section need open existentials common scope section 
type inference higher ranked polymorphism get rid spurious data type forced introduce section 
data type served tell type inference engine introduce existential quanti cation occurrences constructor eliminate case expressions match 
able existential quanti cation freely type schemes mediating data type 
example write intset example directly intset exists set int intset set empty add xs filter xs id existential quanti ers able occur result function type 
example types saw section forall exists set forall eq exists set type signature expresses construct set implementation equality type equality representation type result 
say type signature mimics generative functor application ml 
shall see section system mimic ocaml applicative functors requires type sharing manifest 
system supports higher ranked signatures adopting system type annotations odersky :10.1.1.27.5598
extend binder rule section requiring type annotation lambda bound letrec bound variable type uses existential universal quanti cation 
exception case letrec universal quanti cation top level annotation may omitted standard hindley milner trick recursive de nitions 
odersky system strictly generalises type inference algorithm haskell implementations supporting rank polymorphism 
type inference reduces solving set subsumption constraints types mixed pre example consider inferring type forall int system discovers general type forall type checking outer application reduces checking forall forall int write denote subsumes 
check proceeds right hand side quanti ed variables forall int skolem constant left hand side quanti er variables int skolem constant nally unifying result 


int general uni er subsumption check succeeds 
extend system odersky ways 
firstly allow type schemes arbitrarily mix universal existential quanti ers 
adds expressive power great aid reporting type errors 
subsumption existentials exactly dual universals 
secondly account haskell class constraints 
particular quanti er may introduce constraint may need decide constraint entailment subsumption checking 
consider previous example amended include class constraints forall num int undefined type check outer application system decide subsumption forall eq forall num int eq constraint arises num type annotation check proceeds right hand side quanti ed variables left yield eq num int skolem constant constraint num added set known constraints eq int assuming num skolem constant rank existential exists may replaced rank universal forall 
forall moment eq constraint ignored left right hand side types uni ed yield general uni er 

int 
system check num eq denotes constraint entailment relation 
true eq superclass num 
term typed 
illustrative examples appendix gives technical details 
type inference algorithm potentially expensive existing haskell implementations 
particular expensive operations constraint simpli cation generalisation occur default step type inference just bound term 
plan investigate re ning inference algorithm avoid operations possible 
opening existentials allow existentials appear mediating data constructor nd replacement ole previously played case 
example recall previous section intset exists set int attempting project intset directly lead type error intset intset add intset empty error project empty term non record type exists set int motivated russo semantics ml modules introduce variation explicitly opens existential quanti ed type variables bound term int inferred open intset add empty keyword open indicates body add empty type checked assuming set int fresh skolem type constant replacing existentially quanti ed type intset opening intset explicitly eliminate existential quanti er type compromising type abstraction bad open intset add error incompatible types type variable arises open haskell existing monadic notation uses binding construct left hand right hand side types differ 
writing range type kind contexts 
range kind contexts may write typing rule open follows exists 
dom 
dom 
scheme open notice existentially quanti ed type variables 
arising lifted binding free skolemized type variables checking type side condition 
ensures existentially quanti ed type variable free alpha conversion may satisfy condition 
check wellformed type scheme prevents type variable 
escaping scope example term ill typed open intset empty error skolemized type introduced open escapes scope binding type int restriction system unsound open exists 
bool snd fst true crash 
alternative design modify typing rule projection words existential quanti ers transparent projection 
prefer design explicit generative nature existential types 
example term rightly ill typed attempts mix sets created di erent equalities int ineq int normal equality integers eq int equality mod open open eq empty error incompatible types set int set int type variable arises open type variable arises open limitation approach mimic applicative functors ocaml open open empty error 
see actual rule approximates 
absence side ects observationally equivalent type system considers implementation types distinct 
type sharing system manifest extreme case rejected open intset open intset empty error 
type annotations opened bindings recall running example intset exists set int int inferred open intset add empty possible programmer give type signature 
trouble body type set int fresh skolem type constant programmer way write thing 
annotations desirable documentation reasons absolutely essential come top level bindings see section 
solution add new open form type signature dual open form term binding open exists set int open intset add empty open type signature simply declares type obtained opening type exists set int type signature behaves exactly type signature optional may constrain type polymorphic inferred type 
done 
suppose write arti cially open exists set int open intset add empty give type signature 
say open exists int int introduce fresh skolemized type distinct introduced type signature want say type 
preliminary odersky zenger allow programmer say precisely 
type scope term variable denotes type new type form occur type 
example 
type forall annotation forces type illegal take type variable scheme type id forall inferred id id error id type scheme type dereferenced quite 
consider version example open exists set int open intset unit add empty unit write type unit 
type set int unit type int int 
need able refer component type 
add new type form unit int int unit add empty projects component type application 
syntactical convenience allow names original de nition set back section eld names type projections 
new type forms give rise small algebra types 
example types equal int set int int set int set int int arg know record set type parameter named parameter bound int application set int recall type application binds tighter 
rely built type parameters refer successive type arguments tuple type con notation involves term variables type expressions type depend value term variable type 

similarly rely built type parameters arg res refer argument result types respectively function type constructor 
allow record eld dereferenced 
example unit int empty 
int unit add empty say result unit type empty eld record type denoted 
opening top level bindings far tackled second problems identi ed section existential opened scope contains terms share implementation type 
identi ed serious problems 
design far carefully chosen solve problem 
needed allow open top level bindings 
consider intset example section 
improved support existential quanti cation eliminates need spurious datatypes 
open may open bind intset single top level declaration open intset exists set int open intset rest program intset type set int fresh skolem type constant 
functions remain unchanged forall set set 
forall set int int int 
de nitions may create directly intset main intset looking type see type set int application typed 
section mentioned preserve soundness skolemized type variables escape scope term variable introduced 
scope top level binding entire program check unnecessary opened top level signatures 
fortunate separate compilation means may able see entire scope binding 
top level interfaces implementations haskell existing module system combines implementation module interface speci cation single compilation unit 
system split notions 
roughly speaking take top level interface body parameterless record type declaration toplevel implementation body record appearing notional cosmic global scope 
top level interfaces appear hsi les 
example le lists hsi look module lists data list nil cons list map forall 
list list 
le induces type declaration cosmic scope record lists data list nil cons list map forall 
list list 
top level implementations appear hs les 
continuing example le lists hs resemble module lists map 

induces cosmic term declaration lists lists lists lists map 

ect simply introduce term variable lists initial type context type lists 
interfaces implementations may import interfaces 
interfaces supply type information able type check implementations independently order 
interfaces may mutually recursive type declarations subject usual rule recursion passes data record constructor 
type dereferencing possible write mutually recursive type signatures see section 
little generous cosmic record type declarations record terms order support open signatures bindings instance declarations 
constructs sense arbitrary records 
allowing open leads unsoundness reason section 
allowing instance example may lists hsi declarations record length forall list int bool open exists instance eqlist eq eq list declare record containing functions calculate test representation list length 
instance declaration named eqlist may reconciled de nition 
declarations matching bindings lists hs open length xs map xs xs case xs nil cons xs xs false instance eqlist 
haskell existing module system allows top level term type bindings hidden 
system supports similar mechanism brevity consider 
working details section complete exposition describing existentials interact recursion type classes 
recursive types lazy language haskell allows top level de nitions arbitrarily mutually recursive 
section consider mutual recursion interacts type abstraction mechanism 
consider recursive top level de nitions record pair fst snd pair int bool pair fst snd snd pair int bool pair fst fst snd true declarations leads local instance declarations profound change haskell type class system 
wish hide implementation types int bool 
course example easy collapse recursion single term open xy exists 
pair pair open xy pair fst snd snd pair fst fst snd true xy fst xy xy snd xy may awkward practice impossible de ned separate compilation units 
better solution allow type dereferences mutually recursive open exists pair pair fst snd snd open exists pair pair fst fst snd true notice type level recursion 

exactly mirrors term level recursion furthermore de ned separate implementation les signatures visible compiler respective interface les 
mutually recursive bindings may type checked isolation 
little restrictive type level recursion term level recursion 
example bindings rejected undefined undefined 
undefined undefined error undefined cyclically defined type pair pair pair pair pair pair fst pair snd snd pair fst error pair defined type annotated usual way undefined forall undefined undefined pair forall pair pair pair fst pair snd snd pair fst bindings accepted undefined pair rejected 
roughly speaking mutually recursive resulting values fully de ned similarly types 
undefined pair contain unde ned elements types positions remain undetermined 
deal typecheck recursive binding group phases illustrate example 
rst phase existentially quanti ed type variables opened de nitions producing environment gives types pair pair skolem types introduced instantiate respectively 
phase types rewritten avoid type dereference type variable projection eld projection 
furthermore relative types rewritten canonical absolute form 
normal order call name evaluation strategy accept recursively de ned types possible 
type form 
rewritten type environment care taken detect cycles 
example rewrite type follows pair pair pair pair rewriting environment pair pair perform standard kind inference types new environment haskell reduces type inference simply typed lambda calculus 
carry standard type inference righthand side binding type environment computed earlier phases 
haskell type inference involves weak form higher kinded kind preserving uni cation 
relative types normalized absolute form equality theory types free 
pair fst snd snd pair int pair fst fst snd true pair bool lastly check right hand side claimed existentially quanti ed type pair fst snd snd exists pair pair fst fst snd true exists pair notice course rewrite original existential type signatures just phase obtain claimed types 
consequence rewriting types phase kind inference phase system admits dubious looking type annotations 
example record pair fst snd strange pair int int pair strange phase type annotation strange rewritten pair int int pair 
pair int pair int kind inference nds 
perform kind inference rewriting augmenting kind system record kinds additional complexity justi ed 
confusing types harmless 
exposition applies recursive bindings 
di erence ensure skolemized type variables escape scope term 
ensure type inference remains complete presence recursive bindings require letrec bound variables type annotated single letrec bound variable opened 
type classes existentials far existential quanti cation hide type parameter open intset exists set int exploiting haskell type class system selectively expose information types 
example expose functor open intset exists functor set int intset signature intset interfaces sets integers 
rst explicit interface simply elds set reached projection intset 
second implicit interface provided overloaded operators class functor 
operations may directly 
example term type int intset fmap intset add intset empty notice overloaded operator functor class fmap forall functor type checking binding intset system checks functor satis able extends known constraint context functor skolemized type corresponding signature intset 
function fmap may instantiated type int int int int 
haskell instance declaration allows programmer new data type instance class 
example data age int instance eq age open mechanism introduces new data type skolemized type constant sense allow instance class 
example open exists 
bool int int bool instance eq arg recall arg projects argument type function type 
allow class declarations appear record declarations 
mentioned section allow instance declarations appear top level module implementations 
related system draws separate systems 
firstly jones parameterised signatures took idea heart module implementation just record module interface just record type polymorphic elds parameterised types 
problems type abstraction type sharing trivial ordinary existential quanti cation hide types ordinary parametric polymorphism capture type sharing 
approach avoided need dependent types automatically respected phase distinction types terms 
simplify matters disallowed anonymous records type equality record types system nominal 
secondly adopted annotations type system odersky allow higher ranked polymorphic types conjunction type inference types :10.1.1.27.5598
particular system allowed write existential quanti ers result type functions write haskell functions mimic ml functors 
system allowed share eld names polymorphic type records complicating type inference 
little care taken extend system support haskell constrained polymorphism 
existing haskell implementations support rank polymorphism 
extension odersky system seen natural generalisation existing type inference algorithm arbitrary ranked polymorphism 
possibility abandon hindley damas type inference preference local type inference 
felt great change haskell 
thirdly examined russo semantics ml signatures structures order understand dot notation ml modules interacts ordinary existential universal polymorphism 
result re ned haskell construct able optionally open existentially quanti ed type scope 
new construct possible access records existential type dot notation turn allowed records type compilation units 
re nement place may view research agenda re ning haskell expressive ml language semantic objects argue convenient programming ml module language directly 
borrowed notation turns underlying type theoretic machinery odersky zenger nested types 
notation allowed type annotations capture type sharing types refering type term variables scope 
aspect system probably unusual 
tried re nements orthogonal possible 
say proposal add monolithic module language haskell re ne haskell core language number features taken capture desired expressiveness 
biggest de ciency system programs subject non local changes making previously concrete types 
record types changed parameterise types uses record types similarly changed encode appropriate propagation type information 
long justi cation move dependent sum module systems 
ort date invested experimenting prototype compiler invaluable design tool 
hope transfer ideas ghc industrial strength haskell compiler months 
time writing just begun establish usual soundness completeness properties 
begun explore extension system method constraints believe provides expressive framework interface oriented programming 
approach interface subtyping object oriented programming emulated constraint entailment method constraints virtual method dispatch oop emulated terms existential type capturing methods interface 
claudio russo martin odersky fool reviewers helpful comments :10.1.1.27.5598
crary harper dreyer 
type system higher order modules 
appear popl sept 
harper lillibridge 
type theoretic approach higher order modules sharing 
proceedings annual acm symposium principles programming languages portland oregon pages portland oregon jan :10.1.1.27.5598
harper mitchell moggi 
higher order modules phase distinction 
proceedings seventeenth annual acm symposium principles programming languages pages 
jones 
system constructor classes overloading implicit higher order polymorphism 
proceedings acm sigplan conference functional programming languages computer architecture fpca copenhagen denmark 
jones 
quali ed types theory practice 
distinguished dissertations computer science 
cambridge university press 
jones 
parameterized signatures express modular structure 
proceedings rd annual acm sigplan sigact symposium principles programming languages st petersburg beach florida pages 
acm press jan 
leroy 
manifest types modules separate compilation 
proceedings annual acm symposium principles programming languages portland oregon pages :10.1.1.27.5598
acm press jan 
leroy 
applicative functors fully transparent higher order modules 
proceedings nd annual acm sigplan sigact symposium principles programming languages popl san francisco california pages 
acm press jan 
macqueen 
dependent types express modular structure 
proceedings th acm symposium principles programming languages st petersburg ussr pages jan 
milner tofte harper macqueen 
de nition standard ml revised 
mit press oct 
mitchell plotkin 
types existential type 
acm transactions programming languages systems july 
odersky :10.1.1.27.5598
putting type annotations 
proceedings rd annual acm sigplan sigact symposium principles programming languages st petersburg beach florida pages 
acm press jan 
odersky zenger 
nested types 
proceeding workshop foundations object oriented languages fool london uk jan 
odersky zenger zenger 
colored local type inference 
proceedings th annual acm sigplan sigact symposium principles programming languages popl london england pages 
acm press jan 
pierce turner 
local type inference 
proceedings th annual acm symposium principles programming languages san diego california pages 
acm press jan 
russo 
types modules 
phd thesis department computer science university edinburgh june 
russo 
class structures standard ml 
nordic journal computing 
russo 
recursive structures standard ml 
proceedings sixth acm sigplan international conference functional programming icfp firenze italy pages sept 
shields peyton jones 
object oriented style overloading haskell 
workshop multi language infrastructure interoperability babel firenze italy sept 
type checking section gives brief overview type checking idealized haskell extensions 
er proofs correctness proper account preparation 
presents syntax 
common module systems represent names pair written base name stamp way possible alpha convert binder changing base name signi cant projecting types elds 
assume stamps source program names 
avoid stamps class term variable instance names type substitution capture names 
retain uniformity 
constructs marked top level may appear record declaration bodies record term bodies outermost level program 
assume program set record type declarations corresponding imported interfaces single record term corresponding implementation compiled 
practice type var names type names instance names class names term var names integers stamps kinds type types int type schemes forall 
exists 
primitive constraints constraint scheme forall 
record decl bodies record 
top level open top level class 
top level instance record constructor class constructor terms opt opt opt free 
record 
record bodies opt top level instance type var contexts 

type contexts record opt 
class opt constraint contexts programs prog record syntax elements reside separate le 
preserve soundness system reject record declaration shadows top level interface name 
allow shadowing contexts 
type contexts ranged map type variables record int type 
int type 
type 
type 
type 
type 

record opt type 
opt type 
type 

si 

si record type 
type 

si type 
type 
kinded types names class names term variables kinds record bodies class bodies type schemes respectively 
constructs separate name space 
kind contexts ranged 
map type variables kinds 
dom denote domain type context kind context record type declaration body 
presents rules simultaneously kind check rewrite type 
types form expanded types denote 
furthermore relative types rewritten absolute types 
achieved recording record class declaration scope optional type pre denoting scope declaration introduced 
relative record class type looked environment replaced absolute type 
example declaration record record 
int relative type int rewritten absolute type int pre declaration type note record declarations body program prog pre contained record declaration 
write pre types opt write 
denote absent pre presents supporting rules resolving type record 
components derived substitution record type arguments actual values type kind context record arguments record type declaration body suitably instantiated 
type record built record returned possible 
example record int bool 
int 
bool type type int bool analogue primitive constraints allows primitive constraint resolved class 
components derived superclass context class declaration kind context class arguments class body type suitably instantiated 
figures extends kind checking rules primitive constraints type schemes obvious way 
gures formalize kind checking record type declaration bodies 
little involved combination recursive record bodies type skolemization opened signatures 
gives rules collecting skolemized type variables record body 
result set type variables rewritten body variable signature augmented external type signature write braces 
ordinary variables external type signature identical supplied internal type signature 
opened variables external type signature copy supplied signature outermost existential quanti ers removed 
example signature open exists forall rewritten signature open exists forall 
si int hid 
arg 
res 
arg type res type 
tn 
type tn type record opt dom dom dom 


si 
si 
si 



si record dom dom dom 


si 

record corresponding type forall assuming type variables fresh 
shows extract type context constraint context corresponding record body 
judgement parameterised type pre representing record body scope de nition 
type context collects just declarations record body notice external signature variable declarations signi cant forming type contexts 
record type pre record body nested record class declaration relative types may rewritten absolute types see 
constraint context col 
dom class opt 


dom class 

class corresponding primitive constraint 
constraint class opt 
opt constraint 
class type 

constraint kinded primitive constraints instance declarations constraints appearing underneath existentially quanti ed type variables opened signatures 
assigned arbitrary fresh names function named reasons soon clear instance declarations added constraint context name combines instance declaration name pre scope de nition 
assume injective function type pre instance name composite instance name 
example 
extends kind checking judgments record bodies rewritten rules 
record bodies mutually recursive types may de term variable scope kind checking nested record body rst extend type context de nitions record body suitably alpha converted 
may turn attention type checking 
presents constraint entailment class constraints entirely standard 
rules deciding type scheme subsumption 
extend system handle existential types constraints :10.1.1.27.5598
presents rules expand record constructors scheme dom :10.1.1.27.5598
dom fv dom 
constraint scheme forall exists 
forall exists 
scheme scheme scheme scheme type scheme kinded type schemes 

skolem dom 
dom 


skolem 


skolem record 



record 
skolem dom 
dom 


skolem open exists 


open exists 
skolem 

skolem opt 

opt skolem 

skolem class 


class 
skolem 

skolem instance 

instance skolem 
skolem opened type schemes class constructors types denoting particular record class 
necessary record class constructors terms elide type arguments 
course type inference system infers types 
figures type checking rules 
com opt fv opt opt opt opt record opt opt opt opt hx named opt opt class 
opt 
opt opt instance opt opt extracting type constraint context record body mon generalise type nearly sub term contrast hindley damas milner systems bound terms need generalised :10.1.1.27.5598
accomplished judgement form 
binding construct shadows variables scope name 
rules record function reset stamps context corresponding record declaration body extend current context 
record bodies kind checking re ected terms continue names default stamp 
types type context absolute prevent shadowing top level module names sound shadow type declarations simple minded way 
rule project external signature projected variable determine expression type 
record bodies type checked rules 
assume record bodies permuted match record declaration bodies 
checking instance bindings instance declarations somewhat involved ensure supplied term appropriate type superclass context instance declaration class may satis ed 
check requires instance declaration construction temporarily removed known constraint context 
reason form composite name instance declaration 
example assume class declaration opt 
record dom opt dom dom opt 
record opt record 
record record 
scheme constraint 
scheme opt 
record opt opt 
opt record dom constraint type 
opt 
record opt class 
class record dom 
dom constraint constraint opt 
record opt instance forall 

instance forall 
record 
record kinded record declaration bodies 
forall dom 

constraint entailment class int dom 

forall dom named exists dom named forall dom 

exists type subsumption instance declaration instance forall instance binding instance furthermore assume type forall check matches instance declaration ii type compatible corresponding class declaration iii superclass constraints class satis able 
known constraint context 
little possible accomplish tests checking nw forall 
forall int notice constraint added type scheme check iii 
subsumption test succeeds 
record opt 
opt 

si record 

class opt 
forall opt dom 

si class 
forall expanding record class constructors contains constraint form forall didn remove subsumption test succeed contains constraint form forall forall forall avoid circularity problem temporarily remove instance declaration trying type check known constraint context :10.1.1.27.5598
shows type check entire program 
rst split program record type declaration body single term 
record declaration body skolemized kind checked result construct initial type context 
term type checked assuming interface variable type scope 
term correspond implementation require appropriate record type 
brevity formalized aspects system 
firstly detect cyclic types 
easily achieved keeping track times variable dereferenced rewriting dom 
dom 
constraint named 
gen forall 

int int var type nx abs scheme nx app tup nx nx 
scheme nx typed terms part type 
secondly prevent top level interface names shadowed disallow explicit construction record top level interface constructor module record 
illegal 
illegal formalized top level types 
handled augmenting interface local type declarations implementation 
top level types named interface simply overwritten concrete declaration implementation 
subtlety checking type declarations equal kinds 
type inference system formalized haskell program available www cse ogi edu mbs 
easily familiar presentation set inductive relations 
exists 
dom 
dom named nx 
scheme open exists 
dom 
dom constraint 

scheme exists 
named nx 
scheme open 
scheme dom 
free free 

si record 
si opt project 
class dom dom 
dom 

skolem 



record record 
scheme record 
typed terms part opt opt opt record 
opt opt class 
opt opt opt opt dom 
forall forall dom 

forall 
opt opt opt instance instance forall opt typed record bodies prog toplevel record 

skolem 



record 
record toplevel formed programs 
