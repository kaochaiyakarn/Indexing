completeness theorems abadi rogaway language encrypted expressions daniele micciancio bogdan warinschi department computer science engineering university california san diego gilman drive ca daniele bogdan cs ucsd edu show abadi rogaway logic indistinguishability cryptographic expressions complete giving natural example secure encryption function pair expressions distributions associated expressions computationally indistinguishable equality proved logic 
introduce new property encryption schemes called confusion freeness show abadi rogaway logic extension due sound complete encryption scheme confusion free 
prove confusion freeness consequence natural security property authenticated encryption 
addition consider refinement logic overcomes certain limitations original proposal allowing encryption functions hide length message sent 
soundness theorem abadi rogaway completeness result authenticated encryption easily extend realistic notion secrecy 
decades logic computational complexity communities developed related quite different approaches theoretical modeling security 
approach benefits shortcomings 
hand logic approach usually formal language primarily intended task writing verifying cryptographic protocols manageable 
approach criticized cryptographers clear semantics language captures right intuition cryptographic security 
hand formalizing clarifying meaning common security notions secrecy authenticity primary goals major achievements complexity approach cryptography 
stronger comprehensive adversarial model approach gained wide acceptance cryptographic community providing right notion security 
relatively unstructured way security formalized framework proving security moderately complex protocols quite formidable task 
attempts bridge gap worlds 
approaches retain simplicity original logic formulations capture complexity theoretic notion security full power 
context logic introduced abadi rogaway deserves special attention 
logic allows reasoning elements simple language exp expressions built basic messages cryptographic keys pairing encryption operations 
example expression exp denotes encryption key style community elements exp assigned different interpretations 
hand expression research supported part nsf career award ccr fact specific formalisms subject debate formal methods community consensus specific formalism best captures desired security notions 
associated pattern intuitively captures information eavesdropper legitimately obtain seeing expression prior knowledge key 
example pattern denotes string 
hand expression naturally associated probability distribution bit strings strings obtained applying key generation encryption algorithms corresponding concrete cryptosystem 
main result show certain standard security requirements cryptosystem expressions pattern naturally associated distributions computationally indistinguishable 
words equivalence expressions proved logic corresponding distributions guaranteed equivalent standard computational interpretation 
cryptographic language clearly limited allows modeling simplest protocols party sends sequence complex messages 
nice example simple language clean semantics sound standard notion security complexity cryptography 
result important step languages model complex cryptographic protocols 
basic framework extended complex protocols parties interact encrypting decrypting sending messages :10.1.1.29.1076
techniques similar execution protocol represented abstractly set patterns corresponding message sent received party :10.1.1.29.1076:10.1.1.29.1076
computational task faced adversary actual messages sent received execution protocol try gain additional knowledge legitimate information revealed patterns 
notice adversary acts passive observer adversary alter control flow protocol change messages inject messages communication network 
take closer look semantics consider completeness issue probability distributions associated expressions indistinguishable true expressions pattern :10.1.1.29.1076
words ask pattern associated expression fully characterizes information recoverable adversary possible expressions equivalent computational setting equivalence proved abadi rogaway pattern semantics 
simplicity focus basic framework show results easily extended arbitrary protocols considered see section :10.1.1.29.1076:10.1.1.29.1076
abadi rogaway give example illustrate semantics complete 
example relies pathological situation easily avoided 
specifically considers encryption functions hide information input including length 
easy see strong notion secrecy achieved priori bound put length input 
case encryption messages different patterns lie outside restricted message space lead probability distribution invalid message 
consider general purpose encryption schemes schemes encrypt arbitrary messages require encryption function applied messages prescribed range example breaks leaving question completeness open 
show abadi rogaway semantics complete general purpose encryption schemes constraint messages encrypted belong message space 
consider completeness theorem proved assumption encryption function satisfies stronger notion security considered 
consider authenticated encryption encryption schemes providing secrecy message integrity 
stronger natural relatively standard notion security subject research papers cryptographic community :10.1.1.106.5488
interestingly show authenticated encryption abadi rogaway pattern semantics sound complete 
fact assume encryption scheme satisfies confusion freeness property independently defined implied definition authenticated encryption informally states attempting decrypt ciphertext randomly independently chosen key fail negligible probability :10.1.1.29.1076:10.1.1.29.1076
suggestion extend pattern semantics deal encryption schemes hide length message observe soundness completeness results hold realistic encryption schemes 
kind technique prove completeness result quite general illustrate sketching extension result complex logic :10.1.1.29.1076
rest organized follows 
section give background compu tational approach cryptography 
section review logic encrypted expressions 
incompleteness logic demonstrated section means natural counterexample considered 
section prove completeness result appropriate assumptions encryption scheme 
main technical contribution 
sections sketch extensions results 
section extend pattern semantics deal encryption schemes hide length message observe soundness completeness results hold realistic encryption schemes 
section show techniques easily extended complex logic yielding similar completeness result :10.1.1.29.1076
section concludes discussion possible extensions results open problems 
preliminaries section recall terminology concepts complexity approach cryptography 
notions relatively standard possibly terminology security levels encryption section safely skipped reader familiar modern cryptography 
subject reader referred 
computational setting notion efficient computation identified polynomial time computability 
formally function say bit strings bit strings efficiently computable exists turing machine polynomial input halts steps output 
cryptographic applications interesting consider randomized algorithms succeed probability 
running times probabilities usually measured function security parameter cryptographic functions arbitrarily hard break appropriately choosing value 
implicitly assumed size inputs algorithms bounded polynomial function security parameter 
definition function negligible polynomial exists definition negligible function naturally corresponds identification efficient computation polynomial time 
particular experiment succeeds negligible probability repeating experiment polynomial number times fail negligible probability 
say event overwhelming probability happens probability negligible function 
probability ensemble sequence probability distributions indexed security parameter 
usually probability distribution set poly binary strings length polynomial security parameter 
notion plays fundamental role complexity approach cryptography computational indistinguishability 
definition probability ensembles computationally indistinguishable probabilistic polynomial time computable predicate negligible function 
pr pr encryption scheme triple possibly probabilistic algorithms key generation algorithm input security parameter outputs randomly chosen key domain key 
encryption algorithm takes input key plaintext outputs ciphertext ek 
decryption algorithm takes input key string outputs underlying plaintext dk decryption succeeds 
encryption scheme satisfy standard correctness requirement key message dk ek informally encryption scheme secure ek hides partial information message possibly length 
stronger requirement simply asking computing ek hard important practical scenarios example message comes small message space adversary priori knowledge message message form password day 

reason encryption schemes usually required hide length message arbitrarily long messages requires arbitrarily long ciphertexts represented 
way hide length message put absolute bound length allowable message equivalently restricting message space finite set ciphertexts length messages 
intuition encryption scheme hide partial information messages possibly length captured requiring messages length distribution ensembles ek ek computationally indistinguishable 
security parameter probability distributions defined choice key randomness encryption algorithm 
fact computational indistinguishability equivalence relation equivalently require message ensemble ek computationally indistinguishable ek denotes standard message zeros message length definition usually described terms adversary trying break scheme key chosen uniformly random running key generation algorithm adversary knowing key chooses message having adversary choose corresponds universal quantification message 
ciphertext drawn random distribution ek ek 
adversary considered successful correctly guesses distribution select ciphertext 
say output ek ek 
clearly adversary succeeds probability outputting uniformly random guess 
advantage adversary defined probability succeeds minus 
replacing probability outputs input encryption minus probability opposite event simple calculations show advantage equal pr ek pr ek adversary advantage negligible distributions ek ek computationally indistinguishable 
shown standard techniques see allowing adversary submit polynomially messages receive encryptions encryption single definition stronger 
formally consider adversary oracle access possible encryption procedures ek input outputs independently randomly chosen encryption message second ek replaces input message length consisting zeros returns encryption message 
denote ao result running oracle access encryption scheme secure probabilistic polynomial time adversary advantage pr ek pr ek negligible function security parameter 
probabilities computed random choice key randomness adversary encryption oracles 
basic notion security introduced known equivalent formulations indistinguishability semantic security chosen plaintext attack 
chosen plaintext attack refers fact adversary allowed see ciphertexts messages choice 
abadi rogaway consider possible variants definition described 
specifically consider encryption schemes hide length message fixed finite message space hide different ciphertexts obtained different keys 
stronger notions captured modifying experiment follows 
encryption schemes hide length message oracle ek replaced oracle ignores input message completely outputs encryption standard message ek fixed length 
hiding key encrypt multiple messages captured replacing oracle ek pair oracles ek ek encrypt input independently chosen keys oracle ek replaced identical oracles ek ek encrypt standard message respect random key possibly different randomness course 
possible combinations security requirements considered labeled numbers type security corresponding scheme hides information including length message key encrypt 
notion security focuses 
completeness repeat formal definition 
definition type secure encryption encryption scheme type secure polynomial time algorithm access encryption oracles quantity adv pr ek pr ek ek negligible function 
abadi rogaway logic section recall main ideas abadi rogaway logic 
syntax logic allows reasoning expressions language exp defined follows 
consider fixed finite set block symbols block represents fixed data set 
slight generalization language basic data set bool contains symbols representing bits 
imagine example block contains symbols bit sequences fixed length consider fixed set key symbols denoted keys 
denote elements key 
elements exp built keys block pairing encryption operations 
formally exp language generated grammar key keys block block pair encryption keys possible interpretations associated elements exp called formal semantics pattern 
second called computational semantics distribution ensemble bit strings 
formal computational semantics formal semantics 
formal semantics defined spirit formal methods community purely syntactical 
associates expression exp element pattern pattern language generated grammar extends special symbol denote messages key keys block block pair encryption keys undecryptable computing pattern attached expression done steps 
step compute set keys denoted recoverable 
intuitively set contains keys computed adversary seeing contains keys sent clear keys obtained decrypting messages keys sent clear 
different formal definitions possible function recoverable 
sequel iterative formulation useful proving completeness result 
second step keys recoverable decrypt subexpressions possible 
start giving recursive definition key recovery function fkr input exp keys returns set keys recoverable decryption keys definition obvious 
example equation says key set keys recovered keys equal set keys recovered directly set keys 
similarly equation says keys recoverable known 
define recoverable set keys recoverable expression fixed point function fkr respect set inclusion ordering relation 
algorithmically set easily obtained follows 
expression inductively define sets gi set keys recovered applications key recovery function starting keys 
recoverable gi 
notice 
gi 
gi subsets key symbols appearing sufficiently large equality gi gi holds 
upper bound number distinct key symbols appearing size expression recoverable gi 

fkr 
fkr 
fkr fkr fkr 
fkr 
fkr fkr gi fkr gi recoverable gi definition set keys recoverable example 
fkr fkr recoverable 
assume adversary possession set keys keys 
adversary view expression exp described pattern pattern defined inductively keys block exp pattern associated expression naturally defined pattern recoverable expressions exp equivalent denoted pattern pattern 
note equivalence identify expressions differ names represent keys 
fact key names significant captured equivalence renaming relation denoted defined follows exists injection keys keys result applying keys computational semantics 
fixed encryption scheme security parameter see section expression exp defines natural probability distribution strings 
distribution denoted obtained follows 
key symbols appear expression assigned key values key generation algorithm 
key value assigned identical key symbols different symbols assigned independent executions 
denote key value associated keys refer key assignment underlying 
rest definition recursive 
basic block block mapped fixed bit string bit string corresponding pair obtained bit strings corresponding respectively image formal encryption obtained running encryption algorithm bit string recursively associated key independent uniformly random coin tosses 
specific way expressions encoded bit strings application dependent particularly important 
relevant property encoding function unambiguous type expression determined bit string context occurs bit strings corresponding component subexpressions unambiguously recovered 
example considers representation expressions mapped bit strings consisting encoding subexpressions followed type tag representing basic types block key pair ciphertext 
special delimiter symbols appropriate pairs encoded special delimiters mark subexpression second 
alternatively prefix free encoding subexpressions followed type tag making delimiter symbols unnecessary 
unambiguity property play fundamental role soundness result essential achieving completeness result 
specific way property achieved important 
example type expression inferred context expression occurs explicitly included type tag actual bit representation 
consider example protocol party sends party fixed length data block identifying protocol type followed encryption ek pair actual message repeated twice sort redundancy check 
case type tags delimiters sorts required party simply reads data block identifying repeat encrypt protocol applies decryption algorithm key possibly specified data block remaining portion message recover 
point checks cleartext length half equals second part 
rest assume type arguments expression recovered bit string representation write tag denote representation expression type tag tag explicitly included actual bit string 
computational semantics distribution ensemble distribution strings security parameter 
expressions equivalent computational semantics associated distribution ensembles computationally indistinguishable defined section 
soundness result main result relation formal computational semantics described 
relation holds acyclic expressions encryption schemes type secure see section definition type security 
recall definition acyclicity 
say encrypts exists expression subexpression occurs possibly encryption key 
defines binary relation keys encrypts relation 
say acyclic expression associated encrypts relation contain cycles sequence keys 
kl ki encrypts ki 
kl 
example ek ek ek ek ek ek ek ek acyclic ek ek ek contains cycle 
encryption functions cyclic expressions referred circular encryption typically regarded bad security practice cryptographic community standard cryptographic definition security encryption schemes requires key chosen randomly independently message encrypted 
soundness theorem 
theorem abadi rogaway acyclic expressions type secure encryption scheme 
suppose 
logic incomplete general encryption important question briefly addressed regards exact power formal approach 
case indistinguishable ensembles associated different expressions expressions proved equivalent logic 
words converse theorem true 
authors provide simple counterexample 
consider encryption scheme limited plaintext space expressions representing encryption known key messages bit representation lies outside plaintext space 
messages different expressions mapped different patterns 
messages encrypted running encryption algorithm produce distribution error message specifying input range 
section provide natural counterexample avoids pathological situation described 
exhibit secure encryption scheme expressions different patterns computational interpretation inputs encryption function belong prescribed message space 
consider bit string representations explicit type tags 
case define specific encryption scheme possibly limited message space satisfies standard notion security considered exhibits corresponding counterexample demonstrate logic complete 
cases examples involve application encryption function messages outside prescribed range 
untagged representation 
fi pseudorandom function family fi define encryption scheme plaintext space follows 
key generation algorithm input picks uniformly random element selects random function family encryption key fk freshly generated randomness denotes string concatenation denotes bitwise exclusive operation simplify notation sequel omit parenthesis assume higher precedence 
plaintext corresponding ciphertext recovered fk reader easily verify key message dk ek scheme known type secure assumption function family fii pseudorandom 
consider expressions 
distributions patterns pattern pattern equivalent renaming 
words expressions equivalent logic 
consider probability distributions associated expressions security parameter 
distributions fk fk uniformly independently distributed claim distributions identical 
bit string associated expression consists random concatenated fk followed key 
initial randomness trailing key independent uniformly random 
middle expression fk distributed uniformly random exclusive fixed value fk independent uniformly distributed key 
similar reasoning shows probability distribution associated second expression completely random 
particular distributions identical despite fact expressions equivalent logic 
discrepancy formal computational semantics informally explained follows 
formal semantics implicitly assumed decrypting succeeds decryption key informally family function pseudorandom random element family look truly random function computationally bounded observer 
formal definition considers adversary oracle access function decide function belongs family 
probability accepting function chosen random family negligible terms access completely random function domain codomain performs decryption aware success failure 
similar assumption hold general encryption schemes constructed holding key help telling apart encryptions encryptions 
note type tags case counterexample breaks image key symbol form key decrypting encryption plaintext wrong key detected checking tag 
construction shows principle type tags solution problem encryption schemes limited message space 
tagged representations 
encryption scheme defined construct new encryption scheme plaintext space equal key security parameter 
key generation algorithm encryption plaintext key key ek key tag ignored encryption function applied 
decryption ciphertext dk key ciphertext decrypted resulting plaintext tagged tag key output 
easy check correct type secure encryption scheme messages encrypted 
consider expressions counterexample 
security parameter associated distributions fk ciphertext key fk ciphertext key uniformly independently distributed equal 
logic complete authenticated encryption section provided counterexample shows type security sufficient achieve completeness abadi rogaway logic 
counterexample suggests case general possible determine ciphertext created key develop idea show encryption scheme satisfies certain condition called confusion freeness abadi rogaway logic complete 
show confusion freeness implied standard security requirement encryption schemes authenticity :10.1.1.106.5488
confusion free encryption authenticated encryption confusion free property informally described follows 
asks encryption scheme keys generated independently random decrypting key ciphertexts produced key fails possibly negligible probability 
note similar notion confusion freeness independently defined :10.1.1.29.1076:10.1.1.29.1076
definition confusion freeness dl finite set distributions ensembles symmetric encryption scheme indexed security parameter 
say confusion free respect iff exists negligible function pr di dk ek say confusion free confusion free respect finite set distribution ensembles 
equivalently defined confusion freeness respect single distribution ensemble 
gave definition involving sequence distributions order simplify presentation proof completeness result 
anticipate proofs typically instantiated el el subexpressions exp security parameter encryption scheme 
case refer function associated expression concept authenticated encryption received quite lot attention 
fundamental goal authenticity communication informally stated follows polynomial time adversary able produce valid ciphertext ciphertext decrypted seeing polynomially encryptions messages choice negligible probability 
different flavors authenticity possible concentrate specific definition integrity plaintext int security terminology defined 
definition secure authenticated encryption scheme symmetric encryption scheme 
adversary authenticity property polynomial time algorithm access encryption oracle ek allows see ciphertexts corresponding plaintexts choice adversary sends query oracle oracle answers ek time independent randomness encrypt message 
security authenticated encryption scheme defined experiment defined fixed security parameter generate random key instantiate encryption oracle ek 
adversary interact encryption oracle stops outputs attempted forgery say adversary wins produced forgery ciphertext dk valid ciphertext asked encryption oracle produce ciphertext dk 
encryption scheme authenticity property probability adversary wins taken coin tosses key generation algorithm coin tosses negligible function security parameter 
relation secure authenticated encryption schemes confusion freeness captured lemma 
lemma secure authenticated encryption scheme 
confusion free respect finite set polynomial time distributions 
proof secure authenticated encryption scheme dl set polynomial time distributions 
define adversary ai authenticity works follows 
ai access encryption oracle ek unknown randomly chosen key adversary ai invokes oracle 
simply generates random key ki running freshly generated coins selects random plaintext distribution di outputs eki attempted forgery 
valid ciphertext respect key dk forgery ai queried encryption oracle plaintext 
follows security success probability ai pr ai dk negligible function security parameter 
max 
easy see negligible function 
immediately follows definition ai 
confusion probability distribution ensemble di pr ki completeness theorem ki di dk eki 
main result converse theorem case encryption scheme secure authenticated just confusion free encryption scheme 
conjunction result prove fact weaker notion authenticity described definition 
notion described definition called authenticity chosen plaintext attack cpa regarded weakest useful notion cryptographic applications opposed authenticity chosen ciphertext attack cca adversary access encryption decryption oracle 
authenticity message attack weaker notion cpa adversary access oracle come valid ciphertext respect random unknown key 
theorem type secure authenticated encryption scheme generally type secure confusion free encryption scheme 
acyclic expressions direction soundness result 
prove part 
proof idea 
show bit string representation sample recover pattern high probability 
introduce functions correspond fkr recoverable operate bit strings expressions exp show overwhelming probability pattern recovered bit string equivalent renaming pattern recovered corresponding expression 
algorithm distinguishing distribution associated expressions different patterns easily constructed sample distributions compute pattern associated check equivalent pattern output output 
simple consequence discussion algorithm distinguish distributions overwhelming probability 
see proof section details 
recovering keys 
fixed expression random sample corresponding distribution underlying key assignment 
claim bit string recover set recoverable recoverable set key values assigned keys recoverable overwhelming probability 
define functions ckr string key key string key intention showing computational counterparts fkr recoverable respectively 
algorithm ckr takes input bit string set key values tt computes set key values simple case analysis type definition closely resembles fkr 
interesting case ciphertext 
case algorithm attempts decrypt keys tt decryption succeed keys tt output tt result decryption key tt algorithm outputs result recursive call ckr tt 
algorithm bit string input computes set key values recoverable definition closely follows definition recoverable 
iteratively computes increasing sequence key value sets ti ckr ti 
iteration stops ti ti 
proceed show functions fkr recoverable ckr related 
algorithm ckr tt block output tt key output tt pair output ckr tt ckr tt ciphertext exactly tt dk output ckr dk tt output tt algorithm cont true cont ti ckr ti ti ti cont false output ti algorithms ckr define computational counterparts functions fkr recoverable 
input algorithms sample precisely keys set key symbols show fkr ckr recoverable negligible probability 
formally captured lemmas 
lemma confusion free encryption scheme exp keys 
bit string selected distribution underlying key assignment pr ckr fkr negligible function 
proof negligible function associated expression defined 
prove statement lemma induction structure case consider sets fkr ckr compute probability statement lemma 
case analysis type probabilities taken random choice equivalently choice underlying key assignment 
block form block intended representation block follows definitions fkr ckr case fkr ckr fkr 
pr ckr fkr pr ckr fkr form key definitions fkr ckr follows fkr ckr fkr pr ckr fkr pr ckr fkr form pair ei ei 
notice conditional distributions equal distribution associated corresponding subexpressions distributions independent obtained random key assignment 
affect validity proof 
definition fkr ckr follows fkr fkr fkr ckr ckr ckr probabilities choices common key assignment inequalities pr ckr fkr pr ckr fkr ckr fkr pr ckr fkr pr ckr fkr induction hypothesis pr ckr fkr form ciphertext 
distinguish cases key 

definition fkr fkr definition ckr order set ckr different decrypting exactly key successful 
prevented security properties 
formally pr ckr fkr pr dk pr dk independently generated confusion freeness pr dk 
obtain pr ckr fkr 
definition fkr fkr fkr 
inequalities follow definition ckr probabilities taken choice equivalently choice pr ckr fkr pr ckr fkr ki dki pr ckr fkr ki dki pr ckr fkr pr dki ki secure authenticated scheme follows ki inequality pr dki holds 
induction hypothesis obtain pr ckr fkr lemma confusion free encryption scheme exp bit string selected distribution underlying key assignment negligible function 
pr recoverable proof negligible function associated defined 
prove induction statement lemma holds 
consider sets 
define recoverable gi fkr gi sets 
computed execution ti ckr ti 
denote ai event iteration ti gi 
note vacuously true 
pr ai pr ai ai pr ai ai pr ai pr ai ai pr ai replacing ai lemma obtain pr ti gi pr ckr ti fkr gi ti gi pr ti gi gi pr ti gi pr ti gi inequality proved arbitrary repeating obtain pr ti gi pr total number keys obviously bounded iteration algorithm recovers key stops 
pr ti gi immediately implies lemma pr recoverable pattern computation 
shown compute key values assigned keys recoverable non negligible probability 
step show associate computational counterpart function defined section 
consider function psp string key pattern shown 
input string set key values tt returns pattern 
algorithm uses arbitrary fixed naming function associates key value unique key name 
sort values tt lexicographic order assign symbols 
key values position sorted list 
assume easy recover block symbol bit string representation 
algorithm simple case analysis type nontrivial case ciphertext case algorithm attempts decrypt keys tt decryption succeed outputs 
decryption succeeds key due confusion freeness key probably compute ciphertext case algorithm proceeds recursively 
tt keys injective function algorithm psp tt block output block symbol corresponding key tt output pair output psp tt psp tt ciphertext exactly key tt dk output psp dk tt output computational counterpart pattern function lemma states syntactic function computational counterpart psp essentially behavior 
lemma confusion free encryption scheme exp keys set key symbols 
bit string selected distribution underlying key assignment pr psp negligible function 
proof prove statement lemma equal negligible function associated defined 
keys string key assignment underlying 
consider injective key renaming function naming function psp 
show result holds pr psp pair obtained applying renaming expression proof induction structure block bit string representation obtain pr psp pr psp pr keys key obtain pr psp pr pr exp pair ei ei 
equalities probabilities taken choice alternatively choices hold respect common key assignment 
pr psp pr psp psp induction hypothesis obtain pr psp pr psp pr psp ciphertext 
distinguish cases key set known keys 
obtain turn implies pr psp pr ki dki pr psp pr ki dki pr dki ki 
equalities hold pr psp pr psp ki dki pr psp ki dki pr psp pr ki dki pr psp pr dki ki inequality obtained induction hypothesis confusion freeness property 
immediately follows pr psp probability psp recoverable computed lemmas 
quantity negligible follows recover non negligible probability pattern psp 
prove main theorem 
corollary confusion free encryption scheme exp expressions pattern pattern 
bit string sampled distribution negligible function 
pr tt pattern psp tt pr tt pattern psp tt proof note equation immediate consequence equation 
pattern pattern pr tt pattern psp tt pr pattern psp tt remains show equation true 
seen follows function associated pr tt pattern psp tt pr tt recoverable pattern psp tt pr recoverable psp tt tt recoverable pr tt recoverable pr recoverable psp recoverable pr recoverable bound factor product lemma lemma respectively obtain pr tt pattern psp tt equation follows 
proof theorem expressions pattern pattern show exists algorithm non negligible advantage distinguishing 
propose distinguisher sample distributions security parameter 
compute pattern psp compare pattern 
done polynomial time simple unification algorithm 
equivalent renaming algorithm outputs outputs 
distinguishing power algorithm follows applying equations corollary 
precisely advantage algorithm distinguishing pr pr negligible expressions size polynomially bounded security parameter 
extension practical encryption schemes pattern semantics take account size encrypted messages 
example expressions pattern 
order achieve soundness encryption scheme satisfy impractical requirement ciphertexts hide length corresponding plaintexts 
section explore refinement abadi rogaway logic suggested deals length issue 
particular inequality expressions defined proved refined logic 
main idea replace pattern message family patterns order capture notion undecryptable message size 
obtain result consider uniform behavior encryption scheme respect length plaintext 
emphasize choice possibilities corresponds popular encryption schemes shortly explain 
assume encryption scheme views plaintext sequence basic message blocks ciphertext message block longer corresponding plaintext 
practical symmetric encryption schemes cbc ctr cipher block chaining counter mode see example satisfy property 
assume block symbols key symbols mapped bit strings size equal basic message block 
consider length function exp defined recursively definitions 
keys 
blocks 
exp 
applied formal expression returns size expression 
definition motivated discussion equation says size ciphertext block bigger size underlying plaintext 
equation straightforward interpretation 
patterns capture information regarding length plaintexts underlying undecryptable ciphertexts easily defined 
modify pattern semantics function section replacing equation case completeness entire definition repeated 
having patterns capture length related information allows relaxation hypothesis theorem 
theorem type secure authenticated encryption scheme generally type secure confusion free encryption scheme 
acyclic expressions proof proof theorem closely follows theorem 
sketch outline 
completeness result apply strategy show recover pattern sample 
fact proof unchanged pattern recovery algorithm 
change reflects modified pattern semantics replaced follows 
assumption type exists function input ciphertext returns block length underlying plaintext 
step case analysis input ciphertext decrypted output psp 
sequence lemmas theorem yield proof completeness 
soundness result recall hybrid argument proof important step show attach distribution pattern 
modified definition pattern semantics order take account length plaintexts needs changed 
modification straightforward distribution associated obtained running encryption algorithm fixed element block denotes identical copies block 
modification needed order transform proof proof soundness direction theorem 
eavesdropping adversaries section sketch results adapted extension abadi rogaway logic introduced :10.1.1.29.1076:10.1.1.29.1076
new framework allows description complex protocols involving finite set parties communicating synchronously elements exp network internal external channels channels 
external channels represent communication lines observed adversary 
internal channels perfectly secure communication lines example maintain state information represent interaction different parts program running single computer 
party potentially read messages channel write dedicated channel 
loss generality complex parties represented collection programs sharing input channels 
denote pc program writes channel protocol identified collection programs pc channels 
precise syntax language describe programs relevant simplicity omit 
intended execution model iteratively run programs infinite sequence time frames 
content channel time obtained running program pc content channels time assumed time channels contain data 
depending programs interpreted manipulating formal expressions actual bitstrings formal computational semantics associated protocol simplified versions formal computational semantics sufficient explaining extension 
formal semantics 
consider execution programs manipulate expressions exp time frame program defines channel configuration describing content channels time formally function channels exp initial configuration associates channel empty expression 
configurations defined inductively running programs pc channels 
configuration content channel output program pc evaluated expression defined 
way program defines infinite execution trace simple way look infinite sequence tuples expressions indexed channels 
straightforward lifting definition pattern traces yields measure information adversary obtains observing communication external channels 
specifically configuration define external configuration restriction channels 
execution prefix 
compute pattern pattern usual way define recoverable keys time tn recoverable applying key recovery function concatenation messages sent external channels steps computation keys tn compute pattern pattern tn tn 
tn 
infinite traces said equivalent denoted prefixes equal length yield equal patterns renaming 
informal interpretation definition systems said equivalent adversary tell apart observing finite partial executions 
simplicity include presentation key coin renaming mechanism ensures new keys represented different symbols different invocations programs pc 
definition alternative approach program single infinite trace associated equivalence defined terms infinite sequences :10.1.1.29.1076
equivalence relation induced protocols 
protocols said equivalent traces equivalent 
formally say iff 
subtle point important extension result 
syntax language allows describing protocols forward ciphertexts channel 
real executions adversary check equality ciphertexts bit bit comparison kind information captured formal semantics 
done replacing symbol abadi rogaway logic family symbols symbol represent randomness create ciphertext :10.1.1.29.1076
syntax language allow randomness create different ciphertexts occurrences trace represent identical ciphertexts 
computational semantics 
consider real execution protocol channels contain bitstrings keys obtained running key generator algorithm formal encryption instantiated actual encryption scheme 
fixed security parameter assume channels contains possibly empty bit string 
running programs pc channels defines probability distribution probability ensemble content channels distribution channel equal output distribution program pc new randomness new keys generated security parameter 
notice distributions associated different channels necessarily independent programs may share input channels 
starting empty channels configuration associate protocol infinite sequence probability ensembles 
denote probability ensemble describing content channels iterating programs times 
starting distribution associate empty string channel probability distribution obtained described 
denote probability ensemble restricted external channels computational equivalence protocols defined requiring finite executions protocols told apart observing external channel denotes 
completeness theorem 
soundness theorem relates semantics theorem abadi systems generate encryption cycles 
suppose type secure confusion free encryption scheme 
note hypothesis contains requirement confusion free encryption scheme 
necessary formalism explicitly uses decryption mechanism checking decryption done right key needed 
authors mention converse true proof :10.1.1.29.1076
explain techniques extended proof completeness holds 
basic intuition abadi rogaway setting sample distribution associated executing recover pattern corresponding ith prefix execution trace 
done adopting strategy section samples coming distributions associated channels opposed expressions 
show logic complete assume case ith prefixes different patterns 
details may technically involved proof conceptually simple 
implement key recovery algorithm needs little change needs adapted samples coming distributions associated executions simple expressions 
changes pattern function slightly involved 
issue needs detect undecryptable ciphertext duplicates see regarding formal semantics traces 
probabilities ensembles carefully defined order take care case certain keys random strings need value different time periods :10.1.1.29.1076
technically realized choice functions assign values keys random coins time period realized list ck rk ciphertext randomness pairs input pattern function ciphertext algorithm examines list check ci case algorithm outputs ri ciphertext seen 
adds pair rk list outputs rk remaining details straightforward left reader 
analyzed completeness abadi rogaway logic encrypted expressions considered various extensions basic logic 
particular considered logics allow model realistic encryption functions hide length message transmitted complex protocols distributed programs communicating synchronous network studied :10.1.1.29.1076:10.1.1.29.1076
logics sound complete encryption scheme implement protocols satisfies appropriate notion security 
indistinguishability confusion freeness 
words patterns associated programs logics equivalent efficient probabilistic polynomial time adversary distinguish messages transmitted protocol non negligible advantage 
cryptographic primitive considered symmetric encryption 
remarked results easily extended asymmetric public key encryption schemes 
possible extend results cryptographic primitives definition notion indistinguishability :10.1.1.29.1076
natural candidates pseudorandom generators pseudorandom functions 
extending results primitives simple operations messages exclusive strings string concatenation equality test interesting operations cryptographic primitives possible model interesting cryptographic protocols 
example encryption scheme described section expressed terms operations 
natural question simple logic approach studied extended cryptographic primitives collision resistant hashing message authentication codes digital signatures security defined terms indistinguishability distributions 
highlights believe main limitation approach logics capture passive attacks adversary intercepts messages exchanged parties participating protocol unable alter messages inject new messages network :10.1.1.29.1076
parties trusted follow protocol 
cryptographic primitives digital signatures hash functions complicated primitives zero knowledge proofs intended avoid message tampering deviations protocol 
study primitives interesting context messages sent network altered adversary parties may malicious 
designing formal methods reason general adversarial behaviors proved sound possibly complete respect standard computational security notions interesting open problem 
acknowledgments alexandra sasha useful discussions 
abadi :10.1.1.29.1076
formal eavesdropping computational interpretation 
kobayashi pierce editors proceedings fourth international symposium theoretical aspects computer software volume lncs pages sendai japan oct 
springer verlag 
abadi rogaway 
reconciling views cryptography computational soundness formal encryption 
journal cryptology 
bellare 
encryption redundancy provide authenticity 
advances cryptology eurocrypt volume lncs pages berlin germany 
springer verlag 
bellare desai pointcheval rogaway 
relations notions security publickey encryption schemes 
advances cryptology crypto volume lncs pages 
springer verlag 
bellare 
authenticated encryption relations notions analysis generic composition paradigm 
advances cryptology asiacrypt volume lecture notes computer science pages 
springer verlag 
gligor 
fast encryption authentication encryption authentication modes 
fast software encryption lncs 
springer verlag 
goldreich 
foundations cryptography basic tools 
cambridge university press 
goldwasser micali 
probabilistic encryption 
journal computer system science 
guttman thayer zuck 
faithfulness encryption 
proceedings th acm conference computer communication security 
jutla 
encryption modes free message integrity 
pfitzmann editor advances cryptology eurocrypt volume lncs 
springer verlag may 
krawczyk 
order encryption authentication protecting communication 
advances cryptology crypto volume lncs berlin germany 
springer verlag 
lincoln mitchell mitchell scedrov 
probabilistic poly time framework protocol analysis 
proceedings fifth acm conference computer communications security pages 
pfitzmann waidner 
cryptographic security reactive systems 
electronic notes theoretical computer science volume april 
rogaway bellare black krovetz 
block cipher mode operation efficient authenticated encryption 
acm editor acm conference computer communication security pages 
acm press 

