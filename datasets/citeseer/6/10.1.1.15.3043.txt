theoretical computer science inductive data type systems www elsevier com locate tcs frederic blanqui jean pierre jouannaud okada lri universite paris sud orsay france department philosophy keio university tokyo japan previous data type systems tcs authors combined language strongly normalizing algebraic rewrite system typed calculus enriched pattern matching de nitions certain format called general schema generalizes usual recursor de nitions natural numbers similar basic inductive types 
combined language shown strongly normalizing 
purpose reformulate extend general schema order easily extensible capture general class inductive types called strictly positive ease strong normalization proof resulting system 
result provides computation model combination algebraic speci cation language data types strongly typed functional language strictly positive inductive types 
elsevier science rights reserved 
keywords higher order rewriting strong normalization inductive types recursive de nitions typed lambda calculus 
step long term program aiming building formal speci cation languages integrating computations proofs single framework 
focus incorporating expressive notion equality typed calculus 
retrospect quest expressive language allowing specify prove mathematical properties software started system hand automath project hand 
coquand huet combined calculi resulting calculus constructions 
making impredicativity data structures encoded calculus encodings far complex non specialists 
di erent approach taken martin lof theory notion inductive de nition corresponding author 
tel fax 
mail address frederic blanqui lri fr blanqui 
see front matter elsevier science rights reserved 
pii blanqui theoretical computer science originating godel system 
coquand paulin mohring incorporated similar notion calculus constructions name inductive type 
despite legitimate success inductive types calculus inductive constructions easy programming language proofs 
main remaining problem equality 
current version calculus equality reductions recursor rules associated inductive types corresponding structural induction curry howard isomorphism de nitional rules constants primitive recursion higher type 
notion equality main practical drawbacks de nition functions painful user forcing user think operationally axiomatically necessary spell equational proofs short corresponding equality equationally speci ed calculus 
clear problem speci calculus inductive constructions 
shows versions type theory equality rst class concept example martin lof theory types 
solution proposed coquand calculus dependent types functions de ned pattern matching provided right hand side recursive calls structurally smaller left hand side call 
notion relies foundedness assumption satis ed practice 
concurrently pioneering works tannen tannen gallier okada authors proposed solution polymorphically typed calculus pattern matching functional de nitions called general schema 
generalized cover full calculus constructions 
coquand idea general schema control arguments right hand side recursive calls rule de nition checking smaller left hand sides ones time strict subterm ordering extended multiset lexicographic manner 
schema general subsume basic inductive types nat nat nat sense associated recursor rules instances general schema 
contrast coquand proposal subsume non basic inductive types ord ord ord lim nat ord constructor lim takes argument functional type nat ord 
hand multiset lexicographic extensions allows tailor comparisons practical needs making possible nested recursive calls important facility coquand ordering provide 
important note contrast de nitions allow non linear overlapping left hand sides price checking con uence computation critical pairs 
fact general schema covers limited portion possible inductive types calculus inductive constructions shows weakness functions de ned induction inductive types de ned schema 
purpose revisit general schema cover strictly positive inductive types 
solution essential blanqui theoretical computer science positivity condition required inductive types 
framework church simple theory types avoiding problem having equalities type level dependent types 
closing gap simple theory types calculus inductive constructions require generalizations general schema allowing dependent polymorphic inductive types 
strong normalization proof new calculus tait computability predicates method 
contrast structure proof quite modular owing novel formulation new version general schema 
left hand side de ne nite set possible righthand sides rule follows schema 
set right hand sides generated inductively computability preserving operations 
new de nition easily seen strictly stronger previous allows reason induction construction set possible right hand sides easily extensible 
feature prove useful extending calculus inductive constructions 
de ne language section new de nition general schema section 
normalization proof section 
section detail examples explain possible extension general schema order able prove 
conclude section important open problems 

inductive data type systems intuitively inductive data type system simply typed calculus base type equipped set constructors associated structural induction principle form godel primitive recursive rules higher type additional function symbols completely de ned appropriate higher order rewrite rules 
kind rules seen particular case resulting uniform formalism strong rewriting avor 
sequel assume reader familiar notions calculus term rewriting simply typed calculus term rewriting variants higher order rewriting existing literature 
rst introduce term language move de nition higherorder rewrite rules new formulation general schema 

language section introduce successively signature inductive types constructors function symbols set formed terms set computational rules 
blanqui theoretical computer science 
signature de nition types 
set elements called inductive types set types generated grammar rule ranges furthermore consider associates right written 
sets positive negative positions type inductively de ned follows pos pos pos pos pos pos pos pos say inductive type occurs positively type occur occurrence belongs pos 
said occur strictly positively sn occurs si 
notion positivity negativity associated type constructor similar logic respect implication operator expected curry howard isomorphism 
note occur positively occur occurs negative position example ord occurs positively nat ord occurs set positive positions pos 
fact occur strictly positively ord occur nat 
hand ord occur positively ord ord occurs negative position pos 
de nition constructors 
assume inductive type comes associated set constructor equipped type sn called arity denote set constructors arity assume sets pairwise disjoint 
constructor declarations de ne quasi ordering inductive type depends inductive type written ift occurs type constructor 
fact consider re exive transitive closure relation 
respectively equivalence strict ordering associated say equivalent de nition strictly positive inductive types 
inductive type said strictly positive occur occurs strictly positively types arguments constructors type equivalent occurs negative position types arguments constructors strictly positive type basic constructors functional arguments 
blanqui theoretical computer science assumption 
assume founded inductive types strictly positive 
spell strict positivity condition assume inductive type constructors cn ci si si ni si si si ni ti strictly positive ti occurs si type occurs negative position si basic ni examples type de nitions bool booleans nat natural numbers list nat lists natural numbers consider polymorphic types tree list tree mutually inductive types trees lists trees proc process expressions denotes deadlock sequencing choice operator dependent choice ord founded trees brouwer ordinals form formulas predicate calculus expressions built real numbers bool true bool false bool 
nat nat nat nat nil cons nat 
tree node tree 
nil cons tree 
proc proc proc proc proc proc proc proc data proc proc 
ord ord ord ord lim nat ord ord 
form form form form form form term form form cos ln types basic ord form strictly positive 
name constructors di erent types live 
sake simplicity continue practice overload names ambiguity disambiguate names nat 
inductive types inhabited expressions built constructors example represents logical formula xp 
general class inductive types positive inductive types 
inductive type said positive occurs positive positions types arguments constructors case mutually inductive types de ned similarly requiring type equivalent occurs positive positions types arguments constructors 
positivity condition ensures de ne sets objects induction structure elements inductive type implies monotonicity functional set objects xpoint 
class positive inductive types largest class consider framework simply typed calculus non positive type inhabited non terminating typed terms framework 
restrict strictly positive inductive types blanqui theoretical computer science calculus inductive constructions prove strong normalization property calculus assumption 
conjecture strong normalization holds non strictly positive case 
de nition function symbols 
non empty sequence sn sof types assume set fs sn function symbols containing constructors arity type sn symbol fs sn arity sn type 
denote set function symbols arity set function symbols 
assume quasi ordering called precedence associated strict ordering founded 
example may injection function nat ord 
lim represents rst limit ordinal limit nite sequence ordinals see de ne injection function calculus 

terms de nition terms 
family disjoint nite sets variables denoting union set untyped terms de ned grammar rule uu un ranges fn denotes abstraction function parameter body denotes application function term term form un said function headed constructor headed family sets terms type inductively de ned structure terms follows xs function symbol arity type sn un sn un denote set terms calculus 
type term unique type may notation indicate type note adopted presentation type checking rules 
reader easily extract rules de nition sets usual consider application associates left written 
sequence terms un denoted vector length consider denote term blanqui theoretical computer science empty sequence respective terms un xn 
dewey set pos term language alphabet strictly positive natural numbers 
subterm term position pos denoted term obtained replacing term written write subterm denote fv set free variables occurring term term variable occurs freely said linear term linear free variables linear 
substitution application written post notation domain set dom 
substitution naturally extended application replacing free variable image avoiding variable captures 
carried renaming bound variables necessary operation called conversion 
usual modulo conversion identifying terms di er bound variables 
furthermore assume free bound variables distinct bound variables distinct 
may notation denoting substitution associates ui xi 
computational rules language ingredients typed calculus set inductive types constructors set function symbols 
consequence kinds rules calculus rules coming calculus fv rules associated inductive types example natrec natrec natrec inductive type nat rules de ning function symbols example nat ord injection function nat ord 
immediately see recursor rules look rules de ning injection 
show section recursor rules strictly positive inductive types follow general schema de ned section recursor rules need singled technical developments 
blanqui theoretical computer science 
higher order rewriting de ne general schema precisely need introduce notion higher order rewriting 
notions higher order rewriting exist literature 
simplest possible term rewrites term rule matches left hand side equivalently instance substitution matching syntactic convertible instance contrast sophisticated notions higher order rewriting de ned klop combinatory reduction systems nipkow higher order rewrite systems van van higher order rewriting systems generalizing higher order pattern matching convertible instance de nition rewrite rules rewriting 
rewrite rule pair terms headed function symbol fv fv type 
set rewrite rules term ur rewrites term position pos rule written ru exists substitution de ning rules function symbol rules left hand side headed condition ensures reduction relation preserves types type ru property called subject reduction 
give classical examples de ning rst formal addition brouwer ordinals second functions lists 
rst example paradigmatic strictly positive types basic 
second example uses rule abstraction left hand side 
complex examples second kind section 
formal addition brouwer ordinals lim lim fn note rst rules just rst order ones special case higherorder rule 
important note need abstraction right hand side rule bind variable needed higher order variable taken left hand side 
termination proof set rules di cult task 
case termination property readily obtained showing rules follow improved de nition general schema 
di culty course simply delegated strong normalization proof schema 
blanqui theoretical computer science brouwer ordinals note suitable choice provides semantically correct ordinal notation correct notation formal de nition provides semantically correct ordinal addition 
functions overs lists append nil append cons cons append append append append append map nil nil map cons cons fx map map append append map map map note rst rules de ne concatenation append lists usual rst order rules 
rules de ne function map successively applies function elements list 
note third sixth rule matching function symbol append 

general schema proceed describe schema user de ned higher order rules follow 
particular examples higher order rules far satisfy schema 
inspired authors general schema formulation quite di erent 
new schema powerful answers problem left open ability capturing de nitions previously addition ordinals 
main property schema ensures termination property relation set rules general schema 
subject section 
function de nition case recursive call need way compare arguments recursive calls right hand side arguments left hand side prove strictly decrease ensure termination 
expect comparison ordering subterm ordering extension 
going introduce similar coquand notion structurally smaller allow deal de nitions addition ordinals 
comparison recursive call arguments left hand side arguments done lexicographic multiset manner combination thereof status function symbol de ned 
status user computed non deterministic linear time 
assume family xi variables 
blanqui theoretical computer science de nition status ordering 
status linear term stat lex ui form mul xk xk type 
arity stat greatest xi occurs stat 
set lex stat lexicographic positions stat set indices exists uj mul xi 
status stat arity strict ordering set extended ordering stat sequences elements length greater equal follows stat lex lex lex mul stat mul mul stat mul mul lex mul denote lexicographic multiset extension respectively 
example stat lex mul bv 
note status ordering stat boils usual lexicographic ordering stat lex mul mul xn multiset ordering stat lex mul xn 
important property status orderings stat founded founded 
notion status allow accept de nitions ones 
ackermann function ack need take lexicographic status lex mul mul binomial function bin need take multiset status lex mul 
ack ack ack ack ack ack bin bin bin bin bin apart notion status ingredients schema new 
introduce turn 
de nition symbol de nitions 
assume function symbol arity comes status arity set rf rewrite rules de ning denote set rewrite rules rewrite relation calculus 
assumption 
assume precedence founded blanqui theoretical computer science main new idea de nition general schema construct set admissible right hand sides left hand side 
set generated inductively starting set terms extracted left hand side called set accessible subterms computability preserving operations 
computability refers tait computability predicate method proving termination simply typed calculus extended girard polymorphic calculus 
explain construction need recall basics tait method 
starting observation possible prove termination reduction directly induction structure terms application case untyped calculus term xx xx rewrites xx normal form 
tait idea strengthen induction hypothesis property computability implying termination 
computability predicate de ned induction type terms follows inductive type take sn set strongly normalizable terms type terms having nite sequence rewrites issued 
functional type take 
de nition easy prove computable term strongly normalizable sn term computable 
term strongly normalizable 
role general schema rewrite rules added ensure computability preserved added rewritings 
require right hand side rule built subterms left hand side accessible ones computability preserving operations set called computable closure left hand side 
de nition accessible subterms 
term set acc subterms inductively de ned follows acc acc acc acc ui acc ux acc fv fv acc subterm basic type fv fv acc 
see works consider examples append map section 
rule append nil accessible arguments append 
rule append cons cons append accessible cons 
rules dealt way 
example associativity rule addition natural numbers rule variables accessible 
dose addition brouwer ordinals ord basic inductive type 
cases useful complex examples section 
seen extract subterms left hand side rule 
left construction computable closure subterms 
blanqui theoretical computer science operations computable closure constructs recursive calls smaller arguments 
need de ne intended ordering richer usual subterm ordering ed rule de nition addition brouwer ordinals lim lim fn see second argument recursive call strict subterm lim 
extending general schema capture de nitions open problems mentioned 
hand set theoretic interpretation functions input output pairs pair belong fn sense subterm done coquand notion structurally smaller assumes founded proof 
idea concrete relating strict positivity condition inductive types 
de nition arguments 
type terms type strictly positive inductive type greater pos constructor headed 
strict subterm fv fv 
ready de ne computable closure left hand side 
de nition computable closure 
symbol fs sn computable closure ccf term inductively de ned set cc variable cc acc cc terms cc respective types uv cc cc cc ft tp terms cc respective types tp cc ft tp ff terms cc respective types tp cc li li pv vi belongs cc 
de nition general schema 
rewrite rule follows general schema gs ifr ccf fv acc 
example prove de nitions append map section follow general schema 
saw free variables occurring left hand sides accessible belong computable closure cc respective left hand side 
rule blanqui theoretical computer science append cons cons append append belongs cc strict subterm cons 
rule map cons cons fx map fx belongs cc map right hand side 
rules dealt similarly 
previous de nition general schema computable closure kind implicit particular poor accessibility relation case ordering strict subterm ordering 
main di erences coquand notion structurally smaller extension statuses comparing arguments recursive calls lefthand side arguments include lexicographic comparisons may compare function headed term headed term subterm coquand de nition comparisons restricted constructor headed terms 
main advantage notions accessibility computable closure formulation immediate add new cases de nitions 
exibility course essential extending schema richer calculi 
user speci cation general schema question arises properties satis ed subject reduction con uence completeness de nitions strong normalization 
subject reduction follows easily 
con uence reduces local con uence strong normalization satis ed checked critical pairs 
completeness de nitions necessary recursor de nitions sense curry howard interpretation types 
checking done solving higher order disequations 
recalled done automatically reasonable fragment set second order terms 
section address remaining problem strong normalization 

strong normalization section prove rewrite relation terminating nite sequence rewrites rules satisfy general schema 
due formulation schema proof simpler schema general 
tait computability predicate method 
see comprehensive survey method 
rst de ne interpretation types prove important properties 
second part prove computability property function symbols assuming rules satisfy general schema term headed function symbol computable arguments computable 
strong normalization follows easily 
blanqui theoretical computer science 
interpretation types de nition interpretation types 
interpretation type inductively de ned follows set terms sn term ui si 
say term type computable belongs substitution computable variable dom 
reason need complex interpretation need property arguments computable constructor headed term computable 
see lemma just case basic inductive type interpretation merely sn rst show de nition sense 
lemma 
type uniquely de ned 
proof 
su ces prove holds inductive type sake simplicity assume identity mutually inductive types 
tell treat general case apart notations di cult 
sn set subsets sn sn complete lattice respect set inclusion show uniquely de ned xpoint monotone functional lattice 
proof induction assumed founded 
de ne family functions fs sn sn indexed inductive types fs sn ui rsi rt rt rt inductive types assumed strictly positive fs monotone 
tarski theorem xed point 
case mutually inductive types function fs operates product subsets sn sn sn sn inductive types equivalent lattice 
apart notations argument 
lemma computability properties 
term neutral abstraction constructor headed 
computable term strongly normalizable 
strongly normalizable term form computable 
blanqui theoretical computer science neutral term computable immediate reducts computable 
computable strongly normalizable computable 
constructor headed term computable terms immediate reducts computable 
computability preserved reduction 
basic inductive type sn proof 
proved induction type term 
sn de nition 
strongly normalizable term xu type computable reduce constructor headed term 
computable term type variable type 
induction hypothesis de nition interpretation 
induction hypothesis sn sn 
xu strongly normalizable term type 
induction hypothesis sn 

proved induction type term 
neutral term type immediate reducts belong 
immediate reducts strongly normalizable sn suppose reduces constructor headed term 
neutral constructor headed 
reduct immediate reducts de nition assumption terms computable 

neutral term type immediate reducts computable 
sn founded set reducts prove immediate reducts belong induction asu neutral immediate reduct form reduct form reduct rst case computable assumption 
inthe second case conclude induction hypothesis consequence neutral induction hypothesis 
computable 
neutral su ces prove reducts computable 
reduct computable assumption 
reason induction set reducts strongly normalizable founded ordering 
blanqui theoretical computer science constructor headed term terms immediate reducts computable 
strongly normalizable immediate reducts strongly normalizable 
term 
terms computable assumption 
immediate reduct 
assumption computable terms computable 
computable 
proved induction type term 
reduct sn sn reduces constructor headed term reduces 
de nition terms computable 
computable term type reduct 
reduct de nition belongs 
induction hypothesis computable 
sn prove sn induction sn founded ordering 
sn suppose 
basic sn si basic inductive type 
vi strongly normalizable induction hypothesis vi computable 
computable 

computability function symbols start paragraph proving accessibility compatible computability term accessible computable term computable 
prove property computable closure 
lemma compatibility accessibility computability 
term computable substitution dom fv computable 
accessible computable substitution dom fv computable 
proof 
induction acc 
case immediate 
acc 
dom reduct dom fv induction hypothesis computable 
computable assumption computable 
ui acc 
induction hypothesis computable 
de nition computability inductive types computable 
acc fv fv 
type dom 
computable term type 
dom blanqui theoretical computer science fv induction hypothesis computable 
computable 
subterm basic type fv fv 
fv fv subterm computable strongly normalizable subterm strongly normalizable computable basic type 
lemma computability function symbols 
assume rules satisfy general schema 
function symbol term arguments computable computable 
proof 
proof uses levels induction function symbols ordered arguments right hand side structure rules de ning 
lemmas terms computable assumption computable immediate reducts computable 
prove induction lex lex founded ordering 
reduction take place root computability predicates stable reduction terms computable 
di cult see compatible induction hypothesis computable 
reduction takes place root rule substitution dom fv de nition computable closure fact fv fv variable free accessible lemma take identity fv computable hypothesis terms fv computable 
computable 
substitution show induction ccf computable substitution dom fv computable 
variable dom computable computable 
dom computable 
acc 
lemma 
computable variable vw ccf 
induction hypothesis computable 
de nition computability predicates 
com ccf 
type computable term type induction hypothesis computable 
lemma computable 
ff vi ccf 
induction hypothesis vi computable 
induction hypothesis computable 
ff vi ccf induction hypothesis vi computable 
show blanqui theoretical computer science assume li vj li type strictly positive inductive type de nition pos li vj li li pis constructor headed 
assumption vi belongs computable closure 
induction hypothesis vi computable 
li type form sq type li founded sq equivalent ik li li li ik li 
vj strict subterm li fv vj fv li 
vj strict subterm li fv vj fv li 
vj strict subterm lj vj lj induction hypothesis computable 
able prove main lemma strong normalization term computable 
strong normalization follow simple corollary 
lemma main lemma 
assume rules follow general schema 
term computable substitution computable 
proof 
proceed induction structure 
variable ifx dom computable computable 
dom computable variable computable 

induction hypothesis vi computable 
lemma computable 
type computable term type 
induction hypothesis computable 
lemma computable 

induction hypothesis computable 
de nition computability computable 
theorem strong normalization 
assumptions combination simply typed calculus reductions higher order rewrite rules general schema strongly normalizing 
proof 
computability predicate type contains variables type identity substitution computable 
lemma term computable 
computable terms strongly normalizable term strongly normalizable 

examples extensions section applications current limitations general schema termination proof method 
blanqui theoretical computer science 
strictly positive types saw addition brouwer ordinals follows general schema 
true recursor brouwer ordinals user easily check lim type ord nat ord nat ord true mutually inductive types type trees node nil cons property true arbitrary strictly positive inductive types 
general case di cult apart complex notations 
uniqueness rules basic inductive types studied extended strictly positive case 
cases termination proof general schema uniqueness rules general schema 
open modify schema cover kind rules 

curried function symbols assumed function symbols come arguments 
due fact rewrite rules curried symbols lead uence 
take example id nat nat de ned id id id curried symbols possible price duplicating vocabulary follows function symbol arity add new function symbol type arity de ned rule xn xn satis es general schema 
example de nition sum list natural numbers foldl function foldl nil foldl cons foldl xy xy sum foldl blanqui theoretical computer science 
order rewriting authors proved possible combine higher order rewrite rules general schema rst order rewrite system rules decrease rewrite ordering non duplicating free variable occurs right hand side left hand side condition needed avoid toyama counter example modularity termination 
course possible lemma analog lemma rst order function symbols 
give example proved terminate method subtraction division natural numbers 
note follows general schema rule duplicating variable proposes terminating schema notion subtyping allows prove strong normalization property example 
think real issue 
non termination necessarily imply logical false provable 
case toyama counterexample modularity property termination union original con uent terminating rewrite systems terminating term computable normal form 
believe conjecture property ensure false derived combined calculus 

conditional rewriting conditional rule triple written condition form un vn fv fv meaning may applied terms pair ui vi common reduct 
conditional rule un vn encoded non conditional rules eqn un vn eqn xn xn second rule satis es general schema quite trivially 
say conditional rule follows general schema follows general schema un vn computable closure theorem conditional rules satisfy general schema strongly normalizing 
blanqui theoretical computer science fig 

automaton 
known example insertion function lists 
insert nil cons nil insert cons cons cons inf true insert cons cons insert inf false inf true inf false inf inf 
congruent types going see method easily cope basic inductive types constructors satisfy rst order equations provided equations form weakly normalizing term rewriting system term unique normal form 
case initial algebra inductive type equivalent normal form algebra represented accepting states nite tree automaton form 
important property automaton set terms recognized accepting state recursive predicate state easy de ne 
show construction simple example integers 
general case arbitrary basic inductive type di erent 
inductive type int speci ed constructors zero successor predecessor respectively equations easily turned rst order convergent term rewriting system normal forms recognized automaton fig 

automaton easily constructed solving disequations terms see 
blanqui theoretical computer science recursor integers may de ned set constraint rules pos neg usual possible de ne functions addition recursor xy xy equivalent pattern matching de nition pos neg may add example rule associativity completely di erent de nition automaton signature user speci cation course matter debate normal form computations available users 
de nite argument favor alternative 
assumed speci cation constructors weakly normalizing practice con uent terminating set rewrite rules 
method applies constructor commutative associative commutative additional technical restriction 
see explanations additional 
generalized non basic inductive types open 

matching modulo section address case higher order rewrite rules higher order pattern matching patterns 
give examples taken recall plain pattern matching really sense 
hand see blanqui theoretical computer science examples follow general schema explain rst example detail user invited check de nitions 
start example di erentiation functions inductive type sin cos cos sin gx fx ln note rst composition explicitly constructor inductive type positivity condition violated 
de ne rule accessible basic type accessible applied distinct bound variables condition required patterns nipkow framework 
explains composition encoded rule application operator calculus 
rules de ning usual rst order rules 
restrict case di erent 
course possible faithful axiomatization reals equality decidable reals 
rules states di erential constant function equal null function 
de nition substitution ensures occur freely instance constant respect may depend variables free rewritten term 
rule states di erential identity constant function equal 
rule sin cos de nes di erential function obtained composing sin function rules speak 
assume rst order pattern matching rules 
able di erentiate function sin computing sin rule match 
course give new rules case endless game 
higher order matching hand chooses appropriate value higher order free variables cover cases 
blanqui theoretical computer science local con uence rules checked higher order critical pairs shown nipkow 
computation critical pairs done linear time owing hypothesis left hand sides patterns 
show example follows general schema showing rst free variables right hand sides accessible respective left hand side 
rule accessible cases 
rule sin cos accessible sin 
di cult check right hand sides belong computable closure respective left hand side 
prehofer van de pol prove termination system higher order pattern matching de ning higher order interpretation proved strictly monotonic positive natural numbers method developed van de pol generalizes higher order case interpretation method rst order term rewriting systems 
easily imagine easy nd higher order interpretations 
needs interpreted functional takes arguments function positive natural numbers positive natural number example function furthermore interpretation method modular adequate interpretation single function symbol depending set rules 
di cult non experts 
example taken process algebra note left hand side rule pattern 
consequence nipkow results proving local con uence apply 
termination rules proved 
see example follows general schema su ces take precedence de ned 
rule simple projection dealt case 
blanqui theoretical computer science example computation negative normal form formula taken logic give sample rules course fact examples follow general schema imply nipkow rewriting terminates 
conjecture due patterns left hand sides 
prove conjecture essentially need show higher order pattern matching preserves computability 
proved rst author framework described extended typed version klop higher order rewriting framework nipkow higher order critical pair lemma shown apply extended framework 

rewriting modulo additional theories general practice rewrite modulo properties constructors implying underlying inductive type quotient de ned symbols 
usual properties presentations arithmetic commutativity commutativity associativity 
encoding predicate calculus common kind commutativity bound variables expressed equation pxy pxy give sample rules computation prenex normal form formula px qx set rules con uent modulo previous equation con uent directly 
note matching modulo equation necessary form left hand sides rules 
list operation inverse prenex normal form px qx px qx blanqui theoretical computer science examples follow schema 
course prove strong normalization prove schema compatible theories 
generalization quite straightforward commutativity needs investigations complex theories associativity commutativity 

continuation 
important contributions new general schema strong capture strictly positive recursor brouwer ordinals compromising essential properties calculus 
strong normalization proof extension tait girard computability predicates technique uses essential way strict positivity condition inductive types 
notion critical subterm strict positivity condition inductive types appears concrete version coquand notion structurally smaller 
new formulation schema easy de ne new extensions simply adding new cases de nition accessibility new computability preserving operations computable closure 
notion computable closure important concept di erent context 
precise conjectures stated 
important view general schema prove strong normalization higherorder rewriting practical side generalization schema capture non strictly positive inductive types theoretical 
rst conjecture solved rst author 
kind extension considered considering richer type system keeping de nition rules general schema 
richer type system allows richer forms rewrite rules general schema adapted allow rules dependent type rules types 
experience shows kind extension raises important technical di culties 
strong elimination rules calculus inductive constructions rules de ning system natural deduction modulo kind 
fernandez combining rst higher order rewrite systems type assignment systems proc 
st internat 
conf 
typed lambda calculi applications lecture notes computer science vol 
springer berlin 
blanqui theoretical computer science fernandez modularity termination con uence combinations rewrite systems proc 
th internat 
colloq 
automata languages programming lecture notes computer science vol 
springer berlin 
fernandez geuvers modularity strong normalization con uence algebraic cube proc 
th symp 
logic computer science ieee computer society 
barendregt lambda calculi types eds handbook logic computer science vol 
oxford university press oxford 
blanqui termination con uence higher order rewrite systems proc 
th internat 
conf 
rewriting techniques applications 
lecture notes computer science 
blanqui 
jouannaud okada calculus algebraic constructions proc 
th internat 
conf 
rewriting techniques applications lecture notes computer science vol 
springer berlin 

jouannaud meseguer speci cation proof membership equational logic theoret 
comput 
sci 

breazu tannen combining algebra higher order types proc 
rd symp 
logic computer science ieee computer society 
breazu tannen gallier polymorphic rewriting conserves algebraic strong normalization proc 
th internat 
colloq 
automata languages programming lecture notes computer science vol 
springer berlin 
breazu tannen gallier polymorphic rewriting conserves algebraic strong normalization theoret 
comput 
sci 

comon dauchet gilleron tison tree automata techniques applications 
available www grappa univ lille fr tata 
coquand pattern matching dependent types proc 
rd 
types proofs programs chalmers university technology sweden 
coquand huet constructions higher order proof system mechanizing mathematics proc 
european conf 
computer algebra lecture notes computer science vol 
springer berlin 
coquand paulin mohring inductively de ned types proc 
internat 
conf 
computer logic lecture notes computer science vol 
springer berlin 
de bruijn mathematical language automath usage extensions proc 
symp 
automatic demonstration lecture notes computer science vol 
springer berlin 
reprinted selected papers automath nederpelt geuvers de eds studies logic vol 

north holland amsterdam 
dershowitz 
jouannaud rewrite systems van leeuwen ed handbook theoretical computer science vol 
formal models semantics chapter rewrite systems north holland amsterdam 
dowek hardin kirchner theorem proving modulo tech 
report inria france 
dowek werner proof normalization modulo tech 
report inria france 
gallier girard de 
odifreddi ed logic computer science north holland amsterdam 
codifying guarded de nitions recursion schemes proc 
th 
types proofs programs lecture notes computer science vol 
springer berlin 
structural recursive de nitions type theory proc 
th internat 
colloq 
automata languages programming lecture notes computer science vol 
springer berlin 

girard une extension de interpretation de godel analyse son application elimination des coupures dans analyse la theorie des types fenstad ed proc 
nd scandinavian logic symp studies logic foundations mathematics vol 
north holland amsterdam 

girard interpretation fonctionelle elimination des coupures dans ordre 
ph thesis universite paris vii france 

girard lafont taylor proofs types cambridge university press cambridge 
godel intuitionistic arithmetic number theory davis ed undecidable raven press new york 
extensions godel system master thesis keio university japan japanese 
blanqui theoretical computer science 
jouannaud okada executable higher order algebraic speci cation languages proc 
th symp 
logic computer science ieee computer society 

jouannaud okada data type systems theoret 
comput 
sci 


jouannaud rubio 
higher order recursive path ordering proc 
th symp 
logic computer science ieee computer society 
klop combinatory reduction systems ph thesis university utrecht netherlands 
published mathematical center tract 
klop van van combinatory reduction systems survey theoret 
comput 
sci 

martin lof intuitionistic theory types predicative part rose shepherdson eds proc 
logic colloq studies logic foundations mathematics vol 
north holland amsterdam 
martin lof intuitionistic type theory bibliopolis 
mayr nipkow higher order rewrite systems con uence theoret 
comput 
sci 

mendler second order lambda calculi recursive types tech 
report tr cornell university united states 
mendler inductive de nition type theory ph thesis cornell university united states 
miller logic programming language lambda abstraction function variables simple uni cation proc 
internat 

extensions logic programming lecture notes computer science vol 
springer berlin 
automates de formes inductive master thesis universite paris sud france 
nipkow higher order critical pairs proc 
th symp 
logic computer science ieee computer society 
okada strong combined system typed lambda calculus arbitrary convergent term rewrite system proc 
internat 
symp 
symbolic algebraic computation acm press new york 
okada scott note rewriting theory uniqueness iteration theory appl 
categories 
prehofer solving higher order equations logic programming ph thesis technische universitat munchen germany 
qian linear uni cation higher order patterns proc 
th internat 
joint conf 
caap fase theory practice software development lecture notes computer science vol 
springer berlin 
sellink verifying process algebra proofs type theory proc 
internat 

semantics speci cation languages workshops computing 
combinators lambda terms proof theory reidel dordrecht 
tait intensional interpretations functionals nite type symbolic logic 
toyama counterexamples terminating direct sum term rewriting systems inform 
process 
lett 

van de pol termination proofs higher order rewrite systems proc 
st internat 

higher order algebra logic term rewriting lecture notes computer science vol 
springer berlin 
van con uence higher order rewriting ph thesis vrije universiteit netherlands 
van con uence normalization higher order rewriting ph thesis vrije universiteit netherlands 
werner une theorie des constructions ph thesis universite paris vii france 
