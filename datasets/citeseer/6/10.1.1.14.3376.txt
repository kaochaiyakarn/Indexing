automatic clustering produce high level system organizations source code mitchell department mathematics computer science drexel university philadelphia pa usa mcs drexel edu algorithms developed implemented facilitate automatic recovery modular structure software system source code 
treat automatic modularization optimization problem 
algorithms traditional hillclimbing genetic algorithms 
keywords clustering reverse engineering software structure optimization genetic algorithms 

understanding intricate relationships exist source code components software system arduous task 
frequently problem exacerbated design documentation date original system architect longer available consultation 
mechanism gaining insight system design structure software maintenance practitioner forced modi cations source code thorough understanding organization 
requirements heavily software systems tend change time inevitable continually adopting ad hoc approach maintenance negative ect modularity system 
time system structure may deteriorate point source code organization chaotic needs radically abandoned 
software engineers rely notations tools help cope complexity structure large software systems 
way programmers cope structural grouping clustering related procedures associated data modules classes 
chen gansner labs research florham park nj usa research att com modules improve software development maintenance insu cient supporting design ongoing maintenance large systems 
systems contain hundreds thousands lines code packaged large number cooperating modules 
fortunately nd systems organized clusters modules called subsystems collaborate achieve higher level system behavior 
unfortunately subsystem structure obvious source code structure 
research proposes automatic technique creates hierarchical view system organization solely components relationships exist source code 
rst step technique represent system modules module level relationships module dependency graph 
algorithms partition graph way derives high level subsystem structure component level relationships extracted source code 
fully automatic modularization techniques useful programmers lack familiarity system 
techniques useful system architects want compare documented automatically derived ones possibly improve design learning di erences 
shows architecture automatic software modularization environment 
rst step modularization process extract dependencies source code store resultant information database 
cia tool acacia step 
module level dependencies stored database execute awk script query database lter query results produce output textual representation module dependency graph 
clustering tool called bunch source code clustered graph source code analyzer cia graph visualization tool dotty source code database output file query script awk clustering tool bunch module dependency graph 
automatic software modularization environment applies clustering algorithms module dependency graph emits text description high level structure systems organization 
dotty visualization tool read output le clustering tool produce visualization results 
structure remainder follows section presents case study illustrates ectiveness automatic software modularization technique 
section develops pertinent aspects technique formally quantifying inter connectivity intra connectivity modularization quality 
section presents algorithms implemented clustering software components 
section dedicated describing operation performance modularization tool 
section presents related research area software modularization 
conclude outlining research limitations discussion plans improve technique 

example shows module dependency graph program implements le system service 
allows users new le system nos access les old le system oos di erent le node structures mounted users name space 
edge graph represents dependency relationship program entities corresponding source modules source les 
example edge nos established due dependency relationships 
program consists lines code counting system library les 
acacia tool parsed program detected program entities dependency relationships 
note containment relationships classes structs members excluded consideration construction module dependency graphs 
module dependency graph clear major components system 
applying automatic modularization tool graph results large clusters smaller ones 
discussing outcome experiment original designer system interesting observations 
obvious major components system 
right cluster mainly deals old le system left cluster deals new le system 

clustering tool ective putting modules cluster algorithm get hints le names 
clustering consistent designer expectation 

hand just looking module names designer tend associate right cluster 
interestingly algorithm decided put left cluster associations nos modules left cluster 
designer con rmed partition sense main interface le new le system talk le system 

quite explain small cluster consisting created left 
better merge small cluster neighbor cluster 
simple explanation algorithm sub optimal may give satisfactory answer certain cases 
sections examine algorithm detail shed light heuristics obtain sub optimal solution 
log nos fork serv 
module dependency graph file system 
automatic software modularization software systems contain nite set software components nite set relationships govern software components interact 
typical software components include classes modules variables macros structures common relationships include import export inherit procedure invocation variable access 
goal software modularization process automatically partition components system clusters subsystems resultant organization concurrently minimizes inter connectivity connections components distinct clusters maximizing intra connectivity connections components cluster 
accomplish task treating clustering optimization problem goal maximize objective function formal characterization trade inter intra connectivity 
clusters discovered represent higher level component abstractions system organization 
subsystem contains collection modules cooperate perform high level function system scanner parser code generator provide set related services system le manager memory manager 
fundamental assumption underlying approach designed software systems organized cohesive clusters loosely interconnected 

intra connectivity regard intra connectivity measure connectivity components grouped cluster 
high degree intra connectivity indicates subsystem partitioning modules grouped common subsystem share software level components 
degree intra connectivity indicates poor subsystem partitioning modules assigned particular subsystem share software level components limited cohesion 
maximizing measurement increase likelihood changes module localized subsystem contains module 
de ne intra connectivity measurement ai cluster consisting ni components mi intra edge dependencies ai log nos serv fork 
automatically produced high level system organization file system measurement fraction maximum edge dependencies exist cluster isn value ai bounded values 
ai modules cluster share software level resources ai module cluster uses software resource modules cluster modules dependencies subsystem form complete graph 
apply intra connectivity measurement cluster containing modules dependencies 

intra connectivity example 
inter connectivity regard inter connectivity measurement connectivity distinct clusters 
high degree inter connectivity indication poor subsystem partitioning 
having large number inter dependencies complicates software maintenance changes module may ect parts system due subsystem interrelationships 
degree inter connectivity desirable trait system organization indicator individual clusters system large extent independent 
changes applied module localized subsystem reduces likelihood introducing errors parts system 
de ne inter connectivity eij clusters consisting ni nj components respectively ij inter edge dependencies ei inter connectivity measurement fraction maximum edge dependencies clusters 
measurement bound values 
eij module level dependencies subsystem subsystem eij module subsystem depends modules subsystem vice versa 
illustrates example application inter connectivity measurement 

inter connectivity example 
modularization quality recall goal discover partitioning components software system concurrently minimizes inter connectivity maximizes intra connectivity 
modularization quality mq measurement objective function optimization process de ned measurement quality particular system modularization 
speci cally de ne mq module dependency graph partitioned clusters ai intra connectivity th cluster eij inter connectivity th th clusters mq ai pk ei mq measurement demonstrates tradeo inter connectivity intra connectivity rewarding creation highly cohesive clusters penalizing creation inter edges 
tradeo established subtracting average interconnectivity average intra connectivity 
average values ensure unit consistency subtraction intra connectivity summation number subsystems inter connectivity summation number distinct pairs subsystems 
mq measurement bounded cohesion subsystems coupling subsystems 
illustrates example calculation mq 

modularization quality example 
modularization algorithms mq measurement de ned turn attention developing algorithms start module dependency graph source code produce output hierarchy clusters represents subsystem structure software system 
depicts software modularization algorithms supported bunch 
optimal algorithm produces best results works small systems 
algorithms faster may produce optimal result 
remainder section describes algorithms detail 
rst step automatic modularization process parse source code build module bunch clustering tool optimal clustering algorithm sub optimal clustering algorithm genetic algorithm uses uses neighboring partition strategy 
automatic clustering algorithms dependency graph 
formally module dependency graph mdg consists components set named modules software system set ordered pairs form hu vi represents relationships exist module module module dependency graph constructed apply modularization algorithms 
remainder section develops additional theory presents collection algorithms implemented automatically partition software systems 

partitions set consider source code organization software system 
set modules fm mng module contains source code features variables macros functions procedures constants 
ak set non empty subsets call partition set 
sn ai 
ai aj partition call subset ai cluster partition non empty clusters called partition set contains elements number sn distinct partitions set satis es recurrence equation sn ork sn entries sn called stirling numbers grow exponentially respect size example node module dependency graph distinct partitions node module dependency graph distinct partitions 

optimal clustering algorithm algorithm determining optimal clustering software system 

fm mng mi module software system 

mdg graph representing relationships modules 
generate partition set 
evaluate mq partition 

partition largest mq optimal solution 
successfully applied optimal clustering algorithm systems modules 
search space number partitions large explored reasonable time frame 
clearly sub optimal techniques employed systems large number modules 

neighboring partitions sub optimal clustering technique relies moving modules clusters partition improve mq 
task accomplished generating set neighboring partitions np partition 

neighboring partitions de ne partition np neighbor partition np exactly single element cluster partition di erent cluster partition np 
illustrates process determining neighboring partitions ways de ne neighboring partition simple understand implement ers execution performance 
automated software modularization techniques poor module movement decision early negatively bias nal results facility moving module placed cluster 
useful property neighboring partition approach assignment module cluster permanent 

sub optimal clustering algorithm search space required enumerate possible partitions software system prohibitively large number modules system increases 
directed attention developing search strategy traditional hill climbing optimization techniques quickly discovers acceptable sub optimal clustering result 
summary sub optimal clustering algorithm starts random partition repeatedly nds better neighboring partitions neighboring partition higher mq 
sub optimal clustering algorithm 
fm mng mi module software system 

mdg graph representing relationships modules 
generate initial random partition set 
repeat randomly select better neighboring partition bn mq bn mq 
bn bn improved neighboring partitions 

partition sub optimal solution 
sub optimal clustering algorithm better neighboring partition bn discovered going set neighboring partitions partition higher mq 

genetic algorithm implementation experimentation sub optimal clustering algorithm shown initial random starting partition algorithm converge local maximum 
randomly generated initial partitions improve acceptable suboptimal result 
approach solving problem run experiment times di erent initial partitions pick experiment results largest mq sub optimal solution 
number experiments increases probability nding globally optimal partition mq increases 
systematic approach solving optimization problem genetic algorithms 
discovering acceptable sub optimal solution genetic algorithms involves starting population randomly generated initial partitions systematically improving initial samples converge 
approach resultant partition largest mq sub optimal solution 
genetic algorithms successfully applied problems involve exploring large search spaces 
combine survival ttest technique structured randomized information exchange facilitate innovative search algorithms parallel theory natural selection 
genetic algorithms randomized search exploit historical data speculate new information expected yield improved results 
genetic search algorithm nding sub optimal partition software system genetic sub optimal clustering algorithm 
fm mng mi module software system 

mdg graph representing relationships modules 
generate population random partitions set 
repeat randomly select percentage partitions population improve nding better neighboring partition bn generate new population partitions making selections replacement existing population partitions 
selections random biased favor partitions larger 
improvement seen generations partitions population converged maximum mq maximum number generations reached 

partition nal population largest mq sub optimal solution 
genetic clustering implementation user con gurable parameters 
include setting population size maximum number generations execute concluding experiment converge convergence threshold percentage 

hierarchical clustering algorithms previous section generated partitions mdg graph formed recovering relationships source code components 
performing analysis large software systems number clusters partition may large 
case sense cluster clusters creating hierarchy subsystems 
software modularization techniques support hierarchical clustering 
technique way rst step hierarchical clustering process apply standard software modularization algorithms mdg graph 
activity discovers partition plm represents partition converged local maximum lm 
build new higher level graph treating cluster plm single component 
furthermore exists edge clusters plm edge representative nodes new graph 
apply clustering algorithms new graph order discover higher level graph 
process applied iteratively components coalesced single cluster root subsystem decomposition hierarchy 

bunch clustering tool implemented algorithms described applied example software systems 
table presents performance measurements common systems processed bunch 
computation environment experiments pentium computer mb ram running windowsnt operating system 
execution times shown table collected running bunch microsoft virtual java machine 
experienced similar performance results java just time jit compiler provided sun microsystems solaris 
interested readers may download copy software drexel university software engineering research group home page www mcs drexel edu 

related problem automatic modularization referred automatic clustering extensively researched past decades 
provides excellent introductory survey clustering systems remodularization 
widely referenced clustering tools developed speci cally address software remodularization problem rigi arch 
tools employ clustering techniques rely intervention architect understands system structure order produce results 
result techniques little help familiar software system trying understand structure 
basili automatic clustering technique data bindings 
unfortunately data bindings basis performing software modularization shortcomings 
speci cally system modules exhibit strong encapsulation hide data system system type module module level execution time name count relationships unix spell checker sec 
rcs version control system sec 
small operating system sec 
lu proprietary system hour sec 
way determining module level relationships data bindings limited number publicly accessible variables 
additionally modularization data bindings addresses problem clustering procedures variables classes modules 
objective cluster related modules classes subsystems useful systems large number modules 
addition bottom clustering approaches produce high level structural views starting structure source code research emphasis placed top approaches 
example goal software re model isto capture exploit di erences exist source code organization designer mental model high level system organization 
primary purpose technique streamline amount time takes unfamiliar system understand source code structure 

experimentation clustering technique shown results systems investigated 
primary method evaluate results automatically generated modularization software system actual system designer ask feedback quality results 
able produce results systems examined known shortcoming current de nition modularization quality mq take account interconnection strength relationships exist modules software system 
muller measurement exact objects exchanged shared modules 
clustering technique strictly topology module dependency graph convey accurate representation systems modularization magnitude interconnection strengths actual module relations di er signi cantly 
order address shortcoming cur table 
bunch tool performance rently working extension de nitions inter connectivity intra connectivity modularization quality accounts weight dependencies 
expect extension yield better results systems distribution interconnection strength values non uniform 
current assumption value dependencies equal 
chen 
reverse engineering 
krishnamurthy editor practical reusable unix software chapter pages 
john wiley sons new york 
chen gansner os 
data model supporting reachability analysis dead code detection 
sixth european software engineering conference fifth acm sigsoft symposium foundations software engineering sept 

programming large versus programming small 
ieee transactions software engineering pages june 
goldberg 
genetic algorithms search optimization machine learning 
addison wesley 
basili 
system structure analysis clustering data bindings 
ieee transactions software engineering pages aug 
muller orgun tilley uhl 
discovering reconstructing subsystem structures reverse engineering 
technical report dcs ir department computer science university victoria aug 
murphy notkin sullivan 
software models bridging gap source high level models 
proc 
acm sigsoft symp 
foundations software engineering 
wilf 
combinatorial algorithms 
academic press nd edition 
north os 
applications graph visualization 
proc 
graphics interface pages 

intelligent tool re engineering software modularity 
inproc 
th intl 
conf 
software engineering may 

clustering algorithms legacy systems remodularization 
working conference engineering wcre 
