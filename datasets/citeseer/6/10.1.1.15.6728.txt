sharing protection single address space operating system jeffrey chase henry levy michael feeley edward lazowska technical report april revised january appear cm transactions computer systems may department computer science engineering fr university washington seattle wa usa sharing protection single address space operating system jeffrey chase henry levy michael feeley edward lazowska department computer science engineering fr university washington seattle wa technical report april revised january appearance bit address space architectures dec alpha hp pa risc mips signals radical shift amount address space available operating systems applications 
shift provides opportunity reexamine fundamental operating system structure specifically change way operating systems address space 
explores memory sharing protection support opal single address space operating system designed wide address architectures 
opal threads execute protection domains single shared virtual address space 
sharing simplified addresses context independent 
loss protection access independent right access segment determined protection domain thread executes 
model enables beneficial code data sharing patterns currently prohibitive due part inherent restrictions multiple address spaces part unix programming style 
designed implemented opal prototype mach microkernel base 
implementation demonstrates single address space structure supported alongside environments modern microkernel operating system modern architectures 
justifies opal model goals sharing protection presents system abstractions describes prototype implementation reports experience integrated applications 
appear acm transactions computer systems may issue 
sup ported part science foundation 
ccr cda ccr washington technology center digital equipment boeing computer services intel hewlett packard apple computer 
levy supported part fulbright research award inria 
chase supported intel foundation graduate fellowship 
categories subject descriptors processor architectures architecture styles capability architectures programming techniques programming languages language constructs modules packages operating systems storage management operating systems communications management operating systems security protection access controls information flow controls operating systems organization design operating systems performance measurements data structures data storage representations general terms design experimentation measurement performance additional key words phrases single address space operating systems persistent storage protection capability systems object oriented database systems microkernel operating systems wide address architectures bit architectures 
appearance bit address space architectures dec alpha dig hp lee mips mip signals radical increase amount address space available operating systems applications 
shift provides opportunity reexamine fundamental operating system structure specifically change way operating systems address space 
goal restructure operating systems order improve organization system applications 
particular wish enhance sharing simplify integration improve reliability performance complex cooperating applications manipulating large persistent data structures 
example target application domain includes integrated software environments engineering design cad case composed groups data centered tools inherently interdependent rich interactions 
describes opal single address space operating system intended support complex applications wide address architectures 
opal provides single global virtual address space shared procedures data 
crucial design full separation addressing protection intimately bound process concept systems unix multics daley dennis 
fundamental principle opal system addresses unique interpretation applications potentially time 
virtual addresses context independent resolve data independently uses 
thread name data system generally right access data protection domain thread executes defines access rights limiting access specific set pages specific instant 
wide address architectures facilitate single address space approach eliminating need re addresses required bit architectures 
wish debate particular address size propose 
full bit address space years allocated rate gigabyte second 
believe bits time single computer long time small network long global internet 
case clear address sizes past bit boundary continue grow 
past growth averaged additional address bit doubling address space year siewiorek 
purpose opal experiment explore strengths weaknesses single address space approach significant departure traditional model private virtual address spaces executing program unix 
concepts opal related previous hardware software systems spanning years example multics daley dennis hydra wulf pilot redell monads rosenberg abramson intel organick ibm system psyche scott early capability systems dennis van horn 
detailed discussion comparison systems provided section 
fundamentally hope demonstrate advances hardware operating systems language technology enable achieve goals previous systems need purpose hardware loss protection performance requiring single type safe language systems demanded 
section introduces basic premises opal single address space structure contrasts traditional private address space approach 
concentrate particular process process process domain domain copying linearized data pipe file placing multiple components incurs costs copy store redundant data 
process avoids copying compromises incremental updates difficult 
protection 
opal components placed overlapping protection domains shared segment memory 
choices structuring cooperation application components 
opal support sharing protection structures 
section gives overview basic opal abstractions 
section describes mach prototype demonstrates single address space structure supported existing microkernel platforms way permits interaction traditional unix environments 
section discusses opal applications target domain describes mechanism implemented opal manage sharing protection provides performance measurements prototype 
section explores objections single address space approach section describes relationship previous systems 
summarize experience conclude section 
single address space approach examining concepts single address space operating system useful review multiple address space approach take granted 
major advantages private address spaces increase amount address space available programs provide hard memory protection boundaries permit easy cleanup program exits 
disadvantage approach mechanism memory protection isolating programs private virtual address spaces presents obstacles efficient cooperation protected application components 
particular pointers meaning boundary lifetime process creates pointer information easily shared stored transmitted 
primary cooperation mechanisms rely copying data private virtual memories typically converting neutral intermediate representation 
inconvenient expensive large sparsely data structures 
private address space systems force poor tradeoffs protection performance integration 
application designer basic choices place application components independent processes exchange data pipes files messages la sacrificing performance place components process sacrificing protection lb 
choice adequate growing important class applications composed groups programs cooperating shared pointer rich database 
results software systems slow unreliable poorly integrated 
applications need better control protection sharing current systems provide protection crucial programs independently developed evolving natural sharing relationships output program input 
believe dilemma resolved judicious sharing virtual memory protected components 
sharing need compromise modularity increase performance substantially sacrificing protection read sharing 
modern systems support shared memory form pitfalls limitations private address space model 
pointers typically requires priori coordination address space shared regions sharing patterns known statically 
single address space model system applications coordinates address bindings accommodate dynamic sharing patterns uniform way 
systems taken steps direction examples include sections microsoft windows nt custer mmap facilities unix systems 
systems mix shared private regions introduces problems 
pointers may ambiguous private data pointers shared regions difficult detect handle private code pointers important object oriented languages passed shared 
early decisions shared private 
sharing ad hoc process shared region virtual addresses available 
single address space systems avoid problems treating virtual address space global resource controlled operating system disk space physical memory 
done sacrificing major advantages private address spaces 
specifically architectures provide sufficient addressing multiple address spaces need loss protection single address space cleanup harder single address space conventional programs share data 
alternatively cleanup easier private address spaces programs share data 
fact problems sharing protection including reclamation simplified eliminated decoupling protection domains concepts bundled notion process conventional systems 
addition separating protection addressing opal separates program execution resource ownership resource naming protection domains 
purpose decoupling memory protection cheaper easier easier change 
independence protection addressing opal substantially increases flexibility 
programs directly share procedures complex pointer data structures requiring priori negotiation address space usage depicted 
common address space allows dynamic imports binding data structures code 
need decide advance shared private memory segment shared time address conflicts memory access rights easily passed fly domain domain 
opal conventional programs code exists procedures residing shared address space 
procedure entry point protection domain subprograms execute private protection domain depending trust relationship caller callee 
furthermore single address space structure properties exploited memory system implementation 
specifically address overloading eliminated 
removes ambiguity virtual tags processor caches need maintain separate tables virtual physical translations process 
processors equipped software loaded tlbs permits alternative translation table structures huck hays better accommodate large sparse virtual memories 
negative side property prohibits programs mapping different data virtual addresses 
effect restriction discussed section sharing trust today dominant protection model promotes protection domains processes encapsulating fully isolated software components data interacting messages 
strict model fully disjoint protection accommodates distribution tempting simplicity central structured young rozier mullender tanenbaum custer oriented systems 
believe simplistic confining reasons asymmetric trust relationships common exploited accept inputs memory segments trust example name server provide read access database requiring protected messages updates 
direct sharing useful mutually suspicious threads 
memory shared read restricted ways passed sequentially domain domain 
protection domains coordinate data access mutually trusting threads 
example multiple instances database program may prefer execute separate domains enforce different access privileges protection faults drive implicit locking chang mergen 
tradeoffs protection performance unavoidable 
complete isolation achieved protection fully disjoint granularity tradeoffs 
programs may naturally overlapping access stored data may known advance 
fundamentally believe druschel operating system protection structures right level impose modularity 
fact protection structures impose modularity enforce selected module boundaries 
case shared data accessed procedural interfaces protection structures flexible permit application specific choice modularity enforced 
persistence distribution single address space structure accommodate address spaces different temporal geographical scopes single address space system node extended include network wide data persistent data active 
attractive applications manipulating pointer rich data structures need store structures share network 
distributed persistent single address space system network nodes exchange addresses directly messages data structures directly saved long term storage accessed programs need translate internal pointers 
goals extend addressing domain small workstation cluster discussed detail section 
note purpose including inactive distributed data virtual address space eliminate entirely mechanisms data conversion swizzling marshaling translation reduce frequency mechanisms applied 
distributed persistent address space eliminate translation common cases transfers programs single node memory long term storage nodes small lan cluster 
amounts caching precomputed machinedependent representation data retaining ability convert back machineindependent representation exceptional cases transmission outside local addressing domain 
programming large pointer applications demands language level knowledge compiler generated templates structure data order support garbage collection integrity checks 
structures wilson continue transparently convert format data needed crossing boundaries outside single address space scope 
focuses implications single address space structure sharing protection single node discuss persistence distribution detail 
simply note choice single address space node strictly require including persistent distributed data local address space ability accommodate extensions naturally uniformly model strengths 
summary summary believe familiar model programs independent short lived processes transform stream input stream output needlessly restrictive forces poor structuring performance tradeoffs broad increasingly important class applications 
believe applications better served single address space structure enabled appearance bit addressing modern risc processors 
objective single address space operating system expand choices structuring computations protection sharing storage communication data 
opal abstractions mechanisms section defines fundamental opal mechanisms management single address space provides insight design choices 
limit focus aspects system essential single address space structure goal supporting modular sharing protection 
basic concepts familiar appeared previously various contexts 
key simple application concepts accept separation protection addressing wide address architectures 
system facilities described section need exposed directly applications intended substrate building language runtime environments mediators framework described section 
opal prototype includes standard runtime package defines simple programming interface 
package prototype alternative languages application environments implemented framework 
runtime package aspects prototype described detail section 
storage protection opal units storage allocation protection segments contiguous extents virtual pages 
virtual address segment permanent attribute fixed system allocation time 
smallest possible segment page general expect segments large allow growth structures contain 
segments marked persistent managed explicit counting described section 
opal units execution threads 
protection domain execution context threads restricting access specific set segments particular instant time 
thread executes exactly protection domain threads may execute domain 
domains subjects memory access control 
opal domain analogue unix process domains private virtual address spaces passive protection contexts global virtual address space 
alternatively protection domain viewed collection segments accessible protection context 
philosophy opal storage allocation protection reclamation coarsegrained operating system level 
fine grained control best provided language level compilers runtime systems 
example standard runtime package allocates large segments provides heap storage dynamic memory allocation 
programs allocate objects multiple heaps control data structures partitioned segments 
believe burdening operating system worse hardware fine grained protection error particularly safety guaranteed strongly typed languages 
safe languages operating system support hard protection boundaries order separate non trusting parties different safe unsafe language environments 
hard boundaries provided opal protection domains easily supported standard page protection mechanisms modern processors 
access control opal kernel resources protection domains segments named capabilities capability bit confers permission operate named object specific ways 
name service supports symbolic names capabilities access control lists acls protection 
opal uses password capabilities anderson similar amoeba mullender tanenbaum chorus rozier mach style capabilities called port rights young 
advantage password capabilities passed directly shared memory name global resources capabilities mach meaningful mach protection context task preventing sharing 
segment capability executing thread explicitly attach segment protection domain permitting threads executing domain access segment directly 
conversely thread explicitly detach segment deny access 
attach request specify particular access rights segment read read write specify rights permitted capability 
attach opal analogue unix mmap primitive mapping files process opal system application chooses mapped address 
data opal resides segments potentially proper capability data inherently private particular executing program 
segments attached transparently address faults application chooses 
holder segment capability may publish capability acl 
address fault occurs runtime fault domain requests published capability specifying faulting address 
access granted acl handler attaches segment returning address exception 
interdomain communication opal shared memory primary form sharing communication trusting threads different protection domains 
addition system permit control transfers domain 
support opal domain create portals permit domains call protected controlled manner 
portals implement servers protected objects 
portal entry point domain uniquely identified bit value 
thread knows value system call transfers control domain associated portal 
threads entering portal executing global virtual address fixed attribute portal specified creator 
way creator protection domain control code executed 
global name space portals opal allows exchange cross domain call bindings shared memory password capabilities implemented simple bind time extension general purpose rpc facility 
opal capability simply bit value containing object address randomized check field verifies authority operate named object 
check field permits revocation server may deny access called valid capability 
portal name allows client rpc calls server capability server resources 
servers multiplex management multiple objects single portal 
example segment capability contains segment server identifies segment managed server domain capability contains domain server identifies domain managed server 
opal capabilities implemented runtime package hidden users interface proxies shapiro 
client side capability hidden ordinary object called proxy server side check field stored corresponding object called guard holds pointer actual object named capability 
methods proxies guards messaging stubs embedded validation checks 
procedure calls proxy result rpc call guard passing capability argument 
protection boundary capabilities transparent application 
proxy package mentioned completeness example support built raw portals 
details scope 
wc assume existence authentication service supports protected notion identity basis acls 
acls arc implemented current prototype access granted published symbolically named capability 
designed kernel primitive implementing protected procedure call lrpc bershad aj 
particularly system user level threads scheduler activations anderson 
protection domains thread running protection domain parent domain create new restricted domain child typically protect parent data untrusted subprogram 
parents attach arbitrary segments children cause arbitrary code execute children 
child fully trusts parent vice versa 
child domain amplify parent rights protected way case privileged server create child behalf nominal parent 
protected procedure call means causing code execute child domain particular notion executing program 
execute code child parent registers portal child domain specifies procedure entry point calls portal 
ordinarily portal created collection procedures methods guard type code executed entrance portal server side dispatcher stub procedures 
policy supported standard runtime package allows parent create objects segments shared child generate capabilities objects invoke portal calls execute child domain 
parents may pass capabilities children effectively setting rpc connections siblings 
facilities easy structure user software group cooperating domains arbitrary sharing patterns cross domain rpc bindings 
application simply create domains attach code data protected calls possibly causing domains call parent 
linking executing code handling executable code modules systems opal differs respects conventional systems 
topic focus related garrett 
wish points section essentials linking execution classes systems sharing dynamic code modules easy shared address space support private data shared modules trickier respects 
module group compiled procedures table symbols code static data items global variables defined module initial values static data items table external symbols imported modules 
module code contains memory instructions loads stores branches addressing techniques selected compiler pc relative absolute register relative modes 
linker utility processes module resolve linked executing threads call module directly virtual addresses assigned 
opal differs conventional systems way read symbols code constant data bound virtual addresses way symbols resolved 
conventional systems module typically complete self contained program linked execute private virtual address space 
linker statically binds virtual addresses symbols module ordinarily assigning starting address program 
contrast different opal modules run different addresses shared address space module continues reside address time runs 
opal modules statically linked persistent segments global address space 
runtime module ere fixed module segment 
ere distinct benefits linking code modules executing module cen single copy ere running different protection 
efficient cen reduce time 
procedure pointers cen freely system level 
procedure pointers ere implement polymorphic types 
cen cell procedure simply knowing possibility conflicts modules 
systems celled directly ere linked execute protection structuring choices ere locked link time systems 
opel differs systems private static data 
multiple module mey exist concurrently module code version 
code compute correct 
systems module runs copies reside mep different underlying 
opel different exist different 
linker determine pc offsets code register register dynamically 
issue discussed section note leeds flexible protection en opel module register en executing completely determines 
multiple cen en multiple cen execute es determined environment 
resource management reclamation opel provides systems 
explicit counting support runtime collectors untyped units 
counting segments simple opel implicitly counts attach detach deleting segments lest 
user cen register persistent segment persist lest 
philosophy 
opel control cen freely copied memory 
opel counts need reflect number resource 
count number entities registered en interest resource entities cells decrement count 
erroneous cen resources system non trusting entities errors 
resource groups support accounting bulk deletes resources objects prevent entities releasing resource 
mechanisms described subsections 
resource groups call create opal resource increment count pass capability resource group argument 
opal tracks resource created behalf resource group releases resource group destroyed 
opal runtime package retains current resource group thread passes capability group hidden argument server calls thread change current resource group call runtime system 
resource groups intended basis resource control policy quotas billing encourage require users applications limit resource consumption 
addition support bulk deletion group related resources 
useful backup reclamation mechanisms fail untrustworthy 
example resource groups free resources counts held particular software entity longer exists 
resource groups nested allow finer grain control accounting resource management 
holder resource group capability create delete subordinate resource groups subgroups 
set resource groups collection trees 
accounting charges flow tree resources allocated subgroup charged parent ultimately users represented root 
deletion privileges extend tree holder resource group capability delete descendent resource group releasing resources held resource group 
example new subgroup created run untrusted procedure deleted procedure returns 
way traditional policy releasing resources held terminating process easily emulated resource ownership decoupled protection domains 
objects objects separate counts shared resource emanating different entities 
prevents non trusted thread releasing counts requested triggering early deletion shared resource 
objects internal implementation resource reflected interface resource 
example opal uses objects provide protected counts shared segments 
segment capability names segments indirectly object called 
may segment private count named separate capability 
thread capability may access underlying segment manipulate counts named capability 
serve purposes support restricted accesses cloned conferring read permission support selective revocation invalidated independently segment 
dangling despite counts software delete objects prematurely causing dangling various forms 
dangling capabilities detectable contain randomized bit check field 
system level dangling virtual addresses viewed access control problem 
programs granted access shared segment trusted correctly erroneous pointer result incorrect thread stored pointer thread followed pointer thread deleted pointer target 
user code responsible available mechanisms including protection domains segment access control protect damage caused failures untrusted threads 
summary section described basic opal abstractions protection domains segments portals resource groups 
mechanisms support applications structured groups threads overlapping protection domains communicating shared virtual storage protected procedure call 
virtual address pointers resource capabilities freely shared 
resource reclamation handled explicit counts backed bulk delete resource groups enforced accounting reflects view reclamation continue language level knowledge pointer structures application level knowledge usage patterns deletion data explicit user command 
key point section memory protection opal protection domains separated issues combined protection processes conventional systems 
protection decoupled program execution rpc basic mechanism animating passive protection domains resource naming context independent capabilities portals resource ownership resource groups virtual storage named segments global address space 
addition proxies protection boundary crossings rpc syntactically transparent applications 
intent choices memory protection cheaper easier easier change 
implementing opal prototype implemented pal prototype top mach microkernel operating system 
prototype major components opal kernel supports basic system abstractions segments protection domains portals resource groups coordinates usage address space 
standard runtime package supports application interface tailored language including user mode threads capability rpc proxies heap management 
set custom linking utilities statically link code modules execute permanently assigned addresses persistent virtual address space 
unix server node pager pag backing file re ted flush purge recycle opal server opal operations protection segment resource group domain task control ipc thad control mach microkernel organization mach opal prototype 
chosen implement kernel prototype server opal server built mach shown 
programs opal environment share single address space address spaces exist host 
chose path allow opal coexist unix implementation hosted mach 
unix utilities bootstrap monitor debug opal environment 
unix utilities linked runtime package bind opal server subset facilities create opal protection domains rpc calls create attach segments conflict addresses unix process 
prototype initially implemented bit system decstation mips ported bit dec alpha system 
mach microkernel building opal prototype straightforward process existing mach primitives 
single address space opal protection domain implemented task mach execution context threads 
opal segment implemented memory object mach abstraction virtual memory region backing storage managed user mode paging server 
opal applications mach primitives directly cause damage may inhibit ability opal resources time 
opal programs calls runtime package opal server 
opal server maintains assignment virtual address ranges segments manages tasks memory objects relationships 
opal segments backed modified version standard mach paging server inode pager 
mach kernel handles paging operations opal segments making rpc calls server 
paging server represents backing storage segment inode structure implement files unix 
modified inode pager allow opal server backing files directly mach memory objects bypassing unix mmap exploit fact accessed ordinary unix system calls 
added enhancements opal backing file support backing files grow physically zero fill page faults recycled combined purge truncate operation associated segments reclaimed 
modified mach kernel support native portals 
naming resolving portals handled opal server runtime system simulates control transfers portals mach message passing facility 
opal server creates mach message port domain portals domain multiplexed sending messages single port 
transparent opal applications see standard interface rpc uniformly named portals 
standard runtime package standard opal runtime package includes support user mode threads synchronization locks condition variables 
user mode threads traditional reasons lightweight concurrency synchronization state idle passed shared domains 
thread package opal specific features 
synchronization objects locks shared lock object uniformly local cross domain synchronization sacrificing performance local case 
second thread scheduler adjusts processor usage domain processors move domains rpc calls returns 
thread package discussed detail feeley 
thread descriptors thread stacks allocated ordinary heap segments 
thread descriptors hold pointers additional thread specific state 
thread current resource group passed hidden argument server calls current memory pool heap allocations thread 
items retrieved changed runtime system call 
applications feature partition data structures multiple segments separate allocated resources groups needs access control resource control 
runtime system caches mappings mach ports 
thread attempts transfer control domain portal runtime system call opal server passing returns mach send right port domain 
runtime code caches association ordinarily resolves portal 
send right domain port child protection domain returned hidden result domain create operation need look mapping freshly created portals child domain 
opal server opal server creates protection domain initial data segment server attaches runtime system data structures including user mode thread scheduler structures manage rpc connections domains 
fresh domains returned server initial state standard runtime package attached loaded initial data segment initial portal mach port receive messages mach thread listening incoming calls port 
allows protection domains preallocated cached reduce latency new domain creation calls 
opal server keeps record containing status information segment domain indicating address range allocated segment mach port send rights underlying mach resources 
domain record doubly linked list pointers records attached segments 
attach detach operations simply modify list appropriately map segment memory object domain task assigned address 
segment records indexed global structure retrieve segment record virtual address resolving faults published segments 
prototype structure linear list intend splay trees implementations 
server maintains record resource group organized tree reflects resource group hierarchy 
resource group record holds list resources charged just domains 
deleting resource group causes subtree rooted resource group released 
persistence recoverability segments managed opal server may persist system restarts 
example linked code modules stored persistent segments 
backing files persistent segments stored synthesized names protected directory unix file system recovered 
opal capabilities segments resources continue valid restarts 
current prototype support crash recovery 
server retains address bindings backing files persistent address ranges propagate updates backing files guarantee consistent state crash 
support provided segment basis runtime package paging server 
support persistent memory persistent capabilities server address space management structures retained persistent segments rooted special segment statically determined virtual address 
structures recovered server restarted 
problem structures may contain mach port names transient resources tasks threads memory objects 
mach resources ports invalidated shutdown server rebuild mach kernel state rebind ports recovery 
support instantiation server distinct epoch represented value supplied boot time 
example epochs current epoch stored segment records checked attach segment records previous epoch memory object ports refreshed segment symbolic name 
linking described section opal code modules statically linked global address space shared called dynamically 
collection unix utilities including standard compilers build tools prepares code execution opal prototype 
shell script calls opal server allocate segment module linked invokes standard unix linker telling link compiled code run virtual addresses assigned newly created segment 
custom linking utilities called purify resolve postprocess linker output 
result unix file executable opal environment file installed directly backing file module segment 
purify utility examines instructions generated compiler possibly modifying instructions modes 
compilers mips ond represent oll os offsets bose register global pointer gp register 
different styles ore modified gp moy gp offset limited consumed foster 
purify removes modifies instructions thot gp register 
resolve cross module runtime resolving symbols imported list modules os 
oll cross module text ond ore represented determined 
simple ond resolved bind new versions imported modules os ore produced 
environments desiring rebinding provide indirect jump 
purified ond resolved module con protection ond directly 
prototype os module copy 
runtime block segment copies module block element ond module global pointer point newly block 
worth noting thot system con defer copy copy write ond step 
revisit issue section 
prototype limited multiple modules 
module hos pointer gp register cross module ond returns 
compilers instructions gp code computes os linker determined offsets pc 
ore determined ond ond restored memory module 
hove modified purify 
prototype uses gp oll entering hove gp register 
purify gp offsets modules ond modules runtime 
linked modules thot define ore conflicting gp offsets ore restricted module ot time 
summary section described prototype thot single environment con implemented microkernel system 
supports coexistence system environments os unix permitting bi ond existing 
ore currently extending prototype support distribution cluster 
trusted server thot nodes request os amber chose ol 
server provides memory 
cluster ond server memories ore viewed os server gool memory memory network disk 
distributing single address space raises issue coherency shared segments 
believe solutions problems coherency recoverability applied application level mix language support runtime support customized external paging servers 
solutions exist carter bershad operating system dictate single model coherency recoverability applications 
example collaborative applications need different models parallel programs 
alternative exploring uses coarse synchronization nodes fine grained synchronization threads node updates propagating local transaction logs stable storage caching sites network 
applications performance section discusses opal applications presents performance results 
opal features flexible protection simple shared memory mapped persistent storage useful range contexts believe particularly suited needs important growing class integrated software environments 
integrated environment collection software tools support users complex tasks cad case image processing physical modeling integrated application systems may large evolving protection crucial tools separately authored programs possibly running behalf different users tools share information efficiently 
opal prototype experiment integrated environments developed industry boeing software engineering researchers 
hypothesis private address space systems encourage poor structuring tradeoffs integrated applications causing loss protection performance 
applications restructured opal improve safety additional protection domains performance shared memory 
enhance ability scale range functions provide volume data manipulate 
describing boeing aircraft cad system order illustrate target application domain importance 
results experiment opal implementation mediators structuring paradigm integrated environments sullivan notkin 
experiment confirms shared memory significantly improve performance scalability integrated applications demonstrates compatible sound software engineering principles 
discuss performance underlying opal primitives describe experience layering opal mach microkernel 
boeing cad system opal prototype boeing high performance design systems group experimenting new database operating system technologies generation cad systems 
useful consider opal model matches boeing needs 
boeing current cad environment uses centralized relational database database describes aircraft parts indexes tens thousands geometry files 
boeing faces major problems cad system 
performance problems add precious design time cost verifying part fits spatial relationships take overnight demands scan parts database 
second system support anticipated order magnitude growth size data number engineers projects 
third difficult expensive extend functionally 
problems caused fundamental weaknesses structure current cad system 
boeing group charter prototype cad software pronged approach meeting boeing scale performance needs 
objectives directly store design information pointer structures database permit cad tools read structures bulk cache local memory navigate directly 
current relational system represents links key fields traversed associative lookups requiring repeated queries database server 
opal represents links ordinary virtual addresses processed directly programs interpreted directly hardware 
explicitly represent commonly needed parts relationships spatial functional database 
cad tools added current system rebuild internal structures parts records time run structures match predefined database schema 
opal permits storage sharing arbitrary program generated data structures making easier cache reuse intermediate results computed tools 
share cached information cad tools workstation reduce copying communication overhead 
current tools communicate reads writes shared database unnecessarily loading network server 
sharing difficult tools convert data process private pointer structures 
opal allows structures shared preserving meaning embedded pointers 
boeing cad system example large integrated application pointer rich data structures 
believe support afforded existing operating systems inadequate kinds database applications 
efforts support applications focused extensible object oriented database systems dbs number commercial products market 
general oodbs convert object ids virtual addresses data moves database 
opal virtual addresses database format object ids necessary course prohibited 
case key point virtual addresses directly stored database opal facilitates sharing single copy active data node resulting efficient memory database bandwidth possible current oodbs built private address space systems 
similar respects cricket database system shekita allows cad tools directly map shared database fixed virtual addresses 
essence opal generalizes cricket model entire operating system distinction database transient virtual memory protection domains prevent tools viewing modifying specific parts database 
isolation non trusting tools essential mapped databases safely 
structuring integrated tools boeing cad system shares key problem integrated design environments shared database containing source objects modified efficiently propagate source producer 
decon posed configuration protection 
read protected calls data returned read ized reply message 
mediator producer read overlapping configuration read access producer read write access 
configurations tree indexing program built mediators 
changes tools maintain local structures derived sources 
boeing environment source objects aircraft part records derived objects belong tools doing simulation spatial analysis 
today tools repeatedly copy database records source objects messages pipes scanning records reconstructing local objects derived records 
opal wish access source parts shared memory updating derived objects incrementally rebuilding due large size 
approach significantly improve performance 
integrating independent tools way quite complex 
tools assumptions format input adhere standards format output 
standards necessary regardless tools communicate richness shared pointer structures force compromises independence tools 
contrast stream oriented unix programs awk grep combined unanticipated ways exchange unstructured streams bytes 
independence tools achieved cost data copied tool format conversion necessary incremental change supported 
wish support similar interactions tools larger richer information structures cost converting copying lowest common denominator interchange formats 
mediators implemented framework facilitate kinds tool relationships variant mediators sullivan notkin 
mediators solve integration problem reduce complexity 
idea mediators knowledge inter tool dependencies factored tools separate components mediators coordinate behaviors tools 
integrates tools allowing evolve independently 
tools communicate implicitly announcing events updates occur 
events announced data producing tools received mediators acting behalf data consuming tools mediators series calls tools propagate updates 
tools mediators thought modules private data executing variety different protection configurations 
calls announce propagate updates may ordinary procedure thousands byte records decomposed overlapping execution time configurations tree indexing program built mediators 
calls protected procedure calls depending protection relationship components involved 
structure depicted 
opal mediator package includes runtime support protected event manager 
tools register event manager specifying events announce capabilities segments containing procedures data related events 
mediators register event manager specifying events wish receive 
event manager sets appropriate connections attachments tools mediators 
mediator implementation test system built demonstration purposes mediator paradigm implement interesting systems program restructuring griswold notkin computer aided geometric design mccabe radiotherapy planning 
example structuring opal mediators opal applications built mediators transparently configured different protection arrangements including overlapping protection domains shared memory 
illustrate structuring options performance implemented simple mediator application 
source tool producer repeatedly creates deletes fixed size records maintaining tree index records announcing events inserts deletes 
derived tool consumer maintains uses index structure data mediator keeps derived index date response changes producer 
asymmetric trust relationship exists tools producer isolated mediator consumer trust producer supply formed input data 
shows performance application function number records processed protection configurations 

monolithic 
tools mediator share protection domain simulating single unix process sacrificing safety 

decomposed 
non overlapping domains producer consumer mediator rpc domains simulate separate unix processes sacrificing performance 

overlapping 
opal domains 
mediator domain producer data code segments attached read consumer data segments attached read write 
event source domain calls mediator domain rpc passing address changed elements shared segment 
confirms performance benefits sharing environment 
overlapping organization safe fully decomposed configuration nearly fast monolithic configuration 
furthermore performance advantage relative decomposed configuration increases amount shared data increases 
key points example read shared memory natural efficient alternative pipes files rpc read shared memory preserves way isolation provided pipes scratch files programs structured mediators easily adapted run overlapping protection domains 
fact configurations tree indexing program built source code shared memory completely invisible program 
addition complete separation modularity protection interactions procedure calls clean modular interfaces 
overlapping protection domains exist ver top interfaces representing different trust relationships 
example event signal producer mediator crosses module protection boundaries update call mediator consumer crosses module possibly protection boundaries source object read call mediator consumer producer crosses module protection boundaries 
prototype performance previous section measurements opal application demonstrate performance advantages arise sharing protection supported opal 
take look performance specific opal primitives opal prototype running mach mk uk digital alpha processor dec axp mhz 
purpose demonstrate build single address space operating system top conventional microkernel mach case performance competitive environments supported kernel unix 
put effort tuning point objective building prototype implement opal environment rapidly experimentally investigate match opal abstractions design applications just described 
cost certain opal primitives varies widely opal server caches segments protection domains meet needs 
creating new segment scratch takes ms current prototype 
time goes creating segment backing file inode segment involves writes disk 
reduce cost opal inodes assuming recycle list non empty segment creation time time expect applications typically see 
performing attach detach opal segment takes best case 
fifth cost underlying mach vm map vm deallocate operations remainder cost rpc calls opal server small amount internal processing allocate address space record attachment 
performance opal domain operations 
previously stated opal domains cached server cached domain allocated called destroyed ms majority time spent destroying domain domain create call takes destroy little ms high destroy penalty results purging recycling domain data segment requires disk writes due unix file system 
cached domains available creating domain scratch calling destroying substantially requiring ms compares favorably time fork exec exit wait null unix program mach unix ms 
underlying mach unix fork wait ms operation dec osf monolithic unix kernel takes ms hardware 
gives indication cost building system environment mach measure performance 
importantly cost opal cross domain call compares favorably cross address space calls mach systems bershad 
includes small cost incurred runtime support password capabilities built mach rpc 
mach support opal implementing opal kernel mach server clearly entails performance loss compared kernel level implementation unix identify major costs 
mach virtual memory system designed private address spaces separate translation map domain global hashed page directory hp huck hays system better suited opal single address space 
second prototype support native portals start mach kernel thread new domain block port represents roughly cost preparing domain 
third opal memory segments potentially sharable persistent requires backed external paging server zero fill page faults segment deletes somewhat expensive virtual memory unix mach 
mach thread interface basis user mode thread package scheduler activations anderson 
points gleaned mach experience performance data opal primitives performance reasonable absolute sense add significantly cost underlying mach abstractions implemented 
significant hidden costs single address space model 
course achieve substantial performance improvements mach prototype building native opal kernel implementation reduce existing overheads current implementation straightforward understood optimization techniques various system levels 
case expect applications ultimately perform better environment due ease direct memory sharing simplified persistent storage 
issues single address space approach previous sections shown opal structure expands choices protection sharing applications exploit flexibility 
benefits arise part virtual addresses unambiguous global interpretation single address space 
section discuss tradeoffs inherent pure single address space approach 
general tradeoffs related inability context dependent addressing single address space systems 
private address space systems benefit assignment different meanings address 
virtual contiguity single address space programs free select addresses segments create 
particular segments grow segments allocated different times contiguous address space 
loss contiguity generally problem programs written high level languages limit data structures assume contiguity 
programs indexed memory structures arrays request segments large store structures contiguously system impose limits amount address space preallocated allow structures grow 
scheme limits maximum segment size truth maximum segment size limited current bit systems fact current operating systems limit maximum virtual space fraction gigabyte architectural limit full bit address space 
single address space system easily provide larger segments today private address spaces 
conserving address space opal manages virtual address space global system resource 
physical resources disk space system ensure address space fairly needs users met 
requires accounting quotas resource groups system deny request satisfied available address space 
restrictions visible practice hardware address space large meet legitimate needs 
answered question address space goal define evaluate single address space structure assumption wide address processors soon provide virtual address space approach constraining applications 
address space limited system conserve recycling address ranges released 
address recycling occur levels 
example heap managers recycle heap slots segment conserve physical memory virtual address space 
case dangling affect entities heap segment 
operating system reclaim segment reassign entity retained original segment erroneously attempt pointer reassigned segment 
class dangling erroneous address handled access control mechanism 
dangling erroneously generated permit access memory memory lies segment attached current protection domain 
recycling necessary terabyte range virtual spaces implemented current wide address processors 
opal avoids recycling long address space large addresses recycled 
kotz crow compare address space allocation recycling policies single address space systems 
unix style fork unix fork operation copies parent process context including private address space child process 
address space cloning semantics fork emulated single address space unix implementation coexist opal general purpose microkernel unix built native opal kernel 
past reasons fork clone parent address space create multiple concurrent processes executing program allow code parent initialize state file descriptors child 
case lightweight threads better primitive concurrency second case system provide means initialize child executing code child context 
fact fork source complexity inefficiency unix systems majority state copied fork typically needed child inspiring efforts improve performance deferring copy copy write avoid entirely primitive bsd 
copying semantics fork interfere support threads mcjones swart 
opal replaces fork primitives create protection domains initialize attaching segments installing rpc endpoints 
threads parent domain cross domain calls enter child domain 
model suited environment software components cooperate period time contrast fork designed independently executing programs compute result terminate 
note unix programs fork directly capable running single address space environment 
data copying copy write objective single address space approach replace data copying memory sharing possible 
obviously instances copying eliminated 
particular data may copied create new version modified independently original protection reasons preserve original 
data copied address space internal pointers copied data translated 
conventional systems avoid translation data copied address space placing copied data virtual address range receiver process occupied sender 
course impossible process name versions 
possible single address space systems naming context copy occupy different virtual addresses original pointers handled specially 
furthermore conventional system lazily evaluate copy copy write single address space system 
single address space system pointers data relocated receiver read data receiver point wrong version copy copy copy write 
mentioned section absence remapped copying causes problems handling code modules opal prototype 
opal copy initial values writ able static data module loaded instantiated internal pointers relocated load time 
protection domain create time reported section reflects higher cost initializing code segments contain writ able static data 
appear copy write completely incompatible single address space systems assigning new address range copy introduces aliasing form multiple virtual mappings physical page 
copy write introduces benign form aliasing called read aliasing chao 
read aliasing hidden optimization violates consistent interpretation pointers interferes virtually addressed cache 
general aliasing cause synonym problem aliases separate entries virtually addressed cache entries may modified independently 
problem occur read aliasing write virtual address new physical address assigned destroying alias restoring unique mapping 
value cache line modified way affects value cache line 
read aliasing harmless single address space system copy write instance conventional system pointers copied data translated 
summary conclude tradeoffs single address space model reasonable sufficient hardware address space 
context dependent addressing useful acceptable better alternative exists 
furthermore context dependent naming may useful situations virtual addresses may wrong level apply context dependence context dependence appear higher levels naming interpreted software relative registers particular thread mapped single context independent virtual address space interpreted machine 
relation previous opal closely related style objectives number systems commercial experimental dating back years 
early description software system protection domains capabilities dynamic sharing appeared late dennis van horn systems tried implement approach 
believe opal significant exploits modern bit processors meet goals previous systems way simple general efficient 
particular opal requires special hardware supports uniform context independent naming memory address level includes persistent storage efficiently implemented compatible way alongside current operating systems current wide address processors 
opal embodies modern division responsibilities hardware operating system kernel system services language environment 
accommodates alternative language data models relies language facilities fine grained protection storage management 
section discuss previous systems contrasting opal concepts mechanisms goals 
multics segmented systems opal similar multics daley dennis segmented systems chang mergen groves medium grained virtual memory segments units memory protection access control emphasis dynamic sharing persistent storage 
opal differs multics segmented systems critical respect program addresses segmented systems uniform meaning complicates sharing 
multics segment global virtual address programs global addresses directly 
process sharing segment maps segment private address space different virtual location different segment register 
result processes easily share exchange addresses procedures include indirect addressing structures manage multiple address assignments shared data segments operate 
general traditional mapped file systems operate way 
contrast opal segments including persistent segments simultaneously directly visible proper protection virtual memory applications 
linked data structures opal easily span segments different access controls 
respect opal closer hp pa risc lee supports traditional segmented addressing allows applications global virtual addresses directly 
software pa risc uses short form addresses compact efficient permit backward compatibility private address space operating systems 
cedar pilot xerox pilot redell cedar swinehart systems support single virtual address space applications execute 
pilot includes mapped file system 
protection single safe programming language protection provided necessary hardware level 
agree safe languages permit relaxation hardware protection wish exploit fact opal 
want support multiple safe unsafe languages stronger isolation want need 
capability architectures opal goals similar ways capability hardware systems fabry levy 
example intel organick emphasized uniform addressing basis supporting sharing cooperation 
fact addressing fully uniform due part way processor address space managed capabilities contained address bits translated bit uids pollack objects moved memory persistent storage 
second complex hardware protection structures mechanisms restrict access fine grained objects 
opal require special hardware support object addressing protection opal protection coarser granularity similar architectures 
believe capability systems suffered things insufficient underlying hardware base 
underlying virtual address space physical hardware small result emulation level large address space system small address space machine 
ibm system ibm ibm grained similar opal protection model granularity 
access uniformly addressed medium grained segments shared multiple protection domains 
different access shared user objects generally occurs unprotected procedure calls cross domain calls 
system provides memory level hardware support tag bits word capabilities 
key difference opal uses stock bit processors gain benefits capability systems costs 
performance generality comparable standard page systems improved support sharing 
object operating systems languages early object operating systems hydra wulf eden clouds support operating system objects addressed capabilities 
objects eden clouds coarse grained meaning implemented separate virtual address spaces object encapsulation enforced hard protection boundaries 
sys tems conceptually support single global address space objects capabilities address space exists higher level virtual addresses prohibiting fine grained low cost data sharing communication objects 
fact prohibition goal systems 
believe coarse grained object oriented systems confuse modularity protection way excludes useful structuring choices 
specifically objects seen equivalent protection domains systems 
opal objects lightweight data items independent protection domains opal domain may contain objects objects passed shared domains 
furthermore programmers move protection boundaries objects achieve desired balance protection performance affecting modular structure program 
object distributed languages emerald jul guide provide lightweight support fine grained objects distributed global address space 
global address space exists object id level translation addresses required communication storage 
furthermore systems require applications written single safe language 
languages run opal benefit flexible protection opal support sharing pointer data structures 
monads monads rosenberg abramson rosenberg uses large bit shared virtual address space includes persistent data spans local network 
common goal monads opal remove distinction persistent data transient data 
monads partitions global address space network nodes locate distributed pages keep coherent 
monads demonstrates large sparse distributed address space manageable 
paged address space monads provides object addressing protection model supported custom hardware including capability registers 
monads purpose single address space streamline implementation capabilities extend capability space network 
monads differs opal key respects opal programs fiat virtual addresses directly access determined protection domain memory protection pal segment grained object grained pal uses stock bit processors data model pal defined languages applications system 
psyche psyche system scott uses related concepts explore parallel programming protected global address space shared memory multiprocessors 
focus psyche building applications cooperating components different parallel programming models components partially isolated separate protection domains 
psyche realms enforce object style access data shared models part ensure model dependent operations acquiring lock handled correctly regardless component invokes 
contrast opal focuses domains protect shared information multi user operating system 
generally assume cooperating components programming model 
garrett extends psyche unix context adding memory mapped persistent storage dynamic linking shared code modules encapsulate shared data 
hybrid global private address space system addresses low processor address space separate mappings process large globally addressed region upper 
goal preserve backward compatibility unix fork supporting uniform addressing shared memory 
opal differs psyche views segments modules realms basic unit sharing 
part reflects emphasis heap programming languages code module operate data different segments 
example shared code modules shared abstractions data shared module shared data generally referenced language symbols shared global static data pointers 
approach simplifies aspects linking complicates code module operate private shared data 
swizzling swizzling method simulating large address space smaller address hardware translating pointers short inform long vice versa moved memory 
swizzling gained new popularity means supporting persistent store wilson lamb 
described section believe swizzling reserved exceptional cases relocating groups objects network address space 
crucial point data swizzled way memory shared virtual address space ultimately required allow applications share single copy data memory 
single address space greatly simplifies sharing 
alternative usage large address spaces researchers proposed single wide virtual address space reduce cost protection 
okamoto suggests mmu hardware uses current value pc determine memory access permissions 
druschel peterson points shared segments protected accidental error malicious hiding large address space 
idea generalized allow untrusted thread operate protected data intra domain protected calls lower cost rpc calls hardware enforced protection boundary 
opal model complementary opal implementation assigns segment addresses randomly current prototype 
opal applications gain protection different strength cost hardware protection domains 
described opal system single address space operating system targeted bit address space architectures 
key notions opal uniform interpretation addresses orthogonality addressing protection 
context independent addressing removes impediments sharing 
procedures data shared time requiring priori address space coordination 
protection domains independent addressing determine context thread executes access rights memory segments 
segments dynamically created dynamically shared capabilities passed directly virtual addresses memory message channels 
created segment persist system restarts available simply accessing data virtual addresses 
objective opal support growing important class applications consist highly interacting tools manipulating shared persistent database 
studied needs industrial application boeing environments require dynamic sharing tools prototyped mechanism manage sharing protection relationships 
applications opal system simplifies sharing communication persistence broadens choices available structuring computations data 
opal concepts common previous systems particular capability hardware systems object oriented operating systems 
systems tended overly complex slow 
believe problem caused applying heavyweight hardware operating system protection mechanisms fine grained user language objects 
opal provides protection leaves fine grained storage management languages runtime systems 
protection domains flexible ways provide added protection depending trusting relationships needs cooperating parties 
second problem faced previous systems insufficient addressing capacity underlying hardware base resulted additional level software translate long term global addresses short term virtual addresses 
final analysis systems emulating large address space small address hardware 
appearance risc microprocessors bit addressing believe level translation longer necessary 
continuing traditional operating system structures modern operating systems adding unnecessary complexity sense emulating small address space structures top large address architectures causing extra system layers 
demonstrated single address space system opal implemented alongside environments microkernel operating system modern wide address architectures 
permits experimentation single address space environment continue communicate existing tools 
initial experiments opal demonstrate system provide added performance added safety relative current implementation choices conventional operating systems 
kevin sullivan helping adapt mediators opal environment bob joe boeing 
jan built mach system base alpha brian bershad rich draves peter stout provided needed assistance mach 
ted romer implemented mips linking utilities simon modified alpha 
robert valerie koch julien dylan mcnamee stefan savage marc shapiro commented early versions 
brian marsh michael scott william garrett david keppel david kotz david redell thekkath john wilkes gave helpful advice 
norma smith helped typing author impaired tunnel syndrome 
project sor group inria group bull imag labs 
synchronization recovery actions 
proceedings nd cm symposium principles distributed computing pages august 
black lazowska noe eden system technical review 
ieee transactions software engineering se january 
anderson anderson pose wallace password capability system 
computer journal february 
anderson anderson bershad lazowska levy scheduler activations effective kernel support user level management parallelism 
cm transactions computer systems february 
bershad bershad anderson lazowska levy lightweight remote procedure call 
cm transactions computer systems february 
bershad bershad midway distributed shared memory system 
proceedings ieee computer conference february 
carter carter bennett zwaenepoel implementation formance munin 
proceedings thirteenth symposium operating systems principles pages 
acm october 
chang mergen chang mergen storage architecture programming 
cm transactions computer systems february 
chao chao mackey sears mach virtually addressed cache architecture 
usenix mach workshop proceedings pages october 
chase chase lazowska levy amber system parallel programming network 
proceedings th cm symposium operating system principles pages december 
atkinson chisholm persistent object management system 
software practice experience january 
custer custer inside 
microsoft press 
daley dennis daley dennis virtual memory processes sharing multics 
communications acm may 
dennis van horn dennis van horn programming semantics multiprogrammed computations 
communications acm march 
dig digital equipment maynard ma 
alpha architecture handbook 
druschel peterson druschel peterson high performance cross domain data trans fer 
technical report university arizona department computer science june 
druschel druschel peterson hutchinson decoupling modularity protection 
proceedings th international conference distributed computing systems june 
fabry fabry capability addressing 
communications acm july 
feeley feeley chase lazowska user level threads interprocess communication 
technical report university washington department computer science engineering march 
garrett garrett scott mccallum thomas wisniewski luk linking shared segments 
proceedings winter usenix january 
griswold notkin griswold notkin program restructuring aid software maintenance 
technical report university washington department computer science engineering september 
groves groves risc system processor architecture 
misra editor ibm risc technology pages 
international business machines 
hoffman ibm system support capability addressing 
proc 
th symposium computer architecture may 
huck hays huck hays architectural support translation table management large address space machines 
proceedings th annual international symposium computer architecture may 
ibm ibm 
application system technology 
international business machines 
jul jul levy hutchinson black fine grained mobility emerald system 
cm transactions computer systems february 
jacky sweeney unger prism radiation treatment planning system 
technical report university washington radiation oncology department october 
chase eggers architectural support single address space operating systems 
proceedings fifth international conference architectural support programming languages operating systems department computer science engineering october 
acm sigops operating system review volume 
kotz crow kotz crow expected lifetime address space ing systems 
proceedings cm conference measurement modeling computer systems sigmetrics 
technical report pcs tr dept mathematics computer science dartmouth college 
van rousset de design implementation object oriented strongly typed language distributed 
journal object oriented programming september 
lamb lamb landis orenstein weinreb objectstore database system 
communications acm october 
lee lee precision architecture 
ieee computer pages january 
levy levy capability computer systems 
digital press bedford massachusetts 
mccabe mccabe programming mediators developing graphical mesh environment 
master thesis department computer science engineering university washington 
mcjones swart mcjones swart evolving unix system interface support multithreaded programs 
technical report dec systems research center september 
mip mips computer systems sunnyvale ca 
mips rj microprocessor user manual edition 
mullender tanenbaum mullender tanenbaum design capability operating system 
computer journal 
okamoto okamoto shin maeda saito micro kernel architecture generation processors 
usenix workshop microkernels kernel architectures pages april 
organick organick programmer view intel system 
mcgraw hill 
pollack pollack kahn wilkinson imax object filing system 
proc 
th cm symposium operating systems principles december 
rede rede dalai lauer lynch mcjones murray purcell pilot operating system personal computer 
communications acm february 
rosenberg abramson rosenberg abramson monads pc capability workstation support software engineering 
proceedings th hawaii international conference system sciences 
rosenberg rosenberg architectural operating system support orthogonal persistence 
computing systems july 
rozier rozier armand herrmann leonard chorus distributed operating systems 
computing systems 
scott scott leblanc marsh multi model parallel programming psyche 
proceedings second acm sigplan symposium principles practice parallel programming pages march 
shapiro shapiro structure encapsulation distributed systems proxy principle 
proceedings sixth international conference distributed computing systems may 
shekita shekita cricket mapped persistent object store 
proceedings fourth international workshop persistent object systems design implementation september 
siewiorek siewiorek bell newell computer structures readings examples 
mcgraw hill book 
design small business data processing system 
computer september 
sullivan notkin sullivan notkin reconciling environment integration software evolution 
acm transactions software engineering july 
swinehart swinehart zellweger beach hagmann structural view cedar programming environment 
cm transactions programming languages systems october 
wilson wilson pointer swizzling page fault time efficiently supporting huge address spaces standard hardware 
acm sigarch computer architecture news june 
university illinois chicago technical report uic eecs december 
wulf wulf levin pierson 
overview hydra operating system development 
proceedings th symposium operating systems principles pages november 
anderson anonymous rpc low latency protection bit address space 
proceedings summer usenix conference june 
young young tevanian rashid golub chew bolosky black baron duality memory communication implementation multiprocessor operating system 
proceedings eleventh acm symposium operating systems principles pages november 

