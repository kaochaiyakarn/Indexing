counting garbage collector java yossi levanoni erez petrank counting naturally suitable running multiprocessors 
update pointers counts requires atomic synchronized operations 
novel counting algorithm suitable multiprocessor require synchronized operation write barrier compare swap type synchronization algorithm ecient may compete tracing algorithm 
implemented algorithm sun java virtual machine ran way ibm net nity server mhz intel pentium iii xeon gb physical memory 
turns algorithm extremely low latency throughput comparable mark sweep algorithm original jvm 
keywords runtime systems memory management garbage collection counting 

automatic memory management acknowledged important tool fast development large reliable software 
turns garbage collection process important impact runtime performance 
amount time takes handle allocation reclamation memory spaces may reach high running time realistic benchmarks 
clever design ecient memory management garbage collector important goal today technology 
microsoft 
done author dept computer science technion israel institute technology haifa israel 
email microsoft com 
dept computer science technion israel institute technology haifa israel 
email erez cs technion ac il 
research supported coleman cohen academic fund technion fund steiner research fund fund promotion research technion 
automatic multiprocessor concentrate garbage collection multiprocessor machines 
multiprocessor platforms quite standard server machines gain popularity high performance desktop machines 
studied garbage collection algorithms suitable multiprocessor 
particular collectors collector supplied javasoft java virtual machine run single thread program threads stopped called world concept 
causes bad processor utilization hinders scalability 
order better multiprocessor concurrent collectors studied see example 
concurrent collector collector collection concurrently program stopping program threads 
concurrent collectors need program threads point collection order initiate nish collection time mutators halt short 
stopping threads collection expensive operation 
usually program threads stopped point 
stopped safe points collector safely determine reachability graph properly reclaim unreachable objects 
thread wait threads cooperate come halt 
hinders scalability system threads delay system su ers 
furthermore collector running parallel usually case time program threads stopped processors utilized 
advantageous collectors 
collectors program threads simultaneously 
thread cooperates collector pace mechanism called soft handshakes 
alternative adequate garbage collection multiprocessor perform collection parallel see example 
explore avenue 
counting multiprocessor counting intuitive method automatic storage management 
systems count ing implemented starting sixties 
main idea keep object count number object 
number zero object know reclaimed 
point added free list counter predecessors objects referenced object decremented initiating 
counting promising garbage collected systems 
especially spread bit architectures increase usage large heaps 
tracing collectors traverse live objects bigger usage heap amount live objects heap collector perform 
counting di erent 
amount proportional amount done user program collections plus amount space reclaimed 
depend space consumed live objects heap 
study counting multiprocessor extensive thorough study concurrent parallel tracing collectors 
reason counting seemingly inherent problem respect concurrency update counts atomic updated program threads 
furthermore updating pointer thread know previous value pointer slot updated spite writes occuring parallel 
confusion occurs bookkeeping counts 
naive solution requires lock update operation 
advanced solutions reduced overhead compare swap operation time consuming write barrier 
new counting garbage collector extremely ne synchronization 
particular avoid synchronization write barrier 
proceed overview novel ideas algorithm obtain advantage 
detailed precise description ideas rest 
algorithm deutsch bobrow deferred counting keep account changes local pointers stack registers keeping account expensive 
keeps account pointers heap denoted heap count 
garbage collection required collector inspects objects heap count zero 
referenced roots may reclaimed 
rst observation updates counts redundant may avoided 
consider pointer slot garbage collections assigned values objects heap 
updates counts assignments rc rc rc rc rc 
required rc rc 
building observation note order update counts objects garbage collection know pointer slots modi ed collections slot able tell value previous garbage collection current value algorithm keep record pointer slots modi ed 
keep old value existed slot rst modi ed 
may problem obtain value concurrent setting special care sure value properly registered 
synchronization operation 
denote algorithm resulting discussion far snapshot algorithm 
exact details snapshot algorithm section 
look collection 
naive implementation approach threads read values currently kept modi ed slots 
translates snapshot heap snapshot interesting elds heap 
approach allow full concurrency collector onthe sound 
order collector borrow ideas world distributed computing 
snapshot distributed environment computers distributed environment 
takes snapshot computer time snapshots recorded special care taken avoid confusion due non instantaneous view 
example messages computers recorded 
case similar solution 
take non instantaneous view interesting pointer slots heap checking slots special mechanism avoid confusion 
denote view heap sliding view 
sliding view algorithm brie described section 
due lack space provide details sliding view algorithm implementation details allocator mechanism proof correctness algorithm full 
cycle collection major disadvantage counting collect cycles 
chosen collect cycles mark sweep collector 
mark sweep algorithm run seldom collect cycles restore stuck counts 
bits count stuck counters created restored mark sweep algorithm 
novel mark sweep collector designed especially counting algorithm 
note quite natural base mark collector snapshot heap 
marking done snapshot view heap unreachable objects remain unreachable changes heap foil collection garbage 
adapt basic idea sliding view notion obtaining tracing collector perfectly tting setting 
elaborate mark sweep collector 
algorithm described full 
measurements throughput latency reported count collector run times mark sweep run seldom 
memory consistency algorithm requires sequentially consistent memory 
simple modi cations algorithm suitable platforms provide sequentially consistent memory 
encounter problems runs intel platform 
list modi cations required discuss cost section 
implementation implemented algorithm sun java virtual machine ran way ibm net nity server mhz intel pentium iii xeon processor gb physical memory 
standard java multithreaded benchmarks specjbb mtrt benchmark specjvm 
benchmarks described detail spec web site 
turns algorithm extremely low latency 
improves original jvm orders magnitude 
eciency jvm counting collector bits original jvm improvement running time mtrt benchmark 
specjbb allow large maximum heap target collector collector slightly improves running time original jvm 
smaller heaps original jvm better specjbb 
results section report measurements ran collector 
note throughput basically original tracing collector 
multithreaded mtrt benchmark collector improved throughput di erence running time 
specjbb collector throughput similar original collector 
terms latency got best reported results literature 
measure report reported specjbb maximum time takes complete transaction 
measure reported 
ran ibm jvm jit compiler collector gave similar maximal transaction times ms depending number threads assembler loop compilation incorporating collector jit compiler doubt improve transaction time substantially 
result result incomparable bacon bacon report exact pause times measured jalapeno jvm 
related traditional method counting rst developed lisp collins 
small talk awk perl programs 
improvements naive algorithm suggested subsequent papers 
studied delay introduced recursive deletion 
deutsch bobrow eliminated need write barrier local stack registers 
method adapted modula 
study reducing local variables 
works single bit counter mechanism handle ows 
idea objects singly referenced duration short transitions 
detreville describes concurrent multiprocessor counting collector modula 
algorithm adapts deutsch bobrow ideas deferred counting transaction log multiprocessor system 
update operation done inside critical section uses single central lock 
implies single update occur simultaneously system placing hard bound scalability 
fischer propose collection method counting architectures support explicit multi threading processor level 
method requires routine type cooperation program thread corresponding shadow collector threads probably suitable stock smps smp architectures support kind interaction natural ecient manner 
algorithms perform garbage collection snapshot heap appear 
terms synchronization requirements characteristics similar doligez leroy gonthier sense ne synchronization require full halt system mutators required cooperate times collection cycle 
tracing algorithm object sweeping method similar 
bacon independently bacon built counting algorithm appropriate multiprocessor 
presents big step making counting practical servers 
theirs closely related introduce onthe counting collector extremely low pause times elaborate relations collectors 
reducing synchronization 
naive approach multiprocessor counting requires swaps write barrier 
update pointer updates count 
detreville lock update sure pointer updates executed concurrently 
bacon signi cant step exploiting multiprocessor concurrency reducing number synchronizing operations single compare swap 
signi cantly reducing cost synchronization write barrier contains compare swap pointer update 
novel sliding view idea managed completely eliminate synchronization write barrier 
major improvement important contributions 
improving throughput possible compare throughput collectors run di erent platforms compared di erent base jvm 
collector demonstrate throughput comparable original sun jvm 
bacon report reduction throughput jvm compared original jalapeno jvm 
improving latency 
respect pause times measured results provided bacon incomparable 
bacon jalapeno jvm mea sure exact pause times 
unfortunately means get measure provided jalapeno jvm 
report output specjbb benchmark 
reports maximum time takes complete transaction 
results show excellent latency respect previous reports nature 
believe measuring maximum time transaction meaningful shortest garbage collection pause takes account slowdown imposed collector 
collector frequent short pause times collector slightly longer frequent pause times 
important issue concurrent incremental collection 
sequential memory consistency vs oating garbage 
algorithm requires sequential memory consistency 
explained section limitation overcome negligible cost 
algorithm run platform 
cost robustness oating garbage 
algorithm unreachable object collected unreachable consecutive collections 
memory coherence issue drag time objects increases signi cantly resulting substantial amount oating garbage compared collector 
collecting cycles 
papers take di erent avenues collecting cycles 
bacon rajan provide novel cycle detection 
algorithm run algorithm particular demonstrates entire collection run pure counting algorithm 
contrast approach chosen develop mark collector exploits sliding view mechanism uses data structure counting algorithm 
mark sweep collector run seldom order collect cycles restore stuck counts see 
mark sweep collector stand collector run counting algorithm interesting 
dicult compare eciency approaches algorithm run seldom comparison interesting 
note tracing collector allows saving space 
bits counts 
counts exceed value get stuck restored tracing collector 
bacon necessary keep counters correct mechanism restore corrupted counts 
space counter cache place objects counts exceed maximum allowed value 
organization section de nitions terminology rest 
section snapshot algorithm 
section sliding view algorithm 
section discuss adaptation algorithm platforms provide sequentially consistent memory section performance results 
conclude 
system model definitions garbage collection memory management reader referred 
assume reader familiar concepts heap object roots reachability note multithreaded environment thread roots top global roots 
fields objects heap hold called heap slots time just call slots 
count objects summing slots heap 
consider threads local stack registers count 
assume slots initialized null pointer 
denote count associated object rc 
coordination threads 
assume garbage collector thread may suspend subsequently resume user threads 
thread suspended collector may inspect change local state ects place thread resumed 
algorithm assume threads stopped execution protected code 
particular algorithm pieces code protected procedures update new charge updating heap slots allocating new objects respectively 

snapshot algorithm clarity presentation start intermediate algorithm called snapshot algorithm 
ideas required ecient write barrier synchronization 
intermediate algorithm threads stopped part collection 
length pause long bottle neck clearing bitmap dirty ags objects heap long hinder scalability multiprocessor 
section extend intermediate algorithm making idea section computing di erences heap snapshots 
algorithm operates cycles 
cycle begins collection ends 
describe collector actions cycle subscript denote number garbage collection cycle 
rst goal record pointer slots heap changed previous collection cycle 
mutators recording write barrier 
order avoid recording slots keep dirty ag slot 
mutator updates pointer checks dirty bit 
clear mutator sets dirty bit records slot local bu er 
recorded information address slot value current modi cation 
recording done local bu er synchronization 
collection begins collector starts stopping threads marking local objects referenced directly threads stack time pause 
reads threads local bu ers modi ed slots recorded clears dirty bits lets mutators resume 
mutators resume collector updates heap counts re ect values time pause 
recall heap count number object objects heap 
algorithm update justi ed remainder section 
assuming heap counts properly updated collector may reclaim objects counts drop procedure new size integer object 
obtain object allocator speci ed size 
add thread local zct 

new new fog 
return mutator code allocation procedure update slot new object 
local old read written cycle 
dirty keep record old value 

buffer hs 

dirty true 
write new mutator code update operation zero update marked local 
usual counts objects referenced reclaimed objects decremented reclamation proceeds recursively 
standard zero count table zct keeps track objects count drops zero time 
objects candidates reclamation 
object created zero heap count 
created objects put local zct creation 
code create routine appears 
remains discuss updating counts modi ed slots collection explained section slot need know object pointed pause collection object points pause collection values known collector decrements count increments count operation done modi ed slots counts updated match state heap kth collection pause 
go describe obtain addresses objects start obtaining race occured slot rst modi ed cycle write barrier recorded address local bu er 
value held rst modi cation 
suppose race occur threads trying modify code write barrier appears 
updating threads sets dirty ag thread reads dirty ag thread records address recording properly re ect value pause 
thread nds dirty bit clear 
looking code thread starts recording old value slot checks dirty bit 
hand actual update occurs dirty bit set 
thread detects clear dirty bit guaranteed value records value threads modi ed 
threads may record slot bu ers record correct information 
summarize procedure collection cycle 
read current state 
update counters 
read bu ers 
fix undetermined slots 
reclaim garbage collector code case race occurs possible threads record slot local bu ers 
record correct value st pause 
collecting local bu ers threads care taken avoid multiple records slot 
implementation details see full 
conclude address object properly obtained 
explain collector obtains address object pause collection note time collector tries obtain value threads running pause 
collector starts reading current value reads dirty ag 
ag clear modi ed pause collection done 
dirty bit set modi ed 
modi ed value pause currently recorded threads local bu ers 
value obtained searching local bu ers threads 
note threads need stopped bu ers 
know slot record changed collection 
collector operation 
state collector stops threads takes bu ers mark objects directly referenced roots local takes local zct including records newly created objects clears dirty marks 
threads resumed 
threads run collector updates counts excluding slots modi ed pause 
reads current bu ers threads stopping get information slots modi ed pause nish updating counts 
recursively reclaims objects zero count marked local 
correctness algorithm required mutators mutators middle pointer modi cation 
elaborate implementation issues 
discussion intermediate algorithm full code full 
main goal section explain write barrier avoids synchronization 
turn algorithm 

sliding view algorithm snapshot algorithm managed execute major part collection mutators run concurrently collector 
main disadvantage algorithm halting mutators collection 
halt threads stopped collector clears dirty ags receives mutators bu ers local 
halt hinders eciency processor executes rest idle scalability threads cause delays 
eciency enhanced parallelizing ags clearing phase scalability calls eliminating complete halts algorithm 
case second algorithm avoids grinding halts completely 
handshake synchronization mechanism thread stops time perform transaction collector 
algorithm uses handshakes 
mutators stopped time short interval duration depends size mutators local states 
snapshot algorithm xed point time mutators stopped computed counts objects 
easy claim object zero heap count time local time reclaimed 
dispensing complete halting threads longer xed point time 
picture system formalized notion sliding view essentially non atomic picture heap 
show sliding views atomic snapshots order devise collection algorithm 
approach similar way snapshots taken distributed setting 
mutator time provide view heap special care taken system sure information gathered modi cations heap foil collection 
scans sliding views pictorially scan corresponding sliding view thought process traversing heap advance time 
pointer slot heap probed time set value probed pointer 
object sliding view de ne asynchronous count respect number slots referring arc def jv sliding views obtained incrementally get bene having mutators simultaneously order compute view 
order information safely collect garbage need careful 
trying snapshot algorithm guaranteed logging determining re ects sliding view bound fail 
example object may move slot slot sliding view value reading modi cation reading modi cation 
avoid problems snooping mechanism 
view read heap write barrier mark object assigned new heap 
mark objects local preventing collected collection cycle 
recall objects directly referenced roots marked local prevent collecting zero heap count 
preventing collection snooped objects cycle 
assuming snooping mechanism scan heap observe 
observation object arc referenced pointer slot heap re ected sliding view object referenced directly roots threads scan completed object marked local snooping mechanism heap roots scanned time heap scan completed object unreachable may reclaimed 
proof idea object referenced heap slot scan slot pointing object scan heap read written slot 
cases fall criteria unreachable objects observation 
written heap roots scanned roots object unreachable 
rely fact mutator stopped reading stack pointer may move thread stack read furthermore java moved stack thread written heap 
full argument full 
keeping observation mind ready sliding view algorithm 
break description 
rst describe section sliding view heap may reclaim unreachable objects 
call generic algorithm may mechanism obtaining sliding view 
describe counts objects updated sliding view taken 
extension ideas snapshot algorithm preserving light write barrier 
sliding views reclaim objects observation generic garbage collection algorithm 
thread ag denoted snoop signi es collector midst constructing sliding view 

mutator executes write barrier order perform heap slot update 
generic algorithm requires store proper slot performed written slot thread probe snoop ag ag set mark local 
call probing snoop ag subsequent marking snooping 
speci implementation generic algorithm may require additional steps taken part write barrier 

usual threads may suspended midst update 

collection cycle contains stages 
collector raises snoop ag thread 
indicates mutators start snooping 

collector computes implementation speci mechanism scan corresponding sliding view concurrently mutators computations 
actual manner collector computes immaterial just important arrives sliding view 

thread suspended time snoop ag turned object directly reachable marked local 
thread resumed 

object rc arc 

point deduce object rc marked local garbage 
consider object arc marked local 
thread snoop ag set entire duration sliding view computation conclude true count heap scan zero 
may directly reachable thread time 
local observed thread state scanned stage collector snooped prior thread possessed local discarded prior responding handshake stage raising heap count zero 
conclude time handshake stage ends garbage 
snooping mechanism may lead oating garbage conservatively collect objects marked local objects may garbage cycle ends 
objects bound collected cycle 
termed algorithm generic mechanism computing sliding view unspeci ed 
algorithm updating counts implicitly de ned sliding view heap 
algorithm done holds object rc arc sliding view constructed implicitly 
interested sliding view manifestation rc elds implicit computation suces collection purposes 
obtaining sliding view handshakes collection cycle 
sliding view associated cycle spans rst handshake third handshake 
sampling timing individual slot scan determined mutators logging regarding slot 
snooping ags raised prior rst handshake turned forth handshake 
set entire duration scan adhering snooping requirement generic sliding view algorithm 
slot changed cycles logged value sliding view loss information regarding old values 
turns analysis inconsistent logging slots possible responding rst third handshakes cycle 
just fourth handshake collector employs consolidation mechanism consolidate inconsistently logged slot xed value 
thread log con icting value responding fourth handshake inconsistencies visible history cycle 
procedure update slot new object 
object old read 
dirty 
buffer hs 

dirty true 
write new 
snoop 
locals locals sliding view algorithm update operation addition collector slot logged rst third handshakes risk collector value slot consolidated value modi ed consolidation mechanism 
collector mutators agree values slots sliding view 
refer reader full version systematically de ne sliding view associated cycle prove properties 
algorithm code 
mutator code mutators write barrier snapshot algorithm additional snooping marking added store proper see procedure update gure 
object creation unchanged snapshot algorithm 
collector code go main steps collection cycle 
code step provided 

signaling snooping 
collection starts collector raising snoop ag thread signaling mutators start computing sliding view 

reading bu ers rst handshake 
handshake threads bu ers retrieved cleared 
thread bu ers rst snapshot algorithm 
slots listed bu ers exactly slots changed cycle 
sliding view scenario notion requires care 
meaning changing asynchronous setting de ned follows 
slot changed cycle thread changed responding rst handshake cycle responding rst handshake cycle 
steps carried procedure cycle gure 

clearing 
dirty ags slots listed bu ers cleared 
note clearing occurs mutators running 
step carried procedure marks gure 
step may clear dirty marks concurrently set running mutators 
want keep dirty bits set logging bu ers contain objects marked dirty rst handshake set procedure initiate collection cycle 
thread 
snoop true 
thread 
suspend thread copy duplicates 

hist hist buffer clear bu er 


resume sliding view algorithm procedure initiate collection cycle procedure clear dirty marks 
hs oi hist 
dirty false sliding view algorithm procedure marks dirty bits 

reinforcing dirty marks second handshake 
handshake collector reads contents threads bu ers contain slots logged rst handshake 
collector reinforces sets ags slots listed bu ers 

assuring reinforcement visible mutators third handshake 
third handshake carried 
thread suspended resumed action 
time threads resume know view correctly dirty bits 
slot dirty modi ed thread responded rst handshake 
steps executed procedure con ict set gure 

consolidation fourth handshake 
fourth handshake thread local states scanned objects directly reachable roots marked local 
threads bu ers retrieved consolidated 
procedure reinforce clearing con ict set 

thread 
suspend thread 
buffer 
resume thread 

dirty true 
thread 
suspend thread 
nop 
resume sliding view algorithm procedure reinforce clearing con ict set procedure consolidate 
local temp 
locals 
thread 
suspend thread 
snoop false copy clear snooped objects set 
locals locals locals 
locals copy thread local state zct 

locals locals state 
zct zct new 
new copy local bu er consolidation 

temp temp buffer clear local bu er 


resume thread consolidate temp hist 
hist 
local handled 
hs vi temp 
handled 
handled handled fsg 
hist hist fhs sliding view algorithm procedure consolidate procedure update counters 
undetermined 
hs vi pair hist 
curr read 
dirty 
curr rc curr rc 

undetermined undetermined fsg 
rc rc 
rc locals 
zct zct fvg collector code counters consolidating threads bu ers amounts 
slot appears threads bu ers accumulated rst fourth handshakes pick occurrence slot copy digested consistent history 
occurrences slot discarded 
digested history replaces accumulated threads bu ers 
history cycle comprised digested history threads logging rst fourth handshakes current cycle uni ed threads bu ers representing updates occur fourth handshake current cycle rst handshake cycle 
consolidation carried procedure consolidate gure 
updating 
collector proceeds adjust rc elds due di erences sliding views previous current cycle 
done exactly snapshot algorithm see gure 
collector fails determine current value slots modi ed procedure read bu ers 
peek 
thread 
local copy bu er duplicates 

peek peek buffer collector code procedure read bu ers procedure merge fix sets 
peek peek hist sliding view algorithm procedure merge fix sets dirty 
slots treated marked undetermined 

gathering information undetermined slots 
collector asynchronously reads mutators bu ers procedure read bu ers gure 
procedure merge fix sets gure uni es set read pairs digested history computed consolidation step 
set undetermined slots subset slots appearing uni ed set collector may proceed look values undetermined slots 

incrementing rc elds objects referenced undetermined slots 
procedure fix gure undetermined slot looked uni ed set rc eld associated object incremented 

reclamation 
reclamation generally proceeds previous algorithm recursively freeing object zero rc eld marked local 
careful reclaim objects slots appear digested history 
objects modi ed cycle commenced garbage ended 
reclamation objects deferred cycle 
reclamation carried procedures reclaim garbage gure collect gure 

memory coherence mentioned simple modi cations algorithm suitable platforms guarantee sequential memory consistency 
list modi cations discuss cost 
procedure fix undetermined slots 
pair hs vi pair peek 
undetermined 
rc rc collector code procedure slots procedure reclaim garbage 
zct 
object zct 
rc 
zct zct fog 
rc locals 
zct zct fog 
zct zct fog 
object zct 
collect collector code procedure procedure collect object 
local false 
foreach slot 
dirty 
true 

val read 
val rc val rc 
write null 
val rc 
val locals 
collect val 

zct zct 

return general purpose allocator 


zct zct fog sliding view algorithm procedure collect rst note platforms provide sequentially consistent view memory reads writes word 
furthermore guarantee provided generally coherence granule 
guarantee sequential consistency entity larger word memory 
coherence granule platform usually size cache line 
keep guarantee mind turn algorithm 
dependencies instruction ordering algorithm 
dependency write barrier reads writes dirty ag pointer slot executed order stated algorithm 
solve dependency note cases dirty bit pointer slot reside coherence granule 
implementation keep dirty bit header object 
need perform memory synchronization barrier objects dirty bit reside coherence granule modi ed slot 
furthermore write barrier begins check object dirty 
synchronization barrier required check validated object dirty 
cost reported study specjvm benchmarks implied results chilimbi larus objects small 
example median object size runs 
size cache line ranges depending platform 
furthermore measures show objects tested write barrier rarely turn dirty 
javac benchmark happens specjbb benchmark specjvm benchmarks happens 
vast majority pointer updates require cost handling memory coherence 
summarize number actual pointer modi cations write barriers require synchronization overhead large objects dirty tiny expect see negligible impact running time 
dependency modi cation snoop ag 
assume modi cation snoop ag visible threads start rst handshake 
sure case add preliminary handshake cycle snoop ags raised currently done stopping threads 
cost done collection cycle negligible compared running time collection cycle running time program 
implemented modi cations witnessed problem caused reordering instructions intel platform 

implementation java implemented algorithm sun java virtual machine 
implementation done interpreter jit 
original modi ed jvm assembler loop modi ed take account write barrier modi ed object layout 
ran measurements way ibm net nity server mhz intel pentium iii xeon processor gb heap size mb score jbb original throughput units rc change jbb score maximal response original time milliseconds rc times rc responsive throughput latency counting collector original collector standard specjbb runs mb mb heaps 
threads original rc times rc responsive maximal response time milliseconds original jvm counting collectors series specjbb runs xed number threads run mb heap 
physical memory 
measured algorithm performance characteristics compared original algorithm jvm 
measured run collector client machine single pentium iii mhz mb physical memory 
standard testing suites specjbb 
benchmarks described detail spec web site 
target counting algorithm big heaps 
mb java heap jbb server benchmark 
bit worse results java heap size mb 
jvm client benchmarks mb heap 
server performance standard execution specjbb requires multi phased run increasing number threads 
phase lasts minutes ramp period half minute phase 
prior phase synchronous gc cycle may may occur discretion tester 
decided perform synchronous garbage collection believe defeats capturing real world scenarios server chance ine behavior 
results averaged standard runs 
shows throughput latency counting algorithm compared original jvm essentially retain throughput attained original jvm improve maximal response time orders magnitude 
illustrate original jvm may take long seconds complete jbb transaction require milliseconds 
get measurements latency checked latency function number threads ran specjbb 
compared response time original jvm counting collector 
non standard run benchmark reported 
threads time completion improvement seconds original rc time completion seconds mtrt benchmark varying number threads 
threads original rc mb allocated specjbb run xed number threads heap mb 
second benchmark mtrt multithreaded ray tracer 
benchmark measure response time elapsed running time corresponds jvm throughput 
seen gure counting collector outperforms original jvm improvement total running time 
measurements heap consumption 
reason increased consumption counting algorithm lack compaction yielding fragmentation space required dirty bit implemented extra pointer object refer full details 
move objects compaction get waste back joining object handle getting rid handle pointer object 
addition space occupied directly objects allocate memory operating system data structures zct implement zct bitmap potential object address having associated bit bitmap 
object alignment bytes zct requires sixteenth heap 
snoop local marks similarly mark objects snooped bitmap requires additional sixteenth heap 
counters counters implemented bitmap associates potential object address bit counter 
bitmap requires additional eighth heap 
bu ers local update bu ers snoop bu ers allocated pool bu ers 
xed bu er size kb usually working set bu ers didn exceed simultaneously allocated bu ers amounts mb additional memory 
client performance benchmark time completion seconds original rc total compress db jack javac jess mpegaudio elapsed time execution entire specjvm suite intermediate execution time double run suite members 
measurements seconds 
targeted collector multi processor environments wanted verify single processor setting 
specjvm benchmark suite 
suite test harness performing standard automated runs benchmarks suite 
standard automated run benchmark ran twice benchmarks ran jvm 
shows elapsed time entire automated run time double run benchmark 
seen gure counting collector percent slower original jvm 
pay overheads concurrent collection re bene ting availability multiple processors results 
collector characteristics include measurements collector characteristics 
due lack space mention couple brie measured number objects reached stuck count rc 
recall keep bits count object rc increased considered stuck 
count resolved run mark sweep collector 
turns benchmarks happens objects 
compress javac mpegaudio number higher objects 
stuck pointers cycles prevent counting collector collecting dead objects 
check effectiveness collector 
javac uses cyclic structures lesser degree db benchmark benchmarks demonstrated low degree sensitivity counting 
supports assumption may counting garbage collection cycles occasionally resort tracing 

novel counting garbage collector low latency high throughput 
algorithm uses extremely low synchronization overhead barriers modifying barrier creating new object short particular require standard run requires running harness web server performed tests directly disk 
aside executions standard 
benchmark reclaimed reclaimed tracing rc jbb compress db jack javac jess mpegaudio percentage objects reclaimed original collector counting collector backing mark collector 
strong synchronized operations compare instruction 
furthermore particular point threads suspended simultaneously 
thread cooperates collector shortly suspended times collection cycle 
implemented collector sun java virtual machine measurements showing excellent latency throughput comparable original mark sweep compact collector 

acknowledgment hillel kolodner helpful discussions 

alfred aho brian kernighan peter weinberger 
awk programming language 
addison wesley 
andrew appel john ellis kai li 
real time concurrent collection stock multiprocessors 
acm sigplan notices 
bacon attanasio lee rajan smith 
java ee breaks nonintrusive multiprocessor garbage collector 
appear acm sigplan conference programming language design implementation pldi snowbird utah june 
bacon rajan 
concurrent cycle collection counted systems 
appear fifteenth european conference object oriented programming ecoop university os budapest hungary june 
henry baker 
list processing real time serial computer 
communications acm 
henry baker 
minimising count updating deferred anchored pointers functional data structures 
acm sigplan notices september 
hans juergen ohm alan demers scott shenker 
parallel garbage collection 
acm sigplan notices 
chikayama kimura 
multiple management flat ghc 
iclp pages 
chilimbi james larus 
generational garbage collection implement cache conscious data placement 
proceedings international symposium memory management volume acm sigplan notices october pages 
george collins 
method overlapping erasure lists 
communications acm december 
jim 
garbage collection algorithm shared memory parallel processors 
international journal parallel programming 
john detreville 
experience concurrent garbage collectors modula 
technical report dec systems research center palo alto ca august 
john detreville 
experience garbage collection modula topaz environment 
oopsla ecoop workshop garbage collection object oriented systems october 
peter deutsch daniel bobrow 
ecient incremental automatic garbage collector 
communications acm september 
sylvia urs 
study allocation behavior specjvm java benchmarks 
proceedings european conference object oriented programming ecoop lecture notes computer science springer verlag june 
peter deutsch daniel bobrow 
ecient incremental automatic garbage collector 
communications acm september 
dijkstra leslie lamport martin scholten ste ens 
garbage collection exercise cooperation 
communications acm november 
damien doligez georges gonthier 
portable unobtrusive garbage collection multiprocessor systems 
popl 
damien doligez xavier leroy 
concurrent generational garbage collector multi threaded implementation ml 
popl 
elliot kolodner ethan lewis elliot katherine itai yossi levanoni erez petrank igor 
implementing garbage collector java 
international symposium memory management october 
endo akinori yonezawa 
scalable mark sweep garbage collector large scale shared memory machines 
proceedings high performance computing networking sc 
satoshi matsuoka akinori yonezawa 
parallel conservative garbage collection fast allocation 
paul wilson barry hayes editors oopsla ecoop workshop garbage collection object oriented systems 
adele goldberg robson 
smalltalk language implementation 
addison wesley 
goto kimura nakagawa chikayama 
lazy counting incremental garbage collection method parallel inference machines 
iclp pages 
robert halstead 
multilisp language concurrent symbolic computation 
acm toplas october 
maurice herlihy eliot moss 
non blocking garbage collection multiprocessors 
technical report crl dec cambridge research laboratory 
richard jones rafael lins 
garbage collection algorithms automatic dynamic memory management 
wiley july 
elliot kolodner erez petrank 
parallel copying garbage collection delayed allocation 
technical report ibm haifa research lab november 
available www cs princeton edu erez publications html 
yossi levanoni erez petrank 
scalable counting garbage collector 
technical report cs technion israel institute technology november 
available www cs technion ac il erez publications html 
james miller epstein 
garbage collection 
japan workshop parallel lisp lncs pages june 
james toole scott nettles 
concurrent replicating garbage collection 
lfp oopsla workshop memory management garbage collection 
young park benjamin goldberg 
static analysis optimising counting 
ipl august 
charles fischer 
concurrent garbage collection program slices multithreaded processors 
ismm 
david roth david wise 
bit counts unique sticky 
acm sigplan notices pages october 
acm press 
ran elliot kolodner mooly sagiv 
ectiveness gc java 
international symposium memory management ismm 
guy steele 
multiprocessing garbage collection 
communications acm september 
guy steele 
multiprocessing garbage collection 
communications acm september 
standard performance evaluation www spec org stoye clarke arthur norman 
practical methods rapid combinator reduction 
lfp pages august 
larry wall randal schwartz 
programming perl 
reilly associates 
weizenbaum 
symmetric list processor 
communications acm september 
david wise 
bit counting 
ipl july 
david wise 
bit counting 
technical report indiana university computer science department march 

real time garbage collection general purpose machines 
journal software systems 
