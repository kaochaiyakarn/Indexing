structured theory development mechanized logic matt kaufmann strother moore march experience shown large multi user interactive proof efforts benefit significantly structuring mechanisms available modern programming languages 
mechanism allow lemmas definitions exported 
address structuring mechanisms acl theorem prover encapsulation books 
presenting acl justifies implementation acl structuring mechanisms generally formulates proves high level correctness properties acl 
issues relevant acl theorem proving environments 
overview modern programming languages provide convenient features principle computations performed turing machines 
analogy mechanized logics include convenient features conventional mathematical logics example order logic provide firm foundation formal reasoning 
particular experience shown large multi user interactive proof efforts benefit significantly structuring mechanisms available modern programming languages 
supported part computational logic defense advanced research projects agency arpa order office naval research contract 
views contained document author interpreted representing official policies expressed implied eds university texas computational logic defense advanced research projects agency office naval research government 
eds cio services san blvd suite austin tx kaufmann cio eds com dept computer sciences university texas austin austin tx moore cs utexas edu provide structuring mechanisms implemented acl theorem prover 
similar mechanisms appropriate theorem proving systems 
predecessor nqthm acl system supports development order theories 
users introduce axioms way extension principles usually definitions establish provability alleged axioms axioms 
nqthm acl theorem prover provides powerful structuring mechanisms allow user designate certain definitions lemmas local exported specified scopes 
mechanisms concert offered acl challenge formalize structuring mechanisms really mean 
fact unsoundness early versions acl failure understand subtle aspects structuring mechanisms 
give way understand acl session means terms order logic 
rest proceeds follows 
give reasonably brief overview acl particular structuring mechanisms subject 
section provides acl prerequisites rest prior knowledge acl assumed 
section provides informal proof main result alleged theorems theorems 
presentation logical preliminaries section somewhat new treatment recursion induction section 
treatment explaining acl structuring mechanisms sound 
section introduces crucial notion history proves important properties histories 
section introduces notion chronology demonstrates theorems chronology consequences axioms 
tie things section showing acl sessions correspond chronologies 
particular session theorems order consequences axioms consequence modulo obvious restriction session order theory consistent 
appendices address technical points deferred main exposition 
appendix proves correctness functional instantiation backdrop histories 
correctness statement encompasses optimization acl implementation encapsulate structuring mechanism 
appendix proves relevant technical result skolemization 
preliminary direction 
stand contrast lower level presentation provided lay syntax acl particular logic suited reasoning quantification 
consider important issues including packages macros 
higher level abstraction assuming familiarity classical order logic ignoring syntactic extra logical issues 
issues relevant computational logic applicative common lisp acl theorem proving environments 
prerequisites 
assume familiarity acl common lisp providing necessary background section 
assume basic familiarity order logic 
conventions 
definitions notation proofs lemmas theorems conclude symbol 
proof obvious symbol appears immediately statement lemma theorem 
sequences finite sequences 
typewriter font display actual syntax font indicate meta variables stand syntax mathematical entities syntactic elements 
example function symbol cons appearing set sentences 
acknowledgments 
bob boyer played major role development acl years 
gratefully acknowledge numerous contributions design implementation 
virtually implementation related done friendly environment computational logic eds graciously provided kaufmann time away year project 
acl acl stands computational logic applicative common lisp 
name mathematical logic applicative common lisp mechanized theorem proving system logic 
acl closely related boyer moore logic system interactive enhancement 
key reason abandoned nqthm logic adopted applicative common lisp result extremely efficient runtime code 
acl logic kernel acl logic consists syntax rules inference axioms 
kernel logic precisely 
logic supported mechanized acl system extension kernel logic 
kernel syntax describes terms composed variables constants function symbols applied fixed numbers argument terms 
fact term written theta 
traditional syntactic systems 
introducing lisp terms kernel logic introduces notion formulas composed equalities terms usual propositional connectives 
quantifiers 
rules inference propositional calculus equality instantiation induction principle extension principles allowing definition new total recursive functions new constant symbols new symbol packages declaration current package resolution naming conflicts 
extension principles specify conditions proposed extensions admissible 
example recursive definitions proved terminate 
admissibility requirements insure consistency resulting extensions 
acl axioms describe properties certain common lisp primitives 
example axioms 

equal 
equal nil nil 
nil 
function symbols equal possible embed propositional calculus equality term language logic 
write term formula expected abbreviation formula nil 
axiom car cons 
equal car cons mean axiom 
equal car cons nil provably equivalent axiom 
car cons similarly feel free write denote term formula obtained applying function symbol term formally axiom 
nil 
kernel logic includes axioms characterize primitive functions constructing manipulating certain common lisp numbers characters strings symbols ordered pairs 
consider theories extend certain order theory gz 
theory assumed contain axioms kernel logic mentioned analogous cdr cons cdr place car guaranteeing ordered pair operation cons 
contains axioms described section notably founded induction principle 
notice axioms imply nil 
logic supported acl system somewhat richer kernel logic 
full logic obtained kernel syntactic extension syntactic restrictions inclusion new extension principle called encapsulation derived rule inference called functional instantiation inclusion new extension principle called 
syntactic extension provided incorporation common lisp notion macros new syntactic forms implemented functions translate forms terms kernel syntax 
syntactic restrictions syntactic limitations certain primitives allow efficient execution 
example functions returning multiple values return correct number kernel logic bundle values just list insufficiently long bundles effectively padded nils 
encapsulation functional instantiation subject 
feature discussed essentially allows universal existential quantifiers 
acl system acl system presents user read eval print command loop 
basic commands define new functions constants packages designate package current 
commands correspond extension principles kernel logic 
time command executed current order theory extended 
commands called events 
sample event command shown 
command defines function named app 
immediately command show system text output response 
response mainly concerned admissibility requirements recursive definitions 
defun app concatenate lists cons car app cdr admission app trivial relation ord 
known founded domain recognized measure acl count 
observe type app described theorem app equal app 
primitive type reasoning 
event command directs acl system prove theorem successful build theorem system data base 
command prove app associative 
proof shown successful theorem built left right rewrite rule 
associativity app equal app app app app rule classes rewrite loosely speaking record successful event commands called chronology session 
commands allow user display parts chronology undo commands roll back chronology prior setting 
example cryptic command 
undoes back command restores system initial state 
acl system supports constrained new function symbols 
possible introduce new symbol constrained satisfy certain axioms providing definition uniquely determines function behavior 
insure constraints satisfiable user provide witness existing function proved required properties 
mechanism accomplished acl called encapsulation 
certain sense logical underpinnings encapsulation underpinnings sufficiently subtle caused introduce soundness bugs versions acl prior construction careful arguments 
example encapsulation 
suppose chronology time command executed called ff 
encapsulate execute signatures execute local defun execute witness execute local defun null witness execute constraint execute implies preserves execute signatures declare encapsulate command introduce function symbols execute takes argument returns result 
forms local define execute identity function null return nil argument nil 
events local sense axioms added relevant admissibility analysis encapsulate axioms provide alleged witnesses constraints placed new symbols 
event encapsulate event asserts execute preserves 
locally event admissible provided proved 
proof trivial witnesses 
theorem constraint new symbols 
encapsulation command admissible constrained symbols new local non local events body encapsulate admissible witnesses satisfy constraint non local events locally defined symbols constrained ones 
admission analysis extension ff containing local non local events produced 
admissibility requirements met extension interest 
effect encapsulate produce extension ff execute syntactic signatures axiomatized satisfy formula named execute 
roughly speaking constraints encapsulate non local events 
example constraint execute new functions constraints 
local events exported encapsulate encapsulate simply structure proofs 
example declare function signatures prove series local lemmas leading desired theorem 
effect encapsulation add desired theorem consistent axiom cluttering acl data base lemmas necessary prove 
return example encapsulate 
event admitted user issue additional commands 
commands defines function cycle iteratively applies execute certain number times 
commands prove theorems cycle 
zp true positive integers 
defun cycle zp cycle execute cycle implies cycle cycle composition implies equal cycle cycle cycle theorem says cycle preserves states 
second shows decompose long run shorter ones 
theorems proved inductively fully automatically 
recall execute merely constrained defined 
may thought generic 
defined function cycle theorems proved generic sense 
acl provides means generic function symbols instantiated 
suppose define concrete notion machine state concrete execution step prove preserves concrete notion state 
theorem generic functions gives rise analogous theorem concrete ones 
particular define concrete notion cyclic execution engine appeal cycle cycle composition obtain important properties concrete cyclic engine 
appeal stating desired concrete theorem noting functional instantiation appropriate generic functional substitution maps generic symbols concrete ones 
functional instance admissible provided concrete symbols satisfy constraints generic ones 
necessary reconstruct arguments necessary prove generic theorems place 
development generic functions theorems constitute useful body knowledge 
knowledge codified form acl book 
book just file admissible events starting designation current symbol package 
user create suitable book putting text encapsulate defun cycle file adding package acl top 
name file generic cycle lisp 
command certify book generic cycle certify book checking admissibility event 
certified command include book generic cycle extend existing chronology events book provided certain syntactic requirements met insure names redefined 
books encapsulations may contain local events 
book certified local events processed 
book included session local events skipped 
mark lemmas book local 
proved certification book clutter acl data base book included user session 
provision structuring mechanisms especially books encapsulations reasons acl successfully applied verification problems verification floating point division microcode amd floating point square root microcode amd floating point square root hardware verification microcode motorola cap digital signal processor verification certain aspects rockwell collins silicon java virtual machine 
structured proofs produce smaller simpler contexts making easier user control theorem prover exploiting automatic features 
addition books allow users combine build past 
example existing book contains theorems needed new project user create new book provides just useful theorems new book locally includes old non locally states desired theorems 
including new book imports desired importing 
demonstrates notion correctness encompasses encapsulate include book events 
attention turned treatment encapsulate include book events directly introduce constrained functions 
course book may include encapsulate events events 
brief description far may appear encapsulate simple warrant 
suppose encapsulation introduces new constrained function symbol fn 
suppose events encapsulation include local definition fn non local theorem fn 
theorem clearly part constraint fn 
encapsulate contains non local theorems mentioning fn 
part constraints fn moved encapsulate altogether 
mention function symbols fn 
non local function definitions call fn moved 
termination argument function symbol involves fn 
done theorems local witness fn deduced implicitly acl theorems characterize type link suggested induction schemes 
theorems part constraint 
related issues considered carefully 
noted uncovered soundness bugs acl careful consideration 
bug involved constrained function termination argument recursive function defined non locally encapsulation 
failure include definition function constraints encapsulate allowed theorem prover unsound inductions encapsulation 
foundedness argument inductions depended properties witness constrained function properties explicit constraints encapsulation 
additional events especially relevant interactions encapsulate 
acl user may introduce new axiom event form defaxiom name term term term added new axiom name name 
generally discourage defaxiom allows inconsistency constraining axiomatized function symbols 
new previously function symbol constrained recommended symbol constraints done encapsulate 
acl user may introduce mutually recursive function definitions event form mutual recursion defun 
mutual recursion prohibited syntactic restrictions defun event function symbol definition defined introduced 
simple example mutual recur sion 
mutual recursion defun zp odd defun odd zp nil recognizes natural numbers second recognizes odd natural numbers 
measure theorems mutually recursive clique establish termination functions clique 
acl supports explicit mutually recursive definitions singly recursive alternatives possible 
certain sense mutually recursive definitions eliminable favor singly recursive definition 
user introduce conservative choice function satisfying proposition 
example element member introduces function element applied returns member list natural number provided object 
event similar stylized encapsulate new function constrained satisfy axiom described frees user exhibiting witness required encapsulate 
main result seen preceding section session acl may viewed extension built ground zero theory sequence events 
events may classified groups 
axiomatic events introduce new facts definitions especially defun events possibly context mutual recursion constrained axioms encapsulate events pure axioms defaxiom events 
events theorems allegedly proved facts 
claim probably property require theorem prover prover asserts provability formula formula really provable appropriate axioms 
informal claim provability acl checked formulas 
alleged theorem acl session fact theorem order derivable extension built logic induction axiomatic events session 
claim stronger appears 
acl user typically defines function symbols interest introduce extra definitions lemmas leading acl proof conjecture involving function symbols interest 
claim implies theorem really order derivable original definitions axioms extra definitions heuristically useful logically necessary 
see recall books may local events presumably certify book obtained marking auxiliary functions lemmas local 
new session start include book command import session non local events 
application claim new session allows conclude theorem order provable auxiliary definitions 
remainder justify informal claim steps 
section introduce notions allow state theorem formalizes claim prove theorem 
section tie theorem informal claim 
consider extralogical correctness issues correctness acl theorem prover term manipulation procedures rewriter decision procedures acl handling syntax packages macros capability provided slipping program mode 
logical preliminaries section review notions order logic subject assume familiarity part reader 
introduce logical conventions acl specific definitions important follows 
logic considered order logic equality described example restriction relation symbols equality 
set function symbols occurring set formulas called language usual theory set order consequences set axioms set formulas order derivable extra logical symbols occur formulas elements called theorems recall theory conservative extension theory superset theorem language theorem completeness theorem order logic occasion order theory consistent model 
implicitly converse soundness theorem order logic 
consider consistent theories extend order theory gz discussed section 
easy see gz consistent extended described 
write pr denote language gz 
typically write formal 
assume gz contains binary function symbol oe 
intuitively oe founded relation acl universe 
set function symbols corresponding set induction axioms universal closures formulas form called induction axioms respect variable 
oe definition 
set induction axioms language defined set induction axioms respect defined ranges set formulas ranges set free variables 
definition 
order theory inductively complete contains induction axiom language assumptions 
additional assumptions gz 
ordering nonnegative integers inherited oe 
predicate zp returns nil positive integers arguments 
peano axioms contained gz 
assumption permits carrying standard arguments guaranteeing definability primitive recursive functions natural numbers allows apply certain known theorems techniques appendix requirements gz honored acl implementation 
convention 
consider consistent inductively complete order theories extend gz 
henceforth term theory understood mean consistent inductively complete theory 
definition 
inductive completion set order formulas respect language theory axioms set induction axioms language omitted understood language gz 
definition 
theory 
definitional axiom finite conjunction equations form xn term notations pr gz intended suggest primitive recursive ground zero respectively 
term term union language set left hand side function symbols 
xn distinct variables include variables occurring term left hand side function symbol distinct function symbols language conjunct said define list formal parameters xn 
may say case xn defined theory understood important discussion may talk simply definitional axiom 
notation 
write abbreviation term form xn 
feel free extend abbreviation obvious ways example writing abbreviate xn 
convention 
standard notion order definable function respect theory notion applies formula list enumerating free variables property theorem unique holds 
case arity implicitly defined function theory implicit important discussion may omit just talk order definable function 
introduce basic logical notion underlying event 
definition 
order formula free variables contained sequence distinct variables function symbol arity skolem axiom introducing respect defined formula 
allow bound variable free variables distinct variables 
vn 
function symbol arity skolem axiom introducing respect hv vn defined formula 
list vn context definition provable returns list length recursion induction section introduce notions admissibility recursive definitions 
notion measure admissibility similar definitional principle nqthm explained acl implementation 
treatment histories chronologies need different notion call interpreter admissibility 
properties demonstrated 
ffl definitional axiom measure admissible interpreter admissible 
ffl definitional axiom interpreter admissible yields conservative extension 
ffl definitional axiom interpreter admissible associated induction rule inference derived sound rule 
measure admissibility section iii argues recursive definition satisfies certain definitional principle definitional axiom defines unique function 
self contained explication essentially principle nqthm version notion measure viewed informally guaranteeing function set functions defined terminates inputs 
idea imagine recursive call ruled certain conditions guarantee measure arguments smaller recursive call top level call 
illustrate example 
consider definition pair functions defining notions odd natural numbers 
assume zip zero integer property defined true non integers 
recall conventionally represents true nil conventionally represents false 
usual convention acl nqthm write functions treat non integers 
zip nil gamma zip gamma clear execution functions satisfying definitions terminate absolute value decreases recursive call 
absolute value function call measure definition clearly order definable gamma 
general function defined definitional axiom may measure function 
example may viewed generating proof obligations definition jxj measure function 
proof obligations generated definition 
note proof obligation recursive call case tests negated appropriate tree antecedents implication 
zip jx jxj zip jx gamma jxj precise notion measure 
definition 
definitional axiom theory measure associates conjunct term order definable function respect roughly speaking measure decrease arguments recursive call subject conditions ruling call see example involving 
define recursively notion rules 
generous notion example say govern call term rules calls consider top level structure term 
decision accord acl implementation choice heuristic reasons involving induction 
definition 
say term rules occurrence term term iff form test tbr fbr conditions holds occurrence tbr test rules occurrence tbr occurrence fbr test rules occurrence fbr 
definition 
definitional axiom measure theory measure theorem denoted conjunction implications obtained follows occurrence term un right hand side defined formal parameters xn occurrence ruled terms un oe xn definition 
theory 
definitional axiom measure admissible measure corresponding measure theorem theorem case say measure admissible interpreter admissibility handling recursive definitions theory opportunity confusion error done carefully 
require nqthm notion admissibility just include book recursively defined function measure marked local clear definitional axiom measure admissible measure may defined local functions 
develop alternate notion admissibility interpreter admissibility 
show notion follows measure admissibility important verifying section implementation behaved 
main idea interpreter admissibility consider definitional axiom canonical interpreter definable function symbols definitional axiom built members pr 
interpreter order definable current history recursion particularly simple extra stack depth argument decreases recursive call 
represent divergence insufficient stack depth termination return value nil return value pair intended equal result consing real value nil 
interpreter admissibility defined mean canonical interpreter total argument list sufficient stack depth non divergence termination 
conventions 
rest section fix definitional axiom theory assumed inductively complete set function symbols defined assume map associates function symbol language fdg arity exceeds arity 
canonical interpreters turn notion canonical interpreter promised 
key idea embodied definition 
show map term term intended represent cons nil stack depth sufficiently large computing value definitional axiom nil 
technical reasons want categorize occurrences terms top level structure right hand side subscript boolean flag order distinction set initially right hand side conjunct leave top level structure 
definition 
terms value define term recursion follows 
variable constant cons nil nil nil similar idea nqthm value cost function see care cost 
car nil nil 
nil nil cons car car nil nil 
nil nil car car recall section function symbol zp defined theory gz return nil positive integer arguments 
definition canonical interpreter 
canonical interpreter definitional axiom obtained replacing conjunct zp nil gamma say canonical interpreter total theory defined theorem nil convention definability 
standard arguments show definition order definable functions ff fg equations canonical interpreter fact theorems henceforth mention referring order definition just called new function symbol 
definition interpreter admissibility 
definitional axiom said interpreter admissible theory canonical interpreter total obvious proposition may implicitly 
proposition preservation interpreter admissibility 
interpreter admissible extends interpreter admissible lemmas subsection develop machinery allow prove main results interpreter admissibility 
lemma interpreter monotonicity 
definitional axiom theory term language fdg 
variables occurring theorem nil cons car nil proof 
start reductions 
suffices prove conjunct consequent implication second conjunct gives value independent choice second suffices prove theorem terms righthand sides equations done theorem follows easy induction definition third assume renaming variables necessary variables occur universal closure finite conjunction formulas form ranges subterms nil cons car nil sequence variables occurring 
suffices prove claim strong induction suffices show holds subterm value set 
nil cons car nil show holds induction subterms working inside assume nil prove 
cons car nil rest proof depends choice variable constant syntactically term cons nil clear 
form 
case similar argument left reader 
nil nil inductive hypothesis terms property holds subterms cons car nil cases 
definition cons car car nil axiom car cons see subsection equal cons car car nil equals definition 
car car axiom car cons suffices arbitrary nil prove 
cons car nil body definition conjunct definition canonical interpreter know gamma gamma gamma gamma gamma nil gamma cons car gamma nil cons car nil implies 
definition 
fix variable symbol occur define theory td inductive completion extension universal closures equations defined nil nil car nil lemma conservativity td 
td conservative extension proof 
clear convention definability definable function symbol defined lemma interpreter 
term language fdg 
td nil cons nil proof 
easily established induction term definition interpreter monotonicity lemma case lemma divergence 
terms 
theorem td nil subterm nil 
proof 
easily proved induction term definition interpreter lemma 
lemma interpreter correctness suppose interpreter admissible theory canonical interpreter total td proof 
fix conjunct totality canonical interpreter working td may choose nil 
pick car definition td car gamma definition canonical interpreter interpreter lemma shown td proves desired 
lemma interpreter provability 
interpreter admissible definitional axiom theory td subtheory inductive completion extension proof 
suffices prove assuming interpreter admissibility interpreter lemma holds place td nil cons nil proof easy induction proof interpreter lemma omitted 
key properties interpreter admissibility goal show measure admissibility implies canonical interpreter total 
lemma key 
proof shows introduced flag notion lemma 
term theorem suppose subterm form conjunction terms ruling subterm 
nil nil proof 
lemma conservativity td suffices prove theoremhood td proof induction call subterm terms ruling result clear divergence lemma 
suppose form 
observe subterm call function terms ruling argument non case may choose nil 
follows interpreter monotonicity lemma nil 
henceforth restrict 
assume nil case similar 
interpreter lemma note handy td cons nil 
follows inductive hypothesis may applied place obtain nil maximum serves desired value interpreter monotonicity lemma 
theorem interpreter admissibility 
suppose measure admissible definitional axiom theory interpreter admissible proof 
definition measure admissibility exists measure corresponding measure theorem theorem suppose contradiction canonical interpreter total foundedness oe precisely inductive completeness may choose conjunct nil defined renaming necessary disjoint oe 
nil follows immediately measure theorem preceding lemma nil 
canonical interpreter yields nil contradicting 
development theory histories section requires definitional events provide conservative extensions 
lemma crucial 
lemma conservativity definitions 
suppose definitional axiom interpreter admissible theory inductive completion extension conservative extension proof 
indicated extension subtheory td interpreter correctness lemma 
done conservativity td lemma 
consider induction schemes acl implementation 
reasons measure notion admissibility worked successfully nqthm justify corresponding uses induction 
similar justification applies acl 
root justification measure admissibility definition 
order regain justification setting need show interpreter admissibility implies existence appropriate measure 
resulting measure defined inductive completion extension traditional 
problem justifying inductions 
important measure defined function symbols pr definition exists appropriate subtheories containing definition canonical measure 
interpreter admissible definitional axiom inductively complete theory canonical measure defined follows nil technical definition proposition appendix briefly put identifies definitions recursive calls involve functions belonging set furthermore top level tests involve functions definition tight definability 
definitional axiom set function symbols containing gz 
say tight respect function symbol term belongs provided subterm right hand side belongs sets 
proper subterm call member 
subterm equal term negation rules subterm call function introduced proposition tight definability canonical measure 
interpreter admissible definitional axiom theory inductively complete set function symbols containing disjoint set function symbols introduced suppose tight respect canonical measure order definable definition function symbols theorem canonical measure theorem 
interpreter admissible definitional axiom theory canonical measure measure theorem holds inductive completion extension proof 
canonical measure suffices prove measure theory td interpreter provability lemma 
fix conjunct suppose subterm ruled set terms 
need prove noting oe extends assumption section 
td definition suffices prove td nil nil definition canonical interpreter reduces td nil nil establish terms nonnegative integers subterm occurrences ruled set terms induction call term immediate divergence lemma working td 
write occurrence argument analogous case just handled 
occurrence assume case completely analogous 
result adding set terms ruling occurrence inductive hypothesis td nil nil show td nil imply done 
definition follows td nil car immediate interpreter lemma working td histories introduce notion acl history 
notion formalizes axiomatic content acl session 
histories record proved theorems local function definitions session aspects session formalize order reach ultimate goal logically characterizing result user interaction acl 
extend attention proved theorems aspects session consider chronologies section 
defining kinds objects allow histories 
object corresponds primitive kinds axiomatic acts acl session 
point merely describe syntax objects ll consider semantic issues shortly 
definition 
labeled formula pair consisting label formula label forms 
ffl finite set function symbols defined definitional axiom ffl function symbol formula nonempty finite sequence variables 
ffl defaxiom 
ffl constraint sequence labeled formulas 
meaning clear feel free confuse labeled formula formula second component pair 
feel free call universal closure formula axiom axiom introduced sequence appears 
may refer formula labeled defaxiom constraint labeled formula context corresponding label formula 
notation 
write denote result extending sequence new element write denote result extending sequence new element sequence 
clear context objects concatenated elements sequences 
definition 
set function symbols introduced labeled formula sequence labeled formulas defined recursion follows 
formula labeled 
introduces set function symbols similarly 
introduces singleton set ffg 
formula labeled defaxiom 
introduces empty set function symbols 
formula labeled constraint 
introduces set function symbols introduces 
sequence labeled formulas introduces union sets function symbols introduced labeled formula sequence 
definition 
sequence labeled formulas 
function symbol function symbol introduced member pr 
language set function symbols theory inductive closure union gz universal closures formulas induction axioms language convention 
meaning clear feel free confuse sequence labeled formulas theory 
feel free talk sequence labeled formulas conservatively extending sequence labeled formulas indicate theory conservatively extends theory course order elements sequences irrelevant notion 
definition 
notion defaxiom free defined recursion follows 
labeled formula defaxiom free label defaxiom 
label constraint 
defaxiom free 
sequence labeled formulas defaxiom free members defaxiom free 
obvious known case theories 
lemma transitivity conservative extension 
theories sequences labeled formulas conservatively extends conservatively extends conservatively extends prepare notion history starting syntactic requirements ignoring proof obligations 
definition weak history 
weak history finite sequence labeled formulas meeting requirements 
labeled formula label defaxiom label set function symbols introduced non empty 
function symbol occurring formula labeled formula introduced function symbol set predecessors 
family sets function symbols introduced labeled formulas pairwise disjoint 
set function symbols disjoint pr introduced function symbol occur gz 
labeled formula label form formula skolem axiom introducing formula respect sequence variables 
see section definition 
furthermore formula language 
label constraint defaxiom free sequence labeled formulas weak history formula language 
labeled formula label definitional axiom theory definition 
history weak history meets requirements addition 
extending history theorem theory 
extending interpreter admissible definition theory 
number proofs induction sequences labeled formulas 
invariably recursions justified considering number constraint labels length sequence 
leave justification implicit arguments 
proposition 
weak history language includes language theory possible language proper superset language theory consider example happens add constrained function symbol axioms 
implementation note 
encapsulate event acl introduce local functions viewed simply sequence non local events contained 
allows satisfy property 
property probably safely omitted rate acl introduce constraints non definitional axioms local functions encapsulate 
choice reduce proof obligations arising functional instantiation allow induction schemes 
say details implementation encapsulate appendix obvious lemma implicitly 
lemma 
initial segment weak history weak history 
ii initial segment history history 
lemma history monotonicity 
suppose history history theory contains introduce function symbols 
history 
proof easy induction key idea proof obligations introduced processing provable replace larger history particular proposition preservation interpreter admissibility subsection justifies property history 
introduce operation sequences labeled formulas motivated idea replacing constrained formula sequence events justifying 
definition 
expansion sequence labeled formulas defined recursion follows 
expansion empty sequence empty sequence 
expansion labeled constraint expansion expansion labeled formula expansion readers familiar acl 
notion expansion formalizes acl command case local events 
lemma expansion 
expansion sequence labeled formulas 
sequence labeled formulas having properties 
introduce function symbols 
theory subset theory sequences labeled formulas theory subset theory 
history history history 
defaxiom free defaxiom free 
contains constraint labels 
proof easy induction 
history monotonicity lemma proof 
goal show histories provide conservative extensions 
fact prove slightly stronger result useful 
lemma proof 
lemma conservativity 
suppose sequence labeled formulas 
suppose formula label language formula language conservatively extends proof immediate conservativity result appendix ready prove slight strengthening special case theorem concluding section 
consider extensions obtained adding events history 
lemma history conservativity 
history conservatively extends generally suppose sequence labeled formulas includes subsequence function symbol introduced occurs theory conservatively extends proof 
parts expansion lemma hypotheses continue hold replace expansion temporarily call part expansion lemma theory includes theory suffices prove theorem place parts expansion lemma consists entirely formulas labeled defun 
loss generality assume formula labeled defun 
proceed induction length case empty clear 
write apply inductive hypothesis may conclude conservatively extends remains show conservatively extends done transitivity conservative extension 
assumed formula labeled defun immediate conservativity definitions lemma subsection conservativity lemma 
defun case hypothesis extends fact proof obligation interpreter admissibility provable history 
corollary history consistency 
defaxiom free history consistent 
proof 
immediate history conservativity lemma empty history defaxiom free history gz assumed consistent see section 
definition 
fix weak history define set ancestors function symbol labeled formula follows 
function symbol pr empty set ancestors 
fix history labeled formula history introduces function symbol 
set ancestors respect history defined set ancestors defined union set function symbols introduced set ancestors function symbols occurring formula introduced set proper ancestors labeled formula function symbol introduced labeled formula defined result removing function symbols introduced labeled formula set ancestors 
note recursion justifiable part definition weak history 
definition 
suppose sequence labeled formulas suppose subsequence say closed ancestors respect provided conditions hold 
ancestor function symbol occurring formula function symbol 
element labeled defaxiom member proposition follows easily definition definition ancestors 
proposition 
closed ancestors respect weak history function symbol occurring formula function symbol pr introduced simple lemma key ingredient argument required history conservativity theorem follows 
lemma restriction 
suppose sequence labeled formulas history defaxiom free suppose function symbols introduced occur formulas conservatively extends proof 
history defaxiom free history conservativity lemma conservatively extends sequence labeled formulas extends function symbol introduced occurs theory particular conservatively extends just way stating 
theorem history conservativity 
suppose history subsequence closed ancestors 
conservative extension proof induction number labeled formulas number done 
labeled formula result inserting result subsequence may write initial subsequence clearly closed ancestors inductive hypothesis conservative extension relation conservative extension transitive suffices show conservative conservative closed ancestors labeled defaxiom label 
done restriction lemma provided show function symbols introduced occur formulas clear proposition closed ancestors 
chronologies formal results suggested section wish formulate behaved notion chronology formalizes result user interaction acl 
chronologies defined consist axiomatic acts part forming history defined preceding section formulas allegedly order derivable axioms 
chronology sequence labeled unlabeled formulas restriction labeled formulas history unlabeled formula theorem labeled formulas 
users interact acl complex ways simply introducing axioms including definitions proving theorems may structuring mechanisms provided local encapsulate include book 
section formalize user interaction acl key properties 
final section connects formalization implementation 
definitions 
finite sequence labeled unlabeled formulas 
subsequence consisting labeled formulas 
intuitively think history part axiomatic acts 
ii thm set universal closures unlabeled formulas intuitively think thm proved theorems 
iii weak chronology weak history initial subsequence form unlabeled formula function symbol occurring function symbol 
definition 
class chronologies class sequences contains empty sequence closed operations 
ffl labeled extension chronology labeled formula history chronology 
ffl unlabeled extension chronology formula language provable union theory thm chronology 
ffl delete chronology weak chronology subsequence contains labeled formulas label defaxiom chronology 
ffl include suppose chronologies subsequence obtained deleting members belong weak chronology 
chronology 
proposition 
history chronology 
proof easy induction length labeled extension rule 
implementation note 
acl lays certain command markers indicate initial segments chronology accept chronologies 
restriction necessary correctness model 
lemmas remain ready prove main results chronologies 
lemma history sufficiency 
suppose weak history 
assume initial segment exists history set elements subset set elements history 
proof induction empty trivial 
write inductive hypothesis history 
weak history 
assumption theorem may choose history set elements subset set elements clauses definition history follow easily inductive hypothesis order guarantee satisfaction requirement history 
lemma combining 
suppose histories subsequence obtained removing elements weak history 
history 
proof 
immediate consequence history sufficiency lemma 
lemma ancestors preserve history 
suppose history subsequence weak history contains elements labeled defaxiom 
history 
proof 
easy argument omitted uses definition weak history show closed ancestors respect theorem follows easy induction history conservativity theorem guarantee proof obligations met 
notice critical interpreter admissibility measure admissibility order guarantee proof obligations definitional axioms expressed sub history 
main lemma chronologies 
chronology 
history weak chronology thm subset theory 
proof induction construction class chronologies 
ancestors preserve history lemma guarantees delete rule preserves history conservativity theorem guarantees preserves 
step requiring bit thought justification history application include rule 
weak history assumed weak chronology follows combining lemma 
theorem consequence preceding lemma history conservativity theorem preceding section 
captures really want claim chronologies 
theorem correctness chronologies 
chronology 
theorem order consequence history furthermore suppose proved suppose history contained contains labeled formula labeled defaxiom mentions function symbol occurring provable corollary 
chronology defaxiom free 
set universal closures formulas labeled unlabeled consistent 
proof 
correctness chronologies theorem suffices show consistent 
follows fact history part main lemma chronologies history consistency corollary 
implementation correctness section give high level argument notion chronology adequately models informal notion acl session sequence acl events 
goal certainly prove correctness routines acl theorem prover code assumed implement logic level 
goal section show weak chronology fact chronology 
correctness chronologies theorem tells alleged theorem fact order consequence relevant axioms session 
consider event type show preserves chronologies successful execution event chronology leads new chronology 
acl events extending logic rest essentially abbreviations omit consideration types events 
turn attention left 
defaxiom events preserve chronologies labeled extension rule noting extending chronology history main lemma chronologies 
argument defaxiom provides justification definition events including defun mutual recursion 
labeled extension rule justifies claim events preserve chronologies caveats 
need correctness chronologies theorem guarantees sufficient prove necessary proof obligations thm acl system addition 
second need interpreter admissibility theorem subsection order conclude measure admissibility checked implementation implies interpreter admissibility required definitions history chronology 
third need correctness functional instantiation theorem appendix allows functional instantiation proof acl system 
need canonical measure theorem subsection argument justify acl induction schemes proofs 
events preserve chronologies follows similarly unlabeled extension rule correctness chronologies theorem correctness functional instantiation theorem canonical measure theorem 
acl permit local defaxiom events include book preserve chronologies delete rule delete local events followed include rule 
remains see encapsulate events preserve chronologies 
suppose chronology corresponding acl session encapsulate event executed successfully sequence events including local events introduced inside encapsulate form 
may assume inductively chronology 
conjunction events exported marked local 
correctness chronologies theorem 
main lemma chronologies know history history 
labeled formula label constraint formula 
history chronology labeled extension rule 
implementation checks requirement history defaxiom free 
fact acl version allowed encapsulate forms embedded defaxiom forms feature led soundness bug fixed 
bug uncovered course writing 
appendices correctness functional instantiation appendix prove correctness functional instantiation stages 
introducing basic notions prove simplified version 
version generalized larger class functional substitutions slightly strengthened obvious way better match acl implementation 
second version strengthened version accounts optimization acl implementation handling encapsulate events 
nqthm version functional instantiation proved correct 
functional substitutions definition 
history 
pseudo function function symbol expression form lambda vars term vars list distinct variables function symbol occurring term function symbol case define arity length vars variables occurring term belong vars called free variables pseudo function 
definition 
functional substitution finite arity preserving function fs function symbols pseudo functions 
addition range fs consists entirely function symbols call simple functional substitution 
set free variables fs union sets free variables pseudo functions range fs 
possibly weak history fs functional substitution maps function symbols pseudo functions may say fs functional substitution respect recall pr set function symbols occurring gz 
proposition follows immediately definition part definition weak history section 
proposition 
domain functional substitution fs disjoint pr 
notation 
functional instance term formula functional substitution fs 
may call simple functional instance fs simple 
omit details definition may carried recursion straightforward manner 
correctness simple functional substitutions lemma rigorous key idea 
theorem proved involves function symbols mentioned axioms proved meanings functions symbols irrelevant provability 
remains theorem function symbols replaced 
lemma 
suppose theorem order theory fs simple functional substitution domain disjoint set function symbols nfs theorem proof 
proof theoretic argument presumably axiom rules inference remain valid applying fs applications 
give modeltheoretic argument 
note suffices assume domain range fs disjoint may write fs composition appropriate functional substitutions property 
briefly map symbols domain distinct symbols occurring sight map final values 
model interprets symbols range fs domain fs satisfies negation nfs may expand model negation interpreting function symbol domain fs interpretation corresponding function symbol range fs 
theorem 
suppose fs simple functional substitution respect history theorem suppose subsequence closed ancestors formula language suppose labeled formula theorem nfs theorem proof 
assumption theorem theorem history conservativity theorem 
fix proof theory includes induction axioms 
letting conjunction axioms induction axioms proof order theorem gz 
immediately preceding proposition lemma follows nfs order theorem gz nfs theorem gz nfs theorem conjunct theorem hypothesis separate argument needs induction axioms 
claim simple functional instance induction axiom induction axiom clear form induction axioms simple functional instance fs formula form 
correctness functional substitutions acl implementation functional instantiation functional substitutions permitted map function symbol pseudo function lambda vars term length vars arity may include free variables 
need remove restriction simple functional substitutions theorem 
theorem restricts proof obligations obvious way functional instances theorems contain function symbol bound functional substitution 
state simple lemma proof 
lemma 
inductively complete theory set zero ary function symbols constants disjoint language inductive completion respect union language formula language formula resulting substituting constants free variables theorem theorem proof 
suppose theorem completeness theorem model satisfies negation assignment values variables 
expansion model language may obtained interpreting members occurring values variables replace interpreting rest arbitrarily 
expanded model assignment satisfies negation theorem theorem justifies acl generation proof obligations uses functional instantiation optimizations discussed subsection 
subsequence theorem taken implementation include ancestors function symbols occurring defaxiom see acl documentation constraint 
theorem correctness functional instantiation 
suppose fs functional substitution respect history theorem suppose subsequence closed ancestors formula language suppose labeled formula function symbol domain fs occurs theorem free variable fs occurs nfs theorem proof 
observe function symbol domain fs occurs formula just remove restriction formulas function symbol domain fs occurs reduce theorem case free variables fs 
extend new history introduces extending theory distinct zero ary function symbol variable free fs 
technically extension formula true label constraint say defines new zero ary function value 
consider functional substitution fs obtained fs replacing variable free fs corresponding new constant call new zero ary function 
note hypotheses theorem satisfied place fs place fs unchanged theorem theorem instance 
instance 
left reader note hypothesis free variables fs 
application theorem case allow conclude nfs theorem preceding lemma allows conclude nfs theorem assume fs free variables 
pair hf lambda vars term fs extend definition vars term new function symbol 
call resulting history write fs functional substitution obtained replacing expression lambda vars term corresponding new function symbol claim hypotheses theorem hold fs place fs unchanged claim need show theorem theorem clear logically equivalent theorem preceding subsection applies nfs theorem nfs logically equivalent nfs nfs theorem history conservativity theorem nfs theorem correctness presence optimizations documentation topic constraint discusses certain optimizations performed acl implementation generating proof obligations functional instantiation 
argue correctness optimizations 
focus non trivial encapsulations non empty signatures contain contained non trivial encapsulations 
nested non trivial encapsulations rearranged put nest mean part constraints generated 
second follows consider non local events encapsulate assuming satisfy restriction locally defined function symbols signature functions 
encapsulate event move just front order definitions theorems signature functions ancestral 
collect formulas theorems introduced encapsulate definitional axioms 
add set definitional equations non tight terminology defines function formula set 
conjunction resulting set formulas called constraint set signature functions encapsulate function symbols defined encapsulate mentioned constraint called constrained functions 
assign constraint constrained functions 
move just encapsulate definitions function symbols defined encapsulate omitted constraint 
demonstrate correctness optimizations defining corresponding transformations showing preserve chronologies 
transformation maps suitable chronology sequence labeled unlabeled formulas task prove result chronology 
clear justified optimizations described documentation quoted 
transformation rules intended transform chronologies constructed successfully executing encapsulate event 
rules parameterized follows 
ffl chronology 
ffl order derivable associated induction schemes 
label constraint abuse notation calling labeled formula 
note part main lemma chronologies section history 
ffl ffl result deleting ffl result replacing formula order consequence language replacing label constraint 
parameters just defined rules follows 
notion tight introduced section definition tight definability 
proposition definition allows claim rule back canonical measure definable 
ffl front suppose ancestor introduced labeled 
new sequence ffl back suppose labeled formula introduces ancestor labeled formula suppose labeled defun recursive definition tight respect union pr set function symbols introduced 
new sequence proposition 
front rule preserves chronologies 
proof 
fix parameters defined suppose ancestor introduced 
suppose labeled formula 
ancestors preserve history lemma section sequence history 
follows history sufficiency lemma section sequence history 
definition history follows history 
chronology applications labeled extension rule 
suppose unlabeled formula 
correctness chronologies theorem theorem 
history conservativity theorem section theorem 
chronology unlabeled extension rule 
history main lemma chronologies equal clearly history chronology labeled extension rule 
proposition 
back rule preserves chronologies 
proof 
fix parameters defined suppose labeled formula introduces ancestor labeled formula chronology history main lemma chronologies 
mentioned recursive definition tightness allows assert canonical measure definable history conservativity lemma section measure theorem provable 
suffices prove chronology labeled extension rule chronology 
notice guarantee labeled extension applies labeled constraint 
claim closed ancestors 
suffices check labeled formulas occurring ancestor function symbol introduced choice know introduces ancestor definition ancestor functions introduced ancestors function introduced ancestor function ancestor follows closed ancestors 
noted history ancestors preserve history lemma section history 
formula theorem history theorem order consequence hypothesis 
formula language function symbol formula introduced formula theorem history history conservativity lemma 
follows history definition history 
chronology labeled extension rule met final proof obligation 
conservativity skolemization wish check conservativity skolemization context time function symbol introduced induction axioms symbol existing function symbols 
dealing logic precluded non standard numbers manage simply need worry induction axioms introduced add new function symbol skolem function 
sort induction scheme automatically true natural numbers model standard 
want leave realm order logic avoid example eliminate potential integrating non standard analysis system require rethink proof theory 
fortunately ll see assume definable enumeration universe 
enumeration permits explicit definition skolem functions choosing witnesses sense enumeration 
remainder appendix works argument 
jim suggesting key ideas allow carry argument allowing enumeration model 
definition skolem axiom subsection 
notation 
set function relation symbols includes unary relation symbol nat 
write ind nat theory containing induction axioms language simple lemma surely known 
lemma 
suppose subtheory order theory model sentence true finite subset model satisfying conservative extension proof 
suppose contradiction conservative extension say language theorem theorem completeness theorem order logic model satisfies 
hypothesis compactness theorem order logic may choose model satisfies 
model satisfying theorem contradicts choice 
lemma obvious 
concerned induction axioms trivial conservatively extend theory adding bijection universe natural numbers downward lowenheim skolem theorem order logic 
needed want preserve induction 
lemma 
suppose order theory finite language containing pr contains gz ind nat 
conservative extend theory adding axiom introducing new unary function symbol asserting maps universe nat ind nat fgg 
proof sketch 
sketch arguments quite technical model theoretic suggested jim 
model case show expand addition non standard analysis acl major part doctoral research currently undertaken 
countable downward lowenheim skolem theorem model desired assertion ind nat fgg second argument arbitrary finite subset set 
preceding lemma yields desired conservativity claim applying argument requires background models arithmetic second depends deeper result needed argument 
standard direct argument uses variant cohen forcing technique set theory adapted models arithmetic 
fix countable model partial order consists finite sense functions initial segment interpretation nat coded standard argument shows function partial order generic respect dense sets definable parameters gives desired expansion details omitted 
main ideas briefly familiar forcing prove usual truth lemma show forces defines inductive subset nat nat set conditions force predecessors satisfy dense generic set member dense set generic set holds predecessors generic model 
arbitrary holds elements nat generic model induction scheme verified 
second argument uses theorem jim 
theorem tells sentence language peano arithmetic extended model ind nat satisfies finite subset model satisfying definable inside contained interpretation nat interpretation nat isomorphic isomorphism definable interpretation nat 
necessary certainly problem definitional extension carrying argument allowing coding finite sequences manner required theorem 
definable follows follows model ind nat fgg function definable contained interpretation nat exists enumeration elements definable composing appropriately aforementioned definable isomorphism function interpretation nat definable expands model ind nat fgg argued 
theorem implies conservativity lemma section proof deferred 
theorem 
suppose order theory language contains relativization peano arithmetic nat ind nat 
conservative extend adding skolem axiom introducing new function symbol ind nat ffg 
proof 
preceding lemma allows extend theory tively include function mapping universe ind nat fgg 
transitivity conservativity suffices extend new theory manner indicated 
easy indicated theory may explicitly define desired skolem function simply picking witness appropriate values chosen witness exists say 
boyer moore 
computational logic academic press new york 
boyer goldschlag kaufmann moore 
functional instantiation order logic 
artificial intelligence mathematical theory computation papers honor john mccarthy academic press pp 

boyer kaufmann moore 
boyer moore theorem prover interactive enhancement computers mathematics applications 
brock kaufmann moore 
acl theorems commercial microprocessors 
proceedings formal methods computer aided design fmcad srivas eds springer verlag november pp 

boyer moore 
computational logic handbook second edition academic press london 
brock moore 
mechanically checked proof comparator sort algorithm url www cs utexas edu users moore publications index html submitted publication 
greve hardin efficient simulation simple formal processor model technical report advanced technology center rockwell collins avionics communications cedar ia april 
kaufmann moore 
acl computational logic applicative common lisp user manual 
url www cs utexas edu users moore acl acl doc html user manual 
kaufmann moore 
high level correctness acl story 
url www cs utexas edu users moore acl reports story txt october 
kaufmann moore 
precise description acl logic 
url www cs utexas edu users moore acl reports km ps 
kaufmann moore 
industrial strength theorem prover logic common lisp 
ieee transactions software engineering april pp 

kaufmann 
acl support verification projects 
proceedings th int conf 
automated deduction kirchner kirchner eds lnai springer verlag july pp 

moore 
mechanically verified assembly level language automated reasoning series kluwer academic publishers 
moore lynch kaufmann 
mechanically checked proof amd floating point division program 
ieee trans 
comp 
sept pp 

see url devil ece utexas edu lynch divide divide html 
mechanically checked proof correctness amd floating point square root microcode formal methods system design special issue arithmetic circuits 

mechanically checked proof ieee compliance floating point multiplication division square root algorithms amd tm processor url www onr com user russ david div sqrt html 

reflection principle applications nonstandard models 
symbolic logic december 
shoenfield 
mathematical logic 
addison wesley reading ma 
steele jr common lisp language second edition 
digital press north avenue burlington ma 
yu 
automated proofs object code widely microprocessor technical report computational logic th austin tx may 
see url www cli com reports 

