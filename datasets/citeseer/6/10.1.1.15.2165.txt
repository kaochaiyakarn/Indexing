design embedded systems formal models validation synthesis edwards lavagno lee sangiovanni vincentelli stephen edwards university california berkeley cory hall berkeley ca fax eecs berkeley edu edward lee university california berkeley eecs dept cory hall berkeley ca fax eal eecs berkeley edu luciano lavagno politecnico di torino cadence berkeley laboratories addison st suites berkeley ca fax luciano cadence com published proceedings ieee vol 
march alberto sangiovanni vincentelli university california berkeley cadence european labs cadence sgs thomson european economic interest group 
research partially sponsored src cadence cnr vip 
di san roma italy fax alberto leonardo rm cnr addresses design reactive real time embedded systems 
systems heterogeneous implementation technologies design styles example combining hardware asics embedded software 
concurrent design process embedded systems involves solving specification validation synthesis problems 
review variety approaches problems taken 
reactive real time embedded systems pervasive electronics system industry 
applications include vehicle control consumer electronics communication systems remote sensing household appliances 
applications specifications may change continuously time market strongly affects success 
calls software programmable components behavior fairly easily changed 
systems computer perform specific function perceived computer generically known embedded systems 
specifically interested reactive embedded systems 
reactive systems react continuously environment speed environment 
contrasted interactive systems react environment speed transformational systems take body input data transform body output data 
large percentage world wide market micro processors filled micro controllers programmable core embedded systems 
addition micro controllers embedded systems may consist asics field programmable gate arrays programmable computing units digital signal processors dsps 
embedded systems interact continuously environment analog nature typically components perform conversions 
significant part design problem consists deciding software hardware architecture system deciding parts implemented software running programmable components implemented specialized hardware 
embedded systems life critical situations reliability safety important criteria performance 
today embedded systems designed ad hoc approach heavily earlier experience similar products manual design 
higher level languages helps somewhat increasing complexity sufficient 
formal verification automatic synthesis implementations ways guarantee safety 
formal verification synthesis high levels abstraction demonstrated small specialized languages restricted semantics 
odds complexity heterogeneity typical embedded systems 
believe design approach formal models describe behavior system high level abstraction decision decomposition hardware software components taken 
final implementation system possible automatic synthesis high level abstraction ensure implementations correct construction validation simulation verification done possible higher levels abstraction 
typical hardware architecture embedded system illustrated 
type architecture combines custom hardware embedded software lending certain measure complexity heterogeneity design 
software hardware portions heterogeneity 
software control oriented processes mixed supervision multitasking real time kernel running microcontroller 
addition hard real time tasks may run cooperatively programmable dsps 
design styles software subsystems quite different testing interaction trivial 
hardware side design frequently contain asics designed logic behavioral synthesis tools 
hand significant part hardware design consists interconnections commodity components processors memories 
time hardware side find heterogeneity 
design styles specify simulate asics interconnected commodity components quite different 
typical system mixes hardware design software design mixes design styles categories 
set tasks system implements specified rigorous unambiguous fashion design process requires iterations obtain convergence 
design process level abstraction detail specificity different parts design varies 
complicate matters skill sets design styles different engineers project different 
net result design process different specification modeling techniques 
managing design complexity heterogeneity key problem 
believe formal models high level synthesis ensuring safe correct designs depends understanding interaction diverse formal models 
simplicity modeling required verification synthesis reconciled complexity heterogeneity real world design 
concurrent design process mixed hardware software embedded systems involves solving sub problems specification validation synthesis 
problems entirely separated deal successive sections 
specification modeling design process viewed sequence steps transforms set specifications described informally detailed specification manufacturing 
intermediate steps characterized transformation description detailed 
designer perform steps process 
designer input description specification final description design implementation 
example software designer may see set routines written implementation design steps may taken design ready manufacturing 
process verification quality design respect demands placed performance functionality carried 
unfortunately descriptions design various stages informal logically connected set precise relationships 
advocate design process representations precise mathematical meaning verification map initial description various intermediate steps carried tools guaranteed performance 
approach standard certain communities languages strong formal properties ensure robust design 
examples include ml dataflow languages lucid haskell synchronous languages lustre signal esterel 
broad range potential formalizations design tools designers describe behavior design relation set inputs set outputs 
relation may informal expressed natural language 
easy find examples informal specifications resulted unnecessary 
opinion formal model design consist components 
functional specification set explicit implicit relations involve inputs outputs possibly internal state information 

set properties design satisfy set relations inputs outputs states checked functional specification 

set performance indices evaluate quality design terms cost reliability speed size set equations involving things inputs outputs 
define mean exactly inputs outputs state information 
consider sequences values 

set constraints performance indices specified set inequalities 
functional specification fully characterizes operation system performance constraints bound cost broad sense 
set properties redundant properly constructed design functional specification satisfies properties 
properties listed separately simpler incomplete compared functional specification 
property assertion behavior description behavior 
abstraction behavior particular axis 
example designing network protocol may require design deadlock called liveness property 
note liveness completely specify behavior protocol property require protocol 
protocol may require request eventually satisfied called fairness 
completely specify behavior protocol required property 
formal model functional specifications properties classify properties groups 
properties inherent model computation shown formally hold specifications described model 

properties verified syntactically specification shown hold simple usually polynomial time analysis specification 

properties verified semantically specification shown hold executing implicitly specification inputs occur 
example consider property determinate behavior fact output system depends inputs internal hidden choice 
design described dataflow network formal model described determinate property need checked 
design represented network fsms determinacy assessed inspection state transition function 
discrete event models example embodied verilog vhdl determinacy difficult prove checked exhaustive simulation 
design process takes model design level abstraction refines lower 
doing designer ensure properties level abstraction verified constraints satisfied performance indices satisfactory 
refinement process involves mapping constraints performance indices properties lower level computed level 
shows key refinement stage embedded system design 
specification case executable functional model closer problem level 
refinement process defined formally models design formally specified see mcmillan 
specification undergoes synthesis process may partly manual generates model implementation hardware 
model may fairly capturing example timing properties 
example model presumably hardware software partitioning 
suggests purely top process real design needs interaction specification implementation 
design complete best way document top 
require methodology support top design 
elements model computation language set symbols rules combining syntax rules interpreting combinations symbols semantics 
approaches semantics evolved denotational operational 
language ideally consistent practice difficult achieve 
operational semantics dates back turing machines gives meaning language terms actions taken machine typically closer implementation 
denotational semantics developed scott strachey gives meaning language terms relations 
machine operational semantics behave feature call model computation underlying language 
kinds relations possible denotational semantics feature model computation 
features include communication style individual behavior aggregated complex compositions hierarchy abstracts compositions 
design levels abstraction hierarchy functional specification final implementation generally represented set components considered isolated monolithic blocks interacting environment part design 
model computation defines behavior interaction blocks 
sections follow framework comparing elements different models computation called tagged signal model contrast different styles sequential behavior concurrency communication 
give precise definitions number terms definitions inevitably conflict standard usage communities 
discovered short abandoning common terms terminology consistent standard usage related communities 
attempt avoid confusion precise risk 
tagged signal model authors lee sangiovanni vincentelli proposed tagged signal model formalism describing aspects models computation embedded system specification 
denotational scott strachey sense defines semantic framework signals processes models computation studied compared 
describing particular model computation involves imposing constraints concrete 
fundamental entity tagged signal model event value tag pair 
tags denote temporal behavior 
set events aggregation signal 
processes relations signals expressed sets tuples signals 
particular model computation distinguished order imposes tags character processes model 
set values set tags event member event tag value 
signal set events 
signal viewed subset signal possibly partial function set signals denoted signals denoted set tuples denoted different models time model embedded systems translated different order relations set tags tagged signal model 
particular timed system totally ordered binary relation members untimed system partially ordered 
process signals subset set tuples signals particular said satisfy process ans satisfies process called behavior process 
process set possible behaviors relation signals 
applications natural partition signals associated process inputs outputs 
intuitively process determine values inputs determine values outputs 
partition process inputs outputs subset words process defines relation input signals output signals 
tuple said satisfy written wheres tuple input signals process tuple output signals process input signals set describes inputs set behaviors consistent input 
process functional respect partition single valued possibly partial mapping thatis 
case write wheref possibly partial function 
input signals output signals determined unambiguously behavior 
consider motivating example introducing mechanisms denote temporal behavior problem modeling time invariant dynamical system computer 
underlying mathematical model set differential equations continuous time directly implementable digital computer due double quantization real numbers finite bit strings time clock cycles 
translation required means integration rule differential equations set difference equations compute values signal tag values signals previous current tags 
possible identify strongly connected components dependency graph system decoupled 
possible go total order tags implicit physical time partial order imposed depth ordering components 
partial ordering gives freedom implementing integration rule computer 
example play scheduling embedding partial order total order clock cycles 
convenient example directed graph node signal edge signals equation depends 
evaluate component completely tags evaluating components depend 
possible spread computation multiple processors 
time comes back picture double mapping total partial order back total order essential 
prove properties implementation stability integration method bound maximum execution time 
optimize implementation respect cost function size buffers required hold intermediate signals versus execution time satisfaction constraint maximum execution time state models computation include components state behavior sequence state transitions 
order formalize notion consider process functional respect partition 
assume moment belongs timed system tags totally ordered 
tuple signals define tuple possibly empty subset events tags greater input signal tuples relation denoted ifr implies definition intuitively means process distinguish histories prior time inputs identical time outputs identical 
equivalence relation partitioning set input signal tuples equivalence classes long tradition call equivalence classes states hardware community components state called combinational components state called sequential 
note term sequential different ways communities 
decidability components finite number states differ significantly infinite number states 
certain infinite state models turing complete desirable properties undecidable determined finite amount time systems 
properties include system need memory available system halt fast system run 
hopcroft ullman discuss issues length 
undecidability insurmountable barrier decidability sufficient answer questions practice required run time may prohibitive 
successful systems designed undecidable languages questions programs undecidable 
algorithm solve undecidable problem systems algorithms exist solve systems 
buck boolean dataflow scheduler example answer halting bounded memory problems systems specified turing complete dataflow model necessarily fail reach systems 
non terminating nature embedded systems opens possibility infinite time solve certain undecidable problems 
parks scheduler example execute potentially infinite state system forever bounded memory possible 
answer question memory needed program eventually halt 
classical von neumann model computation familiar model sequential behavior 
memory stores state processor advances state sequence memory operations 
commonly programming languages lisp pascal fortran model computation 
memory formalized model called random access machine random access stored program 
viewed having unbounded number finite valued words coupled appropriate choice processor instructions model turing complete modern computer systems model practical simulating unbounded memory elaborate hierarchy registers cache ram hard disk 
embedded systems currently afford scheme 
concurrency communication sequential combinational behavior related individual processes embedded systems typically contain coordinated concurrent processes 
systems interact environment evolves independently speed 
common partition model tasks evolve independently occasionally frequently interacting 
turing completeness obtained finite number infinite valued words 
communication processes explicit implicit 
explicit communication sender process informs receiver processes part state 
implicit communication processes share common notion state 
time plays larger role embedded systems classical computation 
classical transformational systems correct result primary concern arrives important arrives termination question important 
contrast embedded systems usually real time systems time computation takes place important computation 
discussed different models time different order relations set tags tagged signal model 
recall timed system totally ordered untimed system partially ordered 
implicit communication generally requires totally ordered tags usually identified physical time 
tags metric time system notion distance physical time 
formally exists partial function mapping pairs tags real numbers 
event system timed system tags signal order isomorphic integers sided system natural numbers sided system 
intuitively means pair ordered tags finite number intervening tags 
events synchronous tag 
signals synchronous event signal synchronous event signal vice versa 
system synchronous signal system synchronous signal system 
discrete time system synchronous discrete event system 
synchronous reactive languages see synchronous exactly sense 
set tags behavior system denotes global clock system 
signal conceptually event tag models event value denoting absence event called bottom 
clock tick process maps input values output values 
cyclic communication allowed mechanism provided resolve prevent circular dependencies 
possibility constrain output values tags corresponding tick 
possibility common leave result unspecified resulting worse infinite computation tick 
third possibility fixed point semantics behavior system defined set events satisfy processes 
concurrency physical implementations systems occurs combination parallelism having physically distinct computational resources interleaving sharing common physical resource 
mechanisms achieving interleaving vary widely ranging operating systems manage context switches fully static interleaving concurrent processes converted compiled single non concurrent process 
focus mechanisms manage communication concurrent processes 
parallel physical systems naturally share common notion time laws physics 
time event subsystem occurs natural ordering relationship time event occurs subsystem 
physically interleaved systems share natural common notion time 
logical systems hand need mechanism explicitly share notion time 
consider imperative programs interleaved single processor control time sharing operating system 
interleaving creates natural ordering events processes ordering generally unreliable heavily depends scheduling policy system load 
synchronization mechanism required programs need cooperate 
generally logically concurrent systems maintaining coherent global notion time total order events extremely expensive 
practice replaced possible explicit synchronization inwhich total order replaced partial order 
returning example processes running time sharing operating system take precautions ensure ordering events ordering events matters 
variety mechanisms managing order events communicating information processes arisen 
common ones unsynchronized unsynchronized communication producer information consumer information coordinated 
guarantee consumer reads valid information produced producer guarantee producer overwrite previously produced data consumer reads data 
tagged signal model repository data modeled process reading writing events enforced ordering relationship tags 
read modify write commonly accessing shared data structures strategy locks data structure read write process preventing accesses 
words actions reading modifying writing atomic indivisible 
tagged signal model repository data modeled process events associated process totally ordered resulting globally partially ordered model 
read modify write modeled single event 
unbounded fifo buffered point point communication strategy producer generates sequence data tokens consumer consumes tokens generated 
tagged signal model simple connection signal connection constrained totally ordered tags 
tags model ordering imposed fifo model 
consumer implements blocking reads imposes total order events input signals 
model captures essential properties kahn process networks dataflow 
bounded fifo buffered case data repository modeled process imposes ordering constraints inputs come producer outputs go consumer 
input output signals internally totally ordered 
simplest case size buffer case input output events interleaved output event lies input events 
larger buffers impose maximum difference called synchronic distance number input output events 
note implementations communication mechanism may really block writing process buffer full requiring higher level flow control ensure happens cause harm 
rendezvous simplest form rendezvous implemented example occam lotos single writing process single reading process simultaneously point control flow write read occur 
convenient communication mechanism semantics single assignment writer provides right hand side reader provides left hand side 
tagged signal model imposed events identical tags 
lotos offers addition multiple rendezvous multiple possible communications non deterministically selected 
multiple rendezvous flexible single rendezvous allows designer specify easily expected communication ports time difficult expensive implement correctly 
course various combinations models possible 
example partially unsynchronized model consumer data may required wait time producer produces data communication unsynchronized 
essential features concurrency communication styles described table 
distinguished number transmitters receivers broadcast versus point point communication size communication buffer transmitting receiving process may continue unsuccessful communication attempt blocking reads writes result write read single reads 
common models computation ready scheme developed previous section classify analyze models computation describe embedded systems 
consider issues ease modeling efficiency analysis simulation formal verification automated optimization space versus specification 
discrete event time integral part discrete event model computation 
events usually carry totally ordered time stamp indicating time event occurs 
de simulator usually maintains global event queue sorts events time stamp 
digital hardware simulated discrete event approach 
verilog language example designed input language discrete event simulator 
vhdl language underlying discrete event model computation 
discrete event modeling expensive sorting time stamps time consuming 
ironically discrete event ideally suited modeling distributed systems challenging build distributed discrete event simulator 
global ordering events requires tight coordination parts simulation rendering distributed execution difficult 
discrete event simulation efficient large systems large frequently idle autonomously operating sections 
discrete event simulation changes system need processed system 
activity system increases discrete event paradigm efficient overhead inherent processing time stamps 
simultaneous events especially arising zero delay feedback loops challenge discrete event models computation 
situation events may need ordered 
consider discrete event system shown 
process zero delay meaning output time stamp input 
process produces events time stamp output ambiguity invoked shown 
suppose invoked shown 
depending simulator invoked observing input events invocation invoked twice processing events time 
case clear way determine event processed 
addition delta delay easier prevent avoid completely 
introduces level model time instant time broken potentially infinite number totally ordered delta steps 
simulated time reported user include delta information 
zero delay process model delta delay 
example process delta delay firing followed result situation 
firing see event firing see delay delayed event simulators including de simulator ptolemy attempt statically analyze data precedences single time instant 
precedence analysis similar done synchronous languages esterel lustre signal ensure simultaneous events processed deterministically 
determines partial ordering events time stamp examining data precedences 
adding feedback loop process create problem events circulate loop increment time stamp 
problem occurs synchronous languages loops called causality loops 
precedence analysis resolve ambiguity 
synchronous languages compiler may simply fail compile program 
discrete event simulators execute program nondeterministically support tighter control sequencing graph annotations 
communicating finite state machines finite state machines fsms attractive model embedded systems 
amount memory required model decidable explicit part specification 
halting performance questions decidable state theory examined finite time 
practice may prohibitively expensive 
traditional fsm consists set input symbols cartesian product sets values input signals set output signals cartesian product sets values output signals finite set states distinguished initial state output function mapping inputs states outputs state function mapping inputs states states 
input machine sequence input symbols output sequence output symbols 
traditional fsms modeling sequential behavior impractical modeling concurrency memory called state explosion problem 
single machine mimicking concurrent execution group machines number states equal product number states machine 
memory states number values stored location raised power number locations 
number states indication complexity strong correlation 
harel advocated major mechanisms reduce size visual complexity finite automata modeling practical systems 
hierarchy state represent enclosed state machine 
particular state interpretation state machine enclosed active 
equivalently state means machine states enclosed interpretation states called states states exponentially reduce complexity number states required represent system 
compactly describe notion preemption high priority event suspending killing lower priority task fundamental embedded control applications 
second mechanism concurrency 
state machines viewed simultaneously active 
system state parallel state machine simultaneously called states provide potential exponential reduction size system representation 
third mechanism non determinism 
non determinism simply result imprecise erroneous specification extremely powerful mechanism reduce complexity system model abstraction 
abstraction due fact exact functionality defined irrelevant properties currently considered interest 
verification system component components modeled non deterministic entities compactly constrain behavior 
system component described non deterministically permit optimization implementation phase 
non determinism provide exponential reduction complexity 
mechanisms shown cooperate synergistically orthogonally provide potential triple exponential reduction size representation respect single flat deterministic fsm exact claim type non determinism non deterministic choices successful hierarchical states third source exponential reduc harel statecharts model uses synchronous concurrency model called synchronous composition 
set tags totally ordered countable set denotes global clock system 
events signals produced state transitions inputs 
events tick clock trigger state transitions parallel state machines clock 
unfortunately harel left open questions semantics causality loops chains instantaneous tick events triggering flurry activity community resulted variants statecharts 
variants synchronous concurrency model 
applications tight coordination implied synchronous model inappropriate 
response number loosely coupled asynchronous fsm models evolved including behavioral fsms sdl process networks tion type non determinism concurrency 
hierarchical states hand shown able simulate non determinism polynomial increase size 
codesign fsms 
model closely related fsms finite automata 
fas emphasize acceptance rejection sequence inputs sequence output symbols produced response sequence input symbols 
notions composition naturally extended model 
fact concurrency models described usefully combined fsms 
ptolemy project fsms hierarchically nested dataflow discrete event synchronous reactive models 
nesting arbitrarily deep mix concurrency models different levels hierarchy 
flexible model called charts pronounced star charts asterisk meant suggest wildcard 
control flow expressions proposed represent control flow set operations cycle specification language 
algebraic model extending regular expressions compiled fsms synthesis control unit 
synchronous reactive synchronous model computation events synchronous signals events identical tags 
tags totally ordered globally available 
simultaneous events clock tick may totally ordered partially ordered unordered depending model computation 
discrete event model signals events clock ticks simplifying simulator requiring sorting 
simulators exploit simplification called cycle cycle driven simulators 
processing events clock tick constitutes cycle 
cycle order events processed may determined data precedences define microsteps 
precedences allowed cyclic typically impose partial order leaving arbitrary ordering decisions scheduler 
cycle models excellent clocked synchronous circuits applied successfully system level certain signal processing applications 
cycle model inefficient modeling systems events occur rate signals 
conceptually systems modeled example special tokens indicate absence event cost processing tokens considerable 
fortunately cycle model easily generalized multirate systems 
case nth event signal aligns events 
multirate cycle model somewhat limited 
excellent model synchronous signal processing systems sample rates related constant rational multiples situations alignment events different signals irregular inefficient 
general synchronous reactive model embodied called synchronous languages 
esterel textual imperative language sequential concurrent statements describe hierarchically arranged processes 
lustre textual declarative language dataflow flavor mechanism multirate clocking 
signal textual relational language dataflow flavor powerful clocking system 
argos derivative harel statecharts graphical language describing hierarchical finite state machines 
halbwachs gives summary group languages 
synchronous reactive languages describe systems set concurrently executing synchronized modules 
modules communicate signals absent clock tick 
presence signal called event carries value integer 
modules reactive sense perform computation produce output events instants input event 
signal languages conceptually explicitly accompanied clock signal meaning relative clock signals defines global ordering events 
comparing signals associated clock signals indicate events simultaneous precede follow 
case signal lustre clocks complex interrelationships clock calculus allows compiler reason ordering relationships detect inconsistencies definition 
esterel argos simpler clocking schemes focus finite state control 
languages static sense request additional storage create additional processes running 
suited bounded speed critical embedded applications behavior extensively analyzed compile time 
static property synchronous program finite state greatly facilitating formal verification 
verifying synchronous program causal non contradictory deterministic fundamental challenge languages 
computation languages delay free arbitrary interconnection processes possible possible specify program interpretation contradiction consistent value signal multiple interpretations signal consistent value 
situations undesirable usually indicate design error 
conservative approach checks causality problems structurally flags unacceptably large number programs incorrect manifest unreachable program states 
alternative check causality problem reachable state expensive requires exhaustive check state space program 
addition ability translate languages finite state descriptions possible compile languages directly hardware 
techniques translating esterel lustre hardware proposed 
result logic network consisting gates flip flops optimized traditional logic synthesis tools 
execute system software resulting network simply simulated 
technique basis perform efficiently causality checks means implicit state space traversal techniques 
dataflow process networks dataflow program specified directed graph nodes called actors represent computations arcs represent totally ordered sequences called streams events called tokens 
large circles represent actors small circle represents token lines represent streams 
graphs represented visually typically hierarchical actor graph may represent directed graph 
nodes graph language primitives subprograms specified language fortran 
inthe case mixing models computation dataflow serves coordination language subprograms written imperative host language 
dataflow special case kahn process networks 
kahn process network communication unbounded fifo buffering processes constrained continuous mappings input streams output streams 
continuous usage topological property ensures program determinate 
intuitively implies form causality time specifically process partial information input streams produce partial information output streams 
adding tokens input stream result having change remove tokens output stream produced 
way ensure continuity blocking reads access input stream results suspension process tokens 
consequence blocking reads process test input channel availability data branch conditionally point read different input 
dataflow process decomposed sequence firings indivisible quanta computation 
firing consumes produces tokens 
dividing processes firings avoids multitasking overhead context switching direct implementations kahn process networks 
fact signal processing environments major objective statically compile time schedule actor firings achieving interleaved implementation concurrent model computation 
firings organized list processor set lists multiple processors 
shows dataflow graph shows single processor schedule 
schedule list firings repeated indefinitely 
cycle schedule return graph original state state defined number tokens arc 
possible considerable simplification results 
existing environments happens firing specified host language imperative semantics 
ptolemy system consist quantum computation specified models computation fsms synchronous reactive subsystem discrete event subsystem 
useful formal device constrain operation firing functional simple stateless mapping input values output values 
note constrain process stateless maintain state self loop output connected back inputs 
initial token self loop provides initial value state 
possibilities explored precise semantics dataflow coordination languages including karp miller computation graphs lee messerschmitt synchronous dataflow graphs cyclo static dataflow model kaplan processing graph method pgm granular lucid 
limit expressiveness exchange formal properties provable liveness bounded memory 
synchronous dataflow sdf cyclo static dataflow require processes consume produce fixed number tokens firing 
useful property finite static schedule return graph original state 
allows extremely efficient implementations 
general dataflow models undecidable schedule exists 
looser model dataflow tagged token model partial order tokens explicitly carried tokens 
significant advantage model logically preserves fifo semantics channels permits order execution 
examples graphical dataflow programming environments intended signal processing including image processing ptolemy 
models commonly partially ordered concurrency model rendezvous 
concurrent sequential processes proceed autonomously certain points control flow coordinate simultaneously specified points 
rendezvous developed elaborate process calculi hoare csp milner ccs 
implemented occam lotos programming languages 
ada uses rendezvous implementation quite different remote procedure calls elementary synchronization primitives 
rendezvous models computation called synchronous 
definition synchronous 
events partially ordered totally ordered rendezvous points imposing partial ordering constraints 
discussing concurrent models computation complete mentioning petri nets 
petri nets basic form turing complete finite state 
interesting uninterpreted model different classes problems including relevant embedded system design process control asynchronous communication scheduling 
questions petri nets answered finite time 
large user community developed large body theoretical results practical design aids methods 
particular partial order verification methods possible answer state explosion problem fsm verification techniques 
languages distinction language underlying model computation important 
model computation give rise fairly different languages imperative algol languages pascal fortran 
languages vhdl verilog support models computation model computation affects directly support imperative model process discrete event model processes 
support extended finite state machines suitable restrictions known synthesizable subset 
expressiveness language behaviors described language syntax affects compactness modularity reusability 
example object oriented properties imperative languages matter syntax model computation 
expressiveness language important issue 
extreme language expressive specify particular behavior clearly unsuitable extreme raises problems 
language expressive raises complexity analysis synthesis 
fact expressive languages analysis synthesis problems undecidable algorithm solve problem instances finite time 
language desired behavior represented succinctly problematic 
difficulty solving analysis synthesis problems linear size problem description bad times exponential choosing language desired behavior system compact critical 
language may incomplete 
example may specify interaction computational modules computation performed modules 
provides interface host language specifies computation called coordination language examples include linda granular lucid ptolemy domains 
language may specify causality constraints interactions detailing interactions providing interface host language 
case language tool prove properties systems done example process calculi petri nets 
modeling components system replaced nondeterminate specifications give constraints behavior behavior 
abstraction provides useful simplifications help formal verification 
heterogeneous models computation variety models computation developed partially due immaturity field 
appears different models fundamentally different strengths weaknesses attempts find common features result models low level difficult 
low level models dijkstra systems provide theoretical foundation basis design 
faced alternatives designing complex heterogeneous systems 
single unified approach suffer consequences mix approaches 
unified approach today choose vhdl mixed hardware software design doing entire design specifying software vhdl hardware 
worse bloat vhdl language including subset designed software specification making ada subset vhdl 
alternative advocate mix approaches keeping conceptually distinct example vhdl mixed hardware software design 
key problem mixed approach define semantics interaction fundamentally different models computation 
simply problem interfacing languages 
easy example provide mechanism calling procedures vhdl 
mean concurrent vhdl entities call procedures interact 
problem exacerbated lack agreed semantics vhdl 
studying interaction semantics mixed models computation main objective ptolemy project 
hierarchical framework specification model computation contain primitive internally implemented model computation 
object oriented principle information hiding isolate models possible 
validation validation loosely refers process determining design correct 
simulation remains main tool validate model importance formal verification growing especially safety critical embedded systems 
infancy shows promise verification arbitrary systems generic software programs embedded systems specified restricted way 
example finite state 
safety properties including deadlock detection detected time independent way existing model checking language containment methods see kurshan burch 
unfortunately verifying temporal properties difficult alur henzinger provide summary 
research needed practical 
simulation simulating embedded systems challenging heterogeneous 
particular contain software hardware components simulated time 
simulation problem 
basic simulation problem reconciling apparently conflicting requirements execute software fast possible host machine may faster final embedded cpu certainly different keep hardware software simulations synchronized interact just target system 
approach taken practice general purpose software simulator vhdl verilog simulate model target cpu executing software program simulation model 
different models employed tradeoff accuracy performance gate level models viable small validation problems processor simple little code needs run 
instruction set architecture isa models augmented hardware interfaces isa model standard processor simulator written augmented hardware interface information coupling standard logic simulator 
bus functional models hardware models processor interface run software 
configured programmed interface appear software running processor 
stochastic model processor program determine mix bus transactions 
translation models convert code executed processor code executed natively computer doing simulation 
preserving timing information coupling translated code hardware simulator major challenges 
accuracy required acceptable simulation performance achievable standard computers designers resort emulation 
case configurable hardware emulates behavior system designed 
problem accurate modeling controlled electromechanical system generally governed set differential equations 
requires interfacing entirely different kind simulator 
simulation methods section survey representative simulation methods summarized table 
unified approach entire system translated form suitable single simulator conceptually simple computationally inefficient 
making better computational resources means distributing simulation synchronization processes challenge 
method proposed gupta typical unified approach simulation 
relies single custom simulator hardware software uses single event queue high level bus cycle model target cpu 
takes distributed approach loosely links hardware simulator software process synchronizing standard interprocess communication mechanisms offered host operating system 
problems approach relative clocks software hardware simulation synchronized 
requires handshaking protocols may impose undue burden implementation 
may happen example hardware software need handshaking hardware part runs reality faster simulation 
wilson describes commercial hardware simulator 
approach simulator software compiled host processor interact bus cycle emulator inside hardware simulator 
software hardware simulator execute separate processes communicate unix pipes 
thomas take similar approach 
approach keeps track time software hardware independently various mechanisms synchronize periodically 
example hagen describe level simulation environment combines timed untimed level 
untimed level verify time independent properties system functional correctness 
level software hardware run independent passing messages needed 
allows simulation run maximum speed full advantage native debugging environments software hardware 
timed level verify time dependent properties requiring definition time hardware software 
hardware time measured basis clock cycles cycle simulation assuming synchronous operation maximum performance basis estimated extracted timing information maximum precision 
software hand time measured profiling clock cycle counting information maximum performance executing model cpu maximum precision 
authors propose basic mechanisms synchronizing time hardware software 

software master hardware slave 
case software decides send message tagged current software clock cycle hardware simulator 
depending relation software hardware time hardware simulator continue simulation software time back simulation software time requires checkpointing capabilities hardware simulators currently 

hardware master software slave 
case hardware simulator directly calls communication procedures turn call user software code 
lee lee rabaey take similar approach 
simulation design environment ptolemy provide interfacing mechanism different domains 
ptolemy objects described different levels abstraction different semantic models composed hierarchically 
abstraction level semantic model domain dataflow discrete event 
atomic objects called stars primitives domain dataflow operators logic gates 
simulation mode reacting events producing events synthesis mode producing software hardware description 
galaxies collections instances stars galaxies 
instantiated galaxy belong domain different instantiating domain 
domain includes scheduler decides order stars executed simulation synthesis 
synthesis possible construct schedule statically 
galaxy instantiates galaxy belonging domain typical simulation ptolemy provides mechanism called wormhole schedulers communicate 
simplest form communication pass time stamped events interface domains appropriate data type conversion 
lee perform simulation specification level dataflow model implementation level isa processor model augmented interfaces hardware simulator built ptolemy 
lee rabaey simulate specification concurrent processes communicating queues timed model ptolemy communicating processes domain 
message exchanging mechanism retained implementation mix microprocessor boards dsps asics performing simulation part implementation simulation model rest 
example software running microprocessor run host computer dsp software runs dsp 
paulin describe environment coupled retargetable compiler cycle simulation user definable dsp architecture 
user provides description dsp structure functionality environment generates behavioral bus cycle vhdl model run code standard hardware simulator 
formal verification formal verification process mathematically checking behavior system described formal model satisfies property described formal model 
models may may share common semantic interpretation 
ability carry formal verification strongly affected model computation determines decidability complexity bounds 
distinct types verification arise specification verification checking property high level model 
example checking protocol modeled network communicating fsms deadlock 
implementation verification checking relatively low level model correctly implements higher level model satisfies implementation dependent property 
example checking piece hardware correctly implements fsm dataflow network implementation dsp completely processes input sample arrives 
implementation verification hardware relatively developed area industrial strength products appear 
example logic synthesis systems mechanism verify gate level implementation set boolean equations fsm detect bugs synthesis software simulation fall definitions property behavior stimulus expected term formal verification usually reserved checking properties system hold broad class inputs 
properties traditionally broken classes safety properties state matter inputs matter non deterministic choices resolved inside system model system get shows need implementation verification eliminated automated synthesis techniques 
specific undesirable configuration deadlock emission undesired outputs liveness properties state desired configuration visited eventually infinitely expected response input complex checks correct implementation specification usually done terms basic properties 
example dill describes method define check correct implementation asynchronous logic circuits automata theoretic framework 
section summarize major approaches applied embedded system verification 
roughly divided classes theorem proving methods provide environment assists designer carrying formal proof specification implementation correctness 
assistance form checking correctness proof performing steps proof automatically gordon melham hol boyer moore system pvs 
main problems approach undecidability higher order logics large size search space decidable logics 
finite automata methods restrict power model order automate proofs 
finite automaton simplest form consists set states connected set edges labeled symbols alphabet 
various criteria define finite infinite sequences symbols accepted automaton 
set accepted sequences generally called language automaton 
main verification methods case language containment model checking 
language containment system property verified described synchronous composition automata 
proof carried testing language contained language kurshan approach typical 
particularly simple case occurs comparing synchronous fsm hardware implementation 
automata finite strings proof equivalence performed traversing state space product 
simulation relations efficient sufficient conservative criterion establish language containment properties automata originating process algebraic community 
informally simulation relation relation states automata pair states symbol labeling edge pair states symbol relation computed quickly exact language containment test case non deterministic automata requires exponential determinization step fast heuristic check 
simulation relation holds directions true symbol labeling edge called bisimulation 
bisimulation test behavioral equivalence directly supports composition abstraction hiding edge labels 
self bisimulation equivalence relation states automaton minimize automaton result called quotient automaton 
model checking see system modeled synchronous asynchronous composition automata property described formula temporal logic 
proof carried traversing state space automaton marking states satisfy formula 
infinite automata methods deal infinite state spaces minimization finite form possible 
example class called timed automata set real valued clocks measure time 
severe restrictions applied order model decidable 
clocks tested started reset part edge labels finite automaton 
clocks compared integer values initialized integer values 
case possible show finite set equivalence class representatives sufficient represent exactly behavior timed automaton 
varaiya introduced notion suspension extends class systems modeled variations timed automata 
possible principle verify timing constraint satisfaction preemptive scheduling allows low priority process stopped middle computation high priority 
main obstacles widespread application finite automata methods inherent complexity problem difficulty designers generally accustomed simulation models formally model system properties 
synchronous composition automata basis known automata methods inherently sensitive number states component automata size total state space product sizes component state spaces 
abstraction promising technique tackle problem generally known state space explosion 
abstraction replaces generally requiring extensive user intervention system components simpler versions exhibiting nondeterministic behavior 
nondeterminism reduce size state space losing possibility verifying desired property 
basic idea build provably conservative approximations exact behavior system model complexity verification lower false positive results possible 
verification system may say approximate model satisfy property original requiring better approximation say approximate model satisfies property original 
quotient respect bisimulation place component providing mechanism false negative results fight space explosion 
systematic application formal verification techniques early stages design may lead new definition optimal size module apart currently generally related human understanding synthesis compilation 
leaf level module small admit verification large possess interesting verifiable properties 
possibility meaningfully applying abstraction determine appropriate size contents modules upper levels hierarchy 
interesting family formal verification techniques useful heterogeneous systems multiple concurrent agents notion partial ordering computations execution process network 
direct available concurrency information verification process reduce number explicitly explored states 
methods called mazurkiewicz traces trace equivalence class sequences state transitions concurrent transitions permuted 
model checking language containment especially useful verifying correctness protocols particularly suited finite automaton model due relative data independence 
may claim closely related paradigms represent solutions specification verification problem currently close industrial applicability development extremely efficient implicit representation methods state space binary decision diagrams require represent store reachable state modeled system explicitly 
degree automation property satisfaction language containment checks suitable abstraction hand 
match underlying semantics state transition objects finite state behavior digital systems 
verification problem difficult take account actual value data operations performed timing properties system 
problem tackled assuming equality arithmetic functions name different levels modeling specification implementation see burch dill separately verifying piece hardware implements correctly arithmetic function see bryant 
timing verification problem sequential systems hand needs formulated way permits solution practical problems reasonable amount space time 
possibility proposed simultaneously incrementally add timing constraints initially untimed model immediately building full blown timed automaton 
addition done iteratively gradually eliminate false violations desired properties due fact timing properties model ignored 
iteration shown converge speed convergence depends heavily ingenuity designer providing hints verification system timing information consider 
young technologies optimism verification techniques initially led excessive claims potential particularly area software verification term proving programs broadly touted 
reasons including undecidability verification problems fact verification properties designer specifies optimism misplaced 
berry suggested term automatic bug detection place verification underscore hope conclusive proof nontrivial design 
goal verification technology help designers preventing problems deployed systems 
synthesis synthesis mean broadly stage design refinement specification translated specification suggested 
embedded systems synthesis combination manual automatic processes divided stages mapping architecture general structure implementation chosen partitioning sections specification bound architectural units hardware software synthesis details units filled 
informally distinguish software synthesis software compilation type input specification 
term software compilation generally associated input specification pascal imperative generally non concurrent languages 
languages syntax semantics close implementation assembly executable code 
sense describe fairly detailed level desired implementation software 
term software synthesis denote optimized translation process high level specification describes function performed way implemented 
examples software synthesis example assembly code generation capabilities digital signal processing graphical programming environments ptolemy graphical fsm design environments statecharts synchronous programming environments esterel lustre signal 
higher higher level synthesis approaches started appear 
particularly promising technique embedded systems supervisory control pioneered ramadge wonham 
synthesis methods start explicit model system designed behave supervisory control describes achieve 
cleverly combines classical control system view world automata theoretic techniques synthesize control algorithm sense optimum 
supervisory control distinguishes plant abstraction physical system controlled controller embedded system synthesized 
finite automaton model plant possibly including limitations controller expected behavior complete system plant plus controller possible determine finite state controller satisfying specification exists best finite state controller cost function minimum estimated implementation cost 
papers dealing variations problem example 
mapping specification architecture problem architecture selection design key aspects design embedded systems 
supporting designer choosing right mix components implementation technologies essential success final product methodology design 
generally speaking mapping problem takes input functional specification produces output architecture assignment functions architectural units 
architecture generally composed hardware components microprocessors microcontrollers memories devices asics fpgas software components operating system device drivers procedures concurrent programs interconnection media channels busses shared memories 
partitioning determines parts specification implemented components actual implementation created software hardware synthesis 
cost function optimized mapping process includes mixture time area component cost power consumption relative importance depends heavily type application 
time cost may measured execution time algorithm missed deadlines soft real time system area cost real time systems individual timing constraints systems classified soft hard missing deadline just degrades sys may measured chip board memory size 
components cost function may take form hard constraint quantity minimized 
current synthesis methods invariably impose restrictions target architecture order mapping problem manageable 
example architecture may limited library pre defined components due vendor restrictions interfacing constraints 
papers published automating design say memory hierarchy subsystem standard components 
notable exceptions rule papers dealing retargetable compilation formulation partitioning design kumar prakash parker gajski 
structure application specific hardware components hand generally constrained 
communication mechanisms tem performance causes catastrophic failure 
standardized methodology 
choices closely tied communication mechanism specification level offered designer 
done design interfaces chou 
partitioning partitioning problem design component 
particularly interesting problem embedded systems heterogeneous hardware software mixture 
partitioning methods classified shown table main characteristics specification model supported granularity cost function algorithm 
explored algorithm classes include greedy heuristics clustering methods iterative improvement mathematical programming 
far clear winner partitioning methods partly due early stage research area partly due intrinsic complexity problem preclude exact formulation realistic cost function general case 
ernst graph model nodes corresponding elementary operations statements language extended concurrency 
cost derived profiling aimed discovering bottlenecks eliminated initial software partition moving operations hardware estimating closeness operations including control locality distance number control nodes activations operation control flow graph data locality number common variables operations operator closeness similarities add subtract close estimating communication overhead incurred blocks moved partitions 
approximated static number data items exchanged partitions assuming simple memory mapped communication mechanism hardware software 
partitioning done loops 
inner loop uses simulated annealing quick estimation gain derived moving operation hardware software improve initial partition 
outer loop uses synthesis refine estimates inner loop 
perform performance driven partitioning working block block basis 
specification model hardware description language 
allows synthesis hardware cost estimation profiling compiled code simulator software cost estimation 
partitioning done scheduling goal minimize response time context emulation speed simulation 
initial partition obtained classifying blocks synthesizable communication overhead justifies hardware implementation 
determines blocks go software hardware 
uncommitted blocks assigned hardware software starting block gain specific choice 
initial partition improved kernighan lin iterative swapping procedure 
kumar hand consider partitioning general form 
complex set representation system various implementation choices various costs associated 
cost attributes determined mainly profiling 
system designed represented sets available software functions hardware resources communications software hardware units functions implemented assigned set software functions hardware resources communications 
means software runs hardware uses communications implement function 
partitioning process followed decomposition function virtual instruction sets followed design implementation set available resources followed evaluation phase 
ambrosio tackle problem choosing set processors set cooperating tasks executed meeting real time constraints 
mathematical formulation provide optimal solution procedure branch bound 
cost software partition estimated lower upper bound processor utilization 
upper bound obtained rate monotonic analysis see liu layland lower bound obtained various refinements sum task computation times divided task periods 
branch bound procedure uses bounds prune search space looking optimal assignments functions components satisfying timing constraints 
optimization criteria included schedulability response times tasks soft deadlines hardware costs favors software solutions 
barros graph fine grained representation unit corresponding simple statement unity specification language 
cluster units variety vague criteria similarity units concurrency control data independence sequencing control data dependence mutual exclusion vectorization sequence related assignments 
cluster units minimize cost cuts clustering tree improve clustering considering pipelining opportunities allocations done previous stage cost savings due resource sharing 
lee acyclic dependency graph derived dataflow graph simultaneously map node task software hardware schedule execution tasks 
approach heuristic give approximate solution large problem instances 
guide search process uses critical path information suitability node hardware software 
example bit manipulations better suited hardware random accesses data structure better suited software 
gajski perform graph partitioning variable grained specification 
specification language hierarchical model leaves states hierarchical statecharts finite state machine 
states contain arbitrarily complex behavioral vhdl processes written high level specification style 
cost function estimation done leaf level 
level assigned estimated number pins estimated area performing behavioral rtl logic synthesis isolation estimated execution time obtained simulating initial implementation considering communication delay 
area estimate changed leaves mapped physical entity due potential sharing 
cost model attached graph nodes represent leaves edges represent control activation deactivation data communication dependencies 
classical clustering partitioning algorithms applied followed refinement phase 
refinement partition synthesized get better area timing estimates peripheral graph nodes moved partitions greedily reduce cost 
cost partition simple weighted sum area pin chip count performance constraint satisfaction measures 
describe complete synthesis environment cdfg representation derived array specification formats verilog vhdl cdfg partitioned hand results profiling mapped architecture include general purpose micro processors asips application specific instruction processor software programmable components designed ad hoc application asics application specific integrated circuits 
interesting aspect approach architecture fixed synthesis driven user defined structural description 
asic synthesis done commercial tool software synthesis general purpose specialized processors done existing retargetable compiler developed 
ben ismail voss start system specification described sdl 
specification translated solar internal representation hierarchical interconnection communicating processes 
processes merged split hierarchy changed splitting moving clustering subunits 
sequencing operations currently done user 
chou borriello describe specialized scheduling algorithm interface partitioning 
algorithm graph model derived formalized timing diagram 
nodes represent low level events interface specification 
edges represent constraints derived causality links specification added partitioning process example represent events occur wire moved 
cost function time software area hardware 
algorithm min cut procedure applied graph order reduce congestion 
congestion case defined software required produce events rapidly target processor implies need hardware assistance 
hardware software synthesis partitioning partitioning order provide cost estimates hardware software components embedded system implemented 
inputs problem specification set resources possibly mapping architecture 
objective realize specification minimum cost 
generally speaking constraints optimization criteria step partitioning 
area code size traded performance dominates due real time characteristics embedded systems 
cost considerations generally suggest software running shelf processors possible 
choice things allows separate software hardware synthesis process relying form pre designed customized interfacing mechanism 
exception rule authors propose simultaneous design computer architecture program run marwedel 
designers general purpose cpus face different problems designers embedded systems consider authors synthesize application specific instruction processor asip micro code runs 
designer general purpose cpu worry backward compatibility compiler support optimal performance wide variety applications embedded system designer worry addition new functionality user interaction satisfaction specific set timing constraints 
note asip standard application specific integrated circuit asic generally limited programming capabilities embedded system designer couple advantages hardware software 
example performance power consumption improved respect software implementation general purpose micro controller dsp flexibility improved respect hardware implementation 
method achieve goal reprogrammable hardware field programmable gate arrays 
fpgas reprogrammed line just embedded software upgraded changing rom line speed algorithm currently executed 
hardware synthesis task asics embedded systems implemented fpgas generally performed classical high level logic synthesis methods 
techniques worked extensively example books de micheli devadas wolf describe detail 
marwedel goossens overview code generation strategies dsps asips 
software synthesis task embedded systems hand relatively new problem 
traditionally software synthesis regarded suspicion mainly due excessive claims infancy 
fact problem constrained embedded systems compared general purpose computing 
example embedded software virtual memory due physical constraints absence swapping device real time constraints need partition specification software hardware 
severely limits applicability dynamic task creation memory allocation 
highly critical applications stack may forbidden dealt polling static variables 
algorithms tend simpler clear division cooperating tasks solving specific problem digital filtering input source protocol handling channel 
particular problem translating cooperating finite state machines software solved number ways 
software synthesis methods proposed literature classified shown table general lines specification formalism interfacing mechanisms specification implementation levels scheduling done scheduling method 
software synthesis methods perform sort scheduling sequencing execution set originally concurrent tasks 
concurrent tasks excellent specification mechanism implemented standard cpu 
scheduling problem reviewed amounts finding linear execution order elementary operations composing tasks timing constraints satisfied 
depending linearization performed scheduling algorithms classified static scheduling decisions design compile time 
quasi static scheduling decisions run time compile time 
dynamic decision run time 
dynamic schedulers take forms particular distinguished preemptive non preemptive depending task interrupted arbitrary points 
embedded systems compelling motivations static quasi static scheduling minimizing preemptive scheduling order minimize scheduling overhead improve reliability predictability 
course cases preemption avoided feasible solution problem instance cases carefully analyzed limit preemption minimum 
static scheduling methods developed 
construct precedence graph apply adapt classical methods 
refer reader bhattacharyya lee starting point scheduling dataflow graphs 
approaches software synthesis embedded systems divide computation cooperating tasks scheduled run time 
scheduling done 
classical scheduling algorithms 
developing new techniques better knowledge domain 
embedded systems fairly restricted specification paradigms easier target specialized scheduling techniques fully general algorithms written arbitrary high level language 
approach uses example rate monotonic analysis rma perform schedulability analysis 
pure rma model tasks invoked periodically preempted deadlines equal invocation period system overhead context switching interrupt response time negligible 
basic result liu layland states hypotheses set tasks successfully scheduled static priority algorithm successfully scheduled sorting tasks invocation period highest priority task shortest period 
basic rma model augmented practical 
results real time scheduling literature develop scheduling environment supporting process synchronization interrupt service routines context switching time deadlines different task invocation period mode changes may cause change number deadlines tasks parallel processors 
parallel processor support generally consists analyzing schedulability assignment tasks processors providing designer feedback potential bottlenecks sources deadlocks 
chou advocate developing new techniques better knowledge domain 
problem consider find valid schedule processes specified verilog timing constraints 
approach gupta described classical task scheduling methods take account fine grained coarse grained timing constraints 
specification style chosen authors uses verilog constructs provide structured concurrency watchdog style preemption 
style multiple computation branches started parallel watchdogs kill occurrence condition 
set safe recovery points defined branch preemption allowed points 
timing constraints specified modes represent different states computation initialization normal operation error recovery 
constraints minimum maximum time separation events type describe occurrence rates defined mode events different modes 
scheduling performed mode finding cyclic order operations preserves rates timing constraints 
mode transformed acyclic partial order unrolling possibly splitting contains parallel loops harmonically unrelated repetition counts 
partial order linearized longest path algorithm check feasibility assign start times operations 
group describes technique device driver synthesis targeted microcontrollers specialized ports 
takes input specification system implemented description function structure port list bits directions list communication instructions 
exploit specialized functions parallel serial serial parallel conversion capabilities 
algorithm assigns communications specification physical entities micro controller 
tries special functions assigns ports resorts expensive memory mapped overflow communications 
takes account resource conflicts different bits port allocates hardware components support memory mapped output algorithm netlist hardware components initialization routines driver routines called software generation procedure communication software hardware take place 
gupta started software synthesis scheduling analyzing various implementation techniques embedded software 
specification model set threads extracted control dataflow graph cdfg derived hdl called hardware 
threads concurrent loop free routines invoke basic synchronization mechanism 
statements thread scheduled statically compile time threads scheduled dynamically run time 
concurrent language translation problem easier authors concentrate scheduling problem simulate concurrency threads 
authors compare inherent advantages disadvantages main techniques implement threads coroutines single case statement branch implements thread 
coroutine approach flexible coroutines nested respond urgent interrupts expensive due need switch context case approach 
group developed scheduling method reactive real time systems 
cost model takes account processor type memory model instruction execution time 
derived bottom cdfg assigning processor memory dependent cost leaf operation cdfg 
operations unbounded execution time data dependent loops synchronization operations 
timing constraints basically data rate constraints externally visible input output operations 
bounded time operations process linearized heuristic method problem known np complete 
linearization procedure selects operation executed predecessors scheduled immediate selection scheduling cause timing constraint missed measure urgency performs limited timing constraint lookahead 
unbounded time operations hand implemented call runtime scheduler may cause context switch favor urgent thread 
propose software synthesis method extended asynchronous finite state machines called design finite state machines 
method takes advantage optimization techniques hardware synthesis domain 
uses model multiple asynchronously communicating single fsm enabling handle systems widely varying data rates response time requirements 
tasks organized different priority levels scheduled classical run time algorithms rma 
software synthesis technique simple cdfg representing state transition output functions 
nodes cdfg types test nodes evaluate expression branch result assign nodes evaluate expression assign result variable 
authors develop mapping representations state transition output functions binary decision diagrams cdfg form body developed optimization techniques minimize memory occupation execution time 
simple cdfg form permits easy relatively accurate prediction software cost performance cost assignment cdfg node 
cost code data memory occupation performance clock cycles node type evaluated degree accuracy handful system specific parameters cost variable assignment addition branch 
parameters derived compiling running carefully designed benchmarks target processor cycle accurate emulator simulator 
tackle different problem retargetable compilation generic processor architecture 
focus optimization techniques highly asymmetric processors commercial digital signal processors example register may multiplication memory addressing 
register assignment scheme notion classes registers describing type operation register 
information cdfg covering processor instructions minimize number moves required save registers temporary locations 
marwedel uses similar cdfg covering approach 
source specification written vhdl pascal language mimola 
purpose micro code generation long instruction word vliw processors case instruction set defined 
minimum encoding control word generated control step 
control steps allocated soon possible policy asap meaning micro operation scheduled occur soon operands computed compatibly resource utilization conflicts 
control word contains bits necessary steer execution units specified architecture perform micro operations step 
register allocation done order minimize number temporary locations memory due register spills 
tiwari describe software analysis synthesis method aimed estimating power consumption program processor 
power consumption model analysis single instructions addressing modes instruction pairs simple way modeling effect processor state 
model evaluated running benchmark programs characteristics measuring current flow power ground pins 
outlined important aspects design process embedded systems including specification models languages simulation formal verification partitioning hardware software synthesis 
design process iterative design transformed informal description detailed specification usable manufacturing 
specification problem concerned representation design steps validation problem check representation consistent step steps synthesis problem transform design steps 
argued formal models necessary step design distinction language design specified underlying model computation 
models computation defined due just immaturity field fundamental differences best model function design 
heterogeneous nature embedded systems multiple models computation necessity 
models computation built combining largely orthogonal aspects sequential behavior concurrency communication 
outline tagged signal model framework developed authors contrast different models computation 
fundamental entity model event value tag pair 
tags usually denote temporal behavior different models time appear structure imposed set possible tags 
processes appear relations signals sets events 
character relation follows type process describes 
simulation formal verification key validation techniques 
embedded systems contain hardware software components challenge efficiently simulate components simultaneously 
separate simulators efficient synchronization challenge 
formal verification roughly divided theorem proving methods finite automata methods infinite automata methods 
theorem provers generally assist designers constructing proof fully automatic able deal powerful languages 
finite automata schemes represent explicitly implicitly states system check properties representation 
infinite automata schemes usually build finite partitions state space severely restricting input language 
synthesis refers step design refinement process design representation detailed 
manual automated divided mapping architecture partitioning component synthesis 
automated architecture mapping system structure defined restricts result problem manageable 
partitioning sections design bound different parts system architecture particularly challenging embedded systems elaborate cost functions due heterogeneity 
assigning execution order concurrent modules finding sequence instructions implementing functional module primary challenges software synthesis embedded systems 
edwards lee participated study part ptolemy project supported advanced research projects agency air force program contract state california micro program companies cadence hitachi lg electronics mitsubishi motorola nec philips rockwell 
lavagno sangiovanni vincentelli partially supported cadence daimler benz hitachi consiglio nazionale delle ricerche micro program src 
harry hsieh help draft 
berry information processing vol 
chapter real time programming special purpose general purpose languages pp 
north holland elsevier science publishers 
milner tofte andr harper definition standard ml mit press 
wadge ashcroft lucid dataflow programming language academic press 
davie functional programming systems haskell cambridge university press 
halbwachs synchronous programming reactive systems kluwer academic publishers 
mcmillan symbolic model checking kluwer academic 
stoy denotational semantics scott strachey approach programming language theory mit press cambridge ma 
lee sangiovanni vincentelli tagged signal model preliminary version denotational framework comparing models computation tech 
rep electronics research laboratory university california berkeley ca may 
hopcroft ullman automata theory languages computation addison wesley 
buck scheduling dynamic dataflow graphs bounded memory token flow model ph thesis university california berkeley dept eecs tech 
report ucb erl 
parks bounded scheduling process networks ph thesis university california berkeley dec dept eecs tech 
report ucb erl 
shepherdson sturgis computability recursive functions journal acm vol 
pp 

kahn semantics simple language parallel programming proc 
ifip congress 
north holland publishing buck ha lee messerschmitt ptolemy framework simulating prototyping heterogeneous systems int 
journal computer simulation vol 
pp 
apr special issue simulation software development 
ptolemy eecs berkeley edu papers ps 
harel naamad pnueli sherman trakhtenbrot statemate working environment development complex reactive systems ieee trans 
software engineering vol 
apr 
harel power bounded concurrency 
finite automata journal association computing machinery vol 
pp 
may 
von der comparison statecharts variants proc 
formal techniques real time fault tolerant systems 
vol 
lncs pp 
springer verlag 
wolf automaton model scheduling constraints synchronous machines ieee tr 
computers vol 
pp 
jan hsieh lavagno sangiovanni vincentelli formal methodology hardware software codesign embedded systems ieee micro aug 

chang lee effective heterogeneous design nato advanced study institute workshop hardware software codesign lake como italy june ptolemy eecs berkeley edu papers effective 
jr coelho de micheli analysis synthesis concurrent digital circuits control flow expressions ieee trans 
cad vol 
pp 
aug 
benveniste berry synchronous approach reactive real time systems proc 
ieee vol 
pp 

de simone esterel language proc 
ieee vol 

halbwachs caspi raymond pilaud synchronous data flow programming language lustre proc 
ieee vol 
pp 

benveniste le guernic hybrid dynamical systems theory signal language ieee transactions automatic control vol 
pp 
may 
argos language graphical representation automata description reactive systems proc 
ieee workshop visual languages kobe japan oct 
harel statecharts visual formalism complex systems sci 
comput 
program vol 
pp 

berry hardware implementation pure esterel proc 
int 
workshop formal methods vlsi design jan 
halbwachs implementing reactive programs circuits hardware implementation lustre real time theory practice rex workshop proceedings netherlands june vol 
lncs pp 
springer verlag 
berry touati constructive analysis cyclic circuits proc 
european design test conference mar 
lee parks dataflow pro cess networks proc 
ieee may ptolemy eecs berkeley edu papers 
bhattacharyya murthy lee software synthesis dataflow graphs kluwer academic press norwood mass 

chang 
ha lee heterogeneous simulation mixing discrete event models dataflow vlsi signal processing appear 
karp miller properties model parallel computations determinacy termination queueing siam journal vol 
pp 
nov 
lee messerschmitt synchronous data flow ieee proceedings sept 
ad geometric parallelism dataflow grape ii proc 
th int 
workshop rapid system prototyping grenoble france june 
engels static scheduling multi rate cyclo static dsp applications proc 
workshop vlsi signal processing 
ieee press 
kaplan processing graph method specification version naval research laboratory washington dec 
jagannathan parallel execution glu programs nd int 
workshop dataflow computing hamilton island queensland australia may 
ackerman data flow languages computer vol 

carriero gelernter linda context comm 
acm vol 
pp 
apr 
holt marked directed graphs journal computer system sciences vol 
pp 

biswas korner browne task level dataflow language parallel distributed systems vol 
june 
arvind interpreter computer vol 

williams integrated visual language software development environment journal visual languages computing vol 
pp 

hoare communicating sequential processes comm 
acm vol 

milner communication concurrency prentice hall englewood cliffs nj 
peterson petri net theory modeling systems prentice hall englewood cliffs nj 
reisig petri nets springer verlag 
valmari stubborn attack state explosion formal methods system design vol 
pp 

godefroid partial orders improve automatic verification methods proc 
computer aided verification workshop clarke kurshan eds dimacs series discrete mathematica theoretical computer science pages 
dijkstra cooperating sequential processes programming languages ed 
academic press new york 
kurshan automata theoretic verification coordinating processes princeton university press 
burch clarke mcmillan dill sequential circuit verification symbolic model checking proc 
design automation conf pp 

alur henzinger logics models real time survey real time theory practice 
rex workshop proc de bakker huizing de roever rozenberg eds 
gupta coelho jr de micheli synthesis simulation digital systems containing interacting hardware software components proc 
design automation conf june 
hardware software simulation proc 
design automation conf pp 

wilson hardware software selected cycle solution proc 
int 
workshop hardware software codesign 
thomas adams schmitt model methodology hardware software codesign ieee design test computers vol 
pp 
sept 
hagen meyr timed untimed hardware software application efficient implementation proc 
int 
workshop hardware software codesign oct 
lee hardware software design ptolemy case study proc 
int 
workshop hardware software codesign sept 
paulin flexible modeling environment embedded systems design proc 
int 
workshop hardware software codesign 
lee rabaey hardware software simulation environment proc 
int 
workshop hardware software codesign oct 
may paulin register assignment resource classification asip microcode generation proc 
int 
conf 
computer aided design nov 
dill trace theory automatic hierarchical verification speed independent circuits mit press cambridge mass acm distinguished dissertation 
gordon melham eds hol theorem proving environment higher order logic cambridge university press 
boyer kaufmann moore boyer moore theorem prover interactive enhancement computers mathematics applications pp 
jan 
owre rushby shankar pvs prototype verification system th int 
conf 
automated deduction 
june springer verlag 
coudert madre verification sequential machines boolean functional vectors ifip int workshop applied formal methods correct vlsi design november pp 

clarke emerson sistla automatic verification finite state concurrent systems temporal logic specifications acm toplas vol 

sifakis specification verification concurrent systems cesar int 
symposium programming 
april lncs springer verlag 
pnueli temporal logics programs proc 
th annual symposium foundations computer science 
may ieee press 
manna pnueli temporal logic reactive concurrent systems springer verlag 
alur dill automata modeling real time systems automata languages programming th annual colloquium vol 
lecture notes computer science pp 
warwick university july 
cousot cousot interpretation unified lattice model static analysis programs construction approximation fixpoints th acm symp 
principles programming languages los angeles january 
varaiya suspension automata decidable class hybrid automata proc 
sixth workshop computer aided verification pp 

burch automatic symbolic verification real time concurrent systems ph thesis carnegie mellon university aug 
clarke grumberg long model checking abstraction acm trans 
programming languages systems vol 
pp 
sept 
mazurkiewicz traces histories graphs instances process monoid proc 
conf 
mathematical foundations computer science eds 
vol 
lncs springer verlag 
de souza de simone partial orders verifying behavioral equivalences proc 
concur 
bryant graph algorithms boolean function manipulation ieee trans 
computers vol 
pp 
august 
burch dill automatic verification pipelined microprocessor control proc 
sixth workshop computer aided verification pp 

bryant chen verification arithmetic circuits binary moment diagrams proc 
design automation conf pp 

sangiovanni vincentelli verification strategy timing constrained systems proc 
fourth workshop computer aided verification pp 

alur itai kurshan yannakakis timing verification successive approximation proc 
computer aided verification workshop pp 

buck ha lee ptolemy framework simulating prototyping heterogeneous systems journal computer simulation vol 
special issue simulation software development january 
harel naamad pnueli statemate working environment development complex reactive systems ieee trans 
software engineering vol 
apr 
ramadge wonham control discrete event systems proc 
ieee vol 
january 
hoffmann wong toi symbolic synthesis supervisory controllers american control conference chicago june 
di benedetto sangiovanni vincentelli strong model matching finite state machines proc 
third european control conf sept 
castle interactive environment hardware software design proc 
int 
workshop hardware software codesign 
kumar johnson wulf framework hardware software codesign proc 
int 
workshop hardware software codesign sept 
kumar johnson wulf exploring hardware software abstractions alternatives codesign proc 
int 
workshop hardware software codesign oct 
prakash parker synthesis application specific multi processor architectures proc 
design automation conf june 
gajski specification partitioning system design proc 
design automation conf june 
chou borriello scheduling reactive real time systems ieee micro vol 
pp 
aug 
henkel ernst benner adaptation partitioning high level synthesis hardware software synthesis proc 
int 
conf 
computer aided design nov 
levitt software hardware approach digital system simulation ieee micro vol 
pp 
aug 
hu ambrosio murray tang codesign architectures modules ieee micro vol 
pp 
aug 
barros xiong hardware software partitioning unity proc 
int 
workshop hardware software codesign oct 
barros provably correct hardware software partitioning occam proc 
int 
workshop hardware software codesign oct 
lee global criticality local phase driven algorithm constrained hardware software partitioning problem proc 
int 
workshop hardware software codesign 
adams schmitt thomas model methodology hardware software codesign proc 
int 
workshop hardware software codesign oct 
eles peng vhdl system level specification partitioning hardware software environment proc 
int 
workshop hardware software codesign sept 
luk wu declarative framework hardware software codesign proc 
int 
workshop hardware software codesign 
gunther system synthesis hardware software codesign proc 
int 
workshop hardware software codesign oct 
ismail cosmos codesign approach communicating systems proc 
int 
workshop hardware software codesign 
methodology control dominated systems codesign proc 
int 
workshop hardware software codesign 
gupta coelho jr de micheli program implementation schemes hardware software systems ieee computer pp 
jan 
ernst henkel hardware software codesign embedded controllers hardware extraction proc 
int 
workshop hardware software codesign sept 
henkel benner ernst hardware generation partitioning effects system proc 
int 
workshop hardware software codesign oct 
ambrosio hu configuration level hardware software partitioning real time embedded systems proc 
int 
workshop hardware software codesign 
liu layland scheduling algorithms multiprogramming hard real time environment journal acm vol 
pp 
jan 
gajski narayan ramachandran system design methodologies aiming design cycle ieee trans 
vlsi vol 
mar 
design flow hardware software video compression system proc 
int 
workshop hardware software codesign 
transport triggering vs operation triggering th int 
conf 
compiler construction apr 
voss ben ismail 
theory hardware software codesign proc 
int 
workshop hardware software codesign 
smith reed telecommunications systems engineering sdl north holland elsevier 
borriello automatic synthesis device drivers hardware software codesign proc 
int 
workshop hardware software codesign oct 
bo ri re partitioning algorithm system level synthesis proc 
int 
conf 
computer aided design nov 
marwedel tree mapping algorithms predefined structures proc 
int 
conf 
computer aided design nov 
paulin dsp design tool requirements embedded systems telecommunications industrial perspective journal vlsi signal processing vol 
pp 
jan 
de micheli synthesis optimization digital circuits mcgraw hill 
devadas ghosh logic synthesis mcgraw hill 
wolf eds high level vlsi synthesis kluwer academic publishers 
marwedel goossens eds code generation embedded processors kluwer academic publishers 
constructing predictable real time systems kluwer academic publishers 
lee declustering new multiprocessor scheduling technique ieee trans 
parallel distributed systems vol 
pp 
june 
lee compile time scheduling heuristic interconnection constrained heterogeneous processor architectures ieee trans 
parallel distributed systems vol 
feb 
cochran rate monotonic analysis analyze schedulability real time software designs proc 
int 
workshop hardware software codesign sept 
hsieh lavagno sangiovanni vincentelli hardware software codesign embedded systems ieee micro vol 
pp 
aug 
chou borriello software scheduling synthesis reactive real time systems proc 
design automation conf june 
gupta de micheli constrained software generation hardware software systems proc 
int 
workshop hardware software codesign 
hsieh lavagno sangiovanni vincentelli synthesis software programs specifications proc 
design automation conf june 
suzuki sangiovanni vincentelli efficient software performance estimation methods hardware software codesign proc 
design automation conf 
may paulin instruction set matching selection dsp asip code generation european design test conf feb 
tiwari malik wolfe power analysis embedded software step software power minimization ieee trans 
vlsi systems vol 
pp 
dec 
typical reactive real time embedded system architecture 
example design refinement stage uses hardware software synthesis translate functional specification model hardware 
table comparison concurrency communication schemes 
transmitters receivers buffer blocking blocking single size reads writes reads unsynchronized read modify write unbounded fifo unbounded bounded fifo bounded single rendezvous multiple rendezvous simultaneous events discrete event system 
process produces events time stamp 
fired 
zero delay process fired 
times fired 
delta delay process fired consume output 
fired fire consume output 
dataflow process network single processor static schedule table comparison simulation methods 
hardware software synchronization simul 
simul 
mechanism gupta logic custom bus cycle custom single simul 
logic commercial host compiled handshake wilson logic commercial host compiled handshake thomas logic commercial host compiled handshake hagen logic commercial host compiled handshake hagen cycle cycle counting tagged messages logic custom host compiled single simul 
logic custom isa single simul 
lee logic custom host compiled single simul 
logic commercial isa hw simul 
single simul 
table comparison partitioning methods 
model granularity cost function algorithm henkel cdfg operation profiling sw hand outer synthesis sim 
anneal 
similarity hw inner communication cost hdl task profiling sw kernighan synthesis hw lin kumar set task profiling math 
prog 
hu task list task profiling branch sched 
analysis bound acyclic dfg operation profiling sw mixed processor cost hw integer linear communication cost prog 
barros unity hdl operation similarity clustering 
barros occam operation similarity clustering hierarchy 
hierarchy acyclic dfg operation schedulability heuristic look ahead adams hdl 
task profiling sw hand synthesis hw eles vhdl task profiling sim 
anneal 
luk ruby hdl operation rate matching hand hierarchy cdfg hdl operation profiling hand ben ismail communicating task hand processes fsms task hand chou timing diagram operation time sw min cut area hw gupta cdfg hdl operation time heuristic table comparison software scheduling methods 
model interface constraint scheduling granularity algorithm cochran task list task rma runtime chou task list synthesized task heuristic static operation gupta cdfg operation heuristic look ahead static runtime task list synthesized task rma runtime cdfg operation exhaustive hardware asic dsp assembly code software control panel microcontroller programmable dsp system bus real time operating system dual ported memory programmable dsp codec controller process user interface process dsp assembly code specification refinement model imperative fsms dataflow compiler processor model software synthesis processor model partitioning behavioral synthesis logic model discrete event logic synthesis logic model decreasing abstraction stephen edwards received degree electrical engineering california institute technology degree electrical engineering university california berkeley 
currently ph candidate electrical engineering university california berkeley 
worked intern microsoft semiconductor interval research 
research interests include scheduling techniques synchronous languages hardware software compilation techniques heterogeneous embedded system design synthesis 
luciano lavagno received doctor engineering ingegneria degree electrical engineering cum laude politecnico di torino italy 
cselt laboratories torino italy involved esprit project developed complete high level synthesis system 
joined department electrical engineering computer science university california berkeley worked logic synthesis testing synchronous asynchronous circuits 
received ph electrical engineering computer science university california berkeley 
dr lavagno author book asynchronous circuit design published journal conference papers 
received best award design automation conference san francisco ca 
served technical committees international conferences field design automation conference international conference computer aided design european design automation conference 
consultant various eda companies synopsys cadence 
currently assistant professor politecnico di torino italy research scientist cadence berkeley laboratories 
research interests include synthesis asynchronous low power circuits concurrent design mixed hardware software systems formal verification digital systems 
edward lee professor electrical engineering computer science department berkeley 
research interests include real time software discrete event systems parallel computation architecture software techniques signal processing design methodology heterogeneous systems 
director ptolemy project uc berkeley 
author books numerous papers patents 
degree yale university masters mit ph berkeley 
member technical staff bell telephone laboratories holmdel new jersey advanced data communications laboratory 
founder berkeley design technology consulted number companies 
fellow ieee nsf presidential young investigator 
alberto sangiovanni vincentelli professor electrical engineering computer sciences university california berkeley faculty 
obtained ingegneria electrical engineering computer science degree summa cum laude politecnico di milano milano italy 
assistant professor politecnico di milano 
spent year scientist mathematical sciences department ibm watson research center 
spent months mit visiting professor 
held number visiting professor positions university torino university bologna university pavia university pisa university rome 
holds title scientific director cadence sgs thomson european economic interest group general manager cadence european laboratories rome 
helped founding cadence synopsys leading companies area electronic design automation 
director pie design system chair technical advisory board synopsys 
board directors cadence founder member board cadence berkeley laboratories consulted number companies including ibm intel att gte ge harris nynex dec hp japanese companies including kawasaki steel fujitsu european companies including sgs thomson eni fiat bull 
advisory board lester center haas school business center western european studies member brie berkeley roundtable international economy university california 
received distinguished teaching award university california 
received graduate teaching award ieee teaching graduate students 
received best awards best presentation award design automation conference recipient award darlington award best award circuits systems society ieee 
holds vip italian national research council 
research interests related application mathematical ideas approaches design electronic systems 
focusing design methodologies tools mixed signal integrated circuits including high frequency low power circuits controllers 
latest area interested methods software synthesis formal verification 
published papers books area design methodologies tools 
dr sangiovanni vincentelli technical program chairperson international conference cad general chair 
program committee conferences editorial board ieee transactions cas ieee transactions cad archival journals 
