tax tree algebra xml jagadish university michigan jag eecs umich edu laks lakshmanan concordia university ubc laks cs concordia ca divesh srivastava labs research divesh research att com keith thompson university michigan eecs umich edu querying xml subject investigation 
formal bulk algebra essential applying database style optimization xml queries 
develop algebra called tax tree algebra xml manipulating xml data modeled forests labeled ordered trees 
motivated aesthetic considerations intuitiveness ecient computability amenability optimization develop tax natural extension relational algebra small set operators 
tax complete relational algebra extended aggregation express queries expressible popular xml query languages 
forms basis timber xml database system currently development 
xml emerged lingua franca data exchange possibly heterogeneous data representation 
considerable interest querying data represented xml 
query languages xquery quilt xml ql xql proposed purpose 
leads question implementation 
expect large data sets managed xml able evaluate eciently queries written xml query languages data sets 
experience successful relational technology tells formal bulk algebra absolutely essential applying standard database style query optimization xml queries 
xml document viewed labeled ordered rooted tree 
dom application interface standard certainly treats xml documents way 
addition cross tree hyperlinks 
model distinguish types edges 
similar approach adopted 
model mind develop simple algebra called tree algebra xml tax manipulating xml data modeled forests labeled ordered trees 
primary challenges address permit rich variety tree manipulations possible simple declarative algebra ii handle considerable heterogeneity possible collection trees similar objects books 
look popular xml query languages including xquery standard follow approach binding variables tree nodes manipulating variables free looping constructs needed 
direct implementation query written languages result nested loops execution plan 
ecient implementations frequently possible goal devise bulk manipulation algebra enables sort access method selection automated fashion 
section discussing issues designing bulk manipulation algebra xml 
leads data model section 
key abstraction tax specifying nodes attributes pattern tree section 
describe tax operators section 
section show tax complete relational algebra extended aggregation establish translation theorems identifying substantial classes queries expressible popular xml query languages translated tax 
tax designed ecient implementation centrally kept mind 
section discuss key issues regarding query evaluation optimization tax mention key implementation choices timber native xml database system development 
discuss related section conclude section 
design considerations central feature relational data model declarative expression queries terms algebraic expressions collections tuples 
alternative access methods devised bulk operations 
facility heart ecient implementation relational databases 
perform bulk manipulations collections trees relational algebra provides starting point relational operations selection set operations product fairly obvious operations want perform xml databases 
key issue individual members collections case xml 
words correct counterpart xml relational tuple 
tree nodes natural possibility think dom node tagged xml element attributes xml equivalent tuple 
element named attributes unique value structure looks similar relational tuple 
approach diculties 
instance de ned attributes need nodes tree nodes tag name 
tuples drawn domain cartesian product attribute domains 
placed single relation manipulated meaningfully 
importantly xml manipulation uses structural constructs element inclusion determination ancestor descendant relationship pair nodes dom frequently required core operation 
node separate tuple determining ancestor descendant relationships requires computing transitive closure parent child links stated join operation tuples 
computationally prohibitive 
clever encodings ameliorate diculty left low level query expression encodings re ected language data model 
encodings viewed implementation techniques ecient determination ancestor descendant relationships independent data model algebra choose 
alternative data model treat entire xml tree representing document document fragment fundamental unit similar tuple 
solves problem maintaining structural relationships including ancestor descendant relationships 
trees far complex tuples richer structure problem heterogeneity exacerbated 
routes managing structural richness 
tuples subtrees route inspired semantics xml ql transform collection trees collection tuples rst step query processing sensible way tuples bindings variables speci ed conditions 
manipulation applied purely relational terms resulting collection tuples 
trees answer generated nal step 
repeated relational construction deconstruction steps may required semantically meaningful operations adding considerable overhead 
furthermore approach lead limited opportunities optimization 
pure trees remaining route manage collections trees directly 
route problems mentioned exacerbates issue heterogeneity 
presents major challenge de ning algebraic operators view relative complexity trees compared tuples 
central contribution decisive response challenge 
introduce notion pattern tree identi es subset nodes interest tree collection trees 
pattern tree xed operation provides needed standardization heterogeneous set 
algebraic operators manipulate nodes attributes identi ed means pattern tree 
apply heterogeneous collection trees 
innovation show operators relational algebra carry tree domain appropriate modi cations 
need introduce couple additional operators deal manipulation tree structure 
important property xml xml document corresponds ordered tree 
query collection ordered documents turns order critical contexts immaterial 
choice design time tax permits graceful single query places order important places 
data model basic unit information relational model tuple 
counterpart data model ordered labeled tree 
data tree rooted ordered tree node carries data label form set attribute value pairs 
xml data node corresponds element information content represents attributes element children represent subelements 
xml requires attributes associated element single valued 
require assumption model general 
xml assume node special single valued attribute called tag value indicates type element 
node may content attribute representing atomic value type atomic types interest int real string notion node content generalizes notion pcdata xml documents 
pure pcdata nodes just pcdata descriptive exists 
notions id idrefs xml treated just attributes model 
see sample data tree 
node contents indicated parentheses 
assume node virtual attribute called pedigree drawn ordered domain 
operators algebra access node pedigrees attributes purposes manipulation comparison 
intuitively pedigree node carries history came trees manipulated operators 
algebra operators update attribute values pedigree existing node updated 
node copied attributes copied including pedigree 
new node created null pedigree 
pedigree plays central role grouping sorting duplicate elimination 
shall show appropriate attribute valuable duplicate elimination grouping inducing maintaining tree order query answers 
useful regard pedigree document id set document 
implemented pedigree timber implementation tax 
pedigree respects akin lightweight element identi er true identi er 
instance node copied original copy pedigree possible true identi er 
relation relational database collection tuples structure 
equivalent notion tax collection trees similar necessarily identical structure 
subelements frequently optional quite frequently repeated trees schema tax considerable di erence structure 
relational database set relations 
correspondingly xml database set collections 
cases database set collections 
rarely confusing relational context frequently tendency xml context treat database single set attening nested structure 
ght tendency consistently term collection refer set tree objects corresponding relation relational database 
database set collections 
relational implementations useful support relations multi sets bags sets 
similar vein expect tax implementations implement collections multi sets perform explicit duplicate elimination required 
relational algebra operator takes relations input produces relation output 
correspondingly tax operator takes collections data trees input produces collection output 
pedigrees shown example data trees minimize clutter 
predicates patterns allowable predicates predicates central querying 
choice speci set allowable predicates orthogonal tax implementation choice matter 
concreteness mention representative list allowable predicates clear understanding list extensible 
node element attribute attr value val domain atom attr val allowed special case attr type string wildcard comparison attr val val string allowed 
similarly nodes attributes attr attr atom attr attr allowed 
speci cally attribute pedigree predicates form pedigree pedigree pedigree constant allowed 
addition atoms involving aggregate operators arithmetic attr attr string operations attr attr 
terrorism allowed 
predicates position node tree 
instance index means node rst child parent 
generally index means node th node descendants node similarly means node occurs node predicates preorder enumeration relevant data tree 
pattern tree basic syntactic requirement algebra ability specify attributes interest 
relational algebra accomplished straightforwardly 
doing collection trees non trivial reasons 
merely specifying attributes ambiguous attributes nodes 
second specifying nodes means id impossible design kept model simple explicit notion object id third identifying nodes means position tree cumbersome easily tricky 
collections trees deal homogeneous draw tree identical collection manipulated label nodes labels unambiguously specify nodes elements 
sense labels play role similar column numbers relational algebra 
collections xml data trees typically heterogeneous 
frequently know care complete structure tree collection wish portion tree care 
need simple powerful means identifying nodes collection trees 
solve problem notion pattern tree provides simple intuitive speci cation nodes attributes interest 
particularly suited graphical representation 
de nition pattern tree formally pattern tree pattern short pair node labeled edge labeled tree node distinct integer label edge labeled pc parent child ad ancestor descendant 
formula boolean combination predicates applicable nodes 
formal semantics patterns subsection give examples 
shows pattern asks books published having author 
edge label pc indicates year direct subelement book edge label ad indicates author nested descendant subelement 
example pattern asks books published publisher allow variants val attr says val appears value attribute says attribute attr de ned node labels denoted integer pc pc pc pc ad title dummy book book book bib author jack tag year content tag author tag book title dummy computer author jack content jill content jack tag author tag author content science tag publisher tag book tree xml database pattern trees name contains string science authored jack jill order 
examples see tree formula interact 
chosen allow ancestor descendant ad edges addition basic parent child pc edges pattern tree believe may wish specify just relationship involving intervening nodes feature commonly xml query languages 
note additional constructs possible 
instance introduce edges labeled constraints obtain full functionality regular expressions 
extension de nition pattern tree orthogonal de nition tax operators 
pattern trees tax permit attributes nodes compared attributes nodes analogously selection predicates relational algebra permitting di erent attributes compared 
see instance position nodes compared predicate 
witness tree pattern tree constrains node ways 
formula may impose value predicates node 
second pattern requires node structural relatives parent descendants satisfying value predicates speci ed value predicates turn allowable set atomic predicates applicable pattern tree nodes 
formally collection data trees pattern tree 
embedding pattern collection total mapping nodes preserves structure pc resp ad edge child resp descendant image mapping satis es formula embedding node node 
say data tree node matches pattern node embedding 
note embedding need data tree node match pattern node 
note ignored order siblings pattern tree seek embed data tree 
siblings pattern tree may general permuted obtain needed embedding 
chosen permit queries frequent queries order nodes pattern tree material 
maintaining order siblings desired easily accomplished book book book book book book book author jack results various operations applied database ordering predicates applied selectively 
example speci es pattern seeks books authors jack jill jack appearing jill having publisher science care publisher subelement book appears author subelements 
formalize semantics pattern trees notion witness trees 
embedding pattern tree database induces witness tree embedding de nition witness tree collection data trees pattern tree embedding 
witness tree associated data tree denoted de ned follows node witness tree node pattern matches pattern node mapping pair nodes witness tree closest ancestor witness tree witness tree contains edge 
witness tree preserves order nodes retains nodes precedes preorder node enumeration precedes preorder node enumeration 
data tree nodes pattern tree map call source tree witness tree 
refer witness tree meaning witness tree straightforward 
nodes instance satisfy pattern retained original tree structure restricted retained nodes yield witness tree 
pattern tree embedded input tree instance multiple ways multiple witness trees obtained embedding 
example shows witness trees resulting embedding pattern database di erent ways 
book appears di erent witness trees possible author node binding 
tree value function collection trees perform ordering grouping operations lines groupby sql 
fact ordering required ordered trees constructed unordered collections 
take account possible heterogeneity structure collection trees making hard specify nodes nd attributes interest 
solve problem general way proposing notion tree value function maps data tree typically source trees witness trees ordered domain real numbers 
exact nature orthogonal algebra assume eciently computable 
simple example tree value function map tree value attribute node function tuple attribute values associated nodes tree identi ed means pattern tree example section 
pattern trees operators algebra tree value functions useful performing grouping ordering 
operators operators tax take collections data trees input produce collection data trees output 
tax proper algebra composability closure 
notions pattern tree tree value function introduced preceding section play pivotal role operators 
selection obvious analog tax relational selection selection applied collection trees return input trees satisfy speci ed selection predicate speci ed pattern 
may preserve information interest 
individual trees large may interested just knowing tree satis ed selection predicate manner satisfaction addition 
words may wish return relevant witness tree just single bit data tree input selection operator 
appreciate point consider selecting books published collection books 
generate subset input collection relational algebra 
input collection comprises single bibliography data tree book subtrees selection output return original data tree leaving clue book published 
selection tax takes collection input pattern adornment sl parameters returns output collection 
data tree output witness tree induced embedding modi ed possibly prescribed sl 
adornment list sl lists nodes just nodes descendants returned output 
adornment list empty just witness trees returned 
formally output sl selection operator collection trees embedding output tree associated embedding de ned follows 
node input collection belongs output matches pattern node descendant node matches pattern node label appears adornment list sl 
nodes belong output nodes retained output closest ancestor input output contains edge 
relative order nodes input preserved output nodes output precedes preorder enumeration precedes preorder enumeration output 
contents nodes including pedigrees preserved input 
example collection book elements pattern tree fig 
sl produces exactly collection trees fig adornment list sl empty 
hand sl includes entire subtree retained book node result 
speci ed pattern match times single tree selection tax operation 
notion selection strictly general relational selection 
see section 
desire return entire trees input collection match selection predicate add new root node labeled pattern tree ad edge previous root take conjunction previous formula place adornment list sl 
projection trees projection may regarded eliminating nodes speci ed 
substructure resulting node elimination expect partial hierarchical relationships surviving nodes existed input collection preserved 
projection tax takes collection input pattern tree projection list pl parameters 
projection list list node labels appearing pattern possibly adorned 
output pl projection operator de ned follows 
node input collection belongs output embedding matches pattern node label appears projection list pl descendant node matches pattern node label appears projection list pl 
nodes belong output nodes retained output closest ancestor input output contains edge 
relative order nodes preserved output nodes output tree precedes preorder enumeration precedes preorder enumeration output tree 
contents nodes including pedigrees preserved input 
example suppose pattern tree projection list apply projection database 
obtain result shown 
single input tree contribute zero output trees projection 
number zero witness speci ed pattern input tree 
nodes retained witnesses speci ed pattern ancestor descendant relationships 
notion projection strictly general relational projection 
wish ensure projection results output tree input tree include pattern tree root node projection list add constraint predicate pattern tree root matched data tree roots 
relational algebra dealing rectangular tables selection projection orthogonal operations chooses rows chooses columns 
trees rectangular structure data 
selection projection obviously orthogonal 
di erent independent operations generalizations respective relational counterparts 
instance pattern tree projection list parameters projection database results 
compare selection result shown pattern tree database 
product product operation takes pair collections input produces output collection corresponding juxtaposition pair trees precisely produces output collection follows 
pair trees contains tree root new node tag name tax product root null pedigree attributes content left child root right child root technically unnecessary assume primitive predicate 
expressed subtracting nodes parents set nodes 
expressing directly improves readability eciency 
pc pc pc ad ad review review review tax prod root title dummy review review tax prod root content content tag book title tag title tag review tag book tag author input collection pattern tree join result additional left result node left right subtrees new root node attribute values including pedigree input collections 
choice null pedigree newly created root nodes re ects fact nodes origins input collections 
data trees ordered 
departure relational world justi ed order irrelevant tuples important data trees correspond xml documents 
relational algebra join expressed product followed selection 
example reviews collection joined books collection product applying selection pattern shown yields result shown 
derive operators 
instance left collections conditions results collection includes tree addition 
de ne formally 
de nition join collections trees patterns 
selection projection interpreted selection list sl projection list pl depending join operation attr attr refers node label semantics pair witness trees obtained operations say match node say match node say attr attr holds output collection contains tree root tag left child root right child root left expressions de ned follows attr attr refers node label semantics witness tree obtained operation output contains trees determined follows witness tree obtained operation matches node node satisfy condition attr attr output contains just tree corresponding root tag child root hold witness tree obtained matches node node satisfy condition attr attr output contains tree root tag left root right child root lemma shows join left derived operators 
lemma derived operators join left simulated tax 
proof consider join 
construct new tree pattern follows 
root isomorphic copy left child isomorphic copy right child 
assign distinct node labels 
associated formula condition attr attr node labels involved join condition 
call resulting pattern join equivalent expression sl fg 
left simulated projecting attr attr nodes corresponding copy join 
set operations relational model fall back set theory set union intersection di erence 
issue specify elements data trees considered identical 
trees ordered obtaining correspondence nodes straightforward 
require attributes corresponding nodes including tag pedigree content identical 
formally data trees equal exists isomorphism sets nodes preserves edges order furthermore value atom form attribute value atom true node true node notion deep equality union intersection di erence de ned standard way 
multi set versions operations possible 
particular union de ne result multiplicity sum max 
grouping relational model separate grouping aggregation 
rationale grouping natural direct role play restructuring data trees orthogonally aggregation 
worth noting approach taken proposals olap algebra 
objective split collection subsets necessarily disjoint data trees represent subset ordered tree meaningful way 
motivating example consider collection book elements grouped title 
may wish group collection author generating subsets book elements authored author 
multiple authorship naturally leads overlapping subsets 
represent subset desired manner alphabetical order titles year publication forth 
value aggregation involved task involves splitting collection subsets ordering trees subset speci ed way 
relational grouping easy specify grouping attributes 
case need tree value function purpose 
formalize follows 
groupby operator takes collection input parameters 
pattern tree pattern grouping 
corresponding witness tree keep track source tree obtained 
grouping function partitions set witness trees collection typically grouping function instantiated means grouping list lists elements label attributes elements values obtain required partition 
default comparison element values shallow ignoring sub element structure 
element labels grouping list may possibly followed case just element entire sub tree rooted element matched 
ordering tree value function maps data trees ordered domain 
function order members group output manner described 
book book book tax group root tax group tax grouping list tax group root tax group tax grouping list grouping witness trees fig author content pattern tree shown ordering group year content output tree corresponding group formed follows root tag tax group root null pedigree children left child tag tax grouping basis null pedigree sub tree rooted node captures grouping basis right child tag tax group null pedigree children roots source trees corresponding witness trees arranged increasing order value source tree associated witness tree source trees having witness tree appear output group corresponding witness tree 
grouping operation performed result include just bunch groups labels associated group identifying basis creation group 
relational systems set grouping attributes group retained separately remaining attributes tuples group condensed aggregation 
generic grouping basis function specify manner information retained tax grouping basis node result 
typical case grouping list partition grouping list applied projection list parameter obtain projection source trees associated groups 
projections de nition identical group pedigree 
convention associate pedigree values node eliminate rest 
result child tax grouping basis node 
projection returns forest order preserved trees forest 
consider database 
apply grouping pattern tree grouped author ordered year 
result shown 
grouping applied xml database consisting tree book example database books published appear groups authors 
words regarding way collections source trees partitioned order 
node label form grouping list shallow notion equality matches node equal provided contents set attribute value pairs pedigree identical 
node label form grouping list deep notion equality 
matches node equal provided isomorphism subtrees rooted matching nodes preserves order node contents pedigree 
deep equality basis de ning set operations see section pedigree attributes considered 
short equality deep shallow value pedigree node identity pedigree 
appropriate notion circumstance 
duplicate elimination value due presence pedigree attribute distinct nodes input identical value considered duplicates purposes set operations 
need eliminate duplicates value speci ed attributes 
example distinct operator xquery require 
show lemma duplicate elimination duplicate elimination nodes value expressed tax 
proof basic idea group collection data trees root element delete right subtree root node tree resulting collection 
precisely perform grouping pattern projection pattern tag tax group root tag tax grouping basis projection list pl 
easy see resulting collection contain exactly tree set identical deep equality trees input collection 
sorting useful operator sql results sorted order 
sets unordered de nition operator applied output relational algebra 
tax collections unordered 
trees ordered 
frequently result query composed xml tree imposing order 
grouping operator tax ordering collection converting tree 
accomplish empty grouping basis trees input collection map single output group 
result single tree output input tree child tax group 
ordering function speci es relative order 
desired nal result obtained projecting away tax group root tax grouping basis 
query speci es explicit sort order values selected elements attributes stated ordering function identifying appropriate elements attributes pattern tree usual manner 
query requires output ordered basis value basis position input document node pedigrees purpose 
ordering function term representation tree pedigrees node sort lexicographically 
aggregation purpose aggregation map collections values aggregate summary values 
common aggregate functions min max count sum exact choice orthogonal algebra 
generating summary values specify exactly newly computed value inserted tag value attribute 
precisely aggregation operator takes collection input pattern aggregate function update speci cation parameters 
update speci cation denotes aggregate value computed inserted output trees 
exact set possible ways specifying insertion orthogonal issue anyway remain extensible notion 
give examples speci cation 
want computed aggregate value child speci ed node immediately preceding speci ed node precedes 
assume name attribute carry computed aggregate value indicated attr new name label node semantics aggregation operator attr follows 
output contains tree corresponding input tree 
identical input tree new right sibling created node output data tree right child node matches pattern node labeled node attribute value pairs tag tax computed aggregate value 
node input node null pedigree 
interested just extremum aggregate value attribute object possesses attribute 
relational algebra corresponding tuple returned join computed aggregate value original relation 
strategy tax 
better grouping operator preceding aggregation performed necessary join 
appropriate selection aggregation trick 
renaming renaming produces collection isomorphic input collection changing name speci ed attributes value tag attribute speci ed nodes input tree 
analogous relational renaming attributes tuples relation renamed 
need notion de nition renaming 
pattern 
renaming speci cation rs sequence expressions form newname node labels appearing newname identi ers 
renaming takes collection input pattern tree renaming speci cation rs parameters generates output collection rs output follows 
node matches pattern node labeled embedding marked tree collection rs contains isomorphic tree attribute including pedigree node identical corresponding node node output corresponds input node marked pattern node labeled rs contains expression newname tag changed newname 
contains attribute changed newname 
renaming essentially analogous relational algebra 
note static semantics renaming rst node potentially ected renaming embedding marked newname values assigned rhs relevant expressions appropriate changes marked node 
needed ensure renaming cascade ect rs containing name name name name node matches di erent embeddings sense tag names attributes changed output unambiguous 
reserved attribute names tag pedigree may renamed 
due multiple embeddings pattern tree possible input node get marked 
renaming operations due multiple markings clash rs contains name name name name renaming speci cation ambiguous tax implementation may choose resolve ambiguity sees option treat renaming noop case 
reordering wish change order children node want regroup subelements 
instance bibliography may want book elements grouped publisher secondarily title 
reordering operator takes collection operand pattern tree value function reorder list rl parameters 
reorder list list node labels appearing semantics reordering follows 
suppose simplicity unique node matches pattern node label appears rl 
child subtrees reordered increasing order 
maps di erent child subtrees number tax implementation free choose convenient way ordering children 
suppose input node matches pattern node label appears rl 
set nodes 
sort descendant precedes ancestor 
apply reordering nodes order appear sorting 
pedigrees una ected reordering 
example suppose collection books grouped author tree contains books written author 
choose order book subtrees year publication price number book pages 
readily handled invoking reorder operator reorder list identi es book nodes pattern tree value function maps book tree year price number pages appropriate 
lemma proved routine induction 
lemma idempotence reordering pattern tree value function applied subtree rooted node function attribute value pairs node rl reorder list 
collection rl rl rl reordering idempotent operator 
tree pattern reorder list 
maps non trivial tree preorder enumeration values nodes 
sends subtree rooted 
tree value function true counterexample showing top semantics reordering non idempotent tree value function speci ed 
proof base case subtree height lemma hold trivially 
inductive case consider subtree height suppose lemma holds child root subtree height 
de nition reorder operator child subtrees reordered rst root nally reordered 
inductive assumption re application reorder operator child subtrees ect 
consequence re application root ect 
semantics corresponds applying reordering bottom manner descendants ected ancestors 
trivial matter example top evaluation reordering idempotent consider pattern tree value function shown 
consider collection consisting tree isomorphic pattern 
applying reordering operator parameters top produce tree images children root node swapped 
subsequent application reordering nodes cause children turn swapped 
reordering operator swap children root node showing idempotent 
copy paste addition reordering siblings wish perform general restructuring altering relationship data tree 
instance may want take bibliography arranged books subelements publishers transform bibliography publishers listed subelements books 
introduce simple operator called copy paste takes collection input parameters pattern ii copy list cl node labels appearing iii update speci cation 
update speci cation says copy pasted example speci cations include indicating copy pasted child node matching node labeled pattern node semantics copy paste operation cl follows 
tree input collection 
match resulting witness tree create set binding pairs left member pair node copy list right member pair node update speci cation 

partition set subsets right member pair eliminate duplicates 
ect step partitions set binding pairs subsets representing material pasted spot 

partition set obtained previous step order pairs pedigree left member pair 
tax cnp group pc ad ad pc tax cnp group bib tag tag author tag tag book book content content book book bib book author jill book book example copy paste 
create new node speci ed paste location 
tag new node tax cnp group pedigree null 
instance paste location new node placed current child node labeled 
copy match copy child node tag tax cnp group created 
case copy list cl contains place just match entire subtree rooted node included copy 
pedigrees nodes remain unchanged copy 
illustration consider invocation copy paste pattern tree copy list update speci cation 
applying database results structure 
author multiple books case author jill book descendants descendant author node occurrence author 
value updates individual attributes node updated 
pattern tree identify nodes attributes need updated 
new value attribute constant value attribute database computed values arithmetic 
formally update speci cation sequence expressions form attrname newval node labels appearing attrname attribute name newval expression 
expression purpose constant forms attr node label attr attr arithmetic expression involving atomic expressions mentioned 
update takes collection input pattern tree update speci cation parameters generates output collection output follows 
node matches pattern node labeled embedding marked tree collection contains isomorphic tree attribute node identical corresponding node node output corresponds input node marked pattern node labeled contains expression attrname newval newval string constant evaluate newval evaluate unique constant update operation unde ned 
node output corresponds input node marked pattern node labeled contains expression attrname newval contains attribute attrname value changed unique evaluated value newval 
due multiple embeddings pattern tree possible input node get marked 
update operations due multiple markings clash update speci cation ambiguous implementation extended tax may choose resolve ambiguity sees note static semantics update rst node potentially ected update marked newval values assigned rhs relevant expressions appropriate changes marked node 
needed ensure updating cascade ect sense attribute values changed output unambiguous 
node deletion deletion nodes requires new operator basic idea remains 
pattern tree identify nodes delete speci cation indicates node label nodes delete 
formally delete operator takes collection input pattern tree delete speci cation ds parameters 
delete speci cation ds sequence expressions form node labels appearing generates output collection ds output follows 
node matches pattern node labeled embedding marked tree collection ds contains isomorphic tree attribute node identical corresponding node node output corresponds input node marked pattern node labeled ds contains expression node deleted descendants 
ds contains expression node deleted children direct child parent 
children retain relative order inserted position node siblings node 
short delete node operation identical value update operation extra care necessary deleting non leaf nodes 
additionally permit delete speci cations include expressions form attrname interpret mean deletion indicated attribute deletion entire node 
node deletion similar projection 
fact viewed projection complemented projection list specifying nodes eliminated nodes retained 
element form list speci ed means pattern tree simple way general introducing negation de nition pattern tree witnesses transform positive projection retention list complemented projection deletion list vice versa 
node insertion inserting nodes just attributes little information provide 
insert speci cation specify position identi ed pattern tree nodes insertion performed 
insertion data 
insertion leaf node 
nodes children copy paste purpose 
formally insert operator takes collection input pattern tree insert speci cation parameters 
insert speci cation sequence expressions form attrname val pos attrname val attrname val 
node labels appearing attrname names attributes val expressions relative position expression nextsibling 
generates output collection output follows 
node matches pattern node labeled embedding marked tree collection contains isomorphic tree attribute node identical corresponding node node output corresponds input node marked pattern node labeled contains expression involving evaluate val expression reduce constant 
node output corresponds input node marked pattern node labeled contains expression attrname val node new attribute added speci ed name value 
attribute exists name attempt insert new attribute causes xml error 
contains expression new node inserted speci ed attributes values position relative speci ed 
general updates ones possible 
particular possible include old values attributes content de ning new values 
clear notion old new confusion arises 
old values directly structural information 
updates involving structure performed cnp course new aggregate value nodes created relevant extracts structural information values desired updates 
instance possible add attribute book bibliography value equal total number books bibliography 
expressive power tax section establish results expressive power tax 
show complete relational algebra extended aggregation 
central motivation designing tax basis ecient implementation high level xml query languages 
section examine expressive power tax popular xml query languages 
translating relational queries lemma independence operators tax independent operator expressed remaining ones 
proof follow approach essentially similar proof independence relational algebraic operators 
theorem completeness ra aggregation encoding scheme rep maps relational databases data tree representations relational database expression relational algebra extended aggregation corresponding expression tax rep rep 
proof represent tuples level data trees root node tuple child attribute tuple see 
show relational algebra operator simulated tax 
tag attribute name value tag attribute name value tag attribute name value tag attribute name value name tag tuple name tag tuple pc pattern selection data trees corresponding relation tag tuple name tag attribute name value sl selection list simulating relational selection 
selection relation expressed pattern shows complete structure relation tuple data tree representation including selection condition part formula equivalently include tuple root referenced attributes pattern tree 
case selection list tuple root descendants children attributes 
binary relation expressed pattern selection list 
similarly projection simulated means pattern tree identi es tuple root relevant attribute children projection list comprises tuple root set attributes retained projection 
predicate value dropped formula union di erence renaming straightforward 
product tax introduces new root node level trees output 
project second level nodes trees corresponding roots trees input product get desired relational product result 
shown relational algebra operators simulated tax 
turning aggregation generic statement consider form agg agg vm 
tax tax expression equivalent required tax expression obtained applying groupby tax expression tax equivalent grouping basis list speci ed depicting pattern showing full structure trees collection returned tax relevant components thereof including node labels corresponding tags grouping list 
ordering function de ned arbitrarily pedigrees 
apply aggregation operator resulting collection 
pattern tree associated aggregation operator obtained depicting structure collection resulting grouping 
aggregate functions agg included parameters aggregation operator 
added child root 
translating xml queries subsection discuss translation xquery tax 
simple single block flwr expressions gradually add features nesting quanti ers include xquery 
purpose introduce de nitions de nition canonical xquery statement canonical xquery statement form var range var letvar letvar strictly speaking apply aggregation aggregate function turn 
abbreviated cascade single application aggregation operator aggregate functions parameters 
conditions return var agg letvar 
return agg 
variables bound clause bound aggregate expressions clause quanti er free predicate regular path expressions involve constants wildcards may functional calls tag variables recursion expressions mentioned 
de nition single block canonical xquery statement single block canonical xquery statement canonical xquery statement flwr expression nesting 
theorem single block canonical xquery translation single block canonical xquery statement 
expression tax equivalent proof query translated tax follows 
step identify tree patterns variables declared single clause related denoted occurs range related third variable clearly equivalence relation split variables declared clause equivalence classes equivalence class associated clause construct pattern tree declarations follows 
create node corresponding variable edge occurs range declaration 
node degree greater split multiple nodes degree replicating sub tree node 
variable name corresponds multiple nodes create predicates equating nodes 
expand edge appropriate sequence ad pc edges pattern tree creating intermediate nodes required partial path expression corresponding edge 
instantiate node predicates corresponding appropriate nodes path expression 
step push conditions patterns analyze clauses push conditions involving variables single pattern tree relevant pattern tree predicate 
step duplicate elimination distinct keyword perform corresponding duplicate elimination described section 
step evaluate aggregates aggregation operator appropriate grouping evaluate aggregate expressions clauses 
step form joins compute join multiple pattern trees obtained previous steps 
join associate join conditions predicates clause variables exactly trees joined 
step remaining conditions clauses enforce remaining conditions clauses step evaluate return aggregates aggregation operator appropriate grouping evaluate aggregate expressions return clauses 
step ordering perform groupby elements returned de ning grouping basis ordering tree value function de ned order clauses default pedigree ordering 
step projection return statement arguments form projection list copy paste necessary 
resulting tax expression equivalent query result applied single block xquery statement 
nested blocks return clauses handled quite easily 
leading result theorem canonical xquery translation canonical xquery statement 
expression tax equivalent proof translation procedure step arrange various identi ed pattern trees nesting sequence inside form cascade left outer joins patterns form join associate join conditions predicates clause variables exactly trees joined 
step just single grouping order outputs cascade grouping operators applied nesting sequence inside 
consider xquery facilities included canonical xquery statement 
xquery permits variable declared multiple ranges explicitly intersect 
example explicit declaration book author university faculty implicit declaration book author intersect university faculty 
note book author university faculty example declaring variable multiple ranges 
lemma eliminating multiple range declarations xquery statement equivalent xquery statement variable declared multiple ranges 
proof xquery statement variable declared ranges range 
declarations range intersect 
intersect 
replace declaration declarations range xk 
add condition 
xk clause associated clause 
replace occurrence associated return statement xi 
easy see transformation preserves equivalence queries 
repeated application transformation yields desired equivalent query 
lemma quanti ers xquery statement involving quanti ers clauses rewritten equivalent quanti er free statement xquery extended set di erence facility 
proof sketch occurrence quanti ers easily rewritten 
dropping quanti er expression clause 
declaring quanti ed variable immediately surrounding clause range originally quanti ed 
adding condition satisfies clause quanti er originally occurred 
transformation clearly preserves equivalence 
repeating transformation occurrence quanti er generate equivalent xquery statement quanti er 
consider occurrence quanti er 
quanti ed expression satisfies cond occurring query create query identical quanti ed expression deleted 
create query identical quanti ed expression replaced expression satisfies cond 
clearly result obtained result minus result 
quanti er 
quanti er shown ease exposition immediately removed technique shown 
nite number quanti ers query process applied repeatedly quanti ers remain query 
summary shown canonical xquery statement expressed tax 
showed various xquery statements reduced canonical form 
exhaustive consideration xquery constructs establish claim theorem translating xquery xquery query involving recursion function calls tag variables satis es variables bound clauses bound aggregate expression regular path expressions involve constants wildcards may 
expression tax equivalent note precise de nition xquery moving target claim ected addition powerful new constructs xquery 
event xquery construct missed exhaustive consideration added committee construct expressible canonical form recorded additional exception theorem statement 
similar translation theorems shown quilt xml ql xql suppressed brevity 
experience interesting xml queries arising practice translated tax 
consciously chosen keep recursion outside algebra managed devise clean algebra small set simple intuitive operators 
furthermore queries involving recursion implementation tax provide explicit support iteration 
similar implementing deductive databases relational algebra plus iteration 
interestingly queries requiring skolem functions xml ql expressed tax doesn feature 
pc pc pc pc pc pc pc pc pc pc pc pc pc tag book tag publisher tag name tag name tag book tag publisher tag name tag title tag name tag book tag publisher tag title tag name content content tag books tag publisher tag publications tag title pattern trees translation xquery query ex tax xquery examples example consider simple xquery query 
document www biblio com books xml book author firstname mark lastname twain return query expressed tax straightforward selection 
example consider classic xquery query takes document arranged book publisher subelement book rearrange publisher ordering books publisher title lexicographically distinct document xml book publisher name return document xml book publisher name title return note output constructed single ordered tree collection 
easily accomplished tax grouping collection ordering trees collection term representation pedigrees tree 
common idiom repeat step examples 
straightforward translation yields de fg 
pattern trees de ned input collection intermediate result comprising collection bindings publisher name variable de shorthand duplicate elimination value obtained grouping operator followed projection see lemma 
form fg 
denotes left pattern parameter 
intermediate result evaluating inner loops constraining variable values left obtain content content books publications 
puts output correct structure order 
desired output produced simple projection 
example query illustrates filter features xquery 
input document cookbook cookbook xml containing sections nested arbitrary depth containing section title gures may contain titles 
query lters sections titles preserving original hierarchical structure 
document cookbook xml filter section section title return expressed simple projection tax node pattern tree says root tag section child tag title 
sole edge pattern pc edge 
example consider query involves selection aggregate values 
pub distinct publisher bk book publisher pub year count bk return pub query expressed tax shown show initial selection choosing books published aggregation counting books published publisher 
subsequently need select publishers count join result set distinct publishers 
steps routine 
example query illustrates expressed 
consider auction database consisting tables users userid name rating items itemno description bids userid itemno amount date 
xquery query assumes suitable xml representation tables computes left users items 
pc pc pc tag book tag tag publisher tag year content tag book tag tag publisher content count count 
selection aggregation expressing xquery query aggregation 
document users xml return name document items xml itemno return description text 
name example example query drawn directly concerns surgical data data embedded free text 
query nds sections entitled procedure occurs rst 
proc section section title procedure exists proc proc return proc query expressed tax follows 
project input pattern section root title procedure descendant 
select procedure rst child previous result 
third join set procedure elements obtained simple selection equating pedigree rst child descendant procedure element element preceding predicate pattern formula 
project result join procedure elements 
subtract set procedure elements 
tax query shown 
translating xml query languages tax speci cally designed xquery 
fact translation theorems lines theorem xml query languages discussed 
omit details lack space presenting just illustrative example xml ql 
example query pulls bibliography database journal papers books 
depending type retrieves publication month publisher 
pc pc pc ad ad tag section title procedure selection ad tag section title procedure tag projection pc tag section tag index selection product projection null tag section title procedure tag tag section pedigree pedigree pedigree pedigree tag tag title procedure pl tag section title procedure selection result previous step difference expressing order xquery query 
tag title tag year content tag journal tag month tag book tag publisher pc pc pc selection pattern sl expressing xml ql queries skolem functions disjunction 
content www bib xml construct id journal construct id book construct id expressed simple selection tax see xml ql uses heavyweight features skolem functions tag variables express query 
note disjunction formula pattern 
obvious renaming step follow selection omitted 
new expressions shown large parts xml ql xquery expressed terms tax 
furthermore expressions small size cases simpler originals 
tax queries expressed eciently xquery 
example suppose collections books reviews 
suppose want take join collections sense want match whichever elements common tags collections 
number common tagged pairs elements pair trees title year 
wish include join pairs mismatch 
cartesian product collections 
remove product items satisfy condition tag book tag review tag tag content content high level way expressing non trivial query 
expressing query xquery xml ql hard need specify inclusion exactly pairs de ned subelements match having subelements missing 
optimization evaluation implementation issues typical relational query implementation rst step selection index available full scan 
joins implemented data streams result 
similar strategy adopted timber implementation tax 
rst thing happens matching pattern tree database scan indexed access combination indexed accesses targeted processing index entries 
see study alternative access methods pattern tree matching 
witness trees embeddings pattern tree database operator manipulates witness trees required 
note pattern trees independently speci ed operator tax expression 
rst typically selection operator nds witnesses base data 
subsequent operators evaluate pattern tree embeddings suitable intermediate results 
word pedigree 
tax assumes availability pedigree come real system 
unique answer timber system uses position element document purpose 
fact additional attribute costless required part physical implementation serving role akin rid relational database 
similar notion niagara system bearing testament naturalness notion 
derived operators join important operators relational database implementations regarded derived operator 
terms expressing queries evaluating thinks joins directly 
similar arguments apply tax 
just primitive tax operators simple tasks require complex expressions 
appropriate derived operators help 
direct implementation derived operators substantially ecient evaluation sequence primitive operators 
seen value join left outer join operators 
derived operators de ned needed 
operator identities operator identities essential query rewriting optimization 
tax operators usual identities expect 
instance set union intersection associative commutative tax operators groupby subject appropriate constraints predicates may appear pattern trees distribute set operations 
brevity discuss issues particular interest 
product commutative data trees ordered 
furthermore associative shown 
cartesian product immediately followed reorder root node result commutative 
similarly cartesian product rendered associative projecting virtual product root node due rst product operation child root second product operation 
extra node retaining information regarding wish lose assure associativity 
node projected result single product root symmetric children assuring associativity product 
similar observations hold joins 
associativity commutativity join critical join reordering central query optimization 
light foregoing discussion join operations reordered tax query optimizer provided care exercised 
speci cally tax expressions additional reorder project operators inserted pc pc pc pc pc pc pc pc pc pc pc associative product obtained projection insertions shown ect nal answer operators combined joins render associative commutative shown 
cases nal answer ected examples include result join projected operands join self joins 
associative version join natural practice 
related shortage algebras data manipulation 
codd seminal orts extend relational algebra direction 
klug aggregation worth mentioning particular stream nested relational model 
grammar algebra manipulating tree structured data shown equivalent calculus 
tree manipulations performed manner production rules clear path ecient set oriented implementation 
predates xml quite bit obvious means mapping xml data model 
tree pattern matching studied problem notions regular expressions grammars extended strings trees cf 

ideas incorporated object oriented database algebra developed aqua project 
focus algebra identi cation pattern matches rewriting style grammar production rules 
notion tree pattern witness trees follows aqua spirit 
aqua counterpart tax operators 
context web mention graphlog hy proposed models semi structured data see lorel unql propose query languages ort accompanying algebra 
xml context algebras proposed 
uential early impacted xml schema speci cation 
real manipulation algebra described 
proposes algebra carefully tailor quilt 
algebra xduce system focused type system issues 
forms intellectual basis issued xquery algebra document working group xml query 
algebra useful investigating semantics xml query detecting errors proving query programs correct appears algebra form basis ective implementation 
authors algebra xml de ned extension relational algebra practical implemented 
main object manipulation algebra xml ql tuple tree 
bind operator create sets tuples bindings speci ed labeled nodes 
due consequent loss structure scheme quickly breaks complex analyses required 
similarly describes navigational algebra querying xml treating individual nodes unit manipulation trees 
deals aspects xml updates 
consider updates 
summary status tax tree algebra xml extends relational algebra considering collections ordered labeled trees relations basic unit manipulation 
spite potentially complex structure trees involved heterogeneity collection tax couple operators relational algebra 
furthermore operators uses basic structure parameters 
potential complication xml manipulation existence order tree 
collections unordered straightforward maintain document order output results example 
tax able handle requirements eciently 
fact comfortable ordered unordered artifacts key intellectual contributions tax 
believe de nition tax signi cant intellectual accomplishment primary purpose de ning basis query evaluation optimization 
currently building timber xml database system tax core query evaluation optimization 
query optimization currently underway 
abiteboul quass mchugh widom wiener 
lorel query language semistructured data 
journal digital libraries 
johnson kim 
md join operator complex olap 
proc 
international conference data engineering 
jagadish koudas patel srivastava wu 
twig joins ecient matching xml query patterns 
submitted publication 
beech malhotra 
formal data model algebra xml 
xml query working group note sep 
ceri 
comparative analysis xml query languages 
acm sigmod record volume number march pp 

buneman davidson hillebrand suciu 
query language optimization techniques unstructured data 
proc 
acm sigmod june 
chamberlin robie florescu 
quilt xml query language heterogeneous data sources 
proc 
int 
workshop web databases may 
chamberlin florescu robie simeon stefanescu 
xquery query language xml 
working draft 
feb 
codd 
relational model data large shared data banks 
cacm pp 

christophides cluet simeon 
wrapping query languages ecient xml integration 
proc 
sigmod pages 
consens mendelzon 
hy query visualization system 
proc 
sigmod pages 
consens mendelzon 
graphlog visual formalism real life recursion 
proc 
pods apr 
deutsch fernandez florescu levy suciu 
query language xml 
proc 
int 
world wide web conf 

tree acceptors applications jcss vol 
pages 
fankhauser fernandez malhotra simeon wadler 
xml query algebra 
working draft 
feb 
fernandez simeon wadler 
algebra xml query 
proc 
fst tcs delhi december 
fernandez simeon wadler editors 
xml query languages experiences draft manuscript communication xml query working group september 
florescu kossmann 
storing querying xml data 
ieee data eng 
bulletin 
goldman widom 
dataguides enabling query formulation optimization semistructured databases 
proc 
vldb 
gyssens paredaens van gucht 
grammar approach unifying hierarchical data models 
proc 
acm sigmod pages 
ho mann donnell 
pattern matching trees 
jacm vol 
pages 
hosoya pierce 
xduce typed xml processing language 
proc 
int 
workshop web databases may 
jagadish laks lakshmanan tova milo divesh srivastava vista 
querying network directories 
proc 
acm sigmod philadelphia pa june 
kifer kim sagiv 
querying object oriented databases 
proc 
acm sigmod pages 
klug 
calculating constraints relational expressions 
tods pp 

papakonstantinou 
navigation driven evaluation virtual mediated views 
proc 
edbt pp 

papakonstantinou vianu 
dtd inference views xml data 
proc 
pods 
robie ed 
xql proposal 
metalab unc edu xql xql proposal html shanmugasundaram gang tufte zhang dewitt naughton 
relational databases querying xml documents limitations opportunities 
proc 
vldb 
subramanian leung zdonik 
aqua approach querying lists trees object oriented databases 
proc 
icde 
tatarinov ives halevy weld 
updating xml 
proc 
sigmod 
ullman 
principles database systems 
computer science press 
world wide web consortium 
document object model 
www org dom www consortium 
xml query language working group documents 
www org xml query html zhang naughton dewitt luo lohman 
supporting containment queries relational database management systems 
proc 
sigmod 

