draft november chapter appear book traveling salesman problem variations eds kluwer academic publishers 
chapter experimental analysis heuristics stsp david johnson labs research room florham park nj usa research att com lyle mcgeoch dept mathematics computer science amherst college amherst ma lam cs amherst edu 
chapter consider approaches take confronted real world application tsp 
algorithms circumstances 
particular interested case instances large optimization feasible 
theoretical results useful initial guide valuable information come testing implementations heuristics test beds relevant instances 
chapter considers symmetric tsp considers general studied asymmetric case 
symmetric case main types instances tend arise practice heuristics provide surprisingly results reasonable amounts time 
large collection heuristics developed stsp offers broad range tradeoffs running time quality solution 
heuristics range take little time needed read instance get optimum get percent optimum city instances seconds get fractions percent optimum instances size hours 
traveling salesman problem variations relevant level performance course vary depending application 
chapter provides tentative characterization promising approaches levels tradeoff hierarchy 
way hope put previous theoretical experimental practical perspective 
order provide date picture state art authors chapter fred glover cesar rego organized dimacs implementation challenge stsp 
challenge began june continued november additional data collected june 
researchers world including current top research groups ran codes instances collection test suites reporting running times lengths constructed tours 
reported running times special benchmark code distributed organizers 
times allowed estimate speeds machines function instance size normalize running times approximately codes run fixed machine 
provide detailed comparisons wide variety heuristics implementations specific attention robustness scalability solution quality running time tradeoffs 
way hope improve earlier studies golden stewart bentley reinelt johnson mcgeoch covered fewer heuristics instances provide convenient mechanisms comparability 
remainder chapter organized follows 
section provide details challenge testbeds instances covered participants scheme normalizing running times methods evaluating tour quality 
section describe various heuristics studied divided groups basis approach speed summarize experimental results obtained 
section presents suggestions research 
note proceeding certain heuristics described book various reasons covered chapter 
foremost omission approximation schemes geometric stsp arora mitchell described chapter 
heuristics despite impressive theoretical guar dimacs center discrete math theoretical computer science collaboration rutgers princeton universities bell labs labs nec labs telcordia technologies 
th dimacs implementation challenge series 
information see dimacs rutgers edu challenges 
experimental analysis heuristics stsp significant drawbacks compared competition shall describing 
perturbation instances initially perform versions heuristics guaranteeing ffl worstcase ratios significant fraction ffl average case 
competitive heuristics typically get percent optimum practice probably choose ffl 
running times prohibitive large constant factor overheads involved fact running times exponential ffl 
interesting verify case date know attempt serious implementation schemes 
second hole coverage concerns local search heuristics polynomial time searchable exponential size neighborhoods subjects chapter 
results heuristic 
empirical study heuristics infancy far little emerged competitive best traditional stsp heuristics 
final hole coverage large burgeoning field metaheuristics represented results 
cover set tabu search implementations cover heuristics simulated annealing neural nets classical genetic algorithms grasp challenge advertised metaheuristic community announcements sent directly researchers previously published papers heuristics sorts tsp 
various reasons little received 
fortunately may missing practical value context stsp 
reported extensive survey metaheuristic codes stsp dominated opt lin kernighan iterated lin kernighan 
metaheuristics role area useful variants tsp 
example adapt readily handling side constraints classical approaches 

dimacs stsp implementation challenge full description dimacs implementation challenge see website www research att com 
addition providing input chapter challenge intended provide continually updated picture state art area tsp heuristics effectiveness robustness scalability 
help algorithm designers assess approaches compare existing tsp heuristics 
traveling salesman problem variations website currently variety material available viewing downloading including instances instance generators benchmark codes raw data participants statistics comparisons derived 
intent maintain website indefinitely updating new results reported adding new instances instance classes interesting ones available 
chapter presents summary interpretation available results june representing code research groups 
groups reported implementations heuristic variant providing fairly comprehensive coverage classical heuristics stsp promising new approaches 
additional details reader referred website forthcoming dimacs technical report data linear fashion 
remainder section describe challenge testbeds detail scheme normalizing running times 

testbeds designing challenge testbeds chosen ignore instances fewer cities 
done reasons 
shall see currently available optimization codes particular publicly available concorde package applegate bixby chv atal cook able solve typical stsp instances fewer cities quite feasible running times 
concorde able solve city instances random testbeds default settings 
normalized running times typically minutes longest instance took just little hours 
second willing spend seconds minutes best current heuristics hard beat 
instance iteration version publicly available lkh code helsgaun get optimum seconds normalized city random instances tsplib instances cities 
clear heuristics needed instances fewer cities high quality solutions obtained practical running times publicly available codes 
real research question heuristic performance scales instance sizes grow es currently available www math princeton edu tsp concorde html 
tsplib database instances tsp related problems created maintained www uni heidelberg de groups software tsplib gerd reinelt described 
experimental analysis heuristics stsp modern applications generate instances cities 
second decision concentrate primarily geometric instances dimensions 
experimental research stsp date concentrated instances 
largely major applications stsp industrial academic sort 
consequently codes written exploit structure instances 
limited experimentation higher dimensional instances suggests lessons learned dimensions carry 
third decision common practice literature assumption codes restrict attention instances inter city distances integral 
challenge test suite contains classes geometric instances random uniform euclidean instances uniform 
cities points coordinates integers chosen randomly interval instance sizes increasing roughly factors 
distances euclidean distance rounded nearest integer 
instances cities size sizes sizes 
instances type widely studied yield interesting view asymptotic performance 
random clustered euclidean instances clustered 
choose cluster centers coordinates chosen uniformly cities randomly choose center normally distributed variables multiplied rounded added corresponding coordinate chosen center 
distances euclidean distance rounded nearest integer 
class instances cities size sizes size 
designed challenging local search heuristics 
geometric instances tsplib cities june 
instances range size cities 
dimensional rounded euclidean distances rounded nearest integer 
come geography coordinates actual cities earth viewed planar industrial applications involving circuit boards printed circuits programmable gate arrays 
traveling salesman problem variations applications non geometric instances tend asymmetric non geometric covered chapter 
stsp challenge main source non geometric instances consisted random symmetric distance matrices non geometric class previously widely studied context stsp 
instances direct relevance practice offer substantial challenge heuristics useful studying robustness various approaches 
random matrix testbed distances independently chosen integers distributed uniformly interval 
include instances size size size 
instance type consists roughly integers storage problem larger addition testbed contains instance tsplib distance matrix cities si 
participants encouraged run codes testbed instances possible possible 
main reasons participants handle entire test suite 
participant code slow handle largest instances participant machine 

code fast required memory handle largest instances participant machine 

participant code designed handle geometric instances handle instances distance matrices 

participant code designed handle instances fractional coordinates 
despite fact tsplib instances integral inter city distances geometric tsplib instances test suite fractional coordinates 
need defects underlying heuristic 
particular typically circumvented additional coding participants shown ameliorated code tuning memory management powerful machines 
reason may forgiving heuristics geometric definition convex hull cheapest insertion experience substantial slowdowns unable exploit geometric structure 
case report results implementations relevant try identify heuristics faster robust implementations may possible 
experimental analysis heuristics stsp 
running time normalization running time comparisons notoriously difficult precision codes compiled compiler compiler options run machine 
allowing participants compile codes run machines problem substantially difficult 
wish restrict participation willing share source codes wanted establish record state art meaningful machines currently obsolete forgotten choice 
order provide basis comparison distributed benchmark stsp code implementation greedy multi fragment heuristic uses trees speed operation geometric instances 
participants asked run code machines set instances covering range sizes challenge test suite report resulting running times 
note accurately quantify difference speeds machines single number 
various memory hierarchy effects relative speeds machines may vary significantly function size input instances 
graphs running time benchmark code function instance size variety machines shows widely relative machine speeds vary function 
chart running times divided log approximate number basic operations performed heuristic 
reports normalize running times approximately specific benchmark machine compaq es mhz alpha processors gigabytes main memory 
basic plan compute normalization factor function equal instance sizes uniform test suite simply ratio benchmark code time source machine es test instance size assuming benchmark code run source machine instances large 
values interpolate find appropriate normalization factor 
multiple sources potential inaccuracy process 
linear interpolation inexact approach getting intermediate normalization factors 
particular code may require memory value benchmark greedy code 
may efficient instruction data caches benchmark code 
normalization process de emphasizes time read instance 
reading times necessarily differ traveling salesman problem variations machine speeds number cities mhz alpha mhz pentium mhz sparc mhz mips mhz mips mhz mips mhz powerpc 
running times benchmark greedy code function instance size variety microprocessor machines 
microprocessors listed order average times city instances 
factors cpu times significant component running time faster codes study especially smaller instances instances full distance matrices 
de emphasis arises way deal fact systems typically report running times increments seconds 
benchmark greedy code fast running time typically city instances 
difficult derive precise normalization factors single run 
perform benchmark runs smaller instances re experimental analysis heuristics stsp port total time series runs instance 
number runs chosen product number runs roughly just run performed instance cities 
basic data structures rebuilt run instance read 
single read sense heuristics testing read instance 
reducing proportion total time devoted reading approach may impact reading time heuristics major component total time 
get feel typical accuracy normalization procedure see charts benchmark greedy code johnson mcgeoch implementation lin kernighan heuristic ratio actual time target es machine normalized time compiling code running mhz mips processor sgi challenge machine 
note heuristic error somewhat systematic function error consistent heuristics 
greedy tendency go underestimate overestimate increases possibly reflecting reading time underestimate mentioned 
hand read time major component running time geometric instances tendency go overestimate underestimate possibly code needs substantially memory greedy mips machine larger nd level caches es 
worth noting codes estimate typically factor correct time 
unfortunately estimate running times specific codes factor may imply precise talking heuristics 
differing amounts low level machine specific code tuning yield running time differences factor implementations supposedly data structures heuristic speedup tricks 
cause greater changes speed specified highlevel description heuristic 
sees order magnitude differences running times clear distinctions running time growth rates difficult draw definitive relative efficiency heuristics implemented different people different machines 
fortunately orders magnitude differences running time realm tsp heuristics relative efficiency possible 
traveling salesman problem variations mips normalized time alpha actual time errors running time normalization benchmark greedy code overestimate underestimate uniform points clustered points tsplib instances random matrices mips normalized time alpha actual time number cities errors running time normalization lin kernighan overestimate underestimate 
ratios predicted running time actual running time compaq mhz alpha processor benchmark greedy code implementation lin kernighan 
experimental analysis heuristics stsp 
evaluating tour quality gold standard tour quality course distance optimal solution typically measured percentage tour length exceeds length optimum tour 
order standard unfortunately know optimal solution value 
modern optimization technology surprisingly effective provably optimal solutions instances tsplib cities fewer concorde code applegate bixby chv atal cook able solve random instances challenge test suite fewer cities city random matrix instance 
prime reason heuristics get reasonable results instances difficult current optimization algorithms 
reason test suite contains instances optimal tour lengths known 
order provide point similar instances default comparison held karp lower bound optimal solution 
linear programming relaxation standard integer programming formulation stsp described chapter 
johnson argue bound surrogate optimal solution value 
random uniform euclidean instances particular conjecture expected gap optimal tour length held karp bound asymptotically provide extensive experimental evidence supporting conjecture 
table shows percent optimal tour length exceeds held karp bound instances test suite optimal known 
note typical excess maximum excess observed 
optimal tour length known largest tsplib instances tour known held karp bound 
table includes normalized running times computing optimal tour lengths computing held karp bounds typically easier 
running time reported optimal tour length computation represents time taken concorde default settings 
random instances concorde run mhz mips processors 
times tsplib instances reported applegate tsp webpage www math princeton edu tsp mhz alpha processor benchmark machine 
instances known optima quoted running time additional expertise needed running time cpu years 
traveling salesman problem variations random uniform euclidean tsplib name gap name gap pr si vm pcb rl rl fl fl vm random clustered euclidean rl pr pcb fl rl rl pla rl usa random matrices table 
instances challenge test suite known optimal solutions percent optimal tour length exceeds held karp bound normalized running times seconds computing concorde default settings 
indicates default settings suffice 
random instances suffixes stand cities respectively 
number cities tsplib instance numerical suffix 
experimental analysis heuristics stsp held karp times reported concorde contains flag computing held karp bound 
linear program defines bound involves exponential number subtour constraints simple routines finding violated constraints type typically need order solve lp exactly 
effective accurate lagrangean relaxation approach originally suggested held karp 
concorde able compute bound default settings local sgi machine instances challenge test suite cities maximum normalized running time roughly hours city random clustered euclidean instance 
powerful machines rice university bill cook code compute bound city instance 
instances test suite cities relied empirical formula derived city instance 

heuristics results noted currently available heuristics stsp provide wide variety tradeoffs solution quality running time 
example illustrates average performance collection heuristics city instances testbed uniform instances 
underlying data table 
details heuristics implementations represented chart table section 
normalized running times range seconds hours percentage excess held karp bound ranges probably optimum 
complete correlation increased running time improved quality 
heuristics appear dominated heuristic provide equivalently tours time provide better tours time 
example bentley implementation nearest insertion ni dominated implementation nearest neighbor nn tabu search implementation tabu sc sc dominated sophisticated iterated variants lin kernighan clk abcc helsgaun 
chapter shall separately consider groups heuristics clustered different regions trade spectrum attempting identify robust heuristics class 
shall concentrate primarily heuristics exclusively 
dominated heuristics theoretical results traveling salesman problem variations strip karp ni nn greedy fi savings cca christo geni opt opt lk tabu clk helsgaun city random uniform euclidean instances normalized running time seconds percent excess held karp bound 
average tradeoffs tour quality normalized running time variety heuristics applied city random uniform euclidean instances 
full abbreviations heuristic names table explained table chapter 
excess time excess time heuristic hk seconds heuristic hk seconds strip christo karp geni ni opt jm nn opt jm lk jm greedy tabu sc sc fi savings clk abcc cca helsgaun table 
average tour quality normalized running times various heuristics city instances random uniform euclidean testbed 
experimental analysis heuristics stsp proven received significant publicity covered cases fact dominated interesting 
example assuming triangle inequality holds nearest insertion produce tour longer twice optimum nn factor theta log fact better practice somewhat surprising 
domination class instances need tell full story 
table summarizes relative performances bentley implementations nearest insertion nearest neighbor function instance size geometric instance classes represented shorthands random uniform geometric instances random clustered geometric instances tsplib instances 
presents detailed picture charts depict relative solution quality running times implementations geometric instances testbeds applied 
implementations designed exploit geometry possible handle fractional coordinates 
analogous tables charts pairs heuristics generated viewed online comparisons page challenge website 
generate charts running time single heuristic compared various growth rates just running times greedy compared log 
average percent excess ni nn average running time ratio ni nn table 
average comparisons nearest insertion ni nearest neighbor nn geometric testbeds 
bentley implementations heuristics 
positive entry excess table indicates ni tours longer indicated percentage average 
subsequent tables sort tsplib averages instances pr pcb rl pr pcb pla pla pla 
may completely typical samples pick instances codes handle ruling tsplib instances fractional coordinates 
traveling salesman problem variations percent difference tour lengths ni vs nn uniform points clustered points tsplib instances ratio normalized running times number cities uniform points clustered points tsplib instances 
tour length normalized running time comparisons nearest insertion versus nearest neighbor 
experimental analysis heuristics stsp nearest insertion versus nn comparison see tour length results city uniform instances echoed larger instances class predict results instance classes 
ni consistently provides better tours nn clustered instances better majority tsplib instances 
ni remain slower nn factor machine instances certain instance classes willing pay price get better tours 
say ni consistently dominated nn see examples consistent domination follows 
body section divided parts covering group related heuristics 
subsections cover typically called tour construction heuristics heuristics incrementally construct tour soon valid tour created 
remaining sections concern heuristics local search component heuristics repeatedly modify current tour hopes finding better 
section consider tour construction heuristics designed speed quality 
strip heuristic spacefilling curve heuristic example little read instance sort 
sections cover remainder classical tour construction heuristics divided somewhat arbitrarily build tours adding edges time nn section augmentation may involve replacing edges nearest insertion christofides section 
tour construction heuristics stsp covered detail book shall sections summarize known theoretically heuristics discussing empirical behavior 
remaining sections cover local search heuristics subject chapter 
section covers simple local search heuristics opt opt 
section covers famous lin kernighan heuristic variants 
section discusses various heuristics involve repeated calls local search heuristic subroutine chained lin kernighan heuristic introduced 
covers set tabu search implementations operate similar fashion 
final section considers heuristics take step heuristic chained lin kernighan subroutine 
room provide full descriptions heuristics cover high level summary mentioning relevant theoretical results possible pointers sources detailed information 
implementation details major impact performance say 
traveling salesman problem variations 
heuristics designed speed section cover heuristics geometric instances stsp designed speed quality tour construct 
particular restrict attention heuristics observed total running time small factor time simply read coordinates cities standard formatted routines 
normalized times shown table 
note read instances faster lower level routines exploit fact coordinates come known format 
approach speedup reading city instance factor 
significant impact speed fastest heuristics currently take approach 
restriction geometric instances ones tuples coordinates important required instance full distance matrix heuristics satisfy speed criterion hardly called fast instance reading take theta time 
heuristics meeting criteria received significant coverage literature strip spacefilling curve fast recursive partitioning heuristics 
section cover plus obvious enhancement 
defined terms dimensional instances principle generalized geometric instances higher dimensions 
results report obtained machine reading times mentioned removes running time normalization extra source inter heuristic variability 
heuristics making pass data determine minimum maximum coordinates minimum enclosing rectangle point set 
strip 
heuristic dividing minimum enclosing rectangle equal width vertical strips sorting cities strip top bottom 
construct tour proceeding leftmost strip rightmost alternately traveling average normalized running time seconds read table 
average normalized times reading instances standard routines compiled mips processors gcc 
experimental analysis heuristics stsp strip final long edge back city rightmost strip leftmost 
heuristic traced back hammersley introduced tool proof behavior optimal tour length 
easy see strip tours omega gamma times optimum worst case 
points uniformly distributed unit square continuous version uniform instance class expected length strip tour length shown 
expected held karp bound instances empirically asymptotic means strip expected excess instances 
results strip summarized table 
note uniform instances upper bound average case excess mentioned close strip actual behavior strip tours worse classes 
strip fast largest instances running time averages times just reading instance time basically independent instance class times heuristics covered section 
strip computation devoted sorting implementation uses variety sorting routines depending instance size 
largest instances pass bucket sort buckets 
means theoretically implementation run linear time instances practice appears bit slower presumably memory hierarchy effects 
fairly easy see strip tours clustered instances poor jump clusters far frequently 
instances tsplib similar going wonder poor performance just artifact fact average percent excess hk bound strip average normalized running time seconds table 
average performance strip heuristic 
traveling salesman problem variations chose vertical strips 
examine question implemented composite heuristic applies original strip heuristic variant uses horizontal strips returns better result way strip 
reading time amortized runs strip running time goes factor 
unfortunately average improvements minor individual exceptions improvement excess tsplib instance rl 
details explored challenge website 
promising competitor strip 
spacefilling curve 
heuristic invented 
cities visited order encountered traversing spacefilling curve minimum enclosing rectangle 
strip time spent simply sorting 
full details see 
prove spacefilling curve heuristic produce tours worse log times optimum 
bertsimas grigni exhibit bad 
get bounded average case ratios 
probabilistic analysis shows cities uniformly distributed unit square asymptotic expected tour length approximately empirical estimate expected held karp bound 
interestingly ratio heuristic tour length go limit lim inf lim sup extremely close 
table presents results inventors implementation 
strip running time stays factor merely reading instance 
average excess uniform instances matches theoretical prediction percentage points worse average percent excess hk bound average normalized running time seconds table 
average performance spacefilling curve heuristic 
experimental analysis heuristics stsp number cities strip vs uniform points clustered points tsplib instances 
tour quality comparisons strip spacefilling curve heuristics 
strip substantially better classes 
provides detailed picture comparison 
results spacefilling curve heuristic preferred choice choose heuristics 
preferred final candidate 
fast recursive partitioning frp 
heuristic proposed bentley hierarchically partitioning cities tree 
starts minimum enclosing rectangle recursively splits rectangle containing cities rectangles roughly half cities 
parent rectangle longer wide median coordinate cities rectangle vertical split value median coordinate horizontal split value call final rectangles containing fewer cities buckets 
nearest neighbor tours constructed buckets patched tour 
frp effectively dominated average times faster better instances testbed usually 
exceptions clustered instances tsplib instance clustered instance produced earlier version generator 
traveling salesman problem variations 
tour construction pure augmentation section cover heuristics build tours adding edge time making choice length edge added 
contrast strip viewed building tours edge time choices simple directional constraints 
class includes nearest neighbor heuristic greedy heuristic variants including lesser known quite effective savings heuristic 
previous section results report generated machine mhz mips processors ensuring running time comparisons biased normalization errors 
may dangerous draw relative speeds closely matched heuristics may highly implementation dependent 
illustrate presenting results multiple implementations heuristics implemented different programmers 
differ significantly constant factors asymptotic growth rates follow recommendations bentley influential papers promoted trees short dimensional binary search tree lazily updated priority queues exploiting geometric structure instances avoiding unnecessary 
significant component implementations described section worth words 
trees 
defining frp heuristic previous section introduced fundamental hierarchical partition instance space underlies tree 
trees typically split rectangle contains cities opposed bound frp 
partition represented tree vertex rectangle 
vertex represents split rectangle store coordinate median point splitting rectangle split left right split top bottom pointers vertices representing split 
bottom trees store pointer parent rectangle 
vertex corresponding final unsplit rectangle store list cities rectangle 
partition associated tree constructed log time 
simple recursive routines search tree various ways 
mention important ones 
assume existence auxiliary array tells cities relevant current search 
nearest neighbor search city find city nearest second experimental analysis heuristics stsp fixed radius near neighbor search city radius return order cities third ball search city assumes additional array rad radii cities returns cities rad cities ball radius rad contains details efficiently implemented see 
searches involve execution log computer instructions data sets third may take somewhat longer depending number relevant balls 
speed vary depending sophistication implementation interaction memory hierarchy machine heuristic run 
section simple heuristics require operations slight variant 
come play complicated heuristics section 
alternative trees delaunay triangulation exploited reinelt 
appears competitive approach results sufficiently comparable yield firm 
trees rate offer substantially power flexibility 
lazily updated priority queues 
data structure tsp heuristics suggested 
priority queue contains items associated values priorities supports operations remove highest priority item queue deliver user pop insert new item delete item modify priority item update 
algorithms textbooks contain variety implementations data structure support operations time log different tradeoffs constant factors 
choice significant effect running time 
major additional savings possible reduce number updates performed happens lazy evaluation 
technique know update increase priority 
case need perform update takes effect popped highest priority item outdated priority 
case item priority reevaluated reinserted queue 
prepared describe section heuristics implemented 
nearest neighbor nn 
start picking initial city inductively suppose gamma current partial tour 
choose nearest city cities tour 
gamma add edge fc gamma completing tour 
non geometric instances heuristic traveling salesman problem variations take time theta geometric instances trees reduce log practice 
double ended nearest neighbor 
start picking initial city inductively suppose endpoints current partial tour contain cities 
nearest non tour cities respectively choose closest respective endpoint add corresponding edge tour 
cities tour add edge fa bg done 
heuristic implemented run fast nn practice need compute nearest neighbor tour gains new endpoint endpoint previous nearest neighbor added tour 
greedy 
start sorting potential tour edges fc order increasing length 
build tour viewed set edges going edges order starting shortest adding fc long degree new edge complete cycle fewer vertices 
described implementation take time theta log time required non geometric instances 
geometric instances reduced combining trees nearest neighbor searches lazily updated priority queue suggested 
done follows 
constructing tree find nearest neighbor city put ordered pair priority queue priority gammad 
queue contains entries highest priority entry corresponds shortest edge greedy add tour 
proceed mark city degree current tour 
city degree tour denote city tour path starting note build greedy tour just gamma pops maintained property times priority queue contained city currently nearest eligible neighbor nearest city 
unfortunately maintaining property require updates pop 
single city nearest eligible neighbor cities 
attains degree longer eligible city thought nearest eligible neighbor find new partner 
note nearest neighbor city needs updated replaced new city far away city replaced 
lazy updating 
pop highest priority item experimental analysis heuristics stsp queue cases 
degree tour simply discard pair pop 
degree tour equal add edge fc tour 
temporarily mark exists find new nearest neighbor insert queue reset exists pop new highest priority pair 
boruvka 
heuristic variant greedy devised applegate bixby chv atal cook analogy classic minimum spanning tree bor ffi 
greedy implementation start computing nearest neighbor city 
putting resulting pairs priority queue simply sort order increasing edge length 
go list edge edge adding tour building long legally 
words pair encountered longer eligible discard pair updating hasn attained degree 
gone list probably won tour repeat process time restricting attention cities degree eligible neighbors 
continue repeat process tour constructed 
comparison greedy heuristic replaces priority queue overhead simple sorting may nearest neighbor searches 
priori evident tours better worse 
quick boruvka boruvka 
variant due applegate bixby chv atal cook dispenses sorting step boruvka presumably trading tour quality increase speed 
go cities arbitrary fixed order skipping city degree adding edge nearest eligible city 
passes set cities required 
savings 
specialization stsp general vehicle routing heuristic proposed clarke wright 
informally works starting pseudo tour consisting multigraph edges arbitrary central city cities 
successively look best way shortcut graph replacing length path non central city direct link 
practice savings heuristic works greedy surrogate distance function 
pair cities surrogate distance function gamma gamma 
tree nearest neighbors surrogate distance function computed slightly complicated version standard nearest neighbor search shown 
dif traveling salesman problem variations ference greedy put priority queue growing tour contains gamma edges point path complete tour adding edges endpoints 
theoretical worst case results proved heuristics assuming triangle inequality triples cities 
heuristics tours guaranteed constant factor optimum provide bounds 
nn shown produce tour longer dlog ne times optimum instances force generate tours roughly long 
greedy produces tour longer log times optimum roughly upper bound nn worst instances known cause produce tours log log log times optimum 
savings produces tour longer log times optimum weaker bound heuristics worst examples known produce tours log log log times optimum 
unaware worst case results relatively boruvka variants bounds better greedy 
graphs average tour quality function heuristics described section classes random geometric instances 
classes typical heuristics cover average percentage excess held karp bound appears approach asymptotic limiting value limits usually different classes 
uniform instances limiting values nn appear roughly held karp bound compared boruvka greedy boruvka savings 
appears yield slightly better averages nn smaller instances advantage vanishes 
variations point attributable small number instances samples 
greedy appears slightly better boruvka smaller instances advantage disappears time 
heuristics perform significantly poorly clustered instances relative asymptotic ranking remains 
tsplib instances tour quality tends lie extremes savings typically better larger tsplib instances uniform instances similar size 
order heuristics running time appear roughly reverse order implies dominated 
table lists normalized running times uniform experimental analysis heuristics stsp random uniform euclidean instances nn boruvka boruvka greedy savings percent excess held karp bound number cities random clustered euclidean instances 
average percentage excess pure augmentation heuristics 
explanation abbreviations see text table 
note ranges different classes instances 
traveling salesman problem variations stances function times clustered instances roughly 
tsplib instances tend faster possibly added structure instances limits breadth tree nearest neighbor searches 
table covers families implementations bentley implementations nn greedy johnson mcgeoch jm implementations heuristics plus savings concorde abcc implementations plus boruvka variants 
suffixes implementers initials 
codes common implementers code produces better tours typically takes longer time values exceptions takes time nn predicted johnson mcgeoch implementation savings beats implementation greedy 
nearest neighbor searches complicated savings greedy balanced fact far fewer need heuristics roughly time 
generally time greedy savings times nn biggest differences occurring concorde implementations 
cross family comparisons problematic presumably implementation differences 
bentley concorde implementations exploit pointers trees implementations 
pointers add constant factor overhead greatly reduce depth searching 
result johnson mcgeoch implementations faster slower larger 
bentley implementations explain part bentley implementations lose concorde nn greedy 
observed running times implementations appear components grows slowly log nn abcc nn nn jm boruvka abcc boruvka abcc greedy abcc greedy greedy jm savings jm table 
normalized running times seconds pure augmentation heuristics random uniform euclidean instances 
experimental analysis heuristics stsp dominates grows faster log dominates 
component fact appears growing faster log worse 
relative importance components crossover point depend heuristic implementation 
determining causes behavior interesting question research 
respect tour quality appreciable difference various implementations nn greedy 
expected defined nature heuristics 
different implementations yield tours 
different tie breaking rules output nn depends starting city chosen 
cases pure domination heuristics adequately cover range trade offs boruvka savings tree implementation chosen expected size instances handled 
real world applications expect savings fast supplant 
assume looking stand heuristic 
shall see sections different may hold choosing method generating starting tours local search heuristic 
story non geometric applications may differ able provide insight 
non geometric implementations greedy nn testbed non geometric instances consists random matrices relevance practice suspect 
worth greedy continues provide substantially better tours nn instances takes roughly time 
unfortunately time theta heuristics produce tour lengths average ratio optimum appears grow exceeds time 
see 

complex tour construction section consider somewhat complicated heuristics ones build tours incrementally 
heuristics ones appealing theoretical performance guarantees dominated savings 
results dominated heuristics covered full detail viewed challenge website 
nearest insertion variants ni na na 
start partial tour consisting chosen city nearest neighbor 
repeatedly choose non tour city distance nearest neighbor tour cities minimum insert follows traveling salesman problem variations insertion rule ni 
insert consecutive tour cities insertion causes minimum increase tour length 
addition rule na 
insert nearest neighbor tour side yields minimum increase tour length 
augmented addition rule na 
insert ni restrict attention pairs consecutive tour cities twice distance nearest neighbor tour 
ni na na guaranteed produce tours longer gamma times optimum assuming triangle inequality holds produce tours bad 
explained bentley introduced augmented addition rule implemented exploit geometry process complicated 
ni requires ball search na requires fixed radius near neighbor search 
expected added complexity na means bentley implementations heuristics substantially slower savings 
produce worse tours instances geometric testbeds 
uniform instances ni na average percentage excess held karp bound approaches compared savings limiting percentage na 
variants dominated savings 
holds family theoretically interesting heuristics 
cheapest insertion variants ci 
cheapest insertion ci start partial tour consisting chosen city nearest neighbor 
repeatedly choose triple cities adjacent current tour non tour city increase tour length occur inserted minimized perform insertion 
assuming triangle inequality ci obeys gamma times optimum bound nearest insertion 
convex hull variant starts computing convex hull cities creating starting tour consisting radial order 
trivially obeys gamma bound result ci 
implementations take advantage geometry explained 
convex hull linear time algorithm graham 
johnson mcgeoch implementations ci remain substantially slower implementation savings universally worse 
slightly better experimental analysis heuristics stsp savings city clustered instance 
tends produce better tours ci advantage shrinks grows 
uniform instances average percentage excess held karp bound ci tends versus savings 
double minimum spanning tree 
construct multigraph consisting copies minimum spanning tree cities 
graph euler tour necessarily simple cycle includes edge exactly 
construct convert hamiltonian cycle shortcuts avoid visiting cities 
assuming triangle inequality holds heuristic obeys gamma worst case bound nearest cheapest insertion 
geometry exploited implementing particular constructing initial mst 
euler tour linear time shortcuts needed produce tour 
unfortunately slower savings greedy shortcut procedure described context christofides heuristic produces substantially worse tours savings 
uniform instances average percentage excess tends results classes comparable 
karp partitioning heuristic karp 
tree construction frp heuristic section recursively partitioning cities horizontal vertical cuts median cities median city included subsets cities created cut 
process continued cities set partition parameter 
dynamic programming algorithm bellman optimally solve subproblems induced sets cities final partition 
recursively patch solutions means shared medians 
fixed takes log time 
heuristic proposed karp analyzed average case behavior closely related non adaptive heuristic 
non adaptive variant ffl exists ffl uniform instances expected ratio heuristic tour length optimal tour length asymptotically ffl 
unfortunately ffl grows linearly ffl running time space requirements dynamic programming subroutine exponential 
see chapter 
adaptive version heuristic test produce better tours robust presence non uniform data rigorously proved 
suffers drawbacks far concerned largest value proved feasible 
average number cities traveling salesman problem variations final partitions vary depending value heuristic wildly varying running time function average quality tours produces uniform instances fails go limit 
expected best results correspond worst running times hundreds times worse savings 
best results far worse savings lim inf uniform instance larger results clustered tsplib instances substantially worse 
failings approach ameliorated settles nearoptimal optimal solutions final subproblems 
approach taken frp small value poor heuristic nn 
uses large value powerful heuristics describe chapter better 
plausible choice coping instances big handled main memory 
tour construction heuristics proposed literature dominated savings example recursive clustering heuristic greatest angle insertion heuristic golden stewart implemented exploit geometry covered challenge website 
independent theoretical interest 
remainder section concentrate heuristics dominated savings 
consider variants nearest insertion lack strong theoretical guarantees perform better practice 
random farthest insertion variants ri ra ra fi fa fa 
heuristics differ nearest variants mainly choice city add 
random variants city simply chosen randomly 
farthest variants add city largest value minfd 
sets variants start tour consisting maximally distant cities 
best guarantee currently provable heuristics assuming triangle inequality provide tours log times optimum 
know bound tight 
worst examples known random variants obtained azar euclidean instances high probability heuristics produce tours length theta log log log log log times optimum 
worst examples known farthest variants obtained yield ratios optimum approach triangle inequality dimensional euclidean 
nearest variants heuristics implemented exploit trees 
random variants save identifying experimental analysis heuristics stsp city insert fastest 
farthest variants require additional order find point inserted done tree tour cities lazily updated priority queue non tour city lists distance closest tour city time entry computed 
indication relative asymptotic performance variants see table summarizes average results bentley implementations uniform instances 
comparison purposes results johnson mcgeoch implementation savings included 
note family augmented addition takes twice time addition provides substantially better tours especially cases random farthest families 
second note family augmented addition variants produce nearly tours insertion siblings fraction running time cost 
unfortunately heuristics clearly competitive savings running time ra produces poor tours 
uniform instances don tell full story 
illustration total picture see instances geometric testbeds fractional coordinates compares tour lengths fi savings 
savings typically greater advantage tsplib instances uniform ones different story holds clustered instance class 
instances ra ri fa fi find better tours average savings ranging roughly improvement ra ri improvement fa fi 
point ra advantage 
slower savings running time similar bentley implementation greedy faster savings larger roughly implementation dependent reasons 
conclude heuristics savings technically incomparable totally dominates 
heuristic na na ni ra ra ri fa fa fi sav excess seconds table 
average percentage held karp bound normalized running times bentley implementations insertion addition augmented addition heuristics applied city random uniform euclidean instances 
comparison purposes column gives results johnson mcgeoch implementation savings 
traveling salesman problem variations percent difference tour lengths number cities fi vs savings fi better savings better uniform points clustered points tsplib instances 
tour quality comparisons farthest insertion savings heuristics 
artificial nature clustered instances probably choose savings heuristic 
cca 
abbreviation convex hull cheapest insertion angle selection heuristic proposed golden stewart claimed best tour construction heuristic study 
starts constructing convex hull cities proceeds successively inserting remaining cities 
choice insertion complicated 
non tour city determines pair adjacent tour cities inserted increase tour length 
select maximizes angle edges fa cg fc insert tour 
known theoretically heuristic complexity difficult impossible exploit geometry implementing 
results reported impressive largest instance considered cities 
see handles larger instances johnson mcgeoch constructed implementation tested 
running times expected non competitive growing rate theta theta normalized hours cities largest instance tried versus seconds savings 
experimental analysis heuristics stsp percent difference tour lengths number cities cca vs savings cca better savings better uniform points clustered points tsplib instances 
tour quality comparisons cca savings heuristics 
seen cca find better tours instances types advantage uniform tsplib instances vanishing grows 
particular limiting value average percentage excess uniform instances exceed value savings christofides heuristic variants 
final collection tour construction heuristics consider variants famous heuristic christofides currently best worst case guarantee known polynomial time tsp heuristic assuming triangle inequality 
christofides heuristic clever improvement double minimum spanning tree heuristic described earlier 
standard version christofides christo start computing minimum spanning tree 
adding second copy mst get eulerian multigraph add minimum weight matching odd degree vertices mst optimally grows mst eulerian multigraph 
find euler tour traverse past previously visited vertices 
leads improved guarantee assuming triangle inequality tour produced times optimal tour length bound asymptotically attainable dimensional euclidean instances shown nemhauser 
traveling salesman problem variations number cities christofides greedy shortcuts uniform points clustered points tsplib instances 
tour quality christofides greedy shortcuts 
unfortunately improvement worst case behavior comes price 
running time christofides dominated computing minimum weight matching best algorithms known running times compared non geometric worst case running time log savings 
fortunately practice matching codes exploit geometry run quickly 
implementations christofides studied code cook tree minimum spanning tree algorithm 
observed running time appeared able handle instances cities normalized time hour times longer savings 
memory problems prevented successfully running christofides code larger instances 
tour quality results standard version christofides disappointing 
farthest insertion beats savings clustered instances worse uniform instances tsplib instances 
average percentage excess uniform instances appears approach worse limits fa fi savings 
story 
natural question better job final phase heuristic 
shown papadimitriou vazirani experimental analysis heuristics stsp np hard find optimal way shortcut euler tour 
heuristics significantly better naive approach taken standard implementation 
greedy shortcut version christofides christo examines multiply visited cities arbitrary order chooses current best possible shortcuts 
version runs essentially time standard finds better tours savings farthest insertion instance instances worse 
consistent 
plots percentage excess held karp bound christo integral coordinate geometric instances testbeds city instance couldn run 
classes christo larger instances lie 
limiting percentage uniform instances appears substantial improvement heuristics covered 
christo outperforms cca instances cities performs better average case clustered instances cities course faster 
modification christofides proposed replace initial mst tree obtained process computing held karp bound lagrangean relaxation 
approach combined greedy shortcuts andre implementation shall call christo hk 
lagrangean relaxation scheme involves spanning tree computations weighted sparse graphs derived delaunay triangulation cities 
attempt run process convergence takes substantially longer simply computing single mst cities asymptotically christo hk times slower christo 
find significantly better tours average excess hk bound appears go uniform instances clustered instances 
unwilling pay running time penalty christo christo hk natural ask sped bottleneck matching phase christofides algorithm fast heuristic get necessarily optimal matching greedy shortcuts 
implemented heuristic tree greedy matching procedure followed opting looking pairs fa bg fc dg matched cities changing partners fa cg fb dg shortens matching 
opting procedure uses speedup tricks opt tsp heuristic described section 
resulting traveling salesman problem variations average percent excess hk bound uniform instances ra chr fi cca sav ach chr chr hk average normalized running time seconds ra chr fi cca sav ach chr chr hk table 
results powerful tour construction heuristics random uniform euclidean instances 
sav ach chr stand savings christo respectively 
approximate christofides heuristic times faster christo average tour lengths increasing higher clustered instances 
uniform instances limiting percentage excess appears compared savings typically times slower 
table summarizes tour quality running time results uniform instances best complex tour construction heuristics section savings included comparison purposes 
times similarly sized instances geometric classes roughly case clustered instances 
typically twice slow instances christo christo times slower smaller ones improving slower 

simple local search heuristics sections cover various local search heuristics stsp described detail chapter 
local search heuristic tsp defines neighborhood experimental analysis heuristics stsp structure set tours tour declared neighbor tour differs specified way 
classic neighborhoods type opt neighborhoods obtained deleting edges replacing different set edges opt move 
sets need disjoint particular opt move special case opt move 
neighborhood structure standard local search heuristic operates phases 
uses tour construction heuristic generate starting tour 
repeatedly replaces current tour neighboring tour shorter length tour exists case tour locally optimal heuristic explore neighborhoods exhaustively 
local search heuristic uses opt neighborhood usually called simply opt section study various pure restricted heuristics kind 
currently opt opt main opt heuristics practice introduced respectively flood bock 
shen lin influential study opt concluded extra time required opt worth small improvement tour quality yielded results appeared contradict 
contrast attempts trade tour quality improved running time opt exploiting restricted versions opt neighborhood opt heuristic opt heuristic bentley 
implementation details 
simply stating neighborhood structure completely specify local search heuristic 
order determine tours generated heuristic needs provide additional details tour construction heuristic rule choosing improving move method look improving moves rule specified depends order moves examined heuristic running time depend additional implementation details 
naively expect opt opt require omega gamma omega gamma time respectively practice implemented run quickly geometric instances 
opt implemented run quickly omega gamma non geometric instances 
factors involved speedups key ones 

avoiding search space redundancy 
bounded neighbor lists 
don look bits traveling salesman problem variations 
tree tour representation second third trade potential slight degradation tour quality improvements running time 
particular leaves open slight possibility final tour may optimal optimal may better neighboring tour failed notice 
describe factors individually relevant simple local search heuristics section sophisticated heuristics sections 
avoiding search space redundancy 
illustrate context opt 
possible opt move viewed corresponding tuple cities ha di fa bg fc dg tour edges deleted fa cg fb dg edges replace 
suppose intend search possibilities follows range possibilities range possibilities range possibilities choice forced 
note stated move examined times depending ht ha bi hb ai hc di hd ci 
redundancy exploited follows consider city 
note ha di examined regimen improving move 
improving move missed 
restriction typically strongly limits possibilities heuristic proceeds 
generalization opt limits choices analogous final choice geometric instances restriction implemented kd trees fixed radius near neighbor search described 
non geometric instances simply precompute city ordered list cities increasing distance 
quicker option 
bounded neighbor lists 
creating city ordered list cities create truncated list nearest cities ordered increasing distance assumption distant cities yield improving moves 
general lists computed time log 
geometric instances reduced log trees 
possibly robust version approach include city bk cities closest quadrants coordinate system 
total fewer cities augment set nearest remaining cities bring experimental analysis heuristics stsp total referred follows quad neighbor list 
possibility geometric instances suggested reinelt construct neighbor list cities closest delaunay triangulation city set 
don look bits 
idea introduced bentley help avoid repetition fruitless searches 
suppose search improving moves described outer loop considers possible choices suppose considering case time searched didn find improving move ii tour neighbors time 
find improving move time 
bentley proposed searching case willing risk possibility occasionally improving move missed 
order keep track cities searches skipped suggested maintaining array don look bits 
initially bits set 
bit set search unsuccessful 
conversely edge tour deleted improving move endpoints get don look bits set back 
note local search procedure continues number bits set decline may sense simply keep cities bits queue ordered length time examined keeping explicit array don look bits 
way avoid searches spend time considering cities skipped 
tree tour representation 
empirical measurements reported suggest uniform instances opt opt typically theta improving moves 
bentley observed increases time spent performing moves came dominate time implementations 
way represented tour 
opt move basically involves cutting tour places reversing order resulting segments putting back 
tour stored straightforward way array doubly linked list means time performing opt move proportional length shorter segment 
bentley empirical data suggested uniform instances average length shorter segment growing roughly average performing move 
consider alternative tree representations reduced level trees log splay tree data structure 
study tradeoffs involved crossover points various tour representations see 
traveling salesman problem variations results opt opt opt 
implementation choices difference tour quality running time 
consider sets implementations 
opt opt implementations johnson mcgeoch jm 
opt opt opt implementations bentley 
third heuristic restricted version opt opt neighborhood augmented opt moves delete single city tour reinserted 
opt implementations applegate bixby chv atal cook abcc 
included options program concorde software release 
sets implementations similar exploit don bits differ respects 
concorde implementations nearest neighbor generate starting tours bentley johnson mcgeoch implementations greedy heuristic johnson mcgeoch randomized variant picks shortest edge probability second shortest probability 
heuristics concorde considers neighbors choice bentley implementations consider 
difference move selection 
choice johnson mcgeoch concorde implementations apply improving move jm implementations improving opt move performed opt way extend better opt move 
contrast choice bentley implementations keep looking improving moves seen run possibilities performs best 
bentley concorde implementations chance finding improving moves fixed radius near neighbor searches find possible candidates case opt jm implementations restrict choices quad neighbor lists length 
hand case opt bentley implementation examines fewer classes potential opt moves omitting example opt moves permute reverse segments created tour edges deleted 
final difference bentley concorde implementations represent tour array johnson mcgeoch level tree 
table summarizes average heuristic performance implementations instances approximately cities experimental analysis heuristics stsp percent excess time seconds algorithm christo christo hk opt opt jm opt abcc opt opt abcc opt opt jm opt abcc table 
average percent excess hk bound normalized running times city uniform clustered instances tsplib instance pla 
codes run machine 
geometric classes 
observation concorde abcc implementations faster produce worse tours jm counterparts 
reasonable tradeoff context intended concorde implementations quickly generate sets edges concorde components 
illustrate danger concorde restriction choice city primary cause tradeoff applying restriction jm implementations yields similar improvements running time degradations tour quality 
comparisons bentley jm implementations produce better results uniform instances worse clustered instances 
bentley complete examination candidates may paying substantial running time penalty case opt 
tsplib instances results mixed jm implementations producing better tours pla shown table 
evident table running time penalty bentley concorde implementations experience due array representation tours 
observed running times omega gamma growth rates jm implementations tree tour representations observed running times appear log 
consequence opt times slower jm implementation full opt opt abcc opt abcc times slower corresponding jm implementations 
table addresses question simple local search heuristics compare best tour construction heuristics study greedy shortcut christofides christo held karp traveling salesman problem variations percent excess time seconds algorithm nn abcc greedy jm opt jm opt jm table 
average percent hk bound normalized running times random matrix instances sizes cities 
codes run machine 
variant christo hk 
results table appear dominated opt opt jm dominated opt 
situation bit complicated looks challenge testbeds 
christo tends produce better tours opt clustered instances faster bentley jm implementations uniform tsplib instances fewer cities 
opt opt jm produce better tours christo christo hk instances challenge testbeds run 
opt jm loses instances 
running time advantage christo factor smaller instances handled opt jm normalized time seconds usually running time christo hk substantially worse opt jm board probably real reason christofides variant practice assuming implementation opt 
jm implementations opt opt handle non geometric instances ran random matrix testbed 
results summarized table comparison purposes includes results tour construction implementations handle instances benchmark greedy code provides estimate lengths starting tours opt jm opt jm concorde implementation nn 
observe heuristics produce poorer tours random matrix instances geometric instances 
best opt percentage worse factor 
note tour quality declines substantially increases 
results heuristics consistent conjecture average percentage excess grows log geometric instances testbeds heuristics average percentage bounded independent running time random matrices worse growing experimental analysis heuristics stsp somewhat rapidly nominal growth rate simply reading instance 
interesting side effect time performing local search significant component running time 
opt jm takes time nn abcc running time difference opt jm opt jm inconsequential 
local search speedup tricks mentioned continue applicable local search phase take longer random matrices geometric instances 
better opt jm tours heuristics obvious choice want solve kind instance 
starting tours neighbor lists 
noted bentley jm implementations greedy heuristic generate starting tours 
decision extensive experiments reported showed greedy tours tended yield best results comparison worse tour construction heuristics nn infamous generate random tour heuristic better ones fi savings 
appears starting tour needs obvious defects simple local search heuristic find way major improvements bad heuristic able full difference 
random starting tours additional disadvantage lead increased running times moves need reach local optimality 
jm implementations results reported neighbor lists length 
authors suggested substantially shorter lists context implementations reasonable compromise 
lists length saves running time average causes tour lengths increase opt jm opt jm instance classes 
increasing list length increases running time opt jm average improves tour length clustered instances 
average improvements clustered instances variable appear average roughly 
opt jm tour length improvements due increasing neighbor list length slightly larger running time greater opt jm neighbors finds better tours 
full details see challenge website 
simple local search heuristics 
opt restricted version opt heuristic seriously studied 
early attention devoted opt heuristic traveling salesman problem variations uses neighborhood intermediate opt full opt 
opt consider opt moves segments tour initially broken contains just city opt expands segments cities 
originally proposed way reducing running time overhead naive omega gamma implementation opt existence speedup tricks mentioned widely known 
tricks adaptable opt retain speed advantage complete opt implementation 
probable tour degradation due smaller opt neighborhood justified opt longer appears serious competitor 
implementations submitted challenge 
researchers considered putting restrictions opt neighborhood intent getting better tours opt paying full running time penalty opt 
families heuristics type submitted challenge geni genius heuristics gendreau hertz laporte heuristics burke cowling 
point view geni viewed tour construction heuristic tour augmented city time 
augmentation equivalent simple insertion followed opt move chosen consider section local search 
genius uses geni construct starting tour attempts improve procedure technically restricted version opt 
addition heuristics truncated nearest neighbor lists restrict choices heuristic parameterized length lists 
tested implementations geni genius provided gendreau fine tuned improving handling memory allocation removing redundant operations 
fine tuning change output tours result substantial running time improvements 
implementations exploit full set speedup tricks listed geni times slower city instances opt jm machine genius time slower 
geni genius find better tours opt clustered instances worse uniform instances tsplib instances 
increasing yield significant improvement tours causes substantial increases running time 
possible reimplementation heuristics take advantage speedup tricks competitive 
experimental analysis heuristics stsp speed heuristics sufficiently competitive implementations lin kernighan described section find better tours board 
comparisons genius heuristic renaud laporte uses restricted opt neighborhood competitive 
heuristics come parameterized form neighborhood structure restricted version opt neighborhood 
construct neighboring tour deletes disjoint sets consecutive tour edges 
breaks tour gamma isolated cities 
recombined optimally tour dynamic programming 
implementations burke substantially faster geni genius account possible normalization errors 
normalized times comparable opt jm start degrade 
unfortunately average tour quality worse opt jm geometric instance classes 
slightly better opt jm clustered instances close call opt jm times faster 
appear restricted opt heuristics offer promising avenue cost effective improvements opt 
shown lin kernighan better generalization concept variable depth search 
cover heuristics concept section 

lin kernighan variants lin kernighan heuristic limit search moves change bounded number edges 
principle change edges tour single move 
moves specific structure viewed opt move followed sequence opt moves full final move need improve tour 
heuristic keeps running time control restricting lk search moves grown opt move time backtracking fixed level 
addition uses neighbor lists restrict number growth alternatives considers locks edges changed move changes won subsequently undone aborts search strict gain criterion best tour seen far met 
details chapter 
implementing lin kernighan far choices simple heuristics opt opt literature con traveling salesman problem variations tains reports implementations lin kernighan widely varying behavior 
addition standard choices tour construction heuristic continue looking better improving moves long neighbor lists constituted tour representation don look bits new choices broad search 
original lin kernighan implementation restricted attention neighbor lists length levels search 
backtracking allowed 
original lin kernighan implementation considered opt moves met gain criterion restricted class opt moves starting points lk search 
consider just standard choices lock deleted added edges classes 
original lk implementation locked locking classes separately insure search runs polynomial time 
tighten gain criterion middle lk search better tour discovered way 
extend partial move yields best tour best gain criterion 
impose constant bound depth augment moves constructed lk search non sequential double bridge opt moves proposed lin kernighan implementation 
consider topological variants way moves grown structure maintained level search 
lin kernighan structure path fixed changes considered growing move consist adding edge path city neighbor list deleting edge take back path 
possible structures implemented path mak morton stem cycle glover 
addition alternative ways extending lk search experimental analysis heuristics stsp standard opt move considered variant due helsgaun augments opt moves 
space go full detail tested implementations differ 
implementers written descriptions implementations provide answers 
concentrate follows key differences similarities effects various choices necessarily tentative 
basic lin kernighan 
start implementations depart major ways original heuristic implementations path structure opt moves augmentation method lk search perform double bridge moves 
implementations submitted challenge 
lk jm johnson mcgeoch 
main results reported implementation greedy starting tours length quad neighbor lists levels search don look bits level tree tour representation 
lk search implementation uses anchored path structure locks added edges updates gain criterion better tour mid search bound depth searches follows original lin kernighan fortran code derived 

lk neto neto 
implementation original lin kernighan johnson mcgeoch chapter 
differs johnson mcgeoch implementation neighbor lists consist quadrant neighbors unioned nearest neighbors lk searches bounded moves special cluster compensation routines hopes improving performance instances cities grouped widely separated clusters presumably clustered instances 
source code implementation available www cs toronto edu neto research lk 

lk abcc applegate bixby chv atal cook 
default lin kernighan implementation concorde 
remarks appear implementation differs johnson mcgeoch implementation mainly follows uses boruvka starting tours length quad neighbor lists path structure narrower slightly deeper backtracking strategy just choice lk searches bounded moves 
source code available concorde website 
traveling salesman problem variations 
lk acr applegate cook 
remarks appear implementation differs concorde uses slightly broader deeper backtracking strategy bounds depth lk search moves 
implementations optimized context chained lin kernighan speed single invocation lk may important saving fractions percent tour length 
results confirm 
see table presents average tour qualities running times implementations 
comparison purposes corresponding results opt jm included 
note lk jm lk neto provide roughly equivalent tours clustered instances 
tours typically substantially better lk abcc lk acr lk abcc lk acr significantly faster clustered tsplib instances uniform instances 
case abcc implementations opt major reason disparity probably restriction lk abcc lk acr single choice second lesser reason fact heuristics construct shorter neighbor lists quickly 
fact bound depth lk search major factor lk neto bounds depth 
imposes depth bound lk jm tour quality running time typically affected significantly 
asymptotic growth rates observed running times lk jm lk acr appear lk neto lk abcc may somewhat worse 
lk abcc lk acr tends yield slightly better tours take slightly longer results closer opt jm lk jm 
smallest tsplib sizes opt jm average finds better tours lk acr 
surprising look running times lk acr appears subject normalizing errors time opt jm instances 
lk abcc fast 
turning relationship lk jm lk neto observation algorithmic descriptions lk neto implementation adequate define reproducible lin kernighan implementation far tour quality uniform tsplib instances concerned 
implementations differ significantly clustered instances presumably neto added innovations designed handle clustered instances effectively 
unfortunately particular class clustered instances innovations appear effec experimental analysis heuristics stsp average percent excess hk bound random uniform euclidean instances lk jm neto abcc acr opt jm random clustered euclidean instances lk jm neto abcc acr opt jm tsplib instances lk jm neto abcc acr opt jm average normalized running time seconds random uniform euclidean instances lk jm neto abcc acr opt jm random clustered euclidean instances lk jm neto abcc acr opt jm tsplib instances lk jm neto abcc acr opt jm table 
results opt implementations lin kernighan 
averages tsplib taken instances 
traveling salesman problem variations tive 
lk neto provides significantly worse tours lk jm ratio normalized running time lk jm higher clustered instances uniform instances 
appears unidentified difference implementations asymptotic effect running times uniform instances normalized running times lk neto start diverge lk jm gets large 
lk implementations variants greedy heuristic generate starting tours provide opportunity analyze effects different starting heuristics final lk results 
analyses sort 
question hard resist happen combined lin kernighan best slowest tour generation heuristics christo hk 
andre submitted results just combination lin kernighan implementation early lacks detailed tuning lk abcc lk acr results intriguing 
total running time dominated simply generate starting tour uniform tsplib instances averages times slower lk jm 
final tours significantly better 
uniform instances limiting ratio hk bound appears versus lk jm average improvement lk jm tsplib instances ranges 
larger clustered instances improvement lk jm roughly essentially running time penalty 
bigger improvements possible repeated local search heuristics section heuristics typically take time 
combining lin kernighan christo hk appealing option 
complete lin kernighan picture table covers random matrix instances 
results lk neto cover city instance include version lk jm lk search depth bounded lk jm bd 
note triangle inequality hold christo hk starting tours longer relevant 
lk acr faster opt jm case significantly finds better tours 
tours worse lk abcc produce significantly worse tours lk jm lk neto 
clear difference attributed bounding depth lk search 
lk neto bounding finds significantly better tours lk jm bounding reasons unknown contrast results geometric case 
running times implementations lk acr comparable dominated time read experimental analysis heuristics stsp percent excess time seconds algorithm lk jm jm bd neto abcc acr opt jm table 
average percent hk bound normalized running times random matrix instances sizes cities 
preprocess instance 
difficulty instance class general note implementations percentage held karp bound appears growing possibly log rate doesn happen geometric classes 
turn variants basic lin kernighan involve substantial changes basic design heuristic 
stem cycle variants 
variants differ primarily choice structure lk search 
structure consists cycle path connected vertices described detail chapter 
implementation report results due rego glover heuristic described 
level tree tour representation don look bits 
shall see probably severe running time penalty 
variants random starting tours sclk boruvka starting tours sclk yield roughly comparable tours usually twice fast 
shows relative tour quality performance geometric testbed sclk lk jm 
note consistently close usually 
implementation tours consistently better lk jm wins loses 
normalized running time sclk ranges times slower lk jm city clustered instances times slower city uniform instance largest sclk run 
possible incorporating don look bits implementation gap significant advantage approach basic lin kernighan 
helsgaun variant helsgaun 
variant described offers major innovations 
augmentation step lk search opt move sequential opt move 
keep traveling salesman problem variations percent difference tour lengths number cities sclk vs lk jm uniform points clustered points tsplib instances 
tour quality comparisons rego glover implementation stem cycle variant lin kernighan boruvka starting tours johnson mcgeoch implementation basic lin kernighan 
running time control search levels limited length neighbor lists 
constructed innovative fashion 
going compute estimate bound lagrangean relaxation approach augmented techniques 
yields vector values minimum tree spanning tree plus edge distance function close lower bound held karp bound 
new distance function ff value ff edge fc defined difference length minimum tree required contain fc length minimum unconstrained tree 
vector values ff values edges computed linear space time 
neighbor list consists cities smallest values ff 
initially ordered increasing ff value subsequently dynamically reordered give priority edges shared current best tour predecessor 
addition implementation alternates searching sequential opt augmentations neighborhood searching second neighborhood defined set non sequential moves experimental analysis heuristics stsp number cities helsgaun vs lk jm uniform points clustered points tsplib instances random matrices 
tour quality comparisons helsgaun variant johnson mcgeoch implementation basic lin kernighan 
includes double bridge opt moves specially structured opt moves 
power search strategy implementation needs backtrack level 
starting tours uses special heuristic exploits ff values 
reader interested details heuristic referred helsgaun 
source code helsgaun currently available www dat dk 
tour quality results variant impressive 
see compares helsgaun lk jm 
note helsgaun finds better tours large majority instances testbed usually better uniform tsplib instances large amount context differences lk variants 
difference greater random matrix instances 
detailed averages shown table indicates random matrices helsgaun finds tours essentially optimal 
table reports average running times show helsgaun pays significant running time penalty improved tour quality 
cases helsgaun takes times longer lk jm running time growth rate appears omega gamma versus observed rate lk jm 
certain applications price may worth paying course 
active interesting research traveling salesman problem variations average percent excess hk bound lk jm helsgaun lk jm helsgaun lk jm helsgaun lk jm helsgaun average normalized running time seconds lk jm helsgaun lk jm helsgaun lk jm helsgaun lk jm helsgaun table 
results helsgaun variant lin kernighan compared johnson mcgeoch implementation basic lin kernighan 
stsp heuristics today concerns best large amount computation time help narrow small gap optimal tour length left lin kernighan 
section consider ways buying better tours spending time 

repeated local search heuristics way invest extra computation time exploit fact local improvement heuristics random components initial tour construction 
runs heuristic multiple times get different results take best 
unfortunately noted authors aptly illustrated value straightforward repeated run approach diminishes instance size increases 
effective way repeated runs received wide attention decade 
idea basically independently generated starting tours derive starting tours perturbations output tours previous runs 
idea suggested baum sense implicit operation tabu search approach glover :10.1.1.26.7748
effective realization context tsp due martin otto experimental analysis heuristics stsp felten proposed generating new starting tour perturbing current best tour kick consisting random double bridge opt move 
original implementation opt local search engine quickly upgraded lin kernighan johnson 
underlying lin kernighan opt variant uses don look bits approach additional advantage 
run lin kernighan don look bits typically improving moves choice performing opt move get new starting tour changes tour neighbors cities 
suggests starting don look bits stand run want start don look bits fewer cities place cities initial priority queue candidates practice lead sublinear time iteration data structures handled appropriately loss effectiveness individual iterations 
martin otto felten referred approach chained local optimization view underlying process markov chain 
attempted bias choice opt move better average moves incorporated fixed temperature simulated annealing component heuristic 
results descendants approach submitted challenge differing underlying local search heuristic methods generating double bridge kicks 
variants elaborate kicks studied proved competitive large instances best heuristics 
include current top performers known authors region time quality tradeoff space 
implementations simulated annealing call iterated opt lin kernighan mark fact 

iterated opt johnson mcgeoch opt 
uses opt jm random double bridge kicks 

iterated lin kernighan johnson mcgeoch ilk jm 
uses lk jm bd random double bridge kicks 

iterated lin kernighan neto ilk neto 
uses lk neto random double bridge kicks 

chained lin kernighan applegate bixby chv atal cook clk abcc 
uses lk abcc sophisticated method generating promising kicks described 
traveling salesman problem variations 
chained lin kernighan applegate cook clk acr 
uses lk acr new method generated biased kicks random walks number steps random walk doubling nth iteration 
huge running times helsgaun variant lin kernighan variants chained lin kernighan perform iterations take time helsgaun 
time spare perform repeatedly 
helsgaun devised different way exploiting information previous runs 
kick perturb current champion new starting tour uses standard tour construction heuristic generate new starting tour biases choices edges current champion tour 
gets speedup doesn recompute vector ff values iteration running times remain substantial 
shall refer heuristic helsgaun number iterations 
tables summarize results various repeated run heuristics described 
results ilk neto omitted similarity ilk jm implementation fact results reported complete 
corresponding base implementations ilk jm ilk neto produce similar results ilk neto somewhat slower better random matrices 
tables divided sections class instances challenge testbed 
section heuristics ordered grouped tour quality provide 
grouping somewhat subjective attempts reflect performance instance sizes class 
example clustered instances group clk abcc opt better small worse large groupings carried tour quality table running time table cost effective heuristic group identified 
performance repeated run heuristic naturally depends iterations performed 
practice may simply run iterations handled fixed time limit satisfactory solution reached implementations designed usage mind 
scientific study needs results readily reproducible combinatorial stopping criterion preferred 
bound number iterations function number cities 
typical bounds experimental analysis heuristics stsp indicated suffix heuristic name tables 
comparison purposes tables include results lk jm helsgaun 
observation heuristics table consistently dominated tour quality running time 
running time object iterated versions helsgaun heuristic appear way go 
table include rows optimal solution quality gap held karp bound row helsgaun serves purpose fairly 
average excess optimal solution known testbed instances fewer cities tsplib random matrix instances cities fewer 
helsgaun average excess value cases city tsplib instances optimal excess 
instance challenge testbed known optimal solution helsgaun tour longer optimum 
quality retained iteration version uses substantially time feasibly applied larger instances instances fewer cities helsgaun takes hours normalized running time feasible applications 
variants running time growth rates appear omega gamma worse computers lot faster applied city instances 
basic helsgaun heuristic strong performer classes fall seriously clustered instances probably cost effective compared clk acr uniform tsplib instances 
random matrix instances heuristics come close helsgaun iterated versions running times quite reasonable 
reason solve instances practice optimization considered option 
concorde able solve random matrix instances testbed optimality default settings 
average normalized running times quite reasonable cities normalized optimization time seconds marginally helsgaun 
spectrum consider opt 
poorly random matrix instances finds significantly better tours lk jm classes greater running time balanced fact easier implement heuristics table 
substantially outperforms helsgaun large clustered instances beats traveling salesman problem variations average percent excess hk bound lk jm opt ilk jm clk abcc clk acr ilk jm clk abcc helsgaun helsgaun helsgaun lk jm helsgaun clk abcc opt clk abcc clk acr ilk jm ilk jm helsgaun helsgaun lk jm ilk jm clk abcc clk acr ilk jm clk abcc helsgaun helsgaun helsgaun opt lk jm ilk jm clk abcc clk acr ilk jm clk abcc helsgaun helsgaun helsgaun table 
tour quality results repeated local search heuristics helsgaun lk jm included comparison purposes 
experimental analysis heuristics stsp average normalized running time seconds lk jm opt ilk jm clk abcc clk acr ilk jm clk abcc helsgaun helsgaun helsgaun lk jm helsgaun clk abcc opt clk abcc clk acr ilk jm ilk jm helsgaun helsgaun lk jm opt ilk jm clk abcc clk acr ilk jm clk abcc helsgaun helsgaun helsgaun opt lk jm ilk jm clk abcc clk acr ilk jm clk abcc helsgaun helsgaun helsgaun table 
normalized running times repeated local search heuristics 
column omitted table fit page 
missing entries seconds lk jm seconds clk acr 
traveling salesman problem variations clk abcc smaller ones fairly close ilk jm uniform tsplib instances similar running times large 
looks details runs appear gained providing opt iterations 
average improvements iterations 
appear tour quality achieved ilk jm clk acr clk abcc capabilities opt 
note running time growth rate opt appears indicating don look bits paying asymptotically 
similar effect observed lin kernighan variants faster computers extend range heuristics readily helsgaun repeated run variants 
turning lin kernighan variants see effect fact ilk jm powerful slower lin kernighan engine clk abcc clk acr 
ilk jm performs tenth iterations clk abcc running times roughly comparable 
tour lengths exception clustered instances 
ilk jm finds distinctly better tours possibly longer neighbor lists 
clk acr note clk acr produces distinctly better tours clk abcc uniform class comparable possible results clk acr show better tours ilk jm comparable time 
results ilk jm included table space reasons tend yield average tour length improvement ilk jm geometric classes price times long 
random matrix instances improvement closer 
point simply running iterations may best computation time 
section consider possibilities getting ffl improvement tour quality heuristics chained lin kernighan subroutine 
brief digression follow earlier relation tabu search chained lin kernighan 
tabu search 
simplest form tabu search heuristic operates follows 
local search variants assumes neighborhood structure solutions 
current solution find best neighbor best random sample neighbors subject certain tabu restrictions needed avoid cycling 
goes neighbor improving move 
note effect breaks search alternating phases 
improving moves local optimum apparent local optimum perform kick consisting experimental analysis heuristics stsp uphill moves reach solution descent 
full tabu search heuristic usually complicated various strategies diversification intensification search parameters governing lengths tabu lists aspiration levels see :10.1.1.26.7748
underlying similarity chained local optimization remains 
note case stsp tabu search comes extra overhead local search implementations studied performs improving moves seen tabu search heuristic typically generate sizable collection moves best picked 
partially explains results observed collection tabu search variants submitted challenge implemented dam 
implementations allow possibility different neighborhood structures downhill uphill phases choices opt neighborhood double bridge neighborhood db standard lk search neighborhood lk stem cycle variant called flower sc 
interestingly best tours variants closest chained lin kernighan standard lk search stem cycle variant downhill phase double bridge moves uphill phase lk search variant substantially faster 
unfortunately running times version sufficiently slow totally dominated ilk jm clk acr 
finds better tours averages times faster normalized running time depending instance class size 
details viewed challenge website 
tabu search implementations available speedup tricks highly optimized ilk jm clk acr programming effort bridge gap 

chained lk subroutine just able get improved results lin kernighan subroutine chained lin kernighan consider improving chained lk complicated procedures 
simple possibility chained lk generate starting tours second local search heuristic 
effective chained lk second heuristic probably need neighborhood structure quite different chained lk 
balas proposed candidate 
traveling salesman problem variations balas dynamic programming 
approach starts identifying home city loss generality represents tours ordered sequences cities starting fixed say tour bounded neighbor tour city occur note neighborhood structure tours neighbors edges common 
sharp contrast opt neighborhood structure neighboring tours differ edges 
new neighborhood searched effectively 
linear time dynamic programming algorithm tour finds best bounded neighbor 
running time exponential major problem small algorithm perform steepest descent local search bounded neighborhood structure 
submitted results challenge approach clk abcc generate starting tours 
combination run benchmark instances fewer cities city random matrix instance 
improvements starting tour instances 
larger instances improvements significantly higher rate 
problems nodes improvements starting tour instances instances 
improvements small 
improvements larger larger 
improvement rl 
sense improvement quite substantial reduced optimum 
tiny improvements worthwhile obtained relatively inexpensively case 
added overhead applying algorithm tour output clk abcc minimal ranging total running time increased factor 
approach worthwhile low cost general post processor heuristic especially larger instances appears successful 
code currently available tsp webpage www contrib andrew cmu edu tsp index html 
second heuristic cover uses chained lk generate starting tours sophisticated framework 
multi level approach walshaw 
idea recursively apply chained lk local search heuristic smaller experimental analysis heuristics stsp coalesced instance order generate starting tour full instance 
coalesced instance created matching nearby cities requiring edge included generated tours fixing edge 
instance coalesced fixed edges cities matched degree graph fixed edges endpoints path graph 
note coalesced instance containing fixed path modeled smaller instance path replaced single fixed edge endpoints internal cities deleted 
starting original instance create sequence smaller smaller instances repeatedly applying approach reach instance fewer cities 
having constructed hierarchical decomposition proceed follows assuming base heuristic modified outputs tour containing fixed edges 
start applying heuristic smallest instance created heuristic native starting tour generator 
progress back hierarchy result running heuristic previous instance starting tour current instance 
running base heuristic theta log times runs small instances running time times running base heuristic full instance 
see details including geometry method matching cities coalescing phase 
walshaw submitted results instantiations multi level approach 
lk abcc base heuristic second clk abcc 
base heuristics forced obey fixed edge constraints setting costs required edges large negative value 
discussed previous section 
compete clk abcc average tour quality large instances times faster find better tours significant number clustered instances 
compared lk abcc better tours average geometric classes advantage averaging clustered instances 
obtain significant tour length improvements base heuristic clk abcc uniform instances find better tours half tsplib instances clustered instances 
tours averaged better class 
approaches considered far section needed little twice time running chained lk 
remainder section consider wants better tours willing spend substantially computational resources traveling salesman problem variations get 
currently people willing pay price mainly researchers interested testing ultimate limits heuristic techniques generating better upper bounds unsolved testbed instances active community 
area followed paradigm chained lk subroutine key factor exploited randomization inherent heuristic 
multiple independent runs 
chained lin kernighan randomized heuristic possible randomization starting tour generation kicks randomly generated 
runs times different seeds random number generator get different tours 
fact exploited reaches point added iterations longer helping effective take best iteration runs just performing iteration run take roughly time 
see instances testbeds fewer cities compares best tour length runs clk abcc composite heuristic shall denote clk abcc tour length run clk abcc 
best strategy falls random matrix instances loses instance percent difference tour lengths number cities best iteration runs vs iteration run uniform points clustered points tsplib instances random matrices 
tour quality comparisons best runs clk abcc result single run clk abcc 
experimental analysis heuristics stsp classes wins significant amounts smaller clustered tsplib instances 
note best runs heuristic may gap base heuristic better heuristic 
example walshaw multi level approach clk abcc better clustered instances clk abcc takes time 
furthermore helsgaun variant chained lk just iterations consistently outperforms clk abcc shown 
helsgaun typically faster smaller instances running time grows rapidly time reaches cities times slower best approach 
doesn totally rule value simple approach 
best runs helsgaun interesting competitor helsgaun assuming running time available 
creative approaches exploit randomization involved heuristics 
tour merging applegate bixby chv atal cook 
approach observation tours close optimal share common edges 
takes union edges small set tours typically obtains graph number cities helsgaun vs clk abcc uniform points clustered points tsplib instances random matrices 
tour quality comparisons iteration run helsgaun lk variant best runs clk abcc 
traveling salesman problem variations low branch width graph parameter introduced robertson seymour sense quantifies graph exploited algorithmically follows 
np hard determine precise branch width graph effective heuristics finding near optimal branch width decompositions low branch width graphs 
second dynamic programming algorithm due cook seymour edge weighted hamiltonian graph branch decomposition finds shortest hamiltonian cycle time linear running time exponential quite feasible small values 
typically take results runs chained lk find optimal tour contained union edges 
years technique helped applegate bixby chv atal cook solve previously unsolved tsplib instances 
note approach needn restrict oneself chained lk tours 
applegate typically performed tour merging runs result run tours merged subsequent run 
solution aided improved upper bounds obtained applying tour merging iterated helsgaun tours addition chained lk tours 
tour merging typically hands fashion manual choice tours merged possible run stand manner 
cook submitted results challenge heuristic sort tour merging process applied results runs clk abcc 
runs performed set testbed instance fewer cities 
heuristic successful 
runs random matrix instances combined graph tours low branch width tour merging feasible 
similar failures occurred runs tsplib instances pla runs city uniform instances 
results generated instances attempted substantially better simply best runs clk abcc 
take best tour merging runs composite heuristic shall denote competitive helsgaun heuristic allowed iterations 
compares results helsgaun instances generated tours 
note narrower range differences 
worse produces solution better 
comparison gamma range experimental analysis heuristics stsp 
biggest variation tsplib instances better worse 
normalized running time performing tour merging runs substantially worse run helsgaun typically times slower occasionally 
instances runs aborted high branch width times reported estimated running time failed run average successful runs 
instances successfully run normalized time greater finding optimal solution proving optimality concorde default settings 
cases concorde faster factor 
helsgaun slower concorde optimization instances 
time probably manageable applications 
exception city uniform instances instance cities required hour normalized time slowest city instance took just hours instance optimal solution full optimization concorde default settings far complete terminated days 
number cities vs helsgaun uniform points clustered points tsplib instances random matrices 
tour quality comparisons iteration run helsgaun lk variant best tour merges involving clk abcc tours 
traveling salesman problem variations percent percent instance optimal heuristic instance optimal heuristic pr ib si ib vm pcb ib ib rl ib rl ib fl ib fl ib ib ib vm ib ib rl ib ib ib ib pr ib pcb fl rl rl pla rl usa table 
best results obtained testbed instances optimal solutions known 
heuristics sufficed generate results helsgaun abbreviated table ilk jm best runs ilk jm ib 
heuristic best solution list 
experimental analysis heuristics stsp fact helsgaun beats instances suggests final heuristic getting improved results cost increased running times run take best tour 
better run plus effective heuristics previous section take best tour 
table summarizes approach subset challenge testbed instances optimal solution values known heuristics helsgaun ilk jm ilk jm best runs ilk jm 
running times large instances course huge approach method choice concorde unsuccessful optimizing large number hours days willing spend 
recall table significant subset instances fewer cities concorde default settings took normalized hours succeeded failed geometric instances cities 

research chapter discussed wide variety heuristics occupying positions tradeoff curve tour quality running time 
compared performance wider range instance types sizes previous studies 
order get broad coverage accept compromises appropriate remind reader 
codes cover results include come reports submitted implementers runs variety machines 
discussed section methodology normalizing reported running times necessarily inexact 
second seen places chapter implementations heuristic markedly different running times machine depending data structures coding expertise 
local search heuristics tour lengths differ depending implementation choices 
draw implementation heuristics implemented 
results cover run heuristic instance heuristics incorporate randomization lead noisy data 
reason tried concentrate averages similarly sized instances observable patterns data results particular instances 
time constraints effect forcing concentrate just instance classes emphasis dimensional geo traveling salesman problem variations metric instances type occur practice 
considered detail dependence heuristic performance parameter settings example lengths neighbor lists choice starting tour nature kick chained questions naturally fall domain individual papers heuristics question hope challenge testbeds benchmarks facilitate 
intend provide just detailed experimental analysis bentley johnson mcgeoch implementations discussed forthcoming monograph 
mentioned earlier plan maintain challenge website indefinitely resource standard comparison researchers 
reader take lesson away chapter high level performance attained today existing heuristics publicly available implementations 
second major lesson concerns large extent heuristic performance running time tour quality depend implementation details seen times chapter 
final lesson review wide range trade offs referred 
recall provided illustration section 
section table showed range performance possibilities random uniform geometric instances 
instances heuristics percent excess held karp bound appears approach rough limiting bound typically reached time 
table average results selected heuristics uniform instances size covering wide range behavior 
results instance dependent structured instances tsplib 
put earlier table perspective partially ignoring mentioned proviso drawing detailed single runs individual instances conclude discussion table considers currently largest solved tsplib instance gives percentage excess optimum normalized running time obtained key implementations covered chapter related ones 
abbreviated heuristic names table chapter explained table 
analogous tables instances generated comparisons page challenge website 
acknowledgment 
authors jon bentley gregory rego helpful comments drafts chapter challenge participants participation feedback 
experimental analysis heuristics stsp percent running percent running time time optimal seconds heuristic optimal seconds heuristic opt hyper helsgaun genius helsgaun opt helsgaun opt jm clk abcc opt jm ilk jm opt jm clk abcc opt jm clk abcc hyper geni ilk jm opt jm clk acr opt christo hk ilk neto christo ilk jm ilk jm cca savings ilk jm fi clk acr fa ilk neto ri opt christo lk hk ra tabu sc sc boruvka tabu lk db boruvka lk jm greedy abcc lk jm lk neto ci lk neto lk jm ni tabu sc db na lk jm lk neto nn abcc sclk na sclk karp clk acr lk abcc ra clk acr fa lk acr strip opt jm strip opt jm frp hyper karp opt jm read table 
tour quality normalized running times tsplib instance 
general drawn small differences quality time 
traveling salesman problem variations abbrev short description heuristic approximate christofides jm fq concorde implementation quick boruvka cca golden stewart cca heuristic jm jm implementations convex hull cheapest insertion clk version chained lk iterations christo fs gg christofides heuristic shortcuts jm christo hk christofides held karp trees mst concorde concorde optimization default settings double minimum spanning tree heuristic jm ffi bentley farthest addition augmented frp bentley implementation fast recursive partitioning heuristic gendreau hertz laporte geni heuristic neighbors xg implementation greedy default jm implementation held karp bound computed concorde kg helsgaun heuristic iterations hyper burke cowling implementation opt jm implementation iterated opt iterations ilk version iterated lk iterations karp karp partitioning heuristic maximum subproblem size jm implementation opt jmf pg jm implementation opt quad neighbors clustering heuristic maximum subproblem size jm lk version basic lin kernighan quad neighbors lk xf bdg version basic lin kernighan default neighbor lists bounded depth lk searches default lk hk lin kernighan christo hk starts walshaw implementation multi level iteration chained lk walshaw implementation multi level lin kernighan nfi bentley nearest addition augmented nnf xg implementation nearest neighbor default optimal solution lengths variety sources rfi bentley random addition augmented read time simply read instance standard routines savings jm implementation clarke wright savings heuristic sclk fr bg glover rego implementation stem cycle variant starts implementation spacefilling curve jm implementation strip way strip heuristic tabu dam implementation tabu search neighborhood downhill uphill moves tour merging heuristic abcc applied runs clk abcc table 
abbreviated names chapter 
symbol stands abbreviation implementers names abcc applegate bixby chv atal cook concorde acr applegate cook bentley jm johnson mcgeoch neto neto 
adding suffix bn name means best runs 
applegate 
code provided authors 
applegate bixby chv atal cook 
finding tours tsp 
draft available www math princeton edu tsp 
applegate bixby chv atal cook 
solution traveling salesman problems 
mathematica extra volume icm iii 
release concorde code currently available www math princeton edu tsp concorde html 
applegate cook 
chained lin kernighan large traveling salesman problems 
informs computing appear 
arora 
polynomial time approximation schemes euclidean tsp geometric problems 
journal acm 
preliminary versions proc 
th ieee symp 
foundations computer science proc 
th ieee symp 
foundations computer science 
azar 
lower bounds insertion methods tsp 
combinatorics probability computing 
balas 
linear time dynamic programming algorithms new classes restricted tsps computational study 
informs journal computing 
code currently available www contrib andrew cmu edu tsp index html 
baum 
iterated descent better algorithm local search combinatorial optimization problems 
unpublished manuscript 
hammersley 
shortest path points 
proc 
camb 
philos 
society 
traveling salesman problem variations bellman 
dynamic programming treatment travelling salesman problem 
acm 
bentley 
multidimensional binary search trees associative searching 
acm 
bentley 
trees point sets 
proc 
th ann 
acm symp 
computational geometry pages 
bentley 
fast algorithms geometric traveling salesman problems 
orsa journal computing 
bertsimas grigni 
space filling curve heuristic euclidean traveling salesman problem 
operations research letters 
bock 
algorithm solving traveling salesman related network optimization problems 
unpublished manuscript associated talk th orsa national meeting 
bor ffi 
em probl emu aln im certain minimal problem 
pr ace pr acta 
science 


burke cowling 
embedded local search variable neighborhood search heuristics applied travelling salesman problem 
unpublished manuscript 
christofides 
worst case analysis new heuristic traveling salesman problem 
technical report cs carnegie mellon university 
clarke wright 
scheduling vehicles central depot number delivery points 
operations research 
manzini 
perturbation efficient technique solution large instances euclidean tsp 
informs computing 
cook 
computing minimum weight perfect matchings 
informs computing 
software available www uni bonn de home matching html 
cook seymour 
branch decomposition heuristic tsp 
preparation 
nemhauser 
tight bounds christofides traveling salesman heuristic 
mathematical programming 

method solving traveling salesman problems 
operations research 
crowder 
computational improvements subgradient optimization 
ibm research report rc 
dam 
tabu search geometric traveling salesman problem 
osman kelly editors meta heuristics theory applications pages 
kluwer academic publishers boston 
flood 
traveling salesman problem 
oper 
res 
fredman johnson mcgeoch 
data structures traveling salesmen 
journal algorithms 
frieze 
worst case analysis algorithms travelling salesman problems 
methods operations research 
gendreau hertz laporte 
new insertion procedures traveling salesman problem 
operations research 
glover 
tabu search part orsa computing 
glover 
tabu search part ii 
orsa computing 
glover 
new ejection chain alternating path methods traveling salesman problems 
zenios editors computer science operations research new developments interfaces pages 
pergamon oxford 
glover 
ejection chains structures alternating path methods traveling salesman problems 
discrete applied mathematics 
golden stewart 
empirical analysis heuristics 
rinnooy kan lawler lenstra shmoys editors traveling salesman problem guided tour combinatorial optimization 
wiley chichester 
graham 
efficient algorithm determining convex hull finite planar set 
information processing letters 
hansen 
improvements algorithm symmetric traveling salesman problem 
math 
programming 
traveling salesman problem variations held karp 
traveling salesman problem minimal spanning trees 
operations research 
held karp 
traveling salesman problem minimum spanning trees part ii 
mathematical programming 
helsgaun 
effective implementation lin kernighan traveling salesman heuristic 
european journal operations research 
source code currently available author www dat dk 
hong kahng moon 
improved large step markov chain variants symmetric tsp 
heuristics 

nasty tsp instances farthest insertion 
integer programming combinatorial optimization pages 
mathematical programming society 
johnson 
local optimization traveling salesman problem 
proc 
th colloq 
automata languages programming pages berlin 
lecture notes computer science springer verlag 
johnson bentley mcgeoch rothberg 
near optimal solutions large traveling salesman problems 
monograph preparation 
johnson mcgeoch 
traveling salesman problem case study local optimization 
aarts lenstra editors local search combinatorial optimization pages 
john wiley sons new york 
johnson mcgeoch rothberg 
asymptotic experimental analysis held karp traveling salesman bound 
proc 
th ann 
acm siam symp 
discrete algorithms pages 
karp 
probabilistic analysis partitioning algorithms traveling salesman plane 
mathematics operations research 
karp steele 
probabilistic analysis heuristics 
rinnooy kan lawler lenstra shmoys editors traveling salesman problem guided tour combinatorial optimization 
wiley chichester 
lin 
computer solutions traveling salesman problem 
bell system technical journal 
lin kernighan 
effective heuristic algorithm traveling salesman problem 
operations research 

improved solution traveling salesman problem thousands nodes 
acm 

mak morton 
modified lin kernighan heuristic 
operations research letters 
martin otto felten 
large step markov chains traveling salesman problem 
complex systems 
martin otto felten 
large step markov chains tsp incorporating local search heuristics 
operations research letters 
mitchell 
guillotine subdivisions approximate polygonal subdivisions simple polynomial time approximation scheme geometric tsp mst related problems 
siam journal computing 
neto 
efficient cluster compensation lin kernighan heuristics 
phd thesis department computer science university toronto 
source code currently available www cs toronto edu neto research lk 
ong moore 
worst case analysis travelling salesman heuristics 
operations research letters 

traveling salesman type combinatorial problems relation logistics regional blood banking 
phd thesis department industrial engineering management sciences northwestern university evanston il 
papadimitriou vazirani 
geometric problems related travelling salesman problem 
journal algorithms 
iii 
spacefilling curves planar travelling salesman problem 
acm 
rao smith 
approximating geometric graphs spanners 
proc 
th acm symposium theory computing pages 
rego 
relaxed tours path traveling salesman problem 
european operations research 
reinelt 
tsplib traveling salesman problem library 
orsa journal computing 
traveling salesman problem variations www uni heidelberg de groups software tsplib 
reinelt 
fast heuristics large geometric traveling salesman problems 
orsa journal computing 
reinelt 
travelling salesman computational solutions tsp applications 
springer verlag berlin 
renaud laporte 
fast composite heuristic symmetric traveling salesman problem 
informs computing 
robertson seymour 
graph minors obstructions tree decomposition 
combinatorial theory series 

personal communication 
rosenkrantz stearns lewis ii 
analysis heuristics traveling salesman problem 
siam journal computing 
sleator tarjan 
self adjusting binary search trees 
acm 
walshaw 
multilevel approach travelling salesman problem 
operations research appear 
preliminary version available mathematics research report computing mathematical sciences department university greenwich 
