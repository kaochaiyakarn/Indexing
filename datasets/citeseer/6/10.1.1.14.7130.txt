software practice experience vol 
august transparent process migration design alternatives sprite implementation fred douglis john ousterhout computer science division electrical engineering computer sciences university california berkeley ca summary sprite operating system allows executing processes moved hosts time 
process migration mechanism offload idle machines evict migrated processes idle workstations reclaimed owners 
sprite migration mechanism provides high degree transparency migrated processes users 
idle machines identified eviction invoked automatically daemon processes 
sprite takes milliseconds sparcstation workstations perform remote exec evictions typically occur seconds 
pmake program uses remote invocation invoke tasks concurrently 
compilations commonly obtain speed factors range limited primarily contention centralized resources file servers 
cpu bound tasks simulations effective idle hosts obtaining fold speed period hours 
process migration regular service years 
key words process migration load sharing operating systems distributed systems experience network personal workstations machines typically idle time 
idle hosts represent substantial pool processing power times greater available user personal machine isolation 
years number mechanisms proposed implemented harness idle processors 
implemented process migration sprite operating system purpose description implementation experiences 
process migration mean ability move process execution site time source machine destination target machine architecture 
practice process migration sprite usually occurs particular times 
migration happens part exec system call program initiated 
exec time migration particularly convenient process virtual memory reinitialized exec system call need transferred source target machine 
second common address vrije universiteit dept mathematics computer science de boelelaan 
hv amsterdam netherlands 
internet douglis cs vu nl 
received august john wiley sons revised february douglis ousterhout occurrence migration user returns workstation processes migrated 
time foreign processes automatically evicted back home machines minimize impact returning user interactive response 
sprite process migration mechanism provides unusual degree transparency 
process migration completely invisible processes users 
sprite transparency defined relative home machine process machine process executed migration 
remote process migrated machine home exactly access virtual memory files devices nearly system resources executing home machine 
furthermore process appears users executing home machine process identifier change appears process listings home machine may stopped restarted killed just processes 
obvious sign process migrated load source machine suddenly drops load destination machine suddenly increases 
experimental process migration mechanisms implemented sprite receive extensive practical notable examples locus mosix 
sprite migration facility regular years 
version utility uses process migration automatically compilations different files activities controlled performed concurrently 
speed migration depends number idle machines amount parallelism task performed commonly see speed factors compilations occasionally obtain speed ups high 
environment cent user activity performed processes executing home machine 
designing sprite migration mechanism alternatives available 
choice alternatives consisted trade factors transparency residual dependencies performance complexity 
high degree transparency implies processes users need act differently migration occurs 
migration mechanism leaves residual dependencies known residual host dependencies source machine continue provide services process process migrated away 
residual dependencies generally undesirable affect performance source machine process vulnerable failures source 
performance mean act migration efficient remote processes ideally execute efficiency migrated 
lastly complexity important factor process migration tends affect virtually major piece operating system kernel 
migration mechanism maintainable important limit impact possible 
unfortunately factors conflict 
example highly transparent migration mechanisms complicated cause residual dependencies 
high performance migration mechanisms may transfer processes quickly cost residual dependencies degrade performance remote processes 
practical implementation migration trade offs factors fit needs particular environment 
seen transparent process migration sections emphasized transparency performance accepted residual dependencies situations 
see discussion trade offs migration somewhat different result 
broad spectrum alternatives exists policy decisions determine migrate 
sprite chose semi automatic approach 
system helps identify idle hosts automatically migrate processes eviction 
application programs pmake identify longrunning processes user assistance arrange migrated idle machines 
users return machines system program automatically evicts processes migrated machines 
sprite environment sprite operating system collection personal workstations file servers local area network 
sprite kernel call interface bsd unix sprite implementation new provides high degree network integration 
example hosts network share common high performance file system 
processes may access files devices host sprite allows file data cached network guaranteeing consistency shared access files 
host runs distinct copy sprite kernel kernels closely remote procedure call rpc mechanism similar described birrell nelson 
aspects environment particularly important design sprite process migration facility 
idle hosts plentiful 
environment consists primarily personal machines machines idle time 
example theimer reported third machines typically idle similar environment nichols reported workstations typically idle day environment workstations total measurements show cent tions idle average 
availability idle machines suggests simple algorithms selecting migrate need complex choices partially loaded machines 

users workstations 
user sitting front workstation expects receive full resources workstation 
migration accepted users essential migrated processes degrade interactive response 
suggests machine target migration known idle foreign processes evicted user returns finish 

sprite uses kernel calls 
implementations process migration message passing systems communication process rest world occurs message channels 
systems transparency aspects migration handled simply redirecting message communication follow processes migrate 
contrast sprite processes unix processes system calls forms interprocess communication invoked making protected procedure calls unix registered trademark unix system laboratories douglis ousterhout kernel 
system solution transparency problem obvious worst case kernel call specially coded handle remote processes differently local ones 
consider issue greater depth 

sprite provides network support 
able capitalize existing mechanisms sprite simplify implementation process migration 
example sprite provided remote access files devices single network wide space process identifiers features easier provide transparency migration mechanism 
addition process migration able kernel kernel remote procedure call facility network file system purposes 
sparcstation workstations roughly mips running mbits ethernet minimum round trip latency remote procedure call ms throughput kbytes efficiency migration mechanism attributed efficiency underlying rpc mechanism 
summarize environmental considerations wished offload machines users gone way noticed users returned 
wanted migration mechanism existing sprite kernel structure potential disadvantage kernel calls potential advantages network transparent facilities fast rpc mechanism 
migration 
simpler mechanisms migration available invoking operations machines 
order understand migration useful consider rsh command provides extremely simple form remote invocation bsd versions unix 
rsh takes arguments name machine command causes command executed remote machine 
rsh advantages simple readily available lacks important features transparency eviction performance automatic selection 
process created rsh run environment parent process current directory may different environment variables transmitted remote process systems remote process access files devices parent process 
addition user direct access remote processes created rsh processes appear listings user processes manipulated user logs remote machine 
felt mechanism greater transparency rsh easier 
second problem rsh permit eviction 
process started rsh moved begun execution 
user returns machine rsh generated processes user tolerate degraded response foreign processes complete foreign processes killed causes lost annoyance user owns foreign processes 
nichols butler system terminates foreign processes warning user providing processes opportunity save state nichols noted transparent process migration ability migrate existing processes butler pleasant 
option run foreign processes low priority returning user receives acceptable interactive response slow execution foreign processes 
opportunities annoyance eliminated user jobs offloaded user workstation borrowed evicting foreign processes workstation user returns 
third problem rsh performance 
rsh uses standard network protocols particular kernel support overhead establishing connections checking access permissions establishing execution environment may result delays seconds 
rsh impractical short lived jobs limits speed ups obtained 
final problem rsh requires user pick suitable destination machine offloading 
order offloading convenient possible users decided provide automatic mechanism keep track idle machines select destinations migration 
course unfair comparisons rsh disadvantages eliminated resorting full fledged process migration 
example nichols butler layers automatic selection mechanism top rsh remote execution facility 
remote execution mechanisms including butler preserve current directory environment variables 
unix systems provide checkpoint restart facility permits process terminated recreated different process address space open files 
combination approaches providing remote invocation checkpointing process migration offer significant functionality complexity full fledged process migration facility 
justification process migration remote invocation twofold 
process migration provides additional flexibility system remote invocation lacks 
checkpointing restarting long running process possible especially process interacts processes ultimately user decide process checkpointed 
transparent process migration system need restrict processes load sharing 
secondly migration moderately complicated transparent remote invocation 
complexity remote execution arises processes move conjunction program invocation 
particular remote execution transparent turns shared state distributed shared state difficult manage 
access position file example effect described section transferring open files 
issues maintaining transparency remote execution remain 
permitting process migrate times lifetime requires system transfer additional state process address space significantly complicated 
decided take extreme approach implement migration mechanism allows processes moved time mechanism transparent possible automate selection idle machines 
felt combination features encourage migration 
recognized mechanism probably complex rsh 
result key criteria choosing implementation alternatives simplicity 
douglis ousterhout problem managing state techniques migrate process depend state associated process migrated 
existed thing stateless process migrating process trivial 
reality processes large amounts state amount variety state increasing operating systems evolve 
state complex migration mechanism 
process state typically includes 
virtual memory 
terms bytes greatest amount state associated process memory accesses 
time migrate process limited speed transferring virtual memory 

open files 
process manipulating files devices state associated open channels virtual memory process operating system kernel memory 
state open file includes internal identifier file current access position possibly cached file blocks 
cached file blocks may represent substantial amount storage cases greater process virtual memory 

message channels 
message operating system mach state form exist place open files 
system message channels access files sprite file channels interprocess communication 
state associated message channel includes buffered messages plus information senders receivers 

execution state 
consists information kernel saves restores context switch register values condition codes 

kernel state 
operating systems typically store data associated process process identifier user identifier current working directory signal masks handlers resource usage statistics process parent children 
problem migration maintain process access state migrates 
portion state system things migration transfer state arrange forwarding ignore state sacrifice transparency 
transfer piece state extracted environment source machine transmitted destination machine reinstated process new environment machine 
state private process execution state state transfer relatively straightforward 
state internal kernel state distributed complex data structures may difficult extract reinstate 
example difficult state sprite information open files particularly accessed remote file servers described 
lastly state may impossible transfer 
state usually associated physical devices source machine 
example frame buffer associated display remain machine containing display process access frame buffer migrates possible transfer frame buffer 
second option piece state arrange forwarding 
transfer state stay process system may leave state forward operations back forth state process 
example devices transferred operating system arrange transparent process migration output requests passed back process device input data forwarded device machine process 
case message channels arranging forwarding consist changing sender receiver addresses messages channel find way process 
ideally forwarding implemented transparent obvious outside operating system state transferred forwarding arranged 
third option sacrificing transparency resort state transfer forwarding feasible ignore state source machine simply corresponding state target machine 
situation sprite state transfer forwarding reasonable devices frame buffers alluded 
current implementation disallow migration processes devices 
rare cases lack transparency may desirable 
example process requests amount physical memory available obtain information current host home machine 
sprite specialpurpose kernel calls read instrumentation counters kernel intentionally non transparent respect migration 
general unfortunate process behaved differently migration 
surface appear message systems accent charlotte simplify state management problems 
systems process interactions rest world occur uniform fashion message channels 
basic execution state process migrated remaining issues solved simply forwarding messages process message channels 
message forwarding done uniform fashion independent servers communicated state migrated process 
contrast state management difficult system sprite kernel calls 
system process services provided kernel machine process executes 
requires state service transferred migration 
state service different approach complicated uniform message forwarding approach 
turns initial impressions correct 
example possible implement forwarding kernel call system leaving kernel state home machine remote procedure call forward home kernel call 
result similar forwarding messages initially approach sprite 
unfortunately approach entirely forwarding kernel calls forwarding messages practice reasons 
problem services necessarily provided machine process executing 
process invokes kernel call allocate virtual memory sends message memory server allocate virtual memory request processed kernel server machine process executes kernel server control machine page tables 
forwarding viable option machine specific functions state operations migrated processes 
second problem forwarding cost 
expensive forward operation machine douglis ousterhout process locally 
service available locally migrated process new machine efficient local service forward operations back service process old machine 
practice systems transfer substantial amounts state part process migration 
message systems migration somewhat easier kernel call systems state maintained kernel kernel call system maintained process address space system 
state transferred implicitly address space process 
state types system address issues 
mechanics migration section describes sprite deals various components process state migration 
solution component consists combination transferring state arranging forwarding 
virtual memory transfer virtual memory transfer aspect migration discussed literature generally believed limiting factor speed migration 
simple method transferring virtual memory send process entire memory image target machine migration time charlotte locus 
approach simple disadvantages 
transfer take seconds time process frozen execute source destination machine 
processes particularly real time needs long freeze times may unacceptable 
second disadvantage monolithic virtual memory transfer may result wasted portions virtual memory process migrates 
extra particularly unfortunate costly requires old pages read secondary storage 
reasons approaches reduce overhead virtual memory transfer mechanisms described paragraphs 
system long freeze times resulted time outs processes trying communicate migrating process 
address problem theimer method called pre copying 
freezing process migration allows process continue executing address space transferred 
original implementation migration entire memory process transferred directly target theimer proposed implementation virtual memory write modified pages shared backing storage server network 
case pages modified source machine copied freezes process copies pages modified 
theimer showed reduces freeze times substantially 
disadvantage copying pages twice increases total amount migrate process 
pre copying useful environment processes real time response requirements 
accent system uses lazy copying approach reduce cost process migration 
process migrates accent virtual memory pages left transparent process migration time locus charlotte accent sprite source target source target source target file server source target process executes residual transfer virtual memory 
different techniques transferring virtual memory 
shows scheme locus charlotte entire address space copied time process migrates 
shows scheme virtual memory transferred migration process continues execute transfer 
shows accent lazy copying approach pages retrieved source machine referenced target 
residual dependencies accent life migrated process 
shows sprite approach dirty pages flushed file server migration target retrieves pages file server referenced 
case eviction residual dependencies source migration 
process migrates away home machine residual dependencies home lifetime source machine referenced target machine 
pages copied target referenced time 
approach allows process execution target minimal freeze time introduces short delays pages retrieved source machine 
lazy copying reduces cost migration pages copied 
typical programs half process allocated memory needed transferred 
disadvantage lazy copying leaves residual dependencies source machine source store unreferenced pages provide demand target 
worst case process migrates times leave virtual memory dependencies hosts executed 
sprite migration facility uses different form lazy copying takes advantage existing network services providing advantages lazy douglis ousterhout copying 
sprite proposed implementation backing storage virtual memory implemented ordinary files 
backing files stored network file system accessible network 
migration source machine freezes process flushes dirty pages backing files discards address space 
target machine process starts executing resident pages uses standard paging mechanisms load pages backing files needed 
cases disk operations required flush dirty pages sprite 
backing files stored network file servers file servers memories cache file data 
source machine flushes dirty page simply transferred network server main memory file cache 
destination machine accesses page retrieved cache 
disk operations occur server cache overflows 
sprite virtual memory transfer mechanism simple implement uses pre existing mechanisms flushing dirty pages source handling page faults target 
benefits accent approach dirty pages incur overhead migration time pages sent target machine referenced 
approach require total accent dirty pages may transferred network twice file server flushing destination machine 
sprite approach virtual memory transfer fits way migration typically sprite 
process migration occurs exec system call completely replaces process address space 
migration occurs exec new address space created destination machine virtual memory transfer 
observed locus performance virtual memory transfer exec time migration issue 
virtual memory transfer issue migration evict process machine user returned 
situation important consideration remove process source machine quickly order minimize performance degradation returning user 
sprite approach works regard possible free source memory source need retain pages respond paging requests accent 
efficient transfer dirty pages directly target machine file server approach added complexity migration mechanism decided 
virtual memory transfer complicated process migrated sharing writable virtual memory process source machine 
principle possible maintain shared virtual memory sharing processes migrates changes cost shared accesses dramatically unreasonable 
shared writable virtual memory occurs sprite right simply disallow migration processes 
better long term solution probably migrate sharing processes may impractical complex patterns sharing involve processes 
migrating open files transparent process migration turned particularly difficult sprite migrate state associated open files 
surprising sprite provided highly transparent network file system supports remote access files devices allows files cached accessed concurrently different workstations 
expected migration file related information matter reusing existing mechanisms 
unfortunately process migration introduced new problems managing distributed state open files 
migration possible file current access position shared machines 
migration mechanism simpler chosen arrange forwarding approach open files transfer state approach 
implied file related kernel calls forwarded back machine file opened state associated file stayed machine 
frequency file related kernel calls cost forwarding kernel call network felt approach unacceptable slow remote process load machine stores file state 
sprite workstations typically diskless files accessed remotely file servers forwarding approach meant file request passed network machine file opened possibly second time server 
decided transfer open file state migrating process normal mechanisms access file communicate directly file server 
main components state associated open file file caching information access position 
components introduced problems migration 
file indicates file stored provides guarantee file exists required unix semantics file deleted open deletion deferred file closed 
attempt migrating files simply closed file source machine target 
unfortunately approach caused files disappear deleted reopen completed 
common occurrence unix programs file transfer changed move source target closing file 
second component state open file caching information 
sprite permits data file cached memory machines file servers responsible guaranteeing consistent access cached data 
server file keeps track hosts file open reading writing 
file open host writing caching disabled hosts forward read write requests file server serialized 
second attempt migrating files server notified file target machine told file longer source file appear write shared caused server disable caching file unnecessarily 
solve problem problem built special server code just migrating files transfer source destination atomically 
migration cause caching disabled file douglis ousterhout file process source machine migrating process file cacheable target machine 
current implementation caching disabled file remains disabled process file open processes accessing file migrate machine practice caching disabled infrequently optimization re enable caching uncacheable files high priority 
open file transferred migration file cache source machine may contain modified blocks file 
blocks flushed file server machine migration migration target machine retrieve blocks file server involving source 
approach similar mechanism virtual memory transfer advantages disadvantages 
similar happens sprite shared file access migration file opened modified closed machine opened machine modified blocks flushed machine cache server time second open 
third component state open file access position indicates file read write operation occur 
unfortunately access position file may shared processes 
happens example process opens file forks child process child inherits open file access position 
normal circumstances processes sharing single access position reside machine migration move processes access position shared machines 
false starts eventually dealt problem fashion similar caching access position shared machines machine stores access position cache file file server maintains access position operations file forwarded server 
possible approach shared file offsets locus 
process migration causes file access position shared machines locus lets sharing machines take turns managing access position 
order perform file shared access position machine acquire access position token file 
machine access position token caches access position machine may access file 
token rotates machines needed give machine access file turn 
approach similar approach locus uses managing shared file clients take turns caching file pass read write tokens ensure cache consistency 
chose locus approach token passing approach complex disable caching approach disable caching approach meshed better existing sprite file system 
shows mechanism currently sprite migrating open files 
key part mechanism occurs late phase migration target machine requests server update internal tables reflect file target source 
server turn calls source machine retrieve information file file access position file processes source machine 
level remote procedure call synchronizes machines source target server provides convenient point updating state open file 
transparent process migration network 
transferring open files 
source passes information open files target file target notifies server open file moved call server communicates source release state associated file obtain state associated file process control block aside virtual memory open files main remaining issue deal process control block pcb migrating process left source machine transferred migrating process 
sprite combination approaches 
home machine process execute migration assist operations process maintains pcb process 
details interaction described section 
addition current machine process pcb 
process migrated information process kept pcb current machine pcb home machine serves primarily locate process fields unused 
elements process state virtual memory open files easier transfer virtual memory open files bulky virtual memory involve distributed state open files 
state consists entirely fields process control block 
general needs done transfer fields target machine reinstate process control block target 
supporting transparency home machines mentioned previously transparency important goals implementing migration 
transparency mean things particular 
process behaviour affected migration 
execution environment appear access system resources files devices produce exactly results migrated 
secondly process appearance rest world affected migration 
rest world process appear left original machine operation possible process stopping signaling possible migrated process 
douglis ousterhout sprite provides forms transparency know implementation process migration provides transparency degree 
sprite aspects transparency defined respect process home machine machine execute migration 
migration appear process executing home machine 
order achieve transparency sprite uses different techniques described paragraphs 
desirable approach kernel calls location independent sprite gradually evolving direction 
example early versions system permitted different machines different views file system name space 
required open kernel calls forwarded home migration imposing cent penalty performance remote compilations 
order simplify migration reasons changed file system machine network sees name space 
open kernel call location independent extra effort necessary open transparently remote processes 
second technique transfer state source machine target migration time described normal kernel calls may migration 
state transfer approach virtual memory open files process user identifiers resource usage statistics variety things 
third technique forward kernel calls home 
technique originally large number kernel calls gradually replaced uses forwarding transparency state transfer 
kernel calls implemented transparently easily transfer state 
example clocks synchronized sprite machines remote processes sprite forwards gettimeofday kernel call back home machine 
guarantees time advances monotonically remote processes incurs performance penalty processes read time frequently 
example kernel call obtains state process group process 
home machine maintains state groups collections processes may physically execute different machines 
forwarding occurs home machine remote process current machine 
example process signalled process specifies identifier kill kernel call signal operation sent initially process home machine 
process executing home machine home machine forwards operation process current machine 
performance operations improved retaining cache machine process identifiers known execution sites 
approach locus allows operations sent directly remote process passing host 
incorrect execution site detected time correct information sending message host process created locus multi casting 
fourth approach really just set ad hoc techniques kernel calls update state process current execution site home machine 
example kernel call fork creates new process 
process identifiers sprite consist home machine identifier index transparent process migration process machine 
management process identifiers including allocation deallocation responsibility home machines named identifiers 
remote process forks child process home machine parent requires home machine allocate new process identifier 
furthermore home machine initialize copy process control block process described previously 
child process execute remotely machine parent current machine home machine update state 
similar kinds operation occur exit invoked process terminate wait parent wait children terminate 
potential race conditions process exiting parent waiting exit processes migrating easier synchronize operations keeping state wait exit rendezvous single machine home 
locus similarly uses site process created synchronize operations process 
residual dependencies define residual dependency ongoing need host maintain data structures provide functionality process process migrates away host 
example residual dependency occurs accent process virtual memory pages left source machine referenced target 
example occurs sprite home machine participate remote process forks exits 
residual dependencies undesirable reasons reliability performance complexity 
residual dependencies decrease reliability allowing failure host affect processes hosts 
residual dependencies decrease performance remote process require remote operations local ones sufficed 
residual dependencies add load host depended reducing performance processes executing host 
lastly residual dependencies complicate system distributing process state network concentrating single host particularly bad scenario process migrate times leaving residual dependencies host visited 
despite disadvantages residual dependencies may impractical eliminate 
cases dependencies inherent process device specific host dependencies eliminated changing behaviour process 
cases dependencies necessary convenient maintain transparency home machine knowing process creations terminations 
lastly residual dependencies may improve performance cases lazy copying accent deferring state transfer absolutely necessary 
sprite concerned transparency reliability permitted residual dependencies home machine dependencies easier implement transparency 
described section transparency situations home machine participate performance impact minimal 
measurements overhead remote execution reported 
sprite permits residual dependencies home machine douglis ousterhout leave dependencies machines 
process migrates machine evicted migrates away reason residual dependencies machine 
provides assurance process migration affect users response return workstations 
noticeable long term effect foreign processes resources may execution particular user virtual memory working set may demand paged back memory user return 
greatest drawback residual dependencies home machine inability users migrate processes order survive failure home machine 
considering non transparent variant process migration change home machine process migrates break dependencies previous host 
migration policies focused discussion mechanisms transferring processes supporting remote execution 
section considers policies determine migration 
migration policy decisions fall categories 

processes migrated 
processes considered candidates migration particularly cpu intensive processes 
cpu intensive processes identified 


processes migrated time initiated may processes migrated running 


criteria select machines targets migration 


decisions 
decided user automated system software 
policy spectrum lies pool processors model 
model processors system treated shared pool decisions automatically system software 
users submit jobs system idea execute 
system assigns jobs processors dynamically process migration available may move processes execution balance loads processors pool 
mosix example pool processors model processors shared equally processes system dynamically balances load system process migration 
policy spectrum lies rsh provides policy support whatsoever 
model individual users responsible locating idle machines negotiating users machines deciding processes offload 
sprite chose intermediate approach selection idle hosts fully automated policy decisions partially automated 
reasons decision 
environment consists personal workstations 
users happy running processes locally personal workstations expect complete control workstations 
users think workstations shared 
secondly dynamic pool processors approach appeared involve considerable transparent process migration additional complexity convinced benefits justify implementation difficulties 
example processes unix environment short lived migration produce noticeable benefit may slow things 
eager provide additional evidence migration useful particular conditions 
sprite decided migration special case normal case 
sprite kernels provide particular support migration policy decisions user level applications provide assistance forms idle host selection pmake program mig shell command eviction 
discussed subsections 
selecting idle hosts sprite machine runs background process called load average daemon monitors usage machine 
workstation appears idle load average daemon notifies central migration server machine ready accept migrated processes 
programs invoke migration pmake mig described call standard library procedure mig obtain identifiers idle hosts pass kernel invoke migration 
normally process may assigned host time order avoid contention processor time processes request idle hosts indicate executing long running processes central server permit shorter tasks execute hosts 
maintaining database idle hosts challenging problem distributed system particularly system large size shared facilities available storing load information 
number distributed algorithms proposed solve problem disseminating load information hosts periodically querying hosts random find idle multicasting accepting response host indicates availability 
sprite centralized approaches storing idle host database 
centralized techniques generally simpler permit better decisions keeping information date single place scale systems hundreds workstations contention problems centralized database 
initially stored database single file file system 
load average daemons set flags file hosts idle mig hosts library procedure selected idle hosts random file marking selected hosts select 
standard file locking primitives synchronize access file 
switched server approach single server process keeps database virtual memory 
load average daemons mig procedure communicate server message protocol 
server approach number advantages file approach 
efficient single remote operation required select idle machine file approach required remote operations open file lock read server approach easy retain state request request example provide fair allocation idle hosts users idle machines 
features implemented shared file incur high douglis ousterhout overhead repeated communication file server 
lastly server approach provides better protection database information shared file approach file readable writable users 
initially chose conservative set criteria determining machine idle 
load average daemon originally considered host idle keyboard mouse input minutes fewer runnable processes processors average 
choosing criteria wanted certain inconvenience active users delay background processes left running 
assumed usually plenty idle machines go concerned efficiently 
experience minute threshold reduced threshold input seconds increased pool available machines noticeable impact owners machines 
pmake mig sprite provides convenient ways migration 
common process migration pmake program 
pmake similar function unix utility example detect source files changed recompile corresponding object files 
performs compilations actions serially contrast pmake uses process migration invoke commands parallel idle hosts available 
process migration completely transparent users results substantial speed ups situations shown 
systems sprite benefitted parallel facilities see examples 
approach pmake advantage fully automatic processor pool approach migration decisions centrally 
pmake choice processes offload knows hosts available scale parallelism match number idle hosts 
offloading choice agent pmake overload system creating processes accommodated efficiently 
pmake provides degree flexibility permitting user specify certain tasks offloaded poorly suited remote execution 
second easy way migration program called mig takes argument shell command 
mig select idle machine mechanism described process migration execute command machine 
mig may migrate existing process 
eviction final form system support migration eviction 
load average daemons detect user returns 
keystroke mouse motion invoked user load average daemon check foreign processes evict 
eviction occurs foreign processes migrated back home machines process obtained host host reclaimed 
process free evicted processes suspend new host available 
date pmake application automatically processes applications mig processes 
transparent process migration evictions occur host reclaimed process order allocate 
centralized server receives request idle host idle hosts available process allocated fair share hosts server reclaims hosts process 
host process received fair share 
process lost host reduce parallelism obtain additional hosts 
possible optimization evictions permit evicted process migrate directly new idle host home machine 
practice half evictions occur system take place due fairness considerations user returned idle workstation 
permitting direct migration remote hosts benefit half evictions occur complicate implementation require way communication remote hosts home machine knows processes execute 
far optimization warranted 
performance usage patterns evaluated process migration sprite sets measurements 
subsections discuss particular operations isolation time migrate trivial process invoke remote command performance improvement pmake parallel remote execution empirical measurements sprite process migration facility period weeks including extent migration cost frequency eviction availability idle hosts 
migration overhead table summarizes costs associated migration 
host selection sparcstation workstations takes average ms process transfer function fixed overhead plus variable overhead proportion number modified virtual memory pages file blocks copied network number files process open 
process time migration normally case virtual memory transferred 
costs table reflect latency bandwidth sprite remote procedure call mechanism 
example cost transferring open files dominated rpc latency rpcs ms latency speed transferring virtual memory pages file blocks determined rpc bandwidth kbytes 
things considered takes tenth second select idle host start new process counting time needed transfer open files flush modified file blocks servers 
empirically average time perform exec time migration system ms latency may great warrant running trivial programs remotely substantially time needed compile typical source programs run text formatters number cpu bound tasks 
process migrates away home machine may suffer overhead forwarding system calls 
degradation due remote execution depends ratio location dependent system calls operations douglis ousterhout table costs associated process migration 
measurements performed sparcstation workstations 
host selection may amortized migrations applications pmake reuse idle hosts 
time migrate process depends open files process modified blocks tiles cached locally flushed server 
migration done exec time modified virtual memory pages flushed 
done exec time process arguments environment variables transferred 
performed open files 
bandwidth rpc system kbytes single channel kbytes multiple rpc connections parallel virtual memory system action select release idle host migrate null process transfer info open files flush modified file blocks flush modified pages transfer exec arguments fork exec null process migration wait child exit fork exec null process locally wait child exit ms time rate ms ins tile kbytes kbytes kbytes ms ms computation file shows total execution time run programs listed table ii entirely locally entirely single remote host 
applications communicate frequently home machine suffered considerable degradation 
benchmarks fork contrived examples type degradation process experience performed location dependent system calls user level computation 
rcp benchmark realistic example penalties processes encounter copies data tcp tcp operations sent user level tcp server home machine 
forwarding tcp operations causes rcp perform cent slowly run remotely locally 
may seen applications compilations text formatting show little degradation due remote execution 
application performance benchmarks previous section measured component costs migration 
section measures benefits migration pmake 
measured performance improvements obtained parallel compilations simulations 
benchmark consists compiling sprite kernel source files linking resulting object files single file 
pmake command compiling linking performed remote host exec time migration 
host obtained pool available hosts reused pmake finishes host longer available 
shows total elapsed time compile link sprite kernel varying number machines parallel performance improvement obtained 
environment pmake able effective host uses point hosts uses half processing power available additional hosts 
transparent process migration 
comparison local remote execution programs 
elapsed time execute cpu intensive file intensive applications pmake latex showed negligible effects remote execution cent degradation respectively 
applications suffered performance penalties ranging cent rcp cent fork cent table ii 
workload comparisons local remote execution name description pmake recompile pmake source sequentially pmake latex run latex draft article rcp copy mbyte file host tcp fork fork wait child times get time day times compile link curve shows speed factor hosts 
clearly significant difference speed ups obtained normalized compile benchmark compile link benchmark 
difference partly attributable sequential parts running pmake determining file dependencies linking object files done single host 
importantly file caching affects speed substantially 
described host opens file host caching modified blocks host modified blocks transfers server stores file 
pmake uses hosts compile different files parallel single host links resulting object files host wait hosts flush object files created 
obtain object files server 
case linking files created single host takes link step takes multiple hosts compilations 
douglis ousterhout 
performance recompiling sprite kernel varying number hosts pmake program 
graph shows time compile input files link resulting object files single file 
addition shows normalized curve shows time taken compilation pmake start overhead determine dependencies curve represents portion pmake benchmark 
graph shows speed obtained point ratio time taken single host time multiple hosts parallel practice obtain speed indicated benchmark compile link kernel module separately link modules 
link step additional synchronization point may performed host time 
development environment typically see times speed rebuilding kernel scratch 
table iii presents examples typical pmake speed ups 
times representative performance improvements seen day day 
shows corresponding speed curves set compilations number hosts varies 
case marginal improvement additional hosts decreases hosts added 
speed curves show marginal improvement additional hosts significantly processing power hosts suggest 
poor improvement due bottlenecks file server workstation running pmake 
shows utilization processors file server client workstation intervals way kernel pmake 
shows pmake process uses nearly cent sparcstation processor determines dependencies starts migrate processes perform compilations 
sun file server processor bottleneck hosts performing compilations open files write back cached object files 
network utilization shown averaged cent problem 
server client processors get faster network may easily bottleneck 
migration sprite perform compilations nearly years wide ranging applications 
excluding transparent process migration 
speed compilations variable number hosts 
graph shows speed relative running pmake host migration 
speed obtained depends extent hosts kept busy amount parallelization available pmake system bottlenecks table iii 
examples pmake performance 
sequential execution done single host parallel execution uses migration execute tasks parallel 
measurement gives time compile indicated number files link resulting object files steps 
multiple steps required sequentiality reduces speed may obtained pmake example organized directories compiled linked separately linked object files linked program number sequential time parallel time files links speed gremlin tex pmake kernel compilations simulations primary application sprite process migration facility 
common users pmake run simulations letting pmake control parallelism 
length parallelism simulations results frequent evictions occur compilations pmake automatically suspends processes subsequent eviction 
addition having longer average execution time simulations differ compilations file system 
simulators quite intensive completely limited processor time 
perform minimal interaction file servers little network bandwidth scale better parallel compilations 
set simulations obtained cent effective processor utilization minutes processing time minute elapsed time course hour idle hosts system hosts architecture 
douglis ousterhout 
processor network utilization way pmake 
file server client workstation running pmake saturated usage patterns instrumented sprite keep track remote execution migrations evictions availability idle hosts 
process exited total time executed added global counter process executing remotely time added separate counter 
counters excluded long running processes exit host rebooted processes daemons display servers processes normally unsuitable migration 
typical month period remote processes accounted cent processing done sprite 
host ran applications greater remote execution executing cent user cycles hosts 
table iv lists sample processor usage period 
time frame recorded frequency exec time migrations full migrations order determine common usage migration facility 
full migrations require virtual memory copied choice virtual memory transfer method important full migrations occurred relatively 
month period studied exec time migrations occurred rate hour host period constituting cent migrations 
transparent process migration table iv 
remote processing month period 
hosts greatest total processor usage shown individually 
sprite hosts performed roughly cent user activity process migration 
standard deviation fraction remote cent host total cpu time remote cpu time fraction remote garlic sees sees buzz sage total secondly recorded time host changed idle active indicating foreign processes evicted exist counted number times evictions occurred 
date evictions extremely rare 
average host changed active state rein transitions resulted processes evicted processes hour host collection hosts 
evictions due primarily policy allocating hosts hosts assigned decreasing order idle time hosts idle longest migration 
average time hosts idle prior allocated remote execution average idle time hosts evicted processes min 
may assume hosts allocated randomly order idle time evictions considerably frequent 
evictions occur time needed evict varied considerably mean standard deviation migrate average processes 
average kbyte pages written process migrated standard deviation host host 
thirdly course year periodically recorded state host active idle hosting foreign processes log file 
surprisingly large number cent hosts available migration time day weekdays 
partly due environment users sun decstation time 
workstations available public regular basis 
discounting extra workstations find sizable fraction hosts available theimer nichols 
table summarizes availability hosts sprite period 
study availability idle hosts recorded information requests idle hosts day period 
period processes requested idle hosts cent processes obtained hosts requested 
cent processes unable obtain douglis ousterhout table host availability cent 
weekdays monday friday 
times time frame idle migration weekdays hours total hosts 
processes requested average hosts standard deviation hosts cent processes requesting host time 
typically idle machines available machine type expect processes request hosts able obtain interestingly cent hosts requesting hosts able obtain hosts 
shows fraction processes period received hosts requested cumulative function number hosts requested 
observations experience observed charlotte accent 
improvement idle hosts substantial depending degree parallelism application 

remote execution currently accounts sizeable fraction processing sprite 
idle hosts plentiful 
idle hosts currently limited lack applications pmake lack hosts 

cost exec time migration high comparison cost local process creation relatively small compared times noticeable humans 
furthermore overhead providing transparent remote execution sprite negligible classes processes 
system may liberal placing processes hosts exec time long likelihood eviction relatively low 

cost transferring process address space flushing modified file blocks dominates cost migrating long running processes limiting effectiveness dynamic pool processors approach 
environments approach favorable aspects assumptions host availability workstation ownership process migration balance load sprite hosts unnecessary undesirable 
history experience greatest lesson learned experience process migration old adage lose 
experimental version migration transparent process migration 
distribution host requests satisfaction rates 
number hosts shown axis line labelled requesting shows fraction processes requested hosts 
line labelled satisfied shows processes requested number hosts fraction processes successfully obtained hosts 
cent processes able obtain host cent processes requested hosts obtained hosts 
cent processes requested host operational took years migration useful utility 
part problem important mechanisms implemented initially automatic host selection migration integrated pmake process migration deal gracefully machine crashes 
main problem migration continually broke due changes sprite kernel 
regular problems migration noticed tended accumulate 
result migration occasional experiments 
experiment major effort required fix accumulated problems migration quickly broke experiment finished 
autumn suspect migration fragile maintainable 
abandoning decided push process migration completely usable integrate pmake program long understand benefits drawbacks 
fortunate decision 
week migration available pmake members sprite project happily achieving speed factors compilations 
complex interactions rest kernel migration fragile occasionally breaks response changes kernel 
frequently problems detected immediately usually fixed quickly 
maintenance load higher migration parts kernel slightly 
today consider migration indispensable part sprite system 
ones difficulties keeping process migration running example theimer reported similar experiences implementation douglis ousterhout problem inherent migration interacts parts kernel 
sprite complicated aspects migration related migrating open files 
particular locking updating data structures open file multiple hosts provided numerous opportunities distributed deadlocks race conditions inconsistent counts 
worth problems chosen implement simpler remote invocation facility process migration 
process migration taken granted essential part sprite system 
hundreds times daily provides substantial speed ups applications amenable coarse grain parallel processing compilation simulation 
transparency provided migration mechanism easy migration eviction keeps migration bothering people machines borrowed 
collectively remote execution accounts sizable portion user activity sprite 
originally conservative migration order gain acceptance users 
time passed users accustomed workstations migration gained confidence eviction mechanism 
gradually liberal idle machines experimenting new system wide migration tools command shells automatically migrate tasks jobs run background 
far users appreciated additional opportunities migration perceived degradation interactive response 
outset expected migration difficult build maintain 
surprised complexity interactions process migration rest kernel particularly distributed state involved open files 
interesting sprite network file system simplified migration providing transparent remote access files devices complicated file system complex distributed state 
believe implementation reached stable maintainable state taken long time get 
bottom line process migration useful pass 
encourage process migration available systems beware implementation pitfalls 
addition acting guinea pigs early unstable implementations process migration members sprite project significant contributions sprite process migration facility 
mike nelson brent welch implemented mechanism migrating open files adam de boor wrote pmake program 
lisa thorsten von eicken john hartman darrell long mendel rosenblum ken shirriff provided comments early drafts improved presentation substantially 
grateful anonymous referees software practice experience provided valuable feedback suggestions 
course errors article responsibility 
supported part defense advanced research projects transparent process migration agency contract part national science foundation ecs 

nichols idle workstations shared computing environment proceedings eleventh acm symposium operating systems principles acm austin tx november pp 


roberts ellis dp experience distributed parallel implementation proceedings second workshop grained parallelism software engineering institute carnegie mellon university november report cmu sei sr 

theimer cheriton preemptable remote execution facilities system proceedings th symposium operating system principles december pp 


attacking process migration bottleneck proceedings eleventh acm symposium operating systems principles austin tx november pp 


popek walker eds locus distributed system architecture computer systems series mit press 

barak wheeler flood prevention mosix load balancing scheme ieee computer society technical committee operating systems newsletter 

feldman program maintaining computer programs software practice experience 

theimer preemptable remote execution facilities loosely coupled distributed systems ph thesis stanford university 

finkel designing process migration facility charlotte experience ieee computer 

ousterhout douglis nelson welch sprite network operating system ieee computer 

nelson welch ousterhout caching sprite network file system acm transactions computer systems 

birrell nelson implementing remote procedure calls acm transactions computer systems 

computer science division university california berkeley unix user manual berkeley software distribution virtual vax version april 

litzkow remote unix proceedings usenix summer conference june 

accetta baron bolosky golub rashid tevanian young mach new kernel foundation unix development proceedings usenix summer conference july 

cheriton distributed system communications acm 

copy process migration system ph thesis carnegie mellon university pittsburgh pa april 
report 
cmu cs 

li hudak memory coherence shared virtual memory systems proceedings th acm symposium principles distributed computing acm august pp 


eager lazowska zahorjan limited performance benefits migrating active processes load sharing acm sigmetrics may 

eager lazowska zahorjan adaptive load sharing homogeneous distributed systems ieee trans 
software engineering se 

parallel distributed compilations loosely coupled systems case study proceedings workshop large grain parallelism providence ri october 

douglis transparent process migration sprite operating system ph thesis university california berkeley ca september 
available technical report ucb csd 

douglis ousterhout process migration sprite operating system proceedings th international conference distributed computing systems ieee berlin west germany september pp 

