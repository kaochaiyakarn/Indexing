component replication distributed systems case study enterprise java beans graham morgan santosh shrivastava school computing science newcastle university newcastle tyne uk graham morgan santosh shrivastava newcastle ac uk trend seen extension objectoriented middleware component oriented middleware 
major advantage components offer objects business logic application needs addressed programmer support services required incorporated application deployment time 
achieved components business logic application containers host components responsible providing underlying middleware services required components application servers host containers 
known examples component middleware architectures enterprise java beans ejbs corba component model ccm 
services available deployment time component architectures component persistence atomic transactions 
examines ejbs replication availability supported containers components transparently persistence transactions highly available 
keywords availability components corba component model enterprise java beans fault tolerance middleware replication transactions 
modern client server distributed computing systems may seen implementations tier architecture 
typical tier architecture tier client tier consists client applications containing browsers remaining tiers deployed enterprise representing server side second tier web tier consists web server receives client requests typically passes requests specific applications residing third tier business tier capable hosting distributed applications fourth tier mark little technologies newcastle tyne uk mark little com enterprise information systems tier contains databases legacy applications enterprise 
platform providing web tier plus business tier usually called application server 
application server typically deploys variety object oriented middleware services object request broker orb provides applications higher level abstraction component oriented middleware 
worth examining briefly higher level abstraction considered necessary 
object oriented middleware provides type checked remote invocations standard ways commonly required services naming persistence transactions problem remains application developers worry application logic technically complex ways collection services 
example transactions distributed objects requires concurrency control persistence transaction services particularly intricate manner 
component oriented middleware alleviates difficulty components composed objects containers host component instances 
containers take responsibility underlying middleware services communication persistence transactions security forth developer task simplified specifying services required components declarative manner 
major advantage components offer objects business logic application encoded components needs addressed developer 
wellknown examples component middleware architectures include enterprise java beans ejbs corba component model ccm 
investigate software implemented fault tolerance techniques applied support component replication high availability 
take specific case ejb components consider strict consistency requires states available copies replicas kept mutually consistent 
take ejbs primarily extensively industry open source implementations application servers ejbs available experimentation 
believe ideas interest general case component middleware 
particular ejbs closely related language independent ccm ideas applied world corba components 
data object replication techniques studied extensively literature task invent new replication techniques components investigate existing techniques migrated components 
spirit component middleware prefer delegate responsibility replication management container container managed replication 
examine replication availability supported containers components transparently persistence transactions highly available enabling transaction involving ejbs commit despite finite number failures involving application servers computations take place databases persistent data kept 
engineering task poses problems require careful resolution 
order highlight problems possible solutions consider replication approaches simple approach incrementally incorporate additional sophistication 
explain approaches consider simple transaction non redundant system operates ejbs deployed single container beans storing persistent states database system incorporate redundancy follows state replication single application server persistent state stored multiple databases database application server failures masked transaction able commit provided application server access copy state database 
ii state replication clustered application servers persistent state stored multiple databases multiple application servers load sharing total number transactions system individual transaction reliability features case 
iii state computation replication clustered application servers persistent state stored multiple databases instances beans replicated cluster application servers ideal set server side availability measures able mask finite number application server database failures 
existing application servers provide managing persistent state replication 
means rely database vendor specific approaches tolerating database failures vendor specific database replication technique 
computation replication supported stateless computations stateful computations transactions supported 
limitations examined detail section 
shows support managing redundancy incorporated application servers 
require solutions open implementable software 
furthermore require solutions transparent component middleware 
transparency requirement imposes constraints solutions modifications api application programming interface client component modifications api ejb container modifications existing middleware services apis 
constraints contributions show approaches ii implemented relative ease 
implemented approaches validate claim 
possible implement approach iii breaking constraint outline enhancements necessary component middleware support approach iii 
structured follows background information ejb component middleware section replication approaches discussed section section presents performance results related section concluding remarks 

ejbs application servers sub sections describe terminology basic concepts java enterprise edition ee middleware sufficient purposes additional details see 
third sub section describes availability measures currently provided application servers 

ejbs types ejbs specified ee entity beans represent manipulate persistent data application providing object oriented view data frequently stored relational databases 
session beans hand persistent data instantiated client basis instance session bean available client 
session bean may stateless maintain conversational state stateful maintains conversational state 
conversational state needed share state information multiple requests client 
message driven beans provide asynchronous processing acting message listeners java messaging service jms 
container responsible hosting components ensuring middleware services available components run time 
containers mediate client component interactions 
entity bean manage state explicitly persistent store bean managed persistence delegate container container managed persistence 
ejb types may participate transactions 
persistence transactions bean managed container managed 
container managed persistence transactions strongly recommended entity beans 
describe particular combination works assuming combination replication schemes 
transactional ejb applications main elements required supporting transactional ejb applications deployed application server shown 
application server usually manages containers container hosting hundreds ejbs container ejbs shown 
application server multi threaded application runs single process supported single java virtual machine 
middleware services provided application server containers explicitly show just transaction service 
transaction manager hosted application server assumes responsibility enabling transactional access ejbs 
transaction manager necessarily reside address space application server frequently case practical systems 
resource manager persistence store required maintain persistent state entity beans supported application server show 
particular shown relational database management systems rdbms resource managers bean stores state bean 
assume resource managers support acid transactions acid atomicity consistency isolation durability 
client invocation application server container session entity entity transaction manager xaa xab ejb transactions 
communications rdbms container java database connectivity jdbc driver referred ee specification resource adaptor 
jdbc driver primarily accessing relational databases sql statements 
enable resource manager participate transactions originated ejbs interface required 
ee architecture interface referred interface shown xa 
separation concerns transaction management interface resource manager read write operations jdbc clearly defined 
simple terms transaction manager resource manager interface application resource manager jdbc driver 
describe aid sample scenario single transaction involving enterprise beans resource managers 
session bean receives client invocation 
receiving client invocation results session bean starting transaction say issuing number invocations entity beans 
entity beans required session bean session bean activate beans home interfaces results container assuming container managed persistence retrieving states appropriate resource managers initialising instance variables container responsible passing transaction context jdbc drivers interactions turn ensure resource managers kept informed transaction starts ends 
particular retrieving persistent state start lead resource manager write locking resource persistent state stored row table prevents transactions accessing resource ends commits rolls back ii xa resources xaa xab register transaction manager take part phase commit 
session bean indicated transaction manager attempts carry phase commit ensure participants commit rollback 
example transaction manager poll xaa xab respectively ask ready commit 
commit inform transaction manager roll back part transaction 
transaction manager receives positive reply informs participants commit transaction modified states new persistent states 
example beans container 
support distributed transactions involving beans multiple containers possibly distinct application servers straightforward transaction manager built atop corba transaction service java transaction service service coordinate local remote xa resources 
transaction manager able coordinate transaction started client spans ejbs provided client corba enabled 
reason rest need consider simple case transaction non redundant system spans ejbs single container resource managers 

availability measures current application servers commercial application servers multiple application servers deployed cluster machines specialist router hardware see mask server failures rely replication mechanisms database vendors database availability example oracle database products support specific replication scheme 
discuss availability measures integrate properly ejb initiated transactions 
application servers typically deployed cluster machines 
locally distributed cluster machines set machines illusion single ip address capable working host web site provides practical way scaling processing power sharing load site 
commercially available application server clusters rely specially designed gateway router distribute load mechanism known network address translation nat 
mechanism operates editing ip headers packets change destination address ip host address translation performed 
similarly return packets edited change source ip address 
translations performed session basis ip packets corresponding particular session consistently redirected 
load distribution performed process group communication system suggested isis system open source application server mechanism 
market leaders application server space websphere ibm weblogic bea similar approaches clustering 
typically characterise clustering scalability proposed configuration allow system service higher client load provided simple basic single machine configuration 
ideally possible service load simply adding appropriate number machines 
load balancing proposed configurations ensure machine server configuration processes fair share client load processed system 
furthermore total load changes time system adapt maintain load balancing property 
failover machine server system fail reason system continue operate remaining servers 
load balancing property ensure client load gets redistributed remaining servers henceforth process proportionately slightly higher percentage total load 
transparent failover failures masked client minimally need retransmit current request ideal rarely achievable current technology reasons outlined 
important thing current systems forward progress possible eventually time case single machine 
transparent failover easy achieve stateless sessions server cluster service request client multiple requests succession may serviced different server 
failover support case trivial failure server occurs doing client client get exceptional response retransmit request 
situation complicated stateful session server instance requests client server failure lead loss state 
approach adopted commercial systems avoid loss state stateless session approach twist stateful session bean required serialize state datastore client request subsequent bean instance server deserialize state servicing new request obviously servers access datastore 
replication datastore assumed domain datastore 
way functionality available stateless sessions regained 
case failure serialization bean state result state corrupted addressed 
serious limitation transactions supported 
transactional access bean server instance invocation bean 

component replication approaches mentioned start considered detail section 
highlight essential aspects designs glossing minute details replica management 
stating main assumptions 
assume application server works specified simply stops working crash 
crash server repaired finite amount time active 
assume resource managers support acid transactions 
stated earlier consider availability measures session entity beans consider strict consistency 

state replication single server replicating state resource managers application server may continue forward progress long resource manager replica correctly functioning reachable application server 
consider state replication may incorporated scheme shown available copies approach data replication read write client invocation application server session entity entity transaction manager xaa xaa xab xab replication state 
depicts approach resource manager replication leaves container transaction managers internal resource managers transaction manager application server 
rdbmss replicated replicas 
proxy resource adaptors jdbc driver interface introduced identified letter appended labels diagram note clarity lines indicating communication proxy adaptors adaptors shown 
proxy resource adaptors reissue operations arriving transaction manager container replica resource managers resource adaptors 
ensure resource manager replica states remain mutually consistent resource adaptor proxy maintains receive ordering operation invocations redirecting appropriate resource adaptor replicas 
guarantees resource adaptor replica receives operations order guaranteeing consistent locking resources resource manager replicas 
suppose execution transaction say resource manager replicas say fails 
failure result xaa throwing exception caught 
unreplicated scheme exception lead transaction manager issuing rollback 
assuming correctly functioning exceptions propagated transaction manager allowing continue 
scenario states may deviate commits 
removed valid list resource manager replicas time states may reconciled possibly administrative intervention periods system inactivity 
list valid resource managers may maintained case required persistent crash recovery procedures required commit protocol 
outline design provides simple practical way introducing data replication component middleware 

state replication clustered servers single transaction manager may manage transactions clustered application servers 
ensure transaction manager bottleneck system single point failure assume application servers replicated complete transaction managers case practical systems 
depicts scenario cluster contains application servers accessing shared resource manager replicas 
maintained architecture providing state replication described previous subsection 
resource adaptor proxies shown diagram simple communication lines resource managers proxies lines shown dashed emphasise communication resource adapters shown 
possibility multiple transactions running different application servers accessing shared resource manager replicas increases difficulty ensuring resource manager replicas remain mutually consistent 
example assume executing executing require invocations issued entity bean want prevent situation enables proceed container manages obtain state time proceeds container manages obtain state 
break serializable property transactions 
overcome problem single resource manager replica application servers satisfy load requests relevant entity beans call resource manager primary read resource manager 
ensure ordering load requests serialized causing conflicting transactions block locks released 
ensure resource managers remain mutually consistent store request entity bean updates persistent state resource manager issued resource manager replicas 
client invocation client invocation application server session entity transaction manager entity transaction manager entity application server session entity process group clustering state replication 
resource adaptor proxies different application servers need access resource manager replicas agree primary read resource manager 
presence resource manager failure possibility incorrect suspicion resource manager failure agreement protocol needs executed resource adaptor proxies view primary 
obtain facility making group communications system supports abstraction process group totally ordered atomic multicast required particular case 
example proxies need process group proxies need process group 
sake simplicity shown proxies member single group simple arrangement 
furthermore identification primary read resource manager needs available application server restart 
may achieved allowing resource adaptor proxy newly restarted application server gain identity primary read resource manager existing application servers 
requires list available resource adaptor proxies stored persistently application server 
type persistent data may stored xa element proxy resource adaptor 
outline design provides practical way introducing data replication transactional ejb applications cluster servers 

state computation replication clustered application servers consider involved masking application server failures 
state replication incorporated cluster discussed earlier examine masking application server failures independent state replication 
need ability replicate containers distinct application servers distinct transaction managers ensure states ejbs container replicas transactional states respective transaction managers mutually consistent 
way doing process group approach manage replicas active passive replication techniques 
unfortunately pitfalls active replication application servers intrinsically multi threaded working homogeneous application server environment application server replicas copies implementation impossible ensure invocation received container replicas dealt identically 
heterogeneous application servers issues thread pooling add complications 
passive replication primary copy replication theoretically possible homogenous environment checkpoint state container transaction commit time backup take event primary failure assumed application server implementation create checkpoint format instance implementation read 
heterogeneous environment state check pointing requires intimate knowledge different internal external state formats application server implementations involved 
vendors kind information publicly available especially competitors 
unfortunately open standard defining state transfer application server implementations solution application server specific 
issues arise replication transaction managers 
transaction managers concept transaction log persistent entity information transactions kept transactions may completed event recovery failures open standard available initialising transaction manager checkpointed log state transfer mechanisms transaction managers transaction manager specific 
ideally snapshot container possibly application server state taken potentially heterogeneous implementation take snapshot environment point originally taken 
order standard interfaces need defined compliant application server implementations 
attempt address jsr ee apis continuous availability developing notion field replaceable unit fru fru collection modules deployed independently application modules may part example application server 
definer fru responsible ensuring state transfer implementations possible defining format externalised state specifying created initialise fru 
early stage 

experiment results experiments carried determine performance system single lan 
consider figures initial investigations performance system required identify performance replicated state number failure scenarios application failure resource manager failure 
group communication sub system clustered experiments 
implementation setup experiments carried configuration described determine performance clustered jboss clustering non clustered approaches state replication 
single application server replication enable comparative analysis performance figures initial experiment carried single resource manager state replication 

single application server state replication experiment repeated replica resource managers accessed resource adaptor proxy ii 

clustered application server replication application servers constituted application server cluster single resource manager providing persistent storage iii 

clustered application server state replication repeated experiment replica resource managers accessed resource adaptor proxies application servers iv 
application server jboss application server deployed pentium iii mhz pc mb ram running redhat linux 
resource manager oracle release resource manager deployed pentium iii mhz pc mb ram running windows 
client deployed pentium iii mhz pc mb ram running redhat linux 
lan experiments mbit ethernet 
describes different configurations experiments 
client application server resource manager single application server replication resource managers iii clustered application server configuration replication resource managers ii single application server replication resource managers iv clustered application server configuration replication resource managers experimental setup demonstration application experiments 
purposes experiments provide brief description 
benchmark application provided sun microsystems enable vendors measure performance ee products 
presents demonstration application provides realistic approximation may expected real world scenario system represents manufacturing supply chain customer order management 
particularly suited modelling just time manufacturing concepts goals maximum efficiency coupled minimum inventories 
type frequency client orders direct impact manufacturing process turn influences stock ordering 
system implemented ejb components deployed single application server commonly described system test sut 
simple terms order entry application manages customer orders accepting changing orders manufacturing application models manufacturing products associated customer orders 
manufacturing application may issue requests stock items supplier 
supplier implemented emulator deployed java enabled web server 
configuration supplier emulator deployed machine application server clustered approach application servers needs run supplier emulator 
client machine runs driver 
driver may represent number clients assumes responsibility issuing appropriate requests generate transactions order entry manufacturing applications 
driver configured run experiment different injection rates inclusive 
increments record throughput transactions minute order entry manufacturing applications taken 
injection rate relates order entry manufacturer requests generated second 
due complexity system relationship injection rate resulted transactions straightforward 
performance results presents graphs describe throughput applications identifies throughput entry order system ii identifies throughput manufacturing application iii identifies cumulative throughput system entry order manufacturing combined 
inspection see replicated resource managers lowers throughput clustered non clustered configurations injection rates rise iii 
difference comparing order entry manufacturing applications 
manufacturing application suffer degree performance slowdown order entry application state replication introduced 
observation particularly prominent clustered application servers 
reason obvious 
difference may reflect nature different application types types transactions application 
dependency resource manager coupled supplier emulator replicated manufacturing impact replication prevalent manufacturing order entry 
transaction minute transactions minute transactions minute order entry transaction throughput injection rate order entry single replication single replication clustered replication clustered replication manufacturing transaction throughput injection rate ii manufacturing throughput order entry manufacturing transactions injection rate single replication single replication clustered replication clustered replication single replication single replication clustered replication clustered replication iii system order entry manufacturing performance figures 
performance benefit associated clustering shown experiments higher injection rates result lowering transaction throughput single application server scenarios indicating application server overload 
clustering prevents slowdown 
slowdown experienced single server visible manufacturing application injection rates reduce transaction throughput significantly 
state replication introduced single server experience slowdown performance indicating saturation system reached 
fact transaction throughput clustered approach replication similar single application server state replication manufacturing application injection rate 
experiments show clustering application servers benefits systems incorporate state replication scheme 
clustering application servers state replication outperform single application servers state replication approximately 
important observation state replication negate benefits scalability associated clustered approach system deployment 

related replicated data management techniques go hand hand transactions discussed 
object replication process group communication originally developed isis system studied extensively 
eternal system offers replicated non persistent corba objects 
complete fault tolerance framework corba objects ft corba 
existing standards relating object group approaches replication considered issue integrating transactions persistence 
group communications support active replication schemes expectation replicas exhibit deterministic behaviour 
discussed approach appropriate guaranteeing replica states remain mutually consistent considering multithreaded ee application servers 
passive approach replication ee environments developed attempt enable client session consists multiple client requests continue processing backup application server primary fails need abort client session 
shortcomings scheme stateful session beans considered client invocations scheme may benefit transactions 
limitations scheme reflect difficulties associated passive replication ee discussed earlier 
system supported replication transactional persistent objects 
transactions group communication supporting persistent object replication investigated 
replication approach section approach discussed 
approach integrating replication transactions suitable tier systems proposed 
authors base solution combining ft corba corba object transaction service ots 
nested transactions key feature protocol allowing transactions rolled back part restarted backup servers 
applying approach ee problematic flat transactions supported ee specification moment 
additionally problems associated transaction manager replication discussed earlier addressed 
classification database replication techniques suggests group communications utilised support eager strong consistency replication protocols 
traditionally lazy replication schemes favoured commercial products communication overheads eager schemes compared lazy schemes significant 
inconsistencies database replicas may result lazy schemes issues eager schemes coupled promising initial results integrating group communication replica database schemes identify eager schemes viable choice 
group communication mechanisms allow new members database replica group retrieve current state information existing database replicas discussed 
context study drawback approaches need integrate group communications sub system database architecture making schemes difficult existing commercial databases 
second drawback transaction model assumed distributed transaction span multiple databases 
overcome drawback middleware layer proposed provides required functionality enable seamless integration group communication eager replication schemes existing commercial databases 
second drawback removed approaches suitable supporting state replication 

concluding remarks examined case ejb component middleware replication availability supported containers 
shown persistent state replication incorporated transparently possible application servers 
enhancements required enabling pointed explained 
demonstrated approach state replication clustered application server environments series experiments known benchmarking software tool ee 
experiments show significant overhead implementing state replication 
experiments indicate clustering state replication provides scalable solution non clustered approach application server deployment 
concentrate development state computation replication clustered application servers described experiments determine benefit system presence failures 
part funded european union project ist uk dti science programme project funded que project batch iii department informatics engineering institute technology indonesia 

enterprise java beans reilly birman process group approach reliable computing cacm pp 
december 
jboss application server www jboss org websphere scalability wlm clustering september ibm com sg pdf bea white achieving scalability high availability business ftp buy bea com pub downloads wls clustering pdf september 
bernstein concurrency control recovery database systems addison wesley 
jsr ee apis continuous availability www jcp org jsr detail jsp guerraoui felber system support object groups proceedings acm conference object oriented programming systems languages applications oopsla 
felber guerraoui schiper implementation corba object group service theory practice object systems pp 

moser melliar smith narasimhan consistent object replication eternal system theory practice object systems vol 

moser melliar smith narasimhan fault tolerance framework corba proceedings ieee international symposium fault tolerant computing madison wi june pp 

little shrivastava replicated resilient objects proceedings st ieee workshop management replicated data houston november pp 

little shrivastava maintaining information persistent replicated objects distributed system icdcs pittsburgh may pp 

little shrivastava implementing high availability corba applications java ieee workshop internet applications san jose july pp 

little shrivastava integrating group communication transactions implementing persistent replicated objects chapt 
advances distributed systems lncs vol 

pedone schiper kemme alonso database replication techniques parameter classification proc 
th ieee symposium reliable distributed systems srds october 
kemme alonso new approach developing implementing eager database replication protocols acm transactions database systems tods volume september pp 
kemme bartoli online reconfiguration replicated databases group communication proc 
ieee international conference dependable systems networks dsn goteborg sweden june 
jim nez peris mart nez kemme alonso improving scalability fault tolerant database clusters early results proc 
ieee nd int 
conf 
distributed computing systems vienna july 
oracle com products oracle pdf oracle se summary pdf may ftp ftp java sun com pub spec ee fr spec pdf april felber narasimhan reconciling replication transactions reliability corba applications distributed objects applications oct www com 
