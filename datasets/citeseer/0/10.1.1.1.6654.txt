shield vulnerability driven network filters preventing known vulnerability exploits helen wang guo daniel simon alf microsoft com feburary technical report msr tr microsoft research microsoft microsoft way redmond wa shield vulnerability driven network filters preventing known vulnerability exploits helen wang guo daniel simon alf software patching effective line defense preventing large scale worm attacks patches long available corresponding vulnerabilities 
generally people reluctant patch systems immediately patches perceived unreliable disruptive apply 
address problem propose line worm defense network stack shields vulnerability specific exploit generic network filters installed systems vulnerability discovered patch applied 
filters examine incoming outgoing traffic vulnerable applications drop traffic exploits vulnerabilities 
shields disruptive install easier test bad side effects reliable traditional software patches 
show concept feasible describing prototype shield framework implementation filters traffic transport layer 
designed safe restrictive language describe vulnerabilities partial state machines vulnerable application 
expressiveness language verified encoding signatures number known 
evaluation provides evidence shield low false positive rate impact application throughput 
examination sample set known vulnerabilities suggests shield prevent exploitation substantial fraction dangerous ones 
urgent security problems facing administrators networked computer systems today threat remote attacks systems internet vulnerabilities currently running software 
particularly damaging self propagating attacks worms exploit vulnerabilities take control host host find attack hosts vulnerability 
obvious defense attacks prevent attack repairing vulnerability exploited 
typically software vendors develop distribute patches software soon possible learning vulnerability 
customers install patch prevent attacks exploit vulnerability 
experience shown administrators install patches long available 
result attacks including worms widely publicized codered slammer worms exploit known vulnerabilities patches available quite time quite successful causing widespread damage attacking large cohort vulnerable hosts 
reasons administrators may fail install software patches disruption installing patch typically involves rebooting particular host service possibly entire host system 
administrator system service uptime crucial may unable tolerate required service system disruption 
unreliability software patches typically released quickly possible vulnerability discovered insufficient time cursory testing patch 
popular software programs patch testing inherently difficult involves exponential number test cases due numerous versions dependencies various versions libraries depend turn libraries 
patches serious undetected side effects particular configurations causing severe disruption damage host systems applied 
risk damage administrators may prefer thorough time consuming testing simply wait accepting risks vulnerability patch widespread installation 
irreversibility patches designed easily reversible 
applied easy way patch short restoring backup version entire patched application entire system 
factor exacerbates risk associated applying patch 
accident administrator may simply patch announcement reason unaware received announcement neglected act 
drawbacks installing patches methods explored mitigating vulnerabilities installing patches patch determined safe install 
goal address window vulnerability vulnerability disclosure software patching 
window illustrated gap times 
firewall example configured prevent traffic originating outside local network reaching vulnerable application blocking appropriate port 
doing protect application attack outside 
course blocking traffic port crude measure preventing application functioning firewall 
ideally traffic exploits vulnerability blocked time vulnerability privately disclosed vulnerability publicly disclosed patch released fig 

time windows scale axis reflect actual time window duration 
fact time adjacent typically greater time weeks months 
traffic allowed pass application 
explore possibility applying intermediate patch network perform filtering function delay cases eliminate need installing software patch removes vulnerability 
shield system vulnerability specific network filters shields installed host firewall edge router examines incoming outgoing traffic vulnerable applications drops modifies traffic vulnerability signature 
shield operates application level protocol layer transport layer 
example shield conceptually shield vulnerability designed protect buffer overrun vulnerability detect drop traffic resulted excessively long value placed vulnerable buffer 
shield differs previous anti worm strategies section attempting remove specific vulnerability directly mitigate counter effects exploitation 
software patches shields deployed network network stack host 
separated vulnerable application wide variety potential environment configurations unforeseen side effects 
particular compatibility normal operation principle relatively easy test operate network traffic intended drop attack traffic tested simply exposing suitably rich collection network traffic long trace past network activity synthetic test suite representative traffic verify allow unaffected 
focus attention design implementation host shield system 
efficient kind host shield positioned highest protocol layer application layer assuming hooks layer available traffic interception manipulation 
way redundant message parsing avoided 
example essentially shield specific microsoft iis web server uses iis extension package offers hooks request interception manipulations 
applications offer patch applied incoming outgoing network traffic new shield policy shield vulnerability signature vulnerability shield network filter fig 

shield usage shielded traffic processes remote hosts protocols 
designed shield framework lies application layer transport layer offers shielding application level protocols 
transport layer shield need deal ipsec encrypted traffic 
encrypted traffic transport layer ssl application specific encrypted traffic difficult framework handle sensible build respective shield frameworks commonly protocols ssl rpc 
techniques described readily applied 
shield framework model vulnerability signatures combination partial protocol state machines vulnerability parsing instructions specific payloads section iii 
generality generic elements application level protocols shield architecture section iv 
flexibility simplicity express vulnerability signatures countermeasures safe restrictive expressive policy language interpreted shield framework runtime section vi 
minimize shield maintenance protocol state scalability apply defensive design ensure robustness section 
implemented preliminary shield prototype experimented number known vulnerabilities including ones famous slammer codered worms section viii 
evaluation provides evidence zero false positives manageable impact application throughput section ix 
examination sample set known vulnerabilities suggests shield prevent exploitation substantial fraction dangerous ones section ix 
ii 
overview shield usage gives overview basic shield operations 
host shield network filter intercepts network traffic examines manipulates traffic installed shield policies 
shield policy specifies vulnerability signature recognize network traffic exploits vulnerability actions take shield runs root hosts possible shield obtain encryption keys perform decryption 
fact shield framework incur heavy overhead stream ciphers 
traffic encountered 
conceptually shield policy vulnerability 
new vulnerability discovered shield designer typically vulnerable application vendor creates shield policy vulnerability distributes users running application incoming shields protect host potentially malicious incoming traffic similar fashion firewall application specific knowledge 
outgoing shields filtering traffic triggers vulnerability exploiting responses back host protects hosts local network host outgoing traffic 
assumes shield installed higher privilege level malicious compromised sender vulnerability exploiting traffic 
sender simply disable shield attacking hosts 
receiving shield policy host policy installing policy shield system 
note action require re starting vulnerable service rebooting machine 
software patch applied vulnerable application eliminating vulnerability corresponding policy removed shield 
iii 
vulnerability modeling essential part shield design method modeling expressing vulnerability signatures 
shield vulnerability signature specifies possible sequences network events specific payload characteristics lead exploit vulnerability 
note vulnerabilities suitable shielding 
issue discussed section ix 
example signature vulnerability slammer worm arrival udp packet port size exceeds legal limit vulnerable buffer microsoft sql server implementation 
sophisticated vulnerabilities require tracing sequence messages leading actual message potentially exploit vulnerability 
express vulnerability signatures precisely developed taxonomy modeling vulnerabilities illustrated 
application considered finite state machine call application state machine 
overlaying top application state machine protocol state machine transitions network event arrivals 
protocol state machine smaller simpler application state machine 
application state machine viewed refinement protocol state machine 
zooming particular state protocol state machine fine grained application state machine enlarged state 
shield primarily concerned protocol state machine 
define pre vulnerability state state protocol state machine receiving exploitation network event secure distribution shield policies open research question scope 
vulnerability state machine protocol state machine fig 

vulnerability modeling embedded application state machine state cause damage 
call partial protocol state machine leads pre vulnerability state vulnerability state machine network event potentially contain vulnerability vulnerable event 
shield vulnerability signature essentially specifies vulnerability state machine describes recognize vulnerability vulnerable event 
shield policy vulnerability includes vulnerability signature actions take recognizing exploit vulnerability 
section vi detail design policy language shield policy specification 
high level shield vulnerability intercepts application traffic walks vulnerability state machine reaching pre vulnerability state shield examines vulnerable event possible exploits takes specified actions protect exploits 
goals overview iv 
shield architecture objective shield emulate part application level protocol state machine relevant vulnerabilities counter exploits runtime 
identify main goals shield design minimize limit amount state maintained shield shield designed resist resource consumption denial service dos attacks 
carefully manage state maintenance 
host shield bar high shield needs dos resilient service shielding 
flexibility support application level protocol flexibility designed shield vulnerabilities related application level protocol protected shield 
shield system design independent specific application level protocols shield system design implementation simply scale necessary add individual application level protocols core system time 
defensive design design shield way shield easier alternative attack target 
robust shield design ensure shield state machine emulation consistent actual state machine running vulnerable application conditions 
words crucial defend carefully crafted malicious messages may lead shield misinterpretation application semantics 
shield achieves goal applying known principle separating policy mechanism 
shield mechanism generic implementing operations common application level protocols 
shield policies specify varying aspects individual application level protocol design corresponding vulnerabilities 
separation ensures shield flexibility support application level protocol 
identify mechanisms necessary generic elements application level protocol implementation obvious generic elements explained section 
application level protocols parties say client server implemented finite state automata state machine design specification 
carry state machine transitions party perform event identification session dispatching protocol allows multiple parallel sessions 
transaction protocols transaction pair request response session just packet direction 
result applicationlevel messages indicate message type session id applicable 
implementations datagram protocols handle order application datagrams sessions 
see section 
implementations application level protocols messages cross packet boundaries handle fragmentation 
see section 
policy specifies application identification identify packets destined application 
port number serves purpose 
event identification retrieve message type received message 
session identification applicable determine session message belongs 
state machine specification states events transitions defining protocol automaton 
setting specification vulnerability state machine subgraph complete protocol state machine see section iii 
shield mechanisms including policy enabling section iv 
policy language section vi 
components data structures section describe essential components data structures host shield system 
depicts shield architecture 
raw bytes port shield architecture application dispatcher app vulnerability state machine specification spec location messagetype location message boundary drop data structures raw bytes spec id session dispatcher shield interpreter event session interpret handler policy loader state event fig 

shield architecture state state state machine instance instance ii session state statei state new policies main data structures application vulnerability state machine specifications spec runtime session states 
policy loader transforms shield policies specs 
multiple vulnerability state machines application compiled application vulnerability state machine specification 
effectively state machine specification application 
purpose spec instruct shield emulate application vulnerability state machines runtime 
mentioned section iv spec contains state machine specification port number application identification event session identification information 
event session identification spec indicates location offset size vector event type session id information packet event type values concern shield 
application protocols session oriented session id left unspecified session consists single message 
application level protocol may involve negotiating dynamically selected port number session id communications ftp rtp 
case new port number registered shield application identification session id specified port indicating communication port considered single session 
termination session dynamic port de registered shield 
generalize event recognition session dispatching text application level protocols smtp allow units offset size defined words characters addition bytes 
example smtp message type indicated offset size word 
field contains request line method get post version represents status message type 
smtp field contains smtp command mail data 
course generalize unit unit delimiters 
example unit words space unit delimiter bytes 
necessary handful protocols examined 
application level protocols allow multiple application level messages received single buffer 
addition session id message type spec specifies application level message boundary marker 
example message boundary marker crlf crlf smtp crlf 
key challenge application level messages may received entirety due congestion control application specific socket usage order due protocol udp 
essential event identifying parts message event type session id may arrive 
address problem dos resilient copying buffering detailed section note session important abstraction packet dispatching unit shielding apart socket descriptors host pairs 
socket descriptor may multiple sequential sessions multiple sockets may carry communications session ftp 
similarly pair hosts may carrying multiple sessions 
cases sessions eliminates ambiguities packets belong session 
data structure shield session state 
runtime shield maintains session state potentially vulnerable communication session 
session state includes current state session context information needed shielding 
shield modules describe shield module turn policy loader new shield policy arrives old policy modified policy loader integrates new policy existing spec exists creates new 
shield policy expressed shield policy language 
policy loading involves syntax parsing syntax tree stored spec purpose run time interpretation shielding actions details policy language design interpretation please see section vi 
application dispatcher raw bytes arrive shield port application dispatcher invoked determine spec arrived data port number 
application level protocol may port numbers port number corresponds single application 
application dispatcher forwards raw bytes identified spec session dispatcher event session identification 
session dispatcher obtaining locations session id message type message boundary marker corresponding spec session dispatcher extracts multiple messages applicable recognizes event type session id dispatches event corresponding state machine instance 
runtime state machine instance smi state machine instance session 
event current state maintained corresponding session state smi consults spec regarding event handler invoke 
event handlers included shield policies 
smi calls shield interpreter event handler 
shield interpreter shield interpreter interprets event handler specifies parse application level protocol payload examine vulnerabilities 
carries actions packet dropping session tear registering dynamic port shield setting state current smi 
implementation issues scattered arrivals application message shield intercepts traffic transport layer need cope network layer fragments data arrival perceived shield necessarily represent complete application level message independently interpretable application 
scattered arrivals single application level message due tcp congestion control specific message handling implementations application 
instance udp server may multiple calls recvfrom receive single application level message 
case shield recognize multiple data arrivals messages 
complicates session dispatching session id message type received shot 
complicates payload parsing event handlers data arrived event handler finish parsing checking 
copy buffer pass part incompletely arrived data shield system wait rest data arrive interpret 
addition need index copy buffers arrivals message session stitched properly 
socket descriptors appropriate identify sessions section iv safe indexing copy buffers multiple sockets session ftp single application message typically scattered multiple sockets application able interpret parts message due lack information session id message type similarly socket descriptor multiple parallel sessions application message received socket continuously completion interruptions application messages 
apply socket copying incomplete message arrivals 
differentiate pre session copying session copying 
pre session copying happens session id information completely arrived session copying refers copying data session known 
copy buffer associated socket initially session id fully arrives 
session id received copy buffer associated socket respective session 
complete application message received copy buffer de allocated 
need save entire partially arrived message partially arrived field 
example session id field arrived completely say bytes shield needs remember parsing session id field saves received bytes 
copying shield small 
introduce runtime data structure needs maintained shield parsing state 
state application level message records field application message parsed bytes received field 
field terminal field structure fields field nested structures array field represented fields 
restriction minimize amount copying copying terminal field typically small 
vulnerable application maintain state current field parsed application messages shield determined session message belongs lead exploit 
maintain session state copy buffer sessions 
avoid ambiguity keep parsing state message parts message treated new application messages 
attackers easily craft parts single application level message send separately cause inconsistencies emulated state machine shield actual state machine application 
shield able parse application messages parsing instructions payload formats message types application specified shield policy descriptions 
payload formats part spec 
fortunately shield need parse messages detail parts necessary detecting presence exploit 
aggressively bundle ptcp proposes tcp connection multiple sockets tcp 
ptcp deployed shield tcp index copy buffer 
fields application message field total byte count word count number bytes words skip parsing 
shield concludes innocence session goal parsing subsequent application level messages find messages 
parsing messages streamlined 
specifying application messages daunting application level protocol specified standard formalized format policy language format see section vi automatically extract payload format specifications vulnerability state machines format policy language 
hand shield designer knows fact scattered arrivals message happen single multiple recvfrom calls receiving single application message implementation events involved vulnerability state machine need specified 
order arrival application datagrams application level protocol runs top udp datagrams arrive order 
applications care ordering datagrams sequence number field application level protocol headers 
shield properly carry exploit detection functions shield copies order datagrams passes applications 
way shield examine packets intended sequence 
shield sets upper limit number copied datagrams maximum number datagrams application level protocol handle 
maximum needs expressed policy descriptions sequence number location 
application level fragmentation shield runs top transport layer 
shield need deal network layer fragmentation re assembly 
application level protocols application data units perform application level fragmentation re assembly 
protocols top tcp bytes received order 
protocols top udp shield copies order datagrams retain correct packet sequence see section 
receiving processing application level fragments different processing partially arrived data explained section 
spec needs contain location application level fragment id message fragment treated entire message event 
vi 
shield policy language section shield policy language describe vulnerabilities countermeasures application 
shows examples policy language usage 
policy scripts vulnerabilities slammer codered respectively 
shield name transport protocol port list shield vulnerability tcp retrieve session id msg type session id location msg type location initial state final state final state state state state event direction event incoming event outgoing event outgoing event incoming event outgoing event incoming event outgoing event incoming event incoming state machine state event handler 
payload parsing instruction context payload struct skip bytes dummy bytes skip bytes dummy bytes skip bytes version skip bytes context payload parsing instruction payload struct skip bytes dummy bytes skip bytes dummy context contexts 
handler invoking rpc call contexts xb dcf af return fi return final handler return handler teardown session print rpc requests come return final fi return payload structs handlers included 
fig 

excerpt policy description vulnerability parts policy specification shield language 
part includes states events state machine transitions generic application level protocol information ports locations event type session id sequence number fragment id packet message boundary marker 
part policy specification loaded application vulnerability state machine specification spec directly policy loader independent runtime conditions 
second part policy specification runtime interpretation exploit checking 
includes handler specification payload parsing instructions vulnerability slammer shield slammer udp offset size byte msg type location initial state final state final event request incoming state machine request request handler request dont care counter msg len returns exceeded counter msg len drop return final fi return final fig 

policy description vulnerability slammer shield vulnerability codered shield codered tcp initial state final state final msg type location word msg boundary event get request get incoming state machine get request get request payload struct words method words uri bytes rest dummy get request handler get request get request counter counter regular expression retrieve query string uri match str len returns exceeded match str len get request uri exploit 
teardown session return final fi return final fig 

policy description vulnerability codered payload struct definitions figures 
role handler examine packet payload pinpoint exploit current packet payload record session context needed exploit occurrence 
examine packet handler needs follow policy payload parsing instructions 
policy loaded policy loader parses syntax handlers payload parsing instructions stores syntax tree spec run time interpretation 
payload specification payload struct definitions specify parse application level message 
shield needs parse fields payload actual applications needs parse fields relevant vulnerability 
allow policy writers simplify payload parsing clustering insignificant fields single dummy field required number bytes dummy field rpc bind 
fields marked parsing keyword skip copy buffer maintained fields section 
examining number application level protocols find payload parsing specification needs support limited set types fields including bytes size bytes num num variable size expression words size words num text protocols multi dimensional array payload struct boolean 
sense payload parsing specification application level protocol message network data representation ndr layout rpc stub data expressed interface definition language idl definition 
idl provides syntax describing structured data types values rpc procedure call inputs outputs ndr provides mapping idl data types octet streams 
fact application payload expressed idl syntax serialized raw bytes ndr encoding 
believe payload specification potentially generic express application payload 
handler specification shield language handler specification simple highly specialized purpose 
variables scopes local handler global session handlers 
data types bool boolean counter number byte arrays bytes word arrays word 
built variables handlers session id built functions include drop teardown session length functions msg len match str len regular expression functions may needed text protocols 
drop drops udp packet teardown session closes sockets associated session 
regular expression functions data stream string 
able cope scattered message arrivals 
similarly length functions stream required parameter count example scripts figures facilitate handling buffer overrun type vulnerabilities 
length reaches count counting stops returns count 
way shield count maintain state necessary case buffer overrun exploits 
syntax payload instructs shield parse bytes represent payload packet parsing instruction defined payload definition payload struct 
payload earlier policy 
parsed fields payload struct treated local variables handler 
handler allow assignments statements special purpose return statements exit handler indicates state session 
specialized syntax sugar parsing iterative payload structures array items traditional generalpurpose loops 
example item payload 
interpreter parses items field payload iteratively payload definition way performs operations bytes representing item 
note interpreter keep state parse items array 
handler interpretation current payload parsed may completely received 
case save execution state handler part session state new data arrives handler execution resumed 
call continuation 
case continuation state includes queue current handler statements executed potentially nested statements parsing state section payload current field payload parsed bytes read field 
restrictive nature language safer language general purpose languages 
language restrictive find sufficient vulnerabilities worked application level protocols examined 
evolving gain experience shielding vulnerabilities 
language simpler bro language scripting security policies bro intrusion detection system nids :10.1.1.116.8880
bro performs network monitoring intrusion detection network layer network stack monitors cross application cross session interactions various attack patterns 
contrast shield concerned application specific traffic passing top transport protocols higher level protocols rpc 
furthermore key advantage vulnerability driven approach shield attack exploit driven shield need consider attack activities vulnerable application involved example multi stage attacks 
shield needs screen traffic particular vulnerable applications 
hand language complex declarative click router configuration language cover tasks just configuration 
shield needs parse payload perform actions runtime events 
vii 
analysis scalability number section discuss shield scales number vulnerabilities machine 
number shields host grow arbitrarily large shields presumably removed corresponding vulnerability patched 
shields application specific adding negligible overhead applications apply 
shields different applications equivalent single shield terms effect performance single application 
application may multiple vulnerabilities time 
state machines model vulnerabilities preferably merged single 
state machine traversed packet resulting linear overhead 
vulnerabilities appear disjoint paths merged state machine packet shield processing overhead equivalent overhead just vulnerability 
vulnerabilities share path state machine shield overhead may cumulative 
hand data vulnerabilities section ix suggests cumulative effect significant worm exploitable vulnerabilities vulnerabilities appeared single application protocol year 
case vulnerable applications application throughput shield worst halved network traffic processed twice shield application 
experiment shield prototype indicates shield impact application throughput quite small section ix 
false positives design shields able recognize filter traffic exploits specific vulnerability low false positives 
false positives may arise incorrect policy specification due misunderstanding protocol state machines payload formats 
incorrect policy specification debugged stress test suites simply replaying substantial application traffic traces 
trace replay application level easy necessary replay precise transport protocol behavior 
source false positives may come application behavior receiving exploit event 
application state machine embedded state may trigger vulnerable code local machine setting runtime conditions 
information incorporated shield difficult generalize application specific implementation details simple safe policy language constructs 
vulnerabilities experimented observed false positives section ix 
viii 
implementation prototyped host shield system microsoft windows xp 
particular implemented shield microsoft layered service provider lsp 
api latest socket programming interface network applications windows 
runtime network applications link appropriate socket functions linked library dll socket function calls 
lsp mechanism allows new service providers created intercepting calls kernel socket system calls 
lsp compiled dynamically linked library 
installation applications making calls links dll lsp dll 
mechanism implement shield intercepting application traffic transport layer see 
user kernel applications ws dll shield layered service provider dll windows socket kernel mode driver afd sys tcp ip atm 
fig 

shield implementation lsp shield lsp implements architecture depicted lines code employ flex parse syntax shield policy language 
policy loader calls api obtain syntax trees policy scripts 
vulnerabilities slammer codered twelve vulnerabilities microsoft security bulletin board drive design implementation 
input validation type vulnerabilities buffer overruns integer overflow malformed urls 
slammer exploits proprietary application level protocol top udp 
exploits rpc tcp udp 
codered uses 
vulnerabilities exploit telnet smb rpc :10.1.1.116.8880:10.1.1.116.8880
examined application level protocols rtp smtp design policy language 
obtained protocol specification occurrence vulnerability corresponding payload writing shield policy easy 
applicability shield ix 
evaluations applicable shield real world vulnerabilities 
shield designed catch exploits wide variety application level protocols potential gaps coverage vulnerabilities result bugs deeply embedded application logic difficult shield defend replicating application logic network 
example browser vulnerabilities exploited html scripting languages difficult shield prevent languages flexible incoming scripts line count include generated flex files 
easy application vendors produce shield policies easy access protocol specifications 
number nature worm shield 
applicability local client hard server buffer overruns easy cross site scripting hard server denial service hard table applicability shield vulnerabilities year 
parsed run simulation discover fact exploits 
simple vulnerabilities exploitable malformed network protocol independent application objects files difficult shield catch 
example shield simple buffer overruns application file formats spot incoming file arriving different protocols 
file vulnerabilities vulnerability specific anti virus softwares exploit specific ones widely today appropriate 
application specific encryption poses problem shield mentioned section assess significance obstacles analyzed entire list security bulletins published microsoft security response center year 
table summarizes findings 
bulletins described vulnerabilities purely local involving network way 
rest described client vulnerabilities sense requiring local user action vulnerable machine navigating malicious website opening application trigger remaining described server vulnerabilities sense possible trigger network outside machine 
client vulnerabilities generally appear difficult design shields 
client vulnerabilities result self propagating worms exploited kind user action browser 
example involved application file formats 
remainder email client vulnerabilities media player vulnerability rest browser invoked html client side scripting 
server vulnerabilities twelve conceivably exploitable worms ideal conditions server application widely deployed unprotected configuration 
remainder included denial service attacks scripting attacks potential information disclosure 
vulnerable exploitation worms 
potentially worm exploitable vulnerabilities involved application protocols running 
rest involved specific application protocols typically directly tcp udp appear inherently incompatible shield approach 
twelve client bind bind ack request response server fig 

rpc message exchanges clients server throughput evaluation 
buffer overruns shield applicable 
vulnerabilities may appear suitable shield treatment fact threatening prone exploitation worms appear disproportionately shield compatible 
assessed reliability patches associated sample set security bulletins 
patches associated bulletins including repairing potentially worm exploitable vulnerabilities updated initial release 
including involving vulnerabilities updated mitigate reported negative side effects patch 
augmented extra patches legacy versions product 
side effects avoided shield place patch key advantage shields patches easy testability section 
exception related vulnerabilities single application level protocol exhibited rpc vulnerabilities entire year 
apart port port burdened combining shields time cumulative performance costs large numbers shields issue separate overhead shield port place 
application throughput evaluate impact shield application throughput devised experiment clients establishing simultaneous client server rpc sessions tcp session server sends mb data back clients rpc response 
server clients 
server dell gx pentium cpu ghz mb ram 
clients server connected mb ethernet switch 
computers run windows xp sp 
estimate worse case impact policy examines byte traffic server 
measure server output throughput shield lsp enabled disabled 
table ii shows result throughput shield significant differences setting hinting shield design implementation number clients shield mbps shield mbps table ii application throughput shield significant impact performance existing network protocol stack 
false positives mentioned section vii false positives come misunderstanding protocol state machine differential treatment exploit application 
section evaluate false nature implementation 
focus attention shield designed slammer exploits protocol sql server 
obtained stress test suite vendor 
simple protocol message types 
test suite contains total test cases exhaustive testing requests various forms 
running test suite shield observe false 
prove shield false positive free serves evidence shield low false 
related shield network system defending vulnerability exploiting attacks 
network tools defending attacks include firewalls network intrusion detection systems nids 
firewalls similar function shield way rarely customized response particular vulnerability instance 
usually deployed host unaware application level protocols may access example traffic encrypted 
nids systems exemplified bro snort monitor network traffic detect attacks known exploits :10.1.1.116.8880:10.1.1.116.8880
nids usually customized application firewalls deal known exploits known vulnerabilities 
shield nids traffic forwarding path 
focus detection prevention vulnerability exploits 
reliable attack detection traffic proposed forwarding path eliminating potential ambiguities traffic seen monitor removing evasion opportunities 
functions traffic normalizer similar shield traffic normalizer mainly deals transport layer anomalies purpose detection shield run transport layer blocks actual attack traffic 
shield lower false rates false negative rates nids shield vulnerability specific nature 
malicious traffic filters specific traffic web servers proposed deployed microsoft iis web servers 
akin shield approach 
comparison shield generic framework supports application level protocols 
onsets codered slammer past years set new stage worm defense research 
number papers characterized analyzed fast wide spreading nature potential modern day worms :10.1.1.126.2682:10.1.1.160.6250:10.1.1.160.6250:10.1.1.7.3953:10.1.1.119.399
moore showed existing containment systems firewalls content filters successful realistic worms react automatically matter minutes nearly internet paths 
finding spurred research fast worm signature generation 
signatures network intrusion prevention systems nips filter traffic matching signatures 
rate limiting containment method sending rate infected host 
interesting worm detection mechanism honeypots vulnerable machines network number ip addresses 
unsolicited outgoing traffic honeypots represents attacks 
ongoing research copes new exploit detections shield prevents exploits known vulnerabilities sources major damages far 
past assumed removing vulnerabilities matter patch distribution management research suggests patching complete solution 
shield provides alternative complement conventional approach removing vulnerabilities patching network stack 
xi 
shown network vulnerability specific filters feasible implement low false positive rates manageable scalability broad applicability protocols 
number natural directions research shield experience writing shields specific vulnerabilities better indicate range shield applicability adequacy shield policy language 
may possible develop automated tools ease shield policy generation 
example writing shield policy currently requires fairly deep understanding protocol vulnerability exploited 
protocols described standard formalized format possible build automated tool generates protocol parsing portion shield policy 
rest task writing policy manual relatively easy vulnerability exploiting portion incoming traffic say overly long field causes buffer overrun easy identify traffic parsed 
shield need necessarily implemented host 
may preferable cases administration performance point view deploy shield firewall router special purpose box 
alternate deployment options explored 
advantages shield shields principle tested relatively simple way verifying collection traffic test suites real world traces interfered 
automating process shield installation process easier 
ensuring secure reliable distribution shields crucial 
releasing patch enables attackers reverse engineer patch understand corresponding vulnerability exploit shield reverse engineering easier vulnerability signatures spelled shield policies 
shield distribution installation tighter race exploit designing hacker 
possible shield design prove useful applied virus problem viruses exploit vulnerability application invoked infected file opened 
today anti virus software signature identifying specific exploits vulnerabilities 
incorporating shield technology anti virus systems allow protect generic classes viruses particular infection method 
xii 
jon pincus insightful constant advice idea formation stage shield project 
jay lorch gave thoughtful critiques draft 
microsoft colleagues product side graciously helped understanding various aspects vulnerabilities microsoft security bulletin 
include mike howard yong qu jiri richter david ross chris walker zhu 
obtained learned stress test suites number application level protocols product group colleagues andu balakrishnan jiri richter pavel 
stephen adams andrew yang offered helpful discussions policy language design interpreter implementation 
anthony jones helped understanding lsp programming model 
benefited discussions john padhye stefan savage david thaler nick weaver 
thankful help 
ganesh krishnan markus kuhn eugene spafford wagstaff jr low threat security patches tools 
ieee international conference software maintenance october 
steve beattie seth arnold crispin cowan perry wagle chris wright 
timing application security patches optimal uptime 
lisa xvi november 

com html 
chen gao :10.1.1.7.3953
modeling spread active worms 
infocomm 
microsoft security bulletin ms november 
microsoft security tool 
www microsoft com security asp 
fielding gettys mogul frystyk berners lee 
hypertext transfer protocol january 
gregory ganger gregg stanley 
finding containing enemies walls self securing network interfaces 
technical report cmu cs carnegie mellon university january 
mark handley vern paxson christian 
network intrusion detection evasion traffic normalization protocol semantics 
proceedings usenix security symposium august 
hung yun hsieh sivakumar 
transport layer approach achieving aggregate bandwidths multi homed mobile hosts 
acm mobicom september 
anthony jones jim 
network programming microsoft windows 
microsoft publishing 

rfc simple mail transfer protocol april 
eddie kohler chen frans kaashoek robert morris massimiliano poletto 
programming language techniques modular router configurations 
technical report lcs tr mit laboratory computer science 
david moore vern paxson stefan savage shannon stuart staniford nicholas weaver 
inside slammer worm 
www computer org security htm 
david moore shannon jeffery brown 
code red case study spread victims internet worm 
acm internet measurement workshop 
david moore shannon geoffrey voelker stefan savage 
internet quarantine requirements containing self propagating code 
proceedings ieee infocom april 
microsoft security bulletin ms september 
vern paxson 
flex scanner generator table contents 
www gnu org software flex manual 
vern paxson :10.1.1.116.8880
bro system detecting network intruders real time 
computer networks dec 
postel reynolds :10.1.1.116.8880
rfc telnet protocol specification may 
postel reynolds 
rfc file transfer protocol ftp october 
valentin daniel simon 
practical automated filter generation explicitly enforce implicit input assumptions 
proceedings th annual computer security applications conference new orleans la december 
eric 
security holes 
cares 
proceedings usenix security symposium august 
dce remote procedure call 
schulzrinne casner frederick jacobson 
rfc rtp transport protocol real time applications january 
umesh shankar vern paxson 
active mapping resisting nids evasion altering traffic 
proceedings ieee symposium security privacy may 
richard sharpe :10.1.1.116.8880
server message block 
samba anu edu au cifs docs smb html 
singh cristian estan george varghese stefan savage 
system real time detection unknown worms 
technical report cs university california san diego 
microsoft security bulletin ms january 
open source network intrusion detection system 
www snort org 
stuart staniford vern paxson nicholas weaver :10.1.1.126.2682:10.1.1.160.6250
wn internet spare time 
proceedings th usenix security symposium august 
nicholas weaver vern paxson stuart staniford robert cunningham :10.1.1.160.6250:10.1.1.119.399
large scale malicious code research agenda 
www cs berkeley edu weaver large scale malicious code pdf 
nick weaver 
potential fast internet plagues 
www cs berkeley edu html 
matthew williamson 
throttling viruses restricting propagation defeat malicious mobile code 
technical report hpl hp labs bristol 

