rv preliminary version static veri cation dynamically detected program invariants integrating daikon esc java jeremy nimmer michael ernst mit lab computer science technology square cambridge ma usa email lcs mit edu shows integrate complementary techniques manipulating program invariants dynamic detection static veri cation 
dynamic detection proposes invariants program executions resulting properties guaranteed true possible executions 
static veri cation checks properties true dicult tedious select goal annotate programs input static checker 
combining techniques overcomes weaknesses dynamically detected invariants annotate program provide goals static veri cation static veri cation con rm properties proposed dynamic tool 
integrated tool dynamically detecting program invariants daikon tool statically verifying program properties esc java 
daikon examines run time values program variables looks patterns relationships values reports properties ed test runs satisfy certain conditions statistically justi ed 
esc java takes input java program annotated preconditions postconditions assertions reports annotations statically veri ed warns potential runtime errors null dereferences bounds array indices 
prototype system runs daikon inserts output code esc java annotations runs esc java reports able annotations 
entire process completely automatic users may provide guidance order improve results desired 
preliminary experiments esc java veri ed invariants proposed daikon 
preliminary version 
nal version published electronic notes theoretical computer science url www elsevier nl locate entcs nimmer ernst static dynamic analyses complementary strengths weaknesses combining great promise 
static analysis operates examining program source code reasoning possible executions 
builds model state program values variables expressions 
static analysis conservative sound inecient produce weak results require explicit goals annotations 
dynamic analysis obtains information program executions examples include pro ling testing 
modeling state program dynamic analysis uses actual values computed program executions 
dynamic analysis ecient precise results may generalize program executions 
research integrates static dynamic analysis take advantage complementary strengths dynamic analysis propose program properties veri ed static analysis 
focuses analyses program invariants 
program invariant property true particular program point points appear assert statement formal speci cation 
invariants include procedure preconditions postconditions loop invariants object representation invariants 
examples include abs array contains duplicates child parent nodes size keys size contents graph acyclic 
invariants explicate data structures algorithms helpful programming tasks design maintenance 
invariants assist creation better programs document program operation assist testing enable correct modi cation assist test case generation validation form program spectrum enable optimizations uses 
despite advantages invariants usually missing programs 
dynamic invariant detection technique postulating invariants program runs dynamic invariant detector runs target program examines values computes looks patterns relationships values reporting ones true entire test suite satisfy certain conditions see section 
outputs invariants guaranteed universally true test suite characterize possible executions program 
static invariant veri cation technique checking program properties 
program set properties program veri er reports properties guaranteed true executions 
ed properties universally true 
static veri ers operate data ow analysis theorem proving model checking techniques 
users static veri ers annotate programs properties proved properties depend 
combining dynamic invariant detection static veri cation bene ts users invariant detectors users static checkers 
nimmer ernst output dynamic invariant detector guaranteed sound programmers may reluctant output fed tools require sound input 
static veri er indicate proposed invariants guaranteed true 
users lter ed invariants results sound veri cations rst approximation determining dynamically detected properties functional invariants usage properties useful di erent tasks 
users static veri ers bene decreased annotation burden 
static veri cation requires extensive annotations intermediate assertions goals 
automatic annotation relieves users burden annotating programs scratch task enjoy 
dynamically detected invariants indicate properties programmers overlooked 
started explore bene ts integrating dynamic invariant detector daikon static veri er esc java :10.1.1.137.4260:10.1.1.152.4499
system operates steps 
runs daikon outputs list invariants obtained running target program test suite 
second inserts invariants target program annotations 
third runs esc java annotated target program report invariants statically veri ed 
section gives details process 
steps completely automatic users may provide guidance order obtain better results desired 
users may edit re run test suites de ciencies may add remove speci program annotations hand 
remainder organized follows 
section provides background dynamic invariant detector static veri er system 
section presents results experiments 
section describes integrated tools section discusses problems arose building running system 
section relates results research section proposes research section concludes 
background daikon invariant discovery dynamic invariant detection discovers invariants program executions instrumenting target program trace variables interest running instrumented program test suite inferring invariants instrumented values :10.1.1.137.4260
inference step tests set possible invariants values captured instrumented variables invariants tested sucient degree cation reported programmer 
dynamic approaches nimmer ernst invariants instrumented program original program test suite run instrument data trace database detect invariants fig 

overview dynamic detection invariants implemented daikon 
testing pro ling accuracy inferred invariants depends part quality completeness test cases 
daikon invariant detector language independent currently includes java 
daikon detects invariants speci program points procedure entries exits program point treated independently 
invariant detector provided variable trace contains execution program point values variables scope point 
set possible invariants tested various combinations traced variables 
scalar variables computed constants examples checked invariants equality constant small set constants fa cg lying range non zero modulus mod linear relationships ax ordering functions fn 
invariants involving sequence variable include minimum maximum sequence values lexicographical ordering element ordering invariants holding elements sequence membership 
sequences example checked invariants elementwise linear relationship lexicographic comparison subsequence relationship 
addition local invariants node node child parent nodes daikon detects global invariants pointer directed data structures sorted linearizing graph data structures 
daikon detect conditional invariants universally true null value value limit left 
conditional invariants result splitting data parts condition comparing resulting invariants invariants halves di er composed conditional invariant 
variable tuple variables scope program point potential invariant tested 
potential unary invariant checked variables potential binary invariant checked pairs variables forth 
potential invariant checked examining sample tuple values variables tested turn 
soon sample satisfying invariant encountered invariant known hold checked subsequent samples 
daikon maintains acceptable performance program size increases false invariants tend nimmer ernst ed quickly cost computing invariants tends proportional number invariants discovered 
invariants inexpensive test require full edged theorem proving 
enable reporting invariants regarding components properties aggregates values stored program variables daikon represents entities additional derived variables available inference 
instance array integer scope properties may interest variable may appear program text 
derived variables treated just variables invariant detector permitting infer invariants hardcoded list 
instance size derived sequence system report invariant size comparison check case scalar length sequence 
performance reasons derived variables introduced known sensible 
instance sequence derived variable size introduced invariants computed introduced ensure range invariant reported adequate evidence plausibility 
particular inadequate number samples particular variable patterns observed may mere coincidence 
consequently detected invariant daikon computes probability property appear chance random input 
property reported probability smaller user de ned con dence parameter 
daikon invariant detector available download sdg 
lcs mit edu daikon 
esc static checking esc extended static checker implemented modula java 
statically detects common errors usually detected run time null dereference errors array bounds errors type cast errors 
esc intermediate power ease theorem provers aims lightweight comparison 
proving complete program correctness esc detects certain types errors 
programmers write program annotations similar avor assert statements need interact checker processes annotated program 
esc issues warnings annotations proven potential run time errors 
esc performs modular checking checks di erent parts program independently check partial programs modules 
assumes speci cations missing unchecked components correct 
esc implementation uses theorem prover internally 
discuss esc nimmer ernst checking strategy detail research treats esc black box distributed binary form 
esc java successor previous esc modula 
esc java annotation language see section simpler slightly weaker 
keeping philosophy tool easy useful programmers extraordinarily powerful dicult programmers shy away 
research uses esc lightweight technology detecting restricted class runtime errors tool verifying representation invariants 
chose esc aware equally capable technology statically checking properties runnable code 
veri ers operate non executable speci cations models research aims combine dynamic static techniques code artifact 
furthermore wished explore limits invariants dynamically detected statically veri ed 
event representation invariants required determine variables non null array accesses bounds 
versions esc publicly available research compaq 
com src esc 
experiments section gives quantitative qualitative results experiments statically verifying dynamically detected invariants 
sections discuss detail examples taken data structures textbook sections characterize generated invariants provide intuition output system 
section overviews experiments highlights types problems system may encounter 
stackar array stack stackar example array stack implementation 
source contains non comment lines code methods comments describe behavior class mention representation invariant 
system determined representation invariant method preconditions modi cation targets postconditions statically proved properties hold 
annotations esc issues warnings potential runtime errors 
addition detected invariants esc successfully checks stackar class avoids runtime errors meets speci cation maintains important properties execution 
shows daikon invariant detector nds invariants object invariants requires clauses method preconditions modi es clauses modi cation targets ensures clauses method postconditions 
nimmer ernst expressible inexpressible unique 
unique 
total object requires modi es ensures total fig 

invariants detected daikon stackar program 
table classi es invariants expressibility stated language see section redundancy logically implied invariants 
system discovered proved invariants non redundant 
invariants inexpressible esc see section 
invariants implied invariants removed improved redundancy checks daikon see section 
system heuristically added annotations involving owner array see section 
shows part automatically annotated source code stackar 
rst annotations describe representation invariant 
array null runtime type object 
topofstack index length array 
elements array non null index topofstack null 
annotations describe speci cation constructor 
capacity non negative entry exit array length matches capacity topofstack index indicates empty stack elements array null 
nal assertion redundant implied representation invariant 
addition proving absence errors system generated speci cations operations class veri ed implementation met speci cation 
example postconditions method ensures old topofstack result null ensures old topofstack result null invariants state returns null stack empty entry 
assertions method provide partial speci cation necessarily give full input output relation 
speci cations derived detected invariants useful reasons 
users understand behavior method reading speci cations reasoning implementation 
similarly static tools nimmer ernst public class stackar invariant null invariant typeof type java lang object invariant topofstack invariant topofstack invariant forall int null invariant forall int topofstack null public stackar int capacity requires capacity ensures capacity length ensures topofstack ensures forall int null new object capacity topofstack set owner 
spec public private object invariant owner spec public private int topofstack 
fig 

object invariants rst method eld declarations annotated stackar java le 
jml annotations comments starting produced automatically daikon automatically inserted source code system automatically veri ed esc java 
check assertions checked assertions perform reasoning calling code 
furthermore programmers modifying existing code may aided knowledge existing invariants code preserves 
may check speci cations previously generated proved unmodi ed program hold true new source 
invariants explicate potentially important properties implementation 
example representation invariant stackar guarantees unused array elements set null 
objects popped stack prevented garbage collected 
nimmer ernst expressible inexpressible unique 

unique 
total object requires modi es ensures total fig 

invariants detected daikon program 
table classi es invariants expressibility stated language redundancy logically implied invariants veri ability esc able verify 
system discovered proved invariants non redundant 
coincidental invariants due speci cs test suite proved 
union nd disjoint sets second example illustrates results provides example invariants veri ed 
class array implementation disjoint sets partition range integers disjoint subsets support union find operations 
source contains non comment lines code methods comments describe behavior class mention representation invariant 
system determined representation invariant method preconditions modi cation targets postconditions statically proved properties hold 
shows daikon invariants class invariants expressible esc remaining ones redundant 
annotations involving owner array added heuristic 
esc proved expressible invariants warned unprovable test suite artifacts 
unprovable invariants coincidences test suite detect invariants 
implementation integer array represent sets integer set element leader set 
union operation daikon reported precondition requires length invariant states neighbor penultimate element element 
test cases include case penultimate element added set element assertion true input data true general 
tests contradict assertion added suite arguably general utility 
nimmer ernst experiments run system examples primarily chosen textbooks sta solutions assignments programming course mit 
selected particular programs contain interesting nontrivial representation invariants obviously capabilities esc 
system able verify detected invariants programs stackar 
section discusses challenges static veri cation illustrate brie 
general classes problems 
foremost artifacts test suites initially resulted irrelevant universally true invariants 
instance integer bounds variables denom common artifacts test suites 
initial test suites unit tests came textbooks grading 
speculate unit tests tend smaller stylized typical usage throw daikon statistical justi cation tests see section running system tests 
second class veri cation problems involved invariants daikon detect missing classes invariants 
instance negate method rational numbers daikon detected equality denominators argument result 
proving property require detecting numerator denominator argument relatively prime gcd operation called constructor ect 
previously rejected invariants general applicability 
users easily add invariants daikon writing java class satis es interface methods 
third class problems involved esc inability prove certain invariants 
discovering source second third class problems easy quick little trouble convincing correctness incorrectness invariant code 
comparison extending unit test suites nd interesting invariants daikon output time consuming tedious 
avoid starting unit tests 
implementation section discusses implementation 
enhanced daikon invariant detection capabilities permit report certain invariants section 
permit esc verify detected invariants converted esc input language section 
annotations added heuristically section 
nimmer ernst daikon additions enhancements daikon output easier esc prove 
added invariants sequence elements comparing elements variable constant 
invariants previous version daikon added current implementation 
listed variables modi ed routine 
output misleading 
instance disjoint set union method modi es set set listed possibly modi ed modi ed set 
plan eliminate extraneous listing combination statically analyzing method text heuristically omitting modi cation list modi ed variables overlap modi ed variables 
enhanced daikon list splitting criteria consider boolean procedure return values procedure exit points 
daikon uses criteria produce implications splitting data parts di erent invariants true parts data combined implications disjunctions 
daikon able report preconditions caused boolean function return true false preconditions caused certain return statement executed properties hold 
altered daikon report invariants methods implied object invariant 
daikon successful nding redundant invariants greatly reduced number redundant reported invariants making manageable removing information 
output changes ect provability invariants ease interpretation esc output 
esc notation esc input language variant jml java modeling language 
jml interface speci cation language specify behavior java modules 
relevant research ability specify object representation invariants method preconditions postconditions 
jml expressions written syntax closely resembling java 
jml variant accepted input esc java 
daikon default output language similar java extensions permit certain varieties invariant expressed concisely clearly possible java 
user option daikon produce output 
di erences formats fall categories 
semantics di er convenient concise languages equally expressive usually convert daikon output 
cases express concepts nimmer ernst daikon discovers expresses language omit invariants attempting veri cation esc 
semantic di erences full jml daikon default output format support array comprehensions represent subarray indices inclusive 
daikon permits quanti cation expression array elements instance elements length 
daikon represents accesses arrays vectors linked lists uniformly succinctly subscripting notation 
field accesses may applied sequences indicating sequence speci ed elds instance fld represents sequence fld fld 
contrast states expressions arrays explicit forall quanti er access vector linked list elements 
default expressions daikon output assumed hold subexpressions sensible 
instance foo bar daikon output means foo null foo bar means length 
daikon switch guards explicit output eliminates invariants expressions nonsensical 
esc expression may legal index result failure verify uninformative error messages 
daikon object invariants speci ed hold entry exit methods esc required hold entry exit methods 
private helper methods need require maintain object invariants 
match semantics remove daikon object invariants repeat appropriate method entries exits judged verbose confusing prevents true public object invariants proved esc 
invariants inexpressible daikon method postconditions indicate orig daikon old expressions evaluated pre state 
instance return orig indicates procedure returns value held method called procedure may modi ed execution 
daikon orig apply variable distinguishes array identity array contents array subsequences 
old apply array contents method parameters primitive type 
furthermore way mix expressions post state expressions pre state 
limitations worked tricks existential quanti ers resulting invariants particularly readable 
annotations include method calls ones ect free 
daikon uses obtaining vector elements predicates implications 
nimmer ernst daikon express closure operations elements linked list 
properties collections interesting important invariants recursively de ned data structures 
full jml language permits method calls assertions old applied primitive parameters reach expressing reachability transitive closure 
annotations system private variables accessible speci cation spec public annotation 
signi cantly constructor sets owner ghost eld non primitive eld object constructed 
states contents eld aliased objects 
annotation esc reasons eld arbitrarily modi ed time method little whatsoever proved 
adding annotation source code analysis potentially unsafe discipline frequently followed acceptable experiments date 
challenges section discusses challenges static veri cation dynamically detected program invariants 
challenges fall general categories problems tools problems target programs problems test suites target programs 
cases largely solved problems cases diculties remain overcome 
tools section lists enhancements daikon invariant detector part research 
daikon prototype anticipate additional changes may required particularly extended new varieties invariant 
strengthening checks redundant invariants reduce size output improve comprehensibility removing information 
section noted problems esc input language variant jml express certain important invariants concisely clearly express 
cases esc appear strong verify certain true invariants error messages occasionally cryptic 
general pleased esc operated ectively eciently 
instance run esc daikon source code esc detected bugs daikon failing verify reported invariants closer inspection true 
bugs paste errors case invariant formatting routine incorrect case rst element array ignored 
nimmer ernst esc express invariants strings daikon reports invariants event 
result esc prove object invariants hold exit constructor method interprets string argument show invariant maintained methods 
cases esc prove properties daikon reports property depends object invariant daikon scope 
users add invariants hand delete properties depend 
target programs challenge static veri cation invariants fact programs contain errors prevent desired invariant true 
goal previously identi ed errors textbooks programs testing research 
example error detected course project object invariants stackar states unused elements stack null permits objects garbage collected stack popped permits earlier detection certain types error 
operation maintains invariant approximately doubles size code routine fails non obvious oversight implementor clients 
test suites dynamic invariant detection may produce properties true test suite target program run true arbitrary runs program 
problem solved integrating dynamic invariant detection static veri cation 
static veri er indicates invariants universally true true capabilities veri er true context program run accidental usage properties test suite 
case reported invariants specify unintended property test suite general programmer knows exactly wrong improve test suite 
static veri cation partly solves question invariants necessarily true contexts remainder section treats problem absence static veri cation dicult eliminate properties universally true output veri es warnings whatsoever 
cases bad invariants gave valuable hints test cases needed added test suite 
instance experiments certain stack operations performed completely full nimmer ernst stack queue implemented array forced wrap adding deleting elements capacity 
example serious oversight test suite calls safe stack pop operation protected check array empty 
resulting invariants stated result non null indicating full functionality method tested 
cases eliminating undesirable invariants tedious chore 
required nding test case ed particular special case little abstraction relevant data structures logic particular implementation 
largest problems undesirable upper lower bounds variables 
speculate daikon statistical tests particular invariants need adjusted 
possible statistical tests strive space ecient approximations produce accurate result 
related rst research aware dynamically generated statically proved program properties 
dynamic analysis variety tasks instance inductive logic programming ilp produces set horn clauses rst order rules run program traces limited success 
programming example similar requires close human guidance version spaces compactly represent sets hypotheses 
value pro ling eciently detect certain simple properties runtime 
event traces generate nite state machines explicate potential system organization behavior 
program spectra capture aspects system runtime behavior 
techniques successful daikon detecting invariants programs valuable domains 
static inference techniques exist space prohibits discussing 
techniques tools esc statically checking formal speci cations 
systems different strengths weaknesses esc polish integration real programming language see section 
houdini research closely related houdini annotation assistant esc java 
houdini motivated observation users reluctant annotate programs invariants attempts lessen burden providing initial set 
houdini takes candidate annotation set input computes greatest subset valid particular nimmer ernst program 
repeatedly invokes checker removes refuted annotations annotations refuted 
candidate invariants possible arithmetic comparisons elds interesting constants array lengths null elements initial set mutually contradictory 
daikon candidate invariants richer houdini daikon outputs implications disjunctions base invariants richer including complicated arithmetic sequence operations 
required invariant missing houdini eliminate true invariants depend 
houdini attempt eliminate implied redundant invariants daikon reducing output size order magnitude dicult interpret numbers invariants produced houdini 
houdini publicly available perform direct comparison 
merging approaches useful 
instance daikon output form input houdini permitting houdini spend time eliminating false invariants 
prototype dynamic essentially limited dynamic invariant detector built details results provided 
houdini di erent intent daikon houdini try produce complete speci cation annotations people missing annotations permit programs cluttered respect similar type inference 
daikon output place houdini 
invariants true depend missing invariants provable esc eliminated users closer completely annotated program need eliminate invariants hand 
section listed number problems system components daikon esc corrected 
obvious way extend di erent invariant detectors daikon di erent veri ers esc 
section lists invariant detectors 
examples static veri ers connected real programming languages include lclint acl loop java pathfinder bandera 
currently integrating daikon ioa formal language describing computational processes modeled automata 
ioa toolset theory lcs mit edu tds ioa html permits ioa programs run provides interface larch prover lp interactive theorem proving system rst order logic 
daikon propose goals lemmas intermediate assertions theorem prover 
side conditions representation invariants nimmer ernst enable proofs hold reachable states representations possible states representations 
tedious error prone people specify properties proved current systems trouble postulating researchers consider task harder performing proof 
interested recovering failed attempts static veri cation 
broadly speaking veri cation fails goal properties strong weak 
properties strong may true capabilities veri er may universally true instance guaranteed program context artifacts test suite 
properties weak true proved static veri er useful instance loop invariants may need strengthened proved 
anticipate dynamic invariant detection propose overly strong invariants overly weak ones 
veri cation fails know strengthen weaken invariants principled way examining source code program executions patterns invariants veri er output increase likelihood successful veri cation 
dynamic invariant detection quite successful number application domains believe truly successful program analysis requires static dynamic components 
hard variety analysis easy 
properties dicult obtain dynamic analyses apparent examination source code properties state art static analysis easily checked runtime 
plan integrate static analysis system particularly daikon 
dynamic analysis need check properties discovered static analysis dynamic analysis focus statically indicated code 
demonstrated feasibility dynamically detecting statically verifying program invariants 
particular built system takes output daikon invariant detector feeds esc static checker 
knowledge rst system dynamically detect statically prove program properties 
preliminary experiments small programs demonstrate daikon ective proposing useful invariants esc ective verifying invariants 
integrating dynamic invariant detection static veri cation bene ts tools 
static veri er augment dynamic invariant detection overcomes potential objection possibly unsound output classi es output permit programmers ectively permits proven invariants contexts input certain programs demand sound input may improve performance output dynamic invariant detection 
result programmers take advantage nimmer ernst dynamically detected invariants variety contexts directly leading fewer bugs introducing fewer detecting better documentation time wasted program understanding better test suites ective validation program changes ecient programs 
dynamically detected invariants bootstrap static veri cation annotating programs providing goals intermediate assertions speed adoption static analysis tools lessening user burden remains user 
direct ect increased tools detection errors earlier software development process statically compile time dynamically test time worse application 
indirect ect production robust reliable correct computer systems 
visible faults silent errors occur easier maintain properties program life machine checking conditions program correctness depends 
acknowledgments members daikon group particularly ben morse michael harder melissa hao contributions project 
fruitful conversations william griswold josh rustan leino greg nelson david notkin james saxe 
research supported part nsf ccr ccr 
david abramson ian foster john soci relative debugging new methodology debugging scienti applications 
communications acm november 
thomas ball 
concept dynamic analysis 
esec fse pages september 
bensalem lakhnech saidi 
powerful techniques automatic generation invariants 
cav pages july august 
ivan bratko marko grobelnik 
inductive learning applied program construction veri cation 
jos editor pages 
north holland 
brad calder peter feller alan eustace 
value pro ling 
micro pages december 
brad calder peter feller alan eustace 
value pro ling optimization 
journal instruction level parallelism march 
www 
org vol 
nimmer ernst chang debra richardson 
structural speci cation testing automated support evaluation 
esec fse pages september 
william cohen 
grammatically biased learning learning logic programs explicit antecedent description language 
arti cial intelligence august 
jonathan cook alexander wolf 
discovering models software processes event data 
acm transactions software engineering methodology july 
jonathan cook alexander wolf 
event detection concurrency 
fse pages november 
james corbett matthew dwyer john corina robby shawn laubach hongjun zheng 
bandera extracting nite state models java source code 
icse pages june 
allen cypher daniel david henry lieberman david brad myers alan editors 
watch programming demonstration 
mit press cambridge ma 
david detlefs 
overview extended static checking system 
proceedings workshop formal methods software practice pages january 
david detlefs rustan leino greg nelson james saxe 
extended static checking 
src research report compaq systems research center december 
matthew dwyer lori clarke 
data ow analysis verifying properties concurrent programs 
fse pages december 
michael ernst 
dynamically discovering program invariants 
phd thesis university washington department computer science engineering seattle washington august 
michael ernst jake cockrell william griswold david notkin 
dynamically discovering program invariants support program evolution 
ieee tse february 
previous version appeared icse pages los angeles ca usa may 
michael ernst adam william griswold david notkin 
quickly detecting relevant program invariants 
icse pages june 
michael ernst william griswold david notkin 
dynamically discovering pointer program invariants 
technical report uw cse university washington seattle wa november 
david evans 
static detection dynamic memory errors 
pldi pages may 
nimmer ernst david evans 
lclint user guide version may 
lclint 
cs virginia edu guide 
david evans john guttag james horning yang meng tan 
lclint tool speci cations check code 
fse pages december 
cormac flanagan rajeev joshi rustan leino 
annotation inference modular checkers 
information processing letters february 
cormac flanagan rustan leino 
houdini annotation assistant esc java 
international symposium formal methods europe formal methods increasing software productivity volume lncs pages berlin germany march 
stephen garland john guttag 
lp larch prover 
stickel editor proceedings tenth international conference automated deduction kaiserslautern west germany volume lncs 
springer verlag 
stephen garland john guttag 
guide lp larch prover 
technical report digital equipment systems research center december 
stephen garland nancy lynch 
automata developing distributed systems 
gary leavens murali sitaraman editors foundations component systems pages 
cambridge university press 
stephen garland nancy lynch 
ioa language specifying programming validating distributed systems 
technical report mit laboratory computer science 
todd graves alan karr marron harvey 
predicting fault incidence software change history 
ieee tse july 
david gries 
science programming 
springer verlag new york 
mary jean harrold gregg rothermel rui wu liu yi 
empirical investigation program spectra 
paste pages june 
klaus havelund thomas 
model checking java programs java pathfinder 
international journal software tools technology transfer 
haym hirsh 
theoretical underpinnings version spaces 
ijcai pages august 
hoare hayes jifeng morgan roscoe sanders sorensen spivey 
laws programming 
communications acm september 
see 
nimmer ernst hoare hayes jifeng morgan roscoe sanders rensen spivey 
laws programming 
communications acm august 
see corrigendum 
monica hutchins herb foster thomas ostrand 
experiments ectiveness data ow control ow test adequacy criteria 
icse pages may 
bart jacobs joachim van den berg marieke huisman martijn van ulrich hendrik 
reasoning java classes 
oopsla pages vancouver bc canada october 
matt kaufmann strother moore 
industrial strength theorem prover logic common lisp 
ieee tse april 
john knight nancy leveson 
experimental evaluation assumption independence multiversion programming 
ieee transactions software engineering january 
lau pedro domingos daniel weld 
version space algebra application programming demonstration 
icml stanford ca june 
gary leavens albert baker clyde ruby 
jml notation detailed design 
haim kilov bernhard rumpe ian simmonds editors behavioral speci cations businesses systems pages 
kluwer academic publishers boston 
gary leavens albert baker clyde ruby 
preliminary design jml behavioral interface speci cation language java 
technical report iowa state university department computer science february 
see www cs iastate edu leavens jml html 
rustan leino greg nelson 
extended static checker modula 
compiler construction pages april 
rustan leino greg nelson james saxe 
esc java user manual 
technical report compaq systems research center palo alto california october 
nancy leveson stephen cha john knight timothy 
self checks voting software error detection empirical study 
ieee tse 
barbara liskov john guttag 
abstraction speci cation program development 
mit press cambridge ma 
nancy lynch 
distributed algorithms 
morgan kaufmann san francisco ca 
nimmer ernst nancy lynch mark tuttle 
hierarchical correctness proofs distributed algorithms 
podc pages vancouver bc canada august 
nancy lynch mark tuttle 
input output automata 
cwi quarterly september 
tom mitchell 
version spaces approach concept learning 
phd thesis department computer science stanford university stanford ca december 
stanford university technical report hpp 
lori clarke leon osterweil matthew dwyer 
veri cation concurrent software 
icse pages may 
xiao mei chou 
imperfect debugging ect software reliability growth 
icse pages may 
frank pfenning 
dependent types logic programming 
frank pfenning editor types logic programming chapter pages 
mit press cambridge ma 
ross quinlan 
learning logical de nitions relations 
machine learning 
thomas reps thomas ball das james larus 
program pro ling software maintenance applications year problem 
esec fse pages september 
gregg rothermel mary jean harrold 
empirical studies safe regression test selection technique 
ieee tse june 
sohi 
empirical analysis instruction repetition 
asplos pages october 
rgen anderson stephen garland john guttag nancy lynch anna 
computed assisted simulation proofs 
courcoubetis editor fifth conference computer aided veri cation pages heraklion crete june 
springer verlag lecture notes computer science 
nigel tracey john clark keith mander john mcdermid 
automated framework structural test data generation 
ase pages october 
ben wegbreit 
synthesis loop predicates 
communications acm february 
mark allen weiss 
data structures algorithm analysis java 
addison wesley longman 

