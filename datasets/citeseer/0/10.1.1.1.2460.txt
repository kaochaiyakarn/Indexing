portable virtual machine target proof carrying code michael franz deepak chandra andreas gal vivek ferm ning wang franz gal uci edu department computer science university california irvine ca virtual machines vms proof carrying code pcc techniques independently provide safety mobile code 
existing virtual machines java vm drawbacks effort required safety verification considerable 
second subtly need provide verification code consumer inhibits amount optimization performed code producer 
turn justin time compilation surprisingly expensive 
proof carrying code hand set limitations sizes proofs fact certified code longer machine independent 
describe progress combining approaches 
hybrid safe code solution uses virtual machine designed specifically support code simultaneously providing efficient justin time compilation target machine independence 
particular approach reduces complexity required proofs resulting fewer proof obligations need discharged target machine 

considerable amount effort invested mobile code safety 
general idea simple trusting piece code came specific provider example purchased box reputable store digitally signed verify code prior execution 
verification means determining code safety examining code came 
past years main approaches safe code prefer term safe code term mobile code reasons 
code mobile program patches applications increasingly distributed internet 
second believe far code resident desktop computers outside small hardware secured trusted computing base developed 
turn virtual machines code verification proof carrying code inherently safe code formats :10.1.1.40.2507:10.1.1.12.1222
virtual machines code verification code examined ensure semantic gap source language virtual machine instruction format exploited 
example virtual machines general goto instructions possible control flows legal example language definition java requires variable initialized control flow strictly linear property inferred trivially virtual machine program requires verifier perform dataflow analysis 
proof carrying code solutions code producer attaches safety proof executable 
receiving code recipient examines calculates verification condition code 
verification condition relates potentially unsafe constructs occur executable 
task code producer supply proof discharges verification condition code executed 
third approach inherently safe code format transport mobile program making aspects program safety formedness criterion mobile code 
checking formedness format simpler verifying bytecode 
disadvantage complex memory intensive machinery required code recipient site inherently safe formats compression syntax static program semantics 
consequence approach suited resource constrained client environments 
describe hybrid approach combines solutions applies elements third 
aim research find sweet spot reconciling high execution performance final code high dynamic compilation efficiency small proof size proof carrying code component limited resource consumption client computer 
structured follows discuss java verified prior execution 
note code producing irreducible control flows verifiable don easily map back control structures source language 
virtual machine representative vm genre de facto standard transporting mobile code 
give overview proof carrying code section 
section presents case new virtual machine specifically designed code 
section gives sketch architecture currently implementing architecture refined merely presenting current state progress 
section contains examples 
section expands proof carrying code aspects 
section presents related 
give outlook conclude 

java virtual machine java virtual machine bytecode format java bytecode de facto standard transporting mobile code internet 
generally acknowledged java bytecode far ideal mobile code representation considerable amount preprocessing required convert java bytecode representation amenable optimizing compiler dynamic compilation context preprocessing takes place user waiting 
addition shown rules bytecode verification don exactly match java language specification certain classes perfectly legal java programs rejected compliant bytecode verifiers 
due need verify code safety arrival target machine due specific semantics jvm particular security scheme possible optimizations performed source java bytecode compiler done eventual target machine cumbersome perform code producer site 
example information redundancy type check may front compiler prove value question correct type path leading check fact communicated safely java bytecode stream needs re discovered just time compiler 
communicated safely mean way malicious third party construct mobile program falsely claims check redundant 
take common subexpression elimination compiler generating java bytecode principle perform common subexpression elimination store resulting expressions additional compiler created local variables approach incomplete eliminate common address calculations arrays verification requires preserving language abstractions optimizations jvm performed verification target machine 
problem just time compilation occurs interactive users waiting execution commence 
dynamic compilation time unbounded able perform extensive optimization obtain high code quality 
interactive setting just time compilers need tradeoff verification compilation time side code quality example employing faster linear scan register allocation slower better graph coloring algorithms 

proof carrying code proof carrying code pcc framework ensuring untrusted programs comply safety policy defined system programs execute 
typical policies type memory control flow safety framework described necula property program expressed order logic constitutes valid safety policy :10.1.1.40.2507
reception untrusted program code consumer examines code emits proof obligation operations potentially unsafe respect safety policy 
instance require proof memory write lies bounds certain array allocated stack 
proof obligations traditionally called verification conditions vcs 
provider untrusted program supply proof vcs 
proof missing code consumer determines constitute proof vc program determined potentially unsafe executed 
done examining program proofs dependence digital signatures mechanisms trust 
important practical aspect pcc size proofs time spent proof checking 
shown proofs java type safety compressed size machine code factor reduction respect previous scheme unfortunately increases proof checking time factor 
notice compresses proofs reduce amount facts need proved 
mobile code contexts space overhead large checking times considered high 
aims reducing size proofs proof checking time generating smaller vcs 
instance having separate register file booleans vcs required state type values contained registers 
pcc demonstrated context machine code 
carries ideas machine independent format advantages represents 

case virtual machine support proof carrying code reasons pcc large proofs level reasoning low machine code level 
level registers memory untyped worse differentiation data values address values pointers 
large portion proof typically re establishes typing data example distinguishing integers booleans pointers 
interestingly current research pcc foundational proof carrying code appears directed solely reducing size trusted computing base target platform 
unfortunately increases volume proofs required 
believe promising go way raising semantic level language proofs reason proofs smaller 
facts previously required confirmation way proof handled axioms 
goal find higher semantic level effective supporting proof carrying code manner translated efficiently highly performing native code variety target platforms 
example mean higher semantic level imagine virtual machine supports concept tagged memory areas memory tag stored offset pointer unreachable regular memory access instructions 
virtual machine guarantees property regular memory access instructions access locations lie data area memory block accesses verified lie range block block doesn include tag 
conversely access tag area requires privileged instructions reads writes tag value 
architecture greatly simplifies certain proofs fragment code doesn privileged write tag instruction changed tag 
higher level tag relates dynamic type memory object implies type remained constant 
aim create software defined layer proof carrying code dynamic translation meet effectively 
need demonstrate second half equation virtual machine efficiently implementable 
key type separation referentially safe encodings hand previously demonstrated safetsa project intricate memory addressing scheme hand 

architecture central element architecture division concerns proof carrying code mechanism virtual machine layer 
virtual machine layer designed way reduce burden proof providing number inherently safe operations 
safe operations involve runtime overhead safe vs non safe properties vm carefully balanced 
prototype implementation choose include safe construction mechanisms little overhead compared equivalent non safe operations 
proof carrying code mechanism provide proof safety remaining parts vm architecture 
vm architecture provides finite number scalar data types complete type separation types explicit conversion operations 
type vm maintains dedicated register set values type reside 
simplicity scalar types integer boolean description 
size register set unlimited 
integer registers bn boolean registers pn pointer registers address registers typed register sets architecture play key role reducing complexity proofs maintaining safety time 
register sets disjoint type integrity scalar values enforced syntactically 
high level types enumerations implemented integers 
constraints integers valid arguments multiplication enforced vm 
constraints enforced proof carrying code level 
relying register architecture vm allows imply greater variety ahead time optimizations stack portable code representation java bytecode il 
example constant folding common subexpression elimination copy propagation performed ahead time architecture 
vm architecture aims ease task providing proof safety memory access operations offering instruction set guarantees memory integrity 
vm provides single instruction allocate memory pj new sizep ik proof carrying code layer ensure pointer registers defined 
conceptually new allocates array objects length ik 
single objects arrays single element 
allocated object divided sections section values section pointers 
size section determined values section sizep pointers section 
pair sizep referred characterizing tuple 
allocation new subsequent memory access operations specified permit safe access record content 
proof carrying code layer responsible ensure proper specified memory access operations 
mechanism understood rudimentary static type checking 
separate instructions provided values pointers objects 
pair value access operations value register type ij iload sizep pk offset istore sizep pk offset il bj sizep pk offset sizep pk offset bl pointers stored retrieved pointer access operations pj sizep pk offset pcc hll static compilation proof generation machine code hll proof generation vm dynamic compilation machine code jvm hll jvm dynamic compilation machine code dashed line machine independent 
compared current pcc implementations framework requires shorter proofs machine independent 
compared current vms dynamic compilation simpler semantic distance actual target machines smaller 
able perform optimizations ahead time 
pstore sizep pk offset pl vm guarantees pointers values intermixed 
memory access operation proper provided allow vm access value pointer depending section stored offset offset 
verification layer ensure base pointer pk allocated exactly allocation layout expressed sizep specified load store operation offset exceeding sizep respectively 
prototype implementation shows memory integrity implemented little runtime overhead dynamically guaranteed type safety usually expensive terms runtime cost 
pointer registers point arrays 
access array members vm offers instruction pointer register pk array index il input generating address address register aj aj adda sizep pk il memory access operations proper memory layout provided ensured pcc layer 
adda instruction perform mandatory array bounds check 
proof carrying code layer provide static proof index array bounds dynamic guard inserted instruction 
pk il instruction ensures exception raised il exceeds length array referred pk 
succeed vm stores array length allocated memory block memory block header 
variant instruction loads length array register 
il pk address registers designed cache addresses generated single adda instruction point inside allocated memory block necessarily pointers 
increase complexity garbage collector potentially combination vm architecture 
consider example 
new sizep adda sizep null array object allocated array assigned pointer register 
adda instruction gain access member allocated array 
address stored address cache 
garbage collector triggered original array overwritten known stale address problem arises 
garbage collector mark memory area live knowing starting address 
information available address memory block 
eliminate potential additional runtime overhead garbage collector address cache valid current basic block purged branch instruction 
ensuring garbage collection triggered branch instructions negative impact address cache garbage collection performance eliminated 
pointers proof carrying code layer guarantee address registers defined 
purging address cache branches convenient side effect verification trivial performed linear stream instructions having consider multiple basic blocks case pointers 
regular memory access operations accept address register base address 
specialized address access instructions ij sizep ak offset sizep ak offset il bj sizep ak offset sizep ak offset bl aj sizep ak offset sizep ak offset pl rationale split regular pointer memory access operations take memory block header account calculating target address address access operations 
note address generation instruction adda applied address registers pointer registers 
vm offers additionally forms dynamic guards placed instruction stream static proof certain properties provided 
pcc layer treat existence instructions instruction stream proof associated condition true runtime exception raised 
instruction raises runtime exception pointer register contains null pointer 
note adda operation definition applied null pointers address registers automatically null 
pi 
exception instruction verifies pointer points memory block specified memory layout raises exception 
pi sizep 
exception support instruction vm storing allocated memory block array length memory block header 
location memory block header unknown addresses address registers takes pointer registers input 
applied base pointer previously generate address question 

proofs vm vm provides guarantees memory safety type safety primitive types int floats 
proof burden code producer greatly reduced 
memory safety primitive type safety taken care virtual machine proofs type safety non primitive types needed 
consider example code simple factorial procedure vm code 
procedure fact integer integer integer fact iconst iconst bls iconst isub goto note procedure uses primitive types type safe construction 
instruction set allow type unsafe operations assigning integers booleans 
reduces proof burden code producer type safety proofs need produced non primitive types pointers arrays records 
substantial fractions object oriented programs manipulate primitive types expect smaller proofs 
sharp contrast java bytecode instruction set 
java bytecode instructions indicate type operand example iload loading integer loading float 
bytecode verification technique prove type safety bytecodes operating values primitive types 
java virtual machine stack memory model 
stack typeless entity data pushed stack information type lost inferred point data read stack 
load stack proven type safe primitive types 
measured fraction java bytecodes operate primitive types ints floats doubles section large scale applications benchmark 
average bytecodes type 
crude measure proof burden virtual machine saves right away compared java virtual machine 
proofs needed pointers records 
instruction manipulates address need sure resulting pointer 
points array record value pointers point middle int 
points object correct type pointer integer allowed point boolean field accesses adda instruction condition checked offsets known compile time 
condition pointers type safety proofs take form 
typemap simply mapping pointers types 
procedure entry simply declared types formal parameters local variables 
code generation emitted basic block 
letting vm execute code type checker sure code type safe 
code annotated explained checker basic block set derived typemap annotated typemap iterate instruction basic block simulating effect derived typemap block successor block match derived typemap annotated typemap 
matching procedure simply checks type successors typemap general corresponding type derived typemap 
note takes linear pass code 
simple example consider code snippet 
pointer int int new sizeof int new sizeof int shows corresponding vm code annotated derived 
type int translates characterizing tuple vm bytes data section pointer section 
derived typemap block compared annotated typemap successors 
case checking succeeds 

related virtual machine vm designs low level instruction set similar proposing 
keeping instruction sets close real machine translation real machine code fast efficient attractive compilation target 
primary focus vms code optimizations safe code 
llvm project proposes optimize program compile time link run time :10.1.1.10.331
achieve strongly typed ssa intermediate representation ir 
ssa having type new iconst new annotated typemap derived typemap simple example illustrating proofs type safety 
example instruction new shorthand new achieve syntactic similarity typemap 
information optimizations fast efficient 
supports type unsafe cast operations unsafe languages provide type safety 
project focuses ir runtime available 
tao intent commercial system focuses binary portability mainly multimedia games application 
vm heart system simple low level 
aims binary portability provide type safety 
partly wanted support legacy code written partly reasons performance important factors multimedia applications 
dis virtual machine provides execution environment inferno system 
cisc architecture support high level data structures list strings operators manipulate 
allows type unsafe operations provide type safety guarantees 
system designed provide open system producing executing mobile code 
system designed language processor architecture neutral 
instruction set risc architecture cisc functionalities uses software fault isolation sfi provide module level memory safety 
provide type safety supports unsafe languages vm close real architecture able achieve near native speeds 
typed assembly language tal framework verifying safety program low level representation :10.1.1.24.6526
tal uses type system source language prove safety program 
achieves annotating assembly code generated high level type information available source code 
annotations easily verifiable proofs safety 
translation assembly code binary executable code quickly verified safety annotations 
important point note trust relationship compiler proof checker 
proof checker trust compilation process annotations 
time compilation quickly check correctness annotations 
pcc safety policy expressible order logic tal uses typing rules programming language express safety 
loss generality safety policies leads simpler compact easy generate proofs 
obvious automate proof generation policies complex memory type safety 
system ways close tal supports type safety proofs 
vm instruction set strongly typed primitive types int boolean 
type safety higher order types proved verifiable proofs 
vm provides higher level abstraction machine assembly code provides memory safety guarantees claim proofs shorter faster verify 
case segments programs primitive types proofs implicit instruction set doesn need additional proofs 
safetsa type safe intermediate representation static single assignment form ssa 
safetsa solves problem making ssa easily verifiable safe software transportation format 
combination type separation introducing referentially safe naming scheme ssa values 
consequence type safety safetsa verified linear time 
java virtual machine safetsa tightly coupled java type system easily support languages highly different type systems 
safetsa semantically removed machine layer vm described requires substantial dynamic translation machinery target machine 

outlook exploring design space hybrid solutions virtual machines proof carrying code 
goal find sweet spot reconciles high execution performance just time compilation speed hand small efficient type safety proofs hand 
reported design implementation solution populate design space undoubtedly candidates follow 
preliminary evidence suggests hybrid solutions advantages single mode vm pcc approaches 

parts effort sponsored national science foundation ccr tc defense advanced research projects agency darpa air force research laboratory air force materiel command usaf agreement number office naval research 

lucco adl tabatabai wahbe 
efficient language independent mobile programs 
proceedings sigplan conference programming language design language design implementation pages may 
wolfram dalton peter frohlich vivek peter jeffrey von christian stork michael franz 
project reconciling mobile code security execution efficiency 
darpa information survivability conference exposition june 
wolfram dalton jeffery von michael franz 
safetsa type safe referentially secure mobile code representation static single assignment form 
proceedings acm sigplan conference programming language design implementation pages snowbird utah june 
sigplan notices may 
appel 
foundational proof carrying code 
th annual ieee symposium logic computer science lics pages washington brussels tokyo 
ieee 
karl crary greg morrisett david walker neal glew :10.1.1.24.6526
system typed assembly language 
th acm sigplan sigact symposium principles programming languages pages san diego ca usa january 
vivek christian stork michael franz 
source proof 
new security paradigms workshop sep 
iso iec 
common language infrastructure cli partition iii cil instruction set dec 
chris lattner :10.1.1.10.331
llvm infrastructure multi stage optimization 
master thesis university illinois urbana champaign urbana illinois 
tim lindholm frank yellin 
java virtual machine specification 
java series 
addison wesley longman second edition 
george necula :10.1.1.40.2507
proof carrying code 
conference record popl th acm sigplan sigact symposium principles programming languages pages paris france january 
george necula rahul 
oracle checking untrusted software 
conference record popl th acm sigplan sigact symposium principles programming languages pages london united kingdom january 
sigplan notices march 
robert st rk joachim schmid egon rger 
java java virtual machine definition verification validation 
springer verlag berlin germany heidelberg germany london uk 
sun microsystems connected limited device configuration apr 
intent technology 
available biz aux files intent technology pdf 
phil robert pike 
design inferno virtual machine 
hot chips symposium august 
