cient data structures lazy functional language martin department computing science chalmers university technology goteborg sweden lot theoretical done purely functional data structures implemented general usefulness part data structure library providing uniform framework 
chris okasaki started change implementing edison library cient data structures haskell 
unfortunately abandoned creating framework writing data structure implementations parts 
document gives overview current state edison describes ciency lazy language means measure way trades complexity precision produce meaningful results 
techniques applied give analysis sequence implementations edison 
okasaki briefly mentions main characteristics data structures implemented allow user choose cient task complete analysis needed 
round edison sequence part new implementations previously known theoretical analysed deques pair lists approach data structures allow constant time appending preserving constant time tail init 
achieve certain confidence correctness new implementations quickcheck properties check operations behave desired abstraction allow data structure specific invariants tested polymorphic 
preface thesis degree master science 
documents project aimed improving edison analysing existing data structure implementations adding new ones 
reader assumed familiar functional programming lazy evaluation general haskell particular 
furthermore basic knowledge amortised runtime analysis recommended techniques thesis outlined briefly 
fully understand quickcheck related code fragments quickcheck manual read 
meaning quickcheck constructs quite apparent 
thesis companion edison manual introductory overview time complexity overview appendix relevant 
go supervisor koen claessen proposed project provided excellent guidance gotten excited functional programming place 
contents time complexity lazy language 
current state edison 
sequences 
collections 
associative collections 

runtime complexity analysis existing implementations 







new implementations quickcheck properties sequences 




discussion related 
functional data structure libraries 
java collection framework 
standard template library 
noteworthy di erences edison 


overview time complexities parametricity properties reducer complete source code module chapter modern imperative programming languages exist ready libraries cient data structures sets bags finite maps priority queues java collection classes standard template library prominent examples 
furthermore textbooks data structures claim language neutral silently assume imperative language 
functional programmer needs certain data structure browse multitude papers luck find implementation suits needs 
motivated chris okasaki published book functional data structures oka started development edison functional data structure library written haskell :10.1.1.54.6229
unfortunately okasaki abandoned edison created framework written implementations 
aim thesis complement giving detailed description implementations presently edison manual enrich library implementations 
particular briefly outline methods perform runtime complexity analysis describe current status edison library detailed time complexity analysis carried chapter existing implementations 
necessary papers describing implemented data structures edison manual limited discuss main operations implementations edison provide 
due limited scope master thesis limited certain part edison sequences 
new implementations introduced chapter 
papers implementations describe minority operations available edison remaining functions developed course project 
ensure certain quality implementations edison quickcheck package developed claessen hughes ch 
allows specification properties haskell functions automatic testing properties large number randomly generated test cases 
order automatically generate random data certain type type instance arbitrary class mainly defines arbitrary function responsible generating random data observing required structural invariants 
done inside gen monad defined part quickcheck provides useful combinators 
edison contains property definitions part defined type classes 
instances provide arbitrary interface allow automatic testing 
way quickcheck properties currently specified drawbacks develop section 
chapter concludes comparing edison data structure libraries functional object oriented discussing di erences proposing done edison useful library haskell programmers 
time complexity lazy language document worry runtime complexity function 
measuring time complexity lazy language little tricky 
di cult determine function evaluated furthermore may evaluated partially 
wadler wad sands san developed methods describe precisely 
machinery complex situation programmer wants easily implementation best suited certain purpose 
single term notation function appropriate cost precision 
easiest way produce term analyse function pretending implementation language strict 
unfortunately cient functional data structures rely laziness algorithmically prevents approach 
important insight rely laziness constructs internally 
reasonable simplify time complexity analysis assuming strictness function arguments results di erent data type analysed structure 
parameters reasonable assumption forcing yield arbitrarily long runtimes 
return value equally apparent atomic values needed function evaluated making unnecessary worry runtime 
composite return values notably lists simplification discards useful information function monolithic partially incremental 
sacrifice precision sake brevity 
assumptions amortised runtimes determined methods okasaki oka oka usually describes data structures environment laziness applied selectively standard ml 
situation may require additional thought usage functions returning di erent composite type implement function part library 
typical scenario implementation specific function converts data structure list operates list converts result back 
incrementality neglected may relevant 
briefly outline methods amortised runtime analysis document detailed description left oka oka 
basic principle keep runtime account deposit runtime fast operations withdraw runtime expensive operations 
amortised runtime operation real runtime plus deposited runtime minus withdrawn runtime respectively 
depending account kept distinguish physicist banker method 
physicist method physicist method object potential defined terms objects internal structure 
amortised cost real time plus change potential course negative 
analysis worst case change potential assumed potential lower bound actual runtime account 
banker method banker method credits placed individual locations data structure 
total runtime real runtime plus number allocated credits minus number spent credits course credits previously allocated may spent 
crucial part analysis definition credit invariant ensures expensive operation spent su cient credits 
methods unfortunately break analysed data structure persistently 
document term persistence refer persistent storage program invocations possibility access older versions data structures updates taken place 
property course inherent purely functional programming languages program takes advantage justifying methods 
problem methods persistent usage expensive operation invoked argument possible persistency 
terms banker method means credits spent method potential decreased multiple times 
banker method persistency exploiting lazy evaluation possible give amortised runtime bounds valid persistent usage 
achieve keep credits cheap operations generate debits suspend expensive operation 
particular generated suspension number debits corresponding runtime needed evaluate suspension placed 
operation accesses result suspensions pay debits associated 
amortised runtime time needed generate suspended operations plus number discharged debits 
important aspect analysis define invariant debits ensures forced suspensions free debits 
memoization generated suspension evaluated making method feasible persistent scenarios 
worst case bounds data structures relying lazy evaluation possible establish worst case bounds amortised bounds 
trick force suspension just conceptually paid banker method 
demands computations rewritten enable incremental monolithic evaluation actual design problem find suitable ways force computation lazy language 
course achieved haskell strictness flags pattern matches seqs 
function applies techniques force suspension called call may suspended rendering approach pointless 
application data structure featuring worst case amortised runtimes prevent lazy evaluation operations invoked data structure 
application haskell may considered unusual inappropriate 
document amortised time bounds considered implemented data structures rely lazy evaluation 
benchmarking data structures described strictly better asymptotic bounds considered quite simpler faster note take suspensions consideration take benefit may assume strict evaluation parts simplify analysis 
practice reduced overhead 
unfortunately practice means may vary significantly depending usage scenario 
try distinguish ciency di erent data structures benchmarks limit asymptotic bounds 
users extremely concerned performance may try di erent implementations application easy provide interface tool specifically designed benchmark data structures 
allows benchmark data structures automatically generated datatype usage graphs parametrised relative frequency di erent operations degree persistency exploited 
current state edison section intended give overview edison library current state development 
framework described manual oka important aspects summarised 
focus laid existing implementations mentioned briefly manual 
type classes provided framework divided categories sequences stacks queues deques collections sets bags priority queues associative collections maps priority queues distinct priorities 
sequences sequences store elements order insertion stacks queues deques 
class sequences edison sequence 
implementations provide functionality di ering operations supported ciently 
example queues edison allow reading writing front rear reading front writing rear turn cient 
instance sequence data type instantiate functor monadplus monad class functor monadplus sequence fmap functor simply edison generalised map monadplus easily instantiated return single xs concatmap xs mplus append mzero empty furthermore elements eq class sequence eq likewise show 
implementations sequences section implementations exist 
furthermore section implementations mentioned manual 
main concepts implementations described detailed analysis runtime complexities carried chapter 
detailed discussion underlying principles left cited papers 
simplest implementation sequence abstraction 
just uses built haskell lists instance sequence functions prelude straight forward implementations functionality prelude 
fromlist time complexities considered default values implementations compared 
fromlist trivial default value 
common functional implementation queues described hood melville hm named oka :10.1.1.54.6229
uses lists internally front reversed order rear maintaining invariant front list may empty rear list empty 
requires rear list reversed new front list gets empty amortised time bounds standard queue operations lhead ltail snoc non persistently 
tolist setting queue longer includes sequence operations queue non persistently amortised time complexity 
changing invariant enforce front list long rear list exploiting lazy evaluation okasaki oka oka managed queues cient persistently 
comes cost additional overhead 
separately stores sizes lists size inbounds operations accelerated implementation 
mye close relative ordinary list addition normal tail node maintains jump tail possible skip elements traversing list 
determined way possible reach position list log time accelerating lookup related operations size rhead essentially just traverse list 
oka oka takes di erent approach allow lookup update related operations log time 
elements stored list complete binary trees increasing size trees allowed size 
length list depth largest tree log permitting demanded time complexity accessing ith element preserving cons 
oka hybrid structure tree list :10.1.1.54.6229
tail list constructor list longer list list 
allow number elements stored additional constructor exists takes head 
resulting structure seen complete binary tree inner nodes may may contain elements share property level 
giving log time lookup update unfortunately approach results log time cons 
noted consecutive calls cons total time complexity log 
represents sequence binary leaf tree allows cons snoc append constant time slows lhead ltail runs amortised 
suggested hoo braun trees balanced binary trees implement flexible arrays operations dealing element run logarithmic time 
okasaki oka developed implementations size copy run log log respectively fromlist runs time 
adaptors edison presently contains adaptors modify behaviour sequence implementation 
sized module sized adaptor stores size underlying sequence explicitly ering constant time size inbounds adding small overhead operations change size 
rev module rev uses underlying sequence reversed order replaces calls cons snoc lhead rhead vice versa 
additionally size stored explicitly sized adaptor 
quickcheck properties axioms stated user manual appropriate quickcheck properties specified supplementary file hs 
properties stated means fromlist tolist constructs direct translations axioms 
furthermore implementation tested selected import statement hs file changed new implementation tested 
collections edison contains total classes collections di ering support uniqueness sets ordering priority queues observability see manual detailed discussion observability 
class eq class ord class setx class setx class coll class coll class coll setx set class set ordset table gives overview collection classes supporting observability non observable classes appended name 
note data types instantiating collection classes need instantiate classes outside hierarchy contrary sequences type elements restricted class eq possibly ord necessary element type appear class signature 
unordered ordered multi coll unique set ordset table collection classes supported properties implementations edison currently contains implementations heaps instances implementation ordset 
noted currently available implementations require stored elements instances ord 
implementation set ordset class 
uses simple unbalanced binary tree runtime complexity operations 
instance uses heap ordered binary tree maintaining leftist property node right spine left child long right child 
allows merge operations log oka :10.1.1.54.6229
implementation resembles binary splay tree slight di erence functional setting queries course restructure tree 
consequence operations logarithmic runtime time complexity 
furthermore persistently restructuring ect yielding linear runtimes operations 
non persistently caching minimum element cient due low overheads oka :10.1.1.54.6229
pairing heaps described heap ordered multiway trees linking subtrees deletemin carried special way constant amortised runtime main heap operations conjectured logarithmic time bounds proven 
decrease key operation part edison framework fredman showed fre performed constant amortised time 
operations contained edison conjectured runtimes proven 
adaption pairing heap utilising lazy evaluation maintain amortised time bounds persistent usage 
functional adaption self adjusting heap described st 
similar maintaining strict leftist property uses simple restructuring heuristic reduce length right spine su cient achieve amortised time bounds 
adaptors adaptor available collection classes min module 
instances results explicitly stores minimum element 
useful conjuction data structures expensive operation 
quickcheck properties files quickcheck properties ordset exist 
includes operations defined collections necessary properties specified 
edison manual states axioms collection operations quickcheck properties considered normative 
associative collections classes associative collections edison similar plain collections di erent classes distinguished properties ordering uniqueness observability respect keys elements course observable class eq class ord class class class assoc class assoc class assoc class table gives overview observable association classes non observable classes appended name 
unordered ordered multi assoc unique table associative collection classes supported properties said elements collections holds keys associations type stored elements completely unrestricted occur class signature 
implementations currently edison contains implementations associative collections instances 
assoclist assoclist simply resembles list key element pairs 
duplicate keys kept occurrence list latest insertion considered valid 
allows insert performed results curious property size data structure bounded number logically contained bindings 
especially problematic operations take time linear physical logical size assoclist 
patricia trees mor og derived binary tries collapsing paths common bit subsequences single node 
maximum depth tree number bits key average depth reduced slightly speeds insert lookup importantly union significantly accelerated 
edison fixed key type int processes bits keys little endian order 
type signatures class definitions force data type take key type parameter instances defined int key types 
quickcheck properties quickcheck properties associative collections implemented edison manual state axioms 
operations described manual intended behaviour easily derived names types operations comparison respective collection operations 
edison provides nice framework classes lacks implementations 
furthermore existing implementations documented su ciently 
functional behaviour defined respective type classes described manual runtime complexities central point library concerned ciency documented operations sequence implementations 
worse implementations collection association classes mentioned manual 
useful practice user provided implementations especially exist far comprehensive overview runtime complexities decision easy implementation 
unfortunately reaching goal full breadth scope project 
focus sequence part 
part evolved far beneficial focus neglected ones providing basics 
bringing part point considered ready shipping potentially yield insights useful basic stages parts prefer 
chapter runtime complexity analysis existing implementations unfortunately edison manual gives runtime complexities operations sequence implementation 
section analyse operations examined publications implementations 
operations runtime complexity trivial see exclude operations detailed analysis 
summarised table 
empty single null lview maximum lhead ltail rview maximum rhead rtail map foldr foldl foldr foldl reducer reduce tabulate filter partition takewhile dropwhile time needed application function argument adjust update plus lookup zip zip zipwith zipwith zip plus nmin unzip unzip table common time complexities sequence implementations code fragments taken edison chris okasaki 
functions implemented defaults replaced respective definitions defaults 
note variables text function arguments follow appendix may di er ones code general meaning apparent context 
take account lists lazy perform analysis banker method invariant cumulative debt nodes node free debits 
cases analysis trivial just state results cons lhead ltail fromlist 
snoc rhead rtail size reverse unzip 
append reverseonto 
concat 
concatmap 
inbounds lookup update take drop splitat 
subseq 
zip nmin 
runtime complexity fact done assuming strictness 
profit laziness copy constructor leave debits creates undischarged amortised runtime 
hand consistent implementations tolist return list free debits therefor discharge debits resulting linear amortised runtime 
known functional queue implementation front rear list proposed hm 
shown oka physicist banker method lhead ltail snoc run amortised non persistently :10.1.1.54.6229
physicist method analyse remaining operations potential length rear list 
cons adds element front queue constant time ect potential amortised runtime 
queues appended potential second preserved total potential reduced length rear list 
pays cost reverseonto leaving runs time linear length front list 
argument reverseonto exchanged holds queue reverseonto operation 
queues non empty rear list rhead rtail reverse obviously run 
respective operation front list called takes potential remains unchanged giving amortised runtime 
determining size queue needs determine length lists take time amortised 
fromlist obviously runs tolist needs reverse rear list non empty 
data seq invariant front empty rear empty cons xs ys xs ys append xs ys xs ys xs reverseonto ys xs ys rhead xs ys rhead error rhead empty sequence rhead xs rhead xs rtail xs ys xs ys rtail rtail xs rtail xs size xs ys length xs length ys reverse xs reverse xs reverse xs ys ys xs reverseonto xs ys xs ys ys reverseonto xs xs ys fromlist xs xs tolist xs xs tolist xs ys xs reverse ys concat foldr append empty concatmap foldr append empty copy fromlist copy take fromlist take tolist drop fromlist drop tolist splitat take drop subseq xs take drop xs inbounds lookup adjust xs fromlist adjust tolist xs update zip xs ys fromlist zip tolist xs tolist ys unzip listing analysed functions obviously concat requires foldr traverse queue plus appends performed total 
holds concatmap additionally applied times 
perform analysis assuming strictness completely account complete evaluation list copy operation yielding runtime copy 
take drop operate conversion list back 
reduces potential zero paying reverse 
furthermore index lies front list take partially evaluated yielding amortised runtime 
unfortunately true drop runtime complexity 
implies course splitat runs 
subseq things slightly di erent need elements result drop necessarily need completely evaluate steps drop steps take 
furthermore tolist inside take trivial case rear list empty contribute constant runtime 
likewise element drop needed 
return new queue reduce potential complexity reverse dominates runtime 
course case lookup inbounds internally 
remaining functions update zip unzip keep elements queue resulting front list evaluate complete run 
zips shortest queue deciding 
analysis falls apart persistent usage main point operations takes time rotation operations constant time rotation needed 
persistent usage simply invoke expensive operation ltail queue element front list allowed original queue doing ltail 
modifying exploit okasaki overcome problem shown maintains constant amortised runtime lhead ltail snoc persistently oka :10.1.1.54.6229
analysis remaining functions follow approach banker method cumulative debits elements front list hold min 
debits allowed rear list 
obviously cons runs constant time maintains debit invariant 
inside append places debit element xs elements resulting front list reverseonto places ys debits element addition debits inherited original queues 
obviously xs ys xs ys xs ys xs ys su cient discharge debits reestablish debit invariant yielding amortised runtime 
shown similar argument reverseonto 
analysis rhead rtail consider expensive cases rear list empty 
data seq int int invariant front long rear xs ys xs reverse ys xs ys cons xs ys xs ys append xs ys xs ys xs reverseonto ys xs ys reverseonto xs ys xs ys ys reverseonto xs xs ys rhead xs ys rhead error rhead empty sequence rhead xs rhead xs rtail xs ys xs ys dec rtail empty case rtail xs dec rtail xs size xs ys inbounds reverse xs ys ys xs fromlist xs length xs xs tolist xs ys xs xs reverse ys copy copy lookup xs ys idx idx lookup ys idx listing analysed functions part case respective list function called 
result list rtail monolithic debits discharged immediately giving linear amortised runtime operations 
explicitly stored lengths lists size inbounds obviously run 
reverse operation runs easily seen considering worst case rear list empty 
front list reverse created debits discharged immediately 
conversion list requires length list determined fromlist time complexity 
reverse conversion list need total addition debits discharged 
contrary case copy constructor leave debits front list runs amortised 
lookup family operations update directly call corresponding list function respective list 
index lies front queue obviously results time complexity 

index take lies front list call list take takes steps 
additionally necessary discharge debits may total debits elements front list total number limited index lies rear list drop obviously runs preserves debit invariant 
drop distinguish cases index lies front list rotation needed index lies front list rotation needed index lies rear list 
case list drop requires steps discharge debits elements additional debits resulting front list index shift 
rotation needed know drop number debits front list bounded discharge perform list drop 
rotation places debit nodes new front list 
reestablish discharge debit node 
obviously su cient discharge debits ith node reestablish debit invariant 
index lies rear list list take reverse run require debits discharged immediately arrive amortised runtime complexity 
combining arguments take drop easy see splitat amortised 
follows directly subseq runs 
concat directly relies append obviously runs 
similarly concatmap requires perform appends addition time required applying times 
zip family operations uses list representation internally 
noted nmin length shortest queue elements queue accessed reverse tolist forced queues longer nmin establish amortised runtime complexity nmin 
unzip operations trivially run 
update idx xs ys idx idx update idx xs ys idx xs update ys take len xs ys len len empty len take len xs len len len xs drop len ys len drop len xs ys len len len drop len xs ys len len len empty len reverse take len ys splitat idx xs ys idx idx empty xs xs splitat idx xs idx xs idx xs ys idx idx idx empty ys ys splitat idx ys xs ys idx idx reverse ys subseq len xs take len drop xs concat foldr append empty concatmap foldr append empty zip xs ys fromlist zip tolist xs tolist ys unzip listing analysed functions part similar ordinary list addition normal tail node contains additional jump tail points elements list number elements skipped jump tail 
shown myers mye jump tails constructed right way possible reach element log steps operations inherit runtime complexity normal list 
particular myers considers cons ltail runtime lookup runtime log size 
uses slightly di erent representation allows size determined constant time possible implementation 
argument lookup easily adopted inbounds drop 
furthermore trivial see operations bounded give slightly better bound min log 
discuss operations essentially normal lists adding constant overhead maintain jump tails leaving deserve analysis 
data seq int seq seq jump xs xs size xs go xs go int go xs xs size xs update xs upd xs upd upd xs xs xs xs upd xs ys ys ys jump ys ys upd xs fromlist foldr cons empty tolist foldr copy fromlist copy subseq len xs take len drop xs listing analysed functions size recurses jump tail shortest path list runs log 
unfortunately argument lookup hold update rebuild list ith element takes steps 
conversion list performed applying foldr cons yielding linear runtime 
note list returned tolist evaluated incrementally 
obviously copy takes 
subseq combination take drop runs min log 
data tree tree tree deriving eq data seq int tree seq deriving eq copy int half child xs xs half child xs xs child rhead error rhead empty sequence rhead rhead xs rhead xs rtail listing analysed functions part explained okasaki oka oka skew binary random access list preserves constant time bounds cons lhead ltail giving complexity lookup update operations min log 
resembles list pre ordered complete binary trees strictly increasing size may size 
data structure rely lazy evaluation analyse remaining function evaluation strict 
copy constructor works phases 
smallest complete tree containing elements log constructed 
children node level constructed constant time time logarithmic 
second tree subtrees selected put sequence total number elements gets correct 
tree level taken exception smallest taken tree taken twice obviously performed logarithmic time total runtime complexity copy log 
lookup runs log course rhead 
rtail hand sequence traversed reconstructed omitting element requiring linear time 
determine size su cient add sizes trees explicitly stored list 
length list bounded log time size 
reverseonto traverses complete sequence reversed adds elements second sequence cons runs linear runtime 
obviously reverse runs 
due tree sizes stored list inbounds traverse tree determine index lies inside 
length list tree including index bounded log runtime inbounds 
proceeding similar lookup drop traverses list dropping unneeded trees traverses tree index lies 
step sub function descends level skips element constant time total runtime bounded min log lookup 
snoc append foldr traverse sequence front part result successively cons respective elements 
cons runs total runtime linear 
holds fromlist tolist 
noted laziness allows list generated tolist built incrementally 
concat concatmap incarnation foldr scheme append cons 
appends take time linear length result overhead foldr linear length input yielding usual runtime plus time apply concatmap 
observing tolist incremental follows directly take runs splitat 
furthermore subseq runs min log sum runtimes take drop 
similarly zips run nmin 
size xs sz xs sz int sz xs sz xs reverseonto ys ys reverseonto xs ys reverseonto xs ys ys cons ys ys cons ys reverse reverseonto empty inbounds xs inb xs inb false inb xs inb xs drop xs xs drp xs drp drp xs drp xs xs xs xs error drop bug impossible case xs xs xs half snoc foldr cons single append null foldr cons fromlist foldr cons empty tolist foldr concat foldr append empty concatmap foldr append empty take fromlist take tolist split take drop subseq len xs take len drop xs zip xs ys fromlist zip tolist xs tolist ys unzip listing analysed functions part hybrid data structure list tree 
constructors similar list tail seq seq results binary tree shape 
able store number elements inner nodes necessarily contain elements list perspective constructor tail head 
perspective see head elements odd constructor complete binary trees represented nested pairs quite similar 
argued okasaki oka gives logarithmic runtimes cons lhead ltail lookup :10.1.1.54.6229
laziness restrict runtime analysis strict worst case analysis 
worst case append obviously relies foldr 
needs just foldr traverse sequence plus time needed cons 
mentioned cons takes logarithmic time worst case average successive calls cons better 
half calls cons take step quarter average time cons converges 
small logarithmic case cons may triggered take account arrive total runtime complexity log append 
holds course reverseonto 
follows directly reverse runs 
rhead size recursively traverse list length logarithmic number elements runtime complexity 
unfortunately rtail construct result element element linear runtime 
similar copy constructor take advantage fact subtrees level achieve log runtime 
observing inbounds halves argument recursive call easy see runs log 
conversion list performed foldr 
argument append successive cons invocations fromlist constant average time start empty get linear runtime total 
noted tolist evaluated incrementally 
may take log steps element determined usual 
observing easy see worst case take call runs log 
analysis drop trickier ones 
easy see maximum recursion depth log step ltail may called requiring log steps 
show drop runs log 
order see consider result looks performing recursive 
consists log constructors possibly ltail ltail ltail rest rest remaining part recursion terminates assuming 
observe arbitrary number successive evens possible 
performing step ltail results sake brevity ignore elements stored odd constructors fact ltail call recursively lview 
data seq seq odd seq deriving eq ps ps append xs xs append xs ys case xs ys append odd odd append append xs ys odd foldr cons ys xs reverseonto xs ys foldl flip cons ys xs reverse reverseonto empty rhead error rhead empty sequence rhead ps snd rhead ps rhead odd rhead odd ps snd rhead ps rtail size size ps size ps size odd ps size ps copy cp cp int seq cp odd odd cp half cp half inbounds xs inb xs inb seq int bool inb false inb ps inb ps half inb odd ps inb ps half fromlist foldr cons empty tolist foldr listing analysed functions part take xs tak xs tak int seq seq tak xs tak tak ps tak half ps tak odd ps odd odd tak half ps tak xs xs drop xs xs drp xs drp int seq seq drp xs xs drp drp ps drp half ps ltail drp half ps drp odd ps odd drp half ps ltail drp half ps splitat take drop subseq len xs take len drop xs snoc foldr cons single concat foldr append empty concatmap foldr append empty zip xs ys fromlist zip tolist xs tolist ys unzip listing analysed functions part odd ltail odd ltail odd ltail rest observe ltail produces odd constructor recursion outer ltail 
total runtime inner ltail bounded log 
length rest log log complexity inner ltail giving total runtime log plus log log recursion drp 
considering runtimes take drop easy see splitat runs logn subseq log 
account average time successive cons constant easily establish linear runtime snoc 
importantly concat starts empty sequence long chains successive cons operations generated logarithmic component total runtime case append just linear length output 
account time foldr linear input length gives usual concat 
consideration runtime tolist especially evaluation element may take log zip operations obviously take nmin log nmax 
unzip operations run usual 
uses binary leaf tree represent sequence 
unfortunately okasaki gives literature runtime basic operations analysed 
hint edison manual states constant runtime snoc append linear runtime lview ltail rview rtail practice 
physicists method non persistent usage perform detailed analysis establish ltail fact runs amortised 
potential defined follows leaf node max inner node children largest path root leaf number left branches minus number right branches taken cons snoc append clearly run 
merely special cases focus change potential append 
joining trees total potential obviously join 
change max yielding desired constant amortised runtime 
lhead traverse left spine tree length change potential needs runtime 
ltail traverse left spine restructures tree particular performs right rotations root possible left spine length 
determine change potential rotation right rotation causes look single rotation consequences rotations 
depicts right rotation 
potential rotation max max max potential max max max data seq seq seq cons cons xs xs snoc snoc xs xs append ys ys append xs xs append xs ys xs ys lhead error lhead empty sequence lhead lhead xs ys lhead xs ltail ltail ltail xs ys ltl xs ys ltl zs error ltl bug ltl zs zs ltl xs ys zs ltl xs ys zs rhead error rhead empty sequence rhead rhead xs ys rhead ys rtail rtail rtail xs ys rtl xs ys rtl xs ys zs xs ys rtl zs rtl xs ys xs ys rtl xs xs size xs sz xs int sz sz int sz xs ys sz xs sz ys reverse xs ys reverse ys reverse xs reverse xs xs reverseonto append reverse listing analysed functions part di erentiate di erent cases depending terms original potential constituted maximum 
case obviously potential decreased 
case max potential reduced case 
max max max know rotation case case max case easy see potential reduced 
furthermore see max max consecutive rotations case important insight call ltail case occur rotation decrease potential takes place 
final removal head element caused increase potential bounded get constant amortised runtime ltail 
exception rule lview runs take advantage lhead 
rhead directly corresponds lhead traverses right spine runs rtail substantially di erent ltail 
performs rotations level recursive call performed new root new right child 
left rotation increases potential second node right spine rotation performed total runtime increase potential 
size operation traverse tree runs 
holds reverse consider change potential 
easy see worst case occurs tree inner nodes right spine reversal consists left spine 
increase potential 
considering obviously reverseonto runs 
tolist tree traversed essentially way size resulting amortised runtime 
unfortunately reaching element take exploit incrementality 
data structures working trees th copy operation run log argument halved recursive call 
easy see potential resulting tree log yielding logarithmic amortised runtime 
concat concatmap foldr results fold application append 
append runs amortised concat amortised runtime concatmap invocation taken account dominate total runtime 
cons runs fromlist obviously runs 
drop take run amortised ltail lview cons internally run 
splitat bit careful return new sequences consider sum potentials 
front part constructed series cons potential maintain amortised runtime splitat 
subseq amortised runtime follows directly take drop 
lookup operations inbounds drop try access demanded element 
result new simply rely amortised cost drop 
contrary accessing element take 
analysis ensure total runtime access ith element bounded 
hand update return new sequence adding amortised runtimes splitat append easily arrive amortised runtime 
zip family operations uses lview cons decompose inputs construct output 
run amortised applied nmin times total amortised runtime 
similarly foldr traverse input cons construct output amortised runtime 
tolist xs tol xs tol rest rest tol rest rest tol xs ys rest tol xs tol ys rest copy cpy cpy xs cpy half xs xs xs cpy half xs xs concat foldr append empty concatmap foldr append empty fromlist foldr cons empty take drop splitat subseq len xs take len drop xs inbounds lookup update zip unzip listing analysed functions part uses braun trees strictly balanced variant binary trees represent sequences proposed hoo 
shown cons ltail lookup update run log worst case 
shape tree elements independent total number elements furthermore easy see lookup update better bound log 
holds inbounds proceeds way lookup find requested element possible 
runtime complexities snoc hoo assume explicitly stored sizes node implementation feature 
size operation runs log derived okasaki oka furthermore implementation copy running log fromlist linear runtime 
suggests inverting obtain tolist linear runtime exactly way implemented 
mentioned log bound snoc hoo assumes known sizes 
implementation size determined log appropriate position tree reached log 
size operation dominates runtime snoc log 
rtail operation proceeds pretty way requires log 
similarly rhead uses size determine index element calls lookup size determines runtime 
append operations recurses left sequence way calls twice half length left sequence 
obviously amounts total recursive invocations 
step cons takes time log yielding total runtime log 
follows directly concat runs max log max log log 
append take calls twice halved argument call expensive operation runtime complexity 
hand drop call combine step takes log time requires log time total 
easily seen splitat subseq run log log respectively 
reverse operation looks quite determining runtime complexity poses problems obviously sub functions call times halved arguments starting total size sequence total runtime linear 
combining reverse append yields log runtime complexity reverseonto 
zip operations recurse trees shortest completed run nmin 
traverse tree similar fashion linear runtime 
combine integral part ltail analysed hoo 
data seq seq seq deriving eq snoc ys size ys ys single odd half half exported odd half half rtail rtail xs size xs xs rhead error rhead empty sequence rhead xs lookup xs size xs append xs xs append xs ys app size xs xs ys app xs ys ys app xs xs app odd app cons app app app cons half concat foldr append empty concatmap foldr append empty take xs ta xs ta ta odd ta ta ta ta half listing analysed functions part exported combine combine combine drop xs xs dr xs dr dr odd combine dr dr combine dr dr half splitat take drop subseq len xs take len drop xs reverse xs rev size xs xs rev xs xs rev odd rev rev rev rev half similarly rev rev rev reverseonto append reverse zip zip zip zip unzip unzip unzip unzip listing analysed functions part chapter new implementations quickcheck properties sequences edison comes file hs defines quickcheck properties sequence operations 
unfortunately flaws monomorphic check preservation structural invariant 
monomorphic means properties defined type seq data structure defined importing respective module hs file changed implementation tested 
checking structural invariant added assuming respective module exports property prop inv seq bool checking property holds modification beneficial redesign thing polymorphic function performs necessary tests data structure defined argument 
allow invariant tested introduce new type class sequences checked instances 
furthermore introduce generator function delivers arbitrary sequence contents checking equality operator see 
class sequence checkablesequence invariant bool gen tempting write ordinary arbitrary function terms arbitrary arbitrary generating arbitrary list constructing sequence containing elements 
possible problems writing arbitrary generators care taken complete construct allowed instance data structure 
easier verified explicit arbitrary typically complicated 
second may beneficial generate elements size parameter suggests avoid trivial cases especially tree structures arbitrary taken recursive steps 
done help lot ahead planning recursion needed resulting complication 
properties follow approach somewhat di erent looked hs 
define function terms lview empty cons possibly functions checked compare results definition implementation tested verify invariant case new sequence results 
noted empty cons correspond list constructors furthermore lview corresponds pattern matching possible lists 
fairly easy adapt list representations functions definitions alas looking little pattern matching replaced case statements 
testing lview empty cons looks little di erent 
lview assume correct definition gives sequence interpretation underlying data structure defining head tail 
empty cons compatible interpretation check giving definitions 
check thing lview tail returns fulfills invariant prop lview checkablesequence eq bool prop lview xs case lview xs true just xs invariant xs verify empty fulfills invariant lview empty yields 
unfortunately construct way telling property data type operate quantify sequences 
explicitly passing invariant argument resolve overloading 
constructor functions single copy tabulate 
prop empty sequence eq eq bool bool prop empty inv inv xs case lview xs true just false xs empty things worthwhile noticing 
variable quantify perfectly ok quickcheck just check thing times 
second clause important occur similarly properties 
replacing xs empty case clause code fragment give type error polymorphism resolved specific type 
clause take advantage monomorphism restriction forces xs type occurrence type invariant fix type xs 
order check cons equality testing useful define terms lview test 
definition performs element wise equality testing simultaneous recursion sequences 
sequence eq bool xs ys case lview xs case lview ys true just false just xs case lview ys false just ys xs ys new sequence generated resulting property simply comparison return values definition implementation 
prop equals sequence eq eq bool prop equals xs ys xs ys xs ys way testing equality operator poses problem su cient prove xs ys xs impl ys xs def ys perform automated testing generating limited number instances xs ys 
highly sequences generated equal short cases 
compensate check prop equals second time sequences generated equal 
order able need special generator takes list elements generates sequence containing respective elements arbitrary internal structure 
checkablesequence class contains second function 
equality easy test cons correct verifying resulting sequence satisfies invariant lview undoes ect 
prop cons checkablesequence eq eq bool prop cons xs lview xxs just xs invariant xxs xxs cons xs remaining definitions properties straight forward require explanation 
see appendix complete source code 
lhead may invoked non empty sequences ensure conditional property feature 
nice possible check lhead produces error invoked empty list unfortunately terminate test bench 
holds course functions requiring non empty sequence 
prop lhead sequence eq eq property prop lhead xs null xs lhead xs xs provide user feedback arbitrary function produces sequences su cient complexity collect sizes test data checking size 
prop size sequence eq eq property prop size xs collect size xs size xs xs reduce family operations return unambiguously defined results function argument represents associative function case result equal fold yield order function applied di er 
simply appropriate fold definition 
sequence foldr quickcheck provides way generate arbitrary functions possible quantify functions fold operations easy way quantify associative functions 
circumvent function show su cient sense testing property prove proven associative function 
wadler wad calls parametricity derive sets representing types function operator ax ay holds reducer xs reducer au xs element wise application map see appendix 
choose lists elements append operation 
furthermore define definition obviously ax ay associative leave decomposition multiple appends ambiguous ecting result 
equivalence derive results arbitrary types associative functions just concentrating appending lists starting singletons obviously 
prop reducer sequence eq eq arbitrary bool prop reducer xs xs map xs reducer xs xs argument holds easily adapted reduce 
generator type element restrict type arguments zip operations properties type 
prop zipwith checkablesequence eq eq bool prop zipwith xs ys invariant xys xys xs ys xys zipwith xs ys able quantify explicitly seq generate arguments unzip operations way implicit quantification 
enforces resolve type way take invariant extra argument 
prop unzip sequence eq eq bool bool prop unzip inv xys inv xs inv ys xs ys xys xs ys unzip xys test properties data type collect function parameterized type checks 
just add invariant additional argument just resolve overloading get meaningful results invariant argument checkablesequence class 
typical invocation look invariant seq int bool start checking arbitrary generate sequences fulfill invariant 
defines type generator seqs enforced monomorphic function 
inv putstr checking arbitrary quickcheck forall seqs inv putstr checking quickcheck xs xs property inv xs remaining properties follow pattern explicit quantification implicit quantification invariant inv extra argument 
putstr checking lview quickcheck forall seqs prop lview putstr checking empty quickcheck prop empty inv putstr checking quickcheck forall seqs prop equals exception equality test special generator generate sequences containing elements 
putstr checking equal cases quickcheck xs xs xs property prop equals testing concatmap sized generator function argument avoid producing large sequences 
putstr checking concatmap quickcheck forall seqs xs forall gen prop concatmap xs checks refer appendix skip provide new insights 
seqs arbitrary xs xs xs prop forall xs prop gen arbitrary gen gen sized resize min arbitrary implementations described contain function invariant seq int bool simplify testing calling su cient 
sequence operations polymorphic type element easy see wadler parametricity theorem property holds element type holds type lower cardinality 
furthermore perform limited number tests di erence types infinite domains su ciently large finite domains int irrelevant 
justifies test element type int confident properties hold types 
simple deque implementation suggested hoo similar similar properties constant amortised time bounds typical deque operations non persistently 
data type consists lists front rear list 
data seq contrary lists handled symmetrically maintained invariant deque contains elements lists non empty 
reduce number cases distinguished arbitrarily demand element singleton deque stored front list 
invariant seq bool invariant true empty invariant true element invariant true elements invariant false runtime analysis carried assuming strictness applying physicist method potential defined di erence length lists 
showed potential empty ltail rtail cons snoc reverse run amortised 
ltail rtail operations literally translated haskell article 
tails define function front rear list creates deque fulfils invariant 
maked xs xs reverse ys xs ys splitat size xs div xs maked ys reverse xs ys ys xs splitat size ys div ys maked xs ys xs ys cases handle situation list empty list split half halves reversed 
length list odd split performed front list gets element longer rear handle singleton case demanded 
runtime complexity obviously linear length nonempty list resulting potential 
third case lists non empty unaltered requires constant time 
calculation size non empty list avoidable maintaining separate size fields datatype 
approach introduce additional overhead operations ectively decreasing performance mainly operations add remove single elements 
basic constructors straight forward obviously run result potential zero respectively 
empty single cons snoc operations similarly easy implement 
cons xs xs xs contains zero element cons xs ys xs ys snoc ys empty snoc xs ys xs ys lists non empty new element added respective list constant time increasing potential 
rear list empty cons invoked old front list new rear list reversing unnecessary front list element new front list singleton list containing new element 
empty front list snoc invoked things easier rear list guaranteed empty 
cases require constant time increase potential 
append operation distinguishes cases depending second deque 
append append snoc append xs ys xs ys xs reverseonto ys xs ys second deque contains element append degenerates identity snoc respectively yielding constant runtime 
non trivial case obviously requires steps total xs append ys reverseonto xs ys size deque 
initial potential xs ys xs ys resulting potential xs ys xs ys xs ys xs ys xs ys change potential bounded xs ys giving amortised time complexity 
accessing left element requires distinction cases 
lview lview ys just maked ys lview xs ys just xs ys lhead error lhead empty sequence lhead ltail ltail ys maked ys ltail xs ys xs ys front list empty deque empty 
front list contains exactly element demanded calculating tail requires call maked reestablish invariant 
lhead produce tail distinguish case 
front list contains elements tail list new front contradict invariant 
second case operations amortised runtime obviously require constant runtime change potential 
second case needs special attention 
call maked runtime complexity potential reduced compensating linear runtime giving amortised runtime 
accessing right element similar 
rview rview just rview xs ys just maked xs ys rhead error rhead empty sequence rhead rhead rtail rear empty element deque rtail xs ys maked xs ys distinguished cases slightly di erent due asymmetrical handling singleton deques argument easily adapted establish constant amortised runtime operations 
checking deque contains elements obviously run constant time 
null true null false calculation size deque requires determining length lists resulting runtime complexity 
size xs ys length xs length ys symmetry reversing deque fairly simple 
reverse xs reverse xs ys ys xs deque contains elements list non empty simply exchanged 
deque contains zero element equal reverse 
cases obviously run constant time leave potential unaltered yielding constant amortised runtime 
reverseonto operation similar append 
reverseonto xs ys reverse reverseonto xs ys snoc reverse reverseonto xs ys xs ys ys reverseonto xs xs ys considering reverse runs non trivial case equal append exchange xs ys easily seen argument similar append amortised runtime turns 
helper function conversion list deque straight forward conversion back list 
fromlist xs maked xs tolist xs xs tolist xs ys xs reverse ys operations clearly take time noted tolist returns result calculated incrementally front list lazy manner 
map fold reduce family operations simply performed calling appropriate list functions front rear list 
required runtime mainly determined applying function argument times 
map xs ys map xs map ys foldr xs ys foldr foldl flip ys xs foldl xs ys foldr flip foldl xs ys foldr error foldr empty sequence foldr foldr xs ys foldr foldl flip ys xs foldl error foldl empty sequence foldl xs ys foldr flip foldl xs ys reducer xs ys reducer flip ys xs xs ys reducer flip xs ys reduce error reduce empty sequence reduce xs ys reducer flip reduce xs ys splitting deque specified position performed repeated application lview cons 
lview cons constant amortised runtime called times total amortised runtime 
splitat splitat empty just lview splitat cons copy constructor easily implemented copy lists generate front lists suitable sizes 
copy copy div copy div required runtime potential resulting deque amortised runtime 
similarly tabulate implemented constructing deque appropriately enumerated lists applying map 
tabulate empty div map application times predominant part required runtime 
map filter partition operations carried directly respective list operations 
cause involved lists empty call maked required 
runtime maked possible increase potential number applications filter xs ys maked filter xs filter ys partition xs ys maked maked partition xs partition ys check certain index deque done checking catenation front rear list reversing rear necessary change length 
observing incrementality implementation time complexity 
inbounds xs ys inbounds xs ys remaining operations implemented defaults 
concatenating multiple deques performed right associatively appending foldr 
concat concatmap foldr runs plus time needed appends length resulting deque plus time needed map concatmap giving total runtime 
splitat take drop implemented repeated calls lview ltail respectively 
lview ltail run constant amortised time obviously results amortised time complexity 
take drop drop easy implement lookup derivatives 
lookup unfortunately original deque may amortised runtime analysis done ltail drop relied non persistent usage transferred operations 
index happens lie rear list operations take 
case adjust update implemented splitting deque updating element appending parts 
adjust update splitting appending take time amortised total amortised time complexity 
operations utilise tolist function 
conversion list back case map applying times determines runtime operations 
drop take easy implement subseq 
total amortised time complexity drop plus take subseq 
subseq operations traverse deque repeated application lview 
accepted element takes constant amortised time lview cons applicable plus time required evaluation predicate elements accepted 
takewhile dropwhile zip unzip operations operate conversion lists internally 
zip zip zip zipwith zipwith zipwith unzip unzip unzip zips means longest deque determines runtime front list shorter shortest deque reverse forced 
assume length longer deque times shorter deque 
front list shorter shorter deque potential longer deque minimum length rear list maximum length front list 
potential resulting deque decreased amortised runtime min 
argument holds case deques 
amortised runtime complexity trivially 
generating arbitrary performed generating arbitrary front rear lists 
empty special attention required violate invariant 
specifically empty list rear list list shortened element 
lists empty resulting deque empty list empty resulting deque contains exactly element lists non empty arbitrary length elements preserved 
way possible generated empty case generated lists empty element case exactly list empty arbitrary distribution elements front rear list lists non empty resulting queue contains elements 
instance arbitrary arbitrary seq arbitrary xs arbitrary ys arbitrary return null xs take ys null ys take xs xs ys generating list elements distinguishes cases elements zero passed stored front list directly enforced invariant 
input list split random position parts non empty acquire front rear list respectively 
easy see possible generated non trivial case element splitting done arbitrary position allowed range 
instance checkablesequence seq xs len size xs len return xs lenf choose len splitat lenf xs return reverse similarly adding symmetry get deque implementation suitable persistent usage adapting maintain symmetric invariant oka oka 
data type deque equal queue front rear list respective lengths 
data seq int int invariant front list long rear length balanced sense particular maintained invariant integer constant 
note implies deque containing elements lists non empty 
specified haskell invariant looks follows invariant seq bool invariant lenf lenr lenf size lenr size lenf lenr lenr lenf operations amortised runtime increases choose int higher values advantage sequences accesses deque fewer rotations executed 
situations may assumed queue implementations may suitable anyway lowest possible value amortised runtime analysis okasaki shows runtime cons snoc ltail rtail reverse uses bankers method lists denotes number debits ith element total debit elements 
maintained debit invariant min cs min max 
note enforces list heads free debits accessed 
start defining helper function slightly adapted check function oka re establish structural invariant truncating longer list half combined length list reversing rest back shorter list :10.1.1.54.6229
maked lenf lenr lenf lenr lenf lenr div lenf lenr take reverse drop lenr lenf lenf lenr div lenf lenr reverse drop take lenf lenr basic constructors trivially maintain structural debit invariant run constant time 
empty single helper function cons snoc equally easy implement oka :10.1.1.54.6229
cons lenf lenr maked lenf lenr snoc lenf lenr maked lenf lenr runtime analysis cons distinguish call maked causes rotation 
increased violating invariant nodes previously min max 
reestablish invariant obviously su cient discharge debit list say 
case rotation forced know cons min max debits discharged 
rotation debit element front list debit elements rear list take append lists incremental plus th node rear list 
resulting debits 
refer lists cons denote lists rotation 
debit invariant reestablished discharging debit head elements lists discharging extra debit rear list giving constant amortised runtime 
symmetry holds snoc 
explicitly stored sizes perform append time linear shorter deques 
append lenf lenr lenf lenr lenf lenr lenf lenr maked lenf lenr lenf reverseonto lenr maked lenf reverseonto lenr lenf lenr analysis assume establish amortised runtime complexity symmetry append obviously run min amortised 
discharge debits bounded furthermore pay costs reverseonto 
remains similar analysis cons distinguish rotation performed 
cons su cient discharge debits resulting lists 
rotation caused know debits bounded min max discharged 
argument similar cons establish debits rotation 
discharging debit front list debits rear list debit invariant reestablished giving total amortised runtime complexity 
accessing element straight forward requires distinction cases deque may empty may contain element rear list front list non empty front list rear list 
note haskell implementations oka incorrect missing second case standard ml ones correct :10.1.1.54.6229
lview lview just empty lview lenf lenr just maked lenf lenr lhead error lhead empty sequence lhead lhead ltail lenf lenr maked lenf lenr ltail empty zero element rview rview just empty rview lenf lenr just maked lenf lenr rhead error rhead empty sequence rhead rhead rtail lenf lenr maked lenf lenr rtail empty zero element symmetry restrict analysis lview family results hold rview family 
head element lists guaranteed free debits lhead clearly runs constant time lview ltail case returned deque empty 
returned deque non empty distinguish rotation required 
debit invariant front list may violated due resulting index shift 
countered discharging debits list 
furthermore min may reduced making necessary discharge debits rear list 
case rotation required lview ltail case debits discharged 
rotation debit element rear list debit elements front list debits th element giving debits 
debit invariant reestablished discharging debit head rear list discharging debits front list 
amortised runtime complexity 
determining size deque simple due explicit size fields obviously runs 
null lenf lenr lenf lenr size lenf lenr lenf lenr reversing deque equally simple structural debit invariant symmetric preserved front rear list exchanged making operation run constant time 
reverse lenf lenr lenr lenf conversion list performed simple call helper function determining length list 
fromlist xs maked length xs xs determining length takes xs steps rotation necessary xs debit element front list xs debits head rear list discharged resulting amortised runtime xs 
conversion list discharge debits deque append reversed rear front list requiring additional steps giving total amortised runtime complexity 
tolist tolist reverse map fold reduce family operations simply performed calling appropriate list functions front rear list 
required runtime mainly determined applying function argument times 
map xs ys map xs map ys foldr xs ys foldr foldl flip ys xs foldl xs ys foldr flip foldl xs ys foldr error foldr empty sequence foldr foldr xs ys foldr foldl flip ys xs foldl error foldl empty sequence foldl foldl xs ys foldr flip foldl xs ys reducer xs ys reducer flip ys xs xs ys reducer flip xs ys reduce error reduce empty sequence reduce reduce xs ys reducer flip reduce xs ys xs ys xs ys idx idx xs ys ys xs idx idx xs ys xs ys idx idx similarly copy tabulate constructors implemented constructing lists appropriately 
copy lenf div lenr lenf lenf copy lenf copy lenr lenr tabulate lenf div lenr lenf lenf map lenf map lenf lenr operations lists build incrementally debit placed element assuming tabulate runs constant time debit invariant established discharging debit list head element curiously yielding constant amortised runtime 
map filter partition operations carried directly respective list operations 
cause structural invariant violated call maked required 
amortised runtime obviously assuming runs constant time 
filter lenf lenr filter filter maked size size partition lenf lenr maked size ft ft rt size rt maked size ff ff rf size rf ft ff partition rt rf partition looking element certain index carried directly looking element respective list determined explicit size fields 
lookup lenf lenr lookup lenr lenf lenf lenr lenr lenf lenf lenr lenr lenf index front list debits elements discharged bounded lookup list takes time 
index lies rear list worst case occurs results looking element rear list necessary discharge debits plus requires time 
ci establish amortised time complexity cases 
holds update adjust plus time execute adjust 
cost list update adjust assigned new debits change asymptotic time complexity old debits discharged anyway 
update lenf lenr lenf update lenr lenr lenf lenf update lenr adjust lenf lenr lenf adjust lenr lenr lenf lenf adjust lenr take operation distinguishes cut index front rear list calls appropriate list function 
take len lenf lenr len empty len lenf maked len take len len lenf lenr len len lenf maked lenf drop lenr len len analyse cases separately 
len list take caused rotation obviously run len 
argued lookup functions list drop runs len leaving cost maked analysed 
rotation forced debits rear list discharged drop cost paid leaving front list len len discharged maintain debit invariant min may reduced len 
rotation performed know original deque case len necessarily integer 
debits front list rotation bounded cx len len discharged 
rotation debits lists len len len 
furthermore discharging debits list heads additional len debits rear list reestablish debit invariant yielding len amortised runtime complexity 
symmetry easily establish len runtime drop 
drop len lenf lenr len len lenf maked lenf len drop len lenr len lenf lenr len len lenf maked take lenr len lenr len empty want establish runtime len 
case index len rear list easy len easily shown upper bound 
case rotation forced debits len elements discharged list drop runs len reestablish debit invariant necessary discharge len debits front list due index shift len debits rear list establishes amortised runtime len 
argument case rotation performed similar ones observing drop len repeated 
note establishes amortised runtime complexity min len len drop symmetry take 
course splitat implemented min len len omitting formal argument 
splitat lenf lenr empty lenf splitat maked maked lenf lenr lenf lenr lenf splitat lenr maked lenf maked lenr empty remaining functions implemented defaults 
concatenating multiple deques performed right associatively appending foldr 
concat concatmap foldr runs plus time needed appends length resulting deque plus time needed map concatmap giving total runtime 
reverse runs reverseonto reduced reverse append running min append 
reverseonto size explicitly stored perform inbounds constant time 
inbounds drop take easy implement subseq 
total amortised time complexity drop plus take subseq 
subseq operations traverse deque repeated application lview 
accepted element takes constant amortised time lview cons applicable plus time required evaluation predicate elements accepted 
takewhile dropwhile zip unzip operations operate conversion lists internally 
zip zip zip zipwith zipwith zipwith unzip unzip unzip reverse longer deque zip forced front list shorter shorter deque bounds length longer deque 
front list tolist incremental amortised runtime complexity zips min 
equality testing done little clever usual comparing sizes involved deques takes constant time 
worst case time linear length course 
instance eq eq seq size size tolist tolist generate arbitrary su cient generate arbitrary front rear lists reduce length longer establish invariant necessary 
lists arbitrary length accepted fulfill invariant obviously allowed generated way 
instance arbitrary arbitrary seq arbitrary arbitrary arbitrary return lenf size lenr size lenf min lenf lenr lenr min lenr lenf lenf take lenf take lenr lenr generating arbitrary elements necessary split input list position parts fulfil invariant 
xs get invariant xs xs xs xs xs xs xs pick random value range select front rear list accordingly 
may allowed range allowed desired length elements generated 
instance checkablesequence seq xs len size xs lenf choose len div len div lenr len lenf splitat lenf xs return lenf reverse lenr design sequence supports catenation constant amortised time preserving constant time bounds basic list operations proposed okasaki oka oka simpler alternative data structures proposed kaplan tarjan kt achieve worst case time bounds 
elements stored multi way tree pre order left right ordering 
store children node queue case 
data seq seq seq structural invariant child nodes 
case occur respective node removed queue children 
invariant seq bool invariant true invariant xs noe xs noe false noe foldr true map noe amortised runtime analysis carried banker method denotes number debits node tree accumulated debits nodes short hand debits tree debit invariants maintained 
number debits individual node exceed node degree 
note sum degrees tree number nodes 
second require depth refer left linear debit invariant 
ensures root free debits 
invariants okasaki shown constant amortised time append ltail 
repeat arguments analyse remaining operations 
usual basic constructors trivial constant time implementations 
empty single empty concatenating easily performed adding second child root 
append xs xs append ys ys append ys snoc ys snoc runs constant amortised time discharge debit create immediately observing node degree decreases need verify left linear debit invariant preserved 
nodes xs trivial index depth remain new debits created 
nodes second list indexes increased xs depth increased accumulated debits increased debits xs get xs xs ys xs depth ys xs depth xs xs depth xs denotes resulting tree 
left linear debit invariant preserved established constant amortised runtime append 
accessing head element easy obviously performed constant time root node guaranteed free debits 
removing little di cult 
solution append children root node depicted 
tail tail operation append commutative order performed influence result 
exploit lazy evaluation beneficial right associatively result incremental traversed left right 
lview lview just foldr append empty lhead error lhead empty sequence lhead ltail ltail foldr append empty way additional debit placed children root node degrees increased exception right child immediately discharge debit placed 
need verify left linear debit invariant preserved 
xs tail xs ith node xs reside jth subtree consider happens node tail performed index decreased depth tree increased accumulated debits increase get xs xs depth xs depth xs depth xs su cient discharge debits restore left linear debit invariant 
access delete right element necessary traverse right spine 
deletion construction resulting nodes little clumsy avoid having empty leaves tree 
occur respective entry removed queue children 
rview rview null just just xs rview just xs rview xs null xs just just snoc xs rhead error rhead empty sequence rhead null rhead rhead rtail rtail null just xs rview xs rtail xs null xs snoc xs accessing right child node runs degree traversing right spine takes degree xs nodes right spine steps addition xs debits discharged yielding linear amortised runtime 
determining list empty easily done constant time pattern matching root node 
null true null false determining size requires complete traversal resulting linear runtime complexity 
size size foldr map size map fold family operations implemented respective queue operations recurse tree 
foldr right element easily determined 
map map map map foldr foldr foldr flip foldr foldl foldl foldl foldl foldl error foldl empty sequence foldl foldl foldl usual runtime mainly determined applying times 
cons snoc simply append singleton list requiring constant amortised time 
cons append single snoc conversion list done consecutive cons result unary tree list root node suspended violating debit invariants yielding constant amortised time 
holds copy tabulate assuming constant runtime function passed 
fromlist copy tabulate conversion list requires debits discharged complete tree traversed linear runtime 
noted operation incremental 
tolist concatenating lists similar happens ltail 
concat major di erence concatenated lists guaranteed nonempty empty ones remain resulting list may cause depth increase stated analysis ltail 
fact number empty lists depth reduced additional debits discharged reestablish left linear debit invariant resulting amortised runtime complexity 
concatmap argument adapted cost application function argument paid resulting amortised runtime complexity linear length input list constant time function argument independent length result 
concatmap reversing list obviously takes accessing element cost left debits occurs node result 
reverse reverseonto mentioned foldr easily implemented directly 
therefor uses list representation internally reduce operations 
foldr foldr reducer reduce reduce di erent forms sublist extraction constant amortised time ltail lview operations internally run time linear arguments 
take drop splitat subseq filter partition operations foldr traverse list cons build appropriate result 
filter partition likewise family operations uses lview traverse list long necessary 
takewhile dropwhile checking index inside list looking respective element performed drop running 
inbounds lookup changing element index uses splitat reach change desired element linear time appends parts 
update adjust remaining operations list representation internally obviously run tolist fromlist respective list operations 
zip family shortest list determines runtime tolist incremental 
zip zip zip zipwith zipwith zipwith unzip unzip unzip generating arbitrary multi way tree little messy just generate arbitrary list avoid duplicating 
instance arbitrary arbitrary seq arbitrary arbitrary generating arbitrary list elements little involved 
list empty result trivially empty course 
head list element root tail partitioned arbitrary number parts turn arbitrary generated stored queue child nodes 
partitioning performed recursing list right left time elements form right child node 
result trees unbalanced right average 
forms trees possible number children number elements child completely arbitrary 
instance checkablesequence seq return empty xs liftm xs return empty xs choose size xs xs xs splitat xs ls xs xs return snoc ls catenable deques supporting standard deque operations append constant amortised time described oka oka far complicated sequence data structure implemented course project 
requires implementation normal deques linear time append deque implementation features persistence 
furthermore append runs time linear length shorter arguments property comes handy 
catenable deque deque forms shallow deep 
import qualified data seq shallow seq deep seq seq seq seq seq shallow form merely wrapper normal deque 
interesting deep form represents quintuple normal deques deques compound elements 
contain elements length deque deep form reduced converted back shallow form 
compound elements come flavours simple cmpd 
data simple seq cmpd seq seq seq deriving show simple compound element just wrapper normal deque time required contain elements cmpd form represents triple normal deques elements deque compound elements 
invariant seq bool invariant shallow true invariant deep size invariant foldr true size invariant foldr true size bool simple size cmpd size invariant foldr true size note strictness flags occurrences normal deques course interfere laziness inside 
strictness avoids overhead occur creation suspensions yield gain operations suspended way run amortised time anyway 
amortised runtime analysis carried banker method 
fields deep deque field cmpd carry suspensions debits placed 
debit invariant introduced okasaki cmpd debits may placed field cmpd zero fields defined rules base allowance zero debits 
contains elements allowance increased debits 
likewise contains elements allowance increased debits 
okasaki showed constant amortised runtime append cons snoc ltail rtail 
extent ideas remaining operations outline arguments 
operations inside shallow form additional analysis necessary directly mapped respective operations normal deque 
creating empty singleton deque simply creates shallow deque carrying appropriate deque empty directly taken oka :10.1.1.54.6229
runtime obviously constant 
empty shallow empty single shallow single adding single element front rear just add element respective internal deque 
operations described oka oka contains haskell code cons :10.1.1.54.6229
cons shallow shallow cons cons deep deep cons snoc shallow shallow snoc snoc deep deep snoc cons snoc run constant amortised time obviously debit invariant preserved operations run amortised 
append operation distinguish major cases deques shallow second deep deep course second third case symmetric 
deques shallow contains elements call append operation directly create new shallow deque 
contain elements deep deque built components empty component containing element deque element second deque components set remainders internal deques respectively 
see way dividing share helper function deques occurs times introduce helper function share take care 
version adapted oka modified view operations :10.1.1.54.6229
likewise append implementations modified exploit append runs time linear length shorter argument making unnecessary provide di erent specialised appends 
share seq seq seq seq seq share just fi fl rview just rh rt lview fi cons fl single rh rt append shallow shallow size deep empty empty share appending shallow deep deque distinguishes shallow deque elements 
internal deque appended respectively component deep deque 
internal deque shallow deque new respectively old added component simple compound element 
append shallow deep size deep cons simple append deep shallow size deep snoc simple case appending deep deques complicated 
translating concise haskell code english necessarily easier understand tries visualise done note denotes cons snoc respectively 
share append deep append deep deep share snoc cmpd cons cmpd deep functions called append constant amortised runtime share follows directly constant amortised runtime called deque functions cons snoc established deque append arguments arguments bounding runtime 
leaves debits cases involving deep deques analysed 
debits discharge plus may created cons snoc obviously su cient preserve debit invariant get constant amortised runtime 
careful analysis shows discharge debits oka 
accessing head element trivially done constant amortised time respective deque operation 
lhead shallow lhead lhead deep lhead removing head element requires thought 
shallow form quite easy deep deque containing elements su cient just remove head containing minimum number elements cases distinguished non empty remove head element acquire second deque append tail get back elements 
head element simple compound element deque carries need 
cmpd component desired deque need take care components 
cons component encapsulated simple compound element tail append result deque get new empty append tail arrive resulting elements extract head obtain new head simple compound element deque carries new done 
cmpd component new components joined encapsulating simple compound element consing replace empty empty tail appended result put shallow deque deques appended form desired result 
case head cmpd compound element immediately replace head removing 
case course unnecessary preserve minimum length component ltail define auxiliary function handles cons ltail cd little ciently 
seq seq shallow shallow cons ltail deep deep cons ltail putting arrive lengthy implementation ltail literally oka :10.1.1.54.6229
ltail shallow shallow ltail ltail deep size deep ltail null case lhead simple deep ltail append ltail cmpd deep append ltail append simple null case lhead simple deep ltail append ltail cmpd deep ltail append ltail cons simple append shallow append ltail shallow case shallow deque ltail obviously runs amortised 
inspection functions invoked inside ltail run constant amortised time possible exception recursion suspended 
debit analysis critical part 
due recursive structure argue debits passed surrounding suspension level debits discharged 
establish debits passed surrounding suspension dealing di erent cases distinctly 
recursive call occurs may case drops reducing debit allowance making necessary pass debits surrounding suspension 
non empty head simple may carry debit pass surrounding suspension 
component resulting deque elements may leave depending debits inherit recursive call pass debit pass debit 
non empty head cmpd pass debit surrounding suspension 
debits associated new higher component may carry debits append produces debits produces additional debit summing debits 
pass su cient debits passed total 
empty non empty head simple pass debits surrounding suspension leave debits generated recursive call ltail 
guaranteed free debits pass generated debits 
debits passed 
empty non empty head cmpd debits argument holds considers new component 
component compound element may carry debits cons generates additional debit 
debits allowed pass debit yielding total debits passed surrounding suspension 
empty recursive call occurs call append may result debits passed 
ltail runs amortised 
lview lhead ltail come straight forward implementation 
lview cd null cd just lhead cd ltail cd exploiting symmetry define rhead rtail rview similar way yielding constant amortised runtime 
rhead shallow rhead rhead deep rhead shallow shallow snoc rtail deep deep snoc rtail rtail shallow shallow rtail rtail deep size deep rtail null case rhead simple deep rtail append rtail cmpd deep append rtail append simple null case rhead simple deep rtail append rtail cmpd deep rtail append rtail snoc simple append shallow shallow append rtail rview cd null cd just rtail cd rhead cd shallow deque empty test deque empty reduces respective test normal deques runs constant amortised time 
null shallow null null false determining size deque little involved deep form 
size shallow size size deep size foldr size size foldr size size size simple size size cmpd size foldr size size deque size operation runs constant time deques non empty contribute linear runtime total applications deque size operation performed 
recursive call size results call size total number obviously linear furthermore amount debits discharged recursion constant yielding amortised runtime 
reversing shallow carried simply reversing deque inside 
deep form order components reversed components reversed components compound elements contain reversed 
reverse shallow shallow reverse reverse deep deep reverse reverse map rev reverse reverse map rev reverse rev simple simple reverse rev cmpd cmpd reverse reverse map rev reverse observing deque reverse operation argument size linear amortised runtime established 
conversion list performed just converting list deque wrapping shallow constructor linear amortised time respective deque function 
fromlist xs shallow fromlist xs map fold family operations implemented calls respective deque operations special care compound elements 
total number debits discharged fold application function argument determines runtime 
map shallow shallow map map deep deep map map map map map simple simple map cmpd cmpd map map map foldr shallow foldr foldr deep foldr foldr foldr foldr foldr simple foldr cmpd foldr foldr foldr foldr shallow foldr foldr deep foldr foldr foldr foldr foldr simple foldr cmpd foldr foldr foldr foldl shallow foldl foldl deep foldl foldl foldl foldl foldl simple foldl cmpd foldl foldl foldl foldl shallow foldl foldl deep foldl foldl foldl foldl foldl simple foldl cmpd foldl foldl foldl copy tabulate constructors just wrap respective deque operations shallow constructors preserving constant amortised runtime 
copy shallow copy tabulate shallow tabulate drop shallow just calls respective deque operation distinguish cases deep form 
just drop elements violating invariant 
drop elements call ltail remove call drop recursively remove remaining elements 
drop shallow shallow drop drop deep size deep drop drop size ltail deep drop size non recursing cases obviously take linear time deque drop debits discharged case length drops 
ltail drop size run constant amortised time reduced recursive call get amortised runtime total 
case distinction take similar 
shallow index lies just deque take wrap result shallow 
append elements remains dropping elements 
take shallow shallow take take deep size shallow take append shallow take size drop size non recursing cases run amortised 
recursing case drop runs constant amortised time closer inspection reveals recurses 
append runs constant amortised time reduced recursive call get total amortised runtime 
checking index valid shallow form performed respective deque operation 
deep form exploit constant time size operation deque check elements stored components su cient establish index valid 
drop resulting amortised runtime 
inbounds inbounds shallow inbounds inbounds deep deep concatenating multiple conveniently performed repeated application constant time append yielding amortised runtime linear number concatenated 
concatmap time required function added course 
concat concatmap reverseonto operation uses reverse append resulting linear amortised runtime 
reverseonto conversion list uses foldr cons result list 
results list evaluated incrementally total runtime 
tolist quite complex divide evenly reduce family operations uses list representation internally giving runtime determined fold application function argument 
reducer reduce reduce splitat subseq call take drop internally having amortised runtime respectively 
splitat subseq lookup family operations just drops elements access requested index resulting amortised runtime 
lookup changing element update adjust performed splitting index modifying respective element appending parts 
addition potentially expensive application function argument adjust splitat amortised runtime determines total runtime 
update adjust runtime operations lists internally dominated application times 
filter partition foldr traverse build result usual having time complexity determined fold application function argument filter partition holds operation lview traverse far required 
takewhile dropwhile tolist incremental zip family operations list representations internally time linear length shortest involved 
zip zip zip zipwith zipwith zipwith unzip operations traversal performed foldr resulting runtime linear determined function argument respectively 
unzip unzip unzip generation arbitrary little involved implementations need implement arbitrary interface data types 
observing structural invariant demands deques certain minimum size start defining helper function produce arbitrary minimum size 
simply generating deque arbitrary size adding elements ensure minimum size arbitrary int gen seq arbitrary arbitrary xs return cons xs helper function easily generate arbitrary compound element fulfils invariant 
obviously restrictions generated minimum lengths apply allowed compound element produced 
noted small generation sizes cmpd case may entered resulting elements 
allow get interesting test cases non shallow instances 
instance arbitrary arbitrary arbitrary oneof simple sized cmpd simple liftm simple cmpd size resize size div liftm cmpd arbitrary generation arbitrary works similar way restrict generation shallow variant small sizes avoid infinite recursion 
easy see allowed generated 
instance arbitrary arbitrary seq arbitrary oneof shallow sized deep shallow liftm shallow arbitrary deep size size resize size div liftm deep arbitrary arbitrary generation contents trickier arbitrarily add elements deques provide required minimum size 
divide elements legal way 
introduce additional helper functions accomplish starting produces list numbers add value 
extra argument takes list lists allowed values 
advantage compared list minimum values su cient allows case zero elements allowed 
domain lists increasing order permits function just repeatedly remove head element randomly chosen domain list head elements add desired value 
removal head element ensured result high value 
course approach get stuck sum increased possible increases 
applications follow domain list consist increases 
int int gen int xxs return map lhead xxs choose length xxs adjust xxs sum map lhead xxs xs xs xs secondly define function splits list parts lengths parts restricted kind domain lists explained 
function straight forward 
int gen xs liftm xs size xs xs xs xs splitat xs xxs xs xs xxs turn main function 
examine length input list empty result contains elements result shallow shallow deep form possible 
instance checkablesequence seq return empty xs size xs oneof shallow deep generation shallow form trivial need helper function introduced split input list suitable parts 
deque parts simple minimum sizes may empty contain element contain elements 
generate generate list compound elements see call recursively 
shallow return shallow fromlist xs deep xs return deep fromlist fromlist fromlist list compound elements generated choosing length dividing input elements accordingly wrapping 
gen return xs choose size xs div xxs copy xs mapm xxs generation arbitrary compound element contents similar generation 
elements simple forms allowed 
gen xs size xs oneof simple xs cmpd xs simple case simple cmpd case works way similar deep case 
simple xs return simple fromlist xs cmpd xs xs return cmpd fromlist fromlist independent internals expected correct checked fromlist safely produce deques 
chapter discussion related lot theoretical various functional data structures done implemented outside frameworks 
especially design library details implementations special interest able spot possible design flaws edison 
compare edison imperative data structure libraries java collection framework standard template library examining done data structure libraries functional settings 
functional data structure libraries library dedicated functional data structures author able dig baire caml language diego olivier fernandez 
baire loosely edison furthermore contains variety higher level data structures automata lexical trees broader scope edison consider parts directly comparable 
baire progress features implementations edison mature framework interfaces corresponding type classes haskell 
time writing set map interface exist corresponds edison ordset 
part reduction type classes edison just due fact caml provides total ordering data type functions necessary provide interfaces implementations assume presence ordering 
furthermore baire demands observability implementations halves number interfaces 
baire feature interfaces bags sequences expected appear releases 
library worth mentioning sml nj library includes type signatures ordered sets maps similar set respectively require elements keys respectively ordering relation defined keep contents sorted 
implementations adapted signatures ordered list functional graph library available haskell standard ml focuses operations dealing graphs 
splay tree size balanced tree described adams ada 
functional programming languages data structure implementations stand lack framework tying bundled libraries 
examples include emacs lisp library includes stack queue doubly linked list binary tree avl tree implementations portable scheme library contains deque alas called queue priority queue 
want mention leijen collection data structures haskell including bag set map size balanced trees specialisations integers big endian patricia trees 
part type framework easy adapt edison 
java collection framework java collection framework part java platform 
java provide way type parametrisation collection classes store elements objects base class hierarchy 
allows arbitrary objects stored means retrieved elements type casted original type operation may cause type errors runtime 
defines total interfaces basic collection 
extended set list 
additionally interfaces map extend collection stand 
interfaces comparable respective type classes correspond depicted table 
design goals interface ordered unique edison type class list sequence collection coll set set ordset map table correspondence interfaces edison type classes keep simple consists lower number interfaces edison furthermore interfaces contain fewer operations 
particular higher order functions map foldr missing implemented means visitor objects provide functions applied elements 
collections provide iterators allow traversal structure hiding implementation details 
iterators come flavors allows forward traversal removal current element allows backward traversal adding new elements replacing current element 
probably change generics java standard template library name suggests stl extensive template facility 
ensures type safety compile time template concept certain problems explicitly restrict allowed template parameters 
class function template accepts type parameter type 
assumptions class function type implicit may result confusing error messages fulfilled 
documentation stl term concept categorise types way similar type classes haskell important di erence concepts language support 
contrary edison container classes stl provide operations supported ciently gives rise multitude concepts refrain detailed discussion 
worth noticing concepts demand observability 
iterators stl allow traversal containers abstracting away implementation details 
iterators provide operations support ciently resulting large number iterator concepts 
operations go mere adding removing single elements searching specific elements applying function elements partitioning implemented function templates operate iterators independent underlying container implementation invoked 
simplifies development new container classes need provide limited number operations iterator exiting algorithm automatically 
noteworthy di erences edison edison data structure library allows containers non observable 
implementations currently available edison observable 
casts doubt usefulness observability concept 
edison manual okasaki gives examples possible implementations non observable bag represented mapping elements counts collection elements hash function defined produces unique values reversible elements hashes stored 
implemented estimated respect superior observable data structures extent non observable data structures useful practice 
carefully evaluated possibility non observable collections adds real benefits just complexity 
interesting point iterators proven useful practice imperative object oriented collection classes allow traversal collection revealing internals functional counterparts employ di erent approaches 
provide higher order functions perform specific traversal foldr map allow element wise decomposition lview provide way convert canonical form lists 
problem element wise decomposition usually incurs lot overhead restructure collection return remaining elements 
conversion list may result ine ciency list obviously contain elements correct order map order irrelevant long preserved 
desirable higher order traversal operation form traversal wish 
clear project causes lot side implementor data structure 
iterators imperative nature 
consider example iterator allows things deletion current element 
imperative setting update collection longer contain removed element iterator point valid element return 
functional setting new collection new iterator returned 
suddenly user deal iterator collection time beneficial 
hidden user monads source ine ciency 
apparent example considering simple queue deque implementations lists internally sections 
map fold operations need reverse rear list iterator probably 
important easily determined collections associations parts done course project sequences provide detailed analysis existing implementations condensed overview provide new implementations fill gaps 
integration leijen package edison starting point 
possible reduction achieved advantage fact collections associations tightly coupled possible implement terms map set key value pairs set key unit map 
approach tempting care taken inflict ciency penalties overheads caused wrapping arguments unwrapping results calling underlying implementation 
suitable data structures selected checked exploits non observability framework simplified removing classes 
done careful consideration limit possibilities 
edison attractive programmers manual extended include complexity information di erent implementations condensed form table appendix main characteristics allow easy selection data structure suitable certain task 
supplemented benchmarking results possibly gathered help tool 
edison chances stl haskell rendering extremely useful library broad range haskell applications 
despite gaps today provides interesting data structures framework easy 
edison rarely mainly due lack documentation existing implementations 
thesis successfully solved problem sequences part edison 
data structures available theoretical analysis proved extremely labour intensive papers limited description main operations sequence edison provides 
fortunately possible adapt known arguments remaining operations 
noteworthy exceptions include drop operation analysis source code okasaki added comment drop log log showed weaker theoretical works existed 
furthermore implemented new sequence implementations rounding part edison 
course analysed documented carefully existing ones 
increase confidence correctness quickcheck 
order replaced property definitions part edison new ones allowing polymorphic usage checking structural invariant preservation 
unfortunately due limited scope project tackle collections associative collections parts edison benchmarking undermine theoretical practical 
hope increasing usefulness edison level applied enters mental scope haskell programmers fill gaps 
log 
appendix overview time complexities variables size input tables defined follows length sequence functions sequence arguments length second third sequence functions sequences arguments nmin nmax minimum maximum second integer argument time complexity function argument length ith sequence argument concat length result applying ith element concatmap length result concat concatmap table definition input size variables expressions asymptotic bounds omitted sake brevity 
empty single null lview maximum lhead ltail rview maximum rhead rtail map foldr foldl foldr foldl reducer reduce tabulate filter partition takewhile dropwhile adjust update plus lookup zip zip zipwith zipwith zip plus nmin unzip unzip table common time complexities sequence implementations default usage cons log log snoc append log log nmin lhead ltail log log rhead log logn log log concat reverseonto nmin fromlist tolist concatmap nt nt nt tf tf copy inbounds min log log log log update min log log log drop min log min log log log min subseq min log min logn logn ilog nmin nmax unzip appendix parametricity properties reducer framework set wad derive property functions type reducer sequence 
red red 
function start derivation eliminating quantifier 
red red apply rule times arrive 
red red rewrite outer quantification 

gives 


red red equivalently 


red red eliminating get 

xs xs 
red xs red xs rewritten convenient form 

xs red xs red xs 
appendix complete source code module module import prelude hiding concat reverse map concatmap foldr foldl foldr foldl filter takewhile dropwhile lookup take drop splitat zip zip zipwith zipwith unzip unzip null import qualified prelude import just import quickcheck import sequence instance show show class sequence checkablesequence invariant bool gen prop lview checkablesequence eq bool prop lview xs case lview xs true just xs invariant xs prop empty sequence eq eq bool bool prop empty inv inv xs case lview xs true just false xs empty sequence eq bool xs ys case lview xs case lview ys true just false just xs case lview ys false just ys xs ys prop equals sequence eq eq bool prop equals xs ys xs ys xs ys prop cons checkablesequence eq eq bool prop cons xs lview xxs just xs invariant xxs xxs cons xs sequence bool xs case lview xs true just false prop null sequence bool prop null xs null xs xs sequence cons empty prop single sequence eq eq bool bool prop single inv inv xs xs xs single sequence xs case lview xs single just xs cons xs prop snoc checkablesequence eq eq bool prop snoc xs invariant xs xs xs xs snoc xs sequence xs ys case lview xs ys just xs cons append xs ys prop append checkablesequence eq eq bool prop append xs ys invariant xs ys append xs ys sequence empty xs cons xs prop fromlist sequence eq eq bool bool prop fromlist inv inv fromlist sequence int empty cons prop copy sequence eq eq bool int bool prop copy inv inv xs xs xs copy sequence int int empty snoc prop tabulate sequence eq eq bool int int bool prop tabulate inv inv tabulate sequence xs just lview xs prop lhead sequence eq eq property prop lhead xs null xs lhead xs xs sequence xs case lview xs empty just xs xs prop ltail checkablesequence eq eq bool prop ltail xs invariant xs ltail xs sequence xs case lview xs just xs case xs just empty just xs just cons xs prop rview checkablesequence eq eq bool prop rview xs case xs just xs invariant xs xs rview xs sequence xs just rview xs prop rhead sequence eq eq property prop rhead xs null xs rhead xs xs sequence xs case rview xs empty just xs xs prop rtail checkablesequence eq eq bool prop rtail xs invariant xs rtail xs sequence int xs case lview xs just xs xs prop size sequence eq eq property prop size xs collect size xs size xs xs sequence xs case lview xs just xs xs prop tolist sequence eq eq bool prop tolist xs tolist xs xs sequence xss case lview xss empty just xs xss append xs xss prop concat sequence eq eq bool bool prop concat inv xss inv res res xss res concat xss sequence xs case lview xs empty just xs snoc xs prop reverse checkablesequence eq eq bool prop reverse xs invariant rev rev xs rev reverse xs sequence xs ys append reverse xs ys prop reverseonto checkablesequence eq eq bool prop reverseonto xs ys invariant rev rev xs ys rev reverseonto xs ys sequence xs case lview xs empty just xs cons xs prop map checkablesequence eq eq bool prop map xs invariant xs xs xs xs map xs sequence xs concat map xs prop concatmap checkablesequence eq eq bool prop concatmap xs invariant xs xs xs xs concatmap xs sequence xs case lview xs just xs xs prop foldr sequence eq eq bool prop foldr xs foldr xs xs sequence xs case lview xs just xs xs prop foldl sequence eq eq bool prop foldl xs foldl xs xs foldr def sequence foldr def xs just xs rview xs foldr xs prop foldr sequence eq eq property prop foldr xs null xs foldr xs foldr def xs foldl def sequence foldl def xs just xs lview xs foldl xs prop foldl sequence eq eq property prop foldl xs null xs foldl xs foldl def xs sequence foldr prop reducer sequence eq eq arbitrary bool prop reducer xs xs map xs reducer xs xs sequence foldl prop sequence eq eq arbitrary bool prop xs xs map xs xs xs reduce def sequence reduce def foldr prop reduce sequence eq eq arbitrary property prop reduce xs xs map xs null xs reduce xs reduce def xs sequence int xs empty size xs xs just xs lview xs cons xs prop take checkablesequence eq eq int bool prop take xs invariant xs xs xs xs take xs sequence int xs xs size xs empty ltail xs prop drop checkablesequence eq eq int bool prop drop xs invariant xs xs xs xs drop xs sequence int xs take xs drop xs prop splitat checkablesequence eq eq int bool prop splitat xs invariant xs invariant xs xs xs xs xs xs splitat xs sequence int int xs take drop xs prop subseq checkablesequence eq eq int int bool prop subseq xs invariant xs xs xs xs subseq xs sequence bool xs case lview xs empty just xs cons xs xs prop filter checkablesequence eq eq bool bool prop filter xs invariant xs xs xs xs filter xs sequence bool xs filter xs filter xs prop partition checkablesequence eq eq bool bool prop partition xs invariant xs invariant xs xs xs xs xs xs partition xs sequence bool xs case lview xs empty just xs cons xs empty prop takewhile checkablesequence eq eq bool bool prop takewhile xs invariant xs xs xs xs takewhile xs sequence bool xs case lview xs empty just xs xs xs prop dropwhile checkablesequence eq eq bool bool prop dropwhile xs invariant xs xs xs xs dropwhile xs sequence bool xs takewhile xs dropwhile xs prop checkablesequence eq eq bool bool prop xs invariant xs invariant xs xs xs xs xs xs xs sequence int bool xs prop inbounds sequence eq eq int bool prop inbounds xs inbounds xs xs sequence int xs lhead xs xs ltail xs prop lookup sequence eq eq int property prop lookup xs inbounds xs lookup xs xs sequence int xs inbounds xs xs just lhead xs xs ltail xs prop sequence eq eq int bool prop xs xs xs sequence int xs inbounds xs xs lhead xs xs ltail xs prop sequence eq eq int bool prop xs xs xs sequence int xs inbounds xs xs xs cons ltail xs xs just xs lview xs cons xs prop update checkablesequence eq eq int bool prop update xs invariant xs xs xs xs update xs sequence int xs inbounds xs xs xs just xs lview xs cons xs xs just xs lview xs cons xs prop adjust checkablesequence eq eq int bool prop adjust xs invariant xs xs xs xs adjust xs sequence int xs case rview xs empty just xs snoc xs size xs prop checkablesequence eq eq int bool prop xs invariant xs xs xs xs xs sequence int xs case rview xs just xs size xs xs prop sequence eq eq int bool prop xs xs xs sequence int xs case rview xs just xs xs size xs prop sequence eq eq int bool prop xs xs xs sequence xs ys null xs null ys empty just xs lview xs just ys lview ys cons xs ys prop zipwith checkablesequence eq eq bool prop zipwith xs ys invariant xys xys xs ys xys zipwith xs ys zipwith def sequence zipwith def xs ys zs null xs null ys null zs empty just xs lview xs just ys lview ys just zs lview zs cons zipwith def xs ys zs prop zipwith checkablesequence eq eq bool prop zipwith xs ys zs invariant zipwith def xs ys zs zipwith xs ys zs sequence xs ys zipwith xs ys prop zip checkablesequence eq eq bool prop zip xs ys invariant xys xys xs ys xys zip xs ys zip def sequence zip def xs ys zs zipwith xs ys zs prop zip checkablesequence eq eq bool prop zip xs ys zs invariant zip def xs ys zs zip xs ys zs sequence xs map fst xs map snd xs prop unzip sequence eq eq bool bool prop unzip inv xys inv xs inv ys xs ys xys xs ys unzip xys unzip def sequence unzip def xs map fst xs map snd xs map xs fst snd prop unzip sequence eq eq bool bool prop unzip inv inv xs inv ys inv zs xs ys zs unzip def xs ys zs unzip sequence xs map xs map xs prop checkablesequence eq eq bool prop xs invariant xs invariant xs xs xs xs xs xs xs def sequence def xs map xs map xs map xs prop checkablesequence eq eq bool prop xs invariant xs invariant xs invariant xs xs xs xs def xs xs xs xs xs sequence eq arbitrary show arbitrary show eq arbitrary show arbitrary show eq arbitrary eq checkablesequence show bool io inv putstr checking arbitrary quickcheck forall seqs inv putstr checking quickcheck xs xs property inv xs putstr checking lview quickcheck forall seqs prop lview putstr checking empty quickcheck prop empty inv putstr checking quickcheck forall seqs prop equals putstr checking equal cases quickcheck xs xs xs property prop equals putstr checking cons quickcheck forall seqs prop cons putstr checking null quickcheck forall seqs prop null putstr checking single quickcheck prop single inv putstr checking snoc quickcheck forall seqs prop snoc putstr checking append quickcheck forall seqs prop append putstr checking fromlist quickcheck prop fromlist inv putstr checking copy quickcheck prop copy inv putstr checking tabulate quickcheck prop tabulate inv putstr checking lhead quickcheck forall seqs prop lhead putstr checking ltail quickcheck forall seqs prop ltail putstr checking rview quickcheck forall seqs prop rview putstr checking rhead quickcheck forall seqs prop rhead putstr checking rtail quickcheck forall seqs prop rtail putstr checking size quickcheck forall seqs prop size putstr checking tolist quickcheck forall seqs prop tolist putstr checking concat quickcheck forall gen prop concat inv putstr checking reverse quickcheck forall seqs prop reverse putstr checking reverseonto quickcheck forall seqs prop reverseonto putstr checking map quickcheck forall seqs prop map putstr checking concatmap quickcheck forall seqs xs forall gen prop concatmap xs putstr checking foldr quickcheck forall seqs prop foldr putstr checking foldl quickcheck forall seqs prop foldl putstr checking foldr quickcheck forall seqs prop foldr putstr checking foldl quickcheck forall seqs prop foldl putstr checking reducer quickcheck forall seqs prop reducer putstr checking quickcheck forall seqs prop putstr checking reduce quickcheck forall seqs prop reduce putstr checking take quickcheck forall seqs prop take putstr checking drop quickcheck forall seqs prop drop putstr checking splitat quickcheck forall seqs prop splitat putstr checking subseq quickcheck forall seqs prop subseq putstr checking filter quickcheck forall seqs prop filter putstr checking partition quickcheck forall seqs prop partition putstr checking takewhile quickcheck forall seqs prop takewhile putstr checking dropwhile quickcheck forall seqs prop dropwhile putstr checking quickcheck forall seqs prop putstr checking inbounds quickcheck forall seqs prop inbounds putstr checking lookup quickcheck forall seqs prop lookup putstr checking quickcheck forall seqs prop putstr checking quickcheck forall seqs prop putstr checking update quickcheck forall seqs prop update putstr checking adjust quickcheck forall seqs prop adjust putstr checking quickcheck forall seqs prop putstr checking quickcheck forall seqs prop putstr checking quickcheck forall seqs prop putstr checking zipwith quickcheck forall seqs prop zipwith putstr checking zipwith quickcheck forall seqs prop zipwith putstr checking zip quickcheck forall seqs prop zip putstr checking zip quickcheck forall seqs prop zip putstr checking unzip quickcheck prop unzip inv putstr checking unzip quickcheck prop unzip inv putstr checking quickcheck forall seqs prop putstr checking quickcheck forall seqs prop seqs arbitrary xs xs xs prop forall xs prop gen arbitrary gen gen sized resize min arbitrary bibliography ada stephen adams 
functional pearls cient sets balancing act 
journal functional programming october 
ch koen claessen john hughes 
quickcheck lightweight tool random testing haskell programs 
proceedings acm sigplan international conference functional programming icfp volume acm sigplan notices pages september 
acm press 
fre michael fredman 
pairing heaps suboptimal 
technical report dimacs september 
michael fredman robert sedgewick daniel sleator robert tarjan 
pairing heap new form self adjusting heap 
algorithmica 
hm robert hood robert melville 
real time queue operations pure lisp 
information processing letters november 
hoo 
implementation flexible arrays 
mathematics program construction second international conference proceedings pages 
hoo 
symmetric set cient list operation 
journal functional programming 
kt haim kaplan robert tarjan 
persistent lists catenation recursive slow 
proceedings seventh annual acm symposium theory computing pages may june 
mor morrison 
patricia practical algorithm retrieve information coded alphanumeric 

october 
graeme moss colin runciman 
kit benchmarking functional data structures 
lecture notes computer science 
graeme moss colin runciman 
automated benchmarking functional data structures 
lecture notes computer science 
mye eugene myers 
applicative random access stack 
information processing letters december 
og chris okasaki andrew gill 
fast mergeable integer maps 
workshop ml pages september 
oka chris okasaki 
amortization lazy evaluation persistence lists catenation lazy linking 
th annual symposium foundations computer science pages milwaukee wisconsin october 
ieee 
oka chris okasaki 
purely functional random access lists 
proceedings seventh international conference functional programming languages computer architecture pages 
acm press 
oka chris okasaki 
simple cient purely functional queues deques 
journal functional programming october 
oka chris okasaki 
catenable double ended queues 
proceedings second acm sigplan international conference functional programming pages 
acm press 
oka chris okasaki 
algorithms braun trees 
journal functional programming november 
functional pearl 
oka chris okasaki :10.1.1.54.6229
purely functional data structures 
cambridge university press 
oka chris okasaki 
edison user guide haskell version 
san sands 
complexity analysis lazy higher order language 
proceedings third european symposium programming number lncs pages 
springer verlag may 
st daniel dominic sleator robert endre tarjan 
self adjusting heaps 
siam journal computing february 
wad wadler 
strictness analysis aids time analysis 
proceedings th acm sigplan sigact symposium programming languages pages 
acm press 
wad wadler 
theorems free 
fpca london england pages 
acm press september 

