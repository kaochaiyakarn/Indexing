bj rn knutsson dsl cis upenn edu peer peer support massively multiplayer games lu hhl cis upenn edu wei xu seas upenn edu bryan hopkins upenn edu department computer information science university pennsylvania approach support massively multi player games peer peer overlays 
approach exploits fact players display locality interest form self organizing groups locations virtual world 
designed scalable mechanisms distribute game state participating players maintain consistency face node failures 
resulting system dynamically scales number online players 
flexible lower deployment cost centralized games servers 
implemented simple game call experimented players demonstrate applicability approach 
propose peer peer overlays support massively multi player games internet 
players participating game form overlay game functions implemented 
players contribute memory cpu cycles bandwidth manage shared game state 
premise large shared game world inhabited thousands players 
emphasis social interactions exciting story lines 
games lineage recorded registered players concurrent players night 
online traditionally supported clientserver architecture server keeps player account information handles game state 
scalability achieved employing server clusters 
servers connected lans form computing grid butterfly net 
architecture scales number players lacks flexibility server provisioned handle peak loads 
furthermore client server model limits deployment user designed games important trend game design 
games allow limited user designed game extensions security performance concerns limit scope extensions need hosted game servers handling core game 
massively multiplayer online games natural applications peer peer overlays 
take advantage self organizing characteristic overlays create system dynamically scales number players 
game players incentives join overlay participation limited duration player game play 
games different previous applications focus harnessing idle storage network bandwidth including storage systems content distribution instant messaging 
games utilize memory cpu cycles peers maintain shared game state 
potential problems addressed approach fully applicable practice performance games frequent updates propagated certain time constraints 
furthermore peers limited bandwidth located edge network 
availability replicating game states improve availability potential problems 
peer goes offline state quickly stale replica invalid 
secondly high update frequency maintaining large set replicas potential performance bottleneck 
security prevention account prevention cheating game play considered 
distributing game states peers increases opportunities cheating 
discusses problems detail 
design prevents account problem important game industry centralizing account management server distributing game states peers 
cheat prevention major concern online games separate issue basic performance availability gaming 
note instances cheat prevention influenced design details particulars subject ongoing 
primary technical contributions architectural evaluative 
preset novel architecture massively multiplayer games peer peer networking technologies provide detailed performance study demonstrate feasibility design 
key feasibility game architecture locality interest 
games designed game world large area interest single player limited typically correlating sensory capabilities game characters modeled 
players turn arranged groups coinciding areas interest 
self organizing property matches self ieee ieee infocom organizing character peer peer networks 
particular nearby defined game terms players form peer groups keep updates game state group 
rest organized follows sections ii iii provide background material online peer peer overlays respectively 
section iv discusses design choices 
section describes algorithm keeping game state consistent 
section vi details implementation system 
section vii presents experimental results 
section viii discusses related 
conclude discuss section ix 
ii 
online massively multiplayer games massively multiplayer online games distinguish online games allowing thousands players share single game world 
existing role playing games rpg real time strategy rts rpg hybrids 
typical examples include online com star wars galaxies sims online 
person shooter fps games quake doom large numbers concurrent players usually divided small isolated game sessions handful players true networked rts games iii 
basic premise player assumes role character virtual world 
classical setting middle earth characters belonging different races humans classes fighters arbitrary world past 
player experiences game world game avatar representation character game typically limited seeing hearing doing things avatar 
typical game involves game character missions quests part group require travel different parts game world interacting various players finding objects earning money accumulating experience abstracted abilities experience points 
superficial differences aside underlying game mechanics data structures communication patterns similar 
review common characteristics existing network implementations rest section 
game states typical multiplayer game world immutable landscape information terrain characters controlled players pcs mutable objects food tools weapons mutable landscape information breakable windows non player characters controlled automated algorithms 
allies enemies immediately distinguishable pcs interaction 
terrain consists immutable elements game 
graphic elements terrain typically installed part game client software updated normal software update mechanisms 
description terrain region created offline inserted system dynamically 
state player includes position world state game avatar abilities health possessions 
avatar states persistent carried login session 
similar states exists game objects depending role game may persistent temporary 
general player allowed kinds actions position change player object interaction interaction 
players interacting objects including players may subject game rules change state state avatar 
example drinking bottle change state bottle object full empty decrease thirst parameter player object 
similarly player player player objects health parameters change 
persistent player states terrain game states periodically rebuilt 
game progresses npc opponents eventually killed food eaten quests solved 
rebuild implemented game wide reset periodic individual objects 
resulting world huge typically statically divided regions connected possibly player game server 
connections implemented game mechanics tunnel 
region subdivided keep amount data client handles small fit memory 
existing system support client server architecture predominant paradigm implementing online 
model players connect centralized server client software 
clients text terminals advanced rendering systems allows player see world playing 
server typically responsible maintaining disseminating game state players account management player authentication 
main reason hosting game state centralized server allow players share virtual world 
scalability approached number different ways large dedicated servers allow single server handle thousands simultaneous players 
scalability achieved clustering servers dividing game universe multiple different parallel worlds spreading users 
typical single machine server support concurrent clients ieee ieee infocom cluster solution allows support players 
multiplayer games mimaze age implemented decentralized model 
designs severe limitations scalability game states broadcast players 
amaze mercury group communications nearby players game world form multicast group 
multicast games person shooter games 
different mutable objects food drinks 
lack shared game state allows simple distributed implementation sends positions players objects 
effect latency player performance player tolerance network latency lag varies game game 
general games player guiding avatar directly controlling game action better tolerate latency 
unsurprising designed 
person shooter games quake player directly controls avatar tolerate latencies milliseconds 
real time strategy games iii hand tolerate seconds network latency emphasis strategy direct interaction 
study latency tolerance role playing games generally considered latency tolerance similar rts games player controls game telling avatar pick object attack monster 
iii 
peer peer infrastructure number peer peer overlays proposed including chord tapestry pastry 
self organizing decentralized systems provide functionality scalable distributed hash table reliably mapping object key unique live node network 
systems balance object hosting query load transparently reconfigure node failures provide efficient routing queries 
built application top pastry widely overlay scribe multicast infrastructure built top pastry disseminate game state :10.1.1.12.8387
pastry pastry maps participating nodes application objects random uniformly distributed ids circular bit name space implements distributed hash table support object insertion lookup 
objects mapped live nodes id numerically closest object id example nodes ids message routed node message node 
node pointers closest neighbors sides 
closeness context limited numerical id geographical topological closeness implied 
pastry routes message destination expected log bn routing steps configuration parameter 
example network nodes average message route intermediate nodes 
pastry node maintains leaf set consisting nodes ids numerically closest centered local node id leaf set ensures reliable message delivery multiple failures happens 
despite possibility concurrent failures eventual message delivery guaranteed nodes adjacent node ids leaf set fail simultaneously typical value log bn 
node additions fail node failures handled efficiently pastry routing invariants quickly restored 
scribe scribe scalable application level multicast infrastructure built top pastry :10.1.1.12.8387
multicast groups mapped bit ring identifiers 
multicast tree associated group formed union pastry routes group member group id root serves root multicast tree 
messages multicast root members reverse path forwarding 
group member management scribe decentralized highly efficient leverages existing pastry overlay 
adding member group merely involves routing group id message reaches member tree followed adding route traversed message group multicast tree 
result scribe efficiently support large numbers groups arbitrary numbers group members groups highly dynamic membership 
iv 
general distributed game design section discusses partition world synchronize game states general decentralized system best effort multicast capabilities 
section discuss implement general design overlay deal features networks addressing replication 
idea distribute transient game state peer peer network persistent user state payment information character experience handled central server 
important property system allows centralized server delegate bandwidth processing intensive game state management peerto peer network formed clients participating game retaining control frequently updated persistent game state 
system server ad hoc game sessions hundreds thousands players gather play game hours game data transient 
ieee ieee infocom partition game world food player multicast region region multicast fig 

game design direct connection region design fact players games limited movement speed sensing capabilities data access games exhibits temporal spatial localities 
networked games distributed real time simulations exploited property applied interest management game state 
interest management allows limit amount state player access distribute game world fine granularity localize communication 
partition world regions limited sensing capabilities player avatar 
players region form interest group portion map state updates relevant part disseminated group 
player changes group moves region illustrated design overview 
allowed listen updates adjacent regions motivated required game mechanics 
additionally objects residing region need communicate part state visible players 
example chest communicate location appearance players status locked unlocked content 
helps preventing cheating players snooping traffic client memory 
interest management details highly application dependent 
keep prototype simple fixed size regions limit player listening region time 
vary group size frequency group changes emulate network effect various interest management approaches 
game state consistency game state consistent players region 
example player half bottle wine player arrives scene able drink remaining half 
section considers consistency failure free environments 
fault tolerance discussed section closely related features overlay 
basic approach employs coordinators resolve update conflicts 
different game states different access patterns consistency requirements split game state management classes 
player state player state accessed multiple reader pattern 
player updates location moves 
player player interactions fighting trading affect states life points players involved 
position change common event game position player multicast fixed interval players region 
interval determined game design requirements game 
best effort multicast disseminate position updates 
additional reliability added implementing receiver reliable multicast usually unnecessary 
loss delay messages masked application level mechanisms dead reckoning interpolates player positions 
alternative periodic updates multicast position changed significantly different dead reckoning predict 
approach potentially reduces network traffic incurs additional overhead detecting lost delayed messages 
players usually close proximity virtual world order interact 
player player interaction involve multiple actions quick succession heated battle require fast responses 
increased communication requirements limited involved players possibly players immediate vicinity allow see fight 
object state coordinator mechanism keep shared objects consistent 
object assigned coordinator updates sent distribution replication coordinators discussed section 
coordinator resolves conflicting updates repository current value object 
successful updates multicast region keep player local copy fresh 
best effort multicast provide functions allow client probe value verify current value 
timely delivery object state necessary position updates missing information corrected subsequent messages 
map graphic elements terrain players typically installed part game client software updated normal software update mechanisms 
map non graphical description terrain region 
maps considered read remain unchanged game play 
created offline inserted system dynamically 
dynamic map elements handled objects 
distributed game overlay section discusses map distributed game states overlay replicate game states ieee ieee infocom improve availability 
base discussions pastry scribe infrastructures implemented :10.1.1.12.8387
algorithm readily extended hashing functions simplified deterministic routing algorithm chord 
mapping games states peers group players objects regions distribute game regions different peers mapping pastry key space 
region assigned id computed hashing region textual name collision resistant hash function sha 
live node id closest region id serves coordinator region 
current design coordinator coordinates shared objects region serves root multicast tree distribution server region map 
mapping synchronization responsibilities node simplifies design incur high network load coordinator 
load distributed creating different id type object region mapping different peers 
random mapping coordinator region member region lack locality works benefit number reasons 
reduces opportunities cheating separating shared objects players access 
second handing coordinator corresponding player leave region random mapping limits coordinator hand offs player joins leaves game 
random mapping improves robustness reducing impact localized game real world events 
example multiple disconnects region typically result losing region state 
fault tolerance problem major obstacle systems overcome participating machines expected disconnect crash controllable fashion servers corporate data center 
fault tolerance efficient failover priority 
pastry scribe provide limited fault tolerance routing resilient network node failures game states need replicated improve availability 
furthermore replicas kept consistent node network failures 
efficient general solution problem impossible construct assumptions target application expected configuration sufficiently large network 
node failures independent node id assignment networks quasi random ensures large scales correlation node id node geographic network topological location ownership 
follows set nodes adjacent node ids highly independent failures 
failure frequency relatively low expect players online extended periods time incentives disconnect exit gracefully game 
allows lazy node failure discovery existing game events discover node failures actively probing 
means need fewer replicas data maintain consistency face node failures 
messages routed correct node low failure frequency implies key routed node id numerically closest key 
systems chord demonstrated property half nodes fail simultaneously 
lower failure frequency reasonable assume messages eventually reach correct node 
shared state replication design lightweight primary backup mechanism tolerate fail failures network nodes 
failures detected regular game events additional network traffic 
dynamically replicate coordinator failure detected 
algorithm tries keep replica circumstances prevent losses 
furthermore replication algorithm currently distinguish graceful departures quitting fail failures node crash disconnect keep mind graceful departures handled efficiently 
discussion single replica extended multiple replicas cope higher failure frequencies cost increased bandwidth usage replication messages 
additional replicas added removed dynamically response join leave rates 
failover replication property communication subsystem routes messages key node id closest stated object coordinator node id closest id object 
object key numerically closest node coordinator 
similarly numerically closest node object replica 

means pastry message key routed corresponding coordinator fail message routed replica handling failover simple node receives query implies node failed node new coordinator 
delay incurred time takes underlying routing determine failed 
node closest know replica closest node side pastry keeps leaf set updated just sends whichever nearest neighbors closest way replica node fail eligible replica node automatically ieee ieee infocom replica soon leaf set updated 
similarly node joins closer automatically new replica 
newly joined node coordinator 
node added receive update requests object receiving request object coordinate find current coordinator request transfer state transfer complete continue forward updates keep copies 
transfer complete apply stored updates transferred object take coordinator 
new coordinator die state transfer old coordinator just continue coordinator 
new coordinator takes old coordinator new replica old replica retired 
approach accesses shared objects need block data transfer old new replicas 
data replication done background allows game progress noticeable delays client 
discussions replication algorithm replica coordinator lost exists window vulnerability single copy consistent state exists copy lost recovery consistency lost 
size window sum failure detection recovery times 
normal game events detect failures failure detection time depends coordinator contacted proportional number players group 
recovery time time transfer data new coordinator replica depends size game state network characteristics 
know comprehensible study session times interviews players gathered anecdotal data 
large quests take multiple hours complete averages hours 
quest players strong incentives leave game doing may lose investment time 
novice players start smaller quests take time session times necessarily shorter partly need excitement exploring experimenting new game 
lacking hard data real life measurement gnutella system 
period hours average session time hours 
realize file sharing online gaming session lengths apples oranges anecdotal data hours conservative 
equating failure exits gives failure percentage minute nodes fail exit minute 
show section vii window small replication algorithm tolerate relatively high failure frequency loss consistency 
catastrophic failure happen coordinator replicas fail simultaneously recover state consistency guarantees 
node registered interested lost state caches regenerate lost state caches high probability 
isolated network outages indistinguishable node failures affected node handled 
larger scale outages lead network partitions troublesome 
system continue allow shared state access communication partitions original world split parallel worlds loss consistency 
brewer neatly issue cap states distributed system enjoy properties consistency availability tolerance network partitions 
option sacrifice consistency availability tolerance network partitions 
real challenge partitions merge 
parallel worlds may diverged lot time merged back potentially causing paradoxes 
game world limited lifetime better just parallel world exist reset attempt sort remaining paradoxes persistent data 
approach take require coordinators central server node handles account information persistent player states 
partition partial meaning nodes partition reach nodes partition reach central server central server refuses concurrent coordinators object 
solution insists consistency lose availability face network partition 
centralized account server single point failure scheme situation worse 
goal distributed platform improve resiliency improve flexibility scalability 
approach availability worse traditional client server solution 
vi 
implementation details implemented top freepastry open source version pastry 
purposely simple unoptimized want obscure effects want study 
map objects region described dimensional array terrain information object array tracks kind mutable object food game models 
food object consists counter keeps track nutrition food units object consists 
ieee ieee infocom player object handles player current position states 
players perform different actions moving eating fighting 
eating typical player object interaction fighting typical inter player interaction 
distribute computational communication load mapping regions pastry key space described previous section 
multicast message position updates includes player id current location map player specific sequence number 
sequence number detect re ordered missing packets 
inter player interaction inter player interactions implemented direct udp messages 
reduce opportunity cheating actions executed participating parties input algorithm results exchanged comparison 
fighting damage player usually calculated capability skill health player pseudo random number 
pseudo random number generated player seed agreed applying simple deterministic function player ids third party 
coordinator arbiter event ordering important 
object updates implementation object updates aims reduce number message round trips players coordinator maintaining fairness players 
recognize basic types object updates 
type initialization old value matter spell restores health 
second type read write updates update value depends result preceding read 
initializations implemented trivially just sending object name new value coordinator 
read write updates update valid current actual value matches client cached value 
example spell doubles strength 
updates implemented sending object name original value new value coordinator 
coordinator keeps queue requests 
request top queue coordinator compares object current value ensure date 
update proceed match request rejected current value sent back player 
player examine current value decide request 
cases object version numbers value 
illustrate version numbers consider object value player updates lets assume player updates time third player wants update value object additional mechanisms succeed despite fact object updated twice compared object cache coincidence succeed 
behavior unacceptable historic dependency needed implemented adding monotonically increasing version number object 
update succeed version number provided matches version number object 
vii 
experimental results section presents experimental results obtained prototype implementation freepastry open source version pastry 
network emulation environment freepastry experiment large networks pastry nodes instances node software communicate 
network emulator largely transparent pastry implementation 
concentrate networking aspect results computing load node negligible compared bandwidth requirement 
configured pastry nodes run single java vm 
experiments performed dual processor dell ghz pentium iii cpus gb main memory 
machines run linux sun jdk 
extension freepastry written java built top freepastry 
run freepastry key base leaf set 
maximum simulation size constrained memory available system translates practical limit virtual nodes 
analyze effect total population group size network dynamics aggregation optimizations communication load message delay system 
instance results corroborate hypothesis system scalability properties designed 
real traces role playing strategy games available generate traces simple aggressive model typical movements online role playing games 
model simulated players average eat fight seconds remain region seconds 
sustained activity expect real player compensates relative simplicity game 
similarly game position updates second adequate multicast position updates milliseconds really stress system comparison person shooter quake ii broadcasts player position updates ms 
region consists map grid described kb array 
associated region kb object array describing type amount object 
base implementation position object updates sent byte serialized java records 
map object arrays inherently sparse packed format messages transfer maps objects ieee ieee infocom kb 
replica kept coordinator 
simulations randomize actions taken simulated player average results runs data point 
base results measurements system game stable state players join leave game optimizations applied 
measurements allow evaluate basic performance platform 
experiments measure seconds simulated game play average players region 
real game strive average player region dividing world regions 
comparison groups limited members means simulation correspond having full parties players region 
order obtain message delays randomly generated network topology link nodes assigned random link delay range ms messages second percentage nodes fig 

distributions message rate 
average group size 
message aggregation 
presents distribution message rates players regions respectively 
node receives messages second matches expectations region density players region update frequency second yielding update messages second eating fighting take place intervals seconds region change intervals seconds generate smaller number messages 
distribution unicast message hops similarly illustrated 
find practically unicast messages delivered hops 
simulated delays see maximum delay ms messages delivered ms 
multicast messages delivered hops distribution illustrated long tail hops bytes message translates kb flow messages twice capacity modem 
explore reduce resorting obvious reductions message size update frequency 
number hops percentage messages fig 

distributions unicast message hops 
average group size 
message aggregation 
number hops percentage messages fig 

distributions multicast message hops 
average group size 
message aggregation 
going hops node experiment 
translates delays seconds 
behavior due idiosyncrasies scribe multicast routing scribe authors suggest solution problem implemented software available :10.1.1.12.8387
breakdown messages table presents breakdown second message rate functionalities 
message aggregation optimization discussed section vii messages position updates 
remaining messages split object updates player player interactions moves regions 
message rate object updates higher player player interactions take place frequency 
successful object updates multicast region sent replica player player interactions affect participating players 
region changes infrequent events system due amount data involved event consume bandwidth rest operations 
communication dominated position updates important understand distribution actions generalize results games different characteristics 
rest operations position update generate unbalanced load 
presents message distribution object updates 
demonstrates coordinator task concentrated nodes small percentage coordinators handling region 
ieee ieee infocom messages second number nodes number regions message aggregation failure node sec total messages average max average application messages average position updates object update average messages max percentage nodes fig 

distribution object update messages 
effect population growth revisiting experiments illustrated figures see average players region results players players quite similar 
conclude long average region density kept constant increases player population handled 
consistent approach existing online games take expand world keep comfortable population density 
message delay largely depends underlying overlay routing 
pastry routing typically route message log hops total number nodes 
means routing times increase population size slowly 
discussed base results long delay player case largely due scribe multicast algorithm 
effect population density evaluated effect population density re running experiment players regions increasing average player density region 
expect number position updates received node increases linearly increase density 
table shows message aggregation number total message increases times average players region increased 
obviously scheme sensitive player density total number players game 
indicates non uniform player distributions table breakdown message rate functionalities 
hurt performance 
propose ways deal increasing order implementation complexity 
simply game mechanics enforce limits player density example having gate keeper players pass carrying right amulet 
region guarded way solve problem 
place arbitrary strange limitations done 
second way requires region division nonuniform 
different regions different size 
allow statically partition regions higher expected density smaller regions 
sense villages cities walls naturally create barriers limiting player sensory abilities 
approach combined game mechanics 
third way allow system dynamically repartition regions player density increases 
significantly complex solutions harder combine game mechanics adds ability handle unexpected aggregations players players decide re enact empty field 
effects message aggregation updates multicast allows aggregate messages root relaying 
allows reduce number messages amortize overhead payload significantly reducing average node load 
altered system position updates players region aggregated sent 
means case players region update messages aggregated single message 
aggregated update kb size individual messages cutting bandwidth requirements half 
position updates aggregated root multicast tree number messages received root remains unchanged regular nodes observe decrease messages proportional number nodes group 
effect demonstrated 
majority nodes message rate drops ieee ieee infocom messages second aggregated non aggregated percentage nodes fig 

effect message aggregations 
players regions 
second second leaving nodes root nodes handle number messages 
reasons node may coordinate multiple regions node may root multiple multicast trees resulting large amount messages handled node 
mechanism improved performing aggregation nodes techniques similar splitstream 
allow distribute traffic evenly network 
effect network dynamics experiments far excluded effects caused node join departures 
major challenges distributing peer peer network expect nodes added removed randomly 
outlined earlier failover mechanism recover node losses transparently quickly node join departure cause overhead transferring state new replicas coordinators motivated normal player movements 
measure repeat experiment nodes joining leaving experiment 
simulate random node join node depart event second average keeping total number nodes approximately duration experiment 
evaluates node failure rate minute average session length minutes 
close median session length minutes reported henderson bhatti set popular half life servers 
half life person shooter fps expect significantly longer sessions 
short session length allow generate measurable amount transfers coordinators replicas 
experiment stipulated join leave rate leads coordinator migrations replica migrations second run 
average message rate node joins departures higher stable system overhead caused examining messages second failures failures percentage nodes fig 

coordinator handling overhead node joins leaves 
players regions 
node join node leave second average 
message distribution attributed handling coordinators illustrated 
average message rate increased 
artificially high failure frequency see majority nodes little change message rate 
possibility catastrophic failures loss consistent states results losing coordinator replicas time window loss detected state transfer completed 
define scenario catastrophic failure 
system detects failure coordinator processing update request 
experiments single replica region coordinators receives update requests seconds average 
transfer size region kb means transmitted seconds modem speeds 
account re transmission attempts stipulate window vulnerability seconds 
means example coordinator crashes replica sole repository region data seconds taken coordinator created new replica 
replica crashes take coordinator create new replica data potentially permanently lost 
failure frequency previous experiment failure second failures minute ratio coordinators nodes 
coordinator failure frequency coordinator failures minute 
window corresponding replica dies catastrophic failure 
know failure frequency nodes experiment calculate catastrophic failure frequency 
experiment comes minutes 
realistic session length hours see section details interpreting session ends node failures get node failures ieee ieee infocom minute 
gives catastrophic failure frequency hours 
assuming fast network shorter timeouts replica takes window vulnerability shrunk seconds cause catastrophic failure frequency drop hours exaggerated failure frequency days realistic rate derived hour average session length 
similarly keep second window vulnerability add second replica get catastrophic failures hours days respectively 
viii 
related target games massively multiplayer games online 
existing client server model employ server clusters improve scalability 
butterfly net provide middleware grid cluster game servers 
client server approach uses dedicated server resources resources provided game players approach 
approach flexible lowers deployment cost user designed games incurs higher security risk game state distributed peers 
group communications interest management distributed game implementations including amaze mercury fiedler 
interest management dis hla distributed interactive simulations feature large scale virtual environments 
shares techniques previous efforts games distributed simulations distinguish previous uses cycles bandwidth player machines dedicated servers 
result state replication integral part considered previous systems 
replication integral part peer peer file sharing availability performance 
read file systems applies frequent update shared data 
result maintain data consistency tolerating network node failures 
approach maintain constant number replicas similar cfs 
consistency requirements require design replication mechanism small window vulnerability 
fault tolerant consistent data services built quorum systems 
requires central server partitions approaches completely distributed 
quorum systems updates proceed number nodes partition large form quorum 
fault tolerant consistent data services built top view synchronous group communication global totally ordered broadcast services 
approaches provide stronger consistency guarantees approach may incur higher performance costs totally ordered multicast 
similar seti home distributed net peers contribute network bandwidth memory cpu cycles 
particular coordinator contributes compute power manage shared states 
contribution corresponding contribution network bandwidth consistency mechanism applied distributed peer computing 
allow peer peer computing platforms support sophisticated computing current embarrassingly parallel programs 
ix 
presents design implementation simple massively multiplayer game peer topeer overlay 
take advantage interest management characteristic games design scalable mechanism distribute map game states peers 
furthermore lightweight replication algorithm narrow window vulnerability tolerate high failure rates small number replicas 
measurements players show scales number players 
average message delay ms easily tolerated massively multiplayer games 
bandwidth requirement peer kb sec average peaks kb sec 
capacity consumer broadband services dsl 
coordinator backup sustain practical failure rate hours exceeding interval game states refreshed 
demonstrated new application massively multiplayer games supported peerto peer overlays 
application significantly different existing applications focus file sharing content distribution 
shared state distribution replication mechanism handle games extended handle forms peer peer computing 
need done proof concept demonstration 
simple game network emulation assumes uniform latency 
experimenting games larger amount states globally distributed network platforms 
addition validating idea result may motivate optimizations state transfer latency reduction 
furthermore cheating serious problem online games problem exacerbated architecture large portion game function executed untrusted peers 
plan prevent cheating detection 
cheat detection resource consuming job distribute ieee ieee infocom load peers 
architecture potentially suitable cheat detection locality interest basic replication scheme apply game monitoring game states 
acknowledgment michael greenwald jonathan smith anonymous referees suggestions improved content presentation 
research supported part dod university research initiative uri program administered office naval research 
amir dolev melliar smith moser 
robust efficient replication group communication 
technical report cs hebrew univ jerusalem 
david anderson jeff cobb eric matt dan 
seti home experiment public resource computing 
communications acm nov 

experimental estimation latency sensitivity multiplayer quake 
proceedings th ieee international conference networks icon sydney australia september 
nathaniel brian neil levine 
cheat proof playout centralized distributed online games 
infocom pages 
cheriton 
amaze multiplayer computer game 
ieee software 
ashwin bharambe sanjay rao srinivasan seshan 
mercury scalable publish subscribe system internet games 
proceedings workshop network system support games pages 
acm press 
butterfly net butterfly grid distributed platform online games 
www butterfly net platform 

dis vision map distributed simulation 
inst 
simulation training 
castro druschel 
kermarrec nandi rowstron singh 
splitstream high bandwidth content distribution cooperative environment 
iptps 
miguel castro michael jones anne marie kermarrec antony rowstron marvin theimer helen wang alec wolman :10.1.1.12.8387
evaluation scalable application level multicast built peer topeer overlays 
infocom april 
clip 
gnutella protocol specification document revision 
www limewire com developer 
frank dabek frans kaashoek david karger robert morris ion stoica 
wide area cooperative storage cfs 
proceedings sosp october 
judith richard fujimoto richard 
department defense high level architecture 
winter simulation conference pages 
diot gautier 
distributed architecture multiplayer interactive applications internet 
ieee networks magazine july august 
alan fekete nancy lynch alex shvartsman 
specifying partitionable group communication service 
acm transactions computer systems 
stefan fiedler michael wallner michael weber 
communication architecture massive multiplayer games 
proceedings workshop network system support games pages 
acm press 
seth gilbert nancy lynch 
brewer conjecture feasibility consistent available partition tolerant web services 
sigact news june 
henderson bhatti 
modelling user behaviour networked games 
proceedings acm multimedia pages october 
hugh holbrook sandeep singhal david cheriton 
receiver reliable multicast distributed interactive simulation 
sigcomm pages 
sitaram iyer antony rowstron peter druschel 
squirrel decentralized peer peer web cache 
podc july 
keidar 
highly available paradigm consistent object replication 
master thesis hebrew univ jerusalem 
technical report cs 
john kubiatowicz david bindel yan chen patrick eaton dennis geels ramakrishna gummadi sean rhea hakim weatherspoon weimer christopher wells ben zhao 
oceanstore architecture global scale persistent storage 
proceedings asplos 
acm november 
leslie lamport 
part time parliament 
acm transactions computer systems 
lynch shvartsman 
reconfigurable atomic memory service dynamic networks 
proceedings th international symposium distributed computing pages 
nancy lynch malkhi david 
atomic data access content addressable networks 
proceedings st international workshop peer peer march 
alan mislove post charles reis paul peter druschel dan wallach xavier pierre sens jean michel 
post secure resilient cooperative messaging system 
th workshop hot topics operating systems hotos ix may 
katherine morse 
interest management large scale distributed simulations 
technical report ics tr university california irvine 
paul mark 
gdc network programming age march 
www com features htm 
sylvia ratnasamy paul francis mark handley richard karp scott schenker 
scalable content addressable network 
proceedings conference applications technologies architectures protocols computer communications pages 
acm press 
robbert van renesse kenneth birman bradford guo mark hayden hickey malki alex werner vogels 
horus flexible group communications system 
technical report tr cornell university 
sean rhea timothy roscoe john kubiatowicz 
structured peerto peer overlays need application driven benchmarks 
proceedings nd international workshop peer peer systems february 
antony rowstron peter druschel 
pastry scalable object location routing large scale peer peer systems 
proceedings th ifip acm international conference distributed systems platforms middleware november 
antony rowstron peter druschel 
storage management caching past large scale persistent peer peer storage utility 
greg ganger editor proceedings sosp volume acm sigops operating systems review pages new york october 
acm press 
stefan saroiu krishna gummadi steven gribble 
measurement study peer peer file sharing systems 
proceedings multimedia computing networking mmcn san jose ca usa january 
nathan sheldon eric girard seth borg mark claypool emmanuel agu 
effect latency user performance iii 
proceedings nd workshop network system support games pages 
ion stoica robert morris david karger frans kaashoek hari balakrishnan 
chord scalable peer peer lookup service internet applications 
guerin editor proceedings sigcomm volume computer communication review pages new york august 
acm press 
zhao kubiatowicz joseph 
tapestry infrastructure fault tolerant wide area location routing 
technical report ucb csd uc berkeley april 
application frame white 
www net whitepaper pdf 
ieee ieee infocom 
