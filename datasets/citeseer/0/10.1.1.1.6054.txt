combined pointer purity analysis java programs new method purity analysis java programs 
method pure mutate location exists program state right method invocation 
analysis built top combined pointer escape analysis java programs capable determining methods pure methods heap mutation provided mutation affects objects created method 
analysis extracts precise representation region heap method may access able provide useful information methods externally visible side effects 
particular recognize read parameters parameter read method mutate objects transitively reachable parameter safe parameters parameter safe read method create new externally visible paths heap objects transitively reachable parameter 
analysis generate regular expressions characterize externally visible heap locations method mutates 
implemented analysis analyze data structure implementations 
results show analysis effectively recognize variety pure methods including pure methods allocate mutate complex auxiliary data structures 
methods pure analysis provide information may enable developers usefully bound potential side effects method 
keywords static analysis purity analysis effect inference 
methods object oriented languages update objects access including self object 
accurately characterizing updates important tasks 
program analyses example need understand execution invoked methods may affect information analysis maintains :10.1.1.5.9485
accurate side effect information useful program understanding documentation 
knowledge research supported darpa contract nsf ccr nsf ccr nsf ccr singapore mit alliance 
mit csail technical report mit csail tr may alexandru martin rinard computer science artificial intelligence laboratory massachusetts institute technology cambridge ma rinard csail mit edu method pure externally visible side effects especially useful guarantees invocations method inadvertently interfere computations 
researchers variety fields identified method purity useful concept 
example model checking java programs important know methods pure information allows model checker reduce search space removing irrelevant interleavings :10.1.1.29.3872:10.1.1.32.5769
presents new method purity analysis java programs 
analysis built top combined pointer escape analysis accurately extracts representation region heap method may access 
analysis conservatively tracks object creation updates local variables updates object fields 
information enables analysis distinguish objects allocated computation method objects existed method invoked 
allows analysis recognize captured objects lifetime contained lifetime allocating method 
analysis check method pure sense mutate object exists pre state program state right method invocation definition purity adopted java modeling language 
definition allows method perform mutation newly allocated objects construct objects return result 
analysis applies flexible purity criterion previously implemented purity analyses consider method pure perform writes heap locations invoke impure method 
increased precision analysis enables pure methods important programming constructs iterators complex auxiliary data structures 
purity generalizations method pure may useful generalized purity properties 
example analysis recognize read parameters parameter read method write parameter objects reachable parameter 
recognize safe parameters parameter safe read method create new externally visible paths heap objects reachable parameter 
read safe parameter properties consider unknown aliasing calling context 
method invoked context read parameter aliased non read parameter mutation occur object pointed read parameter non read alias 
common approach detecting specifying read annotations java 
program verifier safe parameter information inferred analysis aliasing information call site 
example scenario typestate checker tool tracks typestate objects important application checking complex finite state machine api usage protocols 
typestate checker precisely track state objects aliasing statically known 
time object passed safe parameter typestate checker rely fact method call change state object introduce new aliasing object 
typestate checker knows aliasing tracked object check tracked object aliased object transitively reachable non safe argument call site 
example illustrates safe parameter information increasing effectiveness static analyses 
analysis capable generating regular expressions completely characterize externally visible heap locations method mutates 
regular expressions identify paths heap start parameter static class field potentially mutated object field 
side effect information provide benefits purity analysis enables program analyses developers usefully bound potential effects method 
contributions contributions purity analysis new analysis finding pure methods unannotated java programs 
previously implemented purity analyses track variable field updates allow mutations newly allocated data structures 
analysis supports important programming constructs iterators pure methods 
supporting pointer analysis show place purity analysis top underlying pointer analysis 
updated version whaley rinard pointer analysis 
updated version retains ideas original analysis better structured order allow analysis correctness proof 
experience experience analysis find pure methods number benchmark programs 
analysis able recognize purity methods known pure reach previously implemented purity analyses allocate mutate complex internal data structures 
read safe parameters analysis detects read parameters execution method mutate objects reachable parameters 
analysis detect safe parameters read parameters execution method produce new externally visible heap paths objects reachable parameters 
write effect inference show results analysis generate regular expressions conservatively approximate heap paths externally visible locations impure method mutates 
structure section illustrates execution analysis example 
section presents mathematical notations section describes representation analyzed programs 
section gives formal presentation analysis section shows interpret analysis results 
section presents experimental results 
section discusses related section concludes 

example example overview presents sample java source code implements singly linked list class list list implementation uses list cells class cell 
lists support operations add adds object list iterator returns iterator list elements 
define class point modeling bidimensional points static methods process lists points 
main sumx list returns sum coordinates points list main list flips coordinates points list 
method sumx iterates list elements repeatedly invoking method list iterator 
method impure mutates state iterator implementation mutates field cell iterator 
iterator auxiliary object exist sumx 
section analysis able infer sumx pure spite mutation iterator 
analysis able infer impure method mutates locations accessible paths match regular expression list head data 
intuitive description analysis method program point inside analysis computes points graph models part heap method accesses program point 
nodes points graphs model heap objects inside nodes model objects created analyzed method parameter nodes model objects passed arguments load nodes model objects read outside method 
analysis uses edges model heap edge labeled field corresponds 
write denote edge labeled field intuitively edge models object models node models field analysis uses kinds edges inside edges model heap created analyzed method outside edges model heap read analyzed method escaped objects 
object escapes reachable outside analyzed method parameters normally classes cell implemented inner classes list simplicity examples uses flat format 
term denote state program right execution invoked method 
class list cell head null void add object head new cell head iterator iterator return new head class cell cell object cell data object data cell interface iterator boolean hasnext object class implements iterator cell head cell head cell cell public boolean hasnext return cell null public object object result cell data cell cell return result class point point float float float void flip float class main static float sumx list list float iterator list iterator hasnext point point return static void list list iterator list iterator hasnext point point flip public static void main string args list list new list list add new point list add new point sumx list list sample code section 
inside nodes parameter load nodes inside edges variable outside edges legend point constructor data data cell constructor analysis results simple methods constructors point cell 
case points graph corresponding method set externally visible modified fields 
object captured 
outside edge ends load node 
method analysis computes set modified fields 
field field specific node pair form analysis examines methods starting leaves call graph 
analysis examines method knowing calling context analysis computes parameterized result instantiates take account aliasing relation call site may invoke section contains complete formal presentation analysis 
analysis example presents analysis results constructor class point 
analysis uses parameter node model object parameter points 
analysis records fact point constructor mutates fields parameter node 
presents analysis results constructor class cell 
analysis uses parameter nodes model objects parameters point 
analysis uses inside edges model cell constructor creates 
constructor cell mutates fields data parameter node 
presents analysis results method list add object 
method reads head field parameter 
analysis know head points calling context 
analysis uses load node model loaded object adds outside edge head method allocates new cell model inside node invokes cell constructor arguments 
points graph call points graph invoked constructor analysis maps parameter node cell constructor corresponding nodes calling context 
case maps stands maps maps 
analysis uses node mapping incorporate information points graph cell constructor inside edge data translates inside edge data similarly inside edge stands head head head list add cell cell cell data data head cell cell constructor cell hasnext head cell list iterator analysis results simple methods 
conventions 
addition asterisk mark nodes returned analyzed method 
analysis knows fields mutated 
represents new object exist ignore mutation 
analysis adds inside edge records mutation field head 
similarly analysis examines simple methods obtains information parts 
analysis method main sumx list starts formal parameter list pointing corresponding parameter node 
method sumx calls list iterator obtain iterator list 
analysis takes analysis result iterator method maps produces points graph call shown lower half local variable points node returned iterator 
analysis iterates loop lines reaches fixed point 
presents inter procedural analysis call iteration loop body 
initially analysis maps parameter node actual argument 
analysis matches callee outside edge cell inside edge cell call maps 
key element analysis outside edges read operations inside edges write operations detect nodes load nodes stand 
presents points graph call outside edges generated outside edges put local variable point returned node 
analysis detects mutation cell usual ignores attentive reader may confused absence outside edge inter procedural analysis complex simple example 
particular explain section inter procedural analysis internal step simplifies resulting points graph removing unnecessary edges nodes 
cell list list cell data cell head cell callee node mapping 
head cell cell sumx call data points graph call 
inter procedural analysis call line iteration loop lines 
mutation inside nodes 
section contains complete formal presentation inter procedural analysis 
presents inter procedural analysis call second iteration loop body 
analysis proceeds iteration edges mappings 
presents resulting points graph call 
maps nodes callee outside edge generates loop outside edge loop edges occur analysis methods construct traverse recursive data structures 
iterations loop body produce new information 
analysis main list proceeds identically analysis main list obtains points graphs detects mutations fields node 
analysis results method main sumx analysis detect mutation parameter node load nodes reachable 
analysis guarantees method sumx pure 
hand analysis detects method main pure due mutations node transitively loaded parameter 
addition analysis able conservatively describe set modified locations 
points graph outside edges model read nodes reachable parameters 
furthermore method create head data reads exist 
describe list list cell data cell head cell cell node mapping 
head cell cell data callee sumx call data data points graph call 
inter procedural analysis call line second iteration loop lines 
set locations method modifies suffices describe paths parameter outside nodes 
paths generated regular expression head data 
may modify locations reachable path matches list head data 
section explains compute regular expressions automatically 
analysis results knowing main sumx list pure allows propagate information list calls main sumx list 
allows freely sumx assertions specifications 
main list impure know modifies locations covered heap paths match regular expression list head data 
propagate information calls long information refers locations 
example list cells matches aforementioned regular expression simple type reasoning list spine affected propagate non list calls 

general mathematical notations uses notations 
ak represents set distinct elements 
ak denotes empty set denotes disjoint set union operator 
set set subsets 
ai bi denotes partial function ai bi undefined points particular denotes partial function defined point 
function denotes function value point behaves exactly points domain relation 
furthermore 

program representation analysis context small nontrivial subset java 
straightforward extend analysis handle full java language 
program consists set classes class set methods method 
method list parameters set local variables body consisting list instructions 
method arity parameters 
pk parameter parameter 
var denotes set local variables parameters 
simplicity suppose parameters local variables object fields return values object type analysis implementation straightforward ignore parameters local variables primitive values 
class class set fields fields 
fq 
fields static attached class specific instance static fields act global variables 
distinguish static fields different instructions manipulating 
presents statements programs analyze 
suppose prior analysis application preprocessed contain statements 
instruction may alter normal control flow branching specific address method 
call instruction vr 
calls method named class object pointed 
parameter passing semantics call value 
give mechanism calls native methods analysis handles general case calls calls methods code unavailable expensive analyze 
java threads instances class java lang thread thread started calling special native method java lang thread start thread object 
body newly started thread run method thread object 
equivalently language start thread executing thread start instruction start 
cfg denotes control flow graph method cfg contains arc label lb label lb lb lb consecutive execution path inside method cfg isolated entry point entry single exit point exit label lb method pred lb set direct predecessors lb cfg succ lb set direct successors lb cfg assume conservative call graph cg call label lb cg lb contains methods may called call 
representation exceptions handled explicitly null pointer check pointer dereference detect exceptional condition allocate appropriate exception object transfer control appropriate exception handler statement name statement format informal semantics copy copy local variable new new create new object class fields new object initialized null new array new create array objects class array cells initialized null store store object field static store store static field array store store array cell load load object field static load load static field array load load array cell 
goto conditional transfer control address method condition irrelevant analysis just suppose heap side effects call vr 
vj call method named object pointed return return return currently executed method result thread start start start thread pointed relevant statements analyzed program 
current method 
check call exception thrown invoked method 

analysis presentation analysis processes individual methods analyzed program leaves call graph main method 
analysis method scope analysis method plus methods transitively calls 
program point inside analysis computes points graph models heap point 
specifically label lb method analysis computes points graph lb program point right lb points graph lb program point right lb 
addition method analysis computes set contains externally visible fields mutated field pair models mutation field parameter load node interested externally visible mutations ignore mutations inside nodes inside node models objects allocated current invocation analyzed method 
express analysis method set standard dataflow equations lb init lb entry lb lb pred lb lb lb lb equations init points graph method lb transfer function attached label lb 
transfer function lb takes points graph program point right lb produces pointsto graph program point right lb 
analysis method 
transfer function lb may side effect adding new elements set rest section organized follows 
section defines abstractions analysis 
section presents intra procedural analysis initial pointsto graph init transfer functions lb labels lb node inode pnode lnode lb inode inside nodes pnode parameter nodes lb lnode load nodes afield node field fields node field node node field lnode var node node sets notations analysis 
correspond analyzable calls 
section presents inter procedural analysis transfer functions lb labels correspond analyzable calls 
section gives high level description algorithm computes fixed point analysis equations 
sets notations presents sets notations analysis presentation 
analysis uses nodes model objects analyzed program 
introduce inside node lb label lb corresponds new array new instruction 
lb models objects created analyzed scope executing instruction label lb 
parameter node formal parameter pi analyzed method invocation method parameter node models single object object pointed actual argument 
load instructions read escaped objects objects accessible outside analyzed scope 
analysis examines method knowing calling context analysis know parts program may written fields escaped objects 
label lb corresponds load array load statement reads escaped objects analysis introduces load node lb lb models objects read label lb escaped objects 
parameter load nodes essential ability analyze knowing heap point called 
presence complete information calling context inside nodes modeling heap 
parameter load node placeholder inside nodes associated objects models 
call method inter procedural analysis computes node mapping disambiguates placeholders current calling context 
special node models objects may accessed entire program 
model objects read static field objects returned calls 
field pair conservatively represents field objects models 
points graph tuple consisting set inside edges set outside edges state local variables set globally escaped nodes edges points graph model points relation objects 
inside edges model heap created analyzed scope 
outside edges model heap read analyzed scope escaped objects 
outside edge ends load node 
arrays just special kind objects modeled nodes 
array elements non primitive type values stored array cells addresses objects 
edges represent heap 
distinguish individual array cells special field represents cells array 
models state local variables analyzed method set nodes local variable may point 
keep track objects returned analyzed method introduce special variable set nodes return 
component points graph contains nodes address stored static fields nodes correspond started threads nodes passed arguments calls 
nodes escape analyzed scope potentially reachable entire program say escape globally 
escaped nodes include parameter nodes returned nodes special node models objects returned calls read static field 
addition node reachable escaped node path inside outside edges escapes 
formally definition 
points graph boolean predicate nodes true iff reachable node pnode possibly empty path edges 
escapes captured ordering relation sets set inclusion associated join operation set union 
elements set classic elementwise ordering functions iff var 
associated join operation 

points graphs ordered componentwise iff 
join semi lattice join operator element intra procedural analysis points graph init pi 
pk parameters pa rameter pi points corresponding parameter node init empty 
analysis method wide set mutated fields initialized empty 
presents transfer functions associated labels analyzed program presents informal graphic representation transfer functions 
transfer function lb takes argument points graph program point just label lb returns points graph program point right lb 
lb may side effect adding new elements instruction label lb mutates field nodes 
define functions lb case case basis instruction label lb 
cover case analyzable call study case section 
general rule assignments variables destructive assigning removes previous values assignments node fields assigning remove existing edges start 
reason node represent multiple objects updating overwrite edge update instruction edge concern different objects 
special labels entry exit correspond concrete instruction 
transfer function naturally identity function 
case labels correspond instruction manipulate pointers 
copy instruction point nodes point 
previously mentioned analysis forgets previous value 
transfer function label lb corresponds new instruction new point inside node attached label lb lb notice object creation generate effect analysis interested mutation objects objects existed method 
store instruction analysis introduces labeled inside edge node pointed node pointed 
analysis updates set record mutation field non inside nodes pointed 
case equivalent term weak updates instruction label lb lb new lb new lb set fields added inode inode process load lb process load lb 
goto unmodified case analyzable call studied section 
vr 
vj case call vr vi return start functions lb lb label 
lb takes points graph program point right label lb produces points graph program point lb 
see informal graphic representation transfer functions 
process load lb node lb lb process load 
arguments order points graph load variable load variable load loaded field label lb load instruction 
returns points graph instruction 
statement statement new inside node statement escape escapes load node statement informal graphic representation transfer functions non call statements 
continuous circles types nodes continuous lines inside edges dashed lines outside edges 
bold circles lines potentially new nodes edges 
array store instruction similar special field models coming cells array 
analysis records mutation special field concerned nodes 
static store add nodes pointed set globally escaped nodes record mutation static field transfer function load instruction uses auxiliary function process load 
instruction points nodes pointed labeled inside edges starting nodes collect nodes set load nodes escape analyzed scope points load node lb case analysis introduces labeled outside edge escaped node read lb analyze calls outside edges detect nodes placeholder lb stands 
transfer function array load instruction identical uses special field 
call vr 
vj arguments reachable unanalyzed parts program 
analysis adds nodes pointed 
vj set globally escaped nodes 
points graph call vr points special node models objects potentially reachable entire program 
similarly start thread instruction start analysis adds nodes pointed return instruction return special variable set point returned nodes 
inter procedural analysis consider call instruction label lb vr 
vj callee cg lb possible callees 
inter procedural analysis uses points graph call points graph exit callee callee computes pointsto graph program point call valid case callee called 
possible callees conservatively join points graphs computed 
inter procedural analysis steps 
compute mapping relation node node maps nodes nodes appear final graph disambiguates parameter load nodes possible 

mapping combine 
important aspect step node projected mapping intuitively replaced nodes 

simplify resulting points graph removing superfluous load nodes outside edges 

information fields mutated callee set callee update set fields mutated describe steps paragraphs 
construction node mapping start computing core mapping disambiguates parameter load nodes constraint constraint outside edge existing mapping inside edge new mapping graphic representation constraint constraint 
possible 
define fixed point constraints vi callee 
lnode pnode constraint maps parameter node callee nodes pointed vi th argument passed callee nodes set vi 
constraints extend mapping matching outside edges read load instructions inside edges created store instructions 
constraint handles case callee reads created caller 
matches outside edge callee inside edge caller case represent 
presents graphic representation situation 
outside edge read inside edge load node node 
analysis maps constraint matches outside edge callee inside edge callee scope 
constraint deals aliasing calling context 
consider outside edge inside edge 
presents graphic representation case represent node 
case 
enforce 
node callee node placeholder represents nodes 
node represent nodes represented 
analysis updates mapping record 
reasoning valid represent real implementation constraint initialize mapping iterate constraints fixed point reached 
represent 
constraint unifies cases single condition third part precondition lnode reduces applicability constraint avoids fake mappings 
correctness proof shows condition prevent analysis detecting real mappings 
compute final mapping extending core mapping mapping non parameter node pnode maps nodes nodes appear points graph call 
inside nodes model objects created analyzed scope appear points graph call inside nodes identity relation 
know nodes parameter nodes stand 
parameter nodes unnecessary resulting points graph map extension ignores 
reason constraint pnode want callee parameter nodes appear resulting points graph avoid creating mappings 
parameter nodes load nodes generally fully disambiguated 
load node placeholder nodes specific load instruction loads escaped node 
escaped node remain escaped node points graph call 
phase preserve load nodes 
show section remove 
combining points graphs obtain node mapping combine points graph call points graph callee 
obtain points graph call valid callee called 
formally construct points graph defined equations callee callee vr equations require explanation 
heap existed call exist call 
inside edges appear pointsto graph call 
addition callee created heap edge may node may node callee created inside edges set 
edges appear points graph call 
similarly set outside edges call union set outside edges right call semi projection outside edges callee project start node outside edge target remains unmodified 
outside edge lb callee models action loading field escaped node action done load instruction label lb load node lb models objects read instruction 
may nodes read operation may take place nodes need projecting node lb meaning models objects read instruction label lb 
analysis project lb state local variables call similar state call vr local variable receives value returned callee points nodes returned callee 
projection necessary returned nodes may placeholders callee disambiguates 
set globally escaped nodes union set directly escaped nodes call set nodes directly escape callee 
points graph simplification simplify points graph program point call removing captured load nodes adjacent edges outside edges start captured node 
intuitively load node placeholder unknown nodes loaded escaped node 
need load node load captured nodes analyzed scope access captured node analysis knows nodes loaded 
points graph contains captured load node lb nodes loaded lb captured 
remove captured load nodes 
similarly remove outside edges start captured node 
modified fields update set modified fields caller adding elements set inode callee set nodes appear simplified points graph 
mapping project node modified callee 
usual ignore inside nodes set intersection ignore nodes removed points graph simplification 
analysis algorithm prove transfer functions monotonic 
analyzed program number nodes define bounded parameter node formal parameter inside node new instruction load node load instruction consequence finite infinite ascending chain solve dataflow equations iterative fixed point algorithm 
recommend variant iterating strong components algorithm chapter 
algorithm contains outer loop inter procedural analysis nested inside inner loop intra procedural nodes point outside edge 
analysis 
inter procedural computation processes strongly connected components call graph groups mutually recursive methods increasing topological order leaves call graph main method 
set mutually recursive methods algorithm uses worklist iterate set methods reaches fixed point 
processing strongly connected component worklist contains methods component 
iteration algorithm takes method worklist calls inner computation intra procedural computation analyze method 
points graph method changed possible callers method current strong component added worklist 
inter procedural computation component terminates worklist empty 
intra procedural computation similar interprocedural computation processes strongly connected components control flow graph analyzed method decreasing topological order method iterates component worklist 
complexity size analyzed program 
analysis computes points graphs program points 
height lattice points graphs anf na number nodes nf total number fields 
transfer functions easily implemented polynomial complexity 
difficult operation construction inter procedural node mapping 
notice inter procedural analysis monotonically computes mappings elements 
worst case complexity big nn anf polynomial size program 
practice pointer analysis analyze specjvm applications stack allocate captured objects remove synchronization thread local objects 

analysis results analysis terminates analyzable method points graph set modified fields infer method purity write effects read parameters safe parameters 
explain application paragraphs 
method purity check pure compute set nodes reachable parameter nodes outside edges 
compute set globally escaped nodes nodes reachable nodes potentially reachable mutated entire program native methods guarantee 
method pure iff node escape globally field mutated field constructors follow jml convention allowing pure constructor mutate fields object suffices ignore modified fields parameter node models object 
practice groups singletons 
write effects infer regular expressions describe locations modified follows construct finite state automaton states nodes points graph initial state accepting state outside edge generates transition labeled field labels outside edge 
parameter pi create transition corresponding parameter node label parameter pi 
appears create transition label empty string 
mutated field add transition accepting state label field addition globally lost node see add transition label special field reach 
heap path series fields separated dots starting parameter static field reach matches objects transitively reachable object matches regular expression corresponds constructed automaton describes modified locations 
automaton minimization algorithms try reduce size generated regular expression 
note generated regular expression valid contain inside edge load edge label 
condition guarantees heap modeled outside edges exist regular expressions supposed interpreted context 
interesting example exhibits problem 
bad situation occurs conservatively generate regular expression covers nodes reachable parameters help reach field 
practice case rare methods read mutate field 
read parameters parameter pi read iff locations transitively reachable pi mutated 
check compute set contains corresponding parameter node load nodes reachable outside edges 
parameter pi read iff field 
safe parameters parameter safe read method create new externally visible heap paths object transitively reachable parameter 
suppose pi read parameter 
detect pi safe compute set contains corresponding parameter node load nodes reachable outside edges 
pi read parameter nodes escapes globally mutated 
compute set nodes reachable parameter nodes returned nodes inside outside edges 
notice contains nodes may reachable caller create new externally visible path object transitively reachable pi needs create edge starts object modeled node automaton transition performed consuming input 
ends object modeled node 
parameter pi safe inside edge node node 

experience implementation implemented analysis mit flex compiler infrastructure static compiler java bytecode 
increase analysis precision prevent edges correspond heap manually provide points graphs common native methods 
attach type information nodes order prevent type incorrect edges avoid inter procedural mappings nodes conflicting types 
checking purity data structure consistency predicates ran analysis benchmarks borrowed korat project 
korat tool generates nonisomorphic test cases finite bound 
korat input consists type declaration data structure finitization objects type objects type repok pure boolean predicate written java checks consistency internal representation data structure 
inputs korat generates non isomorphic data structures satisfy repok predicate 
korat efficiently monitoring execution repok predicate back tracking parts data structure repok reads 
korat relies purity repok predicates statically check 
general writing repok predicates considered software engineering practice development data structure programmers write assertions invoke repok check consistency data structure runtime 
course programmers want assertions change semantics program aborting program violates assertion 
repok assertions provides additional motivation checking purity repok methods 
analyzed repok methods data structures binary tree implements set comparable keys 
array implementation fast union find data structure path compression rank estimation heuristics improve efficiency find operations 
array implementation heap priority queues data structure 
dynamic data structures implement heaps differ complexity certain operations 
linkedlist implementation doubly linked lists java collections framework part standard java libraries 
treemap implementation map interface red black trees 
implementation set interface backed hash table 
classic textbooks algorithms data structures detailed algorithmic description data structures 
linkedlist treemap standard java library 
change korat developers performed add corresponding repok methods 
repok method appendix source code repok methods similar complexity 
example appendix shows repok methods complex auxiliary data structures sets linked lists wrapper objects checking purity methods reach simple purity checkers prohibit pure methods call impure methods heap mutation 
problem faced analyzing data structures analysis program analysis operates closed world assumption particular needs know entire class hierarchy order infer call graph 
give analysis program clearly impossible case describe rest world analysis 
case need describe analysis objects put data structures 
methods data structure implementations invoke data structure elements methods java lang object equals java lang object hashcode java util comparable java lang object tostring call methods methods override special methods 
specified analysis special methods pure 
methods introduce new externally visible aliasing new externally visible path requires creating edge violating purity creating path returned object 
methods hashcode equals return primitive data objects method tostring returns immutable java lang string assume generate new aliasing 
aforementioned special methods pure create new externally visible paths 
analysis simply ignore calls methods dynamically dispatched calls 
ran analysis analyzed repok methods data structures methods transitively called methods 
analysis able verify repok methods mutate new objects pure 
pentium ghz gb ram analysis took seconds analyzed data structure 
course results valid special methods pure 
tool tries verify true special methods analysis encountered 
unfortunately methods caches performance reasons pure 
example classes cache hashcode classes cache complex data java util caches set keys entries caches nullified time map update performed 
fortunately analysis tell memory locations mutation affects 
manually examined output analysis checked fields mutated impure special methods correspond caching 
discussion theoretical point view analysis sound 
order analyze complex data structures real java library sacrifice soundness obtain practical tool 
specifically trust caching mechanism classes java library sound just performance issue 
believe making reasonable assumptions unknown code order check complex known code tradeoff 
experience shows knowing exactly method impure useful practice feature allows identify ignore benign mutation related caching 
pure methods java olden benchmark suite ran purity analysis applications java olden benchmark suite 
table presents short description applications analyzed 
standalone applications 
pentium ghz gb ram analysis time ranges seconds seconds voronoi 
case analysis processed methods user library may transitively invoked main method 
table presents results purity analysis 
application counted total number methods user library total number user methods 
category percentage pure methods detected analysis 
jml convention consider constructors mutate fields objects pure 
data table shows analysis able find large numbers pure methods java applications 
applications similar percentages pure methods library methods 
variation larger user methods ranging power perimeter 

related modern research effect inference stems seminal gifford lucassen jouvelot type effect systems 
previous effect inference done context type systems type inference functional languages 
contrast apply dataflow analysis techniques purity checking java programs 
common techniques construction inter procedural node mapping algorithm flavor unification algorithm type inference 
original gifford motivated applications program parallelization current effects done context program specification verification 
popular projects java modeling language jml extended static checker java esc java 
jml behavioral interface specification language java common specification language research projects 
annotations provided user static program verification generating runtime assertions 
methods invoked application description bh barnes hut body solver bitonic sort em models propagation electromagnetic waves dimensional objects health simulates health care system mst perimeter power tsp voronoi computes minimum spanning tree graph bentley algorithm computes perimeter region binary image represented quadtree maximizes economic efficiency community power consumers solves traveling salesman problem randomized algorithm recursive depth traversal tree sum node values computes voronoi diagram random set points table applications java olden benchmark set 
application methods user methods count pure count pure bh em health mst perimeter power tsp voronoi table percentage pure methods java olden benchmarks 
application total number user library methods percentage pure number user methods percentage pure user methods 
jml annotations provided pure 
jml allow user specify assignable locations locations method mutate 
currently purity assignable clauses checked checked conservative analyses method pure iff write heap field invoke impure methods 
esc java tool checking properties java programs 
esc java requires annotations specification language identical jml 
esc java uses theorem prover modular checking provided annotations 
checking method body esc java assumes callers method satisfy specification 
esc java checks callers ensures methods satisfy specifications 
major source constructors treated special way 
unsoundness esc java fact tool uses purity modifies annotations check 
categories approaches solve problem category relies user provided annotations second category including approach relies program analysis 
interesting approach category leino data groups 
approaches category region types ownership types specify effects granularity regions respectively granularity ownership boundaries 
general annotation approaches suited modular checking provide abstraction mechanisms hide representation details 
analysis approach appealing require additional user annotations 
situations annotations desired facilitate modular checking static analysis give user hint annotations look 
briefly discuss related static analyses 
chase syntactic tool designed cata huisman modular checking jml assignable clauses 
method tool traverses method code collects write effects assignable clauses specification invoked methods 
lightweight useful practical situations chase unsound syntactic tool particular analysis keep track values points relation variables fields ignores aliasing 
poll propose interpretation static analysis detects mutated locations 
contains compelling evidence static analysis purpose propagate set mutated locations information new values stored locations analysis results unsound overly conservative 
analysis uses set inside edges keep track new value pointer fields 
unfortunately unaware implementation analysis poll 
fugue protocol checker tool benefit analysis 
fugue tracks correct usage finite state machine protocols 
fugue requires user annotations rich type system specifies state tracked objects method entry exit 
aliasing tracked objects statically known 
library methods relevant checked protocol tedious annotate 
addition promote code reuse fugue attempts support library methods tracked objects objects aliasing may fully known compile time 
fugue tries find parameters equivalent safe parameters 
current analysis type checking algorithm fugue conservative allow object stored fields locally captured objects iterators 
model checking java programs benefit analysis 
example interleavings pure methods distinct threads irrelevant 
true treat synchronizations memory writes 
model checker information reduce search space 
corbett uses related shape analysis reduce finite state models multithreaded java programs identifying thread local objects 
interleavings operations thread local objects irrelevant 
ernst proposed javari java immutability extension java allows programmer specify read parameters called const javari 
type checker checks programmer annotations 
read annotations parameters great documentation asset catch practical bugs related unintended mutation 
cope caches real applications javari allows programmer declare mutable fields 
fields mutated belong const object 
course mutable annotation extreme caution 
encountered problem analyzing real java programs methods impure simply caching performance issues 
tool practical expose mutation caches programmer allow programmer judge mutation allowed 
tool perfect companion javari imagine tool infer read parameters legacy code 
programmer refine annotations small program changes increase number read parameters 
researchers considered pointer analysis side effects 
previous analyses analysis uses separate abstractions inside node objects allocated current invocation analyzed method 
analysis focuses mutation supports pure methods mutate newly allocated objects 

recognizing method purity important variety program analysis understanding tasks 
implemented method purity analysis capable recognizing pure methods mutate newly allocated objects including encapsulated objects escape creating method 
analysis produces precise characterization accessed region heap recognize generalized purity properties read safe parameters 
experience implemented analysis indicates effectively recognize pure methods 
provides useful tool support range important program analysis software engineering tasks 
important direction concerns making analysis better suited analysis incomplete programs libraries possible specification missing parts program 
assignable clauses jml sufficient specify way mutated locations new aliasing created mutation 
points graphs contain information hairy specification language 
section ad hoc solution order analyze consistency predicates data structures systematic solution required 
ideally specification language respect abstraction boundaries reveal private implementation details 
authors people help possible 
darko marinov viktor provided research suggestions darko gave korat testcases 
wrote regular expression java package brian proof read parts 

scott 
mit flex compiler infrastructure java 
www flex compiler lcs mit edu 
adrian 
compiler enforced immutability java language 
technical report mit lcs tr mit laboratory computer science june 
revision master thesis 
chandrasekhar boyapati khurshid darko marinov 
korat automated testing java predicates 
proc 
international symposium software testing analysis pages july 
chandrasekhar boyapati martin rinard 
parameterized type system race free java programs 
proc 
th annual acm conference object oriented programming systems languages applications 
lilian burdy cheon david cok michael ernst joe gary leavens rustan leino erik poll 
overview jml tools applications 
technical report nii computing science institute univ nijmegen march 
kathryn mckinley 
data flow analysis software prefetching linked data structures java 
proc 
th international conference parallel architectures compilation techniques 
martin carlisle anne rogers 
software caching computation migration olden 
proc 
th acm sigplan symposium principles practice parallel programming 
nestor cata marieke 
chase static checker jml assignable clause 
proc 
th international conference verification model checking interpretation volume lncs january 
dave clarke sophia drossopoulou 
ownership encapsulation disjointness type effect 
proceedings th acm conference object oriented programming systems languages applications pages 
acm press 
james corbett matthew dwyer john hatcliff corina pasareanu robby shawn laubach hongjun zheng 
bandera extracting finite state models java source code 
proceedings nd international conference software engineering icse june 
james corbett 
shape analysis reduce finite state models concurrent java programs 
software engineering methodology 
thomas cormen charles leiserson ronald rivest cliff stein 
algorithms second edition 
mit press mcgraw hill 
patrick cousot radhia cousot 
interpretation unified lattice model static analysis programs construction approximation fixpoints 
proc 
th popl 
karl crary david walker greg morrisett 
typed memory management calculus capabilities 
proc 
th acm popl 
robert deline manuel hndrich 
typestates objects 
proc 
th ecoop june 
brian martin rinard 
role exploration object oriented programs 
proc 
international conference software engineering 
cormac flanagan rustan leino mark greg nelson james saxe raymie stata 
extended static checking java 
proc 
acm pldi 
michael hind anthony 
pointer analysis 
proc 
international symposium software testing analysis 
pierre jouvelot david gifford 
algebraic reconstruction types effects 
proc 
th acm popl 
viktor patrick lam martin rinard 
role analysis 
proc 
th popl 
viktor rustan leino 
place refinement effect checking 
second international workshop automated verification infinite state systems avis warsaw poland april 
gary leavens 
advances issues jml 
presentation java verification workshop january 
gray leavens albert baker clyde ruby 
preliminary design jml 
technical report iowa state university 
rustan leino arnd poetzsch heffter zhou 
data groups specify check side effects 
proc 
acm pldi 
barbara liskov john guttag 
program development java abstraction specification object oriented design 
addison wesley 
john lucassen david gifford 
polymorphic effect systems 
pages 
acm press 
darko marinov khurshid martin rinard 
evaluation exhaustive testing data structures 
technical report mit lcs tr mit csail cambridge ma september 
ana milanova barbara ryder 
parameterized object sensitivity points side effect analyses java 
proc 
international symposium software testing analysis july 
peter mueller arnd poetzsch heffter gary leavens 
modular specification frame properties jml 
technical report tr iowa state university february 
flemming nielson hanne riis nielson chris hankin 
principles program analysis 
springer verlag 
alexandru 
pointer analysis applications java programs 
master thesis mit laboratory computer science 
fausto erik poll 
static analysis jml assignable clauses 
proc 
th workshop foundations object oriented languages 
tofte birkedal 
region inference algorithm 
transactions programming languages systems july 
van der berg jacobs 
loop compiler java uml 
technical report csi computing science institute univ nijmegen december 
willem visser klaus havelund guillaume brat park 
model checking programs 
int 
conf 
automated software engineering 
whaley rinard 
compositional pointer escape analysis java programs 
proceedings th annual conference object oriented programming systems languages applications denver november 
appendix example repok contains example repok method binary search tree implements set 
object class represents binary search tree 
size field contains number nodes tree 
objects inner class node represent nodes trees 
elements set stored info fields 
elements implement interface comparable provides method comparisons 
example repok checks input valid binary search tree correct size 
repok checks tree empty 
repok checks sharing underlying graphs nodes reachable root left right fields 
checks number nodes reachable root size 
checks elements left right subtree node smaller larger element node 
method uses breadth traversal check underlying object graph tree 
traversal keeps set visited nodes worklist nodes need traversed 
notice nodes put set wrapper class 
need class standard java util set compares elements equals methods want compare nodes set comparison object identity 
wrapper class typical way achieve behavior 
analysis finds auxiliary methods isordered pure repok pure 
easy establish isordered pure update heap location 
writes heap locations modifies visited set worklist list 
additionally creates wrapper objects putting nodes elements set 
analysis precise determine mutation occurs new objects 
import java util class node root root node int size number nodes tree static class node node left left child node right right child comparable info data static final class wrapper object wrapper object public boolean equals object instanceof wrapper return false return wrapper public int hashcode return system boolean repok checks empty tree size zero root null return size checks input tree return false checks size consistent root size return false checks data ordered isordered root null null return false return true boolean set visited new visited add new wrapper root linkedlist worklist new linkedlist worklist add root worklist isempty node current node worklist current left null checks tree sharing visited add new wrapper current left return false worklist add current left current right null checks tree sharing visited add new wrapper current right return false worklist add current right return true int node null return return left right boolean isordered node comparable min comparable max min null info min max null info max return false left null isordered left min info return false right null isordered right info max return false return true binary tree methods code appendix binary search tree implementation repok method 
