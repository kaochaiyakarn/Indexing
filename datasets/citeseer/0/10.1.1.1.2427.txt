ordering broken unit tests focused debugging markus lli michele lanza oscar nierstrasz software composition group university bern switzerland lanza oscar iam unibe ch current unit test frameworks broken unit tests arbitrary order developers want focus specific ones 
inferred partial order unit tests corresponding coverage hierarchy sets covered method signatures unit tests coverage hierarchy break guide developer test calling smallest number methods 
experiments case studies indicate partial order semantically meaningful faults cause unit test break generally cause specific unit tests break 
keywords unit testing debugging 
unit testing increasingly popular years partly due interest agile development methods 
fault cause unit tests break developers know broken unit tests gives specific debugging context examined 
propose partial order unit tests means coverage sets unit test covers unit test set method signatures invoked superset set method signatures invoked explore hypothesis order provide developers focus needed debugging phases 
exposing order gain insight correspondence unit tests defects number related unit tests break chance breaking common defect hand unrelated unit tests break may suspect multiple defects 
key unit test suite run identify central unit tests failed caused failure proceedings icsm wuyts lab software composition decomposition universit libre de bruxelles wuyts ulb ac avalanche effect tests suite 
results case studies promising unit tests comparable test cases means coverage sets covered unit tests covered 
method mutations artificially introduce errors test case majority cases error propagated test cases covering 
structure article 
section describe problem implicit dependencies unit tests 
section describe solution problem 
section experiments carried case studies 
section discuss findings 
section give brief overview related 
section conclude remarks concerning 

implicit dependencies unit tests example 
assume unit tests simplified university administration system tests person having added professor role 
tests university knows person person added 
tests roles person defined 
tests name person assigned correctly 
detailed look run time behavior test cases see 
furthermore assume implementation person class new broken roles initialized role variable person undefined 
run tests fail university class name 
name 
university class name 
name 

professors person class 
assert persons includes person class assert professors includes new new persons professor class person university new 
persons university 
test covers test 
intersecting signatures displayed gray 

test see yields null pointer exception undefined object understand add occurring person 

test see assertion person roles fails pointing directly problem hand 
failing test case provides developer directly information needed fix error 
order unit tests sets covered methods 
methods called called see 
methods sent included set methods sent see 
note covered test covering 
consider unit tests 
draw arrow unit test covers second defined section 
test method person test method class person class assert person roles person class new assert person name aname name 
new name roles 
small unit tests cover 
invoke run time set methods various classes 
invoke methods coverage set includes 
note require invoke test remotely logical conditions merely methods executed test run 

sample test hierarchy coverage sets 
unfortunately existing unit testing tools frameworks order unit tests terms method coverage collect information 
investigate hypothesis multiple unit tests fail ones cover fail due defects 
provide initial evidence unit tests typical application comparable covers relation partially ordered 
unit test fails test covers typically fails 
unit tests break coverage chain coverage hierarchy infer single defect causing unit tests break 
smallest test sense covers methods provides better focus helps find defect quickly 
case fact unit tests related consider group debugging process 

ordering broken unit tests section explain approach ordering detail discuss implementation smalltalk environment 
problem tackle infer coverage hierarchies set unit tests 
need generate traces order 

approach order tests dynamic analysis runnable test cases apply dynamically statically typed languages interested actual paths taken unit tests examined unit tests written smalltalk version series unit test frameworks exist languages 
approach structured follows 
create instance test sorter store partially ordered test cases 

iterate unit tests application 
instrument methods application obtain trace information messages sent 
exact instrumentation mechanism obtain information depends implementation language 
concept method wrappers methods looked method dictionary replaced wrapped versions trigger actions method executed :10.1.1.49.7167
method wrapper simply stores wrapped method executed 

execute unit test case api obtain set method signatures called test case iterating wrapped methods checking executed check set empty example due fact test called methods prerequisite packages set empty create new instance covered test case store set method signatures test add covered test case test sorter reset method wrappers ready store unit test executes 

covered test cases equivalent sets covered method signatures equal 
obtain partial order subsume equivalent covered test cases node call equivalent test case 
equivalent covered test cases create instance equivalent test case store set method signatures names equivalent test cases store test sorter remove equivalent covered test cases test sorter 
note covered test cases equivalent test cases test nodes superclass store shared behavior 

order resulting test nodes stored test sorter relationship test node smaller test node set method signatures included set method signatures pairwise compare remaining test nodes build partial order 
store covering covered relationship variables test node 

compute transitive reduction lattice eliminating redundant covering relations test nodes 

obtain instance test sorter ask tests attack 
note case studies non breaking unit tests 
real world scenario broken unit tests test sorter initialized tests non breaking reinitialize broken unit tests 

implementation order perform experiments validate claim implemented approach visualworks smalltalk see www com information 
chose implementation visualworks smalltalk tools wrap methods assess coverage freely available numerous case studies available build available tool codecrawler visualize information obtained 
obtain trace information aspects flexible tool builds john brant :10.1.1.49.7167
aspects obtains traces way method wrappers described aspects lets obtain detailed information current state stack method entered 
java aspectj 

case studies performed experiments systems created different developers unaware attempts structure tests writing 

application easy graphically view change export import keyboard bindings visualworks smalltalk 

van rba version analysis tool built top moose reengineering environment 

smallwiki collaborative content management tool 

codecrawler lanza language independent reverse engineering tool combines metrics software visualization 

setup experiments phase ordered unit tests case study described section measured relevant portion comparable coverage criterium 
second phase introduced defects methods validate unit test breaks covering unit tests break 

iterated test cases case study covered test case 
determined methods invoked tests test covered homepages ulb ac index html 
mutated methods mutation strategy 
mutation executed unit tests covering unit tests collected results 
mutation strategies 
full body deletion removed complete method body 

code mutations jester jester mutation testing extension test junit tests finding code covered tests 
jester change code runs tests tests pass jester reports changed 
applied mutations jester change occurrences number number flip true false vice versa change conditions iftrue statements true conditions iffalse statements false 

results case studies detail table table 

coverage hierarchy code crawler tests visualized code crawler 
see table experiment performed applications lines code 
ratio loc tests loc reached 
maximum test coverage 
arrow top bottom denotes test node top covers test node bottom 
see typical coverage hierarchy obtained part experiment unit tests covered system loc loc tests coverage unit tests equivalent tests tests covered tests magic keys van codecrawler smallwiki table 
resulting coverage unit tests case studies 

distribution comparable test nodes case studies 
covered unit test stand 
considerable percentage unit tests see table called set method signatures test 
unit tests covered unit test 
means roughly third test case studies probability high test fails fail 
carried second phase experiment automatic method mutation case studies code crawler 
mutations codecrawler resulted endless loops time complete 
merely full deletion mutation th method omitted jester mutations 
results displayed table full deletion mutations method broke smallest test calling method covering tests jester mutations 
note number mutated methods larger number methods method mutated context different tests 
detailed look effects full method deletion coverage hierarchy magic key tests 
mutating method called test covering tests 
picked rare example covering tests failing 
node including equivalent test cases fail deleted method 
hand tests fail cover test merely non empty intersection set including mutated method 
note standalone test lowest number method signatures called system methods strategy methods mutated errors propagating covering tests magic keys full deletion jester van full deletion jester codecrawler full deletion smallwiki full deletion jester table 
results automatic mutation experiments 

avalanche effect coverage hierarchy magic keys 
manually introduced bug causes test cases fail 


discussion experiments performed simple remarkable consistency results case significant majority test cases comparable unit tests stringent criterion inclusion sets called methods 
furthermore case study consistently showed defect causes particular unit test break unit tests precede partial order tend break 
partial order tests accidental exposes implicit dependency relationships tests 

semantic ordering tests focused bug tracking partial ordering unit tests 
providing order unit tests help developer comprehend structure unit tests structure underlying system 
developer perceived layering system order test cases reflects layering 
method names example table indicate parallel structure tests method names list suggest hierarchical system signature test case magic keys magic keys magic keys codecrawler codecrawler codecrawler 
limitations lightweight nature approach drawbacks limitations unexpected result jester mutations applicable unit tests cases broken inner test case meant covering tests broken 
assumption specific jester mutations covering test cases survive incorrect jester method fatal majority covering tests full body deletions 
plan realistic mutations manual errors experiments overcome problem 
parallel tests cover differ method signature 
sorting basically equal unit tests add advantage exception telling 
far limited case studies smalltalk programs 
style conventions smalltalk produce results differ objectoriented languages 
developers case studies members research group working academia plan case studies programs developed industrial settings 
measured implications real bugs 
unit tests break just real bug artificial mutation 
distinction failures errors evaluating chain failed tests caused mutation 
table 
examples equivalent test cases 

related unit testing major issue software development decade test driven development tdd technique testing development occur parallel providing developers constant feedback 
popular unit testing framework tdd named currently prioritize failed unit tests 
define process test driven development starts fine grained tests proceeds coarse grained tests 
state set test cases identified attempt order test case runs way maximizes early testing 
means defects potentially revealed context methods possible making defects easier localize approach tests written particular order mind approach investigate posteriori orderings existing tests 
rothermel introduce term granularity software testing focus cost effectiveness test suites debugging processes 
selective regression testing concerned determining optimal set tests run software change 
similarities described emphasis quite different selecting tests run analyse set tests failed suggest examined 
test case prioritization successfully past increase likelihood failures occur early test runs tests prioritized different criteria criterion closely matched approach total function coverage 
program instrumented test case number functions program exercised test case determined 
test cases prioritized total number functions cover sorting order total function coverage achieved starting highest 
wong compare different selection strategies regression testing propose hybrid approach se lect representative subset tests combining modification selection minimization prioritization 
emphasize tests run failing tests ordered 
modification selection key minimize number tests run relying having prior versions tested program approach principle having prior versions order tests coverage failed tests 
zeller delta debugging simplify test case input reducing relevant execution states finding failure inducing changes 
focus reducing failing tests set semantically different tests concise failing tests 
technique zeller pay smaller tests initial input 

proposed lightweight approach partially order unit tests terms sets methods invoke 
initial experiments case studies reveal technique exposes important implicit ordering relationships independent tests 
furthermore experiments show partial order corresponds semantic relationship specific unit tests tend fail specific unit tests fail 
reported experiments step 
plan explore larger case studies see results scale 
correspondence partial order failure dependency unit tests needs tested kinds defects 
plan analyze historical test failure results correspondence partial order 
far experiments limited smalltalk plan extend approach languages java 
long term interested exploring impact order structure unit tests development process 
partial order detected automatically may help guide developers debugging process may provide hints tests better structured refactored composed 
believe research step coverage information get information failing tests 
section describes ideas got experiments validating claims 

defect tracking coverage relationships aid developers track defects software changes introduced change causes multiple unit tests break partial order unit test set identify specific unit tests broken smallest coverage sets 
identifying unit tests gives developer best focus debugging 
specific unit tests probably breaking reason may introduce noise debugging process 
currently order unit tests sets covered method signatures produce run failure 
sets unnecessarily big need prior versions system test 
want compare approach coverage failed test cases taken account 

lightweight metrics sorting tests testing time size coverage sets having evidence situation depending unit tests occurs regular basis seek lightweight variants approach example testing time equivalent mechanism order tests 
unit tests covered unit tests faster executed covering ones methods inner test occur loop outer ones executed 
languages garbage collectors testing time vary 
size sets covered method signatures practical sure get specific unit test sufficient sort test cases size covered sets starting lowest 
program instrumented tests sorted 
admittedly simple way pairwise comparing test cases omitted lead faster results 
metric difficult hand show semantic dependencies unit tests 

pre postcondition keeping scenarios looking back small example gain prioritizing effect little code refactoring assertion program postcondition moved person class new 
covering tests immediately fail position giving developer specific information problem hand 
refactoring test long knows person class new executed test case 
test code reduced compose scenarios execute methods scenarios possibly deliver result executions scenario building 
identifying high level scenarios necessary run sub scenarios lead massive reduction testing time massive reuse assertions unexpected scenarios post mortem sorting approach unnecessary specific assertions fail directing developer immediately problem hand 
case studies analyze software developers wrote pre post condition invariant relying solely assertions unit tests 
common behavior smalltalk developers today open source smalltalk environment squeak version february includes unit tests pre post conditions 
methods xp suggest frequent testing developing small increments developers identify latest changed code starting point know error know error occurred want go detailed test focused assertion 
experiments experience show failed unit test comes seldom start putting assertions code need find specific 
approach combining design contract classical unit testing facing problems requires manual refactoring test cases program 
unit tests assertions self contradiction pose mental barrier developers 
missing explicit relationships unit tests methods test hard tell scenarios covering method containing postcondition 
missing integration coverage browsers current ides hard tell test scenario executes method containing postcondition 
acknowledgments rba helpful comments 
gratefully acknowledge financial support swiss national science foundation projects tools techniques decomposing composing software snf project oct sept recast evolution object oriented applications snf project sept aug 
see www squeak org information 
beck 
test driven development example 
addison wesley 
beck gamma 
test infected programmers love writing tests 
java report 
bible rothermel rosenblum 
comparative study coarse fine grained safe regression test selection 
acm apr 
brant foote johnson roberts :10.1.1.49.7167
wrappers rescue 
proceedings ecoop volume lncs pages 
springer verlag 
cleve zeller 
finding failure causes automated testing 
proceedings fourth international workshop automated debugging aug 
ducasse lanza tichelaar 
moose reengineering environment 
smalltalk chronicles aug 
rothermel 
prioritizing test cases regression testing 
international symposium software testing analysis pages 
acm press 
rba ducasse lanza 
yesterday weather guiding early reverse engineering efforts summarizing evolution changes 
th international conference software maintenance icsm 

aspects aspect oriented programming squeak 
aksit mezini editors objects components architectures services applications networked world international conference pages erfurt 
springer 
ingalls maloney wallace kay 
back story squeak practical smalltalk written 
proceedings oopsla pages 
acm press nov 
kiczales hilsdale hugunin kersten palm griswold 
overview aspectj 
proceeding ecoop 
lanza 
codecrawler lessons learned building software visualization tool 
proceedings pages 
ieee press 
moore 
jester junit test tester 
editor proceedings nd international conference extreme programming flexible processes xp 
university 
jones dixon 
extreme unit testing ordering test cases maximize early testing 
wells williams editors extreme programming perspectives pages 
addison wesley 

smallwiki collaborative content management 
university bern 
rothermel 
impact test suite granularity regression testing 
proceedings icse pages may 
rothermel harrold 
analyzing regression test selection techniques 
ieee transactions software engineering 
rothermel chu harrold 
test case prioritization empirical study 
proceedings icsm pages sept 
wong horgan london agrawal 
study effective regression testing practice 
proceedings eighth international symposium software reliability engineering pages nov 
zeller hildebrandt 
simplifying isolating failure inducing input 
ieee transactions software engineering se feb 
