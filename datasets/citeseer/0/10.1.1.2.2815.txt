ieee transactions software engineering vol 
december empirical analysis preprocessor michael ernst greg david notkin senior member ieee empirical study macro preprocessor cpp 
determine preprocessor practice analyzes packages comprising lines publicly available code 
determine incidence preprocessor usage macro definitions macro uses dependences macros complex potentially problematic inexpressible terms language features 
various aspects preprocessor particularly note data material development tools including translating reduce preprocessor usage 
results show cpp usage follows fairly simple patterns effective program analysis tool address preprocessor 
intimate connection programming language cpp cpp unstructured transformations token streams hinder programmer understanding programs tools built engineer programs compilers debuggers call graph extractors translators 
tools attempt analyze macro usage simply preprocess input results number negative consequences analysis takes cpp account preferable building tools requires understanding actual usage 
differences semantics cpp lead subtle bugs stemming preprocessor previous reports prevalence errors 
reduce preprocessor usage usage previously measured 
data analyses shed light issues related practical understanding manipulation real programs 
results interest language designers tool writers programmers software engineers 
index terms preprocessor cpp macro macro substitution file inclusion conditional compilation empirical study program understanding 
coping preprocessor programming language incomplete macro preprocessor cpp :10.1.1.44.9066
cpp define constants define new syntax abbreviate repetitive complicated constructs support conditional compilation reduce eliminate reliance compiler implementation perform optimizations 
cpp permits system dependences explicit resulting clearer separation concerns 
addition cpp permits single source contain multiple different dialects style ansi style declarations 
disciplined preprocessor reduce programmer effort improve portability performance readability cpp widely viewed source difficulty understanding modifying programs 
cpp lack structure inputs outputs token streams engenders flexibility allows arbitrary source code manipulations may complicate understanding program programmers tools 
worst case preprocessor merely determining program text difficult determining output ordinary program 
designer language shares ernst department electrical engineering computer science laboratory computer science massachusetts institute technology massachusetts ave cambridge ma 
mail lcs mit edu 
th ave ne washington 
mail cs washington edu 
notkin department computer science engineering university washington box seattle wa 
mail notkin cs washington edu 
manuscript received dec revised apr accepted dec 
recommended acceptance palsberg 
information obtaining reprints article please send mail tse computer org ieeecs log number 
ieee preprocessor noted problems occasionally extreme uses cpp useful facilities unstructured intrusive constant problem programmers maintainers people porting code tool builders 
wide range possible uses preprocessor research addresses question practice 
statistical analysis programs comprising lines code provides significant insights respect question 
aware similar data analysis literature 
initial motivations pursuing line research 
wanted evaluate potential reducing preprocessor usage converting program 
second wanted know difficult produce framework preprocessor aware tools 
third wanted develop tool identifying common pitfalls macros 
motivations drove selection data extracted analyses performed 
data analyses insights take substantive steps addressing issues 
analysis confirms preprocessor exceptionally broad diverse ways complicating development programming support tools 
thirds macro definitions uses relatively simple variety programmer understand simple tedious effort relatively unsophisticated tool manage practice try 
simple kinds macros predominate preprocessor heavily worthwhile understand annotate eliminate remaining third macros macros cause difficulties 
ernst empirical analysis preprocessor different programmers different backgrounds different tasks 
differences lead substantial variations programmers preprocessor attitudes preprocessor data preprocessor find interest 
repeatedly data confirms person intuition comes surprise component data effects different individuals 
provide broad range analyses expectation different readers focus different parts choose extend specific directions 
remainder organized follows section provides additional detail difficulties imposed preprocessor 
section describes experimental methodology 
sections bulk results macro preprocessor 
section discusses related section suggests techniques mitigating negative impact cpp program understanding 
section presents avenues concluding section discusses relevance research 
background tools lesser degree software engineers options coping cpp 
may ignore preprocessor directives altogether accept code usually running cpp input attempt emulate preprocessor tracking macro definitions value conditional compilation tests 
approach different strengths weaknesses 
ignoring preprocessor directives option tools produce approximate information lexical approximate parsing techniques 
accurate information function extents scope nesting declared variables functions aspects program required preprocessor ignored 
operating code common strategy simple implement tool input differs programmer sees 
line number mappings maintained information lost mapping back original source code 
source level debuggers symbolic names types constants functions introduced define tools trace set breakpoints function macros ordinary functions inlined 
example tool working code type inferencing produce function templates input preprocessed include files incorporated macros expanded 
preprocessing may limit readability resulting templates converting terse high level named constructs verbose lowlevel code 
preprocessing may limit reusability macro expanded code perform incorrectly compiled system different settings macros 
example call graph extractors generally terms code human intended consumer call graph 
tool manipulates code run program preprocess platform tool run 
tools reject ill formed programs compile errors 
constraints complicate porting maintenance situations program understanding transformation tools needed 
additionally tool supplied instantiation source code reason program version results particular set preprocessor variables 
instance bug configuration may discovered despite exhaustive testing analysis configurations 
final option emulating preprocessor fraught difficulty 
macro definitions consist complete tokens need complete expressions statements 
conditional compilation alternative macro definitions lead different results single original program text 
preprocessing adds complexity implementation trade performing preprocessing maintaining code close original form 
extracting structure macro obfuscated source task faint 
despite problems situations sort preprocessing cpp analysis produce useful answers 
choices options currently absence understanding cpp practice 
cpp potential pitfalls known previous examined actual preprocessor determine presents practical merely theoretical obstacle program understanding analysis modification 
fills gap examining cpp programs comprising lines source code 
analysis focuses potential pitfalls complicate software engineers tool builders high total sections 
heavy macro substitution conditional compilation overwhelm human tool 
lines depend macros macros affect lines problematic 
complicated bodies section 
macro body need expand complete syntactic entity statement expression 
extra linguistic features section 
macro body may exploit features preprocessor available token pasting free variables 
macro pitfalls section 
macros introduce new varieties programming errors function macros ieee transactions software engineering vol 
december fig 

analyzed packages sizes 
ncnb lines lines 
packages publicly available free internet 
give version numbers permit reproducing results 
fail swallow semicolon macros modify fail uses arguments 
multiple definitions sections 
uncertainty expansion macro harder confidently understand actual program text 
definitions macro may incompatible instance expands statement expression type 
inconsistent usage section 
macro conditional compilation expand code harder understand exclusively purpose 
mixed tests section 
single cpp conditional directive may test conceptually distinct conditions making difficult perceive test purpose 
variation 
preprocessor varies widely 
absence clear pattern commonly repeated paradigms obvious point attack presents eliminate complexity little effort 
examine issue 
report detail aspects preprocessor indicating innocuous practice problematic uses appear frequently 
macro bodies macro features macro errors conditional tests 
taxonomies detailed previous reflect actual accurately 
methodology programs wrote analyze publicly available software packages represent mix application domains user interface styles graphical versus text command line versus batch authors programming styles sizes 
intentionally omitted libraries libc may macros differently application programs 
fig 
describes packages lists sizes terms physical lines newline characters ncnb lines 
ncnb disregards lines consisting comments whitespace null preprocessor directives followed whitespace produces output lines conditional evaluate true analyses skip comments account percent lines 
line numbers ncnb length 
built package times course analysis ran analysis programs marked version source code created third build 
compilation standard build redhat libc gnu linux system generate source files package 
example configure script prepares package compilation creating header files ernst empirical analysis preprocessor source files automatically generated 
second compilation identified global variables 
variables making static preprocessor macro empty expansion recompiled link linking fail multiple definitions variable nm program read global symbols resulting object files executables 
static file global variables shown compilation output 
third compilation pcp extensible version preprocessor place compiler 
step main purposes 
identifies code header files processed compiler see details 
second saves information regarding flags passed compiler indicate preprocessor macros defined undefined command line 
third extension pcp creates copy source code identifiers possibly macro expanded specially marked macros expanded conditionals discharged 
pcp analysis performs conservative reaching definitions analysis examines sides cpp conditional identifier marked possibly expanded define identifier occurs site side cpp conditional undef definitely encountered subsequently outside conditional sides conditional 
examine code cpp conditionals may evaluate true pcp analysis treats include directives just real preprocessor included file processed cpp conditional guards evaluate true 
avoid attempts include header files system 
analysis examines files compiled application omits platform dependent ms dos vms files source code build process 
result see multiple versions system dependent macros analyze possible configurations software package operating system hardware setup 
marking potentially expanded macros processed source files program wrote study 
program collects statistics macro definitions uses dependencies reported details operation reported appropriate results 
tool includes approximate cpp aware parsers expressions statements declarations 
performs approximate parsing input may valid program result may misinterpret constructs cope partial constructs conditional compilation branches 
results reported omit macros defined external libraries usr include hierarchy package source code omit macro uses libraries 

cases modified build process preserve files instance makefile gs creates compiles packages deletes 
tools automatically informed problems detecting macro corresponding definition deleted file 
macros uses omitting prevents library header files uses macros defined swamping characteristics package code focus study 
programmer generally control libraries header files may know library symbol defined macro 
raw data includes considerable data reported programs generate manipulate available authors 
packages widely available internet authors 
occurrence preprocessor directives fig 
shows preprocessor directives appear packages analyzed 
prevalence preprocessor understanding cpp constructs crucial program analysis 
preprocessor directives percent program lines 
packages percentage varies percent percent 
figures include percent lines expand macro percent lines inclusion controlled see section 
conditional compilation directives account percent total directives packages macro definitions comprise percent file inclusion percent 
packages uniform mix preprocessor directives 
group bars fig 
scaled version top group 
particular prevalence include essentially independent incidence directives 
percentage directives conditionals varies percent percent percentage directives defines varies percent percent percentage directives includes varies percent percent 
wide variation usage indicates tool understanding cpp focus just subset directives 
line undef directives definedness macro boolean value 
undef rarely set macros false percent undef directives precede unconditional definition just undefined macro generally avoid preprocessor warnings incompatible macro redefinitions percent undef directives unconditionally follow definition macro percent uses gs 
usage limits macro definition restricted region code effectively providing scope macro 
macros appear expansions macros code region result kind dynamic binding 
line appears lex yacc output enables packages build systems lacking lex yacc equivalents 
instance flex uses parse input includes processed version input specification code corresponding file bootstrapping 
fig 
omits unrecognized directives rarely appearing directives pragma assert ident 
packages studied account percent directives 
ieee transactions software engineering vol 
december fig 

preprocessor directives fraction ncnb lines 
group bars represents percentage ncnb lines containing specific directive 
conditional compilation directives ifdef ifndef elif endif grouped 
example top bar fourth group indicates percent gzip ncnb lines includes bottom bar fifth group indicates percent lines packages conditional compilation directives 
packages heavy preprocessor gzip remind perl packages deserve special attention heavy preprocessor usage percent percent percent ncnb lines respectively 
gzip disproportionately defines macros literals uses system call arguments enumerated values directory components 
macros act const variables 
gzip contains conditional compilation directives low level file operations accessing directories setting access control bits done differently different systems 
bash portable large variety systems uses operating system services percent conditional compilation directives test definedness macro presence absence boolean flag indicating current system supports specific feature 
presence absence feature requires different additional system calls code 
remind supports speakers multiple natural languages defined constants essentially user output 
contains disproportionately conditional compilation directives percent test definedness proto order provide ansi prototypes 
perl high preprocessor usage attributed part define directives percent preprocessor lines 
percent namespace management permit short names code colliding libraries extensions applications embed perl 
perl frequently uses macros inline functions shorthand expressions define sb iters cx cx subst iters define av av max macro definition bodies section examines features macro definitions may complicate program understanding 
results ernst empirical analysis preprocessor fig 

categorization macro definition bodies 
legend numerically represents information top row 
packages ordered preprocessor directives line fewest fig 

indicate necessity difficulty thorough understanding macro definitions software engineer tool 
example percent macro bodies expand partial syntactic entity symbol constant expression statement see section percent macros take advantage cpp features lie outside programming language see section percent macros contain latent bugs see section 
second half section considers macro names multiple definitions complicate understanding 
packages examined percent macro names multiple definitions see section percent macro names definitions different syntax trees see section 
macros multiple definitions percent syntactically incompatible definitions substituted code see section 
categorizations section macro definitions section shows categorize macro names multiple definitions 
macro body categorization categorized macro bodies categories simplicity presentation coalesces higher level categories omits insignificant 
started set categories expected occur frequently similar macro taxonomies iteratively refined break overly broad categories add unanticipated ones 
fig 
reports package definitions fall category 
macros act language constructs variables functions easiest analyze understand translate language constructs 
percent macros bodies expressions percent statements may handled relatively easily people tools 
macros especially expand complete syntactic construct problematic 
macro body categories follows example comes packages studied 
null define 
macro body empty define proto 
cpp conditionals macros frequently act boolean variables 
expanded code represent optional syntax 
instance macro private may expand static depending debugging mode set 
constant 
macro body literal percent category operator applied constant values percent category 
instance define arg max define hosts define literals define re dup max define red cols red bits bits constant possibly literal define constants 
macros act const variables 
category includes macros value invariant configurations package depend compile time values 
ieee transactions software engineering vol 
december expression 
macro body expression define define mod time 
macro acts function returns value macro need take arguments uses may look syntactically function calls 
statement 
macro body statement define signal return return define ordinal override plu define free free null define swallow line fp int getc fp eof macro similar function returning void macro body complete statement uses followed semicolon 
reduce number categories presentation statement category aggregates categories distinct analysis single complete statements comprising percent category statements missing final semicolon percent category define quit interrupt state throw top level multiple statements percent multiple statements lacks semicolon percent partial statements multiple statements partial percent statement category define assert string 
type 
macro body type partial type percent category example storage class static declaration percent category declaration missing terminating semicolon percent category 
examples include define ptr void define inline extern inline define float arg type union flt int define partial types eliminated straightforward translation templates may provide hope 
typedefs may able replace full types instance typedef void ptr replace example 
adding prefix ptr declare constant pointer typedef version pointer constant memory 
syntactic 
macro body punctuation percent category example define contains unbalanced parentheses braces brackets percent category 
create block perform actions occur gc protect gc protect examples define int nonlocal global define nonlocal global global define cases define large pre large size pre obj large size pre define small size pre obj small size pre macros category inexpressible abstractions directly programming language depend preprocessor manipulation uninterpreted token streams 
act punctuation syntax programming language 
enforce block exit actions destructor block local variable 
symbol 
macro body single identifier function name percent category reserved word percent category percent uses variable names reserved words dialect 
examples include define allocate stack malloc define macro body macro name inherits macro name categorization appearing symbol 
unknown identifier 
macro expands single identifier defined package library header file included package 
example define signal bsd signal define symbol may defined compiler command arguments may inside conditional compilation guard meaningful particular architecture system library header files available 
unknown identifiers local variables variables functions failed parse 
approximate parser succeed exact parse code deviates language grammar entities interrupted preprocessor directives occasionally fails recognize declarations definitions 
perl unknown identifiers percent macro definitions compared percent mosaic second largest proportion unknown identifiers average percent 
order avoid link time collisions perl interpreter embedded application perl conditionally redefines global symbols add prefix perl asin define perl 
code 
predominant macros assembly code filenames operating system command lines 
assembly code component includes macros expansion assembly code expressions statements contain snippets assembly code encountered macros system libraries packages examined 
tool processes source code makefiles non files compiled package built 
header files code ernst empirical analysis preprocessor files customize makefiles build process files contribute macros expanding filenames command lines define lib motif define lib standard lib lib package defined macros category appear emacs 
comprise definitions names uses code files omit figures 

category contains macros categorized 
macros percent expand macro defined package multiple definitions conflicting categorizations macro defined unambiguously categorized 
categorization failures resulted limitations parser handle pasting token concatenation converting macro argument string represent percent failures 
handling partial entities incomplete case labels percent failures partial expressions percent declarations percent left bodies pass non class object type operator macro percent 
biggest problem macros adjacent identifiers generally permitted percent macros 
macro bodies macro argument statement operator expand partial declaration cast 
examples include define syslog define png export type symbol type symbol define gx device psdf common gx device vector common psdf distiller params params cases uses macros categorized caused macro bodies appeared similarly categorized 
categorization conservative categorize macro body example statement definitively parsed merely tokens predominantly appear statements certain arguments passed result statement 
result category contains macros heuristically placed category increased risk macros 
number categorization failures small percent definitions packages macros definitions variety failure stands classification failures extensive categorization affect 

cpp specification states input syntactic code avoid performing replacements comments string constants 
practice uses cpp non files forced preprocessors relax assumptions input 
extra linguistic capabilities preprocessor capabilities outside programming language primary motivation cpp 
constructs special challenges program understanding especially reducing preprocessor translation 
section lists constructs effect provide feature unavailable language 
orthogonal syntactic category section contains macros act punctuation 
reports frequency appearance individually combination code analyzed 
capabilities effects macro code coarse categorization body full list difficult understand macros include example macros classified syntactic described section 
expected problems dealing macros conversion preprocessor macro argument string pasting creating new identifier existing identifiers explicit features cpp 
features appear percent macro definitions 
far prevalent problematic program understanding tools exploitation cpp lack structure effect mechanisms available cpp inputs outputs uninterpreted token streams cpp perform unstructured transformations non class partial syntactic constructs types partial declarations 
percent macros contain construct 
fig 
breaks macros constructs contain 
addition showing prevalence construct shows ones occur 
list describes detail constructs appearing fig 

free variables 
macro body uses subexpression applies operator function identifier formal argument variable defined macro body global variable reserved word function macro typedef name 
identifiers typically local variables site macro invocation 
uses local variables local definition scope point captures free variable macro body produce dynamic scoping directly support 
examples usage include define inv line line invisible line offset line wrap offset define atime access time side effects 
macro body directly changes program state assignment form op 
indirect side effects due function macro calls counted category 
side effect may due global variable variable local macro body macro parameter local variable scope point macro invocation 
examples varieties side effects define init fail stack fail stack avail define swallow line fp int ieee transactions software engineering vol 
december fig 

usage extra linguistic capabilities preprocessor listed section 
table indicates usage feature shows features tend 
data assist interpretation overlapping uses sums column totals larger total number macros extra linguistic feature 
features listed top percentage macro definitions exploiting 
row table reports percentage absolute number macro definitions particular combination capabilities indicated black squares 
instance sixth line indicates macro definitions percent definitions perform assignments result macro invocation type extra linguistic features listed 
getc fp eof define free var var var free var var null define add cmd cmd specific limits cmd macro assigns global variable presents difficulties understanding may translated inline function 
assignment variables local macro body easy understand assignment may ignored users macro 
macro argument assigned similar pass function argument need noted macro documentation may unexpected lacks arguments ordinarily function call change argument value 
remaining macro bodies side effects involve assignments dynamically bound variables 
macros bad situation worse unexpected dynamic binding may modification variables unexpected harder understand 
macro type 
macro body result macro invocation type instance declaration type cast define function cell var command var value define declare state hcd declare state int zeros simulate behavior types class may passed functions returned results manipulated 
pass type argument 
macro body literal type passed macro define bits char 
macro result type impossible preprocessor 
argument type 
macro uses arguments type declaration cast 
macro result type impossible language proper 
define dda step struct sname dtype struct sname dtype dq dr ndr define reverse list list type list list 
type reverse list generic list list type list uses unambiguously identified lexically analysis focuses macro definitions potential uses uses happen appear program 
instance macro define decl type name type name identified necessarily argument type invoked decl printf hello world decl 
pasting 
body uses symbol pasting treats arguments tokens strings constructing new token concatenation 
define sizeof sz macro invocation sizeof int expands identifier sz int 
resulting identifier appear literally pasted identifier uses 
pasting abstracted separate macro define concat pasting macros frequently average programs analyzed 

body uses argument replaces argument preprocessor symbol symbol contents string 
define foo bar baz expression foo expands bar baz 
examples include define spam op doc op op doc xx xx language mechanism replace macros 
feature particularly useful debugging order record exact operations performed 
ernst empirical analysis preprocessor tables internal names strings useful serialization 
self referential 
body refers name define 
feature build wrapper existing function variable 
ansi preprocessor performs level expansion recursively defined macros expanded macro contains original name 
pre ansi implementations loop forever expanding self referential macros 
erroneous macros differences execution model cpp macro expansion give rise unanticipated behavior syntactically valid programming constructs 
call macro erroneous functionality achieved function contexts macro behaves differently function 
constructs discussed section generally bugs uses cpp mechanisms achieve results outside abilities language 
verified current uses erroneous macros packages examined happen expand erroneously 
example arguments macro precedence error may expressions high precedence arguments macro evaluates argument multiple times may side effect free 
uses may give rise dormant errors especially programmers familiar generally undocumented caveats relating macro 
caveats macro prominently documented requiring arguments side effect free parenthesized macro definition argued error prone erroneous case practice 
call macros erroneous fail adhere implied specification standard execution model 
flags errors tool play role macro lint program 
discovered problems expected percent macro definitions triggered macro lint warning percent macro names definition triggers warning 
fig 
breaks warnings described 
formal 
argument subexpression adjacent operator enclosed parentheses precedence rules result unanticipated computation performed 
instance define double 
double macro invocation computes value 
warning suppressed argument entire body element comma delimited list commas lower precedence operator making precedence error 
grammar prohibits sequential expressions asa function arguments precedence error occur fig 

macro lint frequency occurrence error prone constructs macro bodies 
second column gives absolute numbers third column gives percentages 
specifically noted leftmost column percentages refer number macro definitions 
functions defined facilities take multiple arguments 
multiple formal uses 
argument expression multiple times side effects actual argument expression occur multiple times 
macro defined define exp char invocation exp char may increment pointer locations just occur exp char function 
argument side effects exp char stdin repeated evaluation may unnecessarily expensive 
dialects provide extension declaring local variable expression 
gnu achieved manner define exp char int free variables 
free variables achieve dynamic scoping discussed section 
include uses error prone instance uses macro may capture local variable times global variable difficult programmer determine achieved intended 
body 
macro body expression ought parenthesized avoid precedence problems point 
instance define increment 
increment expression value 
warning applicable macros expand expression percent expression macros contain error suppressed body single token function call high precedence 
dangling semicolon 
macro body takes arguments expands statement multiple statements percent statement macros contain error instance ieee transactions software engineering vol 
december semicolon enclosed 
invocations look function calls function call define abort kill getpid abort abort expands statements second null statement 
language grammar condition 
warning suppressed macros arguments percent statement macros define force text text section assumption odd syntax may remind programmer add usual semicolon 
solution problem wrap macro body 
partial statement requires final semicolon 
surprise macros percent statement macros standard widely recommended construct 
side effected formal 
formal argument side effected define pop low high low top lo high top hi define skip white space hor space erroneous argument lvalue value assigned 
similar constraint applies parameters model macro arguments lvalue returns 
compiler catch errors compiler messages obscure misleading presence macros goal provide earlier feedback macro definition just uses 

macro ends statement clause follows 
instance env tainting taint env condition taint env results clause executed condition false true tainting false 
problem results potentially incomplete statement may attached information 
mirror dangling semicolon problem listed resulted complete statement failed associated textually subsequent token 
solution similar add clause lacking statement define assert string better wrap statements 
wrap statements 
alternative solution convert macros bodies statements statements wrapped noted 
invocations macros look function calls error prone 
solution requires notifying users change macro interface changing existing macro uses 
inconsistent arity 
macro name defined multiple times different arity example define define may indicate genuine bug macro name different purposes different parts package 
case programmer take care definitions simultaneously active lest override keep track active 
situation may caught cpp redefinition warnings macro name subjected undef second definition 
null body arguments 
macro takes arguments expands form intended define name 
empty comment idiomatic technique indicating null definition programming error comment macro body suppresses warning define attribute spec empty define cbp bad formal name 
formal name valid identifier reserved word possibly dialect define cr faster new cur new cur new presents difficulty cpp programmer reading body especially complicated example may confused code may portable easily translated dialects new keyword 
macro lint tool discovered number additional errors 
illegal constructs module meaningful cpp directive undef go indexable base addr undef takes just macro name arguments appeared define directive 
ansi uses pasting programmer identifiers empty comment expansions form new identifier compiler removes comment 
instance ken interpreted single token macros expanded side comment 
construct perform merging newer implementations warn users appearance 
report statistics style ernst empirical analysis preprocessor pasting rarely bug uncommon especially concat macros provide portability older newer versions preprocessor 
number files analyzed inside brace scope scope 
intentional files meant included files 
bugs case failure close style comment apparently discovered testing build package possible configurations 
multiple definitions package may contain multiple definitions macro macro redefined preprocessing 
multiple compatible definitions macro complicate abstraction desirable 
redefinitions harder determine exactly definition macro particular expansion site may necessary program understanding debugging incompatible macro bodies introduce complications 
section examines frequency macro redefinition sections consider multiple macro redefinitions compatible 
analysis distinguish sequential redefinitions macro definitions take effect single configuration 
independent definitions may result definitions different branches cpp conditional intervening undef directives compilation conventions compiling different programs package different versions program 
percent macro names defined just percent defined twice percent defined times percent defined times percent defined times 
frequently redefined macros complicated understand syntactic categories 
definitions macro definitions categorized system resulting failure categorize macro name 
syntactic macros include expanding punctuation 
frequently support variant declaration styles ansi declarations declarations require definition variety frequently redefined ensure settings correct 
frequently redefined macros categorized unknown identifier 
partially due method coalescing multiple definitions macro definitions categorized unknown identifier overridden definitions categorization see fig 

analysis included library header files include recognizable definition common macros 
packages gawk mosaic remind percent macros defined fewer times 
half packages macros defined times redefinition behavior packages approximates mean packages 
notable exceptions bc remind gcc 
bc multiple definitions exception yacc macros fig 

average number definitions macro names category 
left pair columns examines just files may compiled redhat libc gnu linux system values report right pair considers files package 
left column pair counts definition right column merges definitions identical modulo whitespace comments string character literals formal argument names 
example third line table indicates macro names categorized expressions average different definitions single configuration definitions include different syntax trees 
examine files package find definitions different definitions expression macro name 
macro name categorized categorizations definitions detailed fig 

macro defined times 
contrast remind defines percent macros times 
supports different natural languages various character sets macros user output strings 
tail gcc graph longest percent macros defined times including definitions chunk alloc chunk free 
figures involve single configuration gcc source code including various architectures operating systems excluding libraries percent macros defined times percent defined times 
multiple differing definitions section counted number definitions macro name providing upper bound difficulty mapping uses macro definition 
multiple definitions bodies lexically similar identical section reports case 
fig 
provides data regarding multiple definitions macros definition counted individually definitions differing canonicalized bodies counted 
canonicalization eliminates comments whitespace canonically renames formal arguments considers character string literals identical 
transformation approximates comparing syntax trees strict rules cpp determining issue warning redefinition 
number differing canonical redefinitions dramatically lower number redefinitions indicating multiple definitions troublesome initially appear 
syntactic macros particularly ieee transactions software engineering vol 
december fig 

rules unifying macro definition categories 
rules combining categories multiple definitions macro order assign category macro name 
reduced multiple definitions just alternatives 
additionally macros remind identically usually string contents differed 
inconsistent definitions section continues analysis multiply defined macros 
section considered syntactic structure multiple definitions particular name section refines analysis considering categorization macro bodies described section 
software engineering tool may able take advantage higher level commonalities macro definitions level categorizations section effectively relied syntactic similarity section 
percent cases multiple definitions macro compatible bodies lexically identical 
incompatibilities usually indicate bugs inconsistent usage package failures categorization technique 
macro name categorized merging definitions pairwise 
definitions name fall category consistent category name assigned category name assigned category 
fig 
details rules precisely 
category breakdown macro name detailed legend fig 
differs definition breakdown fig 
ways 
number null definitions lower null definitions conjunction types definition eliminated category merging 
macros defined null definitions generally cpp conditionals 
number statements lower largely macros names statement definitions incompatible definitions macro name categorized percentage unknown identifiers higher macros tend definitions prominent breakdown name definition 
number categorizations increased includes macro definition categorized incompatible definitions 
fig 
gives detailed information percent macro names multiple definitions 
macros grouped definitions fall set categories 
presentation categories categories distinguished tool table manageable hide information 
instance expression statement groups percent percent 
prevalent includes expressions statements categories compatible macro names categorized statements 
second group includes definitions expressions statements complete statements macro names categorized exception represent bugs packages 
bug zephyr define adjust size size size define adjust size size size unsigned int likewise statement row percent name categorization includes full statements interchangeable 
bugs example gcc define target version fprintf stderr bsd ernst empirical analysis preprocessor fig 

categorization definitions macro name definition 
instance macro names percent multiply defined macro names definitions fall expression category macro names percent multiply defined macro names definitions expressions constants 
rows percent representing fewer macro names omitted 
rightmost column indicates categorization macro name percent multiply defined macro names percent macro names categorized chart shows different macro definition categories tend occur assists understanding reasons macro names multiple definitions cause categorized define target version fprintf stderr osf ad macro usage previous section demonstrated ways macro definitions complicate program understanding turn macro uses 
heavy macro usage macro analysis important amplifying effect macro section addressees issue 
macro usage packages analyzed varies perl macros line code 
percent macro names fewer times percent macros macros times 
macros categorized syntactic type related expanded times frequently simpler macros defining constants expressions 
second consistency resolve ambiguities inherent macro definitions inconsistent opposite effect 
macro limited way replaced tool analysis source simpler mechanism 
section demonstrates approach shows promise fewer percent macros tested definedness expanded source code 
macros appear conditional compilation test reveal programmer intention underlying test 
tests specific particular package separation concerns generally section shows percent cpp conditionals test multiple macros different purposes 
frequency macro usage fig 
illustrates frequently package uses macros 
macros code uses line individual packages vary uses line 
heavy preprocessor high incidence preprocessor directives reported fig 
weakly correlated heavy macro usage preprocessor ieee transactions software engineering vol 
december fig 

number macro uses divided number ncnb lines 
packages ordered preprocessor directives line fewest fig 

directives macros 
language implementations study perl gcc gs macros 
fig 
illustrates percent macros expanded twice percent 
unused macros appear incomplete obsolete code 
example gnuplot percent macros defines includes partially implemented terminal types 
frequently macros cause difficulty tool software engineer percent syntactic macros expanding punctuation containing unbalanced delimiters difficult parse percent type related macros times 
long tails frequency distribution result pervasive syntactic type macros variable declaration understanding macros critical 
contrast macros act variables expanding constant expression generally appear times percent macros defining constants occur twice 
macro usage contexts macros general purposes control inclusion lines code appearing cpp conditional controls line change text line expanded line 
uses may correspond language features conditional statements expressions inline declarations certain types substitution 
understanding inhibited macro ways easy mapping existing language feature 
split macro uses contexts uses code 
macro expansion involves textual replacement 
uses ifdef ifndef elif conditions 
section disregard uses cpp conditionals purpose prevent redefinition 
specifically ignore uses condition tests macro definedness body defines macro 
uses body macro definition 
macros contexts eventually control textual replacement code inclusion uses macro defined 
percent macros appear macro bodies uses macro bodies account percent macro uses 
fig 
reports contexts macro names 
general packages macros direct conditional compilation produce code ernst empirical analysis preprocessor fig 
number expansions cpp macro 
numbers graph represent percentage identifiers expanded number times fewer 
example percent macros expanded fewer times 
chart higher lines indicate usage syntactic macros null defines constants 
percentages legend represent total number macro names falling category fig 
gives similar information broken macro definition 
purposes 
percent macros fourth group fig 
expand code conditional contexts 
macros expanded order magnitude control source code inclusion percent group versus percent second 
conditional compilation accounts percent cpp directives percent macro usage 
conditional directive control lines code code affects final program text just line see section 
macro usage conditional control cpp conditionals control inclusion code portability debugging efficiency purposes 
programmer intention line inferred structure context purpose macros uses 
fig 
shows heuristically determined purpose cpp conditional test suite 
heuristic classified conditionals structure context follows commenting 
guards definitely succeed effect written definitely fail unconditionally skip block test 
guards comment code override conditions unconditionally enable disable previously experimental feature 
redefinition suppression 
guards test identifiers control definition identifier avoiding preprocessor warnings redefinition name followed ieee transactions software engineering vol 
december fig 

macro usage contexts 
macros may code macro definition bodies conditional tests combination thereof 
percent uses number uses value mean line fig 

groups example macros code macros code macro bodies assumption uses macro bodies similar uses macro 
endif 
purpose provide default value part system compilation command specifies value 
cpp conditionals classified rules purpose macro name appearing conditional determined system properties reifies 
macro conditional purpose conditional purpose conditional classified mixed usage macro purposes determined macro name examination definitions unavailable trivial constant follows portability machine 
symbols name operating system machine hardware sun macintosh 
portability feature 
symbols describe specific parameters capabilities target machine operating system broken 
portability system 
symbols commonly defined constants functions system language libraries create 
portability language library 
symbols predefined compiler defined standard library defined package part build process indicate existence compiler language library features bool 
miscellaneous system 
symbols reserved underscores fit purpose 
fig 

purposes conditional compilation directives 
legend indicates percentage cpp conditionals fall category numerically presenting information top row chart 
ernst empirical analysis preprocessor debugging 
symbols control inclusion debugging tracing code 
macro names contain debug trace substrings 
multiple inclusion prevention 
guards encompass entire file ensure enclosed code seen translation unit compiler 
guards indicated convention trailing included macro name check 
package specific 
symbols specific package 
fit purposes 
mixed usage 
guards test multiple symbols different purposes defined stdio signals 
significant variation packages clear pattern emerges 
portability accounts percent conditional compilation directives 
redefinition warning suppression percent surprisingly high essentially macro definition mechanism conditional inclusion technique 
mixed usage relatively rare 
suggests conventions macro names fairly standardized programmers rarely write conditional tests combine entirely different concerns single expression 
data suggest percent conditional compilation directives unnecessary preprocessor simple language features define defined directive objective import facility automatically avoids multiple inclusions 
percent conditional compilation directives involve variances target operating systems 
tools gnu project may account prevalence guards making easier maintain code bases sprinkled managing multiple target operating system variants 
interesting compare data software targets single specific platform 
dependences macros control program results running cpp inclusion dependences expansion dependences 
section reports incidence dependences macro line 
inclusion dependence results cpp conditionals test macros determine lines cpp input appear output 
line inclusion dependent macro name macro definedness expansion affect line appears preprocessor output 
words set values macros line appears output value macro case macro undefined appear output value macro case macro defined 
notion related control dependence program analysis 
expansion dependence results replacement macros outside cpp conditionals definition bodies controls content lines macros appear 
line expansion dependent macro name macro definedness value affects text line preprocessing 
words set values macros setting macro value defined results different final text line setting macro different value undefined 
notion related data dependence program analysis 
report direct indirect dependences 
line directly depends macros appear line condition scope contains line 
indirectly depends macros control definitions directly controlling macros 
define final text line uses depends just definition 
indirect dependence expansion dependence dependence chain expansion dependence indirect dependence inclusion dependence 
distinguish may dependences 
dependence links macro known single definition site may dependence links multiple definition sites known definition effect point 
macro defined branches conditional macro definedness depend values tested conditional value 
track dependences file boundaries macro controls file included macro controls line file 
statistics reported section underestimates omit emacs aggressively uses macros 
full dependence information exceeded mb virtual memory part due optional motif complex external library extensive header files 
reports macros defined package computed dependences information macros including defined libraries 
additionally implementation optimized space 
generate dependence information mosaic plan motif 
dependences line fig 
graphs percentage lines dependent number macros 
average line packages dependency analysis macros inclusion dependent macros dependence macros 
inclusion controlled lines appear unconditionally package source inside guard avoid multiple inclusion case header files 
expansion dependence multiple macros prevalent percent lines expansion dependent macros percent macros 
line gcc address mode win expansion dependent different macros 
examined source code just architecture operating system configuration expansion dependent ieee transactions software engineering vol 
december fig 

percentage lines dependent particular number macros fewer 
instance percent lines expansion dependent fewer macros percent lines fewer macros 
lines higher graph indicate dependence fewer macros 
values macros fall log scale axis follows percent lines expand macros percent lines unconditionally included excluded percent lines dependent macros 
macros 
address creates valid memory address memory operand mode defined times gcc definitions dozens lines long macro invocations 
inclusion dependences wider distribution 
percent lines macros percent lines dependent macros 
dependences macro fig 
graphs lines dependent macro 
fig 
gave information line macro 
packages vary size graphs fig 
aggregate reporting percentages package absolute numbers 
expansion dependence chart illustrates macros control lines macros control lines transition varieties gradual 
values follow variant zipf law product number macros percentage lines dependent macros nearly constant 
excluding buckets represent extremal values product average standard deviation directives account percent lines expand macro rare exceptions include testing compiling machine character set 
frequently macros expanded percent lines package 
xfig perl rename variables manage dynamic binding linking 
user defined types rtx gcc perl user defined type modifiers private gs gzip creates ansi function prototypes rcs 
userdefined constant afm enc expression perl defined constant arguments expression arguments bash 
redefine built quantities fprintf gnuplot substitute custom version far meaningful dialects void perl const gs rcs null cvs gawk mosaic 
determined symbols macros running modified version preprocessor report redefinitions package may override built version 
generally built symbols overridden 
inclusion dependence graph bimodal 
macros control inclusion zero lines quite control percent package lot macros 
graphs individual fig 

dependences macro name macro names packages 
bar represents macros completely unused package 
bar represents macros control specified percentage range lines package 
instance bar expansion dependence chart indicates macros control percent percent entire package contains macro 
maximum falls penultimate bucket rightmost bucket empty 
second bar graph represents macros controlling line small nonzero value percent entire package 
axis uses log scale 
ernst empirical analysis preprocessor packages exhibit far higher peaks aggregate inclusion dependence graph fig 
summing graphs tended average 
heaviest dependences tend macros controlling header file inclusion 
cpp partial evaluation support multiple dialects language ansi common preprocessor packages support ansi support preprocessor fully support dialects prefer dialect partially support instance part package supports dialects substantial number functions varieties prototype 
support possible preprocessor language leads unstructured macros partial declarations difficult constructs 
furthermore uses highly visible distracting programmers tools may change syntax function declaration definition 
performed experiment determine eliminating macros simplify understanding analysis reducing complexity macro definitions usage measured 
built cpp partial evaluator called 
cpp style command line arguments specifying macros known defined undefined optionally expansions discharges cpp conditionals including nested conditionals depend macros 
conditionals macro uses remain output 
expand macros inline macro definitions input files 
similar program distributed unix variants permit specifying value defined symbol operates ifdef tests 
preprocess programs library header files definitions macros depended ansi standard including prototypes booleans posix compliant libraries 
reduced size codebase percent individual package reductions ranged percent emacs 
reran experiments surprise results little changed full versions packages 
decline multiple definitions macros categorizations dependences macros metrics report single digit percentages original values 
conclude macro usage test programs presents obvious single point attack eliminating highly prevalent visible largest identifiable source cpp conditionals see fig 
significantly reduce complexity introduced preprocessor 
discharging selected conditionals worthwhile 
developers window manager tool eliminate numerous compile time options inherited predecessor 
transformation resulted cleaner code base developers easier understand modify 
related know empirical study preprocessor macro processor 
literature contain guidance macros effectively writing portable code tools checking macro usage techniques understanding exploring source code uses preprocessor 
style guidelines coding style guides recommendations preprocessor ways reduce unexpected behavior resulting poorly designed constructs 
empirical data help refine sets suggestions extending taxonomies recommendations indicating problems occur practice 
gnu preprocessor manual discusses set techniques including simple macros argument macros predefined macros macros concatenation macros redefining macros 
list pitfalls subtleties macros include unmatched parentheses formals bodies dangling semicolons multiple formal uses self referential macros 
discusses issues addressed argument macro arguments scanned macro expansions twice cascaded macros macro bodies current definition macros ones effect definition site newlines macro invocations throw error line reporting 
gnu coding standards mention cpp recommend upper case macro names macros provide meanings standard symbols platforms don support ansi event gnu programs appear written eye careful adherence standards 
coding standards recommend inline definitions appear separate files header files include files inline functions constants place define preprocessor macro names prefixed avoid name clashes 
adaptation indian hill style coding standards numerous suggestions 
programmers capital letters macro names macros behave function calls acceptable short functions 
statement macros wrapped 
particularly contain keywords 
conditional bodies fully bracketed avoid dangling semicolons 
macros evaluate parameters exactly arguments side effects 
side effects macro parameters documented 
macros avoid global variables global name may hidden local declaration 
macros bodies long variables take empty parameter list 
programmers ansi specification preprocessor tricks token pasting macros rely argument string expansion 
syntax changed macro substitution proto macro 
ifdef avoided appear header files nested ieee transactions software engineering vol 
december source code 
protect uses pragma define macros uniformly code need ifdef 
machine specified compilation fail default conditional compilation generally test features machines operating systems 
text inside ifdef bracketed section parsable code arbitrary text 
stroustrup lists tasks supported preprocessor notes alternatives uses define constants inline subroutines parameterized types functions renaming 
principle design elimination preprocessor continues rely uses stroustrup lists define string concatenation new syntax macro processing ifdef version control commenting pragma layout control flow hints pragmas include exporting declarations composing source text 
stroustrup proposes moving include language eliminate quirks simplify task programmers tool writers import directive objective 
stroustrup remarks retrospect worst aspect cpp development programming environments carroll ellis list varieties non include macro usage culled part stroustrup list 
say replace uses preprocessor declaration macros declaring class constructor destructor macro call code versioning debugging versions 
recommend project specific prefixes avoid macro name header file name conflicts 
portability style guidelines focus portability concerns 
warn implementation limits permitted language standard nesting levels parenthesized expressions macro identifiers characters logical source line 
note incompatibilities preprocessors usually result failure implementations conform specification 
instance nonstandard preprocessors support defined operator pragma elif directives ignore text elif endif directives perform concatenation nonstandard orders macro substitution 
authors recommend incompatibilities accepting directives starting column leading whitespace ifdef hide modern cpp features older preprocessors 
treats detail specific header files may cause portability problems showing overcome difficulties generally macro preprocessor define symbols correctly 
spencer provide set techniques achieving portability ifdef recommend providing default values macros preventing multiple inclusion header files 
software engineering preprocessor se contain preprocessor specific recommendations 
authors suggest standard interfaces providing multiple implementations necessary 
implementations appear separate files sharing code ifdef build configure script select choice files replaces cpp conditionals 
override directory early search path permits bad include files replaced selectively overridden 
uses ifdef eliminated moving system specific tests operations shell scripts standard programs ls df accessing system services code 
strategies complicate porting non unix systems standard programs may different behavior different places 
preprocessor establish numeric constants viewed suspicion dynamically sized objects better approach 
uses ifdef test features characteristics machines error preferable selecting default machine 
spencer recommend ifdef restricted declarations macro definitions call sites include appear inside ifdef 
break uses ifdef lines news program 
uses percent protected default value preprocessor symbol percent configuration percent commented code percent prevented multiple inclusion header files 
error checking krone snelting mathematical concept analysis determine conditional compilation structure code 
determine preprocessor macros line depends terminology compute inclusion dependence expansion dependence display information concept lattice 
determine macro relationships directly nesting information conveyed program 
point lattice stands set lines dependent exactly preprocessor symbols necessarily exactly way 
lattice reveal macro tested influence example 
lattice regular grid structure possible code properly separate concerns 
closely related part section analyzed single compilation directives tested multiple incompatible macros fixed set macro purposes 
number tools check specific programs satisfy particular constraints 
various lint source code analyzers check potentially problematic uses including preprocessor 
macro errors usually discovered byproduct macro expansion instance generating empty statement causes lint issue warning right 
survey static checkers mentions macro preprocessor terms warnings turned tools focuses coding style lead errors lexical issues 
ernst empirical analysis preprocessor lclint allows programmer add annotations enable sophisticated checks lint programs 
lclint optionally checks function macros take arguments macro arguments left hand side assignments statements playing role expressions consistent return types 
lclint approach prescriptive programmers encouraged constructs dangerous change code contains constructs 
full checking lclint requires users add fine grained annotations macro definitions 
tried run lclint version set packages macro diagnostics enabled lclint reported parse error internal bug percent files test suite 
pc lint commercial program checker 
macro errors problematic uses identified tool pc lint warns bodies multiple macro definitions classifying identical inconsistent unreferenced defined macros macros probably replaced const variable 
warns illegal arguments include directive header files declarations module names defined variables macros 
macro definitions warns multiple formals name macro name formal names appear strings preprocessors perform substitution strings 
call sites warns incorrect number arguments macro arguments actual macro argument sufficiently resembles expression expression involves binary operators ignoring operator precedence arguments side effects formal parameter multiple times expression body 
warnings individually suppressed accommodate intentional uses paradigms 
check macro checker detects instances multiple statements side effects precedence errors largely lexical checks 
precedence error checks performed macro uses reporting error prone definitions 
authors report effectiveness tool practice justify trade offs techniques perform parsing tradeoffs major theme 
mention literature software complexity metrics specifically address macro preprocessor study program comprehensibility lotus macro languages 
anecdotal confirmation neglect preprocessor examined publically available systems computing metrics programs 
spr metrics filter cpp directives lines cyclo lc ignore cpp 
metre requires preprocessed source performs preprocessing counts cpp directives count clc hp mas count preprocessor directives count counts statements ignores expanded macros 
cccc permits users specify specific macros ignore skips preprocessor lines assumes macros contain unbalanced braces 
different program count mentioned operates source parser cpp comments macros expanding statements expressions certain types users may specify expansions certain macros side cpp conditionals examined macros ignore 
understanding cpp limited number tools assist software engineers understand code containing cpp directives 
emacs hide ifdef mode enables programmer specify preprocessor variables explicitly defined defined mode presents view source code corresponding configuration hiding code conditionally tools 
similar tool editor supports selective viewing source code automatic insertion cpp conditionals edited code 
evidence version control logs tool effective making programmers productive 
various language construct tagging mechanisms ctags recognize macro definitions permit editors move easily macro expansion various definitions macro name 
sample analyses pcp analysis framework provides emacs tool editing unprocessed source dynamically updating current macro expansion separate window 
favre suggests cpp expressed syntax similar programming languages 
simple semantics free loops complicating constructs assigned cpp traditional analyses call graph construction control data flow analysis slicing specialization performed 
app environment implements approach support full lexical conventions language macros take parameters percent macros study 
slicing tool takes similar approach mapping cpp constructs particularly macro substitution internal representation supports slicing 
permits searches program syntax tree handles uses cpp macros 
macros bodies expressions statements left unexpanded entered symbol table takes similar approach body assuming macro argument turn typedef macro expanded inline authors find necessary percent non header file uses 
making easier understand combination cpp source text unnecessarily difficult understand 
step eliminate cpp uses equivalent construct exists apply tools explicate remaining uses 
discuss approaches reducing need preprocessor improving state art ieee transactions software engineering vol 
december programming applying tools specific source code artifact 
seriously consider simply eliminating preprocessor provides convenience functionality base language 
problematic uses cpp provide portability different language dialects different operating environments standardization obviate uses legacy code easily new code 
library function names calling conventions conditional compilation necessary percent conditionals test operating system variances incidentally programs portable gone special effort achieve portability 
proposal moves responsibility portability really conformance specification application program library operating system 
likewise common uses cpp macros eliminated language dialects single declaration syntax 
declarations particularly important tools humans examine examine implementations declaration macros particularly cluttering 
compilers compilers accept declarations support multiple declaration styles may usefulness 
ansi tool translates program ansi style function declarations classical function declarations 
tool frees authors maintaining commonly required configurations 
cpp directives moved language proper replaced specialized directives 
instance objective uses import place include 
stroustrup proposes language approach eliminates need percent cpp conditionals related definitions prevent multiple inclusion header files 
default directive obviate percent conditionals 
compilers job constant folding percent macros defined constants dead code elimination eliminating uses debugging purposes encourage programmers language constructs relying guarantees tool cpp 
sufficient compiler perform appropriate optimizations programmer confidence compiler apply optimizations skeptical programmers cpp hide computations compiler guarantee code generated 
common cpp constructs replaced specialpurpose syntax 
instance declarations partial declarations explicit objects making type modifiers class compile preprocess time language preprocessor include declaration modifier dynamic binding special declaration dynamic variables lisp similar support provided repetitive constructs 
manipulations objects performed clearly specified interface string token concatenation easing understanding burden programmer tool 
uses visible compiler program checkers lint 
downside approach new syntax new library functions may simplify program text cover possible case 
safer language uses partial evaluation replacement preprocessing source code templates order support portability reuse runtime cost 
evaluation expressions occurs compile time runtime controlled programmer annotations 
maintainability enhanced due elimination separate preprocessing step language simpler syntax 
safer support features preprocessor author recommends recoding totally different style uses preprocessor extend definition preprocessor constants inclusion header files straightforward conditional compilation 
remarks gcc version contains instances preprocessor results contradict finding 
macro systems designed avoid particular pitfalls cpp 
hygienic macro system unintentionally captures variables special construct 
macro systems require output syntactic ast merely token stream 
alternative approach avoids separate language limited expressiveness macro language powerful language constructs evaluated compile time run time 
macro systems common lisp scheme descendants take approach 
limit language provide reflection capability 
approach highly general powerful theoretically clean 
added generality degrades tool ability reason source code 
practice systems fairly restricted ways uses complicated 
dialogue users compiler writers tool writers language theorists necessary introducing feature order prevent unforeseen consequences turning burden 
data results suggest wide variety avenues research terms expanding understanding uses preprocessor practice addressing issues identified study 
comparing cpp libraries differs application code may yield insights language needs library authors 
comparisons unix versus microsoft windows packages packages different application domains user interface styles different versions single package may prove valuable 
formally analyze source code 
preliminary results indicate packages rely heavily cpp uses supports nearly ernst empirical analysis preprocessor identical language construct 
unfortunate situation probably stems combination trivial translations programmers programmers changing habits 
useful analysis packages consider code context history package background authors 
analysis macros free variables needed see roughly percent expression macros percent statement macros lack free variables easy convert inline functions 
framework currently benefit analyzing context macro expansions determining macro category 
example macro type appear inferred expand type macro function body probably expanding declarator 
analyzed packages comprising lines real world code determine preprocessor practice 
reported data extensive wide ranging briefly summarized regarding prevalence preprocessor directives macro body categorizations cpp achieve features impossible underlying language inconsistencies errors macro definitions uses dependences code macros 
empirical study preprocessor article serves confirm contradict intuitions preprocessor 
indicates difficulty eliminating preprocessor translation shows way development preprocessor aware tools provides tools including extensible preprocessor cpp partial evaluator lint cpp checker 
anticipate data may useful cpp related investigations 
particular data analyses provide value language designers tool writers programmers software engineers 
language designers examine programmers macro system capabilities 
language specifications directly support prevent practices instance lines suggested section imposing greater discipline structure 
programming tool writers choose cope common uses preprocessor 
partial preprocessing embedded understanding cpp constructs parser maintain programmer oriented abstractions provided preprocessor directives macro names getting confused programs containing syntax errors 
programmers wish code cleaner portable choose limit preprocessor widely easiest understand cpp idioms 
similarly choose avoid constructs cause tools test frameworks program understanding tools give incomplete incorrect results 
results interest software engineering researchers reasons 
study cpp usage aware worth performing simply determine results predictable priori 
aspect analysis surprising interesting individuals 
pursuing highly focused deeper analyses directions worthwhile 
acknowledgments supported ibm cooperative fellowship ernst national science foundation graduate fellowship 
authors robert anonymous referees comments substantially improved presentation 
atkins ball graves mockus version control data evaluate impact software tools proc 
st int conf 
software eng pp 
may 
notkin framework preprocessor aware source code analyses software practice experience vol 
pp 

cannon elliott miller spencer keppel recommended style coding standards ed 
carroll ellis designing coding reusable 
reading mass addison wesley 
cox object oriented programming evolutionary approach 
reading mass addison wesley 
davis davis law comparison subjective entropy user estimates software complexity empirical foundations information software science 
deutsch ansi ghostscript distribution aladdin enterprises ftp ftp cs wisc edu ghost dec 
keppel reilly notes writing portable programs eighth revision 
nov www 
org pub paul docs htm 
telecommunication systems laboratory programming rules recommendations technical report 
evans guttag horning tan lclint tool specifications check code proc 
sigsoft second acm sigsoft symp 
foundations software eng pp 
dec 
evans lclint user guide aug lclint cs virginia 
edu guide 

favre preprocessors point view proc 
int conf 
software maintenance icsm nov 
software pc lint www com htm 
gnu project gnu preprocessor manual version 

griswold atkinson fast flexible syntactic pattern matching processing proc 
ieee workshop program comprehension mar 
harbison steele jr manual fourth ed 
englewood cliffs prentice hall 
johnson lint program checker computing science technical report bell labs murray hill sept 
kelsey clinger rees revised report algorithmic language scheme acm sigplan notices vol 
pp 
sept 
kernighan ritchie programming language second ed 
englewood cliffs prentice hall 
kiczales des rivi res bobrow art metaobject protocol 
mit press 
kohlbecker friedman felleisen duba hygienic macro expansion proc 
acm conf 
lisp functional programming gabriel ed pp 
aug 
ieee transactions software engineering vol 
december krone snelting inference configuration structures source code proc 
th int conf 
software eng pp 
may 
small understanding code containing preprocessor constructs proc 
ieee third workshop program comprehension pp 
nov 
metrics collection tools source code www cs umd edu users cml 
meyers klaus examining program analyzers dr dobb vol 
pp 
feb 
murphy notkin 
lan empirical study static call graph extractors proc 
th int conf 
software eng pp 
mar 
paul prakash framework source code search program patterns ieee trans 
software eng vol 
pp 
june 
salomon partial evaluation support portability reusability maintainability proc 
compiler construction sixth int conf ed pp 
apr 
reps program generalization software reuse proc 
sigsoft fourth acm sigsoft symp 
foundations software eng pp 
oct 
spencer ifdef considered harmful portability experience news proc 
usenix summer technical conf pp 
june 
static detection preprocessor macro errors technical report james cook univ australia 
manual authoritative guide emacs window managers vicarious existence mit edu 
stallman gnu emacs manual th ed 
cambridge mass free software foundation july 
stallman porting gnu cc version 
boston mass free software foundation june 
stallman gnu coding standards 
gnu project july ftp prep ai mit edu pub gnu standards standards 
steele jr common lisp language second ed 
bedford mass digital press 
stroustrup design evolution 
reading mass addison wesley 
weise crew programmable syntax macros proc 
acm sigplan conf 
programming language design implementation pp 
june 
zellweger interactive high level debugger control flow optimized programs technical report csl xerox palo alto research center palo alto calif jan 
zipf human behavior principle effort 
cambridge mass addison wesley 
michael ernst holds sb sm degrees massachusetts institute technology 
received phd degree computer science engineering university washington prior lecturer rice university researcher microsoft research 
assistant professor department electrical engineering computer science laboratory computer science massachusetts institute technology 
primary technical interest programmer productivity encompassing software engineering program analysis compilation programming language design 
published artificial intelligence theory areas computer science 
greg received phd degree computer science engineering university washington june 
dissertation examined constraints advanced constraint solving systems various interactive graphical applications 
primary author scheme constraints window manager cassowary constraint solving toolkit 
research interests include software engineering programming languages internet 
currently chief technical architect washington 
david notkin received degree brown university phd degree carnegie mellon university 
boeing professor chair computer science engineering university washington 
joining faculty dr notkin received national science foundation presidential young investigator award served program chair acm sigsoft symposium foundations software engineering served program th international conference software engineering chaired steering committee international conference software engineering served charter associate editor acm transactions software engineering methodology journal programming languages served associate editor ieee transactions software engineering named acm fellow served chair acm sigsoft received university washington distinguished graduate mentor award 
research interests software engineering general software evolution particular 
senior member ieee 
information computing topic please visit digital library computer org publications dlib 
