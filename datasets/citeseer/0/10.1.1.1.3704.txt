typed memory management calculus capabilities david walker cornell university karl crary carnegie mellon university february greg morrisett cornell university region memory management alternative standard tracing garbage collection potentially dangerous operations memory deallocation explicit verifiably safe 
article new compiler intermediate language called capability calculus supports region memory management enjoys provably safe type system 
previous region type systems region lifetimes need lexically scoped language may checked safety complex analyses 
type system may deployed settings extensible operating systems performance safety untrusted code important 
central novelty language static capabilities specify various operations memory access deallocation 
order ensure capabilities relinquished properly type system tracks aliasing information form bounded quantification 
previous region type systems proof soundness type system relatively simple employing standard syntactic techniques 
order show language may practice show translate variant tofte talpin high level type effects system region memory management language 
combined known region inference algorithms translation provides way compile source level languages capability calculus 
motivation background current trend systems software allow untrusted extensions installed protected services relying language technology protect integrity service hardware protection mechanisms 
example spin project relies modula type system protect operating system kernel erroneous extensions 
similarly web browsers rely java virtual machine byte code verifier protect users malicious applets :10.1.1.24.6526
situations goal eliminate expensive communications boundary crossings allowing extensions directly access resources require 
research performed author cornell university 
material supported part afosr arpa radc nsf 
eia 
opinions findings recommendations expressed publication authors reflect views agencies 
necula lee proposed proof carrying code pcc morrisett suggested typed assembly language tal language technologies provide security advantages high level languages overheads interpretation just time compilation 
systems low level machine code heavily optimized hand compiler automatically verified proof type checking 
systems spin jvm tal touchstone compiler generates pcc aspect programmers optimizing compilers little control memory management 
particular soundness depends memory reclaimed trusted garbage collector 
applets kernel extensions may perform optimized memory management 
furthermore garbage collectors tend large complicated pieces software degree trust language protection mechanisms diminished 
goal provide high degree control memory management programmers compilers pcc tal frameworks verification safety programs straightforward task 
regions tofte talpin suggest type effects system verifying soundness region memory management 
tofte show infer region types lifetimes implement theory 
advantages region memory management point view important 
region memory management implemented relatively simple constant time routines 

memory operations explicit program text safety guaranteed 
advantage implications 
regions secure system simplicity implementation leads smaller trusted computed base 
may possible formally verify region operations implemented correctly 
contrast standard tracing garbage collector large extremely complicated piece code formal analysis garbage collector onerous task analysis region system 
second region operations constant time trace structure heap programs suffer pauses associated conventional garbage collectors 
consequently region memory management systems may practical alternative real time garbage collectors 
second advantage gives programmers greater control memory 
programmers quickly identify memory regions causing performance problems applications 
allocation deallocation operations explicit program text programmers profiling data accurately relate run time behaviour programs static representation 
words information ways regions run time straight forward examine program code identify memory intensive routines reason lifetimes data structures allocated 
trouble spots identified programmers concentrate optimization efforts small portion code 
importantly programming process type checker guarantees memory operations safe programmers worry programs crashing due memory faults 
order ensure regions safely tofte talpin language includes lexically scoped expression letregion delimits lifetime region region allocated control enters scope letregion construct deallocated control leaves scope 
programs may allocate values live regions notation values may region deallocated 
example region lifetime letregion allocate region allocate value region deallocate region tofte talpin ensure deallocated values accessed type effects system 
informally expression uses value region type system expresses fact effect access 
effects occuring scope letregion construct masked 
specifically expression effects access set effects effect expression letregion simply 
effect entire program region access occured scope corresponding letregion construct 
words values region lifetime 
condition holds conclude program safe 
tofte talpin language efficient memory provided lifetimes values coincide lexical structure program 
lifetimes deviate program structure style region memory management may force programs considerably memory necessary 
consider program fragments 
scope call site dead scope function fun dead return value argument function allocated scope function call 
executed dies quickly 
value exhibits inverse behaviour 
allocated inside returned function result 
lifetimes span lexical scopes live long scope 
consequently vanilla region inference perform setting 
best wrap function call pair letregion commands 
scope call site letregion letregion dead scope function fun dead return regions live longer need due inflexibility letregion construct 
regions allocated outside function call 
notice dead function call returns outer region deallocated inner region deallocated 
lexical scoping enforces stack allocated memory management discipline 
example better solution memory management problem separate region allocation newregion deallocation freeregion 
program takes approach 
principle lifetimes regions overlap memory regions reused 
scope call site newregion dead freeregion scope function fun dead freeregion newregion return unfortunately write program tofte talpin language idea lexical scoping 
consequence language design program transformation alters program structure affect memory management 
devastating transformations tofte talpin type system continuation passing style cps transformation successive computation placed scope previous computations result regions deallocated entire computation completed 
example cps transformation prevents region deallocated code executed deallocated soon completed computation 
letregion code letregion code observation tofte talpin type system poor memory cases 
birkedal aiken proposed optimizations allow regions freed early 
optimizations safe simple proof type checker client check output code 
order construct safe efficient region language re examine fundamental question program access value contributions solution problem provably safe efficient region memory management takes inspiration operating systems hydra 
hydra solves access control problem associating unforgeable key capability object requiring user capability gain access object 
furthermore need arises hydra revokes capabilities preventing access protected objects 
define new strongly typed compiler intermediate language region memory management uses compile time notion capability ensure region operations performed safely 
tofte talpin language lexical scoping plays part verification process 
type system threads static information form capabilities control flow path program 
order value region particular control flow point program capability region 
traditional capability systems type system keeps track capability copies carefully determine capability truly revoked 
traditional capability systems calculus supports voluntary revocation 
capabilities calculus purely static concept implementation requires run time overhead 
mechanism provides efficient way check safety explicit arbitrarily ordered region allocation deallocation instructions 
purely syntactic argument subject reduction progress lemmas style felleisen wright type system capability calculus sound 
contrast tofte talpin formulate soundness system complicated greatest fixed point argument soundness aiken optimizations depend argument 
part reason extra complexity tofte talpin simultaneously show region inference translates lambda calculus terms operationally equivalent region calculus terms stronger property prove 
system security main concern soundness critical property 
simplicity argument demonstrates benefits separating type soundness type inference optimization correctness 
formal translation variant tofte talpin language calculus 
type safe tofte talpin program translation produces type safe capability calculus program 
translation combined region inference algorithm provides way compile source language programs type safe low level code secure extensible systems mobile code 
remaining sections article describe capability calculus greater detail 
section presents syntax semantics language formally motivates design decisions 
section type soundness theorem discuss interesting parts proof 
complete proof may appendix section demonstrates capability calculus expressive tofte talpin language 
define semantics variant language give translation capability calculus 
translation preserves type safety property appendix proves fact 
demonstrate expressiveness capability calculus sketching couple optimizations possible restrictive language 
section describes compile relatively high level capability calculus capability typed assembly language 
elements translation orthogonal capability mechanism section informal capability typed assembly language fully defined 
claim proof target language type safe 
believe prove type safety result proof long tedious doubt reveal new insights 
believe notion static capability generally useful concept 
section informally explores applications capabilities 
section explains connections related 
section concludes 
capability calculus central technical contribution article capability calculus statically typed intermediate language supports explicit allocation freeing accessing memory regions 
mentioned type system language propagates static information capabilities control flow path program 
elegant natural form language continuation passing style cps 
functions capability calculus return values functions finish calling continuation function typically provided argument 
fact means transferring control cps means call return direct style simplifies tracking capabilities 
direct style formulation possible complications involved obscure central issues 
remainder assume familiarity cps 
syntax capability calculus appears 
sections explain motivate main constructs typing rules language 
kinds type rgn cap constructor vars constructors types int handle atr regions capabilities multiplicities constructor contexts value contexts region types memory types word values handle heap values fix xn vn arithmetic ops declarations iv newrgn freergn terms vn halt memory regions hn memories rn machine states capability syntax preliminaries specify operational behavior capability calculus allocation semantics allocation data memory explicit 
semantics specified deterministic rewriting system mapping machine states new machine states 
machine state consists pair memory term executed 
memory finite mapping region names region block memory holds collection heap allocated objects 
regions created run time declaration newrgn allocates new region heap binds name region binds handle handle region 
region names handles distinguished order maintain phase distinction compile time run time expressions 
region names significant compile time type checker identifies region object inhabits region name see 
region names type constructors run time significance may erased executable code 
contrast region handles hold run time data necessary manipulate regions 
addition accounting phase distinction separation region names handles allows refine contexts region handles needed 
handles needed allocating objects region freeing region needed reading data region 
regions freed declaration 
objects large require heap allocation functions tuples called heap values allocated declaration handle region allocated 
data read region ways functions read function call tuples read declaration binds data residing ith field object address operations may performed region question freed 
enforcing restriction purpose capability mechanism discussed section 
region maps locations heap values 
address pair region name location 
course execution word sized values substituted value variables type constructors constructor variables heap values allocated memory referred indirectly address 
executing declaration handle handle region allocated region say address substituted code 
term capability calculus consists series declarations branch function call halt 
class declarations includes constructs discussed plus standard constructs binding variables values pv ranges arithmetic 
types types capability calculus include type constructor variables integers type region handles tuple function types 
region handle region handle 
tuple type contains usual field tuples specifies tuples allocated region region name frequently region variable 
function type atr contains functions arguments types may called capability satisfied see section 
return type intended suggest fact cps functions invoke continuations returning handle dom dom vi dom dom vn newrgn handle freergn handle dom vn cm vn xn cm fix xn dom capability operational semantics direct style function 
suffix corresponding suffix tuple types indicates region function allocated 
functions may polymorphic types regions capabilities adding constructor context function type 
convenience types regions capabilities combined single syntactic class constructors distinguished kinds 
type constructor kind type region constructor kind rgn capability constructor kind cap 
range constructors metavariables constructors types regions capabilities respectively 
metavariables constructor variables kind rgn cap metavariable type variables generic constructor variables 
empty abbreviate function type atr atr 
example polymorphic identity function allocated region continuation function may region may type type rgn atr appropriate letf function argument type continuation type atr 
thenf called 
specifies formed constructors constructor contexts 
main judgments assume constructor context formed 
judgement states formed constructor context second judgement states formed constructor kind 
typing rules region types assign type location allocated region memory types assign region type region allocated memory 
necessary understand constructs preliminary development defer discussing describe static semantics machine formal detail see section 
capabilities central problem ensure statically region freed 
typing rules enforce system capabilities specify operations permitted 
main typing judgement states memory type free constructor variables kinds free value variables types legal execute term provided capability held 
related typing judgement states capability held legal execute declaration new constructor context new capability capabilities indicate set regions presently valid access regions freed 
capabilities formed joining collection singleton capabilities ctxt empty cap type var int type type int rgn type name dom ctxt var dom ctxt sub cap type sub rgn handle type type handle type rgn type type cap rgn atr type cap cap cap cap type type plus type tuple type arrow rgn cap type single cap cap type bar capability static semantics type context formation provide access region capability variables provide access unspecified set regions 
capability joins written associative commutative idempotent section see examples equivalent empty capability provides access regions denoted 
abbreviate capability rn rn 
order read field tuple region necessary hold capability access rule cap dom subgoal indicates capability held equivalent capability includes 
similar rule allocate object region 
type heap value reflects region allocated heap value typing judgement second subgoal provided region 
cap handle dom functions functions defined form fix xn wheref stands function may appear free body specifies function constructor arguments function capability precondition 
empty appear free function body abbreviate fix form xn order call function residing region necessary hold capability access hold capability equivalent function capability precondition cap cap atr vi vn body function may assume function capability precondition satisfied indicated capability premise rule xn xi dom xn expected annotation indicates closure value resides region resultant function type atr 
extend required capability function quantified capability variable similar row variable 
variable may instantiated capabilities leftover rule specializes full rule fix case function polymorphic recursive 
satisfying required capability 
consequently function may variety contexts 
example functions type cap 
atr may called capability extends 
allocation deallocation delicate issue typing region allocation deallocation 
intuitively typing rules newrgn freergn declarations add remove capabilities appropriate region 
naive typing rules newrgn rgn handle wrong handle wrong able rule allocation naive rule freeing regions fundamentally flawed 
example consider function fix rgn rgn handle int 
function formed naive typing rule function begins capability removed freergn declaration leaving 
tuple allocated projection legal 
code operationally incorrect instantiated region case declaration frees second attempts read problem familiar 
free region safely necessary delete copies capability 
instantiating region variables create aliases making impossible tell inspection copies exist 
alias control desire system alias control easily enforced type system expensive complex program analyses 
possibility linear type system 
linear type system aliasing trivially controlled region name consume name ensuring 
linear type system naive rules allocating deallocating regions sound 
unfortunately linear type system restrictive permit useful programs 
example suppose type rgn rgn int int 
atr integer tuples allocated region called arguments require instantiating region 
generally type function takes arguments allocated region 
approaches syntactic control interference permissive linear type system restrictive purposes impossible instantiate multiple arguments region 
uniqueness approach trying prevent aliasing type system track aliasing 
precisely track non aliasing uniqueness 
tagging regions multiplicities forming capability 
form capability access region understood heretofore 
second form permits accessing region adds additional information unique represents different region region appearing capability formed 
example capability indicates permissible access indicates represent distinct regions 
guarantees appear capability formed capability just access free may type region deallocation rule handle cap allocation region accordingly adds new capability unique newrgn rgn handle dom dom note joining capabilities idempotent capabilities question contain unique multiplicities 
instance capabilities equivalent capabilities capability asserts distinct consequently capability satisfied 
equivalent duplicatable 
note capability variables stand capability including ones 
occasionally prevents typing desired programs provide stripping operator replaces 
capability multiplicities multiplicities 
example capability duplicatable 
programs need unknown duplicatable capability may stripped variable 
see section stripping operator essential translation tofte talpin region language capability calculus 
complete rules equivalence capabilities constructors appear 
notice single rule eq flag equates duplicatable capability barred capability 
consequently form redundant presence bar operator 
notation pleasing foil notation flags give convenient way distinguish regions appear regions potentially appear times single capability 
capabilities provide privileges 
say write 
complete system various rules section modified account 
example function call rule atr vi vn ctxt eq empty cap eq reflex cap cap cap cap cap eq ctxt eq kind ci cap cap eq assoc cap eq bar cap cap eq bar idem ctxt eq bound eq symm eq trans eq congruence plus cap cap eq congruence bar cap cap cap eq comm rgn cap eq flag cap cap eq dup cap cap cap eq distrib capability static semantics equality cap sub eq sub congruence plus sub var sub trans sub congruence bar cap sub bar capability static semantics equality relations suppose type rgn rgn 
atr 
hold capability instantiating 
relation may call hold instantiating 
contains rules 
reading rules remember cap 
fact derive judgement cap discussed informally cap sub bar cap eq flag cap sub eq cap sub trans relation accounts forgetting uniqueness information 
intuitively second source generated forgetting entire capability 
example provide privileges reasonable suppose 
construct sound capability calculus incorporating axiom omit doing allows specify memory management obligations prove stronger property space usage 
notice omitting axiom give flexibility may write function called extra capabilities capability variable discussed section 
omitting axiom type system may formally specify responsibility freeing region 
failure follow informal conventions common source bugs languages manual memory management 
type system rules bugs 
example consider type rgn cap handle atr atr system 
consequently function type return call continuation type atr take action satisfy capability free 
general type system prevents region leaks programs deallocate memory regions terminate theorem 
operating system clean program halts 
typing rule halt states capabilities may held capabilities may forgotten means regions freed 
int cap halt bounded quantification system point sound sufficient compiling real source languages 
need able recover uniqueness region name duplicated 
see suppose hold capability type rgn rgn 
atr able instantiate may free calls continuation final argument 
unfortunately continuation possesses capability capability necessary free strengthen capability continuation example may call 
may recover uniqueness information quantifying capability variable 
suppose hold capability type rgn rgn cap 
atr may instantiate continuation possess capability allowing free unfortunately body function longer capability access type draws connection 
solve problem bounded quantification relate 
suppose type rgn rgn 
atr hold capability instantiating instantiating 
instantiation permissible continuation possess capability allowing free body capability access 
bounded quantification solves problem revealing information capability requiring function parametric 
function calls continuation regain stronger capability free capability temporarily hidden order duplicate generally bounded quantification allows hide privileges calling function regain privileges continuation 
support statically checkable attenuation amplification capabilities 
static semantics far combination parametric polymorphism bounded parametric polymorphism notions uniqueness aliasing provide flexible language expressing lifetimes regions 
figures formally summarize rules type checking instructions values depend concepts 
explained majority rules previous sections rules specified obvious ones integers type int 
notice form judgement heap values slightly different judgements instructions small values judgment states memory type free constructor variables kinds free value variables types heap value resides region type 
static semantics machine described type constructor language capability calculus typing rules main term level constructs 
fact previous section contains information programmers compilers require write type safe programs capability calculus 
order prove type soundness result style wright felleisen able type check programs step evaluation 
section give static semantics run time values normally manipulated programmers necessary prove soundness result 
formal definition semantics may appear quite complex number different judgment forms 
forms follow naturally development previous sections type systems allocation semantics 
extra complexity definition language pay come prove type soundness main invariants expressed directly typing rules proof follows straightforward inductions rules 
specifies rules typing memory straightforward 
judgments specify memory types region types formed 
case subcomponents formed 
judgment states memory described judgement states region name described 
informally judgements ensure addresses memory described contains value address type 
judgment sat called satisfiability judgment formalizes connection static capability run time state memory 
clearly current capability contain regions memory lead runtime error 
equally important memory contain regions capability regions freed 
consequently satisfiability ensures time execution machine capability contains exactly regions memory 
furthermore virtue fact cap unique regions may appear properties essential ensure regions safely 
contains rules small values appear run time addresses region handles 
rules typing address quite unusual crucial type soundness proof 
rule addr lifetime region region memory domain memory type 
rule addr applies type 
consider point computation region deallocated 
region longer memory addresses may appear embedded tuples closures allocated regions type 
region appear memory type xn fix xn vi rgn vn type atr xn dom var int int tuple eq atr atr type eq type capability static semantics heap word values sub fix int int int dom val dom prim handle iv newrgn rgn handle handle cap freergn atr vi vn app dom dom proj dom dom freergn newrgn int int cap halt capability static semantics declarations expressions halt sat region type memory type hi hn region ri rn memory cap sat sat capability static semantics memory type system flexibility give function type rule addr arrow tuple type rule addr tuple 
glance rules appear lead unsoundness address dangling pointer may valid type 
fortunately capabilities prevent going wrong 
satisfiability judgment ensures programs possess capabilities regions appear memory explained earlier programs access regions capabilities 
consequently dangling pointer may valid tuple function type capabilities prevent accessed 
components necessary define formed machine state 
state formed memory described formed heap type exists capability satisfies heap type expression formed respect sat program type type addr dom addr tuple handle handle handle dom addr arrow capability static semantics run time values formal properties calculus important property capability calculus type soundness 
type soundness states program enter stuck state execution 
state exist ande halt example state tries project value tuple appear memory stuck 
theorem type soundness stuck 
previous sections article explained type memory relate memory typing static capabilities collection capabilities rules typing expressions prevent unsafe accesses store 
invariants main elements formal proof soundness 
details fill 
proof style wright felleisen uses standard type preservation progress lemmas 
progress states typed states stuck preservation states evaluation steps preserve typedness 
lemma type preservation lemma progress 
exists 
halt kinds type rgn eff constructor variables constructor contexts type schemes constructors int handle term variables term contexts terms en en cn letregion region syntax length tedium proofs lemmas removed proof soundness appendix second important property language typed terminating programs return memory resources system halt 
call property complete collection 
theorem complete collection diverges halt 
subject reduction progress terminating programs formed machine states halt 
typing rule halt expression requires capability empty 
fact infer memory contains regions 
appendix contains formal proof theorem 
regions capabilities primary goal development type safe language gives compilers control allocation deallocation data 
order technology effectively need compiler support generating intermediate language code source language programs 
section define high level explicitly typed variant tofte talpin region language show translated capability calculus 
composing translation region inference may obtain type preserving compiler front 
region calculus preliminaries source language compiler region calculus shown 
language explicitly typed variant calculus tofte talpin 
capability calculus contains integers tuples functions 
capability calculus allocation deallocation regions combined single construct letregion construct allocates new region places handle region term variable 
executes expression region deallocated 
discussed lexically scoped construct flexible separate newrgn freergn constructs provided capability calculus 
main goal section show compile letregion expressions lower level primitives 
original tofte talpin calculus region language prenex predicative polymorphism 
term allocates closure polytype 
closure polymorphic type context may contain ordinary type variables region variables effect variables explained 
closure allocated region expression evaluates region handle expression describes body function 
previous region type systems treat type constructors including region constructors compile time objects 
term cn denotes type application runtime effect 
type checking type scheme polymorphic function instantiated types cn obtain resultant type expression dynamic semantics program shown depend types 
types may erased program run affecting computation 
capability calculus data structures required allocate deallocate regions treated values type handle 
types effects main interest type constructor portion region language presence effects 
effects capabilities control program access regions particular prevent access regions deallocated 
intuitively effect term set regions term accesses 
formally effect empty effect effect variable singleton set union effects 
operator associative commutative idempotent unit union operator 
write eff equality effects abbreviation eff effect 
functions latent effects incurred function called body executed 
effect appears arrow types specifies set regions function type may access invoked 
formal rules type effect formation equality may 
static semantics static semantics terms judgement form track effects produced expression 
judgement states type context value context term type produces effect 
example rule projection states expression producing effect produces effect 
projection operation reads region subexpression may read write regions 
resulting effect union 
tofte talpin require arrow type annotated arrow effect constrained form 
name effect plays role inference system 
interested type checking type inference need name effects arrows 
type dom type eff rgn int type type rgn type eff rgn eff congruence rules omitted eff eff eff eff rgn handle type rgn eff type type eff eff eff eff eff eff eff eff eff eff region type formation equality subset int int int int ei en handle en en int handle ci cn cn rgn handle letregion ftv dom dom type region term static semantics dom rules involving functions complex 
consider function call 
assume generates effect evaluates closure type produces effect type 
expressions evaluated code function projected closure resides region function produces effect effect call union 
contrast value application rule rule type application produces effect remember types erased expression executed 
examine rule letrec term 
components effect produced expression effect evaluating handle expression effect writing closure data structure region effect subsequent expression 
checking types match properly sure effect produced body function subset declared effect 
type system unsound functions hide effects 
rule checks letregion construct 
notation denote effect occurences replaced 
rule discharges effect effect produced subexpression intuitively letregion construct discharges effects constructs pass effect information subexpressions enclosing expressions access region outside scope letregion detected type checker reject expression 
shows example program function count counts zero 
order interesting allocation behavior integers involved count boxed allocated region 
count function stored region takes arguments handle region allocated region 
nonzero count decrements storing result recurses 
function effects read resulting recursive call read write effect resulting line read line store 
give function count effect 
code allocates regions stores closure count stores boxed integer calls count deallocates 
translation order formal connection region calculi corroborate claims region inference techniques developped tofte front capability compiler defined type directed type preserving translation region calculus previous section capability calculus 
appendix contains proof formed source term translated formed target term 
kind type translation translation continuation passing style transformation simultaneously transform effects capabilities 
kind type transformation 
kind translation trivial effects capabilities kinds unchanged 
translation types equally simple 
translation base types identity general translate types recursively translate components recombine corresponding capability constructor 
tuples mapped tuples handles mapped handles letregion letregion letrec count handle int count count count letrec region scope deallocate region scope deallocate count 
handle int unit count region calculus type type rgn rgn eff cap int int rgn cap att handle handle xn xn region capability kind type translation translation function types involved 
recall usual cps translation arrow type transformed accepts translated continuation translation region arrow types structure complications arise transform effects capabilities 
complication involves finding region continuation closure 
solve problem allocating new region hold continuation translated function abstracts region 
second complication effect function may mention subset regions live call site 
resulting capability calculus function thread capability describing live regions context function called body function continuation 
accomplish task abstracting additional capability variable function context sensitive 
mechanism thread capability calling context function continuation 
third complication type translation ensure equal types region calculus translated equal types capability calculus 
part obligation satisfied trivially equality relation region types corresponding capability calculus analogues simple syntactic equality conversion bound variables 
equality relation effects set equality equality relation arbitrary capabilities set equality necessarily idempotent 
fortunately equality duplicatable capabilities exactly set equality 
type translation carefully translates arrow effects duplicatable capabilities 
insights naturally lead translate region function type capability calculus function type rgn cap cont att capability translated function subtype 
capability gives translated function access regions requires regions regions accessed source language function region containing continuation contains regions calling context threaded call continuation 
notice capability appears type duplicatable prove equal types translated equal types 
explained section give continuation correct type bounded quantification allows continuation recover uniqueness information necessary deallocate regions function 
definitions straightforward prove essential properties types wellformedness equality substitution preserved translation 
lemmas proven simple induction formedness equality derivation 
lemma formedness preservation 

lemma equality preservation 
eff cap 
eff cap lemma substitution preservation type 
term translation heart term translation continuation passing style transformation 
variations transformation produce efficient code lead simpler correctness proofs 
chosen simple translation straightforward prove type preserving may focus details relevant region memory management 
informal description basic mechanics cps term translation ignoring details relevant regions capabilities 
main arguments translation type checking context source language term target language continuation formed context type andk continuation translation produce formed target term 
operationally target term computes producing value result calls continuation argument 
source term value suchas integer variable translation simply function call 
hand assuming left right evaluation order source term represents computation say computation cps translation arranges compute producing value compute producing value allocate pair pass resulting pointer continuation write translation follows 


translation subcomponent requires continuation continuation contains code subsequent subcomponents 
primitive operation op applied resulting values result passed compilation arithmetic operations projections form 
couple details notice translation 
taken liberty annotating expressions types necessary 
second translation introduces new variables add variables translated types context 
decision influence behaviour translation facilitates statement proof type correctness theorem 
translation function application begins way operations translate passing resulting value continuation contains translation 
continuation contains function application 
user defined cps functions primitive operations return continuation passed directly translated function 


expressions declare functions translated result expects extra continuation argument xcont calls continuation return 
xcont xcont cont xcont type function continuation cont 
thetype function cont 
simple cps translation provides basic structure translation region language capability calculus 
previous researchers observed translation introduces unnecessary administrative redexes 
example scheme far translation simple pair respect continuation simpler term 
concerned time required execute extra function applications concerned space required additional function closures 
region translation directly naive translation forced allocate additional regions expressions 
previous avoided problems defining translation terms level type system passing translation meta level continuations target level continuations 
interested space properties translation simpler solution 
allocating continuation closures expression bind result computation pass continuation 
solution avoids additional allocation lead complexities level type system 
translation pair respect continuation notation denotes application continuation value 
continuation represented target language expression intuitively application simply 
continuation pair continuation parameter body 
representation natural define notation define cps translation pairs general follows 
region expressions capability calculus ready investigate formal details translation region language expressions capability calculus expressions 
discussed translation form 
context 
components region type context region value context 
third component translation environment 
environment contains capability calculus type context capability calculus value context pair capabilities context describes kinds new type variables introduced translation capability type variables possibly bounds 
value context describes types new value variables introduced translation 
intuitively capability represents current capability point translation bound notation denote translation environment formal translation figures 
translation assumption variables unique introduce variable term continuation fresh conflict variables source term type checking context continuation 
invariant guiding transformation main parts 
region language term formed type value contexts 
formally 
continuation formed current context 
formally 
current capability contains superset regions mentioned effect formally case simplified cps translation translation source language values simplest 
example translate variable integer simply apply continuation respectively 
type application expression cn value take interpretation types erased run time 
apply continuation directly cn 
cn cn int xn en xn xn en xn xn xn letx ix int int letregion newrgn rgn handle region capability term translation fix rgn cap xcont cont 
xcont atr handle cont rgn cap handle xcont cont newrgn fcont fix fcont fcont region capability term translation functions translation tuples follows informal description closely 
translate computations en tuple sequence bind resulting values xn 
translated expressions allocate tuple xn region handle xn 
order tuple allocation operation safe ensure region say corresponds region handle xn live 
words able prove current capability contains capability 
invariants provide means deduce fact informal reasoning 
invariant states expression en en formed effect 
inspection region language typing rule tuples reveals contains effect 
second part invariant states capability contains capabilities regions appear effect including course 
part invariant know current capability contains 
consequently tuple allocation operation safe 
similar reasoning straightforward verify informally translation arithmetic operations projections statements fail type check lack sufficient capabilities 
translation term letregion difficult letregion translated newrgn declaration followed translation inner expression freergn declaration deallocate 
simple reasoning allows check stated invariants hold transformation 
particular translation inner expression reflects fact new region just allocated translation environment step contains capabilities may conclude invariant part satisfied 
inspection typing rule letregion reveals effect effect entire letregion expression 
contains contains capabilities regions including course 
satisfy invariant part translation recall region type system ensures region inside continuation translation safely free region proceed invariant specified expected capability exactly capability context freeing region 
complex part translation involves functions 
fortunately type translation explained specifies main invariants translation functions terms follows directly specification 
specifically extend function type context region continuation closure capability hiding extra regions calling context current capability bounded 
add value argument translated function continuation xcont 
simple verify translated function translated function type 
body function translated assumptions 
continuation part translation invoke function new argument xcont 
examine translation function application 
translation allocates new region continuation closure 
translation allocates continuation 
continuation defined expect capability 
maximum capability point computation permits continuation deallocate region containing closure 
allocating continuation translation continues translation actual function application 
translated function value type rgn cap atr calling function code instantiate variables properly 
code naturally instantiates region just allocated 
point program capability represents current capability upper bound 
code instantiates legal provided prove invariant states 
need verify term arguments continuation fcont expected translated function easily checked 
properties translation proven translation preserves types 
theorem cps type preservation int halt fresh empty proof proceeds induction height typing derivation source language term invariants forming induction hypothesis 
appendix contains formal proof representative cases 
translation preserve space program 
minamide proven standard cps translation preserves maximum amount reachable space constant factor 
defines space profiling semantics simply typed lambda calculus refines blelloch greiner 
augment semantics sort space profiling information may able prove similar result translation 
informal inspection translation indicates resultant term allocates data structures source term exception continuation closure require return function call intuitively closure corresponds stack space required save local variables function call 
formal investigation space properties translation scope 
example program translation count function previous section 
simplifications output formal translation improve readability program 
particular optimized away administrative redexes performed tail call optimization recursive call count function 
writing capabilities 
program begins allocating regions newrgn declaration puts closure count 
function requires capability capability cont needed access argument continuation passes capability continuation type check body count function verify possess capabilities necessary data accesses legal 
comments code indicate checks occur 
calling count pass continuation cont 
continuation requires capability order free regions 
application site count capability instantiated stronger capability needed continuation 
newrgn newrgn capability held count fix count rgn cont rgn cap cont handle int cont capability held cont ok cont ok ok count cont cont ok newrgn capability held cont capability held freergn unique freergn unique freergn unique halt count cont example context count function uses regions currently allocated capability variable redundant 
code instantiates call site count exactly regions cont appear bound general hide left capability 
example allocated fourth region need instantiate capability corresponding changes continuation 
hide capability fourth region count preserve call deallocated continuation count hiding left capability newrgn newrgn newrgn newrgn count 
capability held cont 
count cont power bounded quantification comes play function called regions may may 
example original code rewritten cont share region changing function count way count cont sharing newrgn newrgn count 
capability held cont 
count cont example cont instantiated instantiated capability required cont 
count proceeds exactly cont optimization examples count tail recursive allocate new cell time loop deallocate cells count complete 
contains live values current argument safe reduce program space usage deallocating argument region time loop shown 
note optimization possible region lifetimes lexically scoped 
order deallocate argument revised count requires unique capability argument region 
note program rewritten cont shared region lead run time error deallocated early program longer typecheck 
program rewritten count cont share region fail run time typecheck 
newrgn newrgn capability held count fix count rgn cont rgn cont handle int cont capability held ok freergn unique capability held cont ok newrgn capability held count ok cont ok newrgn cont capability held freergn unique freergn halt unique count cont count efficient memory usage capability calculus typed assembly language section informally describe construct backend compiler translates capability calculus capability typed assembly language 
continuation passing style transformation previous section order evaluation expressions explicit names intermediate computations 
reduces unconditional control flow transfers uniform mechanism function call functional goto transformation performs significant portion compilation high level language 
long way strongly typed assembly code 
morrisett describe eliminate high level language features closures data structures compiling strongly typed risc assembly language 
fortunately addition capability constructs cps language interfere type directed compilation describe 
fact capability constructors machine language level appear capability calculus described 
section briefly retrace compilation strategy laid morrisett point interacts capability framework 
closure conversion assembly languages contain nested functions common high level languages 
closure conversion process transforming function depends explicitly declared parameters depend values defined outer non global scope 
nested functions closed way may lifted top level 
process usually results pairing closed function code environment create closure data structure 
typed closure conversion algorithms various complexities 
minamide show closure converting polymorphic type passing language requires sophisticated target language includes translucent sums kinds existential types 
morrisett hand able define simpler closure translation give advantages type passing semantics assume type erasure semantics 
crary discovered preserve advantages type passing language closure conversion retain simplicity algorithm proposed morrisett 
crary approach achieves expressiveness type passing simplicity type erasure semantics passing values represent types runtime types 
crary distinguishes type constructors erased runtime type representations values manipulated runtime just distinguish region constructors erased runtime region handles values manipulated runtime 
decision allows simpler closure conversion algorithm possible type passing region calculus tofte talpin 
additional considerations choice closure conversion algorithms involving represent environments closure convert mutually recursive functions 
purposes assume simple closure transformation described morrisett 
algorithm requires addition existential types type language 
disadvantage algorithm closure time loop recursive function 
morrisett harper discuss translations require recursive types cyclic reader recognize extra allocation show extra effect high level languages 
pack operation incur overhead repeated closure creation 
practical language implementation choose efficient translations details closure conversion orthogonal central concerns assume simplest alternative refer interested reader literature deeper investigation tradeoffs 
code generation closure conversion completed program memory requirements explicit 
compiler writers opportunity optimize memory usage eliminating closure creation known functions optimizing environment representations removing resulting dead regions 
point code generation 
morrisett describe code generation phases 
phase breaks atomic data structure allocation initialization high level languages series lower level instructions initialize fields data structure 
order prevent access uninitialized fields add flag field indicates read 
example expression malloc int int xr int int int int int int flag indicates field initialized readable 
flag indicates field initialized 
case initialization steps appear 
general may separated field unused need initialized 
flexibility allows optimizer schedule instructions chooses interference type system 
major task second phase code generation compile closed code branching constructs statements assembly language control flow operations 
point control transfers jumps typed assembly language code blocks 
code blocks typing precondition part contains standard assembly language instructions additional typing annotations 
eliminated high level data structures closures tuples named intermediate computations correspondence intermediate language declarations assembly language instructions 
section describes typed code blocks precisely gives complete description capability typed assembly language 
code generation little impact novel features capability calculus refer reader morrisett gives formal description details code generation closed continuation passing style lambda calculus 
accomodate translation checking recursive region calculus function type wemust require contain effect region similarly capability recursive capability calculus function contain region function allocated 
capability typed assembly language capability typed assembly language generic typed assembly language morrisett 
great similarity discuss capability features detail 
syntax language 
types discussed little change type language 
kind structure identical tuples function types changed 
tuple types initialization flags field discussed previous section 
continuation passing style function types translated code block types form types type context specify capability code requires 
typed assembly language alpha varying variables uses fixed set non varying registers 
precondition code block finite map registers types simple list types 
furthermore types classify code closures pair code data assume code allocated special region execution program begins 
omit trailing region annotation appears capability calculus closure types 
tuples remaining heap allocated data 
addition type language existential type need encode results closure conversion 
separation code data reflected memory types split pair code region cd familiar mapping region names data regions 
contains formedness rules new types 
rules formedness capabilities types rules gave capability calculus rules governing formedness contexts type equality relations 
refer reader previous sections rules 
technical reasons tal type system requires simple subtyping relation tuple types register file types 
subtyping relations interact capability subtyping 
see morrisett discussion items complete description tal type structure general 
values tal values split categories word values small values heap values 
heap values code tuples analogous capability calculus counterparts discussed 
small values small distinguish contains registers 
register file mapping registers word values 
map registers registers 
word values contain integers data addresses region handles handle saw capability calculus 
code addresses cd refer code code region 
word value uninitialized value type 
int int uninitialized pair integers 
values coercions change type word value runtime effect technical reasons analogous small value forms 
kinds type rgn cap constructors types int handle regions capabilities multiplicities init flags memory types cd cd region types register file types rn contexts registers 
word values cd pack handle small values pack heap values wn code inst 
sequences jmp halt instructions add rd rs ld rd rs malloc rd mov rd mul rd rs newrgn rd st rd rs sub rd rs unpack rd memory cd rcd rn heaps hn register files rn wn programs capability tal syntax type instantiation saw capability calculus 
second value form introduces existential type hiding type variable 
general form meaning static semantic judgements values similar counter parts capability calculus 
addition judgement states formed typing context word value flagged type contains rules value formedness 
tal machine general tal instruction set closely instructions standard risc instruction set semantics intuitive 
example add rd rs adds contents register rs value places result register rd instructions mul sub multiply subtract similar fashion 
ld rd rs instruction loads ith word data block indicated pointer register rs register rd rd rs instruction writes contents rs ith word memory pointed rd mov rd instruction copies source operand tothe destination register rd 
simplified language contains control flow instructions jmp unconditional jump address contained contents register non zero fall instruction 
instructions typical risc instruction set 
commands malloc newrgn calls runtime system 
newrgn freergn allocate deallocate regions similar manner high level counter parts 
malloc rd allocates space equivalent sum sizes types region indicated region handle resulting address placed register rd instructions coded typed assembly language 
implementations implementation type checker forms trusted computing base 
fortunately region primitives simpler implement standard tracing garbage collector 
goals reduction trusted computing base previous low level safe language efforts tal proof carrying code 
instructions halt unpack somewhat special 
unpack instruction elimination form existential types 
existential type opened value type written register rd type variable introduced type context 
runtime types erased instruction reduces move normal case instruction op 
intuitively halt instruction returns control operating system expects integer register 
machine state contains components memory register file list instructions 
noted memory contains code region set data regions 
memory described memory type 
register file described register file type mapping registers word values 
typing rules machine instruction set figures 
operational semantics machine 
previous development semantics quite straightforward 
semantics additional piece notation cn denotes substitution constructors variables domain 
claim static semantics tal machine sound respect operational semantics new rules cap type type rgn type type type cd cd cd new rules type rn type type type rgn type type type rm rn capability tal abbreviated type formedness hcode wi wn cd cd dom cap code hcode int handle handle cap type pack type cap type pack capability tal value formation halt cap interesting rules jmp handle cap rs cap ld rd rs rd type handle cap malloc rd rd newrgn rd rd handle rd rs cap st rd rs rd capability tal instructions sat rcd cd code ri val cd cd rn cd cd hi hcode hn code hi hn val wi rn wm rn cap sat sat capability tal machine add rd rs rd rs similarly mul sub cd cd code freergn handle dom jmp cd cd code ld rd rs rd wi rs wn malloc rd rd handle dom mov rd rd newrgn rd rd handle new st rd rs wi rs wi wn rd wn unpack rd rd pack pack pack operational semantics tal claim capability tal type safety stuck state believe proof long tedious straightforward 
proof type safety capability calculus proof driven syntax language involve complicated greatest fixed point construction 
discussion believe general framework capability system quite robust 
ways extend language number directions research 
language extensions article concentrated capability calculus implement safe region memory management changes believe capability apparatus may variety settings 
potential application involves reducing overhead communication user kernel address space boundary traditional operating systems 
typically systems data user space kernel kernel copy data ensure integrity preserved 
user process hands unique capability region kernel kernel copy region data capability user longer read modify contents region 
handing user capability kernel ensure kernel exclusive access data governed capability 
generalize idea capabilities ensure access shared mutable data multi threaded environment viewing locks analogous regions 
associate piece sensitive data lock statically check client data obtains corresponding lock associated capability attempting access 
code releases lock type system revoke capability data just revokes capability region freed 
flanagan abadi investigated idea context high level lexically scoped language 
just compiled tofte talpin high level region language capability calculus conjecture compile flanagan abadi locking language variant capability calculus locking primitives allocation primitives 
third application capabilities control reason aliasing object basis region basis 
smith walker morrisett investigated idea associating different capability individual object including type object capability 
code possesses unique capability object may deallocate object chooses may explicitly reuse space object store value different type 
new design may viewed extension conventional linear type systems admits aliasing allows safe deallocation objects 
techniques extend typed assembly language implementation operations explicit verifiably safe memory management 
general system wishes restrict access data statically ensure certain sequence operations performed may consider capabilities 
fact walker shown combination capabilities simple logic sufficiently powerful encode property enforced security automaton 
security automata specify safety property extended capability calculus 
related formalisms reasoning computational effects programming languages including type effects systems monads linear types capabilities 
researchers actively investigating relationships different areas picture fully understood 
eager continue line research explore formal links system 
translation tofte talpin region calculus capability calculus reveals relationship effects capabilities quite close 
necessary prerequisite system type inference performed programmer compiler research effects systems concentrated difficult task 
focus inference effect systems usually formulated bottom synthesis effects 
may viewed producing verifiable evidence correctness inference 
effect systems typically bottom specifying effects occur take top approach specifying capabilities effects permitted occur 
tofte talpin effect system capabilities sensitive control flow 
constructing effect expression union effects subexpressions losing information order evaluation verify programs safe checking instruction capability produced previous instructions verify instructions follow safe 
connection drawn capabilities monadic type systems 
relating effects monads viewed effectful functions pure functions return state transformers 
called ex post view effect takes place function execution 
contrast take ex ante view capability perform relevant effect satisfied function execution 
considerable similarity views just monad laws ensure store single threaded computation typing rules thread capability summarizes aspects store execution path program 
closest relationship occurs linear type systems capabilities 
inspection axioms capability equality reveals similar structural rules linear type systems see wadler linear logic 
particular linear assumptions unique capabilities allow contraction weakening rules non linear assumptions duplicatable capabilities allow contraction weakening rules 
essential difference formalisms capability access object say separated type object say int 
level indirection possible allow aliasing verify deallocation safe operations permissible conventional linear type systems 
significant amount prior research specific topic theory implementation region memory management 
implementation side birkedal formulations linear logic admit weakening rule allows assumption completely forgotten 
explained earlier allow complete forgetting capabilities leads space leaks 
admit restrictive weakening rule allows capability forgotten 
describe optimizations basic region allocation scheme ml kit regions improve space efficiency 
observations functions different contexts context live object remains region function call second context may live objects remaining region call 
order avoid code duplication ensure efficient space usage call site passes information called function run time 
information function may dynamic decisions region deallocation 
type system powerful encode storage mode polymorphic functions 
believe dynamic tests may viewed form intensional type analysis augment capability calculus variant harper morrisett typecase mechanism may able verify results storage mode optimizations 
aiken studied optimize original tofte talpin region framework 
capability calculus separate region allocation region deallocation 
technique verifying results optimizations safe 
conjecture soundness proof aiken analyses analysis produce typing annotations verification take place capability calculus 
gay aiken developed extensions gives programmers complete control region allocation deallocation 
counting prevent programmers accidentally accessing deallocated regions 
hawblitzel von eicken notion region language passport support sharing revocation multiple protection domains 
groups run time checking ensure safety interesting investigate hybrid systems combine features static type system dynamic systems 
theory side believe important contributions syntactic proof soundness region deallocation 
mentioned earlier formulation capability calculus allows standard proof techniques popularized wright felleisen 
long proof requires little creativity 
contrast tofte talpin greatest fixed point construction inductive argument prove correctness region inference scheme 
despite high level differences proof techniques illuminating similarities details proof 
notably tofte talpin proof involves notion consistency relates source target values region inference translation 
consistency defined respect effect rest computation 
informally consistency conditions states source value consistent target value region respect effect appear 
effect capability rest computation deallocate region rest computation distinguish dangling pointer value source language 
tofte talpin proof effect rest computation plays role similar capability required continuation 
key reason language admits syntactic proof soundness continuations capabilities explicit language tofte talpin introduce idea meta level construction proof 
new strongly typed language admits operations explicit allocation deallocation data structures 
furthermore language expressive serve target region inference admits relatively straightforward proof soundness 
believe notion capabilities support statically checkable attenuation amplification revocation effective new tool language designers 
lars birkedal martin elsman dan grossman chris hawblitzel fred smith mads tofte stephanie weirich steve zdancewic anonymous reviewers comments suggestions earlier versions 
alexander aiken manuel hndrich levien 
better static memory management improving region analysis higher order languages 
acm conference programming language design implementation pages la jolla california 
bowen alpern fred schneider 
recognizing safety liveness 
distributed computing 
baker 
list processing real time serial computer 
communications acm 
brain bershad stefan savage pardyak emin sirer marc fiuczynski david becker craig chambers susan eggers 
extensibility safety performance spin operating system 
fifteenth acm symposium operating systems principles pages copper mountain december 
lars birkedal nick rothwell mads tofte david turner 
ml kit version 
technical report department computer science university copenhagen 
lars birkedal mads tofte magnus 
region inference von neumann machines region representation inference 
third acm symposium principles programming languages pages st petersburg january 
guy blelloch john greiner 
provably time space efficient implementation nesl 
acm international conference functional programming pages june 
karl crary stephanie weirich greg morrisett 
intensional polymorphism type erasure semantics 
acm international conference functional programming pages baltimore september 
olivier danvy frank pfenning 
proving syntactic properties cps programs 
third international workshop higher order operational techniques semantics september 
published alan gordon andrew pitts editors electronic notes computer science volume pages 

olivier danvy andrzej filinski 
representing control study cps transformation 
mathematical structures computer science december 
andrzej filinski 
controlling effects 
phd thesis carnegie mellon university school computer science pittsburgh pennsylvania may 
fischer 
lambda calculus schemata 
proceedings acm conference proving assertions programs pages 
cormac flanagan martin abadi 
types safe locking 
proceedings eighth european symposium programming pages march 
david gay alex aiken 
memory management explicit regions 
acm conference programming language design implementation pages montreal june 
gifford lucassen 
integrating functional imperative programming 
acm conference lisp functional programming cambridge massachusetts august 
jean yves girard 
linear logic 
theoretical computer science 
robert harper mark lillibridge 
explicit polymorphism cps conversion 
twentieth acm symposium principles programming languages pages charleston january 
robert harper greg morrisett 
compiling polymorphism intensional type analysis 
second acm symposium principles programming languages pages san francisco january 
chris hawblitzel chi chao chang grzegorz czajkowski hu thorsten von eicken 
implementing multiple protection domains java 
usenix annual technical conference new orleans june 
chris hawblitzel thorsten von eicken 
sharing revocation safe language 
unpublished manuscript 
pierre jouvelot gifford 
algebraic reconstruction types effects 
eighteenth acm symposium principles programming languages pages january 
dexter kozen 
efficient code certification 
technical report tr cornell university january 
john launchbury simon peyton jones 
state haskell 
lisp symbolic computation december 
tim lindholm frank yellin :10.1.1.24.6526
java virtual machine specification 
addison wesley 
john lucassen 
types effects integration functional imperative programming 
phd thesis mit laboratory computer science 
minamide 
space profiling semantics call value lambda calculus cps transformation 
third international workshop higher order operational techniques semantics september 
published alan gordon andrew pitts editors electronic notes computer science volume pages 

minamide morrisett harper 
typed closure conversion 
third acm symposium principles programming languages pages st petersburg january 
eugenio moggi 
notions computation monads 
information computation 
greg morrisett karl crary neal glew dan grossman richard samuels frederick smith david walker stephanie weirich steve zdancewic 
typed assembly language intel ia architecture 
see www cs cornell edu latest implementation 
greg morrisett matthias felleisen robert harper 
models memory management 
acm conference functional programming computer architecture pages la jolla june 
greg morrisett robert harper 
semantics memory management polymorphic languages 
gordon pitts editors higher order operational techniques semantics publications newton institute 
cambridge university press 
greg morrisett robert harper 
typed closure conversion recursively defined functions extended 
carolyn talcott editor higher order techniques operational semantics volume electronic notes theoretical computer science 
elsevier 
greg morrisett david walker karl crary neal glew 
system typed assembly language 
fifth acm symposium principles programming languages pages san diego january 
greg morrisett david walker karl crary neal glew 
system typed assembly language 
acm transactions progamming languages systems may 
george necula 
proof carrying code 
fourth acm symposium principles programming languages pages paris 
george necula peter lee :10.1.1.23.5498
safe kernel extensions run time checking 
proceedings operating system design implementation pages seattle october 
george necula peter lee 
design implementation certifying compiler 
acm conference programming language design implementation pages montreal june 
simon peyton jones philip wadler 
imperative functional programming 
twentieth acm symposium principles programming languages charleston south carolina january 
plotkin 
call name call value lambda calculus 
theoretical computer science 
john reynolds 
definitional interpreters higher order programming languages 
conference record th national acm conference pages boston august 
john reynolds 
syntactic control interference 
fifth acm symposium principles programming languages pages tucson arizona 
john reynolds 
syntactic control interference part 
sixteenth international colloquium automata languages programming july 
amr sabry matthias felleisen 
reasoning programs continuation passing style 
lisp symbolic computation 
fred schneider 
enforceable security policies 
technical report tr cornell university january 
frederick smith david walker greg morrisett 
alias types 
technical report tr cornell university october 
mads tofte lars birkedal 
region inference algorithm 
transactions programming languages systems november 
appear 
mads tofte jean pierre talpin 
implementation typed call value calculus stack regions 
acm symposium principles programming languages pages portland oregon january 
mads tofte jean pierre talpin 
region memory management 
information computation 
philip wadler 
linear types change world 
broy jones editors programming concepts methods sea israel april 
north holland 
ifip tc working conference 
philip wadler 
taste linear logic 
mathematical foundations computer science volume lncs poland august 
springer verlag 
robert wahbe steven lucco thomas anderson susan graham 
efficient software fault isolation 
fourteenth acm symposium operating systems principles pages asheville december 
david walker 
type system expressive security policies 
seventh acm symposium principles programming languages january 
appear 
paul wilson 
uniprocessor garbage collection techniques 
yves jacques cohen editors international workshop memory management number lecture notes computer science pages st malo september 
springer verlag 
andrew wright matthias felleisen 
syntactic approach type soundness 
information computation 
wulf levin harbison 
hydra mmp experimental computer system 
mcgraw hill new york ny 
soundness capability calculus notation capability derived form expository purposes article 
equivalent 
sake simplicity proof operates new language include capabilities form 
syntax capabilities form new syntax unique capabilities 
way form duplicatable capability bar operator multiplicity annotations unnecessary 
rule eq flag derived rule 
abbreviation replaced definition clear rule simply special case reflexivity need system 
convenient continue abbreviation 
notational conventions alpha equivalent expressions considered identical 
memories memory regions memory types region types differ order fields considered identical 
expression denotes capture avoiding substitution updates finite maps denoted 
juxtaposition maps mn mn denotes update elements second 
notation excludes domain map abbreviate 
abbreviate 
abbreviate 
abbreviate cn cn 
notation denote fact appears syntax overview proof broken series lemmas proven induction typing derivations induction syntax language 
proof proof type soundness complete collection 
supporting lemmas grouped follows lemmas describe extensions type contexts exchanges elements type context permissible 
lemmas state constructors involved equality subtyping judgements wellformed free variables formed constructors bound type context 
definitions lemmas describe capabilities equal capabilities subtypes 
provide higher level abstraction rules equality subtyping frequently rest proof 
lemmas substitution lemmas types values respectively 
lemma states formed small values heap values declarations formed types 
lemmas canonical forms lemmas 
type lemmas describe shape memory values 
lemmas describe conditions add labels regions memory type preserve typing 
lemma states satisfiability preserved equality subtyping empty context 
lemma states satisfiability preserved region corresponding unique capability removed memory current capability 
lemmas preservation progress lemmas respectively 
directly proof type soundness 
lemma dom dom 
proof induction derivation 
lemma type context exchange dom dom 

proof induction derivations 
rule type var know domains disjoint 
consequently 
lemma type context extension 
dom dom 


proof induction derivation 
cases follow directly inductive hypothesis 
rules ctxt sub type arrow require type context exchange 
part rules type var type sub part congruence rules type variables part rule sub var follow disjoint domains dom dom 
lemma ftv dom 
proof induction derivation 
lemma equality regularity 
proof induction derivation 
lemma subtyping regularity 
proof induction derivation 
rule sub var show induction derivation cap 
definition atomic element atomic element kind cap capability barred capability 
meta variable ranges atomic elements 
definition set elements appear xn notation set elements xn lemma equality cap 
cap atomic capabilities 
ai ai ai ai ai ai cap 
cap permutation 

cap subsequence duplicate barred elements removed 

cap sets equal 

cap cap 

cap cap 
proof part follows induction derivation cap 
immediate 
case type single follows application equality rules eq symm eq 
case type plus intricate 
inductive hypothesis gives cap cap induction rules eq eq assoc eq trans equality congruence eq trans cap cap induction eq assoc eq symm eq trans case wehave cap ih 
congruence cap 
induction cap 
ai atomic element ai barred eq bar idem rule show ai ai cap 
case induction congruence rules done 
part follows induction eq assoc eq comm transitivity symmetry equality 
part corollary part 
part follows induction number barred duplicates uses part transitivity symmetry eq dup rules 
part follows induction equality judgement 
part may proven follows cap parts 
cap parts 
parts congruence equality aj cap cap jm aji ji contain duplicates ordered canonical ordering 
aji order 
constructors ji syntactically equal definitionally equal 
part follows induction typing derivation 
definition unique duplicatable capabilities capability unique exist capability duplicatable cap lemma cap duplicatable cap 
proof induction typing derivation 
lemma cap unique cap 
proof induction typing derivation 
lemma capability equality cardinality preservation cap cap 
unique duplicatable iff unique duplicatable 

number unique occurences 
proof induction derivation 
lemma capability subtyping cardinality preservation cap 
region names iff 

region names unique unique 
proof induction derivation capability equality cardinality preservation 
note subtyping regularity lemma type variables appear consequently rule sub var appears derivation 
lemma type substitution bn 
bi ci 
bi ci ci ci cap 









proof induction derivations 
cases follow directly ih 
part prove lemma rules cap case result type context extension 
second case assume ci ci cap 
subtyping regularity tells ci cap 
type context extension ci cap 
part rule cap result follows type context extension 
part case apply induction hypothesis inspection rules declarations show general lemma value substitution xn vi 
vn xn 
vn xn 
vn xn 
vn xn proof induction typing derivations 
part case induction hypothesis inspection typing rules declarations reveals general lemma term judgement regularity cap rgn 
type 
type 
cap proof induction typing derivations 
cases follow directly induction hypothesis equality regularity subtyping regularity 
part consider case type application atr induction hypothesis inspection typing rules arrow types deduce judgement form cap type atr type type substitution may deduce second type application rule follows similarly 
lemma canonical memory forms rn dom 
ri vm vj 
ri fix xn xn proof inspection typing judgements memory regions heap values 
lemma canonical memory forms ii 



proof induction typing derivations 
lemma canonical forms 
int 
handle handle 

cm fix xn bm ci ci ci ci cap 
cm cm cm type xn 

vn vi 
proof part follow inspection typing rules word values 
part follows induction derivation canonical memory forms inspection typing rules word values type application rules case trivial 
case trivial 
canonical memory forms trivial 
trivial 
inspection judgement 
case ca cb atr ca cap cb term judgement regularity lemma 
inductive hypothesis follows cn fix xn bm ci ci ci ci cap 
ca cm ca cb cm ca cm type ca ca xn 
cn 
result follows trivially 
assume 
ih 
ih typing judgement states ca cap 
ih type substitution 
ih 
case similar 
part follows inspection typing rules word values 
notice rule rule tuples apply 
assuming trivial immediate follow canonical memory forms 
lemma memory type gc 




proof induction typing derivation 
cases follow directly ih rule case trivial assume canonical memory forms 
type 
type context extension type 
cases rules dom 
lemma memory type extension appear orr 




proof induction typing derivation 
part rule type assumption result holds similarly analogous rule arrow types 
lemma region type extension dom dom 





sat sat proof induction typing derivation 
lemma cap cap cap subset 
proof lemma cap 
lemma 
ai unique duplicatable ai unique duplicatable 
lemma capability satisfiability preservation 
sat cap sat 

sat cap sat 
proof 
symmetry transitivity equality inspection sat derivation 

induction subtyping derivation 
case equality part 
case transitivity ih 
case apply context empty lemma capabilities contain free variables 
case 
assume sat 
cap 
case 
rule eq congruence bar cap 
constructor equality rules cap 
sat 
assume sat 
cap 

equality regularity formed empty context 

lemma cap 


conclude 
lemma eliminate duplicates assume loss generality contain duplicates form 

assume anticipating contradiction appear 
appear 
appear 
contradict indicating assumption false 
may assume loss generality 
conclude sat domain restricted 
analogous reasoning definitions yields sat 
inductive hypothesis sat 
inductive hypothesis sat 
inspection sat judgement know cap know cap 

consequently similarly 

conversely 
summarize state region names exact cover 
reasoning analogously steps deduce contains duplicate region names aside multiplicity flag 

rule eq congruence plus cap 
lemma may eliminate duplicate region names flag right hand side equation 

lemma reorder elements right hand side exactly giving 
consequently sat lemma sat sat 
proof cap 
assume sat 

know cap 

appears 

equality cap 
transitivity equality equality cap 
sat lemma preservation proof proof proceeds cases structure case show form typing judgement inferred inspection typing rules refer case typing judgement 
give transition specified operational semantics 
facts derive result 
sat 

typing judgement value substitution sat handle handle dom dom 
inspection heap value typing rules typing judgement 
typing judgement inspection memory typing rule 

sat region type extension 

typing rules word values 
value substitution 

iv iv sat iv iv vn iv vi 
typing judgement 

sat typing judgement 

vi canonical forms typing judgement 
vi value substitution typing judgement 
vi 
freergn sat handle freergn freergn handle freergn 


memory type gc typing judgement 

sat typing judgement 
sat capability satisfiability preservation sat lemma 
typing judgement memory type gc 

newrgn cap 
sat operational rule newrgn newrgn newrgn rgn handle rgn handle newrgn handle follows 

memory type extension typing judgement 

assumption operational semantics satisfy side condition sat judgement 
prove cap congruence rule equality 
consequently sat 

handle typing judgement application type value substitution memory type extension lemmas 
handle 
int sat ifi 
typing judgement 
vn vi cap cap sat vn vn vn cm fix bm xn bi bi ci cm vn xn 
typing judgement 

sat capability satisfiability preservation 

sat capability satisfiability preservation typing judgement dom 
typing judgement bm xn canonical forms 
cm cap transitivity equality canonical forms type value substitution 
lemma progress 
exists 
halt int 
proof proof proceeds cases structure heavy canonical forms lemma 
trivial 
handle sat handle directly typing judgement 
term judgement regularity lemma canonical forms handle 
capability satisfiability preservation sat dom 
inspection memory typing rules dom 

iv sat iv iv iv capability satisfiability preservation sat 
dom canonical forms vn 
iv vi 
newrgn trivial 
freergn typing judgement 
sat handle cap freergn freergn term judgement regularity lemma canonical forms handle 
capability satisfiability preservation sat 
dom inspection memory typing rules dom 
consequently 
int canonical forms integer 
operational rules applies 
vn vi cap atr cap sat vn vn subtyping regularity lemma 
capability satisfiability preservation sat dom 
canonical forms cm fix bm xn bi bi ci 
cm vn xn vn halt int cap sat halt halt part holds inspection typing judgement 
definition stuck state machine state stuck halt exist 
theorem type soundness stuck 
proof induction number steps taken operational semantics preservation 
progress typed state halt 
theorem complete collection halt 
proof assume 
preservation progress halt int cap sat halt halt sat judgement dom 
consequently 
inspection judgement memory types 
region translation type preservation section prove translation region calculus capability calculus type preserving 
words formed source language term result translation formed capability calculus term 
section describes syntax static semantics term constructs 
notation proof abbreviations conventions 
equality subtyping judgements capabilities written form transitivity rules link equations 
associativity commutativity rules mentioning substitute subcomponent capability equal capability mentioning congruence rules 
notation indicate types formed type context 
formally type dom overview theorem borrows lemmas proof soundness including lemmas manipulating capabilities lemma asserting formedness lemma 
require number lemmas lemmas describe additional formedness constraints types effects appear region calculus judgements 
lemmas state formedness constructors constructor equality substitution preserved translation 
lemma describes way subset relation preserved translation effects sets capabilities sets 
lemma lemmas proof 
lemma miscellaneous lemma required proof letregion construct 
lemma gives conditions static application continuation closure arguments formed 
lemma 


eff eff proof induction derivations 
lemma type eff proof induction derivation 
lemma formedness preservation 

proof induction derivations 
lemma equality preservation 
eff cap 
eff cap proof induction equality derivations 
lemma substitution preservation type 
proof induction typing derivation 
lemma eff 
proof induction derivation 
lemma 
proof inspection sub effecting rule eff effect lemma 
definition type translation 

lemma cap cap 
proof 
cap equality 

definition 

lemma 



definition 

equality cap 
lemma cap proof proof induction structure 

definition 
result follow immediately reflexivity equality 
similar 

reasoning provides result definition rule eq rule eq dup 
induction know 
reasoning provides result def 
eq dup eq dup rule eq comm 
lemma 
proof term defined derivation proves lemma lemma type proof proof induction typing derivation expressions 
theorem cps type preservation int halt fresh empty environment proof proof induction typing derivation expression inductive hypothesis andk proof abbreviations conventions order derivations focus important elements proof 
meta variable range type checking contexts form abbreviate derivations involving 
derivation abbreviated dn dn typing rules contain side condition capability calculus variable contained context judgement 
assumed variables translated term generated fresh case 
sake brevity mention side condition time occurs proof 
rules contain formedness constraints types capabilities 
formedness constraints follow directly source typing judgement lemma 
order concentrate important aspects proof mention conditions time appear derivation 
letrec type application value application letregion equality 
cases follow similar simpler pattern 

translation source typing derivation fix xcont cont 
xcont cont rgn cap handle xcont cont handle dom order derivations case manageable abbreviations handle handle handle handle showing continuation translation formed appropriate context call fact var xcont cont var xcont eq reflex derivation recall rgn cap sub var eq distrib shown 
rule sub var conclude expand abbreviation eq comm eq dup apply induction hypothesis obtain xcont apply induction hypothesis obtain handle build typing derivation code continuation translating call fact var handle derivation dr fix xcont dr handle assumption assumption lemma eq distrib apply induction hypothesis translation giving final result case type application 
translation cn cn source typing derivation cn ci cn show value cn formed context conclude rule var induction number constructors ci applied rule type conclude cn substitution lemma lemma cn cn cn fact assumption lemma obtain final result case application 
translation cn newrgn fcont fix fcont freergn fcont source typing derivation term re re showing result translation type correct showing body innermost continuation newrgn formed appropriate context 
order derivation manageable abbreviations rgn handle rgn handle fcont cont rgn handle rgn handle fcont cont fcont fcont fix fcont freergn app cont atr cont derivation follows app var var fcont cont dr fcont cont fcont dx dh fcont newrgn derivation proven follows 
rule var deduce rgn cap cont atr judgement applications rule type give cont atr rule sub conclude cont atr required sub capability relation holds rgn assumption assumption lemma rule sub bar consider derivation dr show rgn capability reasoning straightforward rgn rule eq comm assumption assumption lemma def 
translation rule eq distrib consider 
judgement prove 
follows rules sub eq eq reflex 
consider dx 
judgement prove handle 
judgement follows rule var 
prove dh var handle eq reflex rgn cap da judgement trying prove derivation da 
rule var conclude 
assumption tells lemma result 
show 
rgn capability fact follows rule sub dup 
satisfied requirements necessary show body innermost continuation formed letregion source typing derivation 
fulfill requirements induction hypothesis may conclude letregion fact source typing derivation apply induction hypothesis conclude equivalent result trying prove 

translation source typing derivation letregion newrgn rgn handle rgn handle letregion ftv dom dom show continuation translation formed appropriate context da var rgn handle handle rgn handle judgement prove da rgn handle rule var conclude rgn handle fact assumption lemma conclude 
judgement prove rgn follows rule eq reflex 
fulfilled requirements necessary show body innermost continuation formed call fact 
typing derivation 
order apply induction hypothesis show rgn assumption rule sub bar rule eq distrib rgn assumption lemma rule eq comm satisfy preconditions applying induction hypothesis 
result rgn handle rgn handle show result translation type checks newrgn rgn handle equality rule 
source typing derivation type continuation formed appropriate context lemma equality judgement type deduce lemma deduce 
recall assumption states type cap fact source typing derivation states lemma deduce cap andd apply induction hypothesis obtain done 
completed proof induction hypothesis preserved translation 
order obtain proof cps translation theorem simply instantiate induction hypothesis 
part int 
continuation halt halt rule part part trivial 
part straightforward int int cap int halt rule sub eq rule eq dup definition conclude empty translation environment trivial continuation halt 
