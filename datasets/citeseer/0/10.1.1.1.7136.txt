generalizing database access methods ming zhou thesis university waterloo fulfilment thesis requirement degree master mathematics computer science waterloo ontario canada zhou declare am sole author thesis 
authorize university waterloo lend thesis institutions individuals purpose scholarly research 
authorize university waterloo reproduce thesis photocopying means total part request institutions individuals purpose scholarly research 
ii university waterloo requires signatures persons photocopying thesis 
please sign give address date 
iii efficient implementation access methods crucial database systems 
today database systems increasingly employed support new applications involving multi dimensional data 
large variety specialized access methods developed solve specific problems 
specialized access methods usually hand coded scratch 
effort required implement maintain data structures high 
alternative developing new data structures scratch researchers tried simplify search tree technology generalization 
thesis generalizes access methods multiple levels starting hierarchical search tree access methods 
basic logic commonalities different database search trees explored 
generalized search tree built generalized class library created including small set specialized components 
specific search trees built significantly faster traditional approach generalized model selecting components library 
attempts start taxonomy secondary memory data structures classify functionality reuse implementation 
similar taxonomy provided leda stl primary memory data structures 
example tree file structures developed performance experiments file structures demonstrate feasibility generalization approach achieve efficient implementation search tree access methods 
iv supervisor dr peter buhr valuable guidance encouragement mentoring patience hard study thesis 
sense humor enjoyable 
extend gratitude dr nishimura dr frank tompa carefully read final draft thesis gave valuable suggestions 
anil goel providing information database time attend meetings give suggestions 
furthermore friends lab mates oliver schuster zak tom help 
working programming language lab pleasant enjoyable 
extend curtis friends liu friends waterloo 
husband zhang parents tremendous encouragement unfailing support studies 
contents problem 
solution 
implementation 
overview 
related specialized database search trees 
dimensional access methods 
point access methods 
spatial access methods 
search trees extensible data types 
gist 
summary 
generalizing techniques database language abstraction mechanism 
vi inheritance 
polymorphism template 
inheritance vs containment 
database 
database storage 
summary 
generalizing persistent search trees generalization search trees 
search trees search keys 
tree functionality 
structure 
tree behavior 
generator 
index 
nested storage management 
hierarchy persistent search tree classes 
ptree 
gtree 
stree 
tree class library 
key 
node key 
node key data 
vii container node 
data 
storage management 
gist key node container 
tree generators 
summary 
example file structures experiments tree example 
tree example 
tree example 
experiments 
trees 
trees tree 
summary 

bibliography viii list figures tree node search values 
tree separate index key parts 
tree node 
example tree 
holey brick represented tree 
example hb tree 
rectangles organized tree 
rectangles organized tree 
multiple segments file structure 
accessing multiple file structures 
sketch database search tree 
typical structure leaf node 
simple tree 
pairing key pointer tree 
simple tree 
ix structures array list container 
different indices 
nested storage managers 
definition 
definition 
gtree definition 
definition 
definition 
tree definition 
components generalization library 
array node example 
list node example 
array node data 
list node data 
array container example 
list container example 
gtree generator 
btree range generator example 
list tables experiment results exact matching queries trees 
experiment results multi response queries trees 
experiment results trees tree 
xi chapter efficient data access properties provided database management system 
common mechanism achieve goal associate index large randomly accessed data file secondary storage 
index auxiliary data structure intended help speed retrieval records response certain search conditions 
index labels folders filing cabinet speeds retrieval directing searcher small part file containing desired item 
disk files index allows number disk accesses reduced 
index may physically integrated file labels employee folders physically separate labels 
usually index file 
index file large index may built top speed retrieval 
organization techniques data structures index files called access methods 
techniques organizing database access methods proposed 
common dimensional structures include hashing variants linear hashing lit lar extendible hashing tree bm variants com 
chapter 
hierarchical access methods tree scalable behave case skewed input nearly independent distribution input data 
property necessarily true hashing techniques performance may degenerate depending input data 
problem aggravated order preserving hash functions try preserve neighborhood relationships data items order support range queries 
result highly skewed data causes accumulation selected locations hash table 
data hand hashing techniques usually outperform hierarchical methods average 
traditional relational systems dimensional access methods tree extendible hashing sufficient sorts queries posed usual set alphanumeric data types 
suitable indexing multi dimensional data 
query find employees years old earn salary example dimensional range query 
way answering query maintaining dimensional indexes age salary indexes narrow set relevant employee records 
way maintain composite index age salary 
solutions efficient specialized structures required handle multi dimensional range queries 
today database systems increasingly employed support new applications geographic information systems multimedia systems cad tools document libraries dna sequence databases fingerprint identification systems biochemical databases 
data management applications rely heavily multi dimensional data 
example geographic information system points lines line groups polygons basic data types 
retrieval update spatial data usually value certain alphanumeric attributes chapter 
spatial location data object 
retrieval query spatial database requires fast execution geometric search operation point query find objects contain search point region query find objects overlap search region 
support search operations special multi dimensional access methods needed 
volker gaede oliver gunther gg list requirements multi dimensional access methods meet properties spatial data applications 
requirements applicable dimensional access methods 
dynamics 
data objects inserted deleted database order access methods continuously keep track changes 
secondary tertiary storage management 
despite growing main memories impossible hold complete database main memory 
access methods need integrate secondary tertiary storage seamless manner 
broad range supported operations 
access methods support just particular type operation retrieval expense tasks deletion 
independence input data insertion order 
access methods maintain efficiency input data highly skewed 
point especially important data distributed differently various dimensions 
related point average storage utilization 
simplicity 
intricate access methods special cases error prone implement sufficiently robust 
scalability 
access methods adapt growth underlying database 
chapter 
time efficiency 
spatial searches usually cpu intensive access method try minimize cpu utilization number disk accesses 
space efficiency 
index small size compared data addressed guarantee certain storage utilization 
problem large variety specialized access methods developed solve specific problems 
hierarchical approach tree bm tree knu tree srf lsd tree hb tree ls ls tree gut tree ssh srf cell tree gun gun tree os hashing techniques grid file nhs bang file fre file hashing heuristic solutions space filling curves om 
significant impact particular domains approach developing domainspecific access methods problematic 
specialized access methods usually hand coded scratch normally requiring substantial knowledge underlying file system build correctly efficiently 
result effort required implement maintain data structures high 
furthermore reason assume trend continue 
new database applications need supported new access methods developed deal efficiently 
chapter 
solution alternative developing new data structures scratch stonebraker sto proposed generalize existing data structures trees trees support user defined data types revising procedures access methods new data types 
hellerstein proposed way generalize search trees tree functionality level introducing generalized search tree called gist :10.1.1.144.2507
gist provides abstraction common tree operations search insertion deletion 
tree structures trees built extensions gist 
add generalization covering alternatives internal structure tree node aspects search tree design 
thesis intends generalize access methods starting database search trees 
generalizing parts search tree developers possibly need specialize developer required write components scratch new search trees built easily 
discovering core reusable components search trees number different dimensions generalized search tree built different search trees developed generalized components significantly faster working scratch 
generalization done advantage reuse capabilities modern programming languages inheritance generic programming example deriving new object implementation existing object possible take advantage previously written tested code substantially reduce time compose debug new object increase robustness 
goal parallels primary memory data structure libraries standard template library sl leda data structures 
libraries attempt provide taxonomy primary memory data structures chapter 
classify functionality reuse implementation 
attempts start similar taxonomy access methods manipulating data secondary storage 
difference performance capability secondary storage primary storage requires separate solution 
thesis intend construct new access methods engineering exercise combining number known ideas way provides new interesting solution important problem 
implementation generalization resulting taxonomy largely system independent 
goal demonstrate partial implementation 
system chosen implementation database 
database toolkit constructing memory mapped databases bgw 
generalization approach apply equally traditional non memory mapped environments 
overview chapter overview related 
categories specialized search trees basic properties discussed 
generalization attempts search trees 
chapter gives background design implementation new generalization search trees 
generalizing techniques provided introduced 
search tree generalization depends language abstraction facilities 
second background database database view storage discussed 
chapter discusses multiple levels generalization detail 
hierarchy persistent tree classes components generalization library 
chapter 
chapter gives example search tree structures developed generalized tree shows experimental results measurement cost generalization 
chapter suggests 
chapter related understand generalize search tree access methods necessary understand various access methods sufficiently find common aspects 
chapter reviews database search trees identifies points commonality looks prior attempts generalize search trees 
specialized database search trees large variety search trees developed solve specific problems 
viewed categories dimensional search trees point search trees spatial search trees 
basic structure representative search trees category discussed subsections 
dimensional access methods classical dimensional access methods important foundation design multidimensional access methods 
hierarchical access methods tree variants chapter 
related efficient data structures indexing dimensional data 
tree tree bm balanced tree corresponding nesting intervals 
node corresponds disk page interval 
interior node intervals corresponding immediate descendants mutually disjoint subsets 
shows example node tree gamma search values 
leaf nodes contain pointers data items depending type tree interior nodes may 
data pointer tree pointer tree pointer tree pointer data pointer data pointer data pointer gamma gamma kn gamma pn kn gamma tree node search values formally tree access method key field search records data file defined follows order tree interior node shown tree pointer pointer node tree 
key data pointer pointer record search key field value equal 
node keys ordered delta delta delta gamma 
search key field values subtree pointed gamma gamma 
node tree pointers 
chapter 
related node root leaf nodes tree pointers 
node full 
root node tree pointers node tree 
leaf nodes level 
leaf nodes structure internal nodes tree pointers 
tree knuth knu defines tree tree node full just full 
tree insertion uses local redistribution scheme delay splitting sibling nodes full 
nodes divided full 
scheme guarantees storage utilization requiring moderate adjustment maintenance algorithms 
increasing storage utilization speed search height resulting tree smaller 
tree tree proposed comer com keys reside leaves 
upper levels organized tree consist index road map enable rapid location index leaves 
shows logical separation index leaves allows interior nodes called index nodes leaf nodes called data nodes different formats different sizes 
particular leaf nodes usually linked left right shown 
linked list leaves referred sequence set 
sequence set links allow easy sequential processing 
chapter 
related random search sequential search sequence set keys index tree separate index key parts 
insertion search operations tree processed way similar insertion search operations tree 
leaf splits promoting middle key algorithm promotes copy key retaining actual key right left leaf 
resulting node structure shown different tree 
search operations differ tree searching key index equals query value 
nearest right left pointer followed search proceeds way leaf 
tree pointer tree pointer tree pointer gamma kn gamma pn gamma kn gamma tree node deletion tree ability leave non key values index part separators simplifies operation 
key deleted reside leaf removal simple 
long leaf remains half full index need changed copy deleted key propagated 
chapter 
related point access methods point defined element domain theta domain theta delta delta delta theta domain rectilinear region defined set points delta delta delta satisfying min max collection min max domain points represented simply storing regions storing min max 
point access methods pams designed primarily perform spatial searches point databases 
points may dimensions spatial extension 
usually points database organized number buckets corresponds disk page subspace universe 
subspaces referred bucket regions simply regions dimension may greater need rectilinear 
tree pams usually generalization tree higher dimensions 
leaf node tree contains points located corresponding bucket region 
index nodes tree guide search typically corresponds larger subspace universe contains bucket regions subtree 
search operation performed top tree traversal 
differences pam tree structures mainly characteristics regions 
pams regions tree level form partitioning universe mutually disjoint union complete space 
examples tree point access methods trees rob lsd trees hb trees ls ls 
tree hb tree introduced representatives category 
chapter 
related tree tree rob combines properties adaptive tree ben tree com handle multidimensional points 
tree tree consists collection nodes 
types nodes 
region nodes region nodes contain collection region child pairs child pointer node 

point nodes point nodes contain collection point location pairs location gives location database record 
tree structure satisfy properties 
algorithm range queries depends properties algorithms insertions deletions designed preserve properties 
region node contains null pointer region page empty point nodes leaves tree 
leaf nodes level root depth 
region node regions node disjoint union region 
root node region node union regions universe 
region child occurs region node child points region node union regions child node region 
region child occurs region node child points point node points point node region node chapter 
related tree perfectly balanced tree adapts distribution data 
trees tree minimum space utilization requirement 
illustrates example tree points represent central points spatial objects 
example tree insert new data point point search performed locate correct bucket 
point node full entry inserted 
split half entries shifted new point node 
order find split various heuristics available rob 
parent region node space left accommodate new entries new region node allocated region node split hyperplane 
entries distributed nodes depending position relative splitting hyperplane split propagated tree 
split index node may affect regions lower levels tree split hyperplane 
forced split effect chapter 
related impossible guarantee minimum storage utilization 
deletion straightforward 
performing exact match query entry removed 
number entries drops threshold point node may merged sibling point node long union remains dimensional interval 
hb tree hb tree ls relative tree 
distinguishing features hb trees index nodes organized trees 
hb trees nodes represent regions smaller regions removed 
regions called holey bricks hb tree called holey brick tree 
index node represents holey brick refers smaller holey bricks lower level index 
dtree ben organize internal structure index nodes hb tree 
tree binary search tree represents recursive subdivision universe subspaces means gamma dimensional hyperplanes 
illustrates holey brick represented tree 
region divided parts left right 
right part subdivided regions part holey brick represented tree shows hb tree root node containing pointers child region union rectangles left 
remaining chapter 
related space excluded explicit entry ext tree representing region ext example hb tree spatial access methods spatial access methods applicable databases containing objects spatial extension 
typical examples include geographic databases containing polygons mechanical cad data consisting dimensional polyhedra 
order handle extended objects point access methods modified techniques sk ffl transformation object mapping basic idea transformation schemes represent minimal bounding rectangles multidimensional spatial objects higher dimensional points 
ffl overlapping regions object bounding key idea overlapping regions technique allow different data buckets access method correspond mutually overlapping subspaces 
known example tree guttman greene 
chapter 
related ffl clipping object duplication clipping schemes allow overlaps bucket regions mutually disjoint 
typical example tree ssh srf variant tree allows overlap regions corresponding nodes tree level 
tree tree gut height balanced tree similar tree index records leaf nodes 
nodes correspond disk pages structure designed spatial search requires visiting small number nodes 
spatial database consists collection tuples representing spatial objects tuple unique identifier retrieve 
leaf nodes tree contain entries form tuple identifier tuple identifier refers tuple database dimensional rectangle bounding box spatial object indexed delta delta delta gamma number dimensions closed bounded interval describing extent object dimension non leaf nodes contain entries form child pointer child pointer address lower node tree covers rectangles lower node entries 
shows rectangles organized tree 
tree satisfies properties node root contains min max entries min max 
leaf entry key smallest rectangle called minimum bounding box spatially contains dimensional data object represented indicated tuple 
chapter 
related rectangles organized tree non leaf entry key smallest rectangle spatially contains rectangles child node 
example actual scope dimension rectangle labeled extends minimum value maximum value 
root node children leaf 
leaves appear level 
search algorithm descends tree root manner similar tree 
subtree visited node may need searched bounding boxes tree level may overlap 
point queries may intervals intersect search point 
insert new object minimum bounding box object inserted tree 
contrast searching single path root leaf traversed 
level child node chosen corresponding bounding box needs enlargement enclose data object bounding box 
intervals satisfy criterion descendant chosen random 
guarantees object inserted object dispersed buckets 
leaf level reached object ready inserted 
chapter 
related requires enlargement corresponding bucket region adjustment done appropriately change propagated upwards 
space left leaf leaf split entries distributed old new page 
new bounding box needs adjusted accordingly split propagated tree 
similarly deletion exact match query performed object deleted 
object deleted 
deletion causes underflow check performed bounding box reduced size 
adjustment change propagated upwards 
hand deletion causes node capacity drop node contents copied temporary node original node removed tree 
bounding boxes adjusted 
orphaned entries temporary node reinserted tree 
original guttman guttman discussed various policies minimize overlap insertion 
node splitting example guttman suggests algorithms including simpler linear time complexity elaborate quadratic complexity 
sophisticated policies seen packed tree rl sphere tree oo hilbert tree kf 
tree overcome problems associated overlapping regions sellis introduced close relative tree called tree srf 
tree uses clipping overlap index intervals tree level 
shows rectangles grouped tree 
objects intersect index interval stored different pages rectangle 
result chapter 
related policy point searches tree correspond single path tree traversals root leaves 
tend faster corresponding tree operation 
important difference node splitting splits may propagate tree tree 
resulting forced split nodes may lead complications including fragmentation data intervals 
rectangles organized tree tree tree variant tree 
careful study tree behaviour different data distributions beckmann bkss identified weaknesses original algorithms 
particular insertion phase claimed critical search performance 
design tree introduces policy called forced reinsert node overflows split right away 
maximal number entries removed node reinserted tree 
addition solve problem choosing appropriate insertion path tree takes area parameter consideration tests parameters area margin overlap different combinations 
tree differs tree mainly insertion algorithms deletion searching essentially unchanged 
chapter 
related search trees extensible data types developing new access methods new data types example polygons stonebraker sto proposes existing data structures trees trees extensible data types support 
general access method collection procedures retrieve update records 
generic abstraction access method open file name returns descriptor file representing relation close descriptor terminates access get descriptor opr value returns record key satisfying key opr value get descriptor opr value returns record insert descriptor value insert record indicated relation delete descriptor value delete record indicated relation search descriptor value search indicated record update descriptor value new value replace indicated record new basic idea approach replace procedures operate different data type allow access method new type 
example consider tree generic query select 

key opr value opr 
tree includes appropriate procedures support operators data type 
example search record matching specific key value need descend chapter 
related tree level searching minimum key value exceeds equals indicated key 
calls operator required final call calls operator 
comparison operators overloaded user defined types 
procedures implementing operators replaced collection procedures overloaded operators tree works correctly 
example stonebraker shows operators box data type added tree 
ae box areas equal box area box area ag box area greater box area 
approach provides generalization data indexed 
example trees index data linear ordering 
generalization simple limited 
regardless type data stored tree queries benefit tree containing equality linear range predicates 
similar tree queries tree containing equality overlap containment predicates 
unified view different search trees achieved approach 
gist hellerstein introduce index structure called generalized search tree gist generalized form tree gut :10.1.1.144.2507
gist allows new data types indexed supports extensible set queries 
addition authors claim gist unifies previously disparate structures currently common data types 
example trees trees implemented extensions gist 
detail gist balanced tree structure tree nodes containing ptr pairs predicate search key ptr identifier tuple database chapter 
related leaf node pointer tree node non leaf node 
gist properties node contains min max index entries root 
index entry ptr leaf node true instantiated values indicated tuple holds tuple 
index entry ptr non leaf node true instantiated values tuple reachable ptr 
root children leaf 
leaves appear level 
principle keys gist may arbitrary predicates hold datum key 
practice keys come user defined object class provides particular set methods required gist 
adapt gist different uses users required register set methods ffl consistent entry ptr query predicate returns false guaranteed unsatisfiable true 
ffl union set entries ptr 
ptr returns predicate holds tuples stored ptr ptr ffl compress entry ptr returns entry pp ptr pp compressed representation chapter 
related ffl decompress compressed representation pp ptr returns entry ptr decompressed representation pp 
ffl penalty entries ptr ptr returns domainspecific penalty inserting subtree rooted aid splitting process insertion operation 
ffl set entries ptr splits sets entries size km minimum fill factor 
tree methods gist provide algorithms search insertion deletion operations ffl search algorithm search dataset query predicate traversing tree necessary satisfy query 
approach general search technique analogous tree 
efficient situations example linear ordered domain tree 
gist provides set methods perform search operation domain indexed linear ordering queries typically equality range containment predicates 
general search algorithm depends user specified consistent method check predicate satisfiable 
consistent method applies index node leaf node 
usually satisfiable conditions different index node leaf node matter exact matching search range window query 
checking needed leaf entries fetched algorithm 
restriction type query conducted program function consistent search pointer function 
chapter 
related ffl insertion routine guarantees gist remains balanced 
similar insertion routine trees generalizes simpler insertion routine trees 
user defined key method penalty choosing subtree insert method node splitting algorithm method union propagating changes upward maintain tree properties 
ffl deletion algorithm attempts keep keys specific possible maintain balance tree 
underflow uses tree borrow coalesce technique linear order uses tree reinsertion technique 
hellerstein describe implementations key classes gist behave tree tree rd tree new tree index set valued data :10.1.1.144.2507
gist key class tree pair integers integer value traditional tree 
pair represents interval contained key particularly key represents predicate contains variable space keys compress method applied key placed node decompression method key read node 
penalty method choose appropriate subtree insertion penalty ptr ptr leftmost pointer node return max rightmost pointer node return max return max max penalty calculated entry node entry minimum penalty chosen 
keys tree order comparisons find correct range needed 
chapter 
related penalty method unnecessary tree 
gist attempts generalize tree access methods approach skewed spatial access methods 
result simpler access methods require complex implementations expected complexity cost implementations questionable 
summary large variety domain specific search trees developed 
representative structures properties category dimensional point spatial detail background material design generalization search trees 
search trees points commonality structure indices structure index data kinds number location keys 
operations search trees strong common point 
attempts extending search tree technology generalization discussed 
approaches provide ideas thesis 
chapter generalizing techniques database reuse facilities design implementation generalized persistent search tree discussed chapter followed system chosen implementation database facilities database managing storage 
language abstraction mechanism inheritance polymorphism capabilities applied commonalities different search tree file structures provide generalized structure easily adapted specific tree access method 
inheritance inheritance form software reusability new classes created existing classes absorbing attributes behaviours capabilities new classes require 
polymorphism enables write programs chapter 
generalizing techniques database general fashion process wide variety existing specified related classes 
dd inheritance provides powerful way representing hierarchical relationships classes expressing commonality classes 
base class specifies common properties derived classes inherit properties base add data members member functions 
example concepts faculty member staff member related university employees concept employee common 
base class employee capture common information employees name age salary 
class faculty class staff include information inheriting class employee add specific information faculty member staff member respectively class employee public int age common information employees char name float salary 
class faculty public employee public char research area additional information faculty members 
class staff public employee public char position additional information staff members 
strength inheritance comes abilities commonality base class define derived class additions replacements refinements features inherited base class 
derived class base class set related classes forms class chapter 
generalizing techniques database hierarchy 
inheritance contains concepts implementation type sharing 
implementation inheritance allows object reuse existing declarations code build object type inheritance means objects derived type behave just objects base type 
supports concepts deriving class base class base class may inherited public protected private class derived public base 
class derived protected base 
class derived private base 
public inheritance provides implementation type sharing 
public read derived subtype 
notion common form derivation 
protected private inheritance represent implementation details reflected type derived class 
protected private read derived implements 
protected inheritance useful class hierarchies derivation norm 
private inheritance defining class restricting interface base stronger guarantees provided str 
provides direct mechanism inherit just type implementation accomplished indirectly empty base class called class 
polymorphism template polymorphism allows algorithm expressed applied variety types 
provides mechanisms accomplish virtual functions provide run time polymorphism templates offer compile time polymorphism 
virtual functions objects different classes related inheritance respond differently chapter 
generalizing techniques database member function call depending type object 
example earnings function call applies generically employees 
way person earnings calculated depends type employee hourly paid employee 
earnings function declared virtual base class employee appropriate implementations earnings provided derived classes class employee class public virtual float earnings pure virtual class public employee private float public virtual float earnings return methods class public employee private float float hours public virtual float earnings return hours templates provide direct support generic programming programming types parameters 
template mechanism allows type parameter definition function class 
template depends properties uses parameter types require different types arguments explicitly related 
particular argument types template need inheritance hierarchy 
code implementing templates identical parameter types 
mentioned functions classes generalized templates 
template function declares single formal parameter type variables compared type return value chapter 
generalizing techniques database template max return compare variables type integers floating point numbers user defined types define operator 
argument types provided calls function automatically generates separate object code functions handle type call appropriately 
function templates provide compact solution macros enable full type checking 
example template stack class template class stack elems int size public stack void push elems size size pop size return elems size basis template stack class stack classes created stack stack float stack intstack stack int stack stack stack int generic programming templates serve need policy parameterization 
consider sorting array elements 
element structure struct char firstname char lastname int age employee concepts involved element type container holding elements array criteria sort algorithm comparing array elements 
sorting criteria hard coded part container container general impose needs element type 
sorting criteria hard coded part element type chapter 
generalizing techniques database different ways sorting elements 
consequently sorting criteria built container element type supplied specific need basis 
example sort array structures employee defined criteria comparison depends different needs 
employees sorted lastname firstname age 
general element type general sort algorithm know conventions sorting array 
general solution requires sorting algorithm expressed general terms defined just specific type specific specific type 
example template parameter class sorting function represents possible comparison criteria template void sort const int 
eq 
lt 
different criteria sort achieved defining suitable eq lt routines 
technique allows sorting algorithms described terms operations supplied operations 
different element comparison pairs needed different kinds comparison 
example name comparison complex age comparison requiring different comparison templates template class cmp public static bool eq 
compare lastname firstname static bool lt 
compare lastname firstname chapter 
generalizing techniques database template class cmp public static bool eq 
compare age static bool lt 
compare age rules comparison chosen explicit specification template arguments void employee int size sort size sort name sort size sort age passing comparison operations template parameter significant benefits compared alternatives passing pointers functions 
operations passed single argument run time cost str 
technique supplying policy template argument widely standard library 
inheritance vs containment examine design choices involving template inheritance necessary look difference inheritance containment 
class derived class said class 
class public 
kind means inheritance relationship 
hand class member class said contain class contains means containment relationship 
classes choose inheritance containment depends kind relationship necessary classes 
example relationship car engine containment chapter 
generalizing techniques database inheritance 
car engine engine 
general inheritance provide relationship template relationship 
database database programmer faced problem dealing different views structured data transient data persistent data 
transient data primary storage ceases exist creating process terminates persistent data stored secondary storage outlives programs create manipulate 
traditional programming languages provide facilities manipulation transient data 
data required persistent explicit file system database management system needed 
data structures primary storage usually organized pointers directly processor instructions 
generally impossible store retrieve data structures containing pointers disk converting pointers worst entire data structure different format 
atkinson abc claim typical programs devote significant amounts code transferring data file system dbms result 
significant time space taken code perform translations structured data primary storage data stored secondary storage especially complex data structures 
powerful flexible data structuring capabilities modern programming languages directly available building data structures secondary storage 
database toolkit provides uniform view data primary secondary storage methodology efficiently constructing low level database tools access methods 
uniform view data gives illusion data secondary storage accessible chapter 
generalizing techniques database way data primary storage need complex expensive conversions structured data primary secondary storage eliminated 
software provided database allows normal programming pointers stored directly secondary storage subsequently retrieved manipulated programs having modify pointers code manipulates 
file structures database tree built database significantly simpler build test maintain traditional file structures 
access file structures statically type safe 
addition multiple file structures may simultaneously accessible application 
database allows generalization facilities templates inheritance overloading applied directly project 
database storage database memory divided major levels storage management goe see address space set addresses refer bytes words memory 
memory conceptually contiguous address space user perspective implemented non contiguous pages 
address space supported hardware managed operating system 
segment contiguous portion memory 
may correspondence address space segment address space may subdivided multiple segments 
database segment group segments mapped portion secondary storage 
segment supported hardware managed address space chapter 
generalizing techniques database storage manager 
heap contiguous portion segment internal management independent storage management heaps segment heaps particular storage level interact 
heap supported hardware managed containing segment storage manager 
heap file disk segment segment segment heap heap heap heap map file disk map segment base address space address multiple segments file structure difference segment heap segments provide units mapping primary storage secondary storage 
major differences heap area provided language runtime system dynamically allocating variables area new allocates storage heap associated database segment 
heap space allocated come heap 
multiple heaps time particular heap specified time memory management request occurs 
chapter 
generalizing techniques database 
language heap general purpose storage area 
hand segment heap dedicated particular data structure tree 
opportunity optimizing storage management scheme contained data structure 
addition data structures require special actions taken overflow underflow occur 
storage management facility able accommodate application specific actions cases 
database provides tools create manage destroy segments heaps address space 
furthermore flexible capabilities provided mapping different segments different disks 
example file structure partitioned list segments mapped single unix file separate unix files may reside different disks depicted 
drawback scheme size segment restricted 
section new scheme introduced file structure composed multiple segments allow segment grow separately 
possible application database multiple file structures accessible simultaneously file structure mapped private address space 
bgw shows memory organization application file structures simultaneously 
addresses address space segments reused segment active time 
shared memory communicate data address space segment addresses shared specific segment 
memory manager classes manage memory allocation deallocation segment heaps 
memory manager objects instantiated classes self contained units capable managing contiguous piece storage arbitrary size starting arbitrary chapter 
generalizing techniques database segment segment segment map map private shared private memory memory memory application process private memory file file map file accessing multiple file structures address 
segment managed memory manager object invoking member routines object implicitly performs desired operation segment heap 
storage management schemes provided database 
uniform fixed allocation size 
size specified creation memory manager object changed 
uniform memory management divide segment fixed sized heaps heap fixed sized nodes tree nodes 
variable variable allocation size 
size specified allocation basis allocated changed 
variable memory management general purpose scheme similar malloc free routines 
dynamic variable allocation size 
size specified allocation basis expanded contracted time long area remains allocated 
chapter 
generalizing techniques database property location allocated blocks guaranteed fixed 
allocation returns object descriptor absolute address 
allocated block absolute address accessed indirectly descriptor 
indirection possible perform compaction managed space garbage collection 
fragmentation dealt application independent manner 
summary chapter presents main forms reuse available inheritance templates 
inheritance defines class hierarchy establishing implementation type sharing 
templates define powerful macro facility constructing new types types 
implementation vehicle database introduced 
database unifies primary secondary storage memory mapping allowing normal primary memory capabilities secondary storage particular reuse capabilities 
database provides complex storage management facilities organize access method data distribute data appropriately secondary storage 
chapter generalizing persistent search trees chapter discusses design methodology achieve generalization multiple levels presents structure components generalized persistent search tree detail 
generalization search trees language abstraction mechanisms discussed section storage management mechanisms discussed section develop generalized search tree provides basis common tree access methods database systems 
commonalities different tree file structures explored achieve generalization multiple levels including search tree functionality behaviour structure index storage management 
search trees search keys generalization database search trees general notion search keys essential nature tree structures observed gist :10.1.1.144.2507
chapter 
generalizing persistent search trees database search tree balanced tree high fanout 
shows basic structure tree 
major components index leaf 
index leaf composed tree nodes usually fixed size usually page size 
tree node series entries empty space node full 
interior nodes called index nodes directory guide search tree 
leaf nodes called data nodes contain data entries pointers actual data 
leaves may connected linked list allow partial complete scanning 
shows typical structure leaf nodes 
key key leafs index sketch database search tree ki pi kq pq data pointer data pointer data pointer 
typical structure leaf node review tree access methods possible deduce tree nodes database search trees dimensional tree multi dimensional point spatial search trees satisfy common properties chapter 
generalizing persistent search trees index node contains min max entries root 
entry leaf node contains data object pointer data object key uniquely identifying object 
entry index node contains key pointer child node 
root children leaf 
leaves appear level 
different search trees solve specific problems different domains different structures keys properties 
leaf keys uniquely identify data objects database 
examples key structures include integer values data tree coordinate values points tree rectangles regions rtree 
index key structures may different leaf key depending kind tree 
example tree leaf keys represent points index keys represent regions 
different structures common notion search keys 
basically tree structure classify information breaking parts repeatedly breaking parts subparts 
sense index key logically matches data stored subparts 
example keys tree logically delineate range data pointer contained 
shows simple tree integer key values 
key values tree 
range divided parts key root 
key value left subtree including left children subtrees rooted equal 
key values right subtree greater 
range left subtree chapter 
generalizing persistent search trees subdivided keys 
happens right subtree 
key values left subtree equal values left subtree equal 
data pointers simple tree notice index nodes trees structures gamma 
order generalize tree tree structures key added pair key pointer index node affecting original structure property tree node 
case node structure 
leaf keys ascending order left right key greater equal key value subtree pointed key biggest value subtree 
leaf keys descending order left right key smallest value subtree 
simple tree redrawn modified index structure 
data pointers pairing key pointer tree chapter 
generalizing persistent search trees ranges represented tree keys disjoint tree regions represented rectangle keys may overlap 
shows region containing rectangles points leaf keys corresponding tree 
index keys rectangles 
region divided parts represented keys 
subdivided 
index key children contained 
children rectangle point contained respectively 
tree keys delineate bounding box data pointer contained 
simple tree satisfy search tree properties restriction placed key logically match datum stored 
trees leaf keys ascending order left right matching condition greater equal 
key values greater equal chapter 
generalizing persistent search trees value subtree 
trees matching condition cover 
starting root rectangle covers rectangles points child 
generalizing notion search key possible capture essential nature database search tree hierarchy categorizations categorization holds data stored hierarchy 
idea possible generalize basic tree operations 
furthermore search tree keys index nodes different leaf nodes 
generalize search key categories keys leafkey 
tree functionality different kinds search trees related share common concept search tree certain common operations insertion deletion search 
possible functions include returning size tree creating empty tree clearing contents tree 
commonality functional level captured generalized search tree class gtree class gtree public int insert leafkey data int delete leafkey bool search leafkey data int size bool empty void clear 
specific search trees trees trees inherit publicly gtree operations operations revised algorithm replace existing ones 
chapter 
generalizing persistent search trees class btree public gtree public add replace gtree operations class rtree public gtree public add replace gtree operations tree may different deletion algorithm tree may different node splitting algorithm 
possible write general function print gtree print contents tree tree 
specific search tree may inherit specific ones forming inheritance hierarchy example class tree public rtree public add replace rtree operations algorithms operations gtree 
general apply search trees independent data types implementations inner structures 
general 
gtree class intended provide common functionalities search trees just interfaces operations implementation class class 
addition search tree properties remain unchanged algorithms applied 
algorithms designed capture common parts search insertion deletion operations stub routines specific parts related particular tree structure user specified 
search recursively descend possible paths tree keys match search key 
chapter 
generalizing persistent search trees 
search subtrees root leaf go step check possible subtrees match search condition 
search leaf check entries leaf match search key search algorithm basically search search tree query predicate 
search condition exact match equality range query window query possible query predicate corresponding key type 
achieve search condition provided stub routine algorithm called consistent 
routine provided user depending individual search tree implementation 
insertion entry new key new data object added leaf level 
leaf overflows split splits propagate tree 

find leaf new record root leaf root choose subtree record go leaf reached 
add record leaf leaf room entry add record leaf split old records new record new leaf ll 
propagate changes upward adjust tree new preserve search tree properties passing ll split performed 
grow tree taller split propagation caused root split create new root chapter 
generalizing persistent search trees choosing subtree step splitting tree node step application dependent 
steps changes propagate upward calculate new parent key new subtree dependent specific application 
deletion remove entry leaf node 
causes underflow adjust tree accordingly updating key parent nodes preserve search tree properties 

find node containing entry invoke search locate leaf node containing entry entry 
delete entry remove entry leaf 
propagate changes adjust tree new preserve search tree properties 
shorten tree root node child tree adjusted child new root algorithms tree operations gtree 
user specifies necessary stub routines gtree routines depend individual search tree specific implementation 
collectively stub routines called tree behaviour routines discussed section 
structure basic structure database search tree hierarchy tree nodes root node leaf nodes 
node divided fixed variable sized block holding chapter 
generalizing persistent search trees key pointer pair data record 
entries linked list inside node 
internal node structures possible example entries index node hb tree organized tree 
generalized search tree independent implementation tree nodes accommodate situations 
solution generalize tree nodes containers generalize entries inside containers level containers nodes previous containers 
structure search tree abstracted hierarchy nested containers 
generally container object holds objects 
examples lists vectors associative arrays 
container generalized search tree area corresponding tree node 
contains storage manager number nodes organized array linked list arranged types data structure 
shows container array nodes container linked list nodes 
nodes inserted removed container 
containers hides implementation details inner container structure tree classes example type fields node nodes organized 
storage manager storage manager list nodes array nodes structures array list container search tree holds containers container type template parameter tree class gtree 
container holds nodes node type template parameter chapter 
generalizing persistent search trees container class 
node container level nesting may hold pointer key data object 
key type data type template arguments node class 
example template class gtree 
template class container 
template class 
template class 
container design meet criteria provide maximum freedom design individual container time requiring containers common interface 
provide common interface containers class type inheritance provided specifies common operations containers template class container protected int count number nodes container int level level container tree public container count level virtual node operator int virtual node node container virtual node node container virtual void node virtual void node virtual void data fields common containers count represents current number nodes container level level tree container level leaves increasing level upward tree hierarchy 
virtual functions provide interface operations subscripting returning node container adding new node container deleting node container printing contents container usually debugging 
specific container implementation array container publicly inherits chapter 
generalizing persistent search trees container class template class public container data fields public define operations data fields defined specific container class 
containers different implementation different data fields 
containers implementation may slightly different structures different search trees 
example leaf containers tree connected easy sequential searching case tree 
tree behavior gtree provides common parts tree operation algorithms requires user give specific tree behaviour routines complete operations individual search trees 
tree behaviour routines defined derived gist modified ffl consistent search key matches certain condition key inside tree node :10.1.1.144.2507
routine search deletion algorithms 
ffl union parent key updated changes subtree 
routine adjusting tree insertion deletion algorithms maintain tree property 
ffl choose subtree subtree chosen insert new record 
routine insertion algorithm 
ffl split tree node split nodes criterion reached 
routine insertion algorithm 
chapter 
generalizing persistent search trees routines specify particular behaviour implementation search tree 
routines accessed gtree 
option gtree contains methods virtual functions class gtree public 
virtual bool consistent 

virtual void split 
specific search tree inheriting gtree example tree gives implementation methods class rtree public gtree public 
bool consistent 
void split 
routines part implementation tree operation 
tree behaviour routines called directly tree operations indirectly tree operations 
solution include virtual functions protected methods gtree implementations protected methods specific tree 
importantly actual implementations methods depend implementation containers 
specific search tree tree methods associated array containers different associated list containers 
furthermore different implementations may chosen index containers leaf containers tree 
example tree choose array implementation index containers holding fixed size key pointer list implementation leaf containers holding variable size data objects 
impossible hard code chapter 
generalizing persistent search trees methods specific tree type containers decided template parameters 
furthermore methods part container 
type container apply different trees methods different different trees 
second choice template functions methods 
example different versions union defined template key union 
inside template class gtree correct version union chosen correct key type compiler unification algorithm 
different implementations method included file 
generalize search trees possible build tree different structures implementations index leaf parts 
third approach bind methods class called gist gtree inherit gist gtree methods superclass class gtree public gist 
inheritance relationship gist gtree inappropriate 
gist gtree gtree contains gist implementation policy 
way seeing think gtree having different implementations tree node splitting algorithm 
situation car different engines 
containment appropriate inheritance 
approach class gist template parameter class gtree specify implementation policy specific tree routines passed single argument run time cost chapter 
generalizing persistent search trees template class gtree 
second different operations static members class example method split called gist split 
insert method 
static methods independent class object class acts module case packaging gist routines unique name allowing compiler unification algorithm select appropriate routine 
example class static methods class public static bool consistent 
static key union 
static node 
static void split 
gtree adapted tree registering behaviour methods class btree public gtree way general tree functionality provided gtree specialized specific search tree 
generator generator iterator abstraction notion pointer element sequence vector array linked list tree str 
generators provide access elements data structures having access particular data structure implementation 
iterating data structures generator flexible powerful tech chapter 
generalizing persistent search trees nique 
depending data structure may multiple generators iterate data structure different ways 
example doubly linked list may generators iterating list forward direction iterating reverse direction 
generator traverse entire data structure just part example nodes tree predicate satisfied 
multiple generators time iterate different parts structure 
generator perform action iteration different actions performed data current node especially condition deciding action perform depends state information local traversal context 
generators perform general queries search tree structures providing clean interface queries 
example generators providing range queries data ordered domain tree include tr represents tree file structure ffl retrieve records sequential scan gen tr ffl sequential scan key key gen tr key key ffl sequential scan key cnt amount gen tr key cnt ffl sequential scan cnt amount key cnt amount gen tr key cnt cnt chapter 
generalizing persistent search trees examples generators window queries similar interface range queries include ffl intersection object find objects point common gen tr ffl enclosure object find objects enclosing gen tr ffl containment object find objects enclosed gen tr ffl adjacency object find objects adjacent gen tr file structure designer able easily provide generators 
generators iterate tree structures similar way perform different query actions 
generalized generator class designed provide common interface complete iteration possible branches tree structure 
specific generators inherit providing specific query criteria possibly overriding member routines 
example possible branches tree need checked window query specific window query generators need inherit pass different query routines 
range query generator may need override member routines take advantage sequential scan iterating branches tree 
implementation details specific tree generators discussed sections 
chapter 
generalizing persistent search trees index number indices different organizations data indices affects interface structure gtree results different gtree types 
data records may stored leaves index tree structure shown 
commonly index data records stored separate areas files shown index tree indexed primary key data records database 
primary index may index non primary key attribute called secondary index shown 
general may multiple indices shown 
different indices achieve level generalization address space file structure able divided segments segment accommodating index tree data part 
furthermore segments different sizes file structure user specify initial size segment 
difficulty occurs segment full expansion possible storage allocated segment 
segment data grow downwards address space easily interior segments expand past initial sizes 
mentioned section initial fixed partition address space multiple segments new memory management scheme needed achieve goal 
leads nested storage management scheme 
chapter 
generalizing persistent search trees nested storage management complex parts data structure efficient storage management 
usually file structure designer spends significant time organizing data primary memory secondary storage 
memory mapped file structures organizing data primary memory indirectly organizes data secondary storage 
order manage storage multiple indices variable storage manager vsm allocate free segment address space 
total size vsm manage address space size 
index tree segment storage manager sm manage memory containers 
example uniform storage manager usm allocates fixed sized blocks container size new container needed frees storage container deleted 
total size sm manage segment size 
inside container uniform variable storage manager manage memory nodes depending nodes fixed sized variable sized 
total size sm manage container size 
data segment usm vsm allocate free storage data objects 
shows picture nested storage managers address space primary index segment data segment 
storage managers linked support expansion 
inner storage manager relies containing storage manager expand 
associated storage manager generalized expansion object supports expansion 
container storage manager allocate space new node index segment storage manager allocate storage new container hold nodes 
space new container address space storage manager allocates storage index structure free memory address chapter 
generalizing persistent search trees vsm sm sm container sm node node data data address space index segment data segment nested storage managers space 
hierarchy persistent search tree classes currently levels defining persistent search tree class persistent generic specialized 
class ptree provide storage management different segments address space 
generic tree class gtree inherits storage management implementation persistent tree class ptree provides common tree operations chapter 
generalizing persistent search trees class gtree private ptree 
stree represent specialized tree tree tree 
specialized tree class stree inherits type implementation gtree class stree public gtree 
parallel inheritance hierarchy tree classes inheritance hierarchy additional data structures administration access wrapper classes needed constructing persistent file structure database discussed detail sections class private 
class public 
class private 
class public 
class private 
class public 
ptree ptree class classes provide storage manager segments cover database implementation details 
chapter 
generalizing persistent search trees class ptree public ptree prototype implementation ptree empty acts name address space containing segments 
data structure allocated start address space administer address space storage 
contains storage manager segments address space 
currently storage manager restricted variable storage manager 
class private friend class public exp vsm int constructor parameter initial file structure size 
address space initializes pointer persistent area 
pointer accessed subclasses protected variable rep reason convention requiring administrative class inherit administrative object stored persistent area 
objects prefixed rep part database implementation details 
simplify explanations thesis details objects omitted 
chapter 
generalizing persistent search trees class friend class const prevent copying operator const protected access class representative public char name name definition class wrapper migrate file segment const prevent copying operator const public const tr wrapper tr definition access class defines duration file structure address space accessible 
constructor parameter unix file name 
file structure mapping established creating object 
pointer file structure address space directly application program persistent area directly accessible application 
wrapper class file structure address space accessible 
definition cover declaring specified persistent area 
chapter 
generalizing persistent search trees gtree tree class hierarchy gtree core component template class parameters template key type index containers class node type index containers class index container type class gist methods index containers class leafkey key type leaf containers class node type leaf containers class leaf container type class gist methods leaf containers class data data type class sm storage manager type class gtree 
details template parameters section 
discussed gtree performs basic operations search tree insertion deletion search methods provided gist 
constructor gtree takes parameter container size specified file structure designer 
definition gtree class macro identifiers replaced program corresponding text defined define statements 
shows example definition inherits privately order link storage manager address space possible expansion 
administrative class contains pointer root root node persistent search tree 
example persistent area address space divided segments primary index tree data objects 
expansion objects storage managers 
storage manager index tree deals fixed size containers built chapter 
generalizing persistent search trees define class class class class class class leafkey class class class data class sm define leafkey data sm template class gtree private ptree gtree const gtree prevent copying gtree operator const gtree int int insert leafkey data data int size int delete leafkey data data search leafkey protected public gtree gtree int gtree definition type storage manager data part passed template parameter type appropriate type chosen fixed size variable size data objects 
constructor parameters initial file structure size segment size container size 
constructor initializes expansion objects storage managers sets root pointer null indicating empty tree 
inherits defines duration gtree accessible 
class definition provides routines operate tree 
chapter 
generalizing persistent search trees template class private public root data usm sm sm int int int int definition way application code access file structure contents 
constructor parameters gtree class object unix file name file structure passed 
constructor retains subsequent access corresponding tree routines 
member routines insert delete search called application programs perform tree operations 
members cover corresponding members tree object 
routine address space accessible creating object performing operation tree 
routines get set needed directly access data segment 
pointer leaf node tree purpose get get data value database assign shared memory application program 
example search routine calls gtree search returns pointer leaf node calls get obtain data value variable record similar embedded sql statement exec sql select 
host variables 
routine set performs update database directly pointer leaf node desired data value similar sql update statement update table set column 

chapter 
generalizing persistent search trees template class gtree tree access class representative const prevent copying operator const public gtree tree char name int insert leafkey data data int size int delete key data data bool search leafkey data record void get const data value void set const data value definition inherits gtree directly accessible 
example definition template class private const prevent copying operator const public const tr tr stree stree highest level class tree class hierarchy representing user specialized persistent search tree 
inherits gtree tree tree database search trees 
file structure designer choose appropriate key type data type storage manager specific implementation gets new persistent file structure significantly shorter time writing scratch 
addition insert delete search methods gtree chapter 
generalizing persistent search trees template class btree public gtree friend class char filename admin public btree char name int int int int btree tree definition overridden stree new versions tree operations 
shows example tree definition 
stree instance generated generic stree type common parameters name unix file contains persistent file structure initial space allocated address space bytes initial size segment size container index 
stree contains pointer inherits encapsulates persistent administrative information address space 
constructor stree copy unix file name shared memory establishes mapping file resulting address space accessible obtains pointer address space location administrative object checks see file created access 
file newly created address space extended specified size administrative object created initializes constructor creating empty tree 
file created constructor checks file correct type performing dynamic type check 
chapter 
generalizing persistent search trees inherits 
constructor parameters initial file structure segment container sizes 
constructor passes copies file type file magic cookie type identifier dynamic type checking tree accessible 
member routine performs dynamic type checking file 
example tree definition template class public char typename public int int int int int char filename inherits defines duration stree gtree accessible 
specific operations defined stree needs provide corresponding cover routines operate tree 
example tree definition template class public friend class public btree tree tree tree filename 
possible routines inherits stree address space accessible 
example tree definition chapter 
generalizing persistent search trees list implementation array implementation node key 
data sm gist key node container 
usm vsm 
key key key data key data linked linked linked linked rtree btree rtree btree node key data 
container node 
data type index leaf key value interval rectangle 
components generalization library template class public public const tr tr tree class library section lists template type parameters gtree class 
section discusses details parameter small set specialization components types available generalization library including common implementations array linked list index leaf container structures various implementations 
components generalization library showed 
chapter 
generalizing persistent search trees key key class provides type key tree node basic operations keys 
examples key structures include integers data trees bounding boxes regions trees 
index key type leaf key type trees trees different kdb trees point tree access methods 
parameter types keys leafkey 
key type provided file structure designer 
node key 
node key data 
node class provides fields needed entry container 
template class key type possible data type parameters depending data stored 
gtree definition type index nodes type leaf nodes tree 
different organizations nodes inside container node different fields 
container array nodes index node contains key child pointer pair 
shows node class named 
variable keyvalue key type key 
variable child pointer child 
general node class child void pointer 
reason untyped pointer depending level node search tree child point index container leaf container data object 
union type define child pointer container types passed class impossible node type template parameter container classes discussed section 
class provides overloaded assignment operator print routine easy manipulation container debugging 
chapter 
generalizing persistent search trees template class public key keyvalue void child child null key void ptr keyvalue child ptr operator const void print array node example template class listnode public key keyvalue void child listnode listnode child null null listnode key void ptr keyvalue child ptr listnode operator const listnode void print list node example shows possible implementation node container linked list nodes 
addition key value child pointer node link field pointer construct linked list 
leaf node contain data objects pointer data objects 
example definitions nodes array linked list implementations respectively 
commonly node class implementations provided library possible combinations chosen index leaf nodes 
file structure designers implement node classes 
chapter 
generalizing persistent search trees template class public key keyvalue data data data data key data data operator const void print array node data template class public key keyvalue data data data data key data data operator const void print list node data container node 
containers nodes inside container type template class node type parameter 
discussed section container class provide common data variables interface operations individual container needs specify subscripting returning node container adding deleting nodes container 
container array linked list 
list versions container type definitions 
maximum number entries container hold 
variants may support linear ordering nodes leaf containers may connected easy sequential retrieval 
associated container cursor class generator container 
chapter 
generalizing persistent search trees template class array public container public int number nodes container private node node node node public class cursor iterator container int array array public cursor array array node start node succ node pred array int size constructor node operator int subscripting operator node node node node void print content container void node node add node container void node node delete node container array container example matter kind structure implementation container provide cursor class common interface class cursor 
public node start node node succ node node pred previous node cursor class provides common interface iterating containers internal structure implementation container transparent 
chapter 
generalizing persistent search trees template class list public container public int number nodes container private usm node pointers node public class cursor iterator container node prev node curr list list public cursor list list node start node succ node pred list int size constructor node alloc node allocate storage node void free node free storage node node node node void print content container void node node add node container void node node delete node container list container example data data stored database may basic type integer float complex array structure user defined class 
database search tree able index different kinds data 
notion data represented minimal dependence special type 
search tree generalized data type data type type parameter 
indexed datum database arbitrary data object fixed variable sized 
chapter 
generalizing persistent search trees data stored index nodes commonly leaves search tree 
usually data objects large order maximize fanout tree pointers tuple ids actual locations data objects database stored leaves tree 
storage management similarly key type data type storage manager type generalized type parameter search tree class 
type storage manager chosen depending type data manages ffl uniform storage fixed size specified creation storage manager ffl variable storage variable size specified allocation basis changed ffl dynamic storage variable size specified allocation basis subsequently expanded contracted gist key node container 
discussed section set static methods class gist provide behaviour routines individual search tree corresponding particular implementation 
gist template class key node container type type parameters 
shows definition gist class 
file structure designer provides implementation gist class kind access method 
chapter 
generalizing persistent search trees template class gist public static bool consistent key key key key static key union container container static node container container key static void split container container node container consistent nodes returns true match certain condition false 
matching condition depends particular tree structure 
union pointer container containing nodes ptr ptr returns key covers nodes container pointer container key insert node selected root subtree insertion depending desired property tree 
tree ordered records leaves node chosen leads correct leaf insert key ordering 
tree node chosen rectangle needs enlargement include key split pointer full container node inserted new container created nodes old container new node distributed containers 
different search trees usually different algorithms container splitting 
search tree may different container splitting algorithms 
example quadratic linear algorithm applied tree 
chapter 
generalizing persistent search trees tree generators definition shown 
implemented coroutines 
retaining data execution state crucial creating generator traverse tree structure 
coroutine allows generator return control back caller node extracted retain location tree structure 
specific tree generators coroutines inheriting example template public 
template public 
member routine resets generator root tree 
operator resumes coroutine main invoke member performs recursive traversal tree suspending back operator node satisfying query 
resume operator restarts coroutine suspended 
query finishes generator returns call main completes traversal setting root null 
member main suspends back operator returns null data pointer false 
constructors 
constructor allows specification tree access object employed generator going particular tree object gen tree gen 
data node second constructor employed create generator subsequently initialized associated tree object 
association occurs member routine 
order accommodate diverse queries specific query routine passed pointer function 
query criteria index keys leaf keys may different 
chapter 
generalizing persistent search trees example containment window query needs test overlap relation query key index keys test containment relation query key leaf keys 
pointers query function consistent applying index keys query applying leaf keys 
counter variable count control traversal certain number records needed 
example query get records range key key performed generator declared tr represents tree file structure gen tr key key default value counter means query conducted entire tree structure 
summary essential nature database search tree general notion search key provide basis generalizing tree operations 
multiple levels generalization shown 
levels include tree functionality container structure tree behavior tree generator index storage management 
implementation generalization including hierarchy persistent tree classes components generalized tree class library 
chapter 
generalizing persistent search trees template protected const ga root curr leafkey bool consistent key leafkey key bool query leafkey key leafkey key int count void void main root root null curr null public const ga bool consistent leafkey bool query leafkey leafkey leafkey int count bool consistent leafkey bool query leafkey leafkey leafkey int count void const ga wrapper ga ga ga root ga tree root bool operator tp wrapper ga root null tp curr return root null gtree generator chapter example file structures experiments constructing generalized search tree developing specialization component library goal demonstrate feasibility generalization idea database search trees show overhead generalization affect performance search trees significantly 
effective way doing design construct illustrative search tree structures run experiments 
tree tree tree file structures developed generalized search tree toolkit 
tree example section showed definition tree 
tree take advantage existing operations provided gtree 
key class contains value type indexed data 
keys ascending order implementation gist methods ffl bool consistent key key key key key key return true return false chapter 
example file structures experiments ffl key union container container return key biggest value container ffl node container container key return address node container key greater key greater keys container node returned ffl void split container container node container half old container new node go old container second half go new container queries supported tree exact match range queries 
achieve efficient range queries tree range generators developed basis full advantage sequential scan 
overloaded coroutine main shown represent range query variable count control number records needed partial retrieval 
versions tree different index leaf structures developed easily specifying appropriate template parameters tree definition 
experiment tree array key pointer pairs index containers linked list key data leaf containers 
declare instance tree statement chapter 
example file structures experiments template public const ba leafkey range int count void main root get record range count count cursor cursor start cursor current curr sequential rest leaves till reach range curr start curr curr cursor succ curr rect root null count count infinite maximum number count break get nodes leaf range count break get leaf exhaust nodes till leaf root null cursor start cursor start root null public leafkey leafkey int count const ba leafkey leafkey int count void const ba bool operator tp btree range generator example chapter 
example file structures experiments btree array array list list btree unix file name creation arguments initial size segment index size container size node types container types chosen generalization library 
key type gist methods need specified 
different implementations set gist method 
unix file name tree file structure initial size bytes 
container size chosen 
tree example similar tree tree defined template class rtree public gtree friend class char filename admin public rtree char name int int int int rtree dimensional domain keys tree numbers type float representing upper left lower right corners rectilinear bounding rectangles objects 
implementation gist methods ffl bool consistent key key key key key contained key return true return false chapter 
example file structures experiments ffl key union container container return rectangle having smallest lower right corner biggest upper left rectangles container ffl node container container key return address node container rectangle needs enlargement include key nodes qualify node chosen randomly 
ffl void split container container node container splitting uses guttman quadratic splitting algorithm exact matching queries supported point queries window queries including containment enclosure intersection queries 
generator classes queries simply inherit class pass query routines constructor 
example generator containment queries query routines overlap querying index containers contained querying leaf containers template public public const tr leafkey int count overlap contained count 
tree file structure separate index data parts built 
declare tree instance backing store file name initial file size chapter 
example file structures experiments rtree array rect array rect array rect array data rtree unix file name creation arguments initial size segment index size data size container size tree example introduced section trees differ trees mainly insertion algorithm 
tree inherits tree uses overloaded insertion routine implement forced reinsertion policy template class public rtree friend class public char name int int int int int insert leafkey data data int size overloaded routine achieve dynamic old rectangles tree forces nodes reinserted insertion routine 
overflow occurs algorithm called container root call container level insertion data rectangle invoke reinsert invoke split tree 
chapter 
example file structures experiments reinsert max nodes container compute distance centers rectangles center bounding rectangle sort nodes decreasing order distances remove nodes adjust rectangle invoke insert nodes removed 
declaring tree similar tree template parameter gist method uses alternative algorithm testing rectangle area margin overlap different combination order minimize overlaps 
experiments experiment performance gathered elapsed time real clock time test run 
experiments show search trees developed generalized model competitive performances comparing traditional search trees developed scratch 
trees query performances compared tree inheriting gtree tree developed scratch memory mapping 
trees uniformly distributed records generated keys taken unit interval 
records inserted tree 
resulting tree kinds queries conducted 
exact matches query files different distributions normal uniform random generated query keys file distributions 
query file experiment searches specified key tree retrieved corresponding data record 
second multiple chapter 
example file structures experiments response searches query files generated requiring records read total response collection multiple response queries size 
individual query file specified key uniform distribution fixed number records size range query read sequentially starting specified key 
query files described tuple total number queries file size query 
example 
implies queries size records query file consists keys uniform distribution 
key experiment searches key tree reads data records sequentially leaf links tree 
tables show experiment results exact matching queries multiple response queries respectively 
results essentially identical experiments run users computer 
elapsed time secs run generalized query number memory mapped memory mapped distribution keys tree tree normal uniform random table experiment results exact matching queries trees chapter 
example file structures experiments elapsed time secs run generalized query memory mapped memory mapped distribution tree tree 



table experiment results multi response queries trees trees tree experiment conducted tree developed traditional generalized tree tree memory mapping 
tree populated data obtained standardized testbed bkss 
data consists dimensional rectangles rectangle assumed unit square centers rectangles follow dimensional independent uniform distribution 
rectangles minimum bounding rectangles elevation lines real cartography data 
query files experiment taken testbed consist point queries containment enclosure intersection window queries 
experiment results shown table 
generalized trees slightly slower 
difficult determine slow result generalization difference traditional memory mapping performance memory mapping trees identical cause difference probably summary chapter demonstrated feasibility viability generalization database search trees 
example tree tree tree file structures easily built illustrate different chapter 
example file structures experiments elapsed time secs run generalized generalized traditional query memory mapped memory mapped type tree tree tree containment enclosure intersection point table experiment results trees tree capabilities generalization running experiments 
experimental results show generalization affect performance search trees significantly 
chapter generalized search tree provides basic search tree logic required build tree access methods 
unifies distinct structures trees trees 
specific search trees built generalized model significantly faster reliably hand coding 
flexibility provided search tree developers choose kind number indices internal representation implementation index leaf specific algorithms particular operations 
tree generators able support extensible set queries provide unified interface queries 
summary generalizations search tree file structures ffl functionality basic search tree operations captured base tree class 
ffl structure container structure internal representation implementation transparent 
ffl behaviour parameterization behaviour routines allow different algorithms implementation 
chapter 
ffl generator extensible set queries built easily unified interface 
ffl index flexibility provided kind number indices 
ffl storage management nested storage managers provide efficient memory management levels 
generalized class library created including small set specialized components search tree file structure developer required write components scratch 
carefully selecting components library specializing components needed new algorithm data structure new tree access method created subsequently tested significantly faster traditional approach experienced developing example tree file structures thesis 
performance experiments demonstrate feasibility viability generalization idea achieve efficient implementation tree access methods 
thesis concentrates generalization database search trees 
needed explore idea database access methods hashing techniques 
currently generalization tree access methods pursued memory mapped environment ideas applicable traditional environment possibly complex data structures 
bibliography abc atkinson bailey chisholm cockshott morrison 
approach persistent programming 
computer journal november 
ben bentley 
multidimensional binary search trees associative searching 
communications acm 
bgw peter buhr anil goel anderson wai 
database toolkit constructing memory mapped databases 
persistent object systems pages 
bkss beckmann kriegel schneider seeger 
tree efficient robust access method points rectangles 
acm sigmod international conference management data pages 
bm bayer mccreight 
organization maintenance large ordered indices 
acta information 
peter buhr 
understanding control flow concurrent programming 
www uwaterloo ca cs 
bibliography com comer 
ubiquitous tree 
acm computing surveys 
dd 
program 
prentice hall edition 
fagin nievergelt pippenger strong 
extendible hashing fast access method dynamic files 
acm transactions database systems 
fre 
bang file new kind grid file 
acm sigmod international conference management data pages 
gg volker gaede oliver gunther 
multidimensional access methods 
acm computing surveys 
goe anil goel 
exact positioning data approach memory mapped persistent stores design analysis modelling 
phd thesis university waterloo 
gun gunther 
efficient structures geometric data management 
lncs number 
springer verlag 
gun gunther 
cell tree objected oriented index structure geometric databases 
proceedings th ieee international conference data engineering 
gut guttman 
trees dynamic index structure spatial searching 
acm sigmod international conference management data pages 
hellerstein naughton avi pfeffer :10.1.1.144.2507
generalized search trees database systems 
proceedings st international conference large data bases zurich switzerland 
bibliography widmayer 
globally order preserving multidimensional linear hashing 
proceedings th ieee international conference data engin pages 
andreas hans werner peter widmayer 
lsd tree spatial access multidimensional point non point objects 
peter apers gio wiederhold editors proceedings international conference large data bases amsterdam netherlands 
widmayer 
file efficient access structure proximity queries 
proceedings th ieee international conference data engin pages 
knu knuth 
sorting searching 
art computer programming volume 
addison wesley 
lar larson 
linear hashing partial expansions 
proceedings sixth international conference large data bases pages 
lit litwin 
linear hashing new tool file table addressing 
proceedings sixth international conference data bases pages 
ls david lomet betty salzberg 
robust multi attribute search structure 
ieee conference data engineering pages 
ls david lomet betty salzberg 
hb tree multiattribute search structure 
acm transactions database systems 
bibliography stefan 
leda 
nhs nievergelt hinterberger sevcik 
grid file adaptable symmetric multikey file structure 
acm transactions database systems 
om orenstein 
class data structures associative searching 
acm sigact sigmod symposium principles database systems pages 
os 
new tree type data structure homogeneous node suitable large spatial database 
proceedings th ieee international conference data engin pages 
rob robinson 
tree search structure large multidimensional dynamic indexes 
acm sigmod international conference management data pages 
sk seeger kriegel 
techniques design implementation spatial access methods 
proceedings th international conference large data bases pages 
sl alexander stepanov meng lee 
standard template library 
srf sellis nick roussopoulos christos faloutsos 
tree dynamic index multi dimensional objects 
peter william kent editors proceedings thirteenth international conference large data bases pages brighton england 
bibliography ssh stonebraker sellis hanson 
analysis rule indexing implementations database systems 
proceedings st international conference expert database systems 
sto michael stonebraker 
inclusion new types relational database systems 
proceedings th ieee international conference data engin pages washington 
str bjarne stroustrup 
programming language 
addison wesley 
