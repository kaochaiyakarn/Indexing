feasibility distributed constraint satisfaction collin cs technion israel institute technology haifa israel rina dechter information cs uci irvine ca shmuel katz cs technion israel institute technology haifa israel characterizes connectionist type architectures allow distributed solution classes constraint satisfaction problems 
main issue addressed exists uniform model computation nodes indistinguishable guarantees convergence solution initial state system solution exists 
show relatively simple constraint networks rings general solution completely uniform asynchronous model 
restricted topologies trees accommodate uniform asynchronous model protocol demonstrating fact 
uniform asynchronous protocol 
show algorithms guaranteed suitable dynamic error prone environments 
consider distributed version graph coloring problem node select color set colors different color selected neighbors 
coloring task sequential version known np complete belongs class constraint satisfaction problems csps interesting challenges distributed computation particularly framework connectionist architectures 
call distributed versions problems network consistency problems 
consider types distributed models admit self stabilizing algorithm converges solution initial state network algorithms possible 
partially supported national science foundation iri air force office scientific research afosr 
constraints useful programming languages simulation packages general knowledge representation systems prospects solving problems connectionist networks promise combined advantages parallelism simplicity design error correction capabilities 
interesting problems attacked researchers neural networks combinatorial involve constraint satisfaction ballard dahl fact discrete state connectionist network viewed type constraint network stable pattern states representing consistent solution 
current connectionist approaches csps lack theoretical guarantees convergence solution satisfying constraints terms convergence guaranteed explored till 
show widely architectures nodes run identical procedures admit algorithms guarantee convergence consistent solution solution exists section 
identify distributed model close spirit connectionist paradigm guarantees established section 
model characterize provide algorithms restricted subclass networks solved uniformly section 
model definitions csp definition network binary constraints involves set variables xn represented domain values dn set constraints 
binary constraint ij variables subset cartesian product theta specifies values variables compatible 
solution assignment values variables satisfies constraints constraint satisfaction problems associated networks find solutions 
binary csp associated constraint graph nodes represent variables arcs connect pairs variables constrained explicitly 
general constraint satisfaction problems may involve constraints arity network communication pairwise focus subclass problems 
presents csp constraint graph 
csp constraint graph dfs tree model general communication model known shared memory multi reader single writer model 
distributed network consists nodes connected shared communication registers called state registers 
network viewed nodes represent processors arcs correspond communication registers 
register state written node may read nodes neighbors 
state register may fields regarded unit 
node modeled finite state machine state controlled transition function dependent current state states neighbors 
words activated node performs atomic step consisting reading states neighbors deciding change state moving new state writing state register collection transition functions called protocol 
processors anonymous identities terms node processor interchangeably writing convenience 
configuration system state vector processors 
execution system managed central demon scheduler defined dijkstra dolev distributed demon defined burns dolev distributed demon activates subset system nodes step central demon activates processor time viewed simplified version distributed demon 
activated nodes execute single atomic step simultaneously 
central demon means interleaving sufficient analysis protocol 
implementation level truly independent nodes execute parallel affect 
neighboring nodes constraint graph fact finer degree atomicity requiring set operation possible order simplify arguments 
execute atomic step central demon assumed 
denote configuration reached configuration subset processors simultaneously executing single atomic step 
execution system infinite sequence configurations execution considered fair node participates infinitely 
self stabilization self stabilizing protocol dijkstra particular convergence property 
system configuration space partitioned classes legal denoted illegal 
protocol infinite fair execution starting initial configuration input values time system eventually reaches legal configuration subsequently computed configurations legal 
self stabilizing protocol converges point configuration space stable legal region 
legality configuration depends aim protocol 
case wish design protocol solving network consistency problem 
set legal configurations having consistent assignment values nodes network assignment exists set 
definition allows system oscillate various solutions consistent assignment possible 
protocols converge possible solutions 
limits uniform self stabilization protocol uniform nodes logically equivalent identically programmed identical transition functions 
observation dijkstra dijkstra regarding computational limits uniform model performing mutual exclusion task show network consistency problem solved uniform protocol 
accomplished presenting specific constraint network proving convergence guaranteed uniform protocol 
consider task numbering ring processors cyclic ascending order call csp ring ordering problem 
constraint graph problem ring nodes domains gamma 
arc set constraints mod gamma left node smaller right 
solution problem cyclic permutation numbers 
gamma means possible solutions different nodes assigned different values 
theorem uniform self stabilizing protocol solve ring ordering problem presence central demon 
proof order obtain contradiction assume exists uniform self stabilizing protocol solving problem 
particular solve ring ordering problem ring having composite number nodes delta 
convergence solution guaranteed initial configuration applies nodes identical states 
construct fair execution protocol network converges consistent solution contradicting self stabilization property protocol 
assume execution gamma gamma 
gamma gamma gamma rq gamma 
note nodes 
gamma activation move identical states inputs initial states transition functions identical activated neighbors identical states 
holds sequential activation processors fp iq qg 
cycling schedule assures instance move identical states infinite number times 
consistent solution requires states different network reach consistent solution yielding contradiction 
theorem implies generally impossible guarantee convergence consistent solution uniform protocol 
implies convergence guaranteed class sequential algorithms called repair methods minton exclude possibility existence uniform protocols restricted activation policies 
show distributed demon convergence solution guaranteed tree networks 
consider instance coloring problem tree network constructed exactly connected nodes having domain 
nodes topologically identical start identical initial states activated simultaneously assigned different values 
consequently network converge legal solution exists 
counterexample extended large class trees possible way distinguish internal nodes 
show section central demon uniform self stabilizing tree network consistency protocol exist 
having proved network consistency problem solved uniform protocol central demon switch slightly relaxed model uniform protocol nodes identical 
denote special node consistency generation protocol network consistency protocol sequential version backtracking algorithm called backjumping 
implemented variable ordering generated depth traversal constraint graph technique enables distributed implementation 
preliminary version protocol appears collin dechter sequential aspects constraint satisfaction common algorithm solving csp backtracking 
standard version algorithm traverses variables predetermined order provisionally assigning consistent values subsequence variables attempting append new instantiation set consistent 
consistent assignment variable deadend situation occurs algorithm backtracks variable changes assignment continues 
useful improvement backtracking called backjumping dechter consults topology constraint graph guide backward phase 
specifically going back variable instantiated jumps back levels variable connected deadend variable 
turns depth search dfs constraint graph generate dfs tree conducting backjumping inorder traversal dfs tree jump back destination variable parent dfs tree 
nice property dfs tree allows parallel implementation arc graph tree connects node tree ancestors path leading root 
consequently dfs tree represents useful decomposition graph variable ancestors removed graph subtrees rooted disconnected 
translates strategy ancestors variable instantiated solutions subtrees completely independent performed parallel freuder quinn general network consistency protocol network consistency nc protocol logically composed self stabilizing subprotocols executed interleaved divide second subprotocol parts order simplify explanation 
dfs tree generation 
graph traversal protocol value assignment subprotocols unrelated independently replaced version implementation 
basic idea protocol decompose network independent subnetworks dfs tree structure instantiate subnetworks parallel 
proper order value instantiation guaranteed graph traversal protocol 
neighborhoods states self stabilizing algorithm generating dfs tree collin dolev discussed 
subprotocol uniform source non uniformity nc protocol 
algorithm stabilizes internal node adjacent node parent designated parent tree set child nodes denoted children 
indicates environment internal node root leaf 
link leading parent called inlink links connecting children called outlinks 
set neighboring nodes path root called predecessors 
role root played special processor node representing variable list possible values denoted domain pairwise relation ij neighbor domain constraints may viewed part system inputs valid changed execution forcing network changes 
leaf root internal node children parent children parent node neighborhood set state register node contains fields 
value field assigns domain values symbol 
denote deadend 
mode field indicating node belief regarding status network 
node mode value ancestors values changed time forward phase modes nodes give indication reached consistent state mode 

boolean fields called parent tag children tag protocol section 
graph traversal protocol graph traversal protocol handled privilege passing mechanism 
protocol node obtains privilege act granted parent children 
node allowed change state privileged 
privilege passing mechanism extension mutual exclusion protocol nodes called balance dijkstra dolev dfs tree established scheme implemented having state register contain fields parent tag referring inlink children tag referring outlinks 
link balanced children tag parent tag endpoints value link unbalanced 
node privileged inlink unbalanced outlinks balanced privilege passed backwards parent balancing incoming link forward children outgoing links changing parent tag children tag value accordingly 
node applies privileged leaves state unchanged 
denote branch tree path root leaf 
privilege passing mechanism eventually converges set legally controlled configurations node privileged branch 
shows configuration parent tag children tag node specified node respectively 
property assures eventually node ancestors reassign values simultaneously 
privileges travel branches backwards forwards 
omit proof due space limitations 
privileged node legally controlled configuration value assignment value assignment forward backward phases corresponding phases sequential backtracking algorithm 
forward phase note defined prove eventually siblings parent tag 
nodes different subtrees assign values consistent predecessors verify consistency assigned values 
node senses deadend assigns value field initiates backward phase 
network consistent processors mode forward backward phases continue forward phase verify consistency network backward phase just returns privilege root start new forward wave 
consistency verification violated node sensing violation initiates new value assignment 
root ancestors check consistency 
assigns new value backward phase needed initiates new forward phase 
elaborate description follows 
internal node situations ffl node activated parent mode forward phase value assignments 
case change value predecessors occurred 
finds value domain consistent predecessors puts mode passes privilege children 
consistent value exists assigns value deadend passes privilege parent initiating backward phase 
ffl node activated parent mode 
case verifies consistency current value predecessors 
consistent stays mode passes privilege children 
assigns new value moves mode passes privilege children ffl node activated children backward phase 
children value processor selects consistent value domain passes privilege children 
consistent value available assigns passes privilege parent children consistent value passes privilege parent 
value assignment protocol uniform node root protocol non root protocol decide role assigned dfs tree protocol 
leaf having children activated parent passes privilege back parent initiating backward phase 
due privilege passing mechanism parent sees children deadend wait privilege 
done guarantee subtrees consistent view regarding predecessors values 
self stabilization property nc protocol inherited subprotocols dfs tree generation privilege passing value assignment 
privilege passing established assures adequacy control implementing dfs backjumping guarantees convergence network legal solution exists keeps checking possibilities 
complexity analysis crude estimate time complexity nc protocol computing maximal number state changes time privilege passing stabilized final convergence 
search space generated sequential dfs backjumping obeys recurrence tm delta delta tm gamma yields tm delta tm stands search space generated sequential dfs backjumping depth maximal branching degree bounds domain sizes 
bound improves freuder quinn note get tm nk 
clearly worst parallel execution get sequential behavior time complexity exponential depth dfs tree 
due parallel instantiations different subtrees parallel protocol may average significant speedup sequential 
believe speedup protocol sequential algorithm 
extreme example consider problem instances backtrack free solution dfs ordering 
solved sequentially parallel 
conclude protocol convergence achieved polynomialtime networks bounded depth dfs tree 
average performance nc protocol improved adding uniform arc consistency subprotocol mackworth freuder network said value node domain consistent value neighbors domains 
arcconsistency achieved repeated execution relaxation procedure node reads neighbors domains eliminates values consistent value neighbors domains 
protocol clearly self stabilizing 
network consistency trees rest discuss protocols restricted class network topologies trees 
aim see restricted class problems solved relaxed uniform distributed model result efficient protocol 
known sequential network consistency problem trees tractable achieved linear time mackworth freuder special algorithm task composed arc consistency phase efficiently implemented trees followed value assignment order created rooted tree 
shown arc consistent tree enables backtrack free value assignment deadends freuder applying general nc protocol arc consistency protocol tree result improved performance arc consistency established forward phase value assignment protocol assign values nodes linear time deadends encountered see dechter dechter 
uniform nc protocol applied trees guaranteed converge polynomial number steps 
dfs subprotocol general algorithm source non uniformity reexamine possibility trees rooted directed tree imposed uniform protocol 
showed distributed demon uniform protocol trees feasible 
avenue explored central demon protocol exist 
show conjecture correct 
uniform tree consistency protocol principle uniform tree consistency tc protocol extracted general nc protocol replacing dfs tree protocol uniform rooted tree protocol rooted tree dfs tree 
arc consistency protocol protocol privilege passing protocol uniform resulting tc protocol uniform desired 
show trees value assignment protocol simplified need special mechanism 
tc protocol consists subprotocols 
arc consistency 
tree directing 
tree value assignment arcs consistent tree directed value assignment eventually guaranteed having node follow rule tree protocol choose value consistent parent assignment 
value exist value assigned parent removed arc consistency procedure 
show tree directing protocol self stabilizing arc consistency protocol self stabilizing value assignment protocol eventually converges consistent solution 
order direct tree break symmetry reflected identical codes lack identifiers exploiting topology tree 
task distributed protocol finding centers tree center tree node maximal distance leaves minimal 
consider sequential algorithm works phases phase leaves previous phase removed tree 
phase tree connected nodes left 
nodes centers tree 
protocol simulates algorithm 
center exists plays role root arcs directed 
centers exist direction link connects remains ambiguous viewed root links directed 
case centers considers parent tree directing protocol results pseudo rooted tree centers nodes play root role 
claim ambiguity hurt assignment protocol 
note center applies assignment protocol assigns value consistent 
scheduled supposed assign value consistent 
current assignment consistent taken care remains unchanged 
nodes assign values consistent parents 
central demon policy assures neighboring center scheduled time 
approach yields relatively simple uniform protocol simulates description 
assume number nodes network node fields bn vector counts number neighbors phase sequential algorithm 
records number neighbors phase means leaf th phase may initialized incorrectly 
repeatedly initialized number neighbors network means leaf original tree 
parent variable assigned value node parent enumeration local 
network stabilizes overcome necessity knowing size network dynamic memory allocation 
sake simplicity code assume knowledge vectors converge node neighbor eligible parent single center nodes parents centers 
protocol works having node scan neighbors vectors compute accordingly 
th entry vector represents number neighbors th phase value recursively computed decreasing number neighbors leaves entire number neighbors previous phase 
node chooses parent neighbor removed tree earlier 
presents pseudo code protocol 
recall code repeated forever point tree change 
proper convergence vectors guaranteed fact depends gamma fn gamma neighbors properly updated earlier 
base iterative convergence applied assigning actual number neighbors network 
complexity tree protocol clearly linear network size subprotocols equals sequential time complexity 
parallel time linearly bounded diameter tree diameter longest path leaves tree 
results establish theoretical bounds capabilities connectionist architectures distributed approaches constraint satisfaction problems 
focuses feasibility solving network consistency problem self stabilizing distributed protocol guaranteeing convergence consistent solution exists initial configuration 
property essential dynamic environments unexpected changes occur constraints 
proved uniform protocol nodes identical solve network consistency problem node activated time 
consequently protocols obvious closer spirit neural networks architectures guarantee convergence solution 
hand distinguishing node sufficient guarantee convergence sets nodes activated simultaneously 
protocol solving problem conditions 
demonstrated network restricted trees uniform self stabilizing protocol solving problem exist asynchronous control neighboring node activated time 
open question uniform protocol feasible specific ordering asynchronous activation 
regarding time complexity shown worse case distributed sequential protocols complexity bound exponential depth dfs tree 
average linear speed feasible bounded depth networks 
ballard ballard gardner srinivas 
graph problems connectionist architectures 
technical report university rochester rochester ny march 
burns burns gouda wu 
self stabilizing token system 
proceedings th annual intl 
conf 
system sciences pages hawaii 
collin dechter collin dechter 
distributed solution network consistency problem 
proceedings th intl 
symp 
methodologies intelligent systems pages tennessee usa 
collin dolev collin dolev 
self stabilizing protocol dfs spanning tree generation 
preparation 
dahl dahl 
neural networks algorithms np complete problem map graph coloring 
proceedings ieee internat 
conf 
neural networks pages san diego 
dechter dechter dechter dechter 
belief maintenance dynamic constraint networks 
proceedings aaai st paul minnesota august 
dechter dechter 
enhancement schemes constraint processing backjumping learning cutset decomposition 
artificial intelligence journal january 
dijkstra dijkstra 
self stabilizing systems spite distributed control 
communications acm 
dolev dolev israeli moran 
self stabilization dynamic systems assuming read write atomicity 
proceedings podc pages quebec city august 

graph algorithms 
computer science press maryland usa 
procedure tree directing 

local counter 
leaf 
leaf th stage 
leaves gamma th stage removed th stage 
gamma gamma jfk neighbors gamma gj od 
neighbors exists 
parent 
center 
parent 
uniform tree directing procedure node freuder quinn freuder quinn 
spanning trees represent constraint satisfaction problems 
technical report university new hampshire durham new hampshire 
freuder freuder 
sufficient condition backtrack free search 
journal acm january 
rotem santoro 
distributed algorithms finding centers medians networks 
acm transactions programming languages systems july 
mackworth freuder mackworth freuder 
complexity network consistency algorithms constraint satisfaction problem 
artificial intelligence 
minton minton johnston philips laird 
solving large scale constraint satisfaction scheduling problems heuristic repair method 
proceedings aaai boston 
