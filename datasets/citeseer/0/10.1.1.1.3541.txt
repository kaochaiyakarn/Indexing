modular verification global module invariants object oriented programs rustan leino microsoft research redmond wa usa leino microsoft com manuscript july draft 
modules objects contain variables values may constrained invariants 
example object oriented languages java module class static fields object instance class instance variables 
invariants modules differently invariants objects invariants modules procedural language 
presents methodology module invariants objectoriented setting 
methodology sound prescribes initialization order program modules supports dynamic loading modules classes amenable static modular checking 
computer program module collection variables procedures 
object collection variables procedures 
difference program contains instance module may contain number object instances 
identity module name mentioned program identity object created dynamic allocation accessible flows value site 
objects dynamic data structures modules entities shared program 
programming uses modules objects 
modules objects data represented respectively module variables called global variables instance variables called fields 
data values constrained programmer declared invariants example java modeling language 
correctness program relies invariants 
consequently tool technique checking correctness program manual automatic static peter ller eth zurich switzerland peter mueller inf ethz ch dynamic depends invariants methodology stating exact meaning guiding 
consider specification verification module invariants object oriented programs surprisingly require methodology different module invariants procedural languages different object invariants 
prove methodology sound modular verification meaning separate verification module implies correctness program 
modules similar example object oriented language modula 
module named scope containing declarations variables procedures classes 
popular object oriented languages including java notion module combined notion dynamically instantiable class 
see connection languages java class modeled module mt variables static fields procedures static methods classes single class ct ct static members removed 
module invariants understood pioneering especially hoare 
solution methodology insists module invariant hold module control boundaries call return procedure defined module 
module invariant holds program control outside module 
solution requires module variables modified module procedures modules 
requirements easily met procedural language modules 
particular requirement met language defined variable accessibility policy second requirement met requiring module import module calls procedure module requiring imports relation modules acyclic 
classic methodology module invariants insufficient object oriented programs subtyping dynamically dispatched methods give rise useful patterns object procedures 
programs methodology dynamic call structure modules follow static imports relation modules 
object invariants require richer methodology analogous classic methodology module invariants 
part support object invariants useful partition program objects contexts hierarchically ordered ownership relation 
methodology suitable module invariants module generally owned just module 
knowledge methodology methodology module invariants object oriented programs 
part methodology module invariants prescribe scheme initializing modules 
scheme flexible handle dynamic module class loading 
scheme different initialization schemes java 
assumptions weak applicable practical programming languages 
combination modules objects interesting consider just invariants global variables fields consider invariants combination global variables fields shared data dynamically allocated data structure rooted global variable objects share data may need invariants relation shared data 
include treatment combination second combination 
rest structured follows 
start motivating describing core methodology sec 

formalize ideas sec 
prove soundness theorem sec 

ownership extend methodology allow module invariants dynamic structures sec 
prove soundness theorem sec 

discussion related 
methodology section introduce basic methodology module invariants explain overcome central problem abstraction multi module setting identify issue arises subclasses declared different modules prescribe initialization modules 
focus general ideas tightening details section 
basic methodology allow module declare invariant module variables 
example module fig 
declares invariant module imports string int int invariant procedure increase expose invariant violated invariant restored invariant checked hold illegal assignment allowed execution expose block procedure string string result string example program showing module variables invariant procedures 
preconditions shown procedures omitted discussed text 
shown example fact modules declare instantiable classes 
invariant may relate values variables methodology permit times module invariant violated 
reason introduce special program statement expose allows invariant module violated duration sub statement time say exposed 
update variable take place exposed restrictions variables read 
module invariant checked hold expose block 
module invariant relied just inside expose block expose blocks non reentrant 
illegal expose exposed module 
reasoning modularly program important know module exposed 
example procedure increase fig 
want declare precondition says module valid exposed possible prove program meets non requirement expose block procedure implementation 
facilitate mentioning validity status module introduce module special variable si possible values ll describe mentioned procedure method specifications 
note si abstraction invariant specification mention si require valid effect says invariant holds doesn give details invariant 
program update si directly 
value si changed automatically entry exit methodology expose statement 
postpone section issue setting initial value si multi module issues special module variable si possible program record usually preconditions procedures methods module invariant expected hold 
module uses clumsy best mention explicitly precondition modules validity needed 
example suppose string module contains global cache integers string representations 
procedures methods string including called fig 
precondition requires string module valid 
procedure turn need declare precondition string valid 
procedures modules may transitively call module deep program day changed call procedure string transitive callers changed add string validity precondition 
programming methodology respect principles information hiding 
address problem provide ability special module variable si express transitive validity validity short module 
time introduce actual values si variables si tvalid says transitively valid invariant holds modules precede validity order defined valid 
si valid says invariant holds says validity predecessors 
si mutable says invariant may violated program allowed execute statements assign module variables suggested bullets shall prove methodology guarantees properties program invariants hold point program example 
assume string precedes validity ordering assume declaration module string procedure string string int requires string si tvalid procedure needs precondition si tvalid needs invariant order parameter passed non negative needs validity string procedure increase si tvalid si tvalid si valid precondition 
generally preferred specification allow implementation rely validity modules 
validity ordering programmer specified partial order modules program 
introduce special declaration introducing edges validity ordering ordering tends follow certain programming patterns tie validity ordering edges declarations 
common edge validity ordering arises module client module 
piggyback validity ordering edges imports relation module declared import module import gives rise edge precedes 
words validity ordering includes imports relation modules 
validity order modules partial order generally hierarchical tree order somewhat analogous ownership relation objects reason object invariants :10.1.1.10.4654
requires care refined definition expose statement 
presence transitive validity precondition statement si tvalid si valid statement temporarily changes si mutable module transitively succeeds transitively precedes si tvalid expose statement temporarily changes si valid expose block initial values si si restored 
reason temporarily changing si tvalid valid maintain program invariant 
si tvalid si tvalid si tvalid si valid modules subclasses says precedes validity order denotes invariant declared module having introduced values spell preconditions procedures involved fig 
validity ordering edges introduced imports relation declared module successor modules imports 
cases wants insert module predecessor module 
subsection give motivating example set way introduce validity ordering edge 
methodology module th class theory method literal 
module arith 
class extends th theory override literal 
example illustrate specification problem method override relies module invariant 
consider hierarchy classes representing decision procedures various theories may implementation automatic theorem prover cf 

theory method adds constraint decision procedure 
fig 
declares class theory root hierarchy enclosed module th consider particular theory say theory linear arithmetic represented subclass declared different module arith see fig 

method override specification theory particular override strengthen precondition overridden method 
suppose implementation arith module variables indirectly calling procedure th relies module invariant hold variables 
specification problem declare precondition theory strong imply arith si tvalid benefit method override explicitly mentioning arith th th may know existence arith may authored long authoring th 
arith precedes th validity ordering solve specification problem account program invariant 
method class theory declares precondition requires th si tvalid implies arith si tvalid needed method override 
words caller method may know existence arith may hold object allocated type establish validity th time call gives implementation information determine arith valid 
allow module arith define edge arith th validity ordering introduce variant imports relation 
call variant extends example module arith extends th 
extends relation just imports relation allows module mention entities declared modules extends 
difference validity ordering edge introduced extends goes direction introduced imports 
words validity ordering includes converse extends relation modules 
example declaration allows class declaration module arith mention th theory inserts arith predecessor th validity ordering 
general allow module import extend number modules resulting validity order acyclic 
viewed different perspective module needs mention name module declared import extend declaration imports gives rise means validity implies validity contrast extends gives rise means validity implies validity 
consider oblivious import effect validity ordering 
programmer choose imports extends way keep validity ordering acyclic 
note way allow cyclic modules 
example refer entities imports extends vice versa cyclic possible oblivious imports 
module initialization module invariant established module initializer designated block code invoked exactly 
module initializers invoked runtime system orchestrate initialization multiple modules 
enable modular reasoning module loading initialization adhere policy 
modules loaded initialized special program statement fetch 
statement executed program start invocation main procedure programs load modules dynamically 

fetch statement loads specified module transitively imported extended modules modules loaded earlier fetch 
formalization module arith extends th imports string string string version invariant arith version null initializer string string string arith version 
example module initializer 

loading completed fetch statement initializes newly loaded modules invoking module initializers 
order initialization follows validity ordering module initialized initialization modules precede validity ordering 
requirements enforce eager initialization modules provides stronger guarantees initializer clients module lazy initialization instance java 
requirement guarantees set loaded modules closed imports extends relations 
loaded modules unresolved modules 
invoking initializer module fetch sets si mutable allows initializer assign module variables 
return initializer fetch sets si tvalid fetch initializes modules specified partial order requirement initializers module assume predecessors valid 
particular necessary allow initializer access variables procedures imported modules 
return able assume precondition si mutable si tvalid quantifications module names range loaded modules initializer responsible making sure implicit assertion holds exit assert example consider module arith fig 

string precedes arith second conjunct precondition implies string si tvalid initializer meet precondition conjunct precondition assignment arith version permitted 
note way arith initializer assume th valid th precede arith provided returns non null value implicit assertion initializer body hold 
program module module id extends idlist imports idlist invariant expr initializer stmt classdecl type id classdecl class id extends id grammar modules classes 
square brackets indicate optional components indicates zero occurrences 
formalization section formalize notions introduced previous section 
defining object oriented language modules prescribing operational semantics object oriented language mapping conventional language 
programming language consider language program consists set module declarations 
module declares set module variables module invariant set procedures initializer set classes see fig 

set admissible invariants described 
module named module explicitly declared imported extended define validity ordering transitive closure union imports relation converse extends relation 
declarations program ensure validity ordering acyclic 
class members include fields instance variables methods dynamically dispatched instance procedures java syntax 
statement language fig 

includes assignments local variables module variables fields 
new local variable introduced giving type initial assignment 
new instance class object allocated special assignment statement 
fields new object zero equivalent values 
custom initialization achieved invocation method 
language separates allocation initialization convenient presentation model languages java combined instance constructors 
assert statement causes program execution abort expression evaluates false 
procedures module variables classes fully qualified names omit module name formalization stmt type expr local variable expr module variable expr field update new object allocation assert expr expr procedure call expr method call expose stmt fetch expr dynamic class load stmt stmt sequential composition expr stmt stmt expr stmt grammar statements 
suggest types expressions identifiers write classes variables modules 
examples module clear 
calls procedures dynamically dispatched methods standard sequential conditional iterative composition 
expose fetch statements described sections respectively 
omit exact grammar expressions include literals local module variables access expressions written refer field object denoted usual operators 
program execution starts procedure named main module say start start main called module start transitively imported extended modules loaded initialized 
bootstrapping process fetch start start main admissible invariants important consideration methodology uses invariants set variables fields invariant refer 
invariant module may refer module variables declared fields declared classes definition admissible simple invariant module invariant module admissible access expression forms 
module variable 

hn field declared class variable predefined variable si note prefix 
hm access expression 
hn access expression 
access expressions case declared fields hi declared classes assert si mutable assert null foreach access expression 
hn mentioned module invariant assert 
hn si mutable expose assert si mutable si tvalid foreach si valid si mutable assert foreach si old si operational semantics object oriented language mapping conventional language 
operational semantics give operational semantics language mapping conventional language 
language includes statements objectoriented language fig 
exceptions assert statement statement cause program abort statements total fetch expose statements language allows statement marked atomicity brackets semantic meaning soundness proof treat number statements 
program execution modules loaded objects allocated 
condition holds false operational semantics variable keeps track set loaded modules quantifications objects range non null allocated objects 
operational semantics language figs 

trivial cases identity simply distributes sub statements omitted 
operational semantics assignment module variable declared module reflects decision methodology abort program execution mutable 
note require mutable update maintain module invariant checking module invariants expose blocks cf 

updating field declared class module requires receiver update non null 
soundness requires mutable invariant depends 
hn subexpression module invariant equals value 
hn example suppose invariant module mentions field declared class program fragment new operational semantics asserts field update hold asserts second field update hold iff mutable 
non expose statement requires module exposed exposed 
executing sub statement expose statement mutable changes tvalid successors just valid executing module invariant checked initial values changed si variables restored 
semantics fetch statement fig 

simplicity forbid recursive fetch operations shown fig 

fetch invoked module initialization 
half fetch statement performs loading atomic operation 
requires predecessors newly loaded module uninitialized case loaded fetch operation valid 
responsibility establishing condition lies callers fetch indicated operational semantics assert 
si variable newly loaded modules set uninitialized modules extended fetch may load new predecessors previously loaded initialized modules 
happen program invariant stake 
loading new modules fetch changes valid successor modules just valid 
second half fetch statement initializes newly loaded modules gradually restores validity modules module initialized setting si mutable calling module initializer setting si tvalid example arith th fig 
loaded fetch th initializer invoked arith initializer 
th loaded earlier fetch th valid fetch fetch changes th si tvalid just valid arith initialized 
loop invariant initialization loop predecessor module valid 
loop invariant holds entry initialization loop loop invariant loop predecessor valid uninitialized modules valid uninitialized fetch choose load assert si uninitialized si tvalid set modules imported extended set module variables zero equivalent values si uninitialized si uninitialized si tvalid foreach si valid var choose si tvalid si uninitialized si mutable init si tvalid pseudo code fetch statement 
loops module si field changed modules loop invariant preserved initialization loop modules removed valid 
validity ordering partial order loop invariant guarantees module chosen choose operation 
fetch statement operation sets si field uninitialized uninitialized modules initialized fetch terminates statement guarantees modules initialized program states fetch progress 
treating fetch atomic operation program invariant si uninitialized 
proof program invariant straightforward omitted 
soundness methodology soundness means si variable module correctly reflects module invariants predecessors expected hold 
soundness section formalize prove property formed programs 
program formed syntactically correct type correct invariants admissible see def 
validity ordering induced declarations partial order 
theorem soundness properties see section program invariants hold reachable execution state formed program 
auxiliary lemma soundness proof auxiliary lemma statement net effect si variable modules loaded execution modules loaded execution valid execution lemma auxiliary lemma statement guarantees postconditions old si old si ii old si tvalid old denotes value expression state execution begins 
proof 
lemma proved rule induction 
cases expose fetch trivial modify si variable loaded modules 
part 
expose statement fig 
modifies si variable modules invokes sub statement induction hypothesis net effect si variable loaded modules restores initial values si variables changed 
fetch statement fig 
modifies si variable modules modules previously loaded initial value si variable module restored number calls module initializers net effect si variables loaded modules induction hypothesis 
part ii 
induction hypothesis know sub statement expose statement satisfies postcondition 
subsequent instructions si variables changed tvalid values 
property preserved 
fetch statement loads number modules eventually assign valid 
calls module initializers don interfere si variables loaded modules part produce newly loaded modules valid induction hypothesis 
module loaded fetch valid exit 
proof program invariant program invariant holds initial state execution program modules loaded 
show rule induction statement preserves 
proof statements modify state load new modules interesting module variable update field update base case expose fetch induction step 
omit cases brevity 
module variable field update 
updates change value si variables load new modules 
expose statement 
consider statement expose 
assume holds state execution statement prove preserved instructions operational semantics expose fig 


assert instructions change state 

foreach statement sets tvalid successors valid preserves 

setting si mutable preserves si variables successors different tvalid 
induction hypothesis preserves 

show foreach statement preserves invariant consider modules prove si tvalid si tvalid continue case distinction loaded execution expose statement property holds foreach expose holds execution expose execution expose statement net effect si variables loaded modules lemma 
loaded execution expose apply lemma ii show tvalid execution si unchanged foreach si tvalid si tvalid preserved 
loaded execution expose apply lemma ii show tvalid execution holds get predecessors particular tvalid modules tvalid state lemma conclude foreach instruction change si si fetch statement 
consider statement fetch 
assume holds state execution statement prove preserved atomic instructions operational semantics fetch fig 

ownership invariants 
atomic loading statement group statements atomicity brackets sets si variable newly loaded modules uninitialized changes valid successor uninitialized module just valid precisely purpose maintaining 

assignment changes si uninitialized mutable preserves 

induction hypothesis execution initializer preserves 

assignment si tvalid preserves chosen predecessors tvalid property changed executing initializer lemma ii 
proof program invariant proof analogous 
cases induction base step 
module variable update 
consider module variable update definition admissible invariants def 
module invariant violated update 
assertion semantics module variable updates guarantees mutable preserved 
field update 
consider field update declared class module module invariant violated update contains access expression 
hn 
hn case assertion semantics field updates guarantees mutable preserved 
expose statement 
consider statement expose 
assume holds state execution statement prove preserved instructions operational semantics expose fig 


instructions execution preserve change si modules tvalid valid si mutable module invariants mention si def 
module invariants affected modifications 
consequently preserved 

induction hypothesis preserves 

foreach statement sets si initial value asserting 
lemma change si modules modules foreach statement changes si valid tvalid affect 
statement preserves 
fetch statement 
consider statement fetch 
assume holds state execution statement prove preserved atomic instructions operational semantics fetch fig 


atomic loading statement sets si variables uninitialized changes si variables tvalid valid operations preserve 

assignment si mutable trivially preserves 

induction hypothesis execution initializer preserves 

initializer ends implicit assertion 
assignment si tvalid preserves ifc change si valid lemma tvalid preserves 
ownership invariants far invariant module may depend module variables fields declared assignment field module variable violate module invariant enclosing module 
restriction allows guard assignment assertion module mutable 
preventing module invariants depending variables fields declared different modules restrictive interesting programs 
instance module may want global cache data structure implemented imported collection class impose certain requirements elements stored collection 
fig 
shows program 
simple cell represent cache client module invariant states natural numbers stored cache 
reason methodology introduced far handle programs illustrated field update method set update potentially violates client module invariant 
invariant contained different module possible determine modularly update guarded assertion client mutable 
section extend methodology notion ownership 
extension allows invariant module depend fields objects owned restricting fields declared 
extended methodology ensures field updated owning module mutable 
ownership ownership organizes objects hierarchy contexts objects context common owner ownership invariants module cell class cell int method set int module client imports cell cell cache invariant client cache null client cache initializer client cache new cell 
simplified implementation module global cache 
ownership invariant module client admissible refers field declared different module 
see 
methodology owner module pair consisting object class name 
ownership restrict object object may non owning objects 
object invariants encode ownership special field owner object 
value owner module pair obj typ 
set object created 
extend object allocation statement owner indicated new creates new object class owned module analogously object created new owned pair object type assume owner immutable object creation 
described handle mutable owner field ownership transfer previous 
say object transitively owned module owner owner transitively owned interested object owned module object 
type component owner handle inheritance methodology object invariants safely ignored 
consequently say object owned object owner type owner field mentioned module object invariants 
simplify notation check definition admissible invariants syntactically module variable field declared modifier rep modifier gives rise implicit invariant 
declaration rep sg module variable module contains implicit module invariant null owner analogously field declared rep class gives rise implicit object invariant null owner admissible invariants ownership allows support module invariants 
addition module variables fields permitted def 
invariant module may depend fields objects transitively owned leads refined definition admissible invariants 
definition admissible ownership invariant module invariant module admissible access expression forms 
module variable 

hn field declared class 

hn hi declared rep 
bound universal quantification form tx owner 
variable predefined variable si cases identical simple invariants def 

access expressions case allow module invariants depend fields owned objects 
fact objects owned derived fact reachable chain rep 
case allows module invariants quantify objects directly owned module objects reachable module variable 
declaring client cache fig 
rep client invariant admissible refined definition 
access expressions client cache client cache meet requirements cases respectively 
mutability owned objects allowing module invariants depend fields transitively owned objects introduces connection methodologies module invariants object invariants instance implicit object invariants introduced rep modifiers field declarations 
methodology object invariants ownership special fields objects statements expose objects 
subsection summarize aspects methodology necessary understand treatment module invariants 
detailed presentation see previous 
ownership invariants mutability objects handled analogously modules 
object special field committed fields objects committed updated 
field update guarded additional assertion assert committed consider module transitively owns invariant may depend declared module 
consequently update may violate invariant 
methodology handles situation rule module mutable objects owns committed 
committed conclude mutable 
invariant allowed violated update mutable committed fields manipulated strict protocol 
protocol guarantees object uncommitted owner objects uncommitted consequently owning module mutable 
enforce protocol committed manipulated restricted way statements object creation expose fetch special statements expose objects 
describe effects statements committed 
object creation 
committed field set false object created 
creation statements new new guarded assertions si mutable committed respectively ensure direct owner mutable module uncommitted object 
expose statement 
statement expose modifies committed field objects directly owned sets committed false si set mutable analogously committed set true original value si restored expose statement 
preserve property object committed objects transitively owned committed operation requires additional assertion objects transitively directly owned committed 
fig 
shows refined semantics expose statement 
fetch statement 
initialization newly loaded module fetch statement sets committed field objects directly owned true 
semantics fetch fig 
assignment si tvalid replaced atomic operation si tvalid foreach owner committed true analogously new assertion expose statement operation leads additional implicit assertion module initializer 
objects transitively directly owned committed assert owner owner committed expose assert si mutable si tvalid foreach si valid si mutable foreach owner committed false assert assert owner owner committed foreach si old si foreach owner committed true pseudo code ownership aware expose statement 
statement modifies committed field objects directly owned unpack pack statements 
objects owned methodology object invariants provides additional statements unpack pack analogous functionality expose 
applied uncommitted object unpack sets committed field objects owned false pack sets true 
statement modifies fields committed detailed description including formal semantics see 
formalize program invariants relation si committed fields section 
example implementation web server fig 
illustrates expressiveness ownership module invariants 
arrays covered formalization arrays example show methodology handle 
array elements behave public fields declared class object procedure method array object modify elements 
reading updating array elements handled analogously field read update 
module server maintains global cache web pages represented array cache indicated rep keyword array object owned module server module invariant requires cache different null 
different slots array store different null 
invariant admissible def 
refers fields length array elements declared classes server invariant admissible ownership invariant fields belong objects owned server server module invariant implicit invariant ownership established module initializer 
soundness presence ownership module webpage class webpage rep string 
module server imports webpage string random rep webpage cache invariant server cache null server cache length server cache null server cache server cache initializer server cache new server webpage class webserver webpage request string url requires server si tvalid url null int result null server cache length result null url equals server cache result server cache result null result 
retrieve webpage random generate expose server server cache result implementation simple web server 
module invariant server refers state cache array owned server module exposed updating cache 
method request requires server tvalid precondition conclude imported modules string random satisfy module invariants program invariants amd 
property necessary meet preconditions methods procedures called request string equals random generate 
specifications methods shown code 
update server cache result method request illustrates ownership invariants handled 
satisfy assertion server cache committed update server exposed 
expose statement sets server si mutable allows array update temporarily violate server module invariant long invariant reestablished expose block ends 
example invariant violated update stored cache preceding loop find array 
soundness presence ownership addition program invariants extended methodology guarantees object committed objects owned committed object directly owned module committed mutable 
extended methodology program wellformed syntactically correct type correct invariants admissible def 
validity ordering induced declarations partial order 
theorem soundness presence ownership reachable execution state formed program program invariants see lemma program invariants hold owner committed committed owner si mutable committed range non null allocated objects 
section show program invariants valid presence ownership invariants 
omit proofs brevity 
analogous proofs 
interesting cases statements manipulate si variable committed field object creation expose fetch unpack pack 
proof program invariant program invariant refers committed depends definition admissible invariants 
proof affected ownership extensions modifications semantics statements assertions manipulate committed proof program invariant program invariant adapt proof see section cover additional cases definition admissible invariants def 

proof case def 
relies properties object invariants particular implicit object invariants owner stemming rep declarations 
properties guaranteed methodology object invariants 
self want properties 
proof restricted part theorem case def 
assume 
invariant module may discussion depend fields objects directly referenced transitively referenced objects 
consequently objects directly owned proved holds general case 
proof case affected refined definition admissible invariants case field updates 
consider field update show module invariant module depends value valid tvalid cases def 

access expression depend field 

declared class module case covered proof section 
module invariant contains access expression declared rep show contradiction valid tvalid assume valid tvalid induction hypothesis holds update 
module invariants hold 
implicit invariant rep variable know owner assertion guarding update get committed program invariant implies si mutable contradiction assumption valid tvalid 
module invariant contains access expression bound universal quantification owner analogously case owner committed si mutable discussion invariants interesting extension methodology expresses relations module variable fields objects necessarily reachable module variables 
instance specify objects thevalue bounded global maximum value thevalue basically properties specified module invariant object invariant methodology express properties objects owned case def 

invariant expressed objects independently owner specified object invariant 
extended methodology object invariants allow object invariants mention module variables 
extensions scope 
static verification soundness methodology essentially guaranteed assertions semantics statements 
instance module invariant module hold body expose statement program aborts 
possible statically verify program abort due violated assertion 
assertion turned proof obligation 
proof obligations introduced assertions module variable field updates expose statements object creation statements implicit assertions module initializers 
technically statements replaced pseudo code including assertions 
appropriate program logic show assertions hold cf 

argument fetch expression denoting string characters name module fetched 
compile time information set modules imported extended module fetched 
general possible prove assertion fetch statement fig 
statically 
reason assertion fetch checked run time 
note assertion abort initial fetch performed start program execution 
crucial element modular static verification reasoning variables call may modify 
analogous interpretation modifies specifications fields envision policy allows procedure method net effect module variables modules valid valid explicitly having mention modifications procedure method modifies declaration 
hidden imports imports extends relations modules visible clients module 
advantage acyclicity requirement validity ordering checked compile time 
sake information hiding may desirable hide portions imports extends relations 
setting acyclicity test may done example link time load time failing acyclicity test may come surprise programmer 
related related module object invariants treatment module invariants methodology reasoning object invariants 
analogously methodology uses special field represent explicitly object invariant allowed violated 
field manipulated special statements unpack pack analogous expose statement field updates require object unpacked exposed modified 
significant differences module invariants object invariants 
methodology object invariants uses hierarchical ownership abstraction mechanism client object exclusively owns objects internal representation 
modules owned owner shared clients program uses different abstraction mechanism acyclic ordering modules 
ownership allow module invariants depend object fields 
ownership encoding identical methodologies 
earlier enables dynamic ownership transfer fixed owner relation simplify formalization 
extension dynamically changing owners straightforward 
barnett naumann extend methodology called visibility object invariants 
invariant object may depend fields objects owned visibility invariants expressive difficult determine objects unpacked field update 
due static nature modules modules potentially affected field update easily determined 
add called creational guards barnett naumann allow invariants quantify objects class instance specify singleton object instance class 
address abstraction problem class invariants initialization order problem classes 
ller thesis uses visible state semantics object invariants requires invariants relevant objects hold pre postconditions exported methods methodology allows invariants violated long violations explicit si field 
ller thesis supports invariants called fields sound way consider methodology 
leino nelson developed sound modular treatment object invariants fields 
notion ownership soundness proof difficult 
extended static checker modula uses technique leino nelson reason validity object structures defining boolean field valid represent validity 
usage field specifications similar si field 
leino nelson treat aspects module invariants module initialization order ller leino nelson fully supports module invariants 
extended static checker java esc java heuristics determine object invariants check method invocations 
described detail esc java user manual heuristics compromise flexibility likelihood errors guarantee soundness 
jml provides static invariants express properties static fields objects referenced static fields 
static invariants correspond module invariants 
analogously methodology static invariant class established static initializer 
contrast jml applies visible state semantics invariants hold pre post states non helper methods 
global data realization global data module variables similar static fields java 
directly supporting static class invariants require programmers explicitly specify acyclic validity ordering classes means abstraction 
avoid overhead modules imports relation module variables procedures static fields static methods 
solution restrict generality methodology 
java program easily mapped notation 
eiffel global data implemented methods 
body methods executed method called time 
calls cached result execution returned 
global data essentially realized objects shared objects access global data 
shared object accessed objects general owned exclusively object 
unclear express invariants module invariant module server fig 
global objects 
loading initialization dynamic class loading linking studied intensely context type safety 
build assuming load operation applies type safe load link mechanism 
details loading resolution bytecode verification semantics fetch 
java uses lazy class initialization 
classes initialized 
lazy formalized operational semantics hoare logics entails problems 
kozen illustrate modular reasoning extremely difficult presence lazy initialization initialization order classes initial values static fields depend clients 
focus kozen static analysis java bytecode determine class initialization dependencies 
analysis needed approach initialization order explicitly acyclic imports relation 
rger schulte report problems java lazy initialization mechanism related portability concurrency compiler optimizations 
problems avoided eager initialization 
modular verification methodology global module invariants object oriented programs 
invariants express properties global data values stored module variables 
addition ownership allows module invariants refer fields objects object structures global caches 
methodology proved sound 
methodology module invariants complements previous treatment object invariants 
methodologies formal model instance encoding ownership 
easily combined 
extend methodology allow method calls invariants 
plan implement methodology part net program checker boogie microsoft research implementation non trivial case studies 
mike barnett robert deline manuel hndrich rustan leino wolfram schulte 
verification object oriented programs invariants 
journal object technology 
www fm 
mike barnett david naumann 
friends need bit maintaining invariants shared state 
dexter kozen editor mathematics program construction lecture notes computer science pages 
springer july 
boris jan vitek 
confined types 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm october 
egon rger wolfram schulte 
initialization problems java 
software concepts tools 
chandrasekhar boyapati robert lee martin rinard 
ownership types safe programming preventing data races deadlocks 
proceedings acm sigplan conference object oriented programming systems languages applications oopsla volume number sigplan notices pages 
acm november 
luca cardelli 
program fragments linking modularization 
principles programming languages popl pages 
acm press 
david cok joe 
esc java uniting esc java jml progress issues building esc java report case study involving esc java verify portions internet voting tally system 
construction analysis safe secure interoperable smart devices cas sis 
submitted 
david detlefs greg nelson james saxe 
simplify theorem prover program checking 
technical report hpl hp labs july 
david detlefs rustan leino greg nelson james saxe 
extended static checking 
research report compaq systems research center december 
sophia drossopoulou giovanni susan eisenbach 
flexible models dynamic linking 
degano editor european symposium programming esop volume lecture notes computer science pages 
springer verlag 
cormac flanagan rustan leino mark lillibridge greg nelson james saxe raymie stata 
extended static checking java 
proceedings acm sigplan conference programming language design implementation pldi volume number sigplan notices pages 
acm may 
hoare 
proofs correctness data representation 
acta informatica 
dexter kozen matthew 
eager class initialization java 
werner damm ernst olderog editors formal techniques real time fault tolerant systems volume lecture notes computer science 
springer verlag 
gary leavens albert baker clyde ruby 
jml notation detailed design 
haim kilov bernhard rumpe ian simmonds editors behavioral specifications businesses systems pages 
kluwer academic publishers 
gary leavens albert baker clyde ruby 
preliminary design jml behavioral interface specification language java 
technical report iowa state university department computer science may 
see www org 
rustan leino 
reliable modular programs 
phd thesis california institute technology 
rustan leino peter ller 
object invariants dynamic contexts 
martin odersky editor european conference object oriented programming ecoop volume lecture notes computer science pages 
springer verlag 
rustan leino greg nelson 
data abstraction information hiding 
acm transactions programming languages systems september 
rustan leino greg nelson james saxe 
esc java user manual 
technical note compaq systems research center october 
sheng liang gilad bracha 
dynamic class loading java virtual machine 
object oriented programming systems languages applications oopsla pages 
acm press 
bertrand meyer 
eiffel language 
prentice hall 
peter ller 
modular specification verification object oriented programs volume lecture notes computer science 
springer verlag 
phd thesis hagen 
david von oheimb 
analyzing java isabelle hol formalization type safety hoare logic 
phd thesis technische universit nchen 
www 
tum de oheimb diss 
dave clarke frank de boer 
creational invariants 
erik poll editor formal techniques java programs pages 
available www cs kun nl pdf 
arnd poetzsch heffter peter ller 
programming logic sequential java 
doaitse swierstra editor european symposium programming languages systems esop volume lecture notes computer science pages 
springer verlag 
qian allen goldberg alessandro coglio 
formal specification java class loading 
objectoriented programming systems languages applications oopsla pages 
acm press 
