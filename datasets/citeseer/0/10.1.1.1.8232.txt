pythia ii knowledge database system managing performance data recommending scientific software elias houstis ann john rice purdue university verykios drexel university ramakrishnan virginia tech catherine houstis university crete scientists need locate appropriate software problems select alternatives 
previously proposed approach dealing task processing performance data targeted software 
approach tested customized implementation referred pythia 
experience realize complexity algorithmic discovery knowledge performance data management data discovered knowledge 
address issue created pythia ii modular framework system combines general knowledge discovery databases kdd methodology recommender system technologies provide advice scientific software hardware artifacts 
functionality effectiveness system demonstrated existing performance studies sets software solving partial differential equations 
user perspective pythia ii allows users specify problem solved computational objectives 
turn pythia ii selects software available user problem ii suggests parameter values iii assesses recommendation provided 
pythia ii provides necessary facilities set database schemas testing suites associated performance data order test sets software 
allows easy interfacing alternative data mining recommendation facilities 
pythia ii open ended system implemented public domain software supported part nsf cda prf darpa navy doe lg darpa aro daah purdue research foundation 
authors addresses houstis rice department computer science purdue university west lafayette verykios college information science technology drexel university philadelphia pa ramakrishnan department computer science virginia tech blacksburg va houstis department computer science university crete heraklion greece 
permission digital hard copy part personal classroom granted fee provided copies distributed profit commercial advantage copyright notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions mathematical software vol 
june pages 
houstis performance evaluation different problem domains 
categories subject descriptors numerical analysis partial differential equations information systems types systems database management database applications artificial intelligence applications expert systems general terms algorithms experimentation additional key words phrases data mining inductive logic programming knowledgebased systems knowledge discovery databases performance evaluation recommender systems scientific software 
complex scientific engineering societal problems solved today utilizing libraries form problem solving environments 
software modules characterized significant number parameters affecting efficiency applicability specified user 
complexity significantly increased number parameters associated execution environment 
furthermore create alternative solutions problem selecting different software various phases computation 
task selecting best software associated algorithmic hardware parameters particular computation difficult impossible 
houstis proposed approach dealing task processing performance data obtained testing software 
testing approach described weerawarana pythia implementation specific performance evaluation study 
approach tested numerical quadrature software ramakrishnan tested parallel computer performance adve verykios 
experience realize high level complexity involved algorithmic discovery knowledge performance data management data discovered knowledge 
address complexity issue scalability portability approach knowledge discovery databases kdd methodology fayyad testing recommending scientific software 
pythia ii system open software architecture implementing kdd methodology build recommender system rs domains scientific software hardware artifacts weerawarana ramakrishnan verykios verykios 
describe pythia ii architecture rs pde software 
problem known class problems performance criteria pythia ii selects best performing software machine pair estimates values associated parameters involved 
recommendations combining attribute elicitation specified problems matching predefined dense acm transactions mathematical software vol 
june 
pythia ii fig 

recommender component pythia ii implemented web server providing advice users 
population similar types problems 
dense means data available reasonable expect recommendation 
dense population reliable recommendation 
describe case studies sets elliptic partial differential equations software houstis 
describe sample pythia ii session 
suppose scientist engineer uses pythia ii find software solves elliptic partial differential equation pde 
system uses broad categorization direct user form interface requests specific information features problem user performance constraints 
illustrates portion scenario user provides features operator right side domain boundary conditions integral parts pde specifies execution time constraint measured sun sparcstation instance error requirement satisfied 
user wants software fast accurate possible software exists 
rs contacts pythia ii web server user behalf uses knowledge acquired learning methodology perform selection software repository 
rs consults databases performance data determine solver parameters grid lines pde estimates time accuracy recommended solver 
note rs involve larger databases kdd process accesses specialized smaller databases knowledge distilled kdd process 
organized follows 
section describes general methodology selecting recommending scientific software implemented pythia ii 
architecture rs pythia ii approach section 
description data management subsystem pythia ii section 
include database schema appropriate building rs elliptic pde software pell pack library illustrate 
section outlines knowledge discovery components pythia ii 
data flow pythia ii illustrated section 
results applying pythia ii case studies acm transactions mathematical software vol 
june 
houstis comparing earlier results sections 
recommender methodology scientific software rs uses stored information user preferences performance data artifact characteristics cost size 
class artifacts software music 
locate suggest artifacts interest ramakrishnan ramakrishnan resnik varian 
rs software hardware artifacts uses stored performance data population previously encountered problems machines locate suggest efficient artifacts solving previously unseen problems 
recommendation necessary user requests objectives properly represented ordinary database queries 
section describe complexity problem research issues address methodology resolving 
algorithm software selection problem originated early rice 
routine tasks computational science problem ill posed quite complicated 
difficulty due factors space applicable software specific problem subclasses inherently large complex ill understood intractable explore brute force means 
approximating problem space feature space helps introduces intrinsic uncertainty 
depending way problem re space applicable algorithms changes better algorithms sacrifice generality performance customized data structures fine tuned computational code 
specific features problem algorithmic performance information affect algorithm selection strategy 
mapping problem space software algorithm space useful measure success needs indicators domain complexity behavior information relative costs 
inherent uncertainty assessing performance measures particular algorithm problem 
minor implementation differences produce large differences performance analytic estimates unreliable 
techniques needed allow distributed recommender systems coexist cooperate exploit relevant information 
methodology building pythia ii uses knowledge discovery databases kdd process shown table assuming dense population benchmark problems targeted application domain rs methodology uses pronged strategy feature determination problem acm transactions mathematical software vol 
june 
pythia ii table methodology building rs 
methodology similar previous procedures adopted performance evaluation scientific software 
instances performance evaluation scientific software automatic generation relevant knowledge 
note dense population assumption quite challenging application domains 
address aspects 
problem features applicability efficiency software depends significantly features targeted problem domain 
identifying appropriate problem features problem domain fundamental problem software selection 
way problem features affect software complex algorithm selection depend unstable way features 
selections performance solving xy completely different 
simple structure exists actual features specified properly reflect simplicity 
example structure simple linear combination features features cos cos ineffective 
furthermore selection methodology fail features inappropriate measurements attribute value meanings 
attribute value approaches neural networks routinely assign value interpretations numeric features values interpreted ordinal symbolic sense 
pythia ii assumes features defined knowledge engineer 
database schema defining feature form name text follows acm transactions mathematical software vol 
june 
houstis nfeatures integer 
attributes identifying feature features text numeric symbolic textual identification text file feature information example relating feature pde equation name text relation record name equation text name equation features feature text name record identifying features foreign keys identify relation equation features 
instances tables name name pde nfeatures equation pde features feature shows correspondence equation pde feature pde laplacian 
performance evaluation exist established performance evaluation methodologies scientific software houstis rice moore 
important factors contribute quality numerical software illustrate ideas speed accuracy 
pythia ii handle attributes reliability portability documentation data storage scheme 
similar performance evaluation methodology attributes needed application domain 
accuracy measured norm difference computed true solutions guaranteed error estimate 
speed measured time required execute software standard execution environment 
pythia ii ensures performance evaluations consistently outputs automatically coded predicate logic formulas 
resort attribute value encodings situation demands instance straight line approximations performance profiles accuracy versus grid size solvers useful obtain interpolated values grid parameters pde problems 
reasoning learning techniques generating software recommendations pythia ii uses multimodal approach integrating different learning methods leverage individual strengths 
explored implemented strategies case reasoning cbr joshi inductive logic programming ilp bratko muggleton dzeroski muggleton raedt describe section :10.1.1.27.4632:10.1.1.31.1630:10.1.1.35.951
cbr systems obey lazy learning paradigm learning consists solely recording data past experiments help problemsolving sessions 
gain simplicity learning offset acm transactions mathematical software vol 
june 
pythia ii complicated process occurs actual recommendation stage 
evidence psychology suggests people approach judgments experience gained solving similar problems devise strategy solving 
addition cbr systems exploit priori domain knowledge perform sophisticated analyses pertinent data 
original pythia system utilized rudimentary form case reasoning employing characteristic vector representation problem population weerawarana 
ilp systems hand eager learning paradigm attempt construct predicate logic formula positive examples recommendations provided logically derived background knowledge negative example logically derived 
advantages approach lie generality representation background knowledge 
formally task algorithm selection set positive exemplars negative exemplars selection mapping set background knowledge induce definition selection mapping positive example derived negative example derived strict definition impractical approximate characterization called cover utilized places greater emphasis representing negative exemplars opposed representing positive exemplars 
techniques relative general generalization inverse resolution dzeroski applied induce clausal definitions algorithm selection methodology 
forms basis building rs procedures banks selection rules 
ilp prohibitively expensive standard practice restrict hypothesis space proper subset order predicate logic 
commercial systems golem progol muggleton require background knowledge ground meaning base facts provided opposed intensional information :10.1.1.31.1630
renders complexity exponential 
pythia ii investigate domain specific restrictions induction hypotheses analyze strategies 
syntactic semantic restrictions nature induced methodology 
example require pde solver activate linear system solver different order pde solver parts sense 
example semantic restriction consistency checks algorithms inputs 
second incorporate generality ordering guide induction rules prune search space generating plausible hypotheses 
software architecture domain specific rs natural database query interface utilize provide metalevel patterns rule generation 
pythia ii employs restricted forms eager learning id induction decision trees quinlan system 
supervised learning system top induction decision trees set examples uses greedy divide conquer approach 
acm transactions mathematical software vol 
june 
houstis fig 

system architecture pythia ii 
recommender component consists recommender system interface inference engine 
kdd component rest 
decision tree structure internal node labeled name predicting attributes branches internal node labeled values node attribute leaf node labeled class value goal attribute 
training examples tuples domain attribute limited small number values symbolic numerical 
id system uses top irrevocable strategy searches part search space guaranteeing simple necessarily simplest tree 

pythia ii recommender system scientific software section detail software architecture domain specific rs pythia ii see methodology discussed 
design objectives include modeling domain specific data structured representation database schema ii providing facilities generate specific performance data simulation techniques iii automatically collecting storing data iv summarizing generalizing discovering patterns rules capture behavior scientific software system incorporating selected inference engine system 
system architecture layers user interface layer acm transactions mathematical software vol 
june 
data generation data mining inference engine layer relational engine layer database layer 
pythia ii database layer provides permanent storage problem population performance data problem features computed statistical data 
layer relational engine supports extended version sql database query language provides access upper layers 
third layer consists subsystems data generation system data mining system inference engine 
data generation system accesses records defining problem population processes problem execution environment generate performance data 
statistical data analysis pattern extraction modules comprise data mining subsystem 
statistical analysis module uses nonparametric statistical method rank generated performance data hollander wolfe 
pythia ii integrates variety publicly available pattern extraction tools relational learning attribute value learning instance learning techniques bratko muggleton kohavi :10.1.1.31.1630:10.1.1.35.951
tools integration methods discussed section 
design allows pattern finding diverse domains features nominal ordinal numerical graphical user interface top layer allows knowledge engineer system generate knowledge query system facts stored database layer 
recommender user interface includes inference engine 
uses knowledge generated lower layers expert system answer domainspecific questions posed users 
architecture pythia ii extensible defined interfaces components various layers 

data modeling management components pythia ii pythia ii needs powerful adaptable database management system open architecture support data generation data analysis automatic knowledge acquisition inference processes 
design requirements summarized follows provide storage problem population input execution environment structured way parameters features constraints support seamless data access user support full extensibility accommodate changes data size schema 
pythia ii uses postgres stonebraker rowe objectoriented relational dbms database management system supports complex objects easily extended new application acm transactions mathematical software vol :10.1.1.48.1422
june 
houstis domains providing new data types new operators new access methods 
provides facilities active databases inferencing capabilities including forward backward chaining 
supports standard sql language interfaces perl python tcl 
pythia ii relational data model offers abstraction structure problem population domain dependent 
example abstraction standard pde problem includes pde system boundary conditions physical domain approximation grid mesh format pde problem specification components constitutes separate entity set mapped separate table relation 
interactions entities modeled tables representing relationships 
higher level abstraction tables batch execution experiments performance data collection aggregate statistical analysis data mining 
experiment table represents large number problems sequences problem components executed time 
profile table collects sets performance data records profile specification information required analyzer 
predicate table identifies collection profile feature records needed data mining 
illustrate data modeling management pythia ii describe example database schema specification rs elliptic pde software library 
remainder example describe aspects components pythia ii 
design system independent particular case study elements system case study dependent clearly indicated 
data modeling component pythia ii schema specification modified domain scientific software 
pythia ii database mechanisms independent application domain problem population performance measures features depend domain 
problem population 
atomic parts pde problem equation domain boundary conditions initial conditions 
entities defined consistently syntax targeted scientific software 
solution algorithms defined sequence calls library modules parts grid mesh indexer linear system solver triple 
sequences entity contains ordered list 
miscellaneous entities required benchmark include output options fortran code 
schema database records equation sequence follows equation name text record name system text software solve equation integer number equations equations text text describing equations solve text source code file definition acm transactions mathematical software vol 
june 
sequences name text record name system text software provides solver modules integer number modules solution scheme types text array record types grid solver names text array module record names text array module parameters instances case studies follows pythia ii name pde system equations projects data files fortran pde eq name uniform proc jacobi cg system types grid machine dec discr indx solver names rect machine runtime grid point star red black jacobi cg equation field attribute equation record uses syntax pse 
specification defines location parameter replacement attribute provides additional source code attached equation definition 
sequences record shows ordered listing module calls solve particular pde problem 
module call list sequence identifies module type name parameters 
features 
features representations section 
experiments 
experiment derived entity identifies specific pde problem collection pde solver sequences 
generally experiment varies solution algorithms parameters 
information produce set driver programs execute produce performance data 
see schema definition example experiment 

schema specifies targeted hardware platforms characteristics operating system communication libraries execution parameters 
performance data 
performance schema general extensible representation data generated experiments 
instance performance data generated pde experiment shown 
knowledge related data 
processing knowledge related components pythia ii driven profile predicate records acm transactions mathematical software vol 
june 
houstis fig 

experiment table specifies experiment listing components pde problem sets solvers collection sequence records solving 
illustrated represent experiments problems methods features analyzed 
derived data 
results data mining performance database written profile predicate records 
data processed visualization knowledge generation tools 
sample pythia ii instantiation problem population problem specification tables equation domain grid mesh dec discr indx solver triple output parameter option relationship tables equation discr mesh domain parameter solver 
additional tables define problem features execution related information machine tables 
table definitions pythia ii database 
sections give examples tables 

knowledge discovery components pythia ii describe pythia ii components top layers 
data generation pythia ii performance database may contain preexisting performance measures data may produced executing scientific software pythia ii 
scientific software operates entirely black box requirements met integration pythia ii 
section describes requirements illustrates software satisfies 
acm transactions mathematical software vol 
june 
fig 

instance performance data pde experiment 
pythia ii possible define input problem definition information experiment record 
translation experiment executable program handled script written software extracts necessary information experiment record generates files drivers software 
experiment record translated file language definition pde problem solution scheme output requirements 
script written tcl consists lines code 
standard preprocessing programs convert file fortran driver link appropriate libraries produce executable program 
second requirement software able operate batch mode 
case perl scripts execute programs sequential parallel number platforms 
programs created executed manual intervention 
software produce performance measures output 
postprocessing program written specifically convert generated output pythia ii performance records 
program execution insert record performance database 
postprocessing program written tcl lines code perl lines code 
acm transactions mathematical software vol 
june 
houstis table ii 
algorithm ranking table friedman rank sums way layout 
ij performance algorithm problem rank measures 
data generation program generation program execution data collection may take place inside outside pythia ii 
process domain dependent problem definition records software output files depend domain 
data mining data mining pythia ii process extracting filtering performance data analysis generating solver profiles ranks selecting filtering data pattern extraction generating knowledge base 
principal components statistical analysis module analyzer pattern extraction module 
pythia ii runs analyzer separate process configurable input call various data analyzers easily integrated 
statistical analyzer problem domain independent operates fixed schema performance records 
problem domain information distilled number measuring performance program problem 
analyzer assigns performance ranking set algorithms applied problem population 
accesses performance data selected predicate record defines complete set analyzer results input single invocation rules generator 
predicate contains list algorithms rank profile matrix row represents single analyzer run columns identify profile records accessed run 
table ii illustrates predicate profile matrix columns represent algorithms rows represent problems specified profile record 
xij performance values see computed analyzer 
pythia ii currently ranks performance algorithms friedman rank sums hollander wolfe 
distribution free ranking assumes nk data values algorithms problems 
analyzer fill missing values various methods 
friedman ranking proceeds follows problem rank algorithms performances 
rij denote rank xij joint rankings xi xik compute rj rij 
sum problems ranks algorithms average rank algorithm rank algorithms problems 
acm transactions mathematical software vol 
june 
pythia ii compute critical value independent algorithms experimental error 
implies algorithms differ significantly 
assignment single value ij represent performance algorithm simple matter 
comparing execution times parameters varied serious evaluation problem size execution platform number processors parallel code 
analyzer uses method squares approximation observed data accommodate variations problem executions 
relations pairs variables time grid size time number processors represented linearly seen case study 
profiles allow query obtain data variable value 
pattern extraction module provides automatic knowledge acquisition patterns models data rs 
process independent problem domain 
pythia ii extends pythia methodology address algorithm selection problem applying various neuro fuzzy instance learning clustering techniques 
relational model pythia ii automatically handles amount raw data related manipulation 
specific format data pattern extraction process filters transform format fly format required various data mining tools integrated pythia ii 
goal accumulate tools generate knowledge form logic rules rules decision trees 
pythia ii golem muggleton feng empirical single predicate inductive logic programming ilp learning system 
batch system implements relative general generalization principle 
experimented learning methods fuzzy logic neural networks large differences learning abilities 
chose ilp easiest pythia ii selection result systematic study effectiveness learning methods 
pythia ii designed learning component replaced necessary 
golem generates knowledge form logical rules model language order predicate logic 
rules easily utilized rule base expert system 
integrated progol muggleton cn pebls oc available mlc library kohavi :10.1.1.31.1630
inference engine recommender component pythia ii answers user questions inference engine facts generated knowledge discovery process 
domain dependent case study dependent 
describe recommender uses knowledge generated golem 
golem logical rule information compression factor acm transactions mathematical software vol 
june 
houstis ing generalization accuracy 
simple formula number positive negative examples respectively covered related form rule 
information compression factor sorting rules decreasing order 
rules set positive examples covered rule passed recommender asks user specify problem features 
uses clips inference engine check rules match specified features 
rule way placed agenda 
rules sorted decreasing order number examples cover rule covers examples fire inference process determine best algorithm 
recommender goes list positive examples associated fired rule retrieves example features common user problem 
fact base recommender processed example provide parameters user needs advice 
fact base consists raw performance data stored database 
information accessed queries generated fly user objectives selections 
user objectives met recommender decides best answer give weights specified user performance criterion 
case studies sections final step recommendation best pde solver 
provides solver parameters grid needed achieve solution accuracy time limitations 
user interface pythia ii accomplish knowledge discovery graphical interface example creating database records problem population experiments sql commands directly inside postgres environment 
generating executable programs experiments separate process called domain specific execution environment called outside pythia ii 
executing programs process controlled scripts invoked pythia ii called outside pythia ii operate generated files directory 
collecting data data collector separate domain specific process called pythia ii 
graphical interfaces assist tasks useful knowledge engineers unfamiliar structure pythia ii postgres sql language 
interfaces provided pythia ii shown 
graphical interface postgres database 
pythia ii record form records type acm transactions mathematical software vol 
june 
fig 

pythia ii top level window 
pythia ii selected editing 
similarly facilitates tasks involved data generation process frees user worrying details generated programs stored scripts available raw output data located encompasses data analysis knowledge discovery 
experienced users perform tasks inside pythia ii 
template query extract performance data statistical analyzer 
query uses profile record may access hundreds performance records build analyzer input file 
pattern matching input specification equally difficult build 
presents simple menu system walks user steps 
integrated olston easy integrated visual environment built top postgres interacts pythia ii database naturally 

data flow pythia ii pythia ii interface knowledge engineer users 
describe data flow interfaces main components pythia ii perspective interfaces 
knowledge engineer perspective data flow pythia ii shown boxes represent stored data edges represent operations database self edges represent external programs 
knowledge engineer begins populating problem database specifying domain terms relational data model match pythia ii database schema 
extensible dynamic schema possible 
postgres restriction imposed traditional relational model attributes relation atomic 
referred normal form nf database systems 
acm transactions mathematical software vol 
june 
houstis fig 

data flow knowledge engineer user interface 
experiment combines problem records groups high level problem specification generated program transformation experiment record input file execution 
problem execution environment invokes appropriate scientific software generate data 
example instantiation referred sections execution environment consists houstis 
execution generates number output files containing performance information related solving problem 
input uses specific schema problem record output format specified system specific user selected file template 
template lists program collect required output data 
data records keep logical called foreign keys problem definition records performance matched problem features executing way joins pattern extraction 
statistical analyzer uses performance data ranking parameter selected user 
ranking produces ordering parameters statistically significant performance data shows significant difference parameters shown tied rank 
predicate record defines collection profile records pattern extraction allows knowledge engineer change set input profile records easily updating database record 
filter program converts data input format required pattern extraction programs 
pythia ii currently supports golem progol mlc machine learning library library 
programs generate output form logic rules rules decision trees graphs categorization purposes 
process tools neural networks genetic algorithms fuzzy logic tool boxes rough set systems 
user perspective recommender interface adapt variety user needs 
users rs scientific computing interested questions regarding accuracy solution method performance hardware system optimal number processors parallel machine achieve certain accuracy keeping execution time limit acm transactions mathematical software vol 
june 
pythia ii allows users specify problem characteristics plus performance objectives constraints 
system uses facts provide user best inferred solution problem 
user objective satisfied system tries satisfy objectives accuracy memory constraints ordering implied user performance weights 

case study performance effects singularities elliptic pde solvers validate pythia ii underlying kdd process reconsider performance evaluation population dimensional singular elliptic pde problems houstis rice 
algorithm selection problem domain select algorithm solve lu bu relative error time pythia ii second order linear elliptic operator differential operator order derivatives rectangle performance criteria constraints 
performance database description study pythia ii collects tables execution times errors solvers various grid sizes 
error maximum absolute error grid divided maximum absolute value pde solution 
grids considered 
pde solvers pt point star plus band gauss elimination coll hermite cubic collocation plus band gauss elimination dcg conjugate gradient order dcg conjugate gradient order fft fft order fast fourier transform point star fft fft order fast fourier transform point star fft fft order fast fourier transform th order point star defining population pdes experiments required equation records parameter sets rectangle domain records sets boundary conditions records grid records indexing linear solver triple records corresponding param acm transactions mathematical software vol 
june 
houstis table iii 
pythia ii process applied case study eters set solver sequence records 
components experiments specified defining collection pde programs involving solver sequences pde problem 
examples records section 
experiments executed sparcstation mb memory running solaris pythia ii execution environment see table iii 
performance records created 
data mining knowledge discovery process execution finished performance database created 
interface access predicate profile records created case study 
rankings produced analyzer pde problem example 
fft 
fft 
dcg 
fft 
coll 
dcg 
pt 
frequency solver best pdes fft fft coll dcg pt fft dcg note solvers applicable pdes 
rankings pde problems associated features see table iv mine rules 
examples rules shown 
rule indicates method cg best problem laplace operator right hand side singular 
best method cg best method fft point order best method fft point order acm transactions mathematical software vol 
june 
pythia ii table iv 
features problem population benchmark case study best method fft point order best method fft point order best method fft point order best method cg best method cg best method cg best method hermite collocation best method hermite collocation knowledge discovery outcomes rules discovered confirm assertion established statistical methods houstis rice higher order methods better elliptic pdes singularities 
confirm general hypothesis strong correlation order method efficiency 
importantly rules impose ordering various solvers problems considered study 
interestingly ranking corresponds closely subjective rankings published earlier see table 
shows simple rules capture complexity algorithm selection domain 

case study effect mixed boundary conditions performance numerical methods apply pythia ii analyze effect different boundary condition types performance elliptic pde solvers considered study acm transactions mathematical software vol 
june 
houstis table listing rankings generated pythia ii parentheses subjective rankings reported houstis rice 
pdes performance evaluation form lu au xx cu yy du eu fu bu su parameters determine strength derivative term 
coefficients right hand sides functions rectangle 
numerical methods considered modules pt coll dcg dcg listed section plus mg multigrid mg 
boundary condition types defined follows dirichlet sides 
mixed su sides acm transactions mathematical software vol 
june 
pythia ii table vi 
sample predicate profile information relative elapsed times analysis mixed vs dirichlet problem executions nearly neumann sun sides 
pde equation paired boundary condition types associated experiments 
experiment consists problem defined pde equation boundary condition solved methods uniform grids 
program executions pde performance data elapsed solver time various error measures collected 
performance data generation collection analysis pythia ii database records equations domains boundary conditions parameters modules solver sequences experiments defined pde programs built executed pythia ii problem execution environment 
experiments executed sparcstation sunos mb memory 
records inserted performance database 
statistical analysis rules generation handled appropriate predicate profile records identify parameters controlling tasks 
predicate names matrix profile records identify number type analyzer invocations 
identifies boundary condition features 
analyzer rankings predicate feature specifications handed rules generation process 
table vi lists part required predicate information 
predicate controls analysis details handled profile records 
profile record identifies fields performance data extracted acm transactions mathematical software vol 
june 
houstis manipulated experiment profiles analyzer built 
result analysis ranking method performance selected experiments 
query posed database profile extracts exactly information see table vi needed analyzer answer question 
complex query building analyzer input data determined profile field entries axis axis field matching 
case profile record builds sets points numerical method values grid points values relative elapsed time changes mixed boundary conditions respect dirichlet conditions changes elapsed time neumann conditions respect dirichlet conditions relative changes error derivative conditions respect dirichlet conditions 
predicates profiles 
knowledge discovery outcomes rules derived case study consistent hypothesis stated 
analysis rankings relative elapsed time profiles described 
performance numerical methods degraded derivatives boundary conditions 
profile graphs values relative elapsed time changes mixed neumann problems respect dirichlet problems mix mix dir dir neu neu dir dir generated analyzer methods grid values 
observed values methods problem sizes 
presence derivative terms slows execution substantially coll solver see 
coll module affected 
specifically increase elapsed time derivative term added coll 
note relative elapsed time coll total elapsed time 
frequencies solver best considering relative time increase changing dirichlet mixed conditions coll pt dcg mg dcg frequencies solver best changing dirichlet neumann conditions coll dcg dcg mg pt final rules generated pythia ii elapsed time predicates acm transactions mathematical software vol 
june 
pythia ii fig 

profile graph depicting relative change execution times dirichlet mixed problems function grid size pde solvers considered 
best method hermite collocation dir mix 
best method hermite collocation dir neu 
fourth order modules coll dcg affected second order modules 
statistics show fourth order modules best time see method ranking profile pde generated dir mix predicate relative time 
rankings show fourth order modules affected mixed conditions neumann conditions mg pt methods perform worst addition derivatives boundary conditions 
consider ranking methods pde boundary condition pairs profile graphs involving problem size versus elapsed time 
acm transactions mathematical software vol 
june 
houstis analysis consider relative increase execution time different boundary condition types ranks methods pde problems case study 
analysis ranks mg best method 
selected time fastest method pde problems 
analysis showed methods best worst ranking fixed pde equation possible boundary conditions 
addition results show methods differ significantly ranking respect execution times collection pde problems 
adve bagrodia brown deelman dube houstis rice teller vernon 
poems performance large parallel adaptive computational systems 
ieee trans 
soft 
eng appear 
rice houstis 
system performance evaluation partial differential equations software 
ieee transactions software engineering se 
bratko muggleton 
applications inductive logic programming 
comm 
acm 
houstis lynch rice 
performance collocation galerkin methods hermite 
siam journal numerical analysis 
rice 
performance numerical software methods elliptic problems mixed boundary conditions 
numer 
meth 
partial differential eqs 

dzeroski 
inductive logic programming knowledge discovery databases 
fayyad piatetsky shapiro smyth uthurusamy eds advances knowledge discovery data mining pp 

aaai press mit press 
fayyad piatetsky shapiro smyth 
data mining knowledge discovery overview 
fayyad piatetsky shapiro smyth uthurusamy eds advances knowledge discovery data mining pp 

aaai press mit press 
hollander wolfe 
non parametric statistical methods 
john wiley sons 
houstis rice 
high order methods elliptic partial differential equations singularities 
inter 
numer 
meth 
engin 

houstis houstis rice 
athena knowledge system 
symbolic numeric data analysis learning 
houstis lynch rice 
evaluation numerical methods elliptic partial differential equations 
journal comp 
physics 
houstis rice weerawarana wang 
parallel problem solving environment pde applications multicomputer platforms 
acm trans 
math 
soft 

houstis mitchell 
performance evaluation algorithms mildly nonlinear elliptic partial differential equations 
inter 
numer 
meth 
engin 

joshi weerawarana ramakrishnan houstis rice 
support step automated solution pdes 
special joint issue ieee computer ieee computational science engineering vol 
pages 
kohavi 
mlc developments data mining mlc 
ins kasif ed working notes aaai fall symposia learning complex behaviors adaptive intelligent systems pp 

aaai press 
acm transactions mathematical software vol 
june 
moore flaherty 
automatic numerical solution partial differential equations 
intelligent mathematical software systems north holland pp 

muggleton 
inverse entailment progol 
new generation computing vol 
pages 
muggleton feng 
efficient induction logic programs 
arikawa goto yokomori eds proceedings international conference algorithmic learning theory pp 

japanese society artificial intelligence tokyo 
muggleton raedt 
inductive logic programming theory methods 
journal logic programming 
olston woodruff aiken chu lin stonebraker 

proceedings acm sigmod conference management data seattle washington pp 

quinlan 
induction decision trees 
machine learning 
ramakrishnan 
recommender systems problem solving environments 
ph thesis dept computer sciences purdue university 
ramakrishnan houstis rice 
recommender systems problem solving environments 
kautz ed working notes aaai workshop recommender systems 
aaai mit press 
ramakrishnan rice houstis 
gauss line algorithm recommender system dimensional numerical quadrature 
acm trans 
math 
soft appear 
resnik varian 
recommender systems 
communications acm vol 
pages 
rice 
algorithm selection problem 
advances computers 
rice 
performance analysis methods solve galerkin method equations 
lin 
alg 
appl 

rice 
software performance evaluation papers toms 
technical report csd tr dept comp 
sci purdue university 
stonebraker rowe 
design postgres 
proceedings acm sigmod conference management data pp 

verykios 
knowledge discovery scientific databases 
ph thesis computer science department purdue university 
verykios houstis rice 
mining performance complex systems 
ieee international conference information intelligence systems pp 

ieee computer society press 
verykios houstis rice 
knowledge discovery methodology performance evaluation scientific software 
neural parallel scientific computations appear 
weerawarana houstis rice joshi houstis 
pythia knowledge system select scientific algorithms 
acm trans 
math 
soft 

received october revised march may accepted may pythia ii acm transactions mathematical software vol 
june 
