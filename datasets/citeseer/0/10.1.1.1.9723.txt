appears freitag jones lengauer schek eds object orientation parallelism persistence kluwer academic publishers coordination negotiated transactions jean marc andreoli rank xerox research center grenoble france usually task coordination systems distinguish aspects task execution functional aspect concerned tasks performed system 
behavioral aspect concerns particular tasks executed 
technological aspect concerns tasks performed 
coordination systems generally provide tools support technological aspect open systems ambition interoperate various systems platforms implement actual actions 
abstracting part activities coordination particularly amenable declarative kind specifications offered rule frameworks 
working tasks done part requires negotiation coordinator external systems supposed perform tasks tasks appropriate order part requires form synchronization 
claim aspects negotiation synchronization elegantly supported rule framework mechanisms past successfully integrated rules respectively constraint propagation solving transactions 
situation summarized table aspect mechanism involved rule framework negotiation constraint propagation solving synchronization transaction propose rule coordination framework negotiation synchronization aspects specified terms respectively constraint solving transactions 
motivations coordination issue occurs different situations 
low level various partners communication protocol coordinate activities achieve communication pattern example reliable communication top unreliable network 
spectrum high level participants workgroup coordinate activities achieve expected output group 
spite similarities important differences extreme cases 
case coordination concerns activities homogeneous level coordinated black boxes capable sending receiving messages coordinate basic actions order achieve requested communication behavior 
case coordination system take account hand wide diversity existing computing devices systems members group rely hand diversity behaviors participants 
participants case fully autonomous software entities support heterogeneous systems human decision making processes 
scenario acme produces device includes electrical component mechanical component 
specifications components provided respectively electrical engineer mechanical engineer team engineers 
produced design 
designs checked approved technical manager financial manager basis reports produced engineers 
global coordinated behavior may fact translate complex negotiations various participants 
example reading report electrical engineer technical manager realizes mistake specification 
immediately informs engineer produces new design report required modification possible deadline 
discussion may occur explore alternate solutions 
complex case occurs reading reports electrical engineer mechanical engineer technical manager realizes specifications designs components correct problems assembling 
example heat sensitive element mechanical component may close heat generating element electrical component 
technical manager requires modifications designs performed simultaneously atomically 
case modifications impossible modification request cancelled partially totally alternate solutions explored 
leads form tripartite generally negotiation fully autonomous partners 
clearly negotiations possibly leading concrete modifications world performed concurrently risk inconsistencies may appear 
example financial controller may require modification design negotiation occurs technical side 
modification executed ins outs ongoing technical negotiation may completely disrupted 
mean negotiation restarted scratch aware modifications take appropriate steps 
certain degree isolation maintained different negotiations modifications designs overlap uncontrolled way 
scenario appears form transactional behavior interleaved negotiation processes traditional characteristic properties transactions atomicity consistency isolation duration known acid need enforced strictly 
approach goal design coordination system capable supporting kind negotiated transactions illustrated previous example 
transactions long lived occur autonomous software agents naturally represented active objects inherently distributed concurrent 
approach keep basic twophase commit mechanism traditional database transactions way maintaining form consistency distributed objects incorporate larger negotiation mechanism 
purely transactional operations invoked successful negotiations enact agreements achieved 
transactions may require short lived known limitations phase commit negotiations occur may long lived fact may permanent processes 
approach coordination process involves hand set participants may autonomous software agents human agents graphical user interfaces hand coordinator attempt ensure global coordinated behavior participants 
participants may diverse interface outside world directly connected coordinators 
consequently assume participant wrapped inside specific piece software precisely called wrapper capable side talk participant appropriate specific channels offering side homogeneous interface coordinators connect 
conceptually general level participant viewed autonomous agent managing set resources 
resource set need explicitly implemented participant 
essential difference database systems generally designed handle explicit sets resources encoded records 
sample scenario section engineer participant handles resources encoding say elements computer assisted designs 
set resources consists ongoing past designs realized engineer designs potentially produce 
description past designs may explicit obviously potential designs represented implicitly 
activity engineer precisely consists transformations implicit explicit descriptions 
occurs participant initiative answer request outside world anticipation requests reason 
dialogue coordinators participants propose protocol assumes clientserver architecture coordinators client side attempt protocol manipulate resources held participants server side order achieve coordination goal expressed terms expected global behavior 
basically protocol distinguishes phases operations coordinator may execute participants preparation phase determines actions coordinator may take achieve goal performance phase schedules executes monitors actions determined phase notification phase generates events corresponding specified stages achievement coordinator goal 
thread activity coordinator composed phases sequence different threads interleaved phases deeply interwoven 
rule coordination section describes principles protocol rule coordination system called clf coordination language facility 
provides basis negotiation framework described section 
manipulating resources rules production rules offer convenient formalism express kind manipulations coordinator may wish perform resources number participants 
basically participant viewed bag multiset resources production rules express multiset rewriting transformations 
left hand side rule consists set tokens represent resources removed participants right hand side specifies set tokens representing resources inserted 
insertions removals may concern different participants rules read transactions participants 
particular left hand side rule specifies removal resource participant removal resource participant removals occur atomically meaning application rule stable state example removed situation different right hand side assume inserting resource participant fail 
fact difference operations insertion removal attach particular semantics operations implemented participants side 
example section rule modif req new design new design 
report changes token modif req represents specification modification request electrical mechanical designs belongs technical manager 
tokens new design new design represent actual modifications designs proposed belonging respectively electrical mechanical engineer 
token report changes represent report performed changes belongs example production unit implement change 
note rule simplified syntax rule written programmer coordinator show dependencies different tokens concern modification request 
realistic assume tokens appear sides rules represent explicit resources 
participants may explicit representation resources potentially 
fact tokens represent resource properties resources token left hand resp 
right hand side rule means remove resp 
insert resource satisfying property 
basic protocol explain phases clf protocol preparation performance notification invoked rules coordinator 
fig 
gives overview mechanism 
preparation phase rule tokens represent resource properties directly resources preparation phase application rule select resource token left hand side 
resource selected token satisfy property expressed token 
coordinator selection delegate task appropriate participants 
achieved invoking inquire operation clf protocol participants 
consider different inquire operations ordered related 
explained section 
purpose simplicity assume token coordinator knowledge participants capable processing inquiry token furthermore participant token 
example coordinator initialized table mapping token occurring set rules assuming static appropriate participant 
means ignore problems information search coordinator knows fetch information requires information mobility knowledge static 
point time may resources participant satisfy property expressed token set may evolve time due changes internal state participant 
output inquire operation may spread long possibly infinite period time 
inquire operation deferred synchronous kind request generates potentially stream answers 
furthermore resources may explicitly implicitly implemented participants resources satisfying token may explicitly potentially 
potential candidate resources token converted explicit resources inquiry transformation may irreversible belong preparation phase 
overcome problem assume coordinator participant communication layer action action action action inquire token preparation phase insert token notification phase reserve action success confirm action performance phase clf protocol coordinating rule inquire operation return explicit resource identifiers returns identifiers actions capable requested performance phase making explicit removing resource satisfying property expressed token passed argument inquiry 
preparation phase rule summarized preparation phase assignment action token left hand side rule 
sample scenario section inquiry may consist request modification design expressed details replace element design element model 
request may require rewiring connections element possibly reorganization surrounding elements may achieved ways 
engineer explore different alternatives propose answers inquiry implementing explicitly done performance phase 
performance phase action assigned token left hand side rule preparation phase rule applicable coordinator selects application enters performance phase 
basically phase consists remotely executing actions corresponding participants single transaction 
performance phase execution actions assigned left hand side rule single short lived transaction 
clf protocol provides rudimentary mechanism achieve transactional behavior phase commit protocol 
client side coordinator invoke basic operations protocol reserve confirm cancel 
operation takes argument transaction identifier action identifier provided result inquire operation 
information attached transaction identifiers need maintained separate process 
reserve operation contract coordinator participant handles action participant commits successfully perform action request coordinator 
means participant anticipate set resources action going manipulate freeze state part prevent manipulations performed frozen part 
achieved responsibility participant 
course participant may refuse contract 
obvious cause refusal occurs preparation phase inquire operation returns action relies existence state resource disappeared irreversibly modified reservation requested 
reserve operation returns success failure case introduced 
purely synchronous operation 
confirm cancel operations rely contract enacted reserve operation 
reserved action confirmed case action executed cancelled case contract ended participant freed commitment 
action confirmed contract ensures action executed successfully 
cancellation succeeds 
cases result returned operation purely asynchronous 
reserve operation may lead precautions taken classical situations deadlock transactions wait free resource 
assume participant responsibility lift deadlocks involving competing transactions different coordinators 
achieve assume transaction identifiers totally ordered arbitrary priority order 
result reserve operation success failure special value busy 
reservation conflicts successful block belongs transaction lower priority return special value busy 
client informed conflict take appropriate actions see section 
notification phase performance phase rule successfully passed resources selected tokens left hand side removed rule enters notification phase new resources attached tokens right hand side inserted inside participants 
notification phase asynchronous insertion resources satisfying tokens righthand side rule 
insert operation clf protocol takes token argument inserts resource satisfying token 
fact insertion may trigger transformation state participant implements returns result 
coordinators point view succeeds potential failure accounted level coordinator operation occur transaction performance phase 
inserting resource participant may course wake suspended inquiries participant changing state 
token occurs left right hand side rule usual policy attach resource occurrences needed remove resource insert immediately 
tokens ensure resource rule applied 
reserved usual way transaction successful corresponding reservation simply cancelled confirmed insertion done 
inference engine inference mechanism coordinator continuously attempts apply rules clf protocol access participants 
basically token left hand side rule inquiry invoked coordinator computes possible combinations actions returned inquiries combination consisting action token left hand side 
process generating combinations similar principle rete algorithm production systems 
combination complete executed transaction 
actions reserved 
reservations succeed confirmed 
reservations fails cancelled 
reservations yields busy cancelled combination tried 
words case conflict lowest priority transactions pre empted 
method lift deadlocks phase commit mechanism crude pessimistic forces cancellation re reservation transactions conflict conflict lead deadlock 
transaction monitors implement sophisticated scheduling techniques allowing maximal concurrency transactions basis detailed analysis conflicting operations 
argue minimalist approach simplifies design wrappers legacy participants may built transactional environment 
example absurd wrap participant acts simple event generator graphical user interface inside complex transaction monitor 
assume set ground rules opposed rule patterns introduced section finite preparation phase invokes inquire operations divided distinct successive phase inquire operation invoked token occurring left hand side rule hypothesis finite number tokens answers collected combined passed performance phase charge transactions notification phase 
set rules infinite impossible invoke inquire operations collect answers 
phases interleaved way 
negotiation plays role 
negotiation coordination section introduce negotiation mechanism preparation phase turn long lived process possibly living time time launches short lived transactions performance phase 
order inquiry operations rule invoked preparation phase interactions 
achieve assume tokens resource properties simple structure form called predicate token taken finite set predicate symbols values taken domain 
furthermore assume rule set extension represented finite set rule patterns rule pattern representing set actual rules 
rule pattern rule tokens uses token patterns form xn xn variable names local rule 
rule pattern stands set ground instances obtained consistently replacing token patterns variables arbitrary values domain 
assuming infinite domain clear rule pattern represents infinitely ground rules fortiori finite set rule patterns 
simplistic strategy section preparation phase works finite sets ground rules 
incomplete requests information thresholds method handle kind infinite sets ground rules proposed relies assumption inquire operations preparation phase deal tokens token patterns tokens fully instantiated 
way infinite sets inquire operations corresponding different ground instances pattern invoked single operation non ground instance pattern 
words preparation phase deal incomplete requests 
inquiries non destructive cost realistic invoke inquire operation token pattern sufficiently informed 
sample scenario section mean requesting say engineer produce possible designs specification sense 
assume inquire operation invoked coordinator incompletely instantiated token patterns degree instantiation pattern reach certain threshold operation correctly processed participant 
various ways introduce notion threshold preparation phase 
discuss ffl static approach assumes coordinator initialized knowledge capabilities participants decide threshold reached 
ffl dynamic approach assume knowledge relies extensions protocol order coordinators dynamically acquire knowledge 
static thresholds signatures solution section assumes knowledge thresholds statically attached predicates program coordinator 
coordinator capable decide inquire operation sufficiently instantiated invoked correctly information provided initialization time 
mode declarations initialization information appears signature table mapping predicate mode declarations 
mode declaration partitions arguments predicate input parameters fully instantiated inquiry mode output parameters returned inquiry mode instantiated 
thresholds depend arguments pattern fully instantiated 
example mode declaration 
specifies mode inquire operation invoked token pattern form provide values arguments leave uninstantiated argument action identifier normally returned answer inquiry coupled possible instantiation output parameters example 
rule patterns defining coordinator checked compile time signature 
checking rule pattern signature consists selecting token pattern left hand side rule pattern mode attached signature predicate token pattern 
mode assignment considered allowed variable occurring input position token pattern occurs output position left hand side rule pattern ii variable occur twice output positions left hand side rule pattern 
condition requires value consumed produced second condition precludes value produced different places consumed 
rule pattern correct signature exists allowed mode assignment 
ambiguous resp 
ill formed resp 
allowed mode assignments 
rule pattern correct signature coordinator interleaving different inquiries preparation phase follows mode assignment rule rule inquire operation token pattern invoked variables input positions mode assigned token pattern instantiated 
possibility multiple reply inquire operation leads exploration search tree see section 
search loop goal search loop preparation phase generate possible instantiations rules 
may zero possible instantiation passed performance phase 
combination token patterns partial assignment variables initially empty set actions ff initially empty algorithm fig 
instantiates progressively variables token patterns 
definition allowed mode assignments precludes possibility variable instantiated different inquire operations require identity tests values coordinator knows 
procedure search ff combination token patterns assignment variables ff set actions non empty pattern input variables instantiated psi fp stream replies returned inquire foreach reply spawn output variables assignment attached reply action attached reply call search phi ff phi fag empty pass ff performance phase search algorithm sequentiality algorithm fig 
intrinsic independent tokens searched parallel 
example signature 


left hand side rule pattern consists preparation phase rule pattern consist inquire operation argument instantiated required mode ii answer previous request simultaneous inquire operations respectively argument instantiated case required mode iii pair answers previous requests inquire operation arguments instantiated required mode 
dynamic thresholds constraints signatures specify thresholds enable coordinator statically determine immediately initialized thresholds instantiation enable disable inquiries 
hand solution section allows dynamic construction thresholds achieved negotiations participants runtime 
negotiators underlying idea inquiry invoked preparation phase invoked fully unspecified token pattern returning directly stream instantiations pattern corresponding actions returns stream negotiators turn charge determining possible instantiations variables pattern corresponding actions 
negotiator token pattern charge producing instantiations actions capable extracting participant lives resources satisfying token 
level indirection enables full flexibility determination instantiations variables left hand side rule may occur token patterns corresponding negotiators agree instantiations shared variables 
agreement reached negotiation term negotiator fact similar nature constraint propagation resolution negotiator broadcasting constraints variables listening constraints sent negotiators shares variable 
rule approach taken clf fully consistent approach negotiation integrated clf protocol way notion constraint traditionally integrated rule frameworks 
precisely protocol inspired popular form constraint propagation range propagation successfully implemented rulebased systems 
course keep ontology specifying range constraints implemented coordinator may know domains manipulates 
introduce definitions definition scope negotiator set pairs consisting action token action capable extracting resource satisfying token 
scope negotiator set resources participant need implemented extension 
assume inquiry token pattern fully un instantiated returns negotiators scope contains tokens form values domain 
negotiation ranges reduced eventually reduced singletons 
definition token range form dn predicate dn subsets domain 
token range negotiator smallest token range includes tokens scope 
enrich clf protocol operation negotiators propagate applies pair negotiators returns stream new negotiators 
negotiator returned stream satisfies properties specialization token attached scope subset communication xn ym tokens attached dn em token ranges variables identical words propagate operation forwards information possible shared variables attached tokens 
notice propagation void cases ffl tokens attached share variable ffl identical true bn token range cases may assume propagate operation returns special value void distinguished empty stream characterizes inconsistent constraints 
consider example negotiators scopes consist tokens form denotes entries multi database bibliographical 
token range denote ranges entries relative documents published respectively 
propagate operation applied expected return stream negotiators scope cover entries concerning published 
ways build stream 
obvious way return single negotiator reduced scope 
way may return negotiators charge respectively periods 
split may justified example underlying multidatabase partitioned 
knowledge publication year considered threshold authorizing actual retrieval corresponding entries negotiator may replaced stream individual negotiators entry document published second negotiator may wait information provided invocation propagate operation proceed 
negotiators individual entries refined initial negotiator capable triggering propagations 
interleaving different operations preparation phase implements range constraint propagation 
basically token pattern left hand side rule pattern inquiry invoked coordinator computes possible combinations negotiators returned inquiries combination consisting negotiator token pattern left hand side 
combination complete enters negotiation loop see section returning stream combinations negotiators ready agree 
agreeing combination stream finalized attempting reserve operation negotiator 
reserve operation attempted negotiator scope reduced singleton token attached single element scope returned corresponding action reserved operation fails 
rest protocol usual performance notification phases 
negotiation loop goal negotiation loop preparation phase generate agreements negotiators 
may zero possible agreements passed performance phase 
combination negotiators token pattern left hand side rule pattern negotiation algorithm fig 
recursively attempts get closer agreement propagating information negotiators yielding refined combinations negotiators 
agreement reached possible propagations negotiators combination void 
formally procedure negotiate combination negotiators foreach psi fn foreach stream negotiators returned propagate void foreach spawn call negotiate phi fng exit pass ready agree performance phase negotiation algorithm definition agreement combination ffl negotiator corresponds negotiator token pattern left hand side rule scope included scope ffl propagation distinct negotiators void 
example consider rule left hand side consists inquire operation may return negotiators inquire operations return single negotiator respectively combinations passed negotiation algorithm 
algorithm may propagate resp 
yielding case stream new negotiators case stream single negotiator combinations propagation goes combinations till propagate operation void 
point combination ready performance phase 
notice important propagation may return streams results single results 
single result force scope obtained negotiator cover possible tokens satisfying propagated constraint range argument specific propagation 
hand negotiator stream results may cover subset possible tokens satisfying propagated constraint subset new information derived individual arguments token 
responsibility negotiator split scope way return stream individual pieces 
decision taken basis information thresholds bibliographic database example 
combination reached negotiation loop enters performance phase may happen scope negotiators reduced singleton sets 
case means negotiation failed reserve operation negotiators fails 
reservation fails conditions participant holds culprit negotiator may learn negotiation revise strategy splitting negotiators scopes revise information thresholds 
related relates different areas objects active objects actors research objects initially focused design individual objects re usability 
assumption easy build complex applications assembling objects having interact standard mechanisms mainly synchronous method invocation passive objects asynchronous message passing active objects 
quickly appeared patterns interaction objects quite complex required specific programming mechanisms 
lead focus distributed object coordination primarily concerned concern script programming tcl meta control actors shared message services linda multi agent systems distributed ai focused providing sophisticated models interaction intelligent agents problem solving see contract net protocol particular speech acts 
point view verbs protocol inquire propagate insert reserve 
seen speech acts 
relaxed transaction models workflow strict acid model database transactions extended relaxed different ways particular coordination tasks workflow transactions federated databases 
rules point view extensions eca rules logic rules la prolog 
main difference approach try relax extend strict acid transaction models integrate larger framework including particular preparation phase plans actions performed transactional performance phase 
focus comes transactions model execution 
constraints important influence comes research constraints 
negotiation algorithm inspired general constraint satisfaction algorithms see overview 
constraints integrated naturally deductive rule systems particular prolog chip system successfully production rules 
main difference approach views constraints way improve efficiency search algorithms computation model interaction autonomous agents 
sense closer constraints ccp 
characteristic algorithm integrates choice mechanism propagate operation may return stream answers inside constraint satisfaction algorithm improves expressiveness course cost terms efficiency 
shown notions constraint transaction mixed traditional way rules natural way specify negotiation synchronization aspects rule coordination system deal main aspects coordination informally captured questions 
propose protocol coordinator participants delegates participants actual operations required execution coordinator part 
allows away real nature participants active objects implementing operations protocol directly wrappers 
wish people coordination technologies team rank xerox research centre grenoble lab john lamping palo alto research centre helpful discussions topic 
anonymous referee comments helped lot improving 
aksit bosch bergmans 
abstracting object interactions composition filters 
nierstrasz editors object distributed processing 
springer verlag berlin germany 

andreoli freeman pareschi 
coordination language facility coordination distributed objects 
theory practice object systems 
cook harris 
open scripting architecture automating integrating customizing applications 
www com william papers toc html 
dayal hsu ladin 
organizing long running activities triggers transactions 
proc 
intl 
conf 
management data atlantic city nj 
www page www xrce xerox com research ct home html 
schek weikum 
semantics multilevel transaction management federated systems 
proc 
icde houston tx 
dincbas van hentenryck simonis graf 
constraint logic programming language chip 
proc 
fgcs 
forgy 
rete fast algorithm pattern object pattern match problem 
artificial intelligence 
agha 
language framework multi object coordination 
proc 
ecoop kaiserslautern germany 
gelernter 
generative communication linda 
acm transactions programming languages systems 
helm holland 
contracts specifying behavioral compositions object oriented systems 
proc 
oopsla ecoop ottawa ont canada 
jablonski 
transaction support activity management 
proc 
international workshop high performance transaction systems asilomar ca 
jaffar 
lassez 
constraint logic programming 
proc 
th acm popl symposium munich germany 
kuhn elmagarmid 
multi database transaction query processing logic 
elmagarmid editor database transaction models advanced applications 
morgan kaufmann publishers san mateo ca 
kumar 
algorithms constraint satisfaction problems 
ai magazine spring 
le provost wallace 
generalized constraint propagation clp scheme 
journal logic programming 
medina mora winograd flores flores 
action workflow approach workflow management technology 
proc 
cscw 
rusinkiewicz sheth 
specification execution transactional workflows 
kim editor modern database systems 
addison wesley reading ma 
saraswat 
concurrent constraint programming languages 
phd thesis carnegie mellon university pittsburg pa 
smith 
contract net protocol high level communication control distributed problem solver 
ieee transactions computing 
smolka 
oz programming language multi agent systems 
van hentenryck saraswat editors principles practice constraint programming 
mit press cambridge ma 
tambe rosenbloom 
investigating production system representation non combinatorial match 
artificial intelligence 
van hentenryck 
constraint satisfaction logic programming 
mit press cambridge ma 
wachter reuter 
contracts model 
elmagarmid editor database transaction models advanced applications 
morgan kaufmann publishers san mateo ca 
weikum 

concepts applications multilevel transactions open nested transactions 
elmagarmid editor database transaction models advanced applications 
morgan kaufmann publishers san mateo ca 
winograd 
language action perspective design cooperative 
human computer interaction 
yellin strom 
interfaces protocols semi automatic construction software adaptors 
proc 
oopsla portland 

