theory comput 
systems doi distributed object location dynamic network kirsten hildrum john kubiatowicz satish rao ben zhao computer science division university california berkeley berkeley ca usa hildrum cs berkeley edu theory computing systems springer verlag new york llc 
modern networking applications replicate data services widely leading need location independent routing ability route queries objects names independent objects physical locations 
important properties routing infrastructure routing locality rapid adaptation arriving departing nodes 
show properties efficiently achieved certain network topologies 
new distributed algorithm solve nearest neighbor problem networks 
describe solution context tapestry overlay network infrastructure employs techniques proposed plaxton 

today chaotic network data services mobile replicated widely availability durability locality 
lead renewed interest techniques routing queries objects names independent locations 
notion routing queries forwarded node node reach destinations 
location independent routing problem spawned host proposals context data sharing infrastructures oceanstore farsite cfs past :10.1.1.115.4299
permit locality optimizations important routing process network hops possible hops short possible 
research supported nsf career award ani nfs itr award ccr nsf graduate research fellowship uc micro award nsf ccr 
locality mean ability exploit local resources remote ones possible 
hildrum kubiatowicz rao zhao properties location independent routing infrastructure include 
deterministic location objects located exist network 

routing locality routes low stretch just small number application level hops 
sending queries nearest copy shortest path possible ideal 

minimality load balance infrastructure place undue stress components implies minimal storage balanced computational load 

dynamic membership system adapt arriving departing nodes maintaining properties 
clearly desirable property guaranteed existing peer peer systems gnutella freenet :10.1.1.111.1818:10.1.1.10.4919
simple object location routing scheme employ centralized directory object locations 
servers publish existence objects inserting entries directory 
clients send queries directory forwards destinations 
solution simple induces heavy load directory server 
nearby server happens contain object client interact potentially distant directory server 
average routing latency technique proportional average diameter network independent actual distance object 
worse fault tolerant scalable directory single point failure contention 
proposals chord pastry viceroy address load aspect problem distributing directory information large number nodes :10.1.1.140.3129:10.1.1.140.3129:10.1.1.28.5987:10.1.1.17.4065:10.1.1.105.3673
particular find object polylogarithmic number application level network hops ensuring node contains share directory entries 
support removal new participants peer peer network 
unfortunately approaches number overlay hops polylogarithmic actual network latencies incurred queries significantly incurred finding object centralized directory 
alternative solution broadcast object location node network 
allows clients find nearest copy object easily requires large amount resources publish maintain location information including network bandwidth storage 
furthermore requires full knowledge participants network 
dynamic network maintaining list participants significant problem right 
describe results context tapestry overlay routing location infrastructure :10.1.1.111.1818:10.1.1.111.1818
tapestry uses starting point distributed data structure plaxton rajaraman richa refer prr scheme 
proposal yields routing locality balanced storage computational load 
stretch ratio distance traveled query object minimal distance query origin object 
distributed object location dynamic network provide dynamic maintenance membership 
original statement algorithm required static set participating nodes significant preprocess set generate routing infrastructure 
additionally prr scheme unable adapt changes node failures 
extends algorithms dynamic network 

related existing object location schemes exhibit routing locality including plaxton awerbuch peleg rajaraman 
provide publication deletion objects logarithmic number messages guarantee low stretch stretch defined ratio actual latency distance object shortest distance 
prr scheme finds objects expected constant stretch specific class network topologies ensuring node directory entries 
awerbuch peleg route polylogarithmic factor optimal general network topologies balance load 
unfortunately prr awerbuch peleg schemes assume full knowledge participating nodes equivalently assume network static 
scheme balances load bounding space node polylogarithmic number nodes need change node enters leaves network give method find nodes need updated 
abundance theoretical finding compact routing tables techniques closely related 
see survey :10.1.1.115.4299
closely related thorup zwick showed sampling scheme similar prr find small stretch routing tables answer approximate distance queries arbitrary metric spaces 
peer peer networks ignore stretch 
chord constructs distributed lookup service routing table logarithmic size :10.1.1.105.3673
nodes arranged large virtual circle 
node maintains pointers predecessor successor nodes logarithmic number chords cross greater distances circle 
queries forwarded chords reach destination 
places objects virtual high dimensional space :10.1.1.140.3129:10.1.1.140.3129
queries routed axes virtual space reach destination 
pastry loosely prr scheme routing queries successive resolution digits high dimensional name space :10.1.1.28.5987
overlay construction leverages network proximity metrics provide stretch prr scheme object location 
viceroy builds constant degree dht butterfly :10.1.1.17.4065
li plaxton presents simplified version prr scheme may perform practice :10.1.1.105.3673
schemes find objects polylogarithmic number application level network hops ensuring node contains share directory entries 
addition chord run time heuristics reduce object location cost may perform practice 
systems support removal nodes 
network topology gives metric space 
hildrum kubiatowicz rao zhao table 
comparison object location systems 
scheme insert cost space stretch metric hops balanced 
chord log log log rn nr rn pastry log log log viceroy log log tapestry log log log awerbuch peleg log log general log log log log general log prr log special log prr log log special log prr log log general log table number nodes :10.1.1.140.3129:10.1.1.140.3129:10.1.1.140.3129:10.1.1.28.5987:10.1.1.28.5987:10.1.1.17.4065:10.1.1.105.3673:10.1.1.105.3673
simplicity assume network diameter polynomial number objects 
stretch hops refer object search 
space assumes object ids occupy constant number bytes 
insert cost shows number hops messages needed node insertion means system provide algorithm 
number changes needed polylogarithmic algorithm changes 
cases time insertion high probability 
cases various messages sent parallel allow optimization stating bounds table 
peer peer applications locate objects dynamic network 
gnutella utilizes bounded broadcast mechanism search neighbors documents :10.1.1.111.1818
freenet utilizes chaotic routing scheme objects published set nearest neighbors queries follow gradients generated object pointers behavior freenet appears converge somewhat prr scheme large number objects :10.1.1.10.4919
techniques guaranteed find objects 
table summarizes related alongside contributions 
systems entry stretch metric column consider stretch special assume metric space certain low expansion property described section 

results goals derive best possible asymptotic results analyze simple schemes basis prr tapestry algorithms 
includes main results simplification prr scheme object location 
prove object location scheme meets bounds stretch prr scheme appears perform practice 
extend scheme prr approach deal changing participant set 
allow nodes arrive depart maintaining ability locate existing objects publish new objects 
works slightly broader class metric spaces assumed prr 
observe static version prr scheme general metric spaces spaces meet conditions assumed prr get results similar awerbuch peleg 
qualitative statement time 
distributed object location dynamic network table gives summary previous results 
contributions bold 
note result general metrics improved results thorup zwick log space 
techniques 
crux method inserting nodes network lies algorithm maintaining nearest neighbors restricted metric space 
approach similar spirit karger ruhl give algorithm answering nearest neighbor queries similarly restricted metric space 
idea nearest neighbor algorithm karger ruhl find nearest neighbor repeatedly finding node halfway current node query node 
done log times finds closest node 
restricted metric spaces considered papers mean substantial fraction nodes right distance halving distance implemented sampling nodes correct radius 
difficulty maintaining structure sampling dynamic network 
karger ruhl suggested general approach specific data structure accomplish 
data structure uses random permutation maintain random sampling approach reminiscent chord network infrastructure 
search algorithm aims halve distance step build different data structure different search algorithm 
particular random names build tree load balancing purposes trees search 
set trees set trees object location system described means search algorithm share data structure object location algorithm 
lee developed simple deterministic nearestneighbor data structure applications broader class metric spaces :10.1.1.38.1850:10.1.1.28.5987
data structure somewhat similar described clear data structure distributed load balanced way 
prove alternate scheme plaxton 
called prr table gives low stretch solution general metric spaces 
follows arguments similar bourgain metric embeddings 
particular show scheme leads covering graph trees nodes distance tree diameter log modifying prr scheme lines proposed thorup zwick improve space bounds logarithmic factor address issue 
remainder divided follows section describes details tapestry highlighting differences prr scheme introducing concepts terminology remainder 
section describes solve incremental nearest neighbor problem 
section explains part inserting node 
section gives algorithms deletion 
section discusses issues applying theoretical results physical networks 
section gives simple proof prr scheme polylogarithmic stretch general metric spaces 
section concludes 
clarkson similar approach 
hildrum kubiatowicz rao zhao 
tapestry infrastructure tapestry wide area location routing infrastructure oceanstore :10.1.1.111.1818
tapestry assumes nodes objects system identified unique identifiers names represented strings digits 
digits drawn alphabet radix identifiers uniformly distributed namespace 
refer node identifiers node ids object identifiers globally unique identifiers guids 
string digits number digits string 
tapestry inherits basic structure data location scheme prr 
prr scheme tapestry node contains pointers nodes neighbor links mappings object guids node ids storage servers object pointers 
queries addressed guids routed node node neighbor links appropriate object pointer discovered query forwarded neighbor links destination node 
query ultimately resolves node id 
tapestry routing mesh tapestry routing mesh overlay network participating nodes 
tapestry node contains links set neighbors share prefixes node id neighbors node id restricted nodes share prefixes nodes node ids satisfy neighbor links labeled level number greater number digits shared prefix 
shows portion routing mesh 
forward neighbor pointer node node backward neighbor pointer backpointer neighbors node grouped neighbor sets 
prefix id symbol neighbor set contains tapestry nodes node ids share prefix refer neighbors simply nodes 
closest node called primary neighbor neighbors called secondary neighbors 
context obvious drop superscript 
collection sets form level routing table 
routing table level maximum length ab af fig 

tapestry routing mesh 
node linked nodes neighbor links shown solid arrows labels 
labels denote digit resolved link traversal 
node link ab resolving digit link af resolving second digit notation section neighbor 
distributed object location dynamic network node ids 
membership neighbor sets limited constant parameter nodes neighbor set choose closest 
implies contains nodes 
gives property consistency 
nodes system 
refer hole routing table level digit property implies routing mesh fully connected 
messages route node node resolving destination node id digit time 
source node destination node node id equal jn empty string routing proceeds choosing succession nodes hop second hop third hop construction gives locality described property 
property locality 
tapestry prr contains closest neighbors determined metric space 
closest neighbor prefix primary neighbor remaining ones secondary neighbors 
property yields important locality behavior tapestry prr schemes 
yields simple solution static nearest neighbor problem node find nearest neighbor choosing set represents empty string 
section discusses maintain property dynamic network 

routing objects low stretch tapestry maps object guid set root nodes 
call root set root node 
assumed evaluated network 
function properly return nodes exist 
size root set small constant objects 
simplest version tapestry 
case speak root node node 
sensible property property unique root set 
root set object unique 
particular generate regardless evaluated network 
storage servers publish fact storing replica routing publish message 
publish messages routed primary neighbor links 
hop publish messages deposit object pointers object 
prr scheme tapestry maintains object pointers objects duplicate names copies 
illustrates publication replicas guid 
provide fault tolerance tapestry assumes pointers soft state pointers expire objects republished published regular intervals 
republishing may requested changes network 
hildrum kubiatowicz rao zhao fe bf ce aa fig 

publication tapestry 
publish object server aa sends publication request root leaving pointer hop 
server publishes replica similarly 
node exists object rooted node 
queries object route root nodes primary neighbor links encounter object pointer route located replica 
multiple pointers encountered query proceeds closest replica current node node object pointer 
query select root randomly 
shows different location paths 
worst case location operation involves routing way root 
desired object close client query path intersect publishing path reaching root 
fe bf ce aa fig 

routing tapestry 
different location requests 
instance locate guid query source routes root checking pointer step 
node encounters pointer server aa 
distributed object location dynamic network prr scheme queries route examining secondary neighbors proceeding primary link root 
number secondary neighbors set metric space bounded constant 
theorem shows important property shared prr tapestry 
theorem 
prr tapestry perform location independent routing property 
proof 
publishing process ensures members contain mappings object pointers server contains 
query routed worst case encounter pointer reaching observation fault tolerance 
names independent retry object queries tolerate faults tapestry routing mesh 
general metric space difficult claims performance system 
prr restricts attention metric spaces certain growth property assumes point ratio number points number points distance bounded constants 
points 
constraint plaxton show average distance traveled locating object proportional distance object queries exhibit stretch 
data structure ignores issues important practical systems 
tapestry simplification easier implement provide low stretch practice :10.1.1.111.1818:10.1.1.111.1818

surrogate routing procedures publishing querying documents outlined section require actual membership known 
required able compute hop root position network 
long incremental version consistent behavior achieve routing locality behavior section 
assume produces ordered list hop roots node prr scheme produces single root node matches largest possible number prefix bits 
ties broken consulting global order nodes 
prr scheme specifies corresponding function follows neighbor sets supplemented additional root links fill holes routing table 
route message root node prr routes directly node tapestry mesh 
assuming supplemental root links consistent publish query document head root node 
call process surrogate routing involves routing node adapting process fails 
roots reached way considered surrogate roots 
hildrum kubiatowicz rao zhao localized routing decisions 
dynamic network maintenance routing pointers problematic 
tapestry chosen focus property primary consistency constraint 
contrast original prr scheme maintain extra route links aid locating root nodes 
routing decisions current routing table source destination guids information collected route query number digits resolved far 
highlight variants localized routing certainly possible 
proceed routing digit time destination guid network hop resolves additional digit destination 
backtracking schemes guaranteed complete 
tapestry native routing route digit time 
match digit route filled entry level table wrapping needed 
example digit routed entry try 
distributed prr routing route digit time follows 
hole route digit time 

hole route existing neighbor link matches desired digit significant bits possible 
route pick route numerically higher digit 

hole pick routing table entry numerically highest available digit 
technique routes root node numerically largest node id matches destination guid significant bits 
schemes routing stops current node node left current level routing table resulting node root node 
localized schemes simpler prr inserts deletes 
addition tapestry native routing scheme may better load balancing properties 
theorem 
suppose property holds 
tapestry version surrogate routing produce unique root 
proof 
proof contradiction 
suppose messages object id routing different nodes longest common prefix length 
nodes st routing step nodes send message different digits 
notice step digits prefix remain constant routing steps 
pattern empty non empty entries 
empty empty property 
send message node st digit contradiction 
similar proof possible distributed prr scheme 
localized routing may introduce additional hops prr number additional hops independent expectation :10.1.1.111.1818:10.1.1.111.1818
notice distributed object location dynamic network observation multiple roots 
surrogate routing generalizes multiple roots 
pseudo random function employed map initial document guid set identifiers route root surrogate route 
comparison tapestry prr section quickly outline differences tapestry prr 
exception changes maintenance object pointers key ways tapestry differs prr revolve eliminating requirements static network adding provisions handle faults graceful manner required system deployable real networks 
clarify contributions key differences noted 
tapestry nodes keep pointers copies object 
prr node stores pointer object regardless copies network 
result deleting object easier tapestry prr comes increase storage 
property allows tapestry applications exploit multiple object replicas queries multicast object name close subset objects 
second prr secondary neighbors core object location algorithms tapestry uses primarily fault resilience 
searching object prr searches primary secondary neighbors additional hop object root 
worth noting equivalent publishing secondary neighbors searching primary neighbors 
contrast tapestry keeps entry small number current implementation additional backup neighbor links fault resilience 
publishing search takes place primary links 
third described surrogate routing different systems 
prr assumes static set nodes precomputed surrogates tapestry algorithms maintain surrogate routes part insertion process 
prr extended dynamic algorithms maintaining surrogate routing scheme 
tapestry surrogate routing slightly better load balancing objects surrogate roots 
tapestry implemented running downloads available 

building neighbor tables building neighbor table complex interesting part insertion process 
problem build neighbor sets new node sets satisfy properties 
seen solving nearest neighbor problem different prefixes 
solution simply method karger ruhl times prefix 
essentially require node participate log karger ruhl data structures level neighbor table 
require log space 
method lower network distance straightforward karger ruhl number network hops incurs additional space prr data structures 
hildrum kubiatowicz rao zhao adopt network constraint 
ba denote ball radius points distance ba denote number points 
assume ba ba constant prr assume ba ba assumption needed extensions 
notice expansion property exactly karger ruhl 
assume triangle inequality network distance set nodes bounds terms network latency network hops ignore local computation calculations 
local computation time consuming fair measure complexity 

algorithm shows build neighbor tables 
words suppose longest common prefix new node node network 
list nodes prefix 
explain get list section 
proceed getting similar lists progressively smaller prefixes closest nodes matching empty prefix 
level node node shares length prefix 
go level list level list ask node level list give method maxlevel length list list maxlevel maxlevel list list list method level temp level temp return fig 

building neighbor table 
words notation function destination represents call run function destination variables italics single valued variables bold vectors 
function described 
distributed object location dynamic network level nodes know ask forward backwards pointers 
note level node level node neighbor table backpointers level nodes gives level nodes 
contact nodes sort distance inserting node 
node contacted way checks see new node added table line 
trim list keeping closest nodes 
lemma says log high probability lists level contain exactly closest nodes 
lists fill neighbor table 
happens lines 
precisely recall level table consists nodes prefix digits node prefix 
fill level neighbor table look level list 
keep closest nodes defined section 

proof correctness theorems prove high probability algorithm correctly creates new node neighbor table correctly updates neighbor tables existing nodes 
theorem uses lemmas show new node table gets built correctly theorem argues tables nodes updated correctly 
lemma shows closest level nodes finds closest level nodes 
lemma 
expansion constant network list closest level nodes find closest level nodes log 
particular log failure probability bounded proof 
radius smallest ball new node containing level matches 
show node inside ball point level node new node 
case query parent find 
rest proof need level nodes level node 
probability true exp exp log 
remainder proof assume level nodes level node 
distance nearest level node level node ball radius triangle inequality distance new node parent 
see 
means long point node inside 
query level means query parent find complete proof need high probability 
expected behavior ball level nodes doubling radius twice gets algorithm sensitive failures slight modification algorithm substantially robust see 
hildrum kubiatowicz rao zhao new fig 

theorem 
point node 
nodes level nodes 
means ball level nodes equivalently ball containing level nodes really times size ball level nodes 
turns informal argument proof 
recall 
pick follows 
note 
notice write function particular log kb required number nodes expects nodes level nodes 
random variable representing total volume ball number nodes ball containing level nodes 
done rest proof argue probability small 
fact pr pr pr pr pr 
bound term product 
show pr na xm random variable representing number level nodes nodes 
notice pr bounded pr xl closest nodes new node contain level nodes 
pr xl pr xl xl 
distributed object location dynamic network chernoff bound xl exp exp exp substituting exp log show pr exp log na consider ball radius new node 
ball contains level nodes smaller ball radius contain level nodes 
know volume number nodes ball fact ym number nodes trials 
rewriting goal notation wish bound pr yc xl 
notice yc independent xl 
write pr pr pr pr pr suffices bound pr yc pr xl 
bounded denominator wish bound pr yc 
yc xl kc get pr yc pr yc yc yc exp yc pr yc exp 
substituting get bounded exp log pr pr yc pr xl na na na long 
recall wish bound pr know pr pr pr pr pr hildrum kubiatowicz rao zhao step follows long 
show closest nodes matching digits fill level neighbor table large 
means list containing closest nodes prefix log nodes 
recall defined section lemma 
log log list closest nodes node contains high probability 
particular log probability na proof 
random variable representing number nodes list 
expectation log want bound pr log pr pr exp step uses chernoff bound 
simplify equation say pr apply union bound possible get probability nodes list bounded assume gives bound desired result 
combine lemmas prove theorem theorem 
expansion constant network digit size log log algorithm produce new node correct neighbor table probability constant proof 
lemma probability ith list incorrectly generated st list 
log levels probability level fails log 
second lemma log probability unable fill neighbor table log neighbors lists length 
log levels fill probability levels left unfilled bounded log 
distributed object location dynamic network choose max probability lists correct table filled bounded proves theorem 
new node causes changes neighbor tables nodes 
instruct node candidate new node table check adding new node improve neighbor table 
happens line 
remains show high probability line updates nodes need updated 
particular show log node needs update level link closest nodes level high probability 
theorem 
new node neighbor closest nodes prefix high probability log closest nodes particular abc log log probability closest nodes proof 
show probability closest nodes arbitrarily small 
distance consider ball radius 
shown 
neighbor table nodes ball 
notice ball containing nodes contain proof done radius consider ball radius 
completely contains ball closest nodes ball radius contains nodes ball radius contains nodes prefix 
show probability small 
log sufficiently large assume log arguing directly ball argue ball radius ba bb 
precisely ba denote number nodes ball radius want argue fig 

theorem 
larger ball contains log nodes smaller ball contains 
hildrum kubiatowicz rao zhao probability ba ba small 
cases depending ba 
number nodes smaller ball ba log probability node node 
note random variable 
abc log 
recall base logarithm expansion constant network 
case intuitively case smaller ball nodes expect nodes 
formally xm number nodes trials 
random variable representing number nodes closest nodes case want bound probability say pr pr xl 
xl log log pr xl pr xl xl 
chernoff bound exp xl substituting exp log exp log na case case argue ball radius contains nodes probability ball radius contained ball imply ball radius contains nodes probability ym random variable representing number nodes trials 
wish bound pr ba equal pr ba contains cl nodes 
pr ba pr pr 
recalling pb log chernoff bound write pr exp exp log 
probability case bounded probability bounded completing proof 
sure probability failing get new node table correctly update tables established nodes combine results way 
large probability mistake building neighbor table possible theorem choose large probability algorithm misses update node table possible theorem 
choose max probability algorithm fails perform correct updates distributed object location dynamic network 
running time node expected constant number pointers level expected time algorithm log level log 
concerned network traffic distance ignore cost local computation 
number backpointers log level node high probability get total time log high probability 
analysis tightened 
techniques theorems argue high probability visited level nodes ball radius 
high probability log level nodes 
means visit log nodes level log nodes 
notice 
suppose number nodes touched level bounded know log 
total network latency bounded iq geometrically decreasing sum network diameter total latency building neighbor tables qd log 

node insertion describe insertion algorithm nearest neighbor algorithm subroutine 
results insertion able build network static data 
means addition updating neighbor tables correctly maintaining invariant property 
node path publisher object root object pointer section show properties hold insert node hold insertion new node part network 
may happen node insertion properties temporarily untrue 
case property particularly serious objects may temporarily unavailable 
section shows algorithm extended eliminate problem 
shows basic insertion algorithm 
new node contacts surrogate node id closest 
gets copy surrogate neighbor table 
steps combined desired 
node contacts subset nodes notified maintain property 
nodes hole neighbor table new node fill 
function detailed section 
final step build neighbor tables described section 
reduce number multicasts multicast step insertion algorithm get list nearest neighbor algorithm 
notice multicast finished node fully functional neighbor table may far optimal 
hildrum kubiatowicz rao zhao method insert insert fig 

node insertion routine 
insertion process begins contacting gateway node member tapestry network 
transfers object pointers optimizes neighbor table 
maintain property 
means nodes path object server object root pointer object 
failure cases correctness fixing problem means network may fail locate object performance fixing problem may increase object location latency 
function takes care correctness transferring object pointers rooted new node deleting pointers longer current node 
move object pointers objects may unreachable 
performance optimization involves redistributing pointers discussed section 

acknowledged multicast contact nodes prefix introduce algorithm called acknowledged multicast shown 
algorithm initiated arrival multicast message node 
multicast message consists prefix function apply 
valid multicast message prefix prefix receiving node 
node receives multicast message prefix sends message node method function fori neighbor exists neighbor function apply function wait fig 

acknowledged multicast 
runs function nodes prefix 
distributed object location dynamic network possible extension sends message node node exists 
extensions node node may receive multicast messages potentially different levels 
know property node exists node knows node 
nodes continues multicast 
node forward message applies function 
need know algorithm finished require recipient send acknowledgment parent receiving acknowledgments children 
node children sends acknowledgment immediately 
initiating node gets acknowledgment children know nodes prefix contacted 
theorem 
multicast recipient prefix sends acknowledgment nodes prefix reached 
proof 
proof induction length 
base case suppose node receives multicast message prefix node prefix 
claim trivially true 
assume claim holds prefix length prove holds prefix length 
suppose node receives multicast prefix length 
forwards multicast node possible digit extension 
receives acknowledgments nodes prefix reached 
waits acknowledgments sending nodes prefix reached sends acknowledgment 
messages form tree 
collapse messages sent node result fact spanning tree 
means nodes reached multicast edges tree 
alternatively node receive multicast message messages sent 
links diameter network total cost multicast nodes dk 
note variant algorithm require maintaining state participating nodes scope 

redistributing object pointers recall objects publish location placing pointers path server root 
time time re establish pointers operation called republish 
section describes special version republish maintains property 
function rearrange object pointers time routing mesh changes expected path root node object node primary neighbor replaced closer node 
adjustment necessary correctness improve performance object location 
node uses ordinary republish simply sending message root leave object pointers dangling timeout 
example disappearance node changes path object root node hildrum kubiatowicz rao zhao method sender level null sender nexthop level self level level method level delete level fig 

helper function 
path skips node node left pointer object 
simple republish may extra updating pointers changed 
nodes new forward route sends object pointer new path 
new path old path converge node delete message sent back old path removing outdated pointers 
requires maintaining hop pointer object pointer 
shows methods needed implement procedure 
notice property critical functioning system 
node performance may suffer objects available 
timeouts regular eventually ensure object pointers correct nodes 

keeping objects available node inserting object requests go new node insertion may go new node pre insertion destination 
shows keep objects available process node receives request object forwards request node 
inserting node receives request object sends request back routing know 
new node fills hole level sends message level surrogate nodes 
surrogate routes message new node entered network 
pre insertion root receives request object pointer moved new node forward request new node 
want way surrogate need keep state show nodes inserting 
require nodes check routing object request publish rejecting nodes test object surrogate distributed object location dynamic network method objectid inserting level length objectid level elseif objectid objectid neighbors endif fig 

route correction 
route correction keep objects available insertion 
step need 
finds surrogate step going new node old root node redirects message new node 
properly require old root delete pointers new root acknowledged receiving 
done nodes guaranteed pointer 
matter node receives request transfer pointers node servicing request information satisfy query forwards query node satisfy local information 
possible request non existent object loop insertion complete 
address problem including information message header request allowing system detect prevent loops 
number hops small unreasonable overhead 

simultaneous insertion wide area network insertions may happen time 
nodes inserted may get older view network node see 
suppose inserted simultaneously 
possibilities insertions intersect 
case need know log nodes high probability chance small 
neighbors distant neighbor 
possible neighbor 
case needs done 
second case fails get added neighbor table network satisfies object requests stretch may increase 
local optimization mitigates problem 
exact answer desired rerun neighbor table building algorithm random amount time 
third case greater cause concern hole property longer hold 
mean objects unavailable 
problem solved re inserting node reinsertion occurs objects may unavailable 
serious problem section presents solution 
liu lam addresses problem solution advantage requires non joining nodes maintain state going joins 
hildrum kubiatowicz rao zhao start definition definition 
assume start consistent tapestry network 
core node node completely integrated network holes neighbor table filled core nodes network fill holes neighbor tables core nodes network 
core nodes satisfy property 
definition node core node meeting locality property 
goal section prove node finishes multicast core node nodes core nodes multicast finishes remain core nodes 
add requirement multicast including insertion start core node 
operations simultaneous point time operations ongoing 
straightforward definition important systems standpoint 
bit imprecise multicasts simultaneous indistinguishable sequential multicasts global clock 
distinguish cases core nodes see evidence consistent sequential ordering cases agreement 
say multicasts conflict nodes receive multicasts different orders 
hole new node fills slot surrogate neighbor table available core node perform multicast operation 
theorem 
suppose inserts 
done multicast table holes filled core nodes 
core nodes holes fill 
statements true insertions proceed simultaneously 
proof induction 
order nodes finish multicasts 
induction hypothesis nodes finished satisfy theorem prove true 
note assuming ongoing multicasts starts multicast 
start proving series lemmas 
lemma simple important 
lemma states simultaneously inserting nodes interfere access core nodes 
lemma 
nodes set core nodes reached multicast presence ongoing completed insertions nodes 
proof 
proof contradiction 
theorem says core nodes reach 
suppose multicast misses node node sent multicast 
suppose prefix received multicast 
ifb send multicast send prefix ofx id node table 
possible case finished multicast 
supposed send multicast know share prefix 
know distributed object location dynamic network network began multicast multicast consists nodes prefix 
means filled entries possibly contacted prefix smaller contradiction 
case finished multicast core node 
theorem node node table 
contradiction 
theorem uses lemma case circular node inserted point time 
remains deal case insertions conflict 
introduce notion pinned pointer 
pointer node stored node pinned nodes multicasts arrived acknowledged 
multicast new node filling slot arrives node puts new node table pinned pointer sends multicast pointer pinned pointers 
receives acknowledgments recipients unlocks pointer 
keep pointer pinned pointers 
done reach nodes knows having store 
intuitively pointer reach pointers pointers equivalent pinned pointers connected reachable multicast 
lemma 
multicast pointer node reaches nodes pointers node proof similar multicast arguments 
ideally multicast see completed 
enforce condition node gets multicast notices hole filled contacts nodes seen fill hole 
contacts pointer pinned pointers 
deal case fill hole 
lemma 
suppose fill hole 
modification described multicast conflicts get multicast message multicast finished 
proof 
node gets multicast gets multicast forwards fill hole 
send acknowledgment returns acknowledgment multicast informed time multicast finishes 
apply argument roles reversed 
done 
consider hole hole filled different nodes 
node may get multicast vice versa multicast sets 
modify multicast 
starting node sends watch list prefixes knows matching node 
represented bit vector 
hildrum kubiatowicz rao zhao method function fori neighbor exists neighbor function apply function function wait fig 

acknowledged multicast watch list 
version acknowledged multicast handles simultaneous insertions 
inserting node sends surrogate zero entry neighbor table 
receiving node checks watch list see fill blank list 
sends relevant node originator multicast marks entry continues multicast 
description may sound sending lot information fact sending little lower levels table filled surrogate step upper levels table zero 
normal case send levels neighbor table level bits 
new version shown 
new multicast get lemma 
lemma 
node node 
core nodes get multicast messages slot hole 
core nodes finished multicasts start multicast 
proof 
cases case node gets multicast case multicast arrives checks watch list watch list hole fill hole filled able notify fill hole 
hole watch list node 
case core nodes gets multicast 
means gets multicast completes proof 
put prove theorem 
distributed object location dynamic network proof 
consider node longest shared prefix case 
fill different holes level fills hole fills hole multicast prefix 
lemma know nodes reached apply lemma theorem lemma theorem lemma 
case 
fill different holes different levels core nodes network lemma know nodes reached 
apply lemma 
case 
fill hole level core node prefix preceding arguments fail 
case rely lemma says multicasts serialized find multicasts complete 
completes proof 
discussion 
note parallel insertion algorithm lock free multicast start core node core node perform multicasts inserting nodes 
process pinning pointers impede forward progress insertion 
side effect lock free behavior new node may receive multicasts inserting nodes 
fortunately effect uncommon rare new node leaf tree new node forward multicast 
new node easily suppress duplicate multicast messages 

running time analysis total number hops log high probability 
finding surrogate costly searching object pointer plaxton argue finding object pointer requires network traffic log hops 
multicast takes time kd number nodes reached 
small expectation bounded log high probability 
building neighbor tables takes log messages 
objects new node cost republishing objects md 
gives total traffic md log object pointer relocation 

node deletion section algorithms help maintain invariants nodes leave network 
consider cases voluntary involuntary delete 
voluntary delete occurs node informs network exit 
preferred mode deletion permits infrastructure maintain availability objects fixing neighbor links object pointers 
involuntary delete occurs node ceases determining dynamically cost reduced log high probability :10.1.1.38.1850
hildrum kubiatowicz rao zhao participate network warning due node failure network failure attack 
note unreasonable hope deletes voluntary deletes algorithm case completeness 
real networks nodes links typically fail warning involuntary delete common case 
discuss case section 

voluntary delete node decides leave network ideally removes way gives infrastructure time adapt routing mesh object pointers maintain object availability 
begins sending intention leave network nodes backpointers list nodes currently point routing table 
notification sends potential replacement routing level 
node links marked leaving removing link leave incorrect hole routing table breaking property 
problem mitigated existing secondary pointers backing potential replacements sends notification 
node may wish run nearest neighbor algorithm tune neighbor table 
initial notification received node local object pointers normally route exist 
incoming queries route normally marked leaving publish operations route replacement 
see 
node sends initial notification messages examines local object pointers root forwards respective surrogate nodes 
objects new root nodes acknowledgments received objects rooted reachable new surrogates 
availability guaranteed 
node sends final delete notification backpointers telling delete routing tables completely 
nodes responded disconnects 
allowable objects temporarily unavailable skipped notification happen phase 

involuntary delete involuntary deletion occurs failure prevents node performing normal tapestry operations 
simplicity consider complete failures network partitions hardware failures complete system halts 
scenarios method pointer backpointers level pointer pointer selfid level pointer level pointer neighbors backpointers pointer selfid fig 

voluntary delete 
shows node leaves network 
distributed object location dynamic network rest tapestry network detect node failure recover possible maintain object availability full reachability routing mesh 
propose unexpected deletes handled lazily 
node notices node fix state attempt dictate state changes node 
process fixing state may hint nodes state may date 
deletion detected soft state beacons node sends message node get response :10.1.1.111.1818
node detects faulty node remove node neighbor table find suitable replacement 
produces hole table find replacement ensure property maintained 
options depending replacement 
find replacement simple local search algorithm asking remaining neighbors nearest matching nodes 
guaranteed give closest replacement node 
alternatively nearest neighbor algorithm repeated 
case object pointers gone deleted node 
ensure property deleting node leaves hole routing table find replacement determine exists 
multicast nodes sharing prefix ofn dead node 
workable solution multicast algorithm assumes tables complete may reach node table path incomplete 
slightly better 
liu lam notification algorithm similar multicast solves problem 
algorithm property node table contacted node returned node starting multicast 
furthermore notification algorithm requires starting node maintain state 
ideal application 
concern node disappears node point start search causing traffic desirable 
cost centralization pick node say surrogate departed node perform search surrogate return answer done 
unfortunately maintain object availability 
objects rooted deleted node may unavailable republish arrives node surrogate 
fact network partition may result inconsistent deletion address 

realistic deployment previous sections algorithmic solutions maintaining properties membership changes overlay network 
algorithms assume network satisfies expansion property distances unchanging 
section reconsider assumptions issues context physical networks internet 

power indirection tapestry replicate data data 
systems consider stretch consider example network hops add level hildrum kubiatowicz rao zhao indirection view data items pointers cost additional hop consequently distinction may significant 
maintenance pointers network application level powerful abstraction 
adding level indirection drastically change stretch properties significantly change number network hops 
addition object location system allows arbitrary object placement extremely flexible 
tapestry enables applications choose data placement policies placing replicated objects near hotspots reliable nodes 
automatically close resources possible 
reduces network traffic bandwidth may improve reliability links traversed access nearby object 

physical network topologies important assumption expansion property 
real networks described simply 
research projects tried create accurate models current internet 
widely accepted models transit stub network model 
transit stub networks may may expansion property depending layout nodes inside stub 
ideally want provide performance networks regardless intra stub layout 
algorithm section may find nearest neighbor expansion constant network large 
modification algorithm chooses dynamically guarantee give right answer may take long time expansion high see :10.1.1.38.1850
algorithm strong dependence expansion factor high expansion implies high dimension high dimension neighbor searches known hard 
castro explore question expansion property running simulations different topology models 
results suggest expansion property hold useful guiding design overlay networks 
context nearest neighbor algorithm continue perform real network topologies 

locality enhancement expansion property hold routing stretch may quite high 
note system find object log hops worst case competes systems locality aware 
expand pointer placement mechanisms described section enhance locality reduce stretch 
instance latency differences intra stub paths inter stub paths order magnitude greater ensure object locate request leaves originating stub copy object inside stub 
propose optimization object publication locate operations effort limit operation local stub domain 
assume moment tapestry nodes detect hop stub network 
ensure message leaves stub desired object inside stub 
object publication route distributed object location dynamic network local network spawns local branch publish message treats local network entire domain 
original routes wide area local publish uses surrogate routing route local root terminates 
object exists local network request terminate local object root 
examines current node id determine surrogate routing started resumes hop continue normal object location 
example suppose node trying find object labeled 
node exists lies outside local network node uses surrogate routing inside local stub tries send message closest node stub 
exists sends closest node stub finds definitive local root node 
object local stub root node resumes normal routing outside stub 
publish side local node publishing object id discovers hop outside local network forwards publish messages id continues normal publish outside network restricted local area publishes surrogate routing local object root 
practice may possible determine exactly node stub 
probably guessed setting local latency threshold marking nodes threshold outside stub 
details simulation locality enhancement schemes appear 
net effect optimization queries objects stub network resolved routing outside stub network 
tradeoff queries remote objects pay price additional surrogate routing hops inside stub network local hops surrogate routing lasts hops expectation :10.1.1.111.1818:10.1.1.111.1818
consequently systems see significant performance gains result eliminating wide area network traffic 

continual optimization real internet routes frequently change due variety factors configuration changes border gateway protocol bgp changes packet forwarding policy internet service providers isps recalculation ip routes router failures inside autonomous systems ass 
network distance change time potentially efforts provide locally optimal routes hop 
section discuss heuristics adapt network mesh underlying network distance instability better 
optimizations trade computation network traffic date network structure 
simplest thing adjust routing table entries 
recall entry neighbor links periodically adjust neighbors primary 
opposite extreme invoke periodic repetitions complete nearest neighbor algorithm 
third option node record identities nodes contacted search nearest neighbor log nodes 
optimize level entry time 
optimize level example contact level nodes contacted original building process rebuild level 
infrequent operation additional storage flushed disk hildrum kubiatowicz rao zhao minimize memory overhead 
frequency set type network dynamically triggered nodes discover significant changes expected node node performance 
fourth option local sharing information 
periodically node sends level neighbors copy level neighbor table 
receiving nodes repeat distance measurements compare neighbors replacing away nodes appropriate 
idea heuristic neighbor table building algorithms :10.1.1.111.1818:10.1.1.111.1818:10.1.1.28.5987
cases new primary neighbor chosen node needs move object pointers 
done efficiently described section 
note pointer movement deferred time affect correctness object location process 

reliable messaging sybil attacks mention significant factors consider real deployment systems tapestry 
reconsider assumption messages arrive reliably destinations order 
internet packets dropped connections broken communication reliability guaranteed 
exacerbated large scale nature systems tapestry 
provide resilience unpredictable failures soft state state needed correctness 
example nodes periodic heartbeat messages detect node link failures objects republished regular intervals order maintain high availability 
soft state mechanisms limit loss availability due failures attacks simplifying algorithms 
efficacy techniques illustrated 
achieve greater resiliency failure invoke epidemic propagation mechanisms synchronize groups pointers alternate root sets techniques topic ongoing research 
second need aware malicious users potential attacks system sit morris describe attacks 
particularly devastating attack occurs single attacker large number physical nodes attempt gain control key positions routing mesh 
generating randomized node ids attacker eventually obtain ids position intended target node mesh 
attacks carried deny service manipulate spoof communication 
attacks referred sybil attacks extremely hard detect circumvent 
physical resources attacker hard overcome 
viable solution centralized certificate authority allocate node ids 
centralized nature lead problems scalability 
problem related security remains unsolved subject active research 
see approaches problem 

object location general metric spaces section take slightly different tack allow arbitrary metric space scheme dynamic 
show route object distributed object location dynamic network polylogarithmic stretch id log average space id size object id strawman scheme proposed plaxton load balancing similar scheme thorup zwick 
proof reminiscent metric embedding results bourgain linial 
si sample metric space node chosen probability log log 
pick single node random 
node network stores closest node si pair node si stores list objects located nodes point 
suppose node wants find object starting log asks parallel representative set si knows returns pointer fails tries si recall node find object exists 
theorem key showing stretch bounds 
theorem 
largest si points show si log high probability 
average space data structure log 
proof 
bx ball radius nodes distance consider sequence radii rk kd log bx rk rk bx rk call rk 
show exists rk theorem holds 
rk radius 
consider log bx log bx half bx constant probability exactly member si intersection member union 
view trial log trials high probability succeed 
si points queries get pointer soi argue rk 
suppose rk bad 
bx dk dk half bx dk dk 
notice bx kd kd contains bx bx kd kd bx kd kd bx say bx kd kd bx 
happen log times bx contains network nodes 
hildrum kubiatowicz rao zhao point bx rk rk contains network element clearly pointed pointer get stretch bound notice si log total distance traveled level log latency waiting time log may log levels means total latency proportional log total distance traveled proportional log note assumed implicitly distance nearest si distance si may strictly true 
true require si si doing change probability point si slightly result holds 
provide load balancing range possible id prefixes search prefixes id results large table size 
know maintain data structure efficiently 

illustrate adapt arriving departing nodes tapestry overlay routing infrastructure routing locality 
describe efficient distributed solution nearest neighbor problem distributed algorithm maintaining prefix routing mesh 
salient properties system objects remain available network changes 
cost integrating new nodes similar systems provide routing locality 
result infrastructure provides deterministic location routing locality load balance changing network 
acknowledgments sean rhea careful reading 
kevin chen thomas members oceanstore group anonymous reviewers insightful comments 
awerbuch peleg concurrent online tracking mobile users 
proc 
sigcomm sept pp 

awerbuch peleg routing polynomial communication space trade 
siam journal discrete mathematics 
bolosky douceur ely theimer feasibility serverless distributed file system deployed existing set desktop pcs 
proc 
sigmetrics june pp 

bourgain lipschitz embedding finite metric spaces hilbert space 
israel journal mathematics 
castro druschel ganesh rowstron secure routing structured peer peer overlay networks 
proceedings th symposium operating systems implementation dec pp 

distributed object location dynamic network castro druschel hu rowstron exploiting network proximity peer peer overlay networks 
proceedings international workshop directions distributed computing june pp 

clarke sandberg wiley hong freenet distributed anonymous information storage retrieval system :10.1.1.10.4919
designing privacy enhancing technologies international workshop design issues anonymity unobservability federrath ed 
lecture notes computer science pp 
springer verlag berlin 
clarkson nearest neighbor queries metric spaces 
proceedings th annual acm symposium theory computing may pp 

compact routing minimum stretch 
proceedings th annual acm siam symposium discrete algorithms jan pp 

douceur sybil attack 
proc 
iptps mar pp 

routing distributed networks overview open problems :10.1.1.115.4299
acm sigact news mar 
gopal manber integrating content access mechanisms hierarchical file systems 
proc 
acm osdi feb pp 

hildrum kubiatowicz asymptotically efficient approaches fault tolerance peer peer networks 
proceedings th international symposium distributed computing oct pp 

hildrum kubiatowicz rao way find nearest neighbor metrics :10.1.1.38.1850
tech 
rep ucb csd computer science division uc berkeley aug 
karger ruhl find nearest neighbors growth restricted metrics 
proceedings th annual acm symposium theory computing may pp 

lee navigating nets simple algorithms proximity search :10.1.1.38.1850:10.1.1.28.5987
proceedings th annual acm siam symposium discrete algorithms jan pp 

kubiatowicz bindel chen czerwinski eaton geels gummadi rhea weatherspoon weimer wells zhao oceanstore architecture global scale persistent storage 
proc 
acm asplos nov pp 

li plaxton name resolution peer peer networks :10.1.1.105.3673
proceedings second acm international workshop principles mobile computing oct pp 

linial london rabinovich geometry graphs algorithmic applications 
proceedings ieee symposium foundations computer science pp 

liu lam neighbor table construction update dynamic peer peer network 
proc 
ieee icdcs may pp 

malkhi naor viceroy scalable dynamic emulation butterfly :10.1.1.17.4065
proceedings annual symposium principles distributed computing pp 

acm press new york 
oram ed :10.1.1.111.1818
peer peer harnessing power disruptive technologies 
reilly cambridge ma 
peleg upfal tradeoff size efficiency routing tables 
proceedings st annual acm symposium theory computing may pp 

plaxton rajaraman richa accessing nearby copies replicated objects distributed environment 
proceedings th annual symposium parallel algorithms architectures june pp 

rajaraman richa data tracking scheme general networks 
proceedings acm symposium parallel algorithms architectures july pp 

ratnasamy francis handley karp schenker scalable content addressable network :10.1.1.140.3129
proc 
sigcomm aug pp 

rowstron druschel pastry scalable distributed object location routing large scale peer peer systems :10.1.1.28.5987
proceedings ifip acm international conference distributed systems platforms nov pp 

hildrum kubiatowicz rao zhao rowstron druschel storage management caching past large scale persistent peer peer storage utility 
proc 
sosp oct pp 

sit morris security considerations peer peer distributed hash tables 
proceedings international workshop peer peer systems mar pp 

stoica morris karger kaashoek balakrishnan chord scalable peer peer lookup service internet applications :10.1.1.105.3673
proc 
sigcomm aug pp 

stribling hildrum kubiatowicz optimizations locality aware structured peerto peer overlays 
tech 
rep ucb csd computer science division uc berkeley aug 
thorup zwick approximate distance oracles 
proceedings rd annual acm symposium theory computing july pp 

thorup zwick compact routing schemes 
proceedings th annual symposium parallel algorithms architectures july pp 

zegura calvert bhattacharjee model internetwork 
proc 
ieee infocom mar vol 
pp 

zhao huang rhea stribling joseph kubiatowicz tapestry global scale overlay rapid service deployment 
ieee journal selected areas communications 
special issue service overlay networks 
zhao joseph kubiatowicz locality aware mechanisms large scale networks 
proceedings workshop directions distributed computing june pp 

zhao kubiatowicz joseph tapestry infrastructure fault tolerant widearea location routing :10.1.1.111.1818
tech 
rep ucb csd computer science division uc berkeley apr 
received october revised form may final form august 
online publication march 
