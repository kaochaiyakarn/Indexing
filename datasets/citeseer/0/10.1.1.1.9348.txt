constraints kluwer academic publishers boston 
manufactured netherlands 
comparative study constraint programming languages boolean finite domains antonio fern ndez lcc uma es departamento de ciencias de la computaci spain patricia hill hill scs leeds ac uk school computer studies university leeds leeds ls jt england 
compares efficiency number constraint logic programming clp systems setting finite domains specific aspect expressiveness concerning reification meta constraints 
key reasons adopting clp technology solving problem 
expressiveness enabling declarative solution readable code vital maintenance second provision efficient implementation computationally expensive procedures 
clp systems differ significantly solutions may expressed efficiency execution important factors taken account choosing best clp system particular application 
aids choice illustrating differences systems indicating particular strengths weaknesses 
keywords constraint programming constraint propagator domain labeling strategy solvers 
evidence success constraint logic programming clp paradigm increasing number clp systems real life applications 
main reasons success clp extends logic programming paradigm enabling declarative readable solutions secondly supports propagation constraints specific domains providing efficient implementation computationally expensive procedures 
clp systems differ significantly solutions may expressed efficiency execution 
important factors taken account choosing best clp system particular application 
fact wrong choice application may disastrous relative efficient performance respect code clarity solution important modifications 
spite appears impartial set guidelines choosing appropriate constraint system solving specific constraint satisfaction problem 
domains clp finite domain fd best studied suitable framework solving discrete constraint satisfaction problems 
fd particularly useful modeling problems scheduling planning packing timetabling consequence clp systems provide substantial fd libraries 
fd boolean domain regarded instance fd considered 
fern ndez hill main contribution provide impartial comparison number fd solvers clp 
contrast constraint systems ecl ps oz ilog solver clp fd chr sicstus prolog prolog 
chose particular systems cover main kinds fd solvers popular clp community 
limited resources chip prolog iv included comparison 
constraint systems tested solving number traditional benchmarks comparative done language implementers 
furthermore benchmarks development assessment languages tests biased 
authors designer clp languages studied comparison impartial previous ones 
intended experience reported aid choosing appropriate constraint language solving specific constraint satisfaction problem 
chosen particular kind logical puzzle called self referential quiz srq original benchmark comparison 
new class puzzles described demonstrating meta reasoning capabilities oz fd system 
self referential nature problem particularly suitable examining ease different languages applications requiring metareasoning 
srq illustrate languages support reification boolean domain meta constraints fd 
srq efficiency comparisons non standard benchmark development systems apart oz 
particular comparisons essentially fair unaffected bias implementation may perform standard benchmarks 
discussed subsection constraint solving viewed combination processes constraint propagation labeling 
constraint propagation main reason choosing clp technology concentrate comparing constraint propagation methods 
ensure fairness efficiency testing consider distinct labelings naive fail 
known single benchmark adequate evaluating programming system 
solved quickly easily scalable 
comparison fair objective extended study problems scalable comparing mainly efficiency solutions 
chose known problems available solutions provided systems directly implementers 
rest organised follows section describes essential features fd constraint systems languages considered 
section srq puzzle defined different solutions described 
section shows tutorial way language express reified constraints 
extracts srq formulations languages highlight main differences 
section comprehensive efficiency comparison reported results discussed 
concludes summary outline possible 
comparative study 
constraint systems tested section describe constraint systems considered 
systems classified glass box black box 
explain mean classifications 
classification describe constraint systems compared 
conclude section short note discussing ease languages learned 

glass box vs black box distinction glass black box language clear 
glass box languages mean provide simple primitive constraints propagation scheme formally specified 
constraints construct specialised high level constraints suitable application 
alternatively black box languages provide wide range high level constraints implementation hidden user 
constraints perform specific tasks efficiently 
languages hard user add new constraints constraints defined low level requiring detailed knowledge implementation 

glass box languages different kinds glass box languages 
differ way constraint propagation may defined single form relational construct called indexical means special constraint handling rules chrs 

indexical languages languages examined support indexicals clp fd sicstus prolog 
indexical reactive functional rule form domain variable 
set valued range expression form terms denote singleton ranges parameters integers combinations terms arithmetical operators indexical ranges 
allowed form indexical range depends language normally min represents minimal value domain variable max represents maximal value domain variable val represents value soon ground 
dom represents current domain indexical constraint seen machine propagation constraint solving 
possible directly encode higher level fd constraints fern ndez hill basic constraint 
feasibility efficiently integrating indexical approach prolog wam demonstrated implementation diaz 

language constraint handling rules chr language library built top ecl ps amalgamating chrs underlying language 
chr define simplification propagation user defined constraints 
simplification rule replaces constraints simpler constraints preserving logical equivalence 
example false 
propagation rule adds new constraints logically redundant may cause simplifications 
example repeatedly applying chrs incrementally simplifies possibly solves user defined constraints 
note chrs originally intended language constraint simplification shown useful building specialised constraint solvers particular applications domains 

black box languages black box languages examined described 

oz oz new language combining functions relations potential extra expressiveness constraint solver 
oz provides algorithms decide satisfiability implications basic constraints take form variables nonnegative integer finite domain 
basic constraints reside constraint store 
non basic constraints contained store imposed propagators 
oz propagator computational agent posted variables occurring corresponding domain 
reads constraint store tries narrow domains posted amplifying store basic constraints 
example suppose constraint store containing domain variables domain 
propagator narrows domain 
propagator said constrain variables comparative study adding constraint narrows domain domain 
propagators provided glass black box languages 
glass box languages indexicals chrs basic components propagators constructed 
hand black box languages means specifying directly constraint propagation propagators primitives determined solely operational semantics 

ecl ps ecl ps includes traditional finite domain constraints incorporated logic programming systems 
supports writing extensions new user defined constraints complete new constraint solvers chr 
extensions mechanism suspension waking goals provided ecl ps extension user needs knowledge underlying system reason ecl ps catalogued glass box language 
note addition integers fd library allows atomic atoms strings floats ground compound elements 

ilog solver ilog solver library constraint programming underlying data control structures defined 
strictly clp system 
uses clp approach popular commercial system solving constraint satisfaction problems include systems studied 
ilog solver constraint object boolean expression values false true 
actual value depends satisfiability constraint constraint violated expression bound expression satisfied bound 
expressions constrained combined logical operators create complex constraints 
constraint posted means function constraint immediately reduce domains constrained variables involves 
backtracking provided combining non deterministic elements 

prolog ecl ps system provides set traditional finite domain predicates arithmetic boolean constraints set primitives process domain variables 
note set built constraint predicates smaller provided ecl ps fern ndez hill 
srq puzzle 

ease learning discuss ease learn different clp languages experience writing solutions srq problem described section 
ease new language may learned depends factors including learners background availability helpful documentation personal tuition 
perspective prolog functional programming languages clp fd sicstus prolog simplest master main constraint form declarative prolog predicate 
black box constraints ecl ps prolog straightforward built prolog provided useful high level tools needed problem 
oz unfair advantage oz implementation srq problem 
compared clp fd sicstus prolog needed learnt language effectively 
ilog solver requires working knowledge impose syntactic extension new language syntax needs learnt 
chr learn new language syntax understand novel constraint propagation mechanism defined syntax system took longest master 

self referential quiz solutions section describe alternative formulations srq puzzle defined 
formulation uses boolean representation boolean variables uses representation requiring variables range numbers 
formulations useful demonstrate differences performance boolean fd solutions different systems illustrate aspects meta reasoning capabilities languages reification meta constraints 
note reason consider possibly comparative study 
solutions srq variables 
efficient solutions problem aspects discussed detail subsections 

representation booleans representation defines srq satisfiability problem 
question options options expressed logical formula connectives conjunction disjunction negation equivalence 
boolean variables lij lij value true answer question false 
call representation variables formulation 
formulation translated oz program 
left hand table shows solution srq representation 

compact representation meta constraints compact representation srq puzzle single variable question assigns value correct answer question variable style usual representation queens problem 
reason representation srq involving fd variables call variables formulation studied 
exactly finite domain variable qi questions 
qi takes value domain answer th question position qi list 
right hand table shows solution representation 
see information representations described 

reification meta constraints section explain reified constraints meta constraints coded languages clp fd ecl ps oz sicstus prolog ilog solver prolog chr 
languages analysed subsection 
chr language considered separately subsection chr language flexible fern ndez hill chr code written styles languages 
srq puzzle illustrate 
important note consider aspect expressiveness concerned reification meta constraints 
comprehensive discussions concerning expressiveness consider aspects ability express search strategies ease development integration constraint satisfaction techniques ease reusing previous development exploitation additional libraries 

reified constraints reified constraints reflect validity constraint boolean variable 
constraints reified form allow fulfillment reflected back fd variable 
example constrains soon inequation known true soon inequation known false 
hand constraining imposes inequation constraining imposes negation 
logical formula associated option question variables formulation srq expressed reified constraints follows af variable defined truth value af defined truth value 

meta constraints meta constraints provide means expressing constraints constraints 
meta constraints logical connectives applied directly constraint expression logical connectives 
example logical formula associated option question variables formulation srq expressed meta constraints follows af variable truth value qi af truth value qi 
expressing reification meta constraints discuss means language express meta constraints reified constraints 
formulas highlight differences languages 
comparative study oz sicstus prolog languages allow reified constraint form admit propagators concatenation way arg arg rn argn rn argn ri propagator arguments 
instance disjunction propagator concatenated way di boolean variable 
propagators operate directly boolean variables boolean variables represent disjunction negation propagators respectively constraint expressions 
fd variables values belong domains 
meta constraints combined reified constraints instance boolean variable 
ecl ps ilog solver propagators concatenated oz sicstus prolog 
main difference languages propagators limited operate constraint expressions fd variables directly variables 
direct application constraint propagators disjunction conjunction negation boolean variables allowed 
instance express negation boolean variable true write ecl ps resp 
ilog 
ecl ps allow reified constraints 
ilog solver allows reification boolean variables 
clp fd prolog fd constraint propagators relational form way result propagator result fd boolean variables close style traditional prolog 
possible employ concatenation shown languages means cases large numbers extra variables needed 
boolean operators require relational form means code needs large number extra fd variables 
meta constraints implemented clp fd direct way 
instance constraint imposed variable formula truth value qi best expressed follows 
fern ndez hill code required detects constraint true 
explained clp fd framework extended constraints expressed just constraints form 
idea implemented current version language approach solving magic square problem adopted 
instance constraint predicate 
call means bis true defined bin dom xin val 
returns ifx delayed instantiated yields range user functions written accept ranges terms argument 
clp fd constraint expressed follows 
note just constraint additional boolean variables necessary 
prolog clp fd meta constraints defined directly reification boolean variables expressed means delay clauses avoids need code 
done defining predicate iff follows delay iff dvar dvar true 
delay iff dvar dvar true 
iff integer 
iff 
iff true 
note equality disequality propagators respectively 
part body clauses called guard 
clauses called delay clauses guards form dvar checks argument domain variable 
result delay clauses iff clauses executed instantiated unique values 
remaining clauses define iff 
guards integer true 
guard clause succeeded remaining clauses defining iff discarded call determinate 
call iff means true constraint imposed false disequality imposed 
hand constraint true false imposed true false 
constraint coded follows iff iff iff iff iff iff 
comparative study 
chr special mention expressively speaking chr deserves special consideration due flexibility writing solvers 
particular glass box approach allows provide formulation different styles 
demonstrate flexibility clp fd language model writing formula chr code 
different clp fd boolean propagators easily simulated chr constraints 
meta constraints reified constraints problem chr 
instance formula coded chr style close oz 
done defining equivalence propagator constraint expressions means definition solve predicate receives argument logical restriction variable constraints meta constraint fd variables returns second argument result 
impose constraint value denoting true argument constraint argument 
formula expressed chr follows solve solve af solve af 
argument solve predicate simulates minor differences oz code employed program formula 
note oz arithmetic propagators defined boolean propagators conjunction disjunction negation respectively done oz program srq 

efficiency compared section compare efficiency constraint systems described section 
subsection describes labeling strategies gives results solving srq different approaches described section 
efficiency study extended benchmarks subsection section concludes evaluation results 
note systems chr provide built symbolic constraints benchmarks code 
particular systems provided different constraint employed applicable 
tried maintain formulation benchmark systems exploit facilities provided system obtain best possible results 

labeling known constraint solving seen combination processes constraint propagation labeling 
constraint propagation procedure reads fern ndez hill constraint store imposes constraints means constraint propagators 
labeling assigns values domain variables instantiation 
labeling process consists choosing variable variable ordering assigning variable value belong domain value ordering 
variable ordering value ordering labeling considerably influence efficiency constraint solving solution problem required 
little effect search solutions 
study considered labelings naive labeling fail labeling 
fail labeling uses principle says succeed try fail 
principle recommends choice constrained variable finite domain means choosing variable smallest domain 
refinement commonly fail labeling consists choosing case recommended variable appears greatest number constraints 
results obtained fail labeling 
far possible maintained variable value ordering systems efficiency comparison 
naive labeling 
contrast fail naive labeling simple labeling chooses left list variables selects smallest value domain 
naive labeling assures variable value ordering systems ways efficient better comparing different systems solution required 
additional results solution search obtained naive labeling 
performance results 

efficiency compared srq subsection discuss efficiency systems solving srq 
consider formulations described section 
examine choice representation affects performance efficiency results 
performance systems srq compared variables formulation variables formulation 

comparing search trees hardness kind puzzle number choice points traversed finding solution 
reason compare different oz programs different approaches variables giving particular inference machine performs search called explorer tool 
allows search tree visualised shown 
choice nodes denoted circles failure nodes squares solution nodes diamonds 
left tree shows search tree original oz program solution search srq solving fail labeling see subsection 
tree contains nodes choice nodes 
right tree shows conditions search tree comparative study 
oz explorer srq solving fail labeling solution search 
variables formulation contains nodes choice nodes 
reduction number choice nodes 

srq results boolean domain performance set programs srq implemented approaches shown subsection 
original solution oz involves boolean variables programs implemented similarly 
modified labeling strategy original oz program wanted efficiency comparisons conditions labeling 
fail labeling see subsection programs chr built labeling constraint handling rules 
able install systems machine machines sparcstation ipx mhz pentium pro pc operating linux 
srq programs ecl ps chr available library ecl ps clp fd ilog solver prolog oz measured sparcstation programs sicstus prolog ecl ps run pc 
note program ecl ps measured machines provide means comparing results platforms 
table summarises results programs sparcstation table gives results programs pc 
meaning columns follows 
column gives name constraint language implementation 
second column gives running time fern ndez hill table 
performance results variables formulations srq sparc mhz 
language time time speedup ilog solver clp fd ecl ps chr prolog oz table 
performance results variables formulations srq pc linux 
language time time speedup sicstus prolog ecl ps table 
normalisation results variables formulations ecl ps column 
ilog clp fd oz chr sicstus prolog ecl ps prolog find unique answer measured milliseconds 
column shows time explore search space 
column gives average speed 
table relation original program oz table relation ecl ps symbol table indicates number average slow speed respect oz 
slow chr high provided result solution search 
give idea efficiency systems respect table shows speedup system relation ecl ps taken 
results show srq problem ilog clp fd programs fastest oz sicstus prolog prolog times slower 
systems times fast ecl ps course times needed solve srq problem high real differences performance systems necessarily indicated subsection compare performance systems larger set benchmarks 
chr program comparative study table 
comparable results variables formulation srq sparc mhz 
language time time speedup speedup prec ilog solver clp fd ecl ps chr prolog oz table 
comparable results variables formulation srq pc linux 
language time time speedup speedup prec sicstus prolog ecl ps table 
normalisation results variables formulation column ecl ps ilog clp fd oz chr sicstus prolog ecl ps prolog far slowest 
expected chr implemented top ecl ps system 

srq results variables approach variables formulation subsection implemented program languages 
variables approach results measured different machines normalised ecl ps results 
tables show results table shows speedup systems respect ecl ps system 
meanings columns tables tables 
just variables formulation result solution search chr 
note table column speedup gives speed respect original program oz respect variables formulation oz table respect ecl ps program variables 
fifth column speedup prec indicates speed factor respect variables program implemented fern ndez hill language results tables 
programs implemented variables approach improve speed programs implemented style original oz program involving boolean variables 
illustrates change representation may significantly affect performance 
table compares programs variables formulation normalising results relative ecl ps timings 

comprehensive comparison 
extra benchmarks clear single benchmark may bias performance results unfairly 
typically constraint languages dominate application resulting performance figures vulnerable slight variations implementation constraints 
order comparison objective extended include known benchmarks problem variables ranging linear equation disequations alpha cipher problem involving variables equations disequations equation system linear equations variables equation system linear equations variables queens place queens chessboard way queen attacks magic sequences calculate sequence numbers number occurrences series position sequence 
programs alpha equation equation test efficiency systems solve linear equation problems 
queens magic sequences programs scalable useful test systems works bigger instances problem 
note number variables number values variable grow linearly value fd variables declared domains range programs measurements extra benchmarks listed provided system written improved language designers 
policy meant system appropriate programs compared 
measured time required finding just solution possible finding solutions 
results obtained fail labeling 
observed subsection choice labeling affect performance searching just comparative study solution 
just solution case systems compared naive labeling 
performance results 
ecl ps initially queens program provided system adaptation sicstus program magic sequences 
performance poor 
reason inefficiency fail labeling see 
smallest domain chosen defined dependent implementation 
order improve efficiency fail labeling joachim improve speed factor 
obtain improvements programs compiled debugging information garbage collection result magic sequences program improved speed factor 
lack garbage collection reduced size problems solved 
noted removing garbage collection systems sicstus improve performance 

benchmarks measured fail labeling results tables obtained fail labeling 
benchmarks times needed obtain solution measured constraint systems chr 
chr benchmarks variables solutions srq 
solutions benchmarks extremely inefficient solutions supplied chr library running existing ecl ps code chr finite domain library suggested chr author slow 
excuse observe chr built writing efficient solvers defining adequate constraints solvers particular problems specific domains 
scalable problems queens magic sequences times finding possible solutions measured constraint systems chr 
explained subsection able install systems machine measurements clp fd chr ilog oz prolog obtained different machine sicstus prolog 
programs ecl ps timed machines results compared 
timings seconds 
tables show results ilog solver clp fd oz chr ecl ps prolog sparcstation ipc mhz table gives times finding solution table times obtaining solutions queens magic sequences problems 
tables show results sicstus prolog ecl ps pentium pro pc operating linux 
table gives times finding solution table shows times obtaining solutions queens magic sequences problems 
tables error clp fd columns means error message trail stack overflow returned 
avoided increasing size environment variable associated stack solution slow 
error fern ndez hill table 
performance results sparc mhz solution search 
benchmark ilog clp fd oz chr ecl ps prolog srq srq queens queens error alpha eq 
eq 
magic magic magic error magic error error error magic error error error magic error error error error table 
performance results sparc mhz solutions search 
benchmark ilog clp fd oz ecl ps prolog queens queens queens queens queens magic magic magic error magic error error error magic error error error comparative study table 
performance results pc linux solution search 
benchmark sicstus prolog ecl ps srq srq queens queens alpha eq 
eq 
magic magic magic magic magic error magic error table 
performance results pc linux solutions search 
benchmark sicstus prolog ecl ps queens queens queens queens queens magic magic magic magic error magic error fern ndez hill table 
normalisation table solution search 
benchmark ilog clp fd oz chr sicstus prolog ecl ps prolog srq srq queens queens error alpha eq 
eq 
magic magic magic error magic error error magic error error error magic error error error error table 
normalisation table solutions search 
benchmark ilog clp fd oz sicstus prolog ecl ps prolog queens queens queens queens queens magic magic magic error magic error error error magic error error error comparative study table 
performance results sparc mhz solution search naive labeling 
benchmark ilog clp fd oz chr ecl ps prolog srq srq alpha eq 
eq 
magic magic magic error magic error error error magic error error error magic error error error error oz column oz system died solving problem 
error ecl ps columns means stack error 
error prolog column means trail control stack overflow error received 
anomalous results tables oz sicstus ecl ps queens took longer queens due choice fail labeling 
results shown naive labeling consistent 
results shown tables normalised means ecl ps timings 
normalisation results solution search shown table solutions search shown table 
cell contains speedup respect ecl ps solution 
symbol means number average slow respect ecl ps system 
cases ecl ps returned error calculated average differences machines measure results normalised results prolog 
note occurs rows tables 

benchmarks measured naive labeling efficiency results naive labeling see subsection shown tables 
note queens problem results shown running times high 
results solution search shown 
results solutions search similar shown fail labeling 
fern ndez hill table 
performance results pc linux solution search naive labeling 
benchmark sicstus prolog ecl ps srq srq alpha eq 
eq 
magic magic magic magic magic error magic error table 
normalisation table solution search naive labeling 
benchmark ilog clp fd oz chr sicstus prolog ecl ps prolog srq srq alpha eq 
eq 
magic magic magic error magic error error magic error error error magic error error error error comparative study 
robustness table 
number fd variables managed magic sequences problem 
ilog clp fd oz ecl ps prolog 
table 
number fd variables managed magic sequences problem 
ecl ps sicstus prolog 
machines efficiency comparison robustness systems measured 
magic sequences programs garbage collection measured maximum value system manage 
tables give interval fd variables 
system succeeded minimum interval failed maximum 
note machines upper bound ecl ps due garbage collection tests ecl ps extremely slow 
chr evaluated 
spite different configurations machines results ecl ps 
note precise values results dependent machine 
results provide indication comparative robustness systems 

results analysed section summarise compare performance results provided subsections 
ilog solver 
general ilog far fastest system 
ilog extremely robust solving magic sequences problem variables 
clp fd 
gave results fast ilog 
unfortunately gave error messages problem size increased indicating scale respect number fd variables 
able solve larger problems changing size certain environment variables performance really poor 
example change clp fd solved queens problem solution search seconds times slower ecl ps 
fern ndez hill oz oz faster ecl ps finding solutions 
obtaining solutions magic sequences problem fast clp fd 
oz robust clp fd failed obtain solution magic sequences problem 
sicstus prolog similar performance figures times fast ecl ps prolog performed badly alpha benchmark 
note prolog worked particularly solution search better clp fd ilog 
sicstus prolog robust clp fd oz ecl ps sicstus greater robustness able solve magic sequences problem fd variables prolog failed solve problem fd variables 
prolog clp fd system worked problems involving small number fd variables 
increased number fd variables queens magic sequences problems performance deteriorated rapidly leading cases program aborted error messages 
direct consequence fact version prolog garbage collector 
ecl ps slowest results chr 
obtain best possible performance figures table ecl ps garbage collection disabled 
garbage collection magic sequences problem took times longer find solution 
results error message scalable benchmarks number fd variables large 
fact cases problems solved poor performance 
example garbage collection magic sequences problem solved 
garbage collection enabled solved sparc station solution search seconds seconds seconds 
chr slowest 
reasons system tested built top ecl ps poor performance chr designed primarily efficiency defining adequate constraints solvers particular problems specific domains 
comparative study 
popular different constraint systems different approaches black box glass box compared boolean finite domains 
focused comparison efficiency specific aspects expressivity concerning reified constraints meta constraints 
showing main differences systems provided guidelines help choice adequate constraint language solving specific constraint satisfaction problem 
noted simple problems 
implementing systems required considerable amount tests needed large amount computing time power 
resources needed realistic problems comparing contrasting clp systems 
noted compared fd libraries 
similar comparative studies common domains intervals reals 
alternative approaches integer linear programming considered comparison systems 
subject 
summarise results maximum efficiency ilog solver best 
clp fd candidate provided size problem measured number fd variables fairly small 
expressive point view chr best 
supports accepted view chr particularly useful building specialised constraint solvers nonstandard applications 
balance expressiveness efficiency prolog sicstus tests sicstus greater robustness 
language expressiveness chr efficiency comparable ilog solver 
implementation chr solver top efficient system ilog worthwhile 
alternatively useful different glass box approaches indexicals chr combined give new glass box approach benefits clp fd chr 
srq study combines number interesting features 
puzzles provide useful benchmarks evaluating new implementations existing fd languages basis studying new language extensions 
srq solutions compared available internet 
acknowledgments grateful people helped 
particular daniel diaz answering questions clp fd mark wallace useful comments joachim users oz ecl ps systems help improving solutions mats carlsson sicstus solution magic sequences problem useful comments sicstus sending newer clp fd library sicstus 
rg providing efficient oz solutions magic sequences queens problems helpful comments preliminary version 
wish andrew answering questions prolog helmut fern ndez hill simonis sending data solution files comparison 
grateful anonymous referees useful comments earlier versions 
epsrc gr gr cicyt tic partly supporting different stages research 
notes 
suggested mark wallace personal communication available 

syntax propagator changes language 

personal communication fa zhou 

propagation possible variable propagators depend chosen maximal value tried 
case suitable strategy general condition propagate better 

note oz taken provided original solution 

personal communication joachim 

personal communication mark wallace joachim 

personal communication thom fr 

note machine different measure results srq solving subsection 

pse user manual 

ecrc munich 

benhamou 

interval constraint logic programming 
constraint programming basics trends podelski editor lncs springer verlag pp 


carlsson carlson 

open ended finite domain constraint solver 
proc 
th international symposium programming languages implementations logics programs plilp lncs springer verlag pp 


carlson carlsson diaz 

entailment finite domain constraints 
proc 
th international conference logic programming mit press pp 


diaz 

minimal extension wam clp fd 
proc 
th international conference logic programming mit press pp 


diaz 

clp combining simplicity efficiency boolean constraint solving 
proc 
th international symposium programming languages implementation logic programming plilp lncs springer verlag pp 


diaz 

compiling constraints clp fd 
journal logic programming 

diaz 

local propagation methods solving boolean constraints constraint logic programming 
journal automated reasoning 



review industrial constraints solving tools 
ai intelligence 



look clp theory application 
applied artificial intelligence 

fern ndez hill 

boolean finite domain solvers compared self referential 
proc 
joint conference declarative programming pp 

comparative study 
fern ndez 

www lcc uma es srq 

fr 

constraint handling rules 
constraint programming basics trends podelski editor lncs springer verlag pp 


haralick elliot 

increasing tree search efficiency constraint satisfaction problems 
artificial intelligence 



don puzzled 
workshop constraint programming conjunction nd international conference principles practice constraint programming cp 

prolog constraints package 

siemens informationssysteme ag munich germany 

ilog solver manual version 


jaffar lassez 

constraint logic programming 
proc 
th acm symposium principles programming languages popl pp 


jaffar michaylov stuckey yap 

clp language system 
acm transactions programming languages systems 

jaffar maher 

constraint logic programming survey 
journal logic programming 

ller 

interfacing propagators concurrent constraint language 
workshop parallelism implementation technologies constraint logic languages 

dong 

prolog iv ou la programmation par contraintes 
proc 
mes journ es de programmation logique programmation par contraintes pp 


puget 

glass box constraints objects 
proc 
international symposium logic programming ilps mit press 

schulte 

solver oz search debugger 
proceedings international workshop oz programming woz institut molle intelligence artificielle perceptive martigny switzerland 

sicstus prolog user manual release 

intelligent systems laboratory swedish institute computer science 



language optimizing constraint propagation 
phd thesis simon fraser university 

smolka 

oz programming model 
computer science today jan van leeuwen editor lncs springer verlag pp 


van hentenryck 

tutorial chip systems applications 
workshop constraint logic programming 
rehovot israel weizmann institute science 

van hentenryck 

constraint satisfaction logic programming 
mit press 

van hentenryck saraswat deville 

design implementation evaluation constraint language cc fd 
constraint programming basics trends podelski editor lncs springer verlag pp 


proc 
sixth international conference practical application prolog fourth international conference practical application constraint technology 

publisher practical application 
zhou 

prolog user manual version 
faculty computer science systems engineering kyushu institute technology fukuoka japan 
