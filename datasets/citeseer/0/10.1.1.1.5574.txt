koorde simple degree optimal distributed hash table koorde new distributed hash table dht chord de bruijn graphs 
inheriting simplicity chord koorde meets various lower bounds log hops lookup request neighbors node number nodes dht log log log hops lookup request log neighbors node 
number different performance measures exist dhts optimizing tends put pressure 
measures include 
degree number neighbors node maintain continuous contact 
hop count number hops needed get message source destination 
degree fault tolerance fraction nodes fail eliminating data preventing successful routing 
maintenance overhead messages passed nodes neighbors maintain coherence nodes join depart 
degree load balance evenly keys distributed nodes load node experiences intermediate node routes 
measures dhts delay proximity routing resilience malicious nodes page limit research conducted part iris project project iris net supported national science foundation cooperative agreement 
ani 
mathematical chord koorde dutch language 
frans kaashoek david karger mit laboratory computer science kaashoek karger lcs mit edu ignore 
quick survey existing systems shows common trends 
degree tends logarithmic worst polylogarithmic 
hop count generally logarithmic 
bounds turn close optimal optimal 
point constant degree log hops optimal 
show provide high degree fault tolerance node maintain log neighbors case log log log hop count may achieved 
koorde simple dht exploits de bruijn graphs achieve lower bounds 
koorde may important practice low maintenance overhead 
bounds tradeoffs section discuss lower bounds tradeoffs dht measures 
degree hop count observation relates degree routing hops system lemma 
node system maximum degree requires log routing hops worst case log average 
proof 
maximum degree number nodes distance induction 
log follows node distance log 
claim follows corollary fact nodes distance log 
protocols chord kademlia pastry tapestry offer log degree hop count 
uses degree achieve dn hops 
near optimal bounds lower bound allows log hops constant degree ii degree log achieving log log log hops 
viceroy dht provides constant expected degree 
high probability bound log fact unlucky nodes log degree 
viceroy relatively complex 
example involves estimating size network select various levels nodes system 
furthermore fault tolerance discussed viceroy 
fault tolerance maintenance strong notion fault tolerance requires live nodes remain connected presence node failures 
connectivity necessary sufficient condition efficient routing 
lemma 
order network stay connected constant probability nodes fail probability nodes degree log 
proof 
suppose maximum degree log log log 
probability particular node isolated staying losing neighbors log log log log nodes expect log nodes isolated 
gives want deal technically fact node independent node isolated living neighbor decreases odds nodes isolated 
maximum degree node neighbors distance 
follows set nodes share neighbors set greedy algorithm take node include delete distance neighbors repeat 
nodes share neighbors isolation events independent prob ability node gets isolated log inequality 
words event happens constant probability 
star graph node degree exceeding manages stay connected constant probability model 

system want node substantially average degree 
restriction lemma strengthened average degree log 
space precludes proof 
particular case network partition thought collection failures nodes side partition tolerating failure rate means larger half system stay connected partition 
argument generalizes failure probabilities roughly speaking expected number surviving neighbors pd log 
similar argument applied maintenance traffic 
liben nowell balakrishnan karger introduce notion half life time takes peer peer network replace half nodes departures new arrivals prove node notified log nodes half life network remain connected 
dhts support mechanism handling failures provide analytical results 
chord dht uses successor lists log neighbors node proves successor lists network remains connected continues route efficiently high probability half nodes fail simultaneously 
building successor lists liben nowell balakrishnan karger show limit maintenance traffic log node half life compared lower bound log 
fiat gribble karlin saroiu provide dht analytical results presence malicious nodes 
dht adversarially fault tolerant adversary killing half nodes necessarily random able disconnect fraction surviving nodes 
achieve high level fault tolerance performance sacrificed 
node maintains log state 
lookups take log time require log messages 
data item replicated log times 
metadata various items distributed log nodes 
load balance dhts discussed offer load balance amount data stored amount routing traffic carried 
general node load log factor average load system high probability 
chord dht shows replicating node log virtual nodes possible improve maximum average load ratio constant arbitrarily close 
similar technique applied dhts mentioned including koorde 
replication increase state needed node maintenance overhead logarithmic factor 
schemes optimal degree hop count koorde viceroy give optimality constant factor load balance achieved 
open question find system degree optimal load balanced 
koorde constant degree dht koorde combines chord de bruijn graphs 
looks key contacting log nodes state node 
chord koorde uses consistent hashing map keys nodes 
node key identifiers uniformly distributed identifier space 
key stored successor node follows identifier circle node followed node 
successor key identified successor 
de bruijn graphs routing koorde embeds de bruijn graph identifier circle forwarding lookup requests 
de bruijn graph node binary number bits 
node outgoing edges node edge node mod edge node mod see 
words node points nodes identified shifting new low order bit dropping high order bit 
represent nodes concatenation mod writing mod mod assume system number corresponds node de bruijn routing works follows 
nodes system consistent hashing map key node successor routing message node node accomplished number shifting de bruijn graph 
procedure lookup return owns return lookup lookup key node de bruijn graph 
key shifted previous iterations 
call bits time number replaced see 
shift corresponds routing hop intermediate address hop valid node neighbors possible outcomes shifting address 
structure de bruijn graphs bit shifted query node node responds key exists 
lookup algorithm contact log nodes left shifts query destination node 
support forwarding step node maintains information de bruijn neighbors 
koorde routing systems contain possible nodes subset nodes joined point time large reasons avoid collisions size determined output cryptographic hash function 
points identifier circle correspond nodes joined system points ring correspond imaginary nodes 
embed de bruijn graph sparsely populated identifier ring joined node maintains knowledge nodes address node succeeds ring successor node precedes de bruijn node 
de bruijn nodes follow directly ring reason keep variable second de bruijn node predecessor 
look key lookup algorithm find successor walking de bruijn graph 
de bruijn graph incomplete koorde simulates path taken complete de bruijn graph passing immediate real predecessor predecessor imaginary node de bruijn path 
shows koorde routing extension de bruijn routing 
koorde passes current imaginary node argument routing function 
single routing step koorde simulates hop imaginary node imaginary node shifting koorde hopping value near hopefully equal predecessor 
koorde iterates routing step 
hop predecessor koorde contacts nodes number bits identifiers algorithm shifts left bit hop 
unfortunately definition closest predecessor may closest predecessor nodes random distribution ring perfectly node interpose land 
koorde checks case corrects 
node receives query checks predecessor examining successor pointer 
koorde takes de bruijn hop 
forwards query forward ring successor pointers predecessor encountered 
section algorithm calls lookup 
bound bound number successor lookups 
lemma 
course doing lookup high probability number routing hops 
proof 
conserve space analyze expected procedure lookup successor return successor successor return lookup return successor lookup koorde lookup algorithm node key 
imaginary de bruijn node 
contains predecessor successor contains successor number hops high probability extension standard 
single step simulating advance imaginary node imaginary node move node predecessor node advance predecessor successor pointers 
nodes traverse way precisely ones located identifier space 
conditioned values fact nodes randomly distributed ring means odds node landing values expected number nodes region identifier space remove conditioning notice regardless nodes inserted randomly expected value distance identifier space expected value 
words imaginary hop involves expectation successor pointers 
total expect follow de bruijn pointers successor pointers 
maintaining predecessor successor total pointers node reduce expected number successor hops shift reducing expected routing cost 
lookup log hops lookup algorithm described far contacts nodes large number bits identifiers 
reduce number hops log high probability carefully selecting appropriate imaginary starting node 
section started lookup node query originated 
responsible imaginary nodes successor choose cost simulate starting imaginary de bruijn node successor 
ring contains real nodes top bits significant set bottom bits value chose leaving region 
choose bottom bits top bits key soon lookup algorithm shifted top bits reached node responsible high probability distance identifier space successor exceeds means region contains imaginary nodes possible values lowest lg lg significant bits means set bits equal high order bits left shift lg significant bits current address requires log hops 
maintenance concurrency just finger pointers chord koorde de bruijn pointer merely important performance optimization query reach destination slowly successors 
property koorde chord join algorithm 
similarly keep ring connected presence nodes leave koorde chord successor list stabilization algorithm 
chord nice self stabilizing property ring consisting successor pointers quickly construct fingers pointer jumping unclear koorde similarly self stabilize 
extensions allow users trade degree hop count extend koorde degree de bruijn graphs 
choosing log koorde fault tolerant 
degree de bruijn graphs koorde generalized provide simple optimal trade routing table size routing hop count 
traditional de bruijn graph node edges nodes 
graph allows shift new address bit single edge traversal 
idea generalized different non binary base 
base de bruijn graph connects node nodes labeled km km 
km 
resulting graph degree shifting factor time diameter log idea carried koorde 
letting node point predecessor koorde node points predecessor km nodes immediately 
shown scheme expect constant number hops real nodes simulate single imaginary node hop correcting single base digit 
expect complete routing log hops matching optimum lower bound degree networks 
fault tolerance base koorde constant degree lemma earlier fault tolerant nodes failing constant probability 
achieve fault tolerance need increase minimum degree log approach straightforward 
provide fault tolerance immediate successors successor list maintenance protocol developed chord maintaining immediate successor maintains log nodes immediately 
nodes fail probability nodes successor list stay alive high probability 
case routing possible worst live successor pointers correct node 
koorde provide similar backup case distant node points predecessor fails 
node fails immediate predecessor ring new correct node point 
koorde proactively points predecessor log nodes ring immediately preceding 
think easiest way provide set predecessor list construction similar successor list 
construction violate key invariants prove correctness chord protocol 
particular successor pointers predecessor pointers may point ring nodes initiated chord join protocol completed pointing new nodes lookup operations incorrect 
fortunately slightly different approach 
set pointers node uses lookup find immediate predecessor immediate predecessor log chosen high probability log nodes occupy interval 
node retrieve successor list gives set log nodes reaching point interval 
nodes provide necessary redundancy half nodes fail high probability pointer immediate predecessor address 
scheme requires estimate easy achieve practice considering distribution nodes successors 
attempt gain fault tolerance eliminated constant degree attraction koorde 
koorde extra degree working base de bruijn graph koorde base log de bruijn graph 
graph koorde fault tolerance number routing hops log log log optimal 
related de bruijn graphs routing concurrent noted application dhts 
compared related primary contribution simulate lookup de bruijn graph sparsely populated identifier space 
koorde approach de bruijn graphs different 
dht attempts organize nodes nodes form de bruijn graph guarantee graph constructed de bruijn graph 
result guarantee high probability degree 
modifies node identifiers create de bruijn graph 
koorde puts restrictions applications choose node identifiers 
koorde inherits chord algorithms handling concurrent joins technical report doesn discuss topic 
summary koorde allows users tune degree log achieve hop counts ranging log log log log 
lets users trade maintenance overhead hop count may important practice systems flux 
implementation koorde available part chord software distribution www 
pdos lcs mit edu chord 
broadcasting gossiping de bruijn networks 
siam journal computing 
de bruijn combinatorial problem 
proc 
akademie van vol 
pp 

fault tolerant routing de bruijn communication networks 
ieee trans 
computers 
content addressable network 
tech 
rep cnrs de paris sud january 
hildrum rao zhao distributed object location dynamic network 
proc 
th acm symp 
parallel algorithms architectures aug 
karger lehman leighton levine lewin panigrahy consistent hashing random trees distributed caching protocols relieving hot spots world wide web 
proc 
th annual acm symposium theory computing el paso tx may pp 

liben nowell balakrishnan karger analysis evolution peer peer systems 
proc 
podc aug 
malkhi naor viceroy scalable dynamic emulation butterfly 
proceedings principles distributed computing podc july 
maymounkov mazieres kademlia peer topeer information system xor metric 
proc 
st international workshop peer peer systems mar 
ratnasamy francis handley karp shenker scalable content addressable network 
proc 
acm sigcomm san diego ca august pp 

rowstron druschel pastry scalable distributed object location routing large peer peer systems 
proceedings th ifip acm international conference distributed systems platforms middleware nov 
fiat gribble karlin saroiu dynamically fault tolerant content addressable networks 
proc 
st international workshop peer peer systems mar 
de bruijn multiprocessor network versatile parallel processing sorting network vlsi 
ieee trans 
computers 
ramaswami multihop networks de bruijn graphs 
infocom pp 

stoica morris karger kaashoek balakrishnan chord scalable peer peer lookup service internet applications 
proc 
acm sigcomm san diego aug 
