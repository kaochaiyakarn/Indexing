bucket elimination unifying framework probabilistic inference dechter department information computer science university california irvine dechter ics uci edu 
probabilistic inference algorithms belief updating finding probable explanation maximum posteriori hypothesis maximum expected utility reformulated bucket elimination framework 
emphasizes principles common algorithms appearing probabilistic inference literature clarifies relationship algorithms dynamic programming algorithms 
general method combining conditioning bucket elimination 
algorithms bounds complexity function problem structure 

overview bucket elimination unifying algorithmic framework generalizes dynamic programming accommodate algorithms complex problemsolving reasoning activities including directional resolution propositional satisfiability davis putnam adaptive consistency constraint satisfaction dechter pearl fourier gaussian elimination linear equalities inequalities dynamic programming combinatorial optimization 
presenting framework demonstrate number algorithms probabilistic inference expressed bucket elimination algorithms 
main virtues bucket elimination framework simplicity generality 
simplicity mean complete specification dechter bucket elimination algorithms feasible introducing extensive terminology graph concepts triangulation arc reversal making algorithms accessible researchers diverse areas 
important uniformity algorithms facilitates understanding encourages cross fertilization technology transfer disciplines 
bucket elimination algorithms similar improvement single algorithm applicable expressed framework 
example expressing probabilistic inference algorithms bucket elimination methods clarifies relationship dynamic programming constraint satisfaction knowledge accumulated areas may utilized probabilistic framework 
generality bucket elimination illustrated algorithm area deterministic reasoning 
consider algorithm deciding satisfiability 
set clauses clause disjunction propositional variables negations ordering propositional variables algorithm directional resolution dr dechter rish core known davis putnam algorithm satisfiability davis putnam 
algorithm described buckets partitioning set clauses clauses containing contain symbol higher ordering placed bucket denoted bucket algorithm see processes buckets reverse order processing bucket resolves possible pairs clauses bucket inserts resolvents appropriate lower buckets 
shown empty clause generated process theory satisfiable satisfying truth assignment generated time linear size resulting theory 
complexity algorithm exponentially bounded time space graph parameter called induced width called tree width interaction graph theory node associated proposition arc connects nodes appearing clause dechter rish 
belief network algorithms common resolution procedure 
possess property compiling theory answers extracted easily complexity dependent induced width graph parameter 
algorithms variations known algorithms part new sense basic ideas existed time pearl lauritzen spiegelhalter shachter jensen shachter bacchus van run shachter shachter shimony shenoy 
presenting syntactic uniform exposition emphasizing algorithms form bucket elimination algorithm directional resolution input set clauses ordering output decision satisfiable 
equivalent output theory empty output theory 

initialize generate ordered partition clauses bucket bucket bucket contains clauses highest literal 
ffl bucket contains unit clause perform unit resolution 
put resolvent appropriate bucket 
ffl resolve pair ff fi bucket fl ff fi empty satisfiable add fl appropriate bucket 

return bucket 
algorithm directional resolution straightforward elimination algorithm 
main virtue presentation uniformity allows ideas techniques flow boundaries areas research 
particular having noted elimination algorithms clustering algorithms similar context constraint processing dechter pearl find similarity carries tasks 
show idea conditioning universal elimination incorporated exploited naturally uniformly elimination framework 
conditioning generic name algorithms search space partial value assignments partial 
conditioning means splitting problem subproblems certain condition 
algorithms backtracking branch bound may viewed conditioning algorithms 
complexity conditioning algorithms exponential conditioning set space complexity linear 
resulting hybrid conditioning elimination trade time space see dechter shachter applicable algorithms expressed framework 
fits framework developed arnborg arnborg arnborg 
table reductions various np hard graph problems independent set problem network reliability vertex cover graph colorability hamilton circuits 
dechter van beek dechter extend approach different set problems 
dechter preliminaries section bucket elimination algorithm belief updating analyze performance section 
extend algorithm tasks finding probable explanation section extend tasks finding maximum posteriori hypothesis section finding maximum expected utility section 
section relates algorithms pearl poly tree algorithms join tree clustering 
describe schemes combining conditioning method elimination section 
section 
preliminaries belief networks provide formalism reasoning partial beliefs conditions uncertainty 
defined directed acyclic graph nodes representing random variables takes value domains 
arcs signify direct causal influences linked variables strength influences quantified conditional probabilities 
belief network relies notion directed graph 
directed graph pair fv fx set elements jx jg set edges 
say points variable set parent nodes denoted pa comprises variables pointing set child nodes denoted ch comprises variables points 
confusion arise abbreviate pa pa ch ch family includes child variables 
directed graph acyclic directed cycles 
undirected graph directions arcs ignored identical 
fx set random variables multivalued domains belief network pair directed acyclic graph fp denotes probabilistic relationships parents conditional probability matrices fp jpa belief network represents probability distribution having product form pi jx pa assignment abbreviated denotes projection tuple subset variables evidence set instantiated subset variables 
denotes partial assignment subset variables respective domains 
upper case letter variables nodes graph lower case letters values variable domains 
bucket elimination 
belief network gjf jc djb bja cja example consider belief network defined gjf jc djb bja cja acyclic graph 
case pa fb cg 
queries defined belief networks 
belief updating set observations computing posterior probability proposition 
finding probable explanation mpe observed variables finding maximum probability assignment rest variables 
finding maximum aposteriori hypothesis map evidence finding assignment subset hypothesis variables maximizes probability 
utility function finding assignment subset decision variables maximizes expected utility problem 
known tasks np hard 
permit polynomial propagation algorithm singly connected networks pearl 
main approaches extending propagation algorithm multiply connected networks cycle cutset approach called conditioning tree clustering pearl lauritzen spiegelhalter shachter 
methods sparse networks small cycle cutsets small clusters 
subsequent sections algorithms tasks relationship existing methods discussed 
conclude section notational conventions 
partial tuple subset variables variable denote tuple appended value definition elimination functions function defined subset variables functions minx maxx dechter defined gamma fxg follows 
minx min maxx max jx jx cardinality domain 
set functions defined subsets product function pi defined pi pi 

elimination algorithm belief assessment belief updating primary inference task belief networks 
task maintain probability singleton propositions new evidence arrives 
pearl propagation algorithm singly connected networks pearl researchers investigated various approaches belief updating 
step step derivation general variable elimination algorithm belief updating 
process typical derivation elimination algorithms 
atomic proposition 
problem assess update belief evidence wish compute je ff delta ff normalization constant 
develop algorithm example 
assume evidence 
consider variables order definition need compute gjf jb dja cja bja apply simple symbolic manipulation migrating conditional probability table left summation variables get cja bja jb djb gjf carrying computation right left compute rightmost summation generates function defined gjf place far left possible yielding cja bja jb djb bucket elimination bucket gjf bucket djb bucket jb bucket bja bucket cja bucket 
initial partitioning buckets summing generating function denoted defined dja get cja bja jb summing generating jb get cja bja summing generating get cja summing generating get answer query computed evaluating product normalizing 
bucket elimination algorithm mimics algebraic manipulation simple organizational devise call buckets follows 
conditional probability tables cpts short partitioned buckets relative order follows going variable bucket place functions mentioning remaining cpts place mentioning bucket 
partitioning rule alternatively stated follows 
bucket variable put functions mention mention variable having higher index 
resulting initial partitioning example 
note observed variables placed corresponding bucket 
initialization step corresponds deriving expression eq 

process buckets top bottom implementing dechter sum bucket bucket bucket bucket bucket bucket 
bucket elimination ordering right left computation eq 

processed 
processing bucket amounts eliminating variable bucket subsequent computation 
eliminate sum values case observed value summation singleton value 
gjf computed placed bucket corresponds deriving eq 
eq 

new functions placed lower buckets placement rule 
processed 
sum getting djb computed placed bucket corresponds deriving eq 
eq 

variable bucket contains functions jb eq 
generate function jb delta placed bucket corresponds deriving eq 
eq 

processing bucket function bja delta delta computed placed bucket deriving eq 
eq 

processing bucket cja delta computed corresponds deriving eq 
eq 

belief computed bucket delta 
summarizes flow computation bucket elimination algorithm example 
note process recorded dimensional functions complexity algorithm ordering roughly time space quadratic domain sizes 
occur different variable ordering 
example lets apply algorithm applying algebraic manipulation right left yields sequence derivations cja bja dja jb gjf bucket elimination bucket bucket bucket bucket bucket bucket 
buckets output processing cja bja dja jb cja bucket elimination process ordering summarized 
bucket contains initial cpts denoted functions generated process denoted summarize general derivation bucket elimination algorithm called elim bel 
consider ordering variables 
notation family variable want compute gamma xn pi ejx pa rest variables get gamma pi gammaf ejx pa delta xn ejx pan pi ejx pa gamma pi gammaf ejx pa delta un un xn ejx pan pi ejx pa dechter algorithm elim bel input belief network bn fp ordering variables evidence output belief 
initialize generate ordered partition conditional probability matrices bucket bucket bucket contains matrices highest variable put observed variable bucket 
subset variables processed bucket matrices new old defined 

backward downto matrices bucket ffl bucket observed variable appears bucket assign put resulting function appropriate bucket 
ffl gamma fx generate xp pi add largest index variable 
return bel ffp delta pi bucket ff normalizing constant 

algorithm elim bel denoted variables appearing probability component excluding process continues recursively gamma computation performed bucket captured eq 

ordering queried variable appears cpt partitioned rule described earlier 
process bucket bucket functions denoted defined subsets multiplied bucket variable eliminated summation 
computed function xp pi gamma function placed bucket variable procedure continues recursively bucket variable going variable variable 
buckets processed answer available bucket 
algorithm elim bel described 
theorem algorithm elim bel compute posterior belief je ordering variables 
peeling algorithm genetic trees zhang poole algorithm zhang poole variations elim bel 
bucket elimination 
ordering moral graph example problem 
complexity see elim bel applied ordering complexity varies considerably 
ordering recorded functions pairs variables record functions variables see 
arity function recorded bucket equals number variables appearing processed bucket excluding bucket variable 
recording function arity time space exponential conclude complexity algorithm exponential size largest bucket depends order processing 
fortunately variable ordering bucket sizes easily read advance ordered associated elimination process 
consider moral graph belief network 
graph node propositional variable variables appearing cpt connected graph 
moral graph network 
take moral graph impose ordering nodes 
figures depict ordered moral graph orderings ordering pictured bottom 
width variable ordered graph number earlier neighbors ordering 
width ordered graph width 
notice ordering number variables initial buckets respectively 
initial partitioning number variables mentioned bucket excluding bucket variable identical width node corresponding ordered moral graph 
processing wish maintain correspondance dechter nodes graph connected iff function new old 
processing function recorded variables bucket connect corresponding nodes graph connect earlier neighbors processed variable 
perform graph operation recursively node node connecting earliest neighbors get induced graph 
width node induced graph identical bucket sizes generated elimination process see 
example induced moral graph relative ordering depicted 
case ordered graph induced ordered graph identical earlier neighbors node connected 
maximum induced width 
case maximum arity functions recorded elimination algorithms 
induced graph depicted 
width initially see induced width 
maximum induced width variables recorded function dimensionality 
formal definition graph concepts 
definition ordered graph pair undirected graph ordering nodes 
width node ordered graph number node neighbors precede ordering 
width ordering denoted maximum width nodes 
induced width ordered graph width induced ordered graph obtained follows nodes processed node processed preceding neighbors connected 
induced width graph minimal induced width orderings 
tree width graph minimal induced width plus arnborg 
established connection buckets sizes induced width motivates finding ordering smallest induced width 
known finding ordering smallest induced width hard arnborg greedy heuristics approximation algorithms available dechter becker geiger 
summary complexity algorithm elim bel dominated time space needed process bucket 
recording function bucket variables time space exponential number variables mentioned bucket 
seen induced width bounds arity functions recorded variables appearing bucket coincide earlier neighbors corresponding node ordered induced moral graph 
bucket elimination theorem ordering complexity elim bel time space exponential induced width network ordered moral graph 

handling observations evidence handled special way processing buckets 
continuing example elimination order suppose wish compute belief having observed 
observation relevant processing bucket algorithm arrives bucket bucket contains functions bja observation see 
processing rule dictates computing ja 
generate record dimensioned function 
effective apply assignment function bucket separately put resulting functions lower buckets 
words generate ja placed bucket placed bucket doing avoid increasing dimensionality recorded functions 
processing buckets containing observations manner automatically exploits cutset conditioning effect pearl 
algorithm special rule processing buckets observations observed value assigned function bucket resulting function moved individually lower bucket 
note bucket top ordering virtue conditioning exploited earlier 
processing bucket contains bja djb jc see 
special rule processing buckets holding observations place ja bucket djb bucket jc bucket subsequent processing dimensional functions recorded 
see presence observations reduces complexity 
buckets observed variables processed linear time recorded functions create functions new subsets variables corresponding new arcs added computing induced graph 
earlier neighbors observed variables connected 
capture refinement notion adjusted induced graph defined recursively follows 
ordering set observed nodes adjusted induced graph generated processing top bottom connecting earlier neighbors unobserved nodes 
adjusted induced width width adjusted induced graph 
dechter theorem belief network having variables algorithm ordering evidence time space exponential adjusted induced width network ordered moral graph 

focusing relevant subnetworks improvement elim bel essence restricting computation relevant portions belief network 
restrictions available literature context existing algorithms geiger shachter 
summation values probability function recorded functions buckets degenerate constant 
recognize cases advance avoid needless computation skipping buckets 
topological ordering belief network acyclic graph parents precede child nodes assuming queried variable starts ordering recognize buckets dynamically elimination process 
proposition belief network topological ordering algorithm elim bel skip bucket time processing bucket contains evidence variable query variable newly computed function 
proof topological ordering bucket contain queried variable contains initially function describing probability conditioned parents 
clearly evidence summation yield constant 
example consider belief network acyclic graph ordering assume want update belief variable evidence clearly buckets skipped processing start bucket bucket processed rest buckets 
alternatively relevant portion network precomputed recursive marking procedure applied ordered moral graph 
see zhang poole 
definition acyclic graph topological ordering starts queried variable evidence marking process works follows 
evidence node marked neighbor query variable marked earlier neighbor marked node marked 
queried variable moved top ordering bucket elimination algorithm elim bel 
backward downto matrices bucket ffl bucket observed variable appears bucket substitute matrix put appropriate bucket 
ffl bucket gamma fx xp pi add largest index variable 
improved algorithm elim bel marked belief subnetwork obtained deleting unmarked nodes processed elim bel answer belief updating query 
easy see theorem complexity algorithm elim bel evidence exponential adjusted induced width marked ordered moral subgraph 
proof deleting unmarked nodes belief network results belief subnetwork distribution identical marginal distribution marked variables 

elimination algorithm mpe section focus task finding probable explanation 
task appears applications diagnosis abduction 
example suggest disease patient suffers data clinical findings 
researchers investigated various approaches finding mpe belief network 
see pearl cooper peng reggia peng reggia 
proposals include best search algorithms shimony algorithms linear programming santos 
problem find max pi ejx pa set observations 
computing ordering max xn max xn gamma max xn pi ejx pa accomplished performing operation ordering right left migrating left dechter step components mention maximizing variable 
get max xn max gamma max xn pi ejx pa max xn gamma pi gammaf ejx pa delta max xn ejx pan pi ejx pa max xn gamma pi gammaf ejx pa delta un un max xn ejx pan pi ejx pa variables appearing components defined clearly algebraic manipulation expressions algebraic manipulation belief assessment summation replaced maximization 
consequently bucket elimination procedure elim mpe identical elim bel change 
ordering conditional probability tables partitioned 
process bucket multiply bucket matrices case denoted defined subsets eliminate bucket variable maximization 
computed function case pi gamma function obtained processing bucket placed bucket largest index variable addition function relates optimizing value tuple recorded placed bucket procedure continues recursively processing bucket variable going variable variable 
buckets processed mpe value extracted bucket 
backwards phase terminates algorithm initiates forwards phase compute mpe tuple 
forward phase variables processed mpe tuple computed assigning values ordering consulting information recorded bucket 
specifically partial assignment gamma selected value appended tuple function recorded backward phase 
algorithm 
observed variables handled elim bel 
example consider belief network 
ordering evidence process variables partitioning conditional probability matrices buckets bucket fp gjf bucket fp djb bucket elimination algorithm elim mpe input belief network bn fp ordering variables observations output probable assignment 

initialize generate ordered partition conditional probability matrices bucket bucket bucket contains matrices highest variable put observed variable bucket 
subset variables processed bucket matrices new old defined 

backward downto matrices bucket ffl bucket observed variable bucket contains assign put appropriate bucket 
ffl gamma fx generate functions pi add bucket largest index variable 
forward assign values ordering recorded functions bucket 

algorithm elim mpe bucket fp jb bucket fp bja bucket fp cja bucket fp process assign get hg jf place result bucket function placed bucket 
process bucket computing hd max djb putting result bucket record djb 
bucket processed contains matrices jb hg 
compute max jb delta hg place resulting function bucket eliminate record function hb max bja delta hd delta place bucket eliminate compute hc max cja delta hb place bucket mpe value bucket max delta hc determined mpe tuple going forward buckets 
backward process viewed compilation learning phase compile information regarding probable extension partial tuples variables higher ordering see section 
similarly case belief updating complexity elim mpe bounded exponentially dimension recorded matrices bounded induced width ordered moral graph 
dechter summary theorem algorithm elim mpe complete mpe task 
complexity time space delta exp number variables adjusted induced width ordered moral graph 

elimination algorithm map elimination algorithm map task 
definition task mixture previous algorithm variables eliminated summation maximization 
belief network subset hypothesized variables fa evidence problem find assignment hypothesized variables maximizes probability evidence 
formally wish compute max max pi ejx pa 
algebraic manipulation expression push maximization left summation 
means elimination algorithm maximized variables initiate ordering processed 
algorithm considers orderings hypothesized variables start ordering 
algorithm backward phase forward phase forward phase relative hypothesized variables 
maximization summation may somewhat interleaved allow effective orderings incorporate option 
note relevant graph task restricted marking similar manner belief updating case 
case initial marking includes hypothesized variables marking procedure applied recursively summation variables 
theorem algorithm elim map complete map task 
complexity delta exp number variables relevant marked graph adjusted induced width marked moral graph 

elimination algorithm somewhat complicated task address finding maximum expected utility 
belief network evidence real valued utility function additively decomposable relative functions defined fq subset decision variables fd assumed root nodes task find set decisions bucket elimination algorithm elim map input belief network bn fp subset variables fa ordering variables ordering observations output probable assignment 
initialize generate ordered partition conditional probability matrices bucket bucket bucket contains matrices highest variable 
backwards downto matrices fi fi fi bucket ffl bucket observed variable bucket contains observation assign fi put appropriate bucket 
ffl gamma fx bucket contains new functions fi xp pi fi fi pi fi fi add fi bucket largest index variable 
forward assign values ordering information recorded bucket 

algorithm elim map maximizes expected utility 
assume variables appearing indexed formally want compute max pi ejx pa previous tasks identifying computation associated extract computation bucket 
denote assignment decision variables 
algebraic manipulation yields max gamma xn pi ejx pa separate components utility functions mentioning denoted index set mentioning labeled indexes ng gamma accordingly get max gamma xn pi ejx pa delta ln tn dechter max gamma xn pi ejx pa ln gamma xn pi ejx pa tn migrating left elements function get max gamma pi gammaf ejx pa delta ln xn pi fn ejx pa gamma pi gammaf ejx pa delta xn pi fn ejx pa tn denote subset variables appear probabilistic component excluding union variables appear probabilistic utility components excluding 
define tuple un jd xn pi ejx pa define wn jd xn pi fn ejx pa tn substituting eqs 
eq 
get max gamma pi gammaf ejx pa delta un jd ln wn jd un jd functions compute effect eliminating result eq 
expression include product matrix utility components element fl applying algebraic manipulation rest variables order yields elimination algorithm elim 
assume decision variables processed elim 
bucket contains utility components probability components evidence constant incorporate marking modification elim bel 
processing algorithm generates bucket multiplying bucket elimination algorithm elim input belief network bn fp subset variables decision variables root nodes utility function ordering variables appear observations output assignment maximizes expected utility 

initialize partition components buckets bucket contains matrices highest variable call probability matrices utility matrices probability variable subsets utility variable subsets 

backward downto matrices bucket ffl bucket observed variable bucket contains observation assign put resulting matrix appropriate bucket 
ffl gamma fx gamma fx bucket contains observation new xp pi xp pi xp pi add bucket largest index variable respectively 

forward assign values ordering information recorded bucket decision variable 

algorithm elim probability components summing bucket computed average utility bucket bucket marked average utility bucket normalized resulting placed appropriate buckets 
maximization decision variables accomplished maximization elimination operator 
include step explicitly simplifying assumption decisions root nodes step straightforward 
clearly maximization summation interleaved degree allowing efficient orderings 
algorithm performance bounded function structure augmented graph 
augmented graph moral graph augmented arcs connecting variables appearing utility component theorem algorithm elim computes belief network augmented utility components influence diagram delta dechter 
poly tree legal processing ordering exp induced width augmented moral graph 
shachter published algorithm variation elim kjaerulff algorithm viewed variation elim tailored dynamic probabilistic networks 

relation bucket elimination methods 
poly tree algorithm belief network poly tree belief assessment mpe task map task accomplished efficiently pearl poly tree algorithm pearl 
augmented graph tree computed efficiently 
poly tree directed acyclic graph underlying undirected graph cycles 
claim bucket elimination algorithm process variables topological ordering parents precede child nodes algorithm coincides minor modifications poly tree algorithm 
demonstrate main idea bucket elimination mpe task 
arguments applicable rest tasks 
example consider ordering polytree assume variables observed denote observed value primed lowercase letter leave variables lowercase 
processing buckets buckets processed observation buckets get bucket ju ju bucket ju bucket elimination bucket ju bucket jx processing bucket elim mpe get hu placed bucket 
final resulting buckets bucket ju ju bucket ju hu bucket ju hu bucket jx hu choose value maximizes product bucket choose value maximizes product bucket selected value 
easy see elim mpe uses topological ordering poly tree time space exp jf jf cardinality maximum family size 
instance example elim mpe records intermediate function hu requiring space bounds domain size variable 
note pearl algorithm time exponential family size better records functions single variables 
order restrict space needs modify elim mpe ways 
restrict processing subset topological orderings sibling nodes parent appear consecutively possible 
second algorithm reaches set consecutive buckets family buckets combined processed 
change elim mpe similar pearl propagation algorithm poly trees 
processing super bucket amounts eliminating super bucket variables recording intermediate results 
example consider example 
processing bucket separately compute brute force algorithm function hu super bucket place function bucket get unary function hu max ju ju ju ju 
details obtaining ordering families poly tree processed super buckets worked scope 
summary proposition exist ordering poly tree algorithms elim bel elim mpe super bucket modification time space complexity pearl poly tree algorithm corresponding tasks 
modified algorithm time complexity exponential family size requires linear space 
pearl algorithm restricted message passing relative rooted tree order identical 
dechter cba dba bc ab fcb gf 
clique tree associated induced graph 
join tree clustering join tree clustering lauritzen spiegelhalter bucket elimination closely related worst case complexity time space essentially 
sizes cliques tree clustering identical induced width plus corresponding ordered graph 
fact elimination may viewed directional goal query oriented version join tree clustering 
close relationship join tree clustering bucket elimination attribute meaning intermediate functions computed elimination 
elimination ordering generate ordered moral induced graph maximal cliques maximal fully connected subgraph enumerated follows 
variable earlier neighbors clique clique connected parent clique shares largest subset variables dechter pearl 
example induced graph yields clique tree ordering tree clustering tree may generated 
functions recorded bucket elimination meaning details proofs claims scope 
function recorded bucket elim mpe defined gamma fx maximum probability extension variables appearing ordering mentioned rooted clique containing instance recorded elim mpe see example equals max appear clique tree rooted fcb 
belief assessment function xp pi defined gamma denotes probability evidence observed clique subtree rooted clique containing conjoined 
bucket elimination 

probability tree 
combining elimination conditioning serious drawback elimination algorithms require considerable memory recording intermediate functions 
conditioning hand requires linear space 
combining conditioning elimination may able reduce amount memory needed performance guarantee 
conditioning viewed algorithm processing algebraic expressions defined task left right 
case partial results assembled partial value assignments conditioning subset variables unfold tree subproblems associated assignment variables 
say example want compute expression mpe network max gjf jb dja cja bja max max cja max bja max jb max djb max gjf compute expression traversing tree going ordering variable variable 
tree traversed breadth depth result known search algorithms best search branch bound 
dechter algorithm elim cond mpe input belief network bn fp ordering variables subset conditioned variables observations output probable assignment 
initialize 
assignment ffl output elim mpe observations 
ffl update maximum probability 

return maximizing tuple 

algorithm elim cond mpe demonstrate idea combining conditioning elimination mpe task 
subset conditioned variables gamma denote assignment assignment clearly max max max max pi ejx pa partial tuple compute max corresponding maximizing tuple argmax pi cjx pa elimination algorithm treating conditioned variables observed variables 
basic computation enumerated value combinations conditioned variables tuple retaining maximum probability kept 
algorithm 
particular value assignment time space complexity computing maximum probability rest variables bounded exponentially induced width ordered moral graph adjusted observed conditioned nodes 
case induced graph generated connecting earlier neighbors evidence conditioned variables 
theorem set conditioning variables space complexity algorithm elim cond mpe delta exp time complexity delta exp jcj induced width computed ordered moral graph adjusted relative variables constitute cycle cutset graph graph ordered adjusted induced width equals 
bucket elimination case elim cond mpe reduces known loop cutset algorithms pearl dechter 
clearly algorithm elim cond mpe implemented effectively take advantage shared partial assignments conditioned variables 
variety possible hybrids conditioning elimination refine basic procedure elim cond mpe 
method imposes upper bound arity functions recorded decides dynamically processing process bucket elimination conditioning see dechter rish 
method uses super bucket approach collects set consecutive buckets super bucket processes conditioning avoiding recording intermediate results dechter el dechter 

related mentioned algorithms probabilistic deterministic reasoning viewed similar algorithms 
addition unifying frameworks observing common features various algorithms appeared past shenoy 

summary bucket elimination framework generalizes dynamic programming concise uniform way expressing algorithms probabilistic reasoning 
framework algorithms exploit topological properties network conscience effort part designer 
shown example algorithms elim mpe elim bel singly connected network algorithm reduces pearl algorithms pearl orderings possible trees 
applies elim map elim tree propagation algorithms explicitly derived 
simplicity elegance proposed framework highlights features common bucket elimination join tree clustering allows focusing belief assessment procedures relevant portions network 
enhancements accompanied graph complexity bounds refined standard induced width bound 
performance bucket elimination tree clustering algorithms suffer usual difficulty associated dynamic programming exponential space exponential time worst case 
performance deficiencies plague resolution constraint satisfaction algorithms dechter rish dechter 
space complexity reduced conditioning 
shown conditioning dechter implemented naturally top elimination reducing space requirement exploiting topological features 
combining conditioning elimination viewed combining virtues forward backward search 
attempt optimize algorithms distributed computation exploit compilation vs run time resources 
issues addressed bucket elimination framework 
particular improvements exploiting structure conditional probability matrices santos press boutilier poole incorporated top 
summary provide uniform exposition tasks applicable probabilistic deterministic reasoning facilitates transfer ideas areas research 
importantly organizational benefit associated buckets allow bucket elimination algorithms improved uniformly 
done combining conditioning elimination shown approximation algorithms shown dechter 

acknowledgment preliminary version appeared dechter 
rish nir useful comments different versions 
partially supported nsf iri air force office scientific research afosr rockwell micro acm america electrical power research institute rp 
arnborg 
linear time algorithms np hard problems restricted partial trees 
discrete applied mathematics 
arnborg 
efficient algorithms combinatorial problems graphs bounded decomposability survey 
bit 
bacchus van run 
dynamic variable ordering csps 
principles practice constraints programming cp france 
becker geiger 
sufficiently fast algorithm finding close optimal trees 
uncertainty ai uai pages 

dynamic programming 
academic press 
montanari rossi 
semiring constraint satisfaction optimization 
journal association computing machinery jacm appear 
boutilier 
context specific independence bayesian networks 
uncertainty artificial intelligence uai pages 
bucket elimination thompson skolnick 
probability functions complex pedigrees 
advances applied probability 
cooper 
nestor computer medical diagnosis aid integrates causal probabilistic knowledge 
technical report computer science department stanford university palo alto california 
davis putnam 
computing procedure quantification theory 
journal association computing machinery 
dechter pearl 
network heuristics constraint satisfaction problems 
artificial intelligence 
dechter pearl 
tree clustering constraint networks 
artificial intelligence pages 
dechter rish 
directional resolution davis putnam procedure revisited 
principles knowledge representation reasoning kr pages 
dechter rish 
guess think 
hybrid algorithms sat 
principles constraint programming cp 
dechter van beek 
local global relational consistency 
principles practice constraint programming cp pages 
dechter 
enhancement schemes constraint processing backjumping learning cutset decomposition 
artificial intelligence 
dechter 
constraint networks 
encyclopedia artificial intelligence pages 
dechter 
bucket elimination unifying framework probabilistic inference algorithms 
uncertainty artificial intelligence uai pages 
dechter 
topological parameters time space tradeoffs 
uncertainty artificial intelligence uai pages 
dechter 
mini buckets general scheme generating approximations automated reasoning 
ijcai proceedings fifteenth international joint conference artificial intelligence 
el dechter 
evaluation structural parameters probabilistic reasoning results benchmark circuits 
uncertainty artificial intelligence uai pages 
geiger verma pearl 
identifying independence bayesian networks 
networks 
jensen lauritzen olesen 
bayesian updating causal probabilistic networks local computation 
computational statistics quarterly 

computational scheme reasoning dynamic probabilistic networks 
uncertainty artificial intelligence uai pages 
lauritzen spiegelhalter 
local computation probabilities graphical structures application expert systems 
journal royal statistical society series 
pearl 
probabilistic reasoning intelligent systems 
morgan kaufmann 
peng reggia 
diagnostic hypothesis 
national conference artificial intelligence aaai pages 
peng reggia 
connectionist model diagnostic problem solving 
poole 
probabilistic partial evaluation exploiting structure probabilistic inference 
ijcai proceedings fifteenth international joint conference artificial intelligence 
anderson shachter 
global conditioning probabilistic inference belief networks 
uncertainty artificial intelligence uai pages 
ambrosio shachter del 
symbolic probabilistic inference belief networks 
automated reasoning pages 
santos shimony williams 
hybrid algorithms approximate belief updating bayes nets 
international journal approximate reasoning press 
dechter santos 
generation alternative explanations implications belief revision 
uncertainty artificial intelligence uai pages 
shachter 
evaluating influence diagrams 
operations research 
shachter 
probabilistic inference influence diagrams 
operations research 
shachter 
ordered examination influence diagrams 
networks 
shenoy 
valuation systems bayesian decision analysis 
operations research 
shimony 
new algorithm finding map assignments belief networks 
bonissone henrion kanal lemmer ed uncertainty artificial intelligence volume pages 
shachter 
dynamic programming influence diagrams 
ieee transactions systems man cybernetics 
zhang poole 
exploiting causal independence bayesian network inference 
journal artificial intelligence research jair 
