scrap boilerplate practical design pattern generic programming ralf vrije universiteit amsterdam simon peyton jones microsoft research cambridge describe design pattern writing programs traverse data structures built rich mutually recursive data types 
programs great deal boilerplate code simply walks structure hiding small amount real code constitutes reason traversal 
technique allows boilerplate written generated mechanically leaving programmer free concentrate important part algorithm 
generic programs adaptive faced data structure evolution contain fewer lines code 
approach simple understand reasonably efficient handles data types conventional functional programming languages 
essential rank polymorphism extension implementations haskell 
relies simple type safe cast operator 
categories subject descriptors programming languages formal definitions theory software engineering reusable software general terms design languages keywords generic programming traversal rank types type cast suppose write function traverses rich recursive data structure representing organisational structure increases salary person structure 
interesting bit algorithm performing code function probably dominated boilerplate code recurses data structure find permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
january new orleans louisiana usa 
copyright acm specified department spelled section 
unusual situation 
contrary performing queries transformations rich data structures nowadays arising xml schemata increasingly important 
boilerplate code tiresome write easy get wrong 
vulnerable change 
schema describing organisation changes algorithm recurses structure 
small programs walk data types half dozen constructors problem 
large programs dozens mutually recursive data types dozens constructors maintenance burden heavy 
generic programming techniques aim eliminate boilerplate code 
large literature discuss section theoretical requires significant language extensions addresses purely generic algorithms 
simple powerful design pattern writing generic algorithms strongly typed lazy functional language haskell 
technique properties application program adaptive face data type schema evolution 
data types change functions modified functions easily generated application specific 
simple general 
copes arbitrary data type structure fuss including parameterised nested types 
subsumes styles generic programming term rewriting strategies 
requires extensions haskell type system rank types form type coercion operator 
extensions relatively modest independently useful available popular implementations haskell ghc hugs time 
contribution synthesis put relatively understood ideas type safe cast layer maps innovative way solve practical problem increasing importance 
direct interest programmers library designers language designers evidence usefulness rank polymorphic types 
code examples available online www cs vu nl gmap distribution comes generative tool support generate datatype specific boilerplate code 
benchmarks show possible get run time performance typical generic programs reasonably close hand coded boilerplate intensive counterparts section 
problem characterising problem addressing 
consider data types describe organisational structure 
divided departments turn manager consists collection sub units 
unit single employee department 
managers ordinary employees persons receiving salary 
data dept data dept name manager subunit data subunit pu employee du dept data employee person salary data person name address data salary float type manager employee type name string type address string small represented data structure research ralf pu joost pu marlow strategy blair ralf joost marlow blair employee ralf ralf amsterdam joost joost amsterdam marlow marlow cambridge blair blair london advent xml schemata widespread tools exist translating xml schemata data type definitions various languages case haskell includes tool 
data types involved constructors structure tends change time 
suppose want increase salary specified percentage 
write function increase float increase just salary increased 
perfectly straightforward write function haskell increase ds map ds float dept dept nm mgr nm mgr map float subunit subunit pu pu du du float employee employee incs incs float salary salary incs looking code apparent mean boilerplate 
code consists routine traversal tree 
interesting bit incs increases salary 
size data type increases ratio interesting code boilerplate decreases 
worse sort boilerplate needs produced new piece traversal functionality 
example function finds salary named individual require new boilerplate 
solution goal write increase accompanying boilerplate code 
give idea come code increase increase float increase mkt incs 
code formed distinct ingredients function incs section interesting part algorithm 
performs arithmetic increase salary 
function mkt type extension incs read mkt transformation applied node tree just salary nodes 
type extended function mkt incs behaves incs applied salary identity function applied type 
discuss type extension section 
function generic traversal combinator applies argument function node tree 
case function type extended incs function increase value salary nodes leave unchanged 
discuss generic traversal sections 
mkt overloaded functions haskell sense classes typeable term introduced shortly 
data type involved dept person programmer give instance declaration classes 
instances shall see sections extremely simple fact pure boilerplate easily generated mechanically 
software distribution comes includes tool just 
sections fill details sketch 
type extension step extend function incs works single type function works types identity types fundamental building brick type safe cast operator type involves haskell class typeable types subject cast class class typeable type safe cast operator cast typeable typeable cast function takes argument type runtime test compares types type cast returns just returns 
example interactive session prelude cast char just prelude cast bool prelude cast true bool just true type signature samples gives cast result context typeable knows result type type test 
type class typeable constrains types involved cast completely polymorphic argument result types instances class typeable 
type safe cast integrated functional programming various ways preferably language extension 
fact languages cast operator performs representation change type change 
cast operationally identity function type change 
known folk lore haskell community functionality cast programmed standard haskell 
section provide corresponding haskell encoding regarded implementation type safe cast 
clarify corresponding extension turns modest 
coming sections simply assume cast available type instance typeable 
cast write mkt met section mkt typeable typeable mkt case cast just id mkt applies type argument type applies identity function examples prelude mkt true false prelude mkt mkt short transformation constructs generic transformation function 
mkt lift incs typeable float mkt incs applicable type instance typeable ultimately aim function applies nodes tree 
necessitates generic traversal 
layer traversal approach traversal steps data type write single function gmapt traverses values type build variety recursive traversals gmapt 
context haskell overload gmapt type class term class typeable term gmapt forall term intended behaviour gmapt takes generic transformation applies immediate children value 
easiest understand idea example 
instance declaration employee instance term employee gmapt sal sal see clearly gmapt simply applies immediate children sal rebuilds new node 
things worth mentioning regarding type gmapt hosting class term 
firstly gmapt nonstandard type argument polymorphic function type forall term 
applied sal instance declaration fields different types 
haskell reject type gmapt rank types quite established haskell community 
elaborate section 
secondly note recursion class declaration term 
member signature gmapt refers term class constraint 
obviously provide simple schematic definition gmapt arbitrary terms tn gmapt tn 
tn node children gmapt effect 
term instance bool looks instance term bool gmapt important thing notice gmapt applies immediate children node opposed kind recursive traversal 
example term instance lists follows exactly pattern instance employee instance term term gmapt gmapt xs xs notice xs tail gmapt xs gmapt traverses layer common recursive map function 
recursive traversal gmapt layer behaviour synthesise variety recursive traversals 
shall see precisely layer behaviour variety easy capture 
example combinator applies transformation node tree apply transformation bottom term forall term gmapt read function follows apply children apply result 
recursion definition definition gmapt 
beautiful thing building recursive traversal strategy non recursive gmapt build different strategies single definition gmapt 
seen works bottom applied gmapt processed children 
equally easy top apply transformation top term forall term gmapt rest see different recursive strategies takes line define 
extremely elegant way building recursive traversal steps define layer map tie recursive knot separately known folk lore functional programming community dealing ana catamorphisms regular data types lists 
lack terminology call non recursive map trick review section 
example lest get fixated increase example uses design pattern 
write function flattens named department takes sub units part parent department flatten name flatten mkt name dept dept concatmap unwrap unwrap subunit subunit unwrap du pu unwrap point free notation gmapt function interesting department looks sub units applies unwrap get list units usually singleton list concatenates results 
unwrap sees target department returns subunits 
manager fired turned plain working unit pu presumably subject drastic subsequent salary decrease code task 
line function flatten uses exactly combinators mkt lift function applied tree 
furthermore data types change example new form subunit added data type boilerplate code re generated code increase flatten unchanged 
course number fields dept subunit changed change mentions du constructors explicitly 
unreasonable dept units split lists say people sub departments algorithm really change 
summary completed initial description new design pattern 
summarise application built chunks code programmer written short piece code particular application 
typically consists code snippet real incs application strategy combinators lift function full data type specify traversal scheme 
mechanically generated data type instance declarations class typeable class term 
requires fixed amount code data type see section 
requires line code constructor seen 
kinds instance declarations take simple regular form readily generated mechanically 
library fixed library combinators mkt 
programmer readily extend library new forms traversal 
way generate instance declarations drift pre processor 
furthermore derivable type classes job template haskell 
software distribution comes includes customised version drift 
mechanical support absolutely necessary writing boilerplate code hand onerous pays task 
rest consists elaboration generalisation ideas 
examples seen far generic transformations take produce new 
turns forms generic algorithms important generic queries section monadic transformations section 
introducing forms pause reflect generalise ideas section showing forms algorithm regarded form fold operation section 
lastly return type safe cast operator section 
concatmap maps function list concatenates results 
queries far concentrated generic transformations 
recall corresponding type scheme forall term second interesting class generic programs call generic queries 
generic query type form forall term fixed result type 
example suppose wanted compute salary bill need function type float float fixed result type implementing queries general approach exactly type extension lift interesting part function polymorphic function data types give single overloaded traversal function build pieces 
code looks similar increase float bills bills salary float bills interesting part function bills applies salary 
lift bills arbitrary types cousin mkt typeable typeable case cast just query behaves follows applied argument type argument type interrogate return default value illustrate examples interactive session recall ord type char int prelude ord prelude ord prelude ord true step extend term class function gmapq applies specified query function list results class typeable term gmapt forall term gmapq forall term instances gmapq simple gmapt instance term employee gmapt gmapq instance term term gmapt gmapq gmapq xs xs instance term bool gmapt gmapq just gmapt notice recursion involved layer operator function rank type 
gmapq build combinator performs recursive traversal 
fold needs operator combine results different sub trees summarise nodes top left right term forall term foldl gmapq see processes children giving list results combines results ordinary list function foldl operator combiner 
result applying query result included foldl 
concludes definition 
queries changing query function combining operator easily query single value combining values nodes tree 
example extract named department data structure find name dept find orelse string dept dept just orelse orelse case just foldl means find find leftmost department specified name 
easy variants find right deepest 
laziness plays role department specified name traversal cease 
monadic transformation transformations section queries section third useful form generic algorithm monadic transformation 
example suppose wanted process structure discarding old salary values filling new ones looking employee name external database 
means input output involved function type io type fit scheme generic transformations queries re run development time 
need function construct basic monadic transformations typeable typeable typeable typeable monad case cast just return type looks somewhat simply explains type representation constraints needed type safe cast 
need extend class term support monadic traversal class typeable term gmapt gmapq monad forall term instances just simple haskell notation monadic composition instance term employee return instance term term return xs xs return xs combinator monad term forall term write follows employee io employee name io salary lookup person external database obvious question new application require new variant gmap 
discuss section 
content observations 
gmapt just special case identity monad 
fact gmapq encoded directly 
second wonder need monadic form gmapq analogy gmapt 
monadic query just special case ordinary query 
see need recognise monad find operation section really performing monadic query 
refinements reflections having introduced basics pause reflect ideas little modest generalisations 
aside types worth noticing type equivalently written forall term forall term moving implicit forall inwards 
nice thing writing way clear generic transformation transformer 
write type forall term approach gives perspicuous type type forall term type theoretic point view type signatures identical original ones ghc supports isomorphisms directly 
particular ghc allows forall type synonym declarations allows forall right function arrow happens type synonym expanded richer traversals need combine generic queries transformations 
example suppose want increase salaries named department leaving salary unchanged 
main function generic transformation uses services generic query name float increase gmapt name bool false name dept bool tests argument see targeted department generic transformation generic query test 
built just 
returning test returns true call increase section department apply recursively children 
case traversal combinators job turned convenient write recursion explicitly 
example benefit keeping recursion definition gmap functions 
identifying interesting cases generic programming technique encourages fine type distinctions algebraic data types opposed anonymous sums products 
specific data types usually serve identification interesting cases generic algorithm 
example separate data type salary data salary float ordinary float salary person type included float person height increase section increasing height salary 
happens solution add type distinctions declarations datatypes opposed type synonyms 
simply include context program terms intercepted patterns 
mkt build special case float build special case employee increase mkt float employee employee incs dual problem traversal functions 
programmer want cut traversal explicitly certain kinds nodes 
case transformation cut offs useful restrict extent changes tree 
example section gave monomorphic type increase need generic type generalise type signature 
parameterise generic query returns true traversal visit sub tree bool gmapt increase names mkt incs names bool names false string bool true writing conditions useful restrict coverage traversal avoid fruitless traversal 
example increase function unnecessarily traverse character department name person name 
haskell string just list char 
point view generic function entirely possible salary buried inside name 
writing efficiency directed conditions undoubtedly tiresome shortcoming approach 
avoided analysis datatype structure certainly feasible compiler support 
compound type extension continuing example happened uninteresting types wanted refrain traversing 
need generic query returned true types false 
compound type extensions topic section 
general question generic query extend new type specific case 
need cousin typeable typeable case cast just build generic query arbitrarily special cases simply composing 
similar type extension functions allow generic transformation arbitrary number type specific cases 
interesting example 
suppose want generate association list giving total head count department name int fst hc type name int int hc main generic function hc returns pair desired association list total head count sub tree 
returning pair way just standard tupling design pattern generic programming 
define type specific cases types dept person interest hcd dept hcd kids kids hcp person hcp rs concat map fst rs sum map snd rs takes list head count information child nodes irrelevant person node builds head count information node 
person return head count empty list departments department add department list sub departments plus manager 
combine functions new traversal combinator forall term gmapq hc hc hcg hcp hcd hcg term hcg node kids kids deals children call gmapq applies specified function node query results children 
main function hc calls function formed generic case hcg type extensions hcp hcd 
aside generic queries higher order result type strange types programming languages ml haskell permit data type definitions 
algebraic data types mutually recursive parameterised higher kinded type variables recursion non uniform 
typical examples taken data rose rose data flip nil cons flip data var app lam data zero succ term instance declaration follow usual form 
example term instance rose instance term term rose gmapt rs rs gmapq rs rs rs rs return rs components algebraic data types involve local quantifiers function types 
necessitate specific treatment 
course extensional way traverse function values meant traverse source code functions 
encountering functions course traversal pose challenge 
treat functions atomic data types shown instance term gmapt gmapq return type safe cast copes strange types sensitive structure datatype components 
typeable instances deal names datatypes names parameter types type constructors 
generalising gmap seen different maps gmapt gmapq 
clearly lot common rich algebra 
example gmapt id id gmapt gmapt gmapt gmapq gmapt gmapq obvious questions new application require new sort gmap 
capture special cases general combinator 
far concerned generic function type term type level function restrict functions return result involving behave differently depending type value 
see identity function yielding generic transformation ignore yielding query return compound type involving case view application parameterised type constructor 
covered case monad lack coverage type constructors 
generic function type form term expressible gmap functions 
lost answer question 
turns generic maps seen just special instances fundamental scheme fold constructor applications 
level comes surprise dealing folds lists arbitrary datatypes known mapping regarded form folding 
absolutely straightforward generalise map fold idea generic setting usually expresses map fold instantiating fold arguments data type specific way 
section show writing fold way possible express various maps terms single fold generic setting 
diving section need concern application programmer carefully chosen match large class applications directly 
generic fold revise class term time adding new operator gfoldl 
able define gmap operators gfoldl choose leave methods class 
doing means giving instance term programmer may wishes define gmapt directly done earlier 
class typeable term gmapt forall term gmapq forall term monad forall term gfoldl forall term forall trying understand type gfoldl directly lead brain damage 
easier see instances look 
instance types employee subunit instance term subunit gfoldl pu pu gfoldl du du instance term employee gfoldl notice constructor pu passed function base case key difference vanilla fold essential generic definitions gmapt gfoldl 
particular gfoldl id instantiating identity function function application simply rebuilds input structure 
chose left associative fold matches left associative structure function application 
gfoldl show gmapt friends just special instances gfoldl 
idea familiar world lists map defined terms foldr 
looking instance helps point gmapt gfoldl instantiate gfoldl behave gmapt 
need identity function defined apply second argument apply argument result gmapt gfoldl id operationally perfect types quite right 
gmapt returns value type gfoldl returns 
instantiate identity function type level obtaining specialised type gfoldl gfoldl forall term forall functions type level type inference harder particular haskell 
solution instantiate type constructor id accompanied wrapping unwrapping newtype id id id id gmapt gfoldl id id id id constructor operationally serve tell type checker 
encoding similar gmapt 
notation nested function application 
type require wrapping monad type constructor directly serves parameter gfoldl return return gmapq little tricky structure processed gfoldl left associative structure list returned gmapq right associative 
example gmapq gfoldl standard way solve higher order functions gmapq gfoldl const id rs rs tiresome type wrapping explain type inference engine definition ok newtype unq gmapq unq gfoldl const id rs rs notice constant function type level ignores second parameter 
query returns type independent type argument data structure 
summary contend layer folding fundamental way perform term traversal framework 
section shown gmap functions defined terms single function gfoldl 
lest involved type wrapping onerous note occurs definitions gmap functions terms gfoldl 
programmer need encounter 
gmap definitions terms gfoldl efficient involve additional amount higher order functions 
programmer implementor language extension choice 
gmap operators defined directly datatype defined terms gfoldl shown default declarations 
type safe cast entire approach predicated availability type safe cast operator turn closely related intensional polymorphism dynamic typing 
discuss related section 
fact known folk lore haskell community functionality cast programmed standard haskell 
strangely published description trick review giving encoding regarded implementation 
typeable class key idea refine type class typeable previously assumed follows class typeable typeof overloaded operation typeof takes value returns runtime representation type 
possible implementation type instances data tr string instance typeable int typeof tr prelude int instance typeable bool typeof tr prelude bool instance typeable typeable typeof tr prelude list typeof get get get undefined instance typeable typeable typeable typeof tr prelude typeof typeof undefined undefined notice typeof evaluates argument 
particular call get list instance evaluated simply serves proxy telling compiler type instantiate recursive call typeof element type list 
haskell explicit type arguments typeof dispense value argument calls type application 
defining cast typeof type safe cast easy implement typeof plus small haskell extension cast typeable typeable cast typeof typeof get just get get undefined check argument result type representation coerce 
extension haskell type easy implement operationally just identity function 
course just unsafe name implies advocate wide spread 
regard implementation device implement safe feature cast language implementations contain similar trap door 
mess 
point reader may inclined throw hands declare requires instance declarations magic strings distinct place language haskell 
note scheme meant implementation opposed programming technique 
compiler provide direct support class typeable instance data type automatically generated compiler 
programmer instantiate class 
furthermore cast provided primitive may implemented inside system library kind low level coercion invisible inaccessible application programmer 
degree compiler support system type safe 
section programming technique user 
shows compiler support cast require mysterious runtime data representations 
somewhat surprisingly cleanly implemented haskell type class framework simple instance declarations 
furthermore albeit gap measure real advantage able prototype system requiring compiler support 
value undefined type forall haskell 
ghc supports scoped type variables nicer way write list instance typeof tr prelude list typeof undefined worry efficiency cast involves comparing data structures 
cost fundamental 
structures readily hash consed especially direct compiler support compared constant time 
business library writer compiler implementor application programmer 
alternative approaches generic programming received great deal attention review section 
worth mentioning approach generic programming lies readily hand universal data type data univ int string 
univ type string generic program works converting embedding input data structure univ traversing universal data structure converting projecting result back original type 
approach merit simplicity inefficient worse completely untyped 
step static check matching constructor named person correct number type fields matched 
ways improve type safety efficiency approach example datatype generic functions separate typed untyped code 
concentrate statically typed approaches rest section 
rank types hindley milner type system gracefully balanced cusp expressiveness decidability 
polymorphic type may quantified outermost level called rank type exchange type inference engine find general type typeable program aid type annotations whatsoever 
higher ranked types occasionally useful 
example type build list production combinator central short cut deforestation technique 
type build forall 
forall 
example runst combinator encapsulates stateful computation pure function runst forall 
forall st known type inference programs types intractable 
tractable easy sufficient type annotations 
haskell implementations ghc hugs support data constructors rank types type inference problem easier data constructor acts type annotation 
inconvenient gmapt data constructor require tiresome unwrapping 
fact ghc uses type inference algorithm permits function type arbitrary rank type provided sufficient type annotations 
details scope 
believe gmap family functions offers evidence usefulness rank types practical programming 
generic traversal polytypic programming core idea underlying polytypic programming define generic function induction structure argument type result type function 
induction usually supported corresponding language extension function definition cases sums products 
approach initially leads purely generic functions ones driven entirely structure type 
examples include serialisation inverse comparison operations hashing 
unfortunately just purely generic operations view purely generic programming restrictive useful 
motivated customisation generic programs addressed generic haskell program 
techniques discussed extend polytypic function cases particular constructor type 
generic haskell substantial extension haskell proposal lightweight better integrated ordinary functional programming 
furthermore generic haskell generic function class citizen 
write generic functions operating generic functions traversal combinators require 
run time nominal type safe cast alien polytypic programming 
techniques encode traversals opposed combinator style 
derivable type classes extension haskell support generic programming 
idea generic function just template specifies generate instance declaration generic function data type 
easy ride template specific types 
derivable oriented structural induction nominal analysis types recursion built generic function new generic function requires new class 
derivable type classes combined rank types sufficient define gmap family functions gfoldl function modest amount encoding 
derivable type classes suitable define nominal type case bias structural induction 
generalised folds established idea maps folds defined kinds datatypes systems datatypes 
inherent assumption recursion compound terms performed fold operation 
sets idea apart simpler general approach layer wise traversal favoured 
way allow programmer wire recursion way convenient 
anticipated recursion generalised folds suffer problem articulated larger systems datatypes considered impractical enumerate ingredients folding hand 
effect instance boilerplate ingredients follow certain scheme ingredients provided programmer 
updatable fold algebras proposed 
development generalises updatable generalised folds dimensions 
firstly type extension operate type level fold algebras updated constructor level 
secondly generic traversal allows define kinds traversal schemes opposed simple fold 
thirdly fold algebra approach suffers closed world assumption adding new data types straightforward 
assumption development 
non recursive map trick non recursive map trick introduced sections known functional programming community time sense programming functors 
approach recursive data type tree say defines auxiliary type tree functor tree data tree leaf fork tree tree data tree leaf fork type isomorphism holds tree tree tree recursive traversals defined recursive functions terms layer functorial map 
approach directly practical programming needs write functions convert isomorphic types situation noticeably complicated mutually recursive types involved breaks altogether recursion non uniform data seq nil cons seq contrast approach require auxiliary data type works fine arbitrary datatypes 
copes systems mutually recursive datatypes 
major improvement previous technique practice 
untyped setting idea map immediate children term straightforward prolog 
similar technique lisp community quite time 
idea building library combinators facilitate firstclass tree traversal strategies top bottom leftmost terms layer traversal steps established term rewriting community 
idea seen flurry activity 
main approaches combinator style 
define new language strategic programming 
prime example untyped language stratego 
approach support strategies existing functional language transform input data single universal data type write generic strategies universal data type example combinator library 
approach works particularly functional programming model strategies datatypes 
implementations strategy combinators hide encoding needed strategies functions programmer 
approach underlies programme 
streams describe rich library strategy combinators 
new contribution show strategic combinator approach traversal smoothly accommodated typed functional language term traversals ordinary functions user defined data types 
employment rank types identification fundamental folding operator improves encodings combinator suites previous 
visitor pattern object oriented programming visitor pattern classic incarnation recursive traversal 
fact instance visitor pattern problematic increase started section visitor requires case data type say class traversal mixed processing done node 
variations basic visitor pattern proposed 
palsberg suggests generic alternative walkabout class reflection performance poor palsberg offers interesting discussion design choices 
generative approach flexible support programming visitors suggested visser accompanied discussion generative approaches 
class hierarchy interface visitor combinators instantiated style strategic programming see 
node processing recursive traversal effectively separated arbitrary traversal schemes defined 
personal communication alex aiken 
www cs vu nl lieberherr adaptive programming offers high level approach traversal object structures compared visitors 
style assumes primitives specify pieces computation performed paths constrained starting nodes nodes passed nodes passed nodes reached 
adaptive programs typically implemented language extension reflection api compilation visitor 
type safe cast main ways implement type safe cast extensive literature intensional type analysis dynamic typing 
intensional type analysis enables write functions depend run time type value 
uses typecase construct examine actual structure type parameter type polymorphic entity case alternatives sums products function types basic datatypes 
structural type analysis performed recursively opposed mere level type case 
checking type equality standard example looks promising base type safe cast weirich shows 
difficulties 
adding intensional polymorphism language highly non trivial step 
second seriously intensional polymorphism geared structural type analysis setting absolutely requires nominal type analysis cf 

example types structurally equal nominally equal data person string float name height data dog string float name weight treat person dog allow distinguished 
great deal excellent research introducing dynamic types statically typed language example :10.1.1.39.8178
addresses general question complicated necessary purpose 
particular need type dynamic central dynamic typing systems need typecase principal language construct underlying dynamic typing 
class typeable function foundation dynamic library standard part hugs ghc distributions years 
material section appeared print 
key idea appeared email current authors closed mailing list forwarded open haskell mailing list 
cast function known trace message haskell mailing list henderson 
concluding remarks practical design pattern generic programming typed functional setting 
pattern encourages programmer avoid implementation tiresome boilerplate code typically needed recurse complex data structures 
pattern relevant xml document processing language implementation software reverse re engineering 
approach simple understand involves designated concepts layer traversal type cast 
approach general restrict datatypes subject traversal allows define arbitrary traversal schemes reusable ones application specific ones 
language support design pattern shown simple 
approach takes advantage research put rank type systems 
performance benchmarks show generic programs reasonably efficient see accompanying software distribution 
generic program salary increase example times slower normal hand coded program 
dominant cause penalty sub optimal encoding technique type safe cast 
recall generic traversals perform comparison type representations encountered node run time 
crucial type representations efficient preferably built support 
hand written solution involve checks 
factor caused fact generic traversal schemes accessible number optimisations available hard wired solutions 
gmap family relies term class higher order style 
recall generic traversals tend traverse nodes necessary extra precautions omitted recursion 
perspective currently investigating options support key combinators cast gfoldl gmap family efficiently ghc compiler haskell 
native implementation remove penalty related comparison type representations render external generative tool support unnecessary 
discusses built support hard provide design space explore 
working automating derivation conditions traversals reachability properties recursive traversal schemes traversed data structure 
envisage template approach derive optimised traversals compile time 
nick benton robert barry jay johan jeuring ralf hinze tony hoare simon marlow riccardo pucella colin runciman joost visser stephanie weirich helpful discussions feedback earlier drafts 
abadi cardelli pierce plotkin 
dynamic typing statically typed language 
th acm conference principles programming languages pages jan 
abadi cardelli pierce remy 
dynamic typing polymorphic languages 
proceedings acm workshop ml applications pages san francisco june 
bird paterson 
de bruijn notation nested datatype 
journal functional programming jan 
clarke loh 
generic haskell specifically 
gibbons jeuring editors proc 
ifip tc working conference generic programming 
kluwer academic publishers 
appear 
acm conference functional programming computer architecture fpca 
acm 
isbn 
gill launchbury peyton jones 
short cut deforestation 
fpca pages 
isbn 
test environment linux pentium iii mb kb cache thinkpad ghc optimisation package enabled 
glew 
type dispatch named hierarchical types 
proceedings fourth acm sigplan international conference functional programming icfp volume acm sigplan notices pages sept 
acm press 
harper morrisett 
compiling polymorphism intensional type analysis 
nd acm symposium principles programming languages popl pages 
acm jan 
henderson 
dynamic type class casts proposal 
email haskell mailing list oct 
hinze 
new approach generic functional programming 
reps editor proceedings th annual acm sigplan sigact symposium principles programming languages boston massachusetts january pages jan 
hinze peyton jones 
derivable type classes 
hutton editor proceedings haskell workshop montreal number tr technical reports sept 
hudak 
phil proposal restricted type classes 
email haskell mailing list june 
hughes editor 
acm conference functional programming computer architecture fpca volume lecture notes computer science boston 
springer verlag 
jansson jeuring 
polyp polytypic programming language extension 
th acm symposium principles programming languages popl pages paris jan 
acm 
jeuring jansson 
polytypic programming 
launchbury meijer sheard editors nd int 
school advanced functional programming wa usa aug volume lecture notes computer science pages 
springer verlag berlin 
kfoury 
type reconstruction finite rank fragments second order lambda calculus 
information computation june 
visser 
typed combinators generic traversal 
proc 
practical aspects declarative programming padl volume lncs pages 
springer verlag jan 
visser 
dealing large bananas 
jeuring editor proceedings technical report universiteit utrecht pages july 
launchbury peyton jones 
state haskell 
lisp symbolic computation dec 
leroy mauny 
dynamics ml 
hughes 
lieberherr 
adaptive object oriented software demeter method propagation patterns 
pws publishing boston 
meijer fokkinga paterson 
functional programming bananas lenses envelopes barbed wire 
hughes pages 
meijer jeuring 
merging monads folds functional programming 
jeuring meijer editors advanced functional programming volume lecture notes computer science pages 
springer verlag 
odersky laufer 
putting type annotations 
rd acm symposium principles programming languages popl pages 
acm st petersburg beach florida jan 
okasaki 
purely functional data structures 
cambridge university press 
palsberg jay 
essence visitor pattern 
proceedings nd annual international computer software applications conference compsac pages aug 
peyton jones 
restricted overloading 
email mailing list dec 
sheard 
generic unification level types parameterized modules 
acm sigplan international conference functional programming icfp volume acm sigplan notices pages florence sept 
acm 
sheard fegaras 
fold seasons 
fpca pages 
isbn 
sheard peyton jones 
template meta programming haskell 
chakravarty editor proceedings haskell workshop pittsburgh oct 
shields peyton jones 
putting putting type annotations 
preparation 
swierstra 
designing implementing combinator languages 
swierstra oliveira editors advanced functional programming third international school afp volume lecture notes computer science pages braga portugal sept 
springer verlag 
visser 
benaissa tolmach 
building program optimizers rewriting strategies 
acm sigplan international conference functional programming icfp volume acm sigplan notices pages baltimore 
acm 
visser 
visitor combination traversal control 
oopsla conference proceedings object oriented programming systems languages applications 
acm press 
wallace runciman 
haskell xml generic combinators type translation 
acm sigplan international conference functional programming icfp pages paris sept 
acm 
weirich 
type safe cast 
acm sigplan international conference functional programming icfp pages montreal sept 
acm 
weirich 
higher order intensional type analysis 
metayer editor programming languages systems th european symposium programming esop grenoble france number lecture notes computer science pages 
springer verlag 

type sensitive preprocessor haskell 
glasgow workshop functional programming 
