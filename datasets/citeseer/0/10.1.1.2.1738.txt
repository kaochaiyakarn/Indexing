generalized version space trees ulrich stefan kramer technische universit nchen institut informatik 
nchen germany rueckert kramer tum de 
introduce generalized version space trees novel data structure serves condensed representation inductive databases graph mining 
generalized version space trees allow comfortable representation version spaces natural way efficiently process inductive queries operations version spaces 
particular focus generalized version space trees field mining free unrooted trees graph databases 
experiments data sets national cancer institute developmental program dtp indicate generalized version space trees boost inductive queries considerably featuring moderately increased space requirements comparison version space representation boundary sets 
order inductive databases acceptable wider group users able answer queries fast enable interactive usage 
particular mining rich graph logic style representations currently far ideal 
partly due high branching factor search space existence syntactic variants problems 
graph mining database scans expensive involve np hard subgraph isomorphism tests general graphs costly subtree isomorphism tests free unrooted trees 
reduce database scans called condensed representations proposed authors rk 
condensed representations data structures possible answer queries inductive database approximately correct reasonably efficient man database access 
dominique laurent defines condensed representations subsets solution patterns allow complete reconstruction 
variety condensed representations proposed free closed sets itemsets version spaces rk combinations thereof 
de raedt introduced data structure called version space trees constructing representing version spaces strings 
version space trees essence suffix tries adapted boundary set representation strings 
generalized version space trees extend original data structure free trees connected graphs 
principle restriction extend data structure instance unconnected graphs 
keep focused concentrate mining free trees general graphs 
companion rk introduced free trees graph mining canonical form efficiently gspan type xy graph mining algorithm 
intention overcome representational limitations linear path patterns rk avoiding complexity issues general subgraph patterns 
investigate free trees constraintbased mining consider conjunctive queries consisting minimum frequency maximum frequency part 
setting easily extended arbitrary conjunctions anti monotonic constraints 
note generalized version space trees principle different purposes focus usage condensed representation speed typical frequent substructure data mining queries 
preferred view generalized version space trees index structures built background database systems queries meet assumptions construction index structure query answering fast take long time 
facet ubiquitous time space trade answering queries just store patterns supplementary information hash table 
access time fast solution space efficient collisions handled 
extreme recompute anew accessing database time 
clear memory wise unproblematic computationally expensive 
condensed representations generalized version space trees intended enable fast access information encountered patterns main memory cost memory overhead 
organized follows section introduces free trees canonical form mining frequent free trees graph data 
section generalized version space tree data structure section report results frequent free tree mining 
conclude section 
frequent free tree mining introduce free tree mining setting formally 
set vertices 
vn set edges def constitutes graph 
set vertex labels lv set edge labels le labeled graph graph vertex label associated node denoted label lv edge label associated edge denoted label le 
purposes class connected acyclic labeled graphs special interest 
examples graphs class 
acyclicity connected acyclic labeled graph node connected rest graph edge leaf 
graph label leaves zero nodes recursively maximal label neighbors plus 
yields unordered unrooted tree structure called free tree 
known fact free tree nodes minimize maximal distance nodes tree called centers 
centers free trees marked empty nodes 
various ways store free tree computer 
efficient processing idea representation ensures equivalent free trees encoded pattern 
representation called canonical form 
broad range possible canonical forms free trees 
particular canonical form properties allow efficient freetreeminer algorithm rk 
canonical form free tree derived step algorithm 
identify canonical center root building rooted unordered tree free tree 
second step order nodes rooted tree get ordered rooted tree canonical form 
fig 

illustration center free trees 
leaf nodes free tree connected acyclic graph labeled zero nodes labeled maximal label neighbors plus nodes largest labels centers graph 
free tree centers 
important building block suitable order ordered rooted trees 
rooted tree edge connects child node parent node 
regard node corresponding edge parent unit 
assigns exactly label pair label le lv node root node 
sake simplicity introduce empty label lv le 
label assigned replacement non existing parent edge root node associated exactly label label le lv assume arbitrary order ev le lv order design lexicographic order rooted trees 
introduce concepts 
depth node tree distance root node 
set nodes depth level 
tree ordered level represented sequence nodes 
levelwise traversal tree enumerates nodes tree top level bottom level trees processing level sequence left right 
nodes ordered trees structural completion node regard addition empty labeled children algorithm algorithm calculating levelwise traversal order ordered trees 
procedure append root root queue queue empty remove front queue label ev label return true label ev label return false max children children ith child children ci empty node ith child children di empty node insert ci di back queue return true procedure number children 
example children child structural completion adds children labeled 
equally children structural completion change 
structural completion tree regard recursive application structural completion nodes nodes 
intuitively structural completion trees adds empty nodes node unique counterpart 
levelwise traversal order compares structural completion regard structural completion regard levelwise traversal 
algorithm sketches idea 
nice property order order trees size change add new nodes bottom level nodes 
property freetreeminer algorithm rk 
levelwise traversal order order subtrees tree transforming unordered tree ordered tree 
order describe steps build canonical form free tree identify centers center unique root 
centers remove edge centers creating subtrees height 
order subtrees compare levelwise traversal order 
root smaller subtrees root tree 
rooted tree simply order nodes tree get unique canonical representation 
calculating canonical form done polynomial time 
canonical form freetreeminer algorithm outlined rk 
freetreeminer able find free trees minimum maximum support graph databases 
builds observation working graph data subgraphs patterns canonization task subsumption coverage tests computationally expensive subsumption coverage tests boil subgraph isomorphism np complete canonization equivalent solving graph isomorphism problem polynomial algorithm known proven np complete 
assumed lie np 
freetreeminer uses free trees computationally better position subsumption canonization done polynomial time 
generalized version space trees generalized version space tree stores information version space suffix trie structure 
suffix trie tree data structure efficient storage large numbers similar strings main idea decompose string substrings store substring node 
original string reconstructed path root node concatenating substrings nodes path 
de raedt show suffix trie called version space tree represent version space strings 
suffix trie version spaces general structure free trees connected graphs 
node generalized version space tree represents canonical form free tree connected graph 
free tree canonical form needs transformed canonical form prior storing generalized version space tree 
start description generalized version space tree free trees show structure extended store graphs 
main differences generalized version space trees version space tree outlined version space tree stores strings generalized version space tree store complex structures graphs free trees 
version space tree designed data structure algorithm 
consequently nodes contain information relevant query processes 
contrast generalized version space tree designed flexible data structure save number flags frequency counts utility information nodes 
suitable support broad range queries including queries containing constraints anti monotonic monotonic 
node version space tree contains links parents previous level 
feasible strings necessary algorithm costly complex structures free trees 
consequently generalized version space trees link parents 
substantial deficit typical operations generalized version space trees processed simple tree traversal parent links needed 
required gspan algorithm mining free trees rk 
generalized version space trees string version space trees allow efficient implementation typical operations version spaces calculating union fig 

illustrates stepwise creation generalized version space tree bottom free trees top 
black lines denote parent child relation grey arrows generalized version space tree denote upward edge parent link 
link specifies parent new child added reconstructing free tree node 
intersection version spaces deciding particular structure contained version space 
typically operations simple tree traversal linear number structures tree 
allow clear concise description denote node general version space tree node node free tree may may contained general version space tree node 
accordingly distinguish edges edges 
explained node general version space tree contains edge node pair 
suffix tries strings canonical form free tree reconstructed general version space tree path root node particular node putting edge node pairs encountered path 
denote free tree generated path root node tv 
assume order edge node pairs outlined section 
children node sorted order 
node contains information labels edge node 
parent node 
leftmost child node 
right sibling node 
edge parent node contains node edge node pair appended 
number flags frequency counts derived utility information free tree represented node 
store labels node 
indicates parent node 
link parent children 
child accessed leftmost child children repeatedly right sibling link 
course depending space performance consideration linking scheme model parent children relation algorithm algorithm reconstruct free tree tv node generalized version space tree procedure path path root node path node path tv tree node labeled add edge labeled node labeled node tv created th iteration return tv procedure double linked lists hash trees 
fourth complicated create free tree follows path root node puts edges nodes encountered path 
labels node specify exactly edge node added existing free tree specify node new edge connected 
information fourth 
illustrates idea creation generalized version space tree start generalized version space tree add free tree nodes 
nodes free tree added levelwise traversal order top level bottom level level left right 
edge parent node denoted grey arrow identifies parent node represented example consider second generalized version space tree insertion free tree edge parent node original free child ofa 
similarly edge parent original free child ofb 
traversing generalized version space tree top bottom easily reconstruct original free tree adding new child node corresponds node current node edge parent created root added children added child algorithm outlined detail algorithm 
ideally edge parent stored index array containing nodes path root node free tree tv 
second free tree differs third node levelwise traversal order 
consequently resulting generalized version space tree branches second node 
edge parent node represents root set zero 
example case node represents roots trees node represents root fourth free tree 
finding free tree tv generalized version space tree straightforward operation just climb generalized version space tree root target node selecting step child edge node labels match edge node labels edge tv 
just insertion operation need way specify edge edge canonical form 
expressed order edges free tree 
principle consistent order sense choose order guarantees generalized version space tree contains canonical forms 
canonically inducing order ensures generalized version space tree trees tw constructed way root node node canonical form 
levelwise traversal order canonical form outlined section fulfill criterion partially seldom cases necessary include nodes corresponding tree tv wrong canonical center root definition canonical form 
quite easy fix problem adding height subtree decision criterion levelwise traversal order remove nice properties order hurt freetreeminer performance 
chose simply mark non canonical node special label ignore non canonical trees find operation 
easy see generalized version space tree store arbitrary rooted labeled tree 
store canonical forms build generalized version space tree containing arbitrary set free trees particular version spaces free trees 
generalized version space tree extended store connected labeled potentially cyclic graphs 
step choose suitable canonical form order edges graph turns yan han approach xy works purpose 
main idea represent connected graph depth search dfs tree 
tree generated forward edges edges node visited graph depth style storing visited node list backward edges edges node visited 
course numerous ways traverse depth manner depending choice starting node order edges node yan han combine orders forward backward edges construct linear order set edges linear lexicographic order dfs trees canonical form orders construct generalized version space tree representing connected graphs node identifies canonical form exactly graph construct path root adding iteratively edges initially empty graph 
conceptual difference generalized version space tree free trees fact edges backward edges edges connect current node generated node build cycle 
yan han give proof orders fact canonically inducing generalized version space tree contains canonical forms 
yan han lay groundwork design generalized version space trees gspan algorithm data structure 
fact yan han define order dfs codes sequences generated traversing graph depth order constrained order edges 
just particular useful way represent compare corresponding dfs trees 
different orders experimental results section application generalized version space trees datasets taken national cancer institute nci developmental program dtp dtp nci nih gov 
nci dtp anti cancer screening data experiment examine performance generalized version space trees just index structures databases 
purpose applying freetreeminer compounds studied dtp human tumor cell line screen program 
classified compounds data set active inactive depending log gi value nci lung cancer line seen measure cancer growth inhibition compound 
classification separates compounds set active compounds set inactive compounds 
created list queries form freq active freq inactive 
values chosen query randomly interval 
note support levels high practical applications serve purpose argument 
freetreeminer calculate version spaces queries 
computation took seconds average seconds query 
step freetreeminer calculate query freq active freq inactive 
resulting version space stored generalized version space tree 
save node tree frequency counts corresponding free tree sets 
preprocessing step simply walk tree output free trees match query 
calculation generalized version space tree took seconds twice average time needed computing query 
generalized version space tree computed queries executed just seconds 
means generalized version space tree cache structure reduced processing time seconds seconds time saving 
clearly generalized version space trees efficient way boost similar frequent substructure queries databases 
note queries form freq freq quite common allow find patterns frequency varies significantly groups instances 
nci dtp anti hiv screening data second experiment examine generalized version space trees representation version spaces 
proposed algorithms literature simply output elements determined version space 
better approach calculate set borders efficient small representation version space 
representation processing 
computational point view generalized version space trees efficient borders subsumption tests necessary calculation processing borders time consuming lookup operations generalized version space tree 
clear space requirements generalized version space trees interfere performance 
generalized version space tree needs space kept main memory stored slower external memory hard disk 
case efficient computationally demanding space consuming representation borders 
examine question dtp hiv data 
dtp aids screen program dtp nci nih gov checked tens thousands compounds evidence anti hiv activity 
available screening results chemical structural data compounds covered confidentiality agreement 
available database october release contains screening results compounds 
screen utilizes soluble assay measure protection human cem cells hiv infection 
compounds able provide protection cem cells retested 
compounds provided protection retest listed moderately active cm confirmed moderately active 
compounds provided protection listed confirmed active ca 
compounds active moderately active listed confirmed inactive ci 
performed tests data set gain insights size generalized version space trees comparison representation borders 
freetreeminer calculate version space containing free trees minimum support ca data set maximum support cm data set 
resulting version space includes frequent free trees 
corresponding generalized version space tree uses nodes 
calculated set set version space 
set contains trees set trees 
trees borders nodes roughly quarter number nodes version space tree 
repeated experiment minimum support ca data set maximum support cm data set 
time version space tree needed nodes version space tree containing trees trees set trees set took nodes 
borders proved compact representation experiments generalized version space tree uses times nodes borders 
increased memory demand generalized version space trees problem large version spaces 
examined application version space trees small easily stored main memory today computers 
case willing accept higher memory usage order gain rapid access free trees easy handling represented version space 
introduced generalized version space trees condensed representation store version spaces structured data easy efficient way utilized database boost certain types queries just index structure 
show built free trees connected graphs give empirical evidence hints applicability substructure pattern mining 
course lot done planning perform elaborate study comparing boundary set representations free trees graphs 
interesting direction research deals type handling queries supported 
example nodes contain flags data generated evaluating constraint monotonic anti monotonic 
envisage incorporating inductive databases supported query languages mpc iv 
anonymous reviewers helpful comments 
jean francois christophe 
approximation frequency queries means free sets 
proceedings fourth european conference principles practice knowledge discovery databases pkdd pages 
arnaud dominique laurent 
condensed representations sets mining queries 
proceedings international workshop knowledge discovery inductive databases 
iv tomasz 
query language database mining 
data mining knowledge discovery 
akihiro inokuchi takashi washio nishimura hiroshi motoda 
general framework mining frequent patterns structures 
proceedings icdm workshop active mining am pages 
man heikki mannila 
inductive databases condensed representations data mining 
international logic programming symposium pages 
mpc rosa meo giuseppe psaila stefano ceri 
new sql operator mining association rules 
alejandro buchmann mohan editors vldb proceedings th international conference large data bases september mumbai bombay india pages 
morgan kaufmann 
luc de raedt manfred jaeger dan lee heikki mannila 
theory inductive query answering 
proceedings ieee international conference data mining icdm pages 
rk luc de raedt stefan kramer 
level wise version space algorithm application molecular fragment finding 
proceedings seventeenth international joint conference artificial intelligence ijcai pages 
rk ulrich stefan kramer 
frequent free tree discovery graph data submitted 
home tum de rueckert freetreeminer pdf 
fine bader boyd 
new soluble assay hiv effects application high flux screening synthetic natural products aids activity 
journal national cancer institute 
xy jiawei ha yan 
gspan graph substructure pattern mining 
proceedings ieee international conference data mining icdm pages 
