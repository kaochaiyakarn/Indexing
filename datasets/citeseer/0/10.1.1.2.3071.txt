querying ranking xml documents torsten schlieder freie universit berlin inf fu berlin de holger meuss ludwig maximilians universit unchen meuss cis uni muenchen de xml allows represent content structure documents 
advantage document structure promises greatly improve retrieval precision 
retrieval technique adopts similarity measure vector space model incorporates document structure supports structured queries 
query model tree matching simple elegant means formulate queries knowing exact structure data 
query model propose logical document concept deciding document boundaries query time 
combine structured queries term ranking extending term concept structural terms include substructures queries documents 
notions term frequency inverse document frequency adapted logical documents structural terms 
introduce ecient technique calculate necessary term frequencies inverse document frequencies query time 
adjusting parameters retrieval process able model contrary approaches classical vector space model original tree matching approach 
xml widely accepted standard representation exchange data attracting growing attention electronic commerce information systems database research 
bene ts xml information retrieval ir point view 
believe advantage xml document structure greatly improve retrieval precision 
structure aware retrieval certainly lower recall compared traditional ir techniques 
traditional text retrieval techniques structured query languages stemming database community face challenges discuss text retrieval models text representations 
impose serious restrictions xml ignore document structure support queries rely static document concept 
ignoring document structure means ignoring semantics 
user specify prefers search terms appear certain contexts 
static document concept bound physical les cope di erent result granularities requested users 
solve problems dynamic document concept necessary dynamic document concept allow basic values needed ranking term frequencies inverse document frequencies 
xml query languages successful applications limited ir context research supported german research society berlin brandenburg graduate school distributed information systems dfg 

torsten schlieder holger meuss require thorough knowledge document structure retrieve exact matches query support result ranking 
properties contrast notion vagueness information retrieval 
note language constructs regular path expressions solve problems user know expression necessary look 
regular path expressions support partial matches 
retrieval formalism informally introduced schlieder meuss seamlessly combines structured queries xml documents relevance ranking 
adopt similarity measure vector space model vsm salton incorporate document structure add structure queries 
query formalism tree matching simple elegant technique query xml documents 
tree matching allows formulate structured queries partial knowledge document structure 
scope queries logical documents term weights dynamically adapted 
tree matching basis de nition structural terms 
structural terms extend classical term concept substructures queries documents 
treating substructures terms able retrieve documents partial structural matches 
structural terms ordinary terms distribution documents 
distribution assign weights structural terms 
furthermore show classical vsm extended dynamically de ned documents structural terms 
approach generalizes classical vsm original tree matching formalism simulate models simply adjusting weights query vector 
combination tree matching vsm requires new implementation techniques 
introduce ecient algorithms simultaneously compute full partial query matches term weights necessary measure similarity query documents 
describe rst experiences prototypical implementation approach 
similarity xml documents structured queries section introduce formalize approach rank xml documents respect structured query 
rst describe general idea develop details model subsections 
basis approach vsm known widely retrieval model 
adopt model extending concepts query document term structured interpretation 
query classical vsm list keywords 
add structure keywords way query interpreted labeled tree 
xml documents interpreted labeled trees model document collection single tree consider subtree logical document 
root query tree determines notion admissible documents logical document rooted node label query root potential candidate returned result 
compare query assign similarity score determines position ranked result list 
similarity scores computed distribution structural terms 
structural terms essentially subtrees query documents 
set structural terms includes special cases terms standard vsm 
count number occurrences structural term logical document count number logical documents containing structural term normalize values compute term weight 
weights construct document vectors 
contrast weights query vector de ned user 
query document vectors compared standard dot product 
torsten schlieder holger meuss trees properties tree structure root consists nite set nodes nite set edges node root forms root node jn denote number nodes set edges binary relation pair establishes relationship nodes say parent child satisfy conditions 
root parent 

node tree root exactly parent 
set children node denoted children fv apply unique numbering children notation child refer ith child node children leaf node 
nodes leaf nodes called inner nodes 
path tree sequence nodes un pair consecutive nodes edge node called ancestor descendant exists path un 
root tree node 
subtree tree descendant write 
subtree labeled tree tree root function label nite set labels 
tree equally labeled nodes connected path called recursive tree 
trees root root isomorphic exists bijective mapping preserves labels parent child relationships numbers assigned children nodes xml documents queries labeled trees notion trees map physical xml document labeled tree standard way neglecting semantics links 
simplify model single node type xml elements attributes text data 
elements represented node element name label 
text sequences decomposed words 
words stemmed stopwords removed 
word mapped leaf node labeled respective word 
attributes mapped nodes parent child attribute name label parent node attribute value label child 
attribute values consisting sequence words decomposed described text data 
shows mapping example xml document normalized tree 
add single root node unique label normalized trees order model document collection see de nition document collection document collection labeled tree uniquely labeled root 
traditional ir models rely static document concept bound physical les 
xml documents may vastly di er granularity documents may contain information single book may collect data entire library consisting thousands books 
obviously appropriate retrieve entire library user interested torsten schlieder holger meuss 
bradley 
xml 
xml document 
xml 
bradley book author name bradley year title xml title xml xml chapter author bradley title section chapter syntax normalized tree 
syntax 
xml 
mapping xml document normalized tree 
books 
problem remains document contains single book may forced database administrator user may interested chapters sections 
replace physical notion document exible logical notion de nition logical document logical document document collection subtree example collection part depicted subtree rooted book node corresponding representation physical xml document logical document subtrees subtree rooted section node tree consisting node labeled 
de nition query approach simple distinguish xml attributes elements logical operators de nition query query labeled tree 
assign types documents queries de nition type root query document respectively 
type label root type label root 
assume user de nes query kind logical documents retrieved 
example root query label chapter logical documents type chapter retrieved 
captured de nition admissible documents de nition admissible documents set admissible documents query respect document collection type 
type type tree matching shown interpret data query trees 
interpretation problem answering query mapped problem embedding query tree data tree 
exact ordered tree embedding problem extensively studied see ramesh ramakrishnan overview solvable polynomial time 
interested ordered embedding ordering data may inconsistent 
consistent order known user 
interested exact embedding torsten schlieder holger meuss xml title author bradley chapter book library book author name bradley year title xml title xml xml chapter author bradley title section chapter syntax query tree part document collection unordered inclusion query tree data tree 
preserves parent child relationship query 
user specify information need exact structure data 
introduced variants tree embedding problems 
adopt unordered tree inclusion variant variant exactly meets requirements 
unfortunately unordered tree inclusion problem np complete 
modi ed version described meuss omits requirements original de nition 
variant polynomial typically sublinear time complexity respect number nodes data tree 
de nition embedding root query root document collection 
function called embedding holds 
label label 
ancestor ancestor original de nition additionally requires embedding injective implication second condition equivalence 
de nition match query document collection embedding root match logical document rooted match answer query 
example shows embedding query tree left data tree right 
admissible document depicted query subtree rooted book node 
dashed arrows show embedding de nes match query document 
match book node 
corresponding answer subtree rooted book node containing nodes participating respective embedding 
note match result di erent embeddings example title branch query mapped branches data tree belong logical document 
structural terms occurrences information retrieval notion terms restricted unstructured terms cases simply words 
extend de nition terms substructures query tree document collection order achieve objectives want relax restrictions tree matching formalism allows full matches query 
model query partial match query subtree occurs logical document 
second torsten schlieder holger meuss want measure query ts data considering query subtrees matches logical document 
third want re ect observation terms substructures distribution logical documents 
de nition structural term labeled tree set labels structural term 
notion structural terms draw connection classical concept terms smallest constituents texts 
structural term quite similar properties term unstructured texts technical point view name structural term just synonym labeled tree 
de nition occurrence traditional ir models simple intuitive term occurs query document contained query document 
tree matching formalism maps query tree data subtree may additional inner nodes simply adopt formalization 
di erent de nitions query document occurrences structural term 
de nition extend notion matches introduced queries documents terms documents 
de nition term occurrence structural term 
exists structural term isomorphic 
query say occurs root called occurrence matches document say occurs call match occurrence 
addition set oriented notation trees simple textual representation structural terms node represented label children node enclosed brackets separated commas 
query example represented expression book chapter title xml author bradley 
example structural terms occur query atomic subtrees consisting nodes labeled xml bradley respectively 
subtrees rooted inner nodes labels title chapter author respectively 
query tree structural term occurring query 
xml document structural term occurrences structural terms book author bradley author bradley book bradley title xml 
obviously possible de nitions term occurrences query 
example consider single query node occurrence term 
alternatively de ne combination branches query subtree occurrence structural term 
de nition allow express containment relation de nition leads combinatorial explosion number query terms 
rest section show de nition structural terms compromise expressiveness eciency 
quantifying weights structural terms behave ordinary terms number occurrences logical document distribution logical documents type 
adopt standard de nitions term frequency tf inverse document frequency idf quantify distribution structural term 
de nition term frequency structural term logical document 
freq number occurrences maximal number occurrences term term frequency tf de ned tf freq torsten schlieder holger meuss note occurrences structural term nodes de nition occurrences bound matches embeddings 
maximal number occurrences structural term equal maximal number nodes label 
example shows logical document type book part document collection 
maximal number occurrences term document xml nodes title nodes 
structural term author bradley term frequency book document 
model inverse document frequency bound documents certain type query selects documents match type 
inverse document frequency idf structural term represents ratio documents type documents type match de nition inverse document frequency structural term type 
jd number documents type number documents matched inverse document frequency idf de ned idf log jd example collection detail depicted shows logical documents type chapter jd chapter part collection 
structural term author bradley occurs logical documents 
follows idf chapter log term frequency re ects certain term describes document inverse document frequency re ects term separates document documents collection 
methods known combine values order calculate term weight see salton mcgill 
choose product tf idf simple frequently method de nition document weight document type weight structural term de ned tf 
idf determining query document similarity analogy vsm represent query documents weight vectors 
tm list pairwise non isomorphic structural terms occurrences document collection 
possible construct collection 
actual construction necessary formalism model 
de nition document vector weight vector document type de ned vd tm de nition query vector weight vector query de ned vq tm occurs 
torsten schlieder holger meuss weighted query vector user possibility give di erent substructures structural terms query di erent weights 
done example assigning query node weight interpreted weight structural term rooted respective query node 
possibility library prede ned weight vectors may prefer structural parts query textual parts 
de ne notion similarity document query re ects relevance document query 
direct application standard vsm de nition 
admissible documents documents type query assigned positive similarity scores documents considered relevant 
re ects fact root query de nes notion logical documents considered retrieval 
logical documents exactly trees type query 
de nition similarity query query vector document document vector vd similarity sim de ned sim vq 
type 
denotes standard dot product vectors 
common technique classical vsm normalizes document query vectors unit sphere length order avoid ect long documents containing terms having longer document vectors having higher similarity query shorter documents normalized similarity scores 
technique applied model way dividing document query vector length 
omit formal de nition simple technique 
obviously di erence classical vsm 
terms structurally dependent terms subtrees query documents 
term occurrence document subterms occurrences 
dependencies contrast term dependencies vsm necessary model assigning weights structural terms contain allows user prefer terms certain context 
results lost term appear desired context user wants neglect 
examples show user prefer term speci ed context require context prefer certain query term respect 
example consider query 
user interested documents containing term xml prefers documents title containing xml assign weights structural query terms xml title xml 
example user interested documents contain term xml inside title set weight representing term xml weight title xml value larger 
term xml positive contribution similarity score contained title element 
example user prefers documents containing term author bradley documents containing title xml assign larger weight structural term smaller weight 
simulation classical models approach generalizes classical vector space model original tree matching model 
simulate classical vsm masking complex structural terms assign values positions query vector correspond leaf nodes query 
torsten schlieder holger meuss atomic terms documents incorporated computation similarity score 
consequently scores computed classical vsm model exactly 
simulate tree matching approach similar way structural term representing query gets weight components query vector set 
technique full matches query achieve score larger 
non matching documents documents partial matches get score 
apply techniques formal way 
simulation standard vector space model section shows standard vector space model proposed salton mcgill modeled approach 
reasons technical simplicity di erent weighting distance measures considered 
assume simple weight measures computed tf 
idf distance measures dot product query document vectors 
note derivatives measures cosine dice jaccard function modeled model simply adjusting weighting distance measures 
rst show model documents approach 
prove proposition weights attached term coincide model vector space model 
corollary follows similarity values equal 
conclude section observation similarity values coincide models take xml document collection treat text vector space model 
de nition structured representation document document containing term occurrences structured representation tree root node labeled doc children labeled de nition structured representation collection dm collection documents 
structured representation tree root node labeled col children dm structured representation assume term basis standard vector space model 
term corresponds atomic structural term consists node label loss generality order structural term basis tn way corresponding atomic structural term term structural terms called complex terms 
theorem term document collection weight vsm 
structured representation structured representation atomic structural term corresponding doc weight doc proof show assertion proving parameters computation term weights coincide model vsm de nition implies freq model equal freq maximal number structural term occurrences document determined maximal number term occurrences respective document follows pair documents 
de nitions follows jd doc equal number documents due de nition number logical documents type doc containing structural term equal number documents containing formulas compute term frequencies inverse document frequencies term weights coincide model vsm parameters formulas terms documents assertion holds 
torsten schlieder holger meuss de nition leaf weight vector weighted query vector vsm 
leaf weight vector tn transformation term basis structural term basis tn corollary query document collection sim vsm denote similarity vsm 
vd document vector structured representation vq leaf weight vector weighted query vector holds sim vsm sim proof similarity sim vsm computed sim vsm weight collection vsm 
ltering query vector eliminates contribution complex terms sim atomic terms contribute similarity value 
theorem weights occurrences terms equal model vector space model 
sim sim vsm sim holds 
xml document indexed traditional ir engine vsm markup ignored element attribute names treated normal words 
model achieve query results ad hoc technique having preprocess collection markup treated normal words construct query simple level structured query vector space model model produce similarity scores documents 
markup ignored similarity scores may di er pathological cases highly frequent tags change normalization value 
note simulation classical vector space model works collection parts documents type see de nition 
simulation tree matching simulate original tree matching formalism weighted query vector assigns weight structural term corresponding query tree weight structural terms de nition root weight vector query 
tm query vector de ned way 
call vq root weight vector theorem shows similarity value document vector root weight vector query larger respective document tree matching match query 
theorem query root weight vector document document vector vd sim match proof di erent types assertion trivially true 
matches term sim 
contains terms occurrences document collection tree matching match de nition implies tm tk sim tk inverse document frequency larger follows tk tf tk 
de nition term frequency follows assertion tf tk match query term term alphabet root weight vector consists 
torsten schlieder holger meuss implementation model proposed sections provides powerful formalism combine structured queries ranking 
implementation model challenging 
matches query subtrees represent occurrences structural terms document collection 

weights structural terms occurrences query document collection calculated 
section describe formalism implemented eciently 
points outline main building blocks approach apply preorder bound encoding document collection allows verify nodes ancestor descendant 
inverted index maps label posting stores nodes carrying label 
postings function join path nds ancestor descendant pairs pair query labels 
tree matching algorithm processes query bottom 
nds matches query subtree combining matches included subtrees function join path 
array intermediate results lled tree matching algorithm term count algorithm calculates term frequencies inverse document frequencies 
topic explained detail subsections 
section introduce prototypical implementation 
encoding indexing document collection indexing technique inspired partial index introduced navarro 
node document collection represented triple integers pre preorder number bound preorder number rightmost leaf subtree rooted maxf maximal number occurrences term subtree rooted example encoded document collection shown 
nodes test ancestor ensuring invariant pre pre bound pre algorithms introduce subsections operate postings 
posting list entries represent data nodes 
entry triple pre bound maxf 
entries posting sorted preorder numbers ascending order 
notations refer ith entry posting pre bound maxf access preorder number bound value maximal term frequency respectively node represented number entries posting denoted jp distinguish index postings transformed postings 
index posting contains nodes document collection label 
index maps labels postings 
expression refers index posting belongs label name transformed posting denote posting derived index posting contains part entries 
torsten schlieder holger meuss part document collection year author name bradley book library xml title title chapter section syntax bradley author chapter title xml index year xml title syntax section name library chapter bradley book author 

xml index document collection joining ancestor descendant relationship function join path takes posting potential ancestors posting potential descendants 
constructs transformed posting consists entries ancestors entries recall postings sorted preorder node numbers ascending order 
document collection recursive node ancestor descendant label ancestor descendant relationship established simultaneously iterating postings particular descendants node reside contiguous interval algorithm shows function join path 
works follows posting contain results join initialized empty list line 
outer loop lines iterates posting potential ancestors 
current entry line algorithm searches position rst descendant algorithm marks position line searches interval descendants line 
interval size larger zero appended lines 
note algorithm correctly document collection recursive 
interested reader may nd algorithm recursive document collections schlieder 
algorithm joins ancestor descendant relationship 
function join path jp jrj pre pre jrj pre bound append copy return torsten schlieder holger meuss xml title author bradley book chapter query postorder enumeration array transformed postings computed algorithm query collection 
implementing tree matching tree matching algorithm processes query tree bottom fetches occurrences leaves computes matches inner nodes matches children 
root query 
access nodes correct order postorder 
postorder number query node accessed function post 
depicts query tree postorder numbers nodes 
algorithm shows tree matching procedure 
precondition requires array initialized 
node array stores transformed posting computed notation post access posting node algorithm processes query tree bottom accessing nodes postorder numbers ascending order line 
leaf algorithm fetches index posting belonging label line stores line 
inner node matches belonging subtrees rooted children computed 
precisely child matches computed stored posting post algorithm uses information lines computes matches subtree rooted combining matches children child calls function join path passing parameters index posting belonging label posting containing matches line 
result call transformed posting entry refers root data subtree contains match query subtree rooted intersecting postings returned function join path algorithm selects matches contain matches children line 
matches belonging subtree rooted stored line 
particular post root stores matches entire query tree 
shows array transformed postings computed executing query depicted document collection depicted 
transformed posting contains matches entire query stored computing term weights typical implementation vsm consists lexically ordered list terms occurring document collection 
term annotated idf list occurrences term frequencies 
weights term documents computed iterating list term frequencies calculating idf tf products 
simple technique reasons set structural terms matches document collection exponentially larger set document terms text model 
second scope term frequencies inverse document frequencies logical documents de ned query time 
maximal number logical documents equal number inner nodes document collection 
computed term frequencies indexing time posting term consist subtrees document collection contain term 
notice query selects documents certain type 
term refer list idf document type 
term weights lead intractable index size compute tf idf values executing query 
torsten schlieder holger meuss algorithm nds matches query tree 
input query root index output array jm transformed postings jm components jm get post label post child join path post child join path intersection fortunately restrict computations structural terms occurring query document type determined label query root 
intermediate results computed algorithm information provided index compute term frequencies inverse document frequency certain query term little additional ort 
calculate weight term logical document type need see de nition jd number logical documents type collection maximal number occurrences structural term number logical documents type occurs freq number occurrences structural term number logical documents type collection derived immediately information provided index root query type label root type number documents type document collection jd ji label root assume evaluated algorithm 
array stores matches query subtrees matches structural terms occurrences query document collection 
particular transformed posting post root contains matches entire query 
index logical document transformed posting computed query root 
maximal term frequency maxf post root compute frequencies structural terms occurring query respect documents type number documents contain certain query term need additional algorithm postings stored array algorithm realizes postprocessing creates arrays tf df rst describe arrays tf df torsten schlieder holger meuss show values freq derived derived arrays 
explain algorithm detail 
tf array frequency vectors entry tf refers logical document contains frequencies query terms notation refer jth component frequency vector belongs ith entry index tf structural term occurrence frequency freq post df array contains term query number logical documents occurs 
occurrence number logical documents type type occurs post algorithm works follows fetches posting array transformed postings line 
contains roots matching documents 
algorithm computes frequency structural term occurring query respect logical documents represented precisely visits query node root gets posting array intermediate results line 
contains matches query subtree rooted document root algorithm counts number matches descendants lines 
match document frequency query term rooted incremented line 
algorithm computes array frequency vectors array document frequencies 
input query root array transformed postings output array tf frequency vectors array df document frequencies post root initialize tf jp frequency vectors having jm components initialize df jm components jm df jp jrj pre pre jrj pre bound tf df df ready put pieces index document transformed posting computed query root type query occurrence term query 
weight term respect document tf 
idf tf post maxf post root log ji label root post example assume query shown executed document collection shown 
results evaluation stored array depicted 
algorithm uses query array transformed postings input computes list consists single frequency vector torsten schlieder holger meuss value rst component indicates occurrences query node labeled xml logical document rooted node 
similarly value second component states structural term title xml occurrences logical document 
maximal term frequency document 
weight query term title xml rst matching document calculated follows maxf log ji book ja log calculate weights structural terms occurring query get document vector normalized multiplied query vector get similarity computational complexity case non recursive trees time complexity join path operator bound 
parameter denotes selectivity maximal number nodes label 
note typically small respect number data nodes 
tree contains recursive labels parts inner posting may processed times 
number nodes carrying label path exceed height tree complexity bound 

time needed intersect postings bound 
nd logical documents matching query tree compute tf idf documents need jm calls function join path 
jm denotes number nodes query 
table shows time complexities algorithm trees recursive labeling trees recursive labeling jm 
jm 

note structure algorithms particular division tree matching part postprocessing part simpli es explanation algorithm 
algorithms optimal time space intersection postings integrated function join path 
second calculation term frequencies integrated tree matching algorithm function join path easily extended compute frequencies 
third integrated algorithm postings stored array intermediate results deleted soon matches belonging level query tree 
prototype completely implemented approach introduced 
prototype consists main components kernel loader indexer query processor web interface 
kernel implemented top berkeley database toolkit software provides basic access structures subsystems 
caching subsystem allowed implement hybrid memory management strategy 
hold inverted list labels memory permanently postings fetched request 
lru strategy provided cache ensures frequently postings removed cache 
top kernel module reside loader query processor 
loader uses xerces xml parser apache software foundation import xml les 
sends content parsed les indexer creates inverted list labels 
query processor implements concepts introduced preceding sections 
provides command line interface interface web module 
components system torsten schlieder holger meuss web interface prototype implemented web module uses fastcgi brown communicate server 
user choose text interface graphical editor formulate queries 
text interface expects queries syntax similar notation structural terms see section 
query language allows assign weight structural term query terms implicitly get weight 
query assigns zero weight entire query weight term xml weight term author bradley book title xml author bradley formal speci cation query practical occasional user provide graphical interface implemented java applet 
interface serves purposes displays element attribute names indexed documents 
second supports user formulating queries 
list labels dynamically adapted context current query node user select labels may ancestors descendants active query node 
shows graphical query editor list ranked results query 
practical experiences section rst experiences implementation model 
currently large test collection xml les decided small set legal documents provided gmbh saarbr 
collection consists documents containing torsten schlieder holger meuss position ranking document number document law minister enact regulation document preamble law minister enact regulation ranking example collection query dashed line metadata query solid line 
laws regulations directives german federal state 
assumed sample information needs formulated di erent queries varied query weights studied rankings generated system 
learned structured queries necessarily lead better ranking keywords semantically related 
example information need get documents describe police prevents produces similar rankings query contains keywords police prevent structured query document paragraph police prevent 
due ect keywords tend occur paragraph anyway structure imposes additional restrictions 
observed strong improvement ranking query speci es certain terms metadata logical documents title preamble query terms closely semantically related 
illustrate improvement retrieval precision sample information need get laws describe enact regulations 
bold faced keywords sentence occur di erent semantic contexts 
rst query unstructured document law minister enact regulation 
applied weight query order simulate vsm model see section 
ranking generated query depicted dashed line 
axis indicates logical document numbers axis shows relative position document ranking 
sorted documents ranking generated query 
second query document preamble law minister enact regulation additionally requires law appears preamble document 
query prefers full matches partial matches implicit weight structural term representing full query 
ranking generated query depicted solid line 
gure points adding structure query lower recall regarding entire collection strongly improves query precision 
shift query structured prefers documents fact laws speci ed document preamble 
documents take rst positions ranking 
note able weaken ect applying smaller weight query node preamble 
kind query extensions able involve metadata text retrieval process query fail metadata contain speci ed terms 
third query torsten schlieder holger meuss position ranking document number document law minister enact regulation document preamble law paragraph minister enact regulation ranking example collection query dashed fully structured query solid line document preamble law paragraph minister enact regulation extends structured query expects keywords minister enact regulation occur paragraph 
new requirement changes ranking order 
documents type law contain keywords single paragraph take rst positions ranking documents 
documents contain information satisfying original information need documents may contain keywords context 
fact inner query node paragraph works similar near operator retrieval engines rely positional distances semantic closeness speci ed document creator 
important observation stability rankings 
documents matches query subtrees preferred respect ranking generated query documents partial matches preserve relative positions 
seen diagrams sequences documents mainly keep descending ranking order queries 
related languages proposed querying xml documents fernandez ceri provide comparisons 
approaches exist consider problem relevance ranking structured queries 
structured query models developed information retrieval community see navarro baeza yates baeza yates surveys typically face challenge 
early suggests incorporate document subtrees computation scores fuller 
queries unstructured method compute exact term weights arbitrary subtrees 
authors propose propagate weights document tree generate text node serves compute weights 
lalmas describes model dempster shafer theory evidence 
model generalized belief function nd part structured document ts best unstructured query 
navarro 
proposed result ranking structured queries 
authors introduced simple query language generic ranking model 
queries logical formulas consisting presence inclusion operators 
score computed document sum occurrences content terms speci ed query 
distribution substructures considered document concept static 
torsten schlieder holger meuss time logic retrieval model multimedia objects proposed fuhr 
aspects model adopted xml query language xirql fuhr gro johann 
language incorporates notion term weights vague predicates xql content structure xml documents mapped facts rules intensional probabilistic logic 
contrast approach xirql treat partial structural matches 
addition fuhr gro johann discuss derive probabilities facts rules data 
probability document term computed single context subtree augmented general contexts application dependent rules multiply weight factor 
approach probabilistic interpretation query document structure proposed wol 
details similar weighting keywords substructures partial matches retrieval 
aspects di er query proposal wol set pairs consisting term keyword phrase path data 
path attached term speci es subtree term appear 
language express example term appear title appear body chapter book 
important di erence ranking model wol suggest measure term subtree speci ed path 
paths weight incorporated ranking function 
contrast model measures term logical document rewards documents matches complex structural terms 
believe measuring distribution terms inside micro trees title little 
terms appear document speci ed context get zero score 
best knowledge xxl theobald weikum elixir kushmerick xml query languages stemming database community incorporate notion relevance xxl elixir add similarity operator subset xml ql deutsch 
xxl similarity operator applied element names text sequences 
query processor searches matches similar name text speci ed assigns probabilities matches 
probabilities combined obtain single score 
elixir comparable xxl additionally supports similarity joins 
languages allow partial structural matches 
question term weights documents adjusted dynamic document notion discussed papers 
static assignment weights terms phrases indexing time re ect term phrase varying notions logical document determined query time 
introduced retrieval technique allows assign similarity scores xml documents respect structured query 
approach allows partial matches query 
improves precision query result compared retrieval models loosing results 
proved model generalizes main concepts tree matching formalism structured queries ranking vector space model ranking documents respect query 
described implementation rst experiences prototype 
include development user interface usability model depends user knowledge element names ancestor descendant relationships elements 
plan extensive evaluation model realistic conditions 
long term plan combine frequency model models approach schlieder naumann schlieder 
cost model plan integrate relaxes condition labels discuss query languages add special information retrieval operators query algebra order enable similarity search text 
torsten schlieder holger meuss preserved match 
cost function shall de ne penalty labels query match xml element names 
feature enhance exibility model 
addition plan investigate structured ranking models extended boolean model salton generalizes vector space model 
extended boolean logic logical formulation query tree basis relevance assignments 
advantages provides possibility enrich query language vaguely interpreted boolean operators 
research supported german research society berlin brandenburg graduate school distributed information systems dfg 

baeza yates ribeiro neto 

modern information retrieval 
addison wesley longman 
ceri 

comparative analysis xml query languages 
sigmod record 
brown 

fastcgi high performance web server interface 
www fastcgi com doc fastcgi whitepaper fastcgi htm 
kushmerick 

expressive ecient ranked queries xml data 
proceedings fourth international workshop web databases webdb pages santa barbara usa 
deutsch fernandez florescu levy suciu 

xml ql query language xml 
note 
www org tr note xml ql 
fernandez sim eon wadler 

xml query languages experiences examples 
www db research bell labs com user simeon xquery ps 
fuhr overt 

system logic retrieval multimedia objects 
proceedings st annual international acm sigir conference research development information retrieval pages melbourne 
fuhr gro johann 

xirql extension xql information retrieval 
acm sigir workshop xml information retrieval athens greece 
fuller mackie sacks davis wilkinson 

structured answers large structured document collection 
proceedings th annual international acm sigir conference research development information retrieval pages pittsburgh 


tree matching problems applications structured text databases 
phd thesis university helsinki finland 
lalmas 

dempster shafer theory evidence applied structured documents modelling uncertainty 
proceedings th annual international acm sigir conference research development information retrieval pages philadelphia usa 
meuss 

logical tree matching complete answer aggregates retrieving structured documents 
phd thesis university munich 
navarro 

language queries structure contents textual databases 
master thesis department computer science university chile 
torsten schlieder holger meuss navarro baeza yates 

integrating content structure text retrieval 
sigmod record 
navarro baeza yates vegas 

model visual query language structured text 
th south american symposium string processing information retrieval spire sta 
cruz de la sierra 
ramesh ramakrishnan 

nonlinear pattern matching trees 
journal acm 


pool probabilistic object oriented logical representation retrieval complex objects model hypermedia ir 
phd thesis university dortmund 
salton 

smart retrieval system experiments automatic document processing 
prentice hall englewood cli nj 
salton fox wu 

extended boolean information retrieval 
communications acm 
salton mcgill 

modern information retrieval 
mcgraw hill 
schlieder 

design implementation approximate pattern matching language xml 
technical report freie universit berlin 
schlieder 

similarity search xml data cost query transformations 
proceedings fourth international workshop web databases webdb pages santa barbara usa 
schlieder meuss 

result ranking structured queries xml documents 
delos workshop information seeking searching querying digital libraries zurich switzerland 
schlieder naumann 

approximate tree embedding querying xml data 
acm sigir workshop xml information retrieval athens greece 
software 

berkeley database 
www com 
apache software foundation 
xerces xml parser 
xml apache org xerces 
theobald weikum 

adding relevance xml 
proceedings rd international workshop web databases webdb dallas usa 
wol fl cremers 

ranking approach retrieval structured documents 
technical report iai tr university bonn 

