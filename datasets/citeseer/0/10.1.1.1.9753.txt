proceedings international conference software engineering edinburgh scotland may 
system discovering architectures running systems hong yan david garlan bradley jonathan aldrich rick kazman carnegie mellon university forbes ave pittsburgh pa yh garlan aldrich cs cmu edu kazman sei cmu edu challenging problems software developers guaranteeing system built consistent architectural design 
describe technique uses run time observations executing system construct architectural view system 
technique develop mappings exploit regularities system implementation architectural style 
mappings describe low level system events interpreted architectural operations 
describe current implementation tool uses mappings show highlight inconsistencies implementation architecture 

complex systems crucial welldefined architecture 
definition provides high level view system terms principal run time components clients servers databases interactions rpc event multicast properties throughputs reliabilities 
representation system architecture permits forms high level inspection analysis 
consequently past decade considerable research development gone development notations tools methods support architectural design 
despite advances developing engineering basis software architectures persisting difficult problem determining system implemented architecture designed 
form consistency guarantees relationship architectural insight actual system hypothetical best invalidating benefits architectural design 
currently principal techniques determine enforce relationships system architecture implementation 
ensure consistency construction 
done embedding architectural constructs implementation language program analysis tools check conformance 
done code generation tools create implementation architectural definition 
effective applied technique limited applicability 
particular usually applied situations engineers required specific architecture development tools languages implementation strategies 
systems composed existing parts require style architecture implementation outside supported generation tools approach apply 
second technique ensure conformance extracting architecture system code static code analysis 
implementation sufficiently constrained modularization coding patterns identified architectural elements 
unfortunately technique limited inherent mismatch static structures classes packages run time structures essence architectural descriptions 
particular actual run time structures may known program runs clients servers may come go dynamically components dlls direct control implementers may dynamically loaded third relatively unexplored technique determine architecture system examining behavior run time 
key idea system monitored running 
observations behavior infer dynamic architecture 
approach advantage principal applies system monitored gives accurate image going real system accommodate systems architecture changes dynamically imposes priori restrictions system implementation architectural style 
number hard technical challenges making technique 
serious finding mechanisms bridge abstraction gap general low level system observations map directly architectural actions 
example creation architectural connector involve low level steps actions interleaved architecturally relevant actions 
single architectural interpretation apply systems different systems different runtime patterns achieve architectural effect conversely possible architectural elements map low level events 
describe technique solve problem dynamic architectural discovery large class systems 
key idea provide framework allows map implementation styles architecture styles 
mapping defined set conceptually concurrent state machines run time track progress system output architectural events predefined run time patterns recognized 
parameterizing framework architectural implementation styles able exploit regularity systems providing flexibility defining new abstraction mappings 
introduce system discovering architectures running object oriented systems 
section discuss related 
section presents technical challenges producing architecture discovery framework multiple architectural styles multiple systems 
section presents main technical contribution state machines map implementation level events architectural operations 
discuss implementation section results case study illustrate utility section 
section discuss strengths weaknesses approach 


related related approaches dynamic analysis system 
number techniques tools developed extract information running system 
include instrumenting source code produce trace information manipulating runtime artifacts get information 
technologies available monitoring systems build 
solve hard problem mapping code models 
previous developed infrastructure doing certain kinds abstraction approach limited observing properties system reflecting architectural model architectural model 
show create model place 
dias xml language describe runtime events patterns map events high level events 
analyzing events determine architectural structure addressed 
addition simple static mapping low level system events highlevel events limited expressiveness 
example handle case event analyzer initially interest set events changes interest interesting events occurred 
doesn provide way specifying event correlations mapping series correlated low level events single high level event crucial capability needed discovering architecture system 
kaiser uses collection temporal state machines perform pattern matching runtime events 
approach similar architectural style explicit approach 
number researchers investigated problem presenting dynamic information observer 
example reiss walker zeller information variables threads activations object interactions ernst shows dynamically detect program invariants examining values computed program execution looking patterns relationships 
somewhat different detecting architectural structure 
describes system allows ada programs monitored dynamically check conformance rapide architectural specification 
approach requires source code annotated transformed produce events construct architecture 
contrast approach require access source code rely architectural construction operations embedded code 
large body research investigated specification dynamic behavior software architectures 
approaches explicit state machines 
approaches link architecture executing system 

technical challenges approach supports dynamic discovery architectures address problems observing system runtime behavior interpreting runtime behavior terms architecturally meaningful events representing resulting architecture 
primarily concerned second problem bridging abstraction gap system observations architectural effects 
number issues hard problem 
mappings low level system observations architectural events usually toone 
low level events may completely irrelevant 
importantly event creating new architectural connector involve runtime events object creation lookup library calls run time infrastructure initialization data structures conversely single implementation event represent series architectural events 
example executing procedure call objects signal creation new connector attachment run time ports respective architectural components 
implies need technique keep track intermediate information mappings architectural model second architecturally relevant actions typically interleaved implementation 
example moment system midway creating components connectors 
implies attempt recognize architectural events able cope concurrent intermediate states 
third single gold standard indicating implementation patterns represent architectural events 
different implementations may choose different techniques creating architectural element 
consider number ways implement pipes example 
find multiple implementation approaches system 
purposes architectural discovery single architectural style systems 
example sockets represent different types connector 
means need flexible way associate different implementation styles architectural styles 
address concerns adopt approach illustrated 
monitored events filtered trace engine select subset system observations considered 
resulting stream events fed state engine 
heart recognition engine state machine designed recognize interleaved patterns runtime events appropriate output set architectural operations 
operations fed architecture builder incrementally creates architecture displayed user processed architecture analysis tools 
handle variability implementation strategies possible architectural styles interest provide language define new mappings 
set implementation conventions refer implementation style vocabulary architectural element types operations refer architectural style provide description captures way runtime events interpreted operations elements architectural style 
pair implementation style architectural style mapping 
significant consequence mappings reused programs implemented style 

design discuss design state engine portion 
introduce language define state machine 
semantics state machine differ standard definition informal operational semantics section 
illustrate approach showing discover pipe filter architecture small java application 
section substantive example 
state engine trace engine running system architecture builder 
architecture 
model condition action state state 
elements state map 

state machine definition illustrate definition state machines consider situation want recognize creation instances binary connector type 
assume implementation constructs connector creating instances read write objects data communicated 
objects correspond read write ports architectural components 
connector constructed ports component invokes receive method read object passing write object contains data 
state machine construct connector states recognize read write objects created receive method called 
transitions states construct elements architecture ports roles connectors 
complicating scenario fact implementation may create read write objects order fact may construct read write objects communicating data 
kind interleaving requires recognition engine multiple active states 
furthermore creation connector relies information previous states read write objects retain information previous states evaluations subsequent states 
state machine graph states triggers actions transitions interpreted state engine 
states keep track progress architecture discovery 
state associated triggers define type events cause transitions states specify conditions occur 
transition taken may produce actions construct architectures 
elements state machine illustrated 
specifying state machine requires definition states triggers actions transitions 
states 
states staging points discovery architectural action 
state may represent partial knowledge architecture example knowledge connector created don know components connects allows build complex mappings combine pieces information coherent architectural actions 
states linked transitions form graph representing implementation flows leading architectural actions 
state state machine associated set state variables 
variable state incoming transition defined start init instance contains filter call method contains main java lang string method filter instance 
state machine discovering filter components 
transition predecessor states 
variables defined incoming edge ensure defined values 
conditions actions outgoing transitions refer variables new variables defined transition 
triggers 
trigger consists parts event specification condition met transition occur 
current prototype types parameterized events received running system trace engine call method caller callee call event occurs method invoked running system 
call event includes name method caller callee 
init constructor creator instance init event occurs constructor invoked instantiate new object 
event contains name constructor name element requesting constructor creator parameter name type collected instance parameter new element 
modify owner field value modify event occurs member variable object assigned value 
event includes name owner object field name field value assigned field 
state activated event parameters event recorded state variables referred subsequent state trigger conditions actions 
way architectural action information previous states produce 
illustrate access state variables shortly 
conditions written boolean expressions values state variables derived parameters current event events previous states 
conditions may operators build complex expressions 
example expression returns icons list show event types indicated figures containing state machines 
current implementation uses types events associated object oriented implementations approach easily accommodate events programming styles 

architecture fragment resulting running system state machine 
true equal contains foo returns true contains string foo 
illustrate consider trigger contains modify event condition field contains reader lock owner instance condition true field parameter modify event contains string reader lock owner parameter equal instance parameter init event activated 
instance example accessing state variable recorded earlier 
actions 
action specifies sequence architecture related operations create modify software architecture running system 
actions directly linked style target architecture expressed operations appropriate architectural style 
example pipe filter style include operations creating pipes filters client server operations creating connecting clients servers 
similar event parameters operations may explicitly define values state variables assignment may actions conditions 
informal operational semantics deal sequences events interleaved 
may maintain concurrently active state state machine 
active state called state activations 
activation pair state binding variables state 
provides forms transitions ordinary fork join 
state machines ordinary transitions remove state activation add 
support concurrency supports fork transitions leave original state activations place creating new state activation parallel original 
likewise join transition merges source state activations single destination activation 
current state state engine set state activations 
state engine begins single activation initial state state machine 
event received trace engine matched outgoing transitions current state activations 
event matches event specification transitions condition transition evaluates true matching transition taken 
ordinary transitions non forking source activation removed new activation added destination state 
variables new state bound values defined transition defined values corresponding variables source activation 
transition fork machine retains source state activation creating destination activation 
transition join triggered state activation source states join 
case source activations removed destination activation created usual 
consider state machine fragment assume currently active 
active trigger transition fired activation consists state variables instance creator constructor init event trigger filter result operation action method caller callee copied variables state 
variables may referred instance filter transition fork transition 
occurs state activation retained new state activation spawned 
allows creation filter components tracked original state activation allowing new state activation track subsequent events happening filter created transition 
way state machine keep track interleaved architectural mappings 

pipe filter example illustrate discovering architectural model consider simple example pipe filter architectural style 
assume style defines component types type data input output files called infile outfile filter type instances consume inputs produce outputs 
pipe connector type interface types specifying input output interfaces filters pipes 
furthermore assume pipe filter style defines operators create elements types name name name name component name component name pipe name pipe port role example assume implementation style uses conventions instance class filter name represents con denote fork transition adding icon transition 
struction filter component java piped reader instances filters communicate data 
write method piped writer called read method pipedreader called need wait call receive method information create pipe architecture receive method pairs instances pipedreader defining ends pipe 
knowing style implementation style architecture construct state machine represents mapping described allow recognize construct architectural elements 
state machine discover pipe filter architecture system adopting implementation conventions 
example wrote system called implemented conventions described 
creates configuration filters check fulfilled prerequisites courses stream student entries file splitting stream depending prerequisites satisfied checking students taken particular courses merging stream output file 
code consists application specific classes filter reads input file student entry time determines student cs program 
entry sent output pipes entry sent pipe 
filter checks entry see student taken prescribed course case entry passed 
entry discarded 
filter takes inputs merges output stream 
class instantiates starts filters 
users execute class providing input output file names 
remainder section divide state machine parts part turn 
creating filters 
part responsible creating system filters 
portion state machine part shown 
call event received trace engine matched triggers active states 
initially state activation start state 
state engine evaluate condition arc start state 
transition start looks method name containing string main java lang string condition satisfied call event start activation goes away active accompanying action executed 
action creates empty architectural model style 
active trigger condition evaluated newly intercepted object initializations 
instance parameter init event filter new state activation forked due fork transition architectural fil ter component constructed action 
action parameters indicate component name captured new instance component type decided initialization constructor 
new component assigned state variable filter referenced example 
follow state machine obtain state activations states respectively 
init event satisfies filter condition outbound arc filter component created concurrent state activation different variable bindings activation 
running just state machine produces architecture depicted 
filters created constructor class constructor constructor 
id generator label architectural counterpart runtime object avoid naming conflicts multiple instances type exist instance example 
connecting filters pipes 
recall target system uses channel output filter input 
state machine creates ports filters 
example write port created noticing creation associating architectural filter implementation filter writes 
similarly read port constructed created filter reads 
pipe created connected calling pipedreader receive method 
state machine achieves 
newly created pipedreader objects stored state variables referred instance instance 
creator init instance contains pipedreader init instance contains call method contains pipedreader receive caller instance callee provider method caller callee sink sink source src output src input snk necessarily user piped reader objects unclear filters belong port creation action produced point 
filters connected pipe apparent 
piped reader read write called previously recorded pipedreader mapped ports components correspond callers 
pipe dataflow signified calling receive method pipedreader 
method triggers join transition 
transition source state activations removed new state activation created action constructs attaches pipe previously defined ports constructed attached 
putting 
fragments state machine figures section including file output shown produce complete state machine discover architecture 
lists events obtained running 
list contains events trigger actions state machine events received trace engine sake brevity removed multiple calls read write pipes 
component creation part events causing creation system filters state machine part 
example interleaving occurs connection section trace 
piped writers created writing reading commences 
pipes created sequentially 
state engine keeps track separate activations pipes trace separate activations state machine track pair pipedreader 
call method contains write caller instance callee instance write filter call method contains pipedreader read caller instance callee instance read filter 
state machine fragments discovering pipe connections 

call method main java lang string requestor null pro null 
init constructor creator null instance name id 
init null name id 
init null name id 
init null name id 
init java io id java io id 
init java io id java io id 
init java io id java io id 
modify name java io reader lock value java io id 
call java io id java io id 
init java io pipedreader null java io pipedreader id 
init java io pipedreader null java io pipedreader id 
init java io pipedreader null java io pipedreader id 
init java io pipedreader null java io pipedreader id 
init java io null java io id 
init java io null java io id 
init java io null java io id 
init java io null java io id 
call java io write id java io id 
call java io write id java io id 
call java io pipedreader read id java io pipedreader id 
call java io pipedreader read id java io pipedreader id 
call java io write id java io id 
call java io write id java io id 
call java io pipedreader read id java io pipedreader id 
call java io pipedreader read id java io pipedreader id 
read write calls 
call java io pipedreader java io id java io pipedreader id 
call java io pipedreader java io id java io pipedreader id 
call java io pipedreader java io id java io pipedreader id 
call java io pipedreader java io id java io pipedreader id 
call java io writer write java lang string id java io id 
relevant output event filter 
running system entire architecture run created 
resulting architecture trace state machine section shown 
implementation component creation file input recall section provide general framework discovering architectures need solve challenges 
section discuss implementation challenges 
monitoring trace engine uses java platform debugger architecture jpda capture system runtime connection file output 
discovered architectural model 
events 
jpda provides communication channel debugger target system 
debugger send requests host virtual machine target system querying certain types events 
host virtual machine dispatch events denote changes state target system 
trace engine acts role debugger sends requests virtual machine hosting target system querying types events object instantiations method calls field modifications 
request contains filter defines set classes trace engine interested 
runtime target system virtual machine intercepts requested events generated classes defined filter queues sends trace engine 
receiving runtime event trace engine classifies converts init call modify puts pipe connected logic engine 
mapping implementation state engine follows design section 
initialization state engine parses state machine definition activates initial state 
keeps scanning stream sent trace engine evaluating newly produced events trigger conditions currently active states 
trigger condition active state satisfied target state activated associated architectural actions fired 
architecture building represent architectures acme architecture description language 
operations acme architectures defined library provides operations form building blocks architectural actions 

aams case study section case study determine run time architecture aams simulation test bed experimenting mobile system architectural design decisions 
test bed allows users specify usable system resources tasks scheduling strategies simulates running mobile system 
chose aams represents fairly complex real world application approximately kloc runtime architectural view system documented 
allows compare discovery result executive simulation controller event event application modeling legend action script file simulation task configuration file user scheduler resource task task task cpu simulation component mem network resource configuration file support component file event local call 
documented runtime view aams 
documentation 
comparison illustrates applying technique discover deviations architecture discovered documented design architecture aams 
furthermore case study illustrate developed refined state machines produce final architecture 
shows informal runtime architecture aams description runtime description 
simulation controller forms simulation resources tasks configuration user activities events information reads set configuration script files 
simulation controller takes commands simulation gui control runtime parameters feedback 
processes simulation frame generate actual performance system 
component application resource layers simulates operation 
set services file error reporting logging available publish subscribe simulated object 

design aams state machine component monitor logging error reporting publish subscribe section steps taken produce state machine discover aams architecture model 
typically writing state machines process starting fairly generic state machines discover components connections refining state machines produce architectures corresponding particular style 
case study specialization publish subscribe style distinguishes participating components tasks resources extra component types description aams 
develop final state machine produced state machine merely observed object creation interaction procedure call 
refined classify objects architectural counterparts resource task 
reused file io part pipe filter example 
point discovered publish subscribe part architecture 
preliminary discovery results informed resource task components interact object class procedure calls named publish subscribe 
conjectured system implements publish subscribe creating object invoking methods 
led design state machine portion architecture 
state machine creates connector notices instantiation object implementation 
done role created notices call publish method object publish port component corresponding call attaches 
similarly subscribe leads creation event sender role providing method creation subscribe port component requesting method creation attachment 

discovered architecture applying state machine running instance aams yields architectural model 
laid model enable easier comparison view 
comparison uncovered types discrepancies documented architectural view discovered 

isolated extraneous components connectors 
result shows connectors isolated parts system 
indicates instance instantiated 
code optimization resolve discrepancy 

additional connections components 
show connections controller component simulation components tasks schedulers 
inform support components logger reporting subscribe event bus 
ignoring backdoor connections architectural view accurate compromise architectural analysis meaningful interactions components considered 
example evaluating performance publish subscribe infrastructure existence hidden communication channels invalidate deadlock analysis 

misplaced connections components 
discovered architecture shows different file scheme gui reading files controller reads files 

discovered architecture aams 

missing components connectors 
components user environment recorded document show architecture 
confirm discovered actual architecture implementation understand discrepancies conferred aams developers 
agreed produced complete correct architectural description diagram uncovered errors coding 
missing user environment components due fact represent user interaction actual components implementation 

discussion described technique discovering architecture running system set pattern recognizers convert monitored system observations architecturally meaningful events 
key idea exploit implementation regularities knowledge architectural style implemented create mapping applied system conforms implementation conventions yield view architectural style 
number advantages approach 
applied system permits runtime monitoring 
case java program java runtime provides built facilities monitoring object creation method invocation instance variable assignment 
current implementation uses jpda causes slowdown target system 
address investigating aspectj provide similar monitoring capabilities 
initial results indicate aspectj negligible impact speed system 
furthermore monitoring technology kinds implementations system properties active research area see section continue provide increasing capabilities leverage 
second simply substituting mapping description possible accommodate different implementation conventions architectural style inversely different architectural styles implementation conventions 
described able discover pipe filter architecture system implemented different pipe convention 
third technique variety monitoring technologies architectural representations 
java acme substitute technologies relatively minor changes recognizer 
inherent weaknesses approach 
works implementation obeys regular coding conventions 
completely ad hoc bodies code benefit technique 
second works identify target architectural style mapping knows output vocabulary 
third analysis runtime observations suffers problem analyze executed 
questions execution violate set style constraints directly answered method 
techniques best viewed technologies architect arsenal architecture conformance checking tools 
potential defects point way research area 
area system monitoring mentioned 
second area codifying ways architectural styles implemented 
technology advances implementation techniques necessarily change important augment set mappings happens 
third area architectural coverage metrics similar coverage metrics testing 
example confidence running system various inputs exercised sufficiently comprehensive part system know architecture fourth find way definition implementation architecture mappings declarative 
operational definition state machines carrier mappings step imagine forms characterization easier create analyze 
developing tool support defining state machines 
mentioned implementation improved 
addition better monitoring facilities approach limited just noticing create init modify events extended information gleaned runtime system probing technology example object destruction thread information 
plan provide mechanism define system level events state machines 
gain experience developing state machines applying systems significantly jboss framework 
anticipate give measurements amount reuse get matching architectural implementation style 
research described supported darpa software engineering institute sei internal 
aldrich chambers notkin 
connecting software architecture implementation 
proc 
icse 
allen garlan formalizing architectural connection 
proc 
icse 
balzer goldman 
mediating connectors 
proc 
workshop electronic commerce web applications 
dias richardson 
role event description architecting dependable systems extended version wads 
lecture notes computer science book architecting dependable systems spring verlag 
ernst cockrell griswold notkin 
dynamically discovering program invariants support program evolution 
ieee 
soft 
eng 

jboss extensible server 
proc 
international middleware conference 
garlan allen 
exploiting style architectural design 
proc fse 
garlan 
cheng 
reconciling needs architectural description object modeling notations 
science computer programming vol 

garlan monroe 
acme architectural description component systems 
foundations component systems gary leavens murali sitaraman eds cambridge university press 
garlan chang 
gauges architecture monitoring adaptation 
proc 
st working conference complex dynamic systems architecture 
garlan 
cheng 
increasing system dependability architecture self repair 
architecting dependable systems de eds 
lncs springer verlag 
jackson 
lightweight extraction object models bytecode 
proc 
icse 
kaiser parekh gross 
extreme external infrastructure monitoring distributed legacy systems 
proc 
th international active middleware workshop 
kazman carriere 
playing detective reconstructing software architecture available evidence 
journal automated software engineering kazman kim 
simulation testbed mobile adaptive architectures computer standards interfaces appear 
kiczales hilsdale hugunin kersten palm griswold 
overview aspect ecoop 
luckham 
rapide language toolset simulation distributed systems partial orderings events 
dimacs partial order methods workshop 

testing ada programs rapide 
proc 
reliable software technologies ada europe 
murphy notkin sullivan 
software reflexion models bridging gap source high level models 
proc 
fse 
murphy notkin lightweight lexical source model extraction acm reiss 
jive visualizing java action demonstration description 
proc 
icse 
shaw deline klein ross young 
abstractions software architecture tools support 
ieee trans 
soft 
eng 

taylor medvidovic anderson whitehead robbins 
component message architectural style gui software 
ieee trans 
soft 
eng 


metah programmer manual version 
technical report honeywell technology center 
dias richardson 
software architecture statechart semantics 
proc 
th international workshop component software engineering 
walker murphy freeman benson wright swanson 
visualizing dynamic software system information high level models 
proc 
oopsla walker murphy 
efficient mapping software system traces architectural views 
mackay johnson eds proc 
cascon 
wells 
taming cyber surveying dynamic reconfigurable software landscapes 
proc 
st working conference complex dynamic systems architectures 
zeller 
animating data structures ddd 
proc 
sigcse program visualization workshop 
