levelwise version space algorithm application molecular fragment finding tight integration mitchell version space algorithm agrawal apriori algorithm 
algorithm generate patterns satisfy variety constraints data 
constraints imposed patterns include generality relation patterns imposing minimum maximum frequency data sets interest 
theoretical framework applied important application chemo informatics finding fragments interest set compounds 
fragments linearly connected substructures compounds 
implementation preliminary experiments application 
mannila toivonen mannila toivonen formulate general pattern discovery task follows 
database language expressing patterns con straint find theory respect viewed way contains sentences pattern lan guage considered constraint true 
formulation pattern discovery generic abstraction specific tasks including discovery association rules frequent patterns inclusion dependencies functional dependencies frequent episodes 
efficient algorithms solving tasks known cf 
mannila toivonen 
far type constraint considered simple typically relies frequency patterns 
past decade data mining community spent lot effort efficiently compute patterns having minimum frequency apriori agrawal 
extend popular data mining model allowing user specify variety different constraints patterns interest 
constraints considered involve generality constraints patterns specify patterns interest resp 
general specific pattern frequency luc de raedt stefan kramer albert university freiburg institute computer science georges hler geb 
freiburg germany informatik uni freiburg de constraints 
frequency constraints considered impose maximum minimum frequency data set interest 
constraints combined order discover patterns general pattern minimum frequency dataset maximum frequency data set result flexible declarative query language specify patterns interest 
point view fits inductive database framework considered researchers imielinski mannila han de raedt 
key problem discovering theories involve conjunction primitive constraints efficiently combine solvers primitive constraints point mitchell version space approach mitchell extremely useful 
primitive constraints results version space 
consider minimum frequency constraint 
shown mannila toivonen minimum frequency constraint results space solutions general pattern element set boundary set 
property holds primitive constraints space solutions conjunction constraints specified version space 
principle computed hirsh version space intersection method hirsh 
applying hirsh framework employ tighter integration version spaces apriori 
demonstrate relevance level wise version spaces implementation experiments domain molecular fragment finding 
molecular fragments sequences linearly connected atoms 
useful important induction called structure activity relationships sars statistical models relate chemical structure biological activity 
automatically derived fragments sars originates case systems developed 
published case systems extensively sar predictive toxicology systems 
previous approaches areas decomposition individual compounds methods generate fragments occurring single compound 
regard contribution language enables formulation complex queries regarding fragments users specify precisely frag ments interested 
implemented efficient solver answer queries language 
algorithmic point view longer necessary process results queries post hoc 
molecular fragment finding studied context inductive logic programming knowledge discovery databases 
instance dehaspe toivonen approach inokuchi inokuchi context 
system discovering frequently succeeding datalog queries restricted fragments 
approach inokuchi deals arbitrary frequent subgraphs restricted linear fragments 
approaches differ pattern domain expressive finding frequent patterns expensive complex linear fragments 
approach fragment finding bottom kramer frank 
approaches handle minimum frequency thresholds 
contrast approaches allows specification sorts constraints instance regarding generality frequency 
time pose constraints maximum frequency fragments minimum frequency 
stress integration version spaces results compact representation resulting solutions 
previous methods typically output patterns version space 
interesting understandability reasons learning fragments features 
organised follows section introduce molecular fragment finding task primitives querying fragments section level wise version space algorithm section discuss experiments molecular fragment finding section conclude touch related 
framework molecular fragment finding task apply integrated version space apriori framework finding molecular fragments satisfy conjunction constraints molecular fragment defined sequence linearly connected atoms 
instance fragment meaning oxygen atom single bond atom single bond carbon atom 
expressions denote elements denotes single bond double bond triple bond aromatic bond 
common literature consider heavy non hydrogen atoms 
assume system database example compounds example compounds database described representation 
information consists elements atoms molecule bond orders single double triple aromatic 
example compound representation shown fig 

example compound representation 
example fragment occurring molecule 
molecular fragment covers example compound considered graph subgraph example instance fragment covers example compound fig 

number interesting properties language molecular fragments fragments partially ordered gen eral relation fragment general fragment write partial order syntactically different frag ments equivalent reversal denote substructure subsequence subsequence reversal 
unique maximally general fragment empty fragment denote maximally specific fragment convenience add artificial denote note representation molecular fragments relatively restricted compared representations employed data mining order queries dehaspe toivonen subgraphs inokuchi 
fragments relatively restricted representation chemical structure easy trained chemists recognize functional group fragment occurs 
interpretation fragment reveals meets eye 
constraints fragments task addressed finding set fragments satisfy conjunction primitive constraints primitive constraints imposed unknown target fragments unknown target fragment specific pattern type primitive constraint denotes cl specific general specified fragment constraint specifies specific contain subsequence denotes frequency fragment set molecules frequency fragment dataset defined number molecules covers positive integer sets molecules constraint denotes frequency dataset larger resp 
smaller equal constraint denotes target fragments minimum frequency set molecules primitive constraints conjunctively combined order declaratively specify target fragments interest 
note conjunction may specify constraints number datasets imposing minimum frequency set active molecules maximum set inactive ones 
constraint include sequence subsequence frequency larger frequency smaller 
queries fragments solving constraints section discuss find set conjunctive constraint search space due fact primitive constraints independent follows find solutions intersection primitive ones 
secondly primitive constraints monotonic anti monotonic generality cf 
mannila toivonen 
constraint anti monotonic resp 
monotonic generality resp 
basic anti monotonic constraints framework basic monotonic ones constraint anti monotonic vice versa 
monotonic anti monotonic constraints important solution space bounded border 
fact known data mining literature cf 
mannila toivonen borders denoted machine learning literature cf 
furthermore negation mitchell symbols typically 
define borders need notions minimal maximal elements set generality 
set fragments define define borders constraint primitive anti monotonic constraints proper constraints proper monotonic constraints furthermore mitchell version space framework property implies resp 
proper borders anti monotone resp 
monotone constraints 
set solutions primitive constraint simple version space completely characterized set solutions completely characterized corresponding point issues 
computing borders primi conjunctive constraint tive constraint 
computing individual borders issue addressed variants common level wise algorithm data mining cf 
mannila toivonen 
second principle solved hirsh version space merging algorithm 
probably clear need integrate level wise algorithm version spaces 
loose coupling approaches sketched provide tighter integration approaches 
show experimental section lead computational advantages 
integrated algorithm computes border sets incrementally 
initializes borders minimal maximal elements repeatedly updates primitive constraint 
update borders regard primitive constraint involving generality employs mellish description identification algorithm 
mellish algorithm extends mitchell version space algorithm allows process constraints fo type secondly update version space handles dual constraints frequency constraints integrated algorithm uses variant level wise algorithm starts borders point follow mitchell terminology works dual borders set maximally general solutions set maximally specific ones 
data mining typically works set 
positive negative examples concept learning 
mellish description identification algorithm order formulate mellish description identification algorithm need introduce operations fragments smallest merged fragments largest common smallest fragments specific general largest fragments general specific notice operators may generate fragment operations instantiate mellish algorithm primitive constraint case max case min case max case min variants level wise algorithm algorithms outlined employ refinement operators 
refinement operator extending fragment atom 
generalization operator removing atom side fragment 
deal frequency constraints may employ generalization level wise algorithm 
downwards version 
constraint type set infrequent fragments considered satisfies constraint endwhile explain algorithm consider case case algo rithm behave roughly level wise algorithm 
contain fragments size algorithm keep track set frequent fragments infrequent ones 
algorithm repeatedly compute set candidate refinements delete frag ments frequent looking frequency generalizations evaluate resulting possibly frequent fragments database 
process continues empty 
basic modifications level wise algorithm concerned fact need consider fragment computed version space element element set 
secondly compute updated set contain frequent fragments re infrequent 
finding updated sets realized dual manner 
case initialize elements proceed completely dual 
resulting upwards algorithm shown constraint type set infrequent fragments considered satisfies constraint endwhile top bottom version works efficiently depend application query consideration 
point remains open question strategy works efficiently 
possible modify algorithms exploiting dualities order handle monotonic frequency constraint form case algorithm dual constraint type endwhile satisfies constraint set frequent fragments considered optimisations various optimisations algorithms possible 
adopted standard level wise algorithm search borders handling frequency constraints possible adopt efficient algorithms bayardo gunopulos 
directly focus specific longest patterns set 
secondly apriori style algorithms efficient elements level level wise search combined give candidates subsequent 
done fragments 
instance known frequent level candidate frequent fragment level 
variants respect order considered combined 
thirdly keep track fragments canonical form 
indicated earlier fragment equivalent reversal 
implementation canonical form fragment defined maximum lexicographic ordering fragment reversal 
implementation operators takes care 
fourthly problem implementation framework fragments stems fact bot tom valid fragment manipulated 
particular defined 
search wards set search downwards equal process maximum frequency constraints upwards undefined starting reason start query constraint concrete fragment 
optimisation primitives primitives especially useful minimize maximize 
imagine interested fragments satisfy number constraints addition maximum frequency certain dataset minimally general 
easy extend framework prim finds fragments satisfy conjunctive constraint minimal maximal regard specified criterion 
consider criteria monotonic anti monotonic frequency generality 
order find elements regard optimisation primitives computes sets regard selects elements depending minimal maximal regard criterion 
experiments order validate approach applied predictive toxicology evaluation challenge dataset srinivasan srinivasan 
data set consists compounds takes mbyte memory prolog encoding standard benchmark predictive toxicology artificial intelligence 
application goal discover molecular fragments relatively frequent carcinogenic compounds infrequent non carcinogenic compounds 
activating toxic fragments called structural alerts literature ashby patton 
interesting question context possible rediscover known alerts 
summarize experience new approach example queries systematic experiments 
interesting queries open research question research role compounds carcinogenicity 
new framework example query concerning fragments frequent active compounds infrequent inactive ones looks follows related query concerns existence activating fragments quantitative results gather quantitative evidence performed systematic experiments domain 
application side quite clear structural alerts relatively rare carcinogenicity safely assumed alerts frequency positive active compounds 
interested fragments frequencies positive resp 
negative examples 
seeking fragments statistically significant active compounds represented 
setting minimum frequency respectively apply test contingency table class variable occurrence fragment determine maximum allowable frequency inactive compounds 
way obtain maximum frequency thresholds respectively 
instance require minimum maximum experiment 
performed comparison approaches search fragments 
approaches consists stages stage handling minimum frequency query algorithm section second stage handling maximum frequency query 
approaches differ second stage dealing maximum frequency query 
approach version spaces searching upwards dual version third algorithm section 
table results method column contrast second searches downwards starting elements set determined third algorithm section min max table runtimes seconds pentium ii 
column table 
third method performs simple post processing column table filters fragments frequent dataset 
table summarizes runtimes methods minimum maximum frequency parameter settings seconds cpu time 
outcome experiments clear priori additional bookkeeping done version space approach 
experiments show cases version space approach pays outperforms ad hoc post processing method terms computation time 
result experiments queries big difference search upwards downwards maximum frequency queries 
important outcome experiments answers queries shown 
indicate queries version spaces constitute suitable compact representation solution sets queries 
outlined computational time needed answering queries reasonable 
br br results experiments context feature construction kramer de raedt 
related contributes theory data mining machine learning integration version spaces level wise algorithm framework inductive databases constraints interpreted queries molecular fragment finding language discussed molecular fragment finding 
briefly review key contributions domains relate relevant possible 
regard builds de raedt presents integration version space level wise algorithms 
expand earlier theoretical various respects 
contrast earlier report implementation experiments show validity framework application molecular fragment finding 
provides time evidence framework theoretical interest effective regard applications 
regard algorithm provides generalized theoretical framework data mining 
resulting framework extends borders levelwise techniques sketched mannila toivonen link level wise algorithm set mitchell version space approach exploit version space model 
experimental evidence indicates approach form viable extension classical level wise algorithm 
borders version space representation characterize space solutions inductive queries done dong li 
version space representation search emerging patterns 
emerging patterns defined itemsets supports increase significantly dataset 
patterns closely related significant fragments discover test 
primitive constraints support different dong li 
compute borders dong li employ levelwise algorithm 
rely efficient algorithms bayardo max miner 
principle possible adapt algorithms bayardo gunopulos framework 
concerns regarded domain specific inductive database imielinski mannila meo 
sketched han inductive databases allow user specify constraints patterns interest 
constraints considered data mining literature cf 
ng han 
context frequency constraints different data sets new 
note discovering molecular structures regularities version spaces related known meta dendral system buchanan mitchell 
agrawal agrawal imielinski swami 
mining association rules sets items large databases 
proceedings acm sigmod conference management data 
ashby patton ashby paton 
influence chemical structure extent sites rodent different human exposures 
mutation research 
bayardo bayardo 
efficiently mining long patterns databases 
proceedings acm sigmod conference management data 
buchanan mitchell buchanan mitchell 
model directed learning production rules 
waterman hayes roth 
eds 
pattern directed inference systems academic press new york 
dehaspe toivonen dehaspe toivonen 
discovery frequent datalog patterns data mining knowledge discovery journal vol 

de raedt de raedt 
inductive logic programming language database mining 
proceedings th international conference artificial intelligence symbolic computation lecture notes artificial intelligence vol 
springer verlag 
de raedt de raedt 
logical database mining query language 
proceedings th inductive logic programming conference lecture notes artificial intelligence vol 
springer verlag 
dong li dong li 
efficient mining emerging patterns discovering trends differences 
proceedings kdd acm 
gunopulos gunopulos mannila discovering specific sentences randomized algorithms 
afrati kolaitis eds database theory icdt th international conference lecture notes computer science springer 
han han lakshmanan ng constraint multidimensional data mining computer vol 

han han pei yin 
mining frequent patterns candidate generation 
proceedings acm sigmod conference management data 
hirsh hirsh 
generalizing version spaces 
machine learning vol 

imielinski mannila imielinski mannila 
database perspective knowledge discovery 
communications acm 
inokuchi inokuchi washio motoda 
apriori algorithm mining frequent substructures graph data 
komorowski eds 
proceedings pkdd lecture notes artificial intelligence vol 
springer verlag 
kramer frank kramer frank 
bottom 
proceedings progress track th international conference inductive logic programming 
kramer de raedt kramer de raedt 
feature construction version spaces biochemical applications 
proceedings th international conference machine learning morgan kaufmann 
mannila toivonen mannila toivonen levelwise search borders theories knowledge discovery data mining knowledge discovery vol 

meo meo psaila ceri extension sql mining association rules 
data mining knowledge discovery vol 

mellish mellish 
description identification algorithm 
artificial intelligence 
mitchell mitchell 
generalization search artificial intelligence 
ng ng han pang 
exploratory mining pruning optimizations constrained associations rules 
proceedings acm sigmod conference management data 
cunningham zhang 
development characterization application predictive toxicology models 
sar environmental research 
srinivasan srinivasan king bristol 
assessment submissions predictive toxicology evaluation challenge 
proc 
ijcai 
