quality speed linear scan register allocation thesis traub computer science partial fulfillment honors requirements degree bachelor arts harvard college cambridge massachusetts april table contents 
register allocation problem 
graph coloring register allocation 
linear scan register allocation 
algorithm 
second chance binpacking 
linear ordering cfg 
allocation candidates lifetime holes 
binpacking model 
second chance allocation 
resolution 
move optimizations 
heuristics 
complexity analysis 
exploring linear model 
experimental evaluation 
run times 
compile times 
related 


acknowledgments 
chapter fast compilation tools essential high software productivity 
despite increasing speeds modern processors important find efficient compilation techniques 
processors complex demand highly opti code generation increasing 
response trend program optimization optimizations targeted program units larger single procedure single file 
success approach depends heavily near linear optimization techniques 
growing trend seeks optimize application code load run time 
example poletto describe benefits techniques adaptive optimization dynamic code generation respec tively 
acceptably responsive techniques operate high speed avoid incurring high run time overhead 
register allocation phase code generation bottleneck register allocation necessary making today processors reach peak efficiency 
important understand trade speed register allocation quality resulting code 
thesis investigate fast approach register allocation called linear scan compare widely graph coloring method 
comparison shows linear scan significantly faster coloring con ditions especially programs large number variables competing registers 
describe new linear scan algorithm called second chance binpacking maintains linear character pays attention quality resulting code 
thesis shows second chance binpacking produces code quality identical graph coloring 
viable cost effective solution 
register allocation problem order run efficiently today microprocessors carefully take advantage registers reside chip 
closest storage units cpu pipeline fastest access time 
minimal compilation sequence front parses source high level language code performing lexical semantic analyses converting program intermediate representation ir 
compiler back takes translating intermediate representation instructions tar get machine native instruction set 
phase code generation register alloca tion performed 
point instructions contain kinds operands program symbolic variables compiler generated temporaries machine registers come pre assigned due architectural conventions 
access ing registers faster accessing memory request hits second level caches object register allocation phase decide vari able compiler temporaries assigned registers spilled memory 
seek register allocation minimizes spilling traffic regis ters memory 
distinguish local global register allocation 
local register allocation seeks find assignment variables registers single basic block linear sequence instructions executed interruption 
global register allocation seeks find assignment variables registers procedure entire control flow graph data structure basic blocks showing condi tional looping structure program code 
thesis considers techniques glo bal register allocation 
register allocation shown np complete 
binpacking register allocation fact equivalent knapsack problem 
graph coloring knapsack problems classical np complete problems :10.1.1.31.6059
formulations researchers suggested heuristics attempt reduce complexity algorithms 
section describes linear scan heuristics 
graph coloring register allocation order find assignment register candidates machine registers graph coloring register allocators information liveness interference 
variable said live program point path exit value may redefined 
dead path 
straight forward dataflow analysis pass compute liveness information 
roughly speaking vari ables said interfere simultaneously live program point 
graph coloring allocator summarizes liveness information relevant regis ter allocation problem interference graph nodes represent register candidates edges connect nodes corresponding candidates interfere 
register target machine finding coloring interference graph equivalent assigning candidates registers conflict 
standard graph coloring method adapted register allocation chaitin iteratively builds interference graph heuristically attempts color 
heuristic succeeds coloring results register assignment 
fails register candidates spilled memory spill code inserted occurrences process repeats 
practice cost graph coloring approach dominated construction successive graphs potentially quadratic number register candidates 
single compilation unit may thousands candidates variables compiler generated temporaries coloring expensive 
linear scan register allocation contrast graph coloring linear scan allocator begins view liveness life time intervals 
lifetime interval register candidate segment program starts candidate live static linear order code ends live 
section describes linear ordering linear scan register alloca tors 
lifetime typically stretches candidate definition 
exception looping control flow lifetime interval extended loop bound aries candidate live 
linear scan allocator visits lifetime interval turn occurrence static linear code order considers intervals currently active 
number active intervals represents competition available machine registers point program 
active lifetimes fit simple heuris tic chooses spill memory scan proceeds 
tries detect resolve conflicts locally entire compilation unit linear scan operate faster graph coloring 
previous linear scan allocators run time linear size procedure compiled 
algorithm chapter describe version linear scan allocator 
algorithm variant linear scan called binpacking digital equipment uses commercial compiler products 
describe improvements binpacking approach 
significant change involves algorithm ability allocate regis ters rewrite instruction stream single scan current linear scan algorithms aware allocate rewrite separate passes 
algorithm introduces additional flexibility register allocation process giving spilled allocation candi dates multiple chances reside register lifetimes 
bility approach requires second pass reconcile linear ordering assumptions non linearity procedure control flow graph cfg 
chapter describe experiments 
machine suif code generation framework com pare performance linear scan algorithm modern graph coloring algorithm 
chapter second chance binpacking chapter describes major contribution thesis new register allocation algo rithm call second chance binpacking 
important goals guide design algorithm speed allocation quality code produced 
spirit linear scan family allocators seek keep allocation time minimum avoiding expensive iterative computations ones graph coloring register alloca tion 
furthermore allocation technique aware algo rithm described performs allocation code rewriting single pass instructions procedure 
order meet goal quality produced code clear want minimize amount spill code inserted 
section section describe novel techniques minimization load store move opera tions 
section introduces methods resolving conflicts remain allocation pass due control flow program 
resolution phase enables flexibility optimizations pass program viewed linear sequence instructions 
conclude chapter analysis complexity algorithm observations implications linear model operate 
linear ordering cfg name implies linear scan register allocator needs fix linear ordering procedure control flow graph 
sense linear scan approach abstracts control flow considering linear ordering basic blocks 
entire control flow graph viewed single block 
linear ordering choice compiler writers reverse postorder depth search control flow graph 
depth search follow paths graph deeply possible point backtracking trying different path 
specifically edges explored dis covered vertex unexplored edges leaving 
edges explored search backtracks explore edges leaving vertex dis covered 
shows example control flow graph tree resulting depth search 
list order nodes visited depth search get fol lowing sequence sequence mark boldface occurrence node number 
postorder nodes 
reversal postorder called reverse postorder 
note reverse postorder represents ordering traverses graph ward direction 

example control flow graph linear ordering associated blocks 
example cfg corresponding depth search tree cormen introduce names different kinds edges depth tree 
back edges defined edges connecting vertex ancestor depth tree 
purpose discussion shall consider edges normal edges 
edge block block representing loop back edge depth tree 
theorem numbered reverse postorder node higher number predecessors edge back edge 
proof observe times node listed visiting sequence discovered successors done backup consider point pro cessing complete finished processing suc cessors 
observation time noted visiting sequence 
backup predecessor arrived clear assigned higher number consider point predecessor back edge 
cases may visited case assigned lower number may visited case ancestor wise discovered edge 
ancestor visited backing assigned lower number consider back edge 
definition ancestor tree receive lower number theorem important implications linear scan register allocators 
reverse postorder blocks allocation order guaranteed block predecessors ones back edges allocated allocate block 
shall see property important carry information block boundaries 
allocation candidates lifetime holes describe preliminary concepts objects wish allocate 
allocator seek assign registers program variables compiler gener ated temporaries 
shall refer allocation candidates temporaries 
refer instructions temporary source operand reading instructions destination operand writing examining lifetime temporary observe may contain intervals useful value maintained 
intervals termed life time holes 
illustrates kinds lifetime holes appear life time temporary 
kind hole extends temporary definition basic block 
hole lifetime kind 
second kind starts extends basic block temporary dead exit block block 
hole lifetime kind 
third type hole starts top block extends defi nition block temporary dead entry block 
hole life time kind 
kind shown occurs temporary dead entry exit basic block referenced block 
case hole extends block 
assign temporary register entire lifetime assign temporary lifetime lifetime fits inside lifetime hole temporary fits entirely lifetime hole assigned register 
single reverse pass code compute lifetimes life time holes 
binpacking model register allocation model adopt views machine registers bins temporary lifetimes packed 
constraint bin may contain valid value point program execution 
assuming infinite resource machine unbounded number registers task choose smallest subset registers assigned lifetimes minimize 






example cfg temporary lifetimes overlaid 

example illustrating concept linear ordering procedure basic blocks lifetimes lifetime holes temporaries procedure 
notice block boundary cause hole linear view program 
number ways 
assign non overlapping lifetimes register 
second assign temporaries register lifetime entirely contained lifetime hole 
cases con straint register bin violated 
binpacking allocator scans code forward linear order processing tempo encountered program text 
processing temporary involves allocation register currently assigned register 
view unoccupied register containing lifetime hole extends point program longer free 
view selection register allocate involves search register hole big contain entire lifetime assign register replace assuming infinite number registers 
reality number registers available machine fixed 
point linear scan overlapping lifetimes available regis ters values need spilled memory 
traditional approach linear ordering blocks lifetime hole lifetime linear ordering example cfg lifetime holes indicated temporary 
linear scan allocation traverses sorted list lifetime intervals deciding temporaries live register live memory 
second phase scans procedure code rewrites temporary operand appropriate register memory 
purpose discussion assume load store architecture register required 
spilled temporary modeled point lifetime interval corresponding load immediately fol definition immediately followed store 
point lifetimes assigned register allocation 
second chance allocation early design binpacking register allocator noticed possible allocate registers temporaries rewrite temporary single linear pass program text 
encounter temporary time inter rewriting process determine allocation spill tem create free register proceed manner identical approaches separate allocation rewriting phases temporary currently residing register spilled memory assigned spilling decisions priority heuristic compares distance temporary weighted depth loop occurs picking lowest priority temporary eviction 
section gives full details heuristic function 
system unique linear scan allocators spill point marks split lifetime evicted temporary point rewritten register algorithm go back change fact 
spill decision affects encountering spilled temporary find reg occupy instruction uses 
read find free register possibly evicting temporary process insert load memory location allocated new register allow remain higher priority temporary evicts lifetime ends 
effect split lifetime 
benefit approach reload near 
need special mechanisms preference spill load register spill load 
approach optimistically pessimistically plan refer ences 
perform lifetime splits due emphasis single allocate rewrite pass allocator naturally supports optimistic approach 
spilled temporary write allocator uses similar optimistic heuristic 
allocate register possibly spilling current temporary register postpone store new value back memory temporary causes allocator evict rewritten reach lifetime may produce postponed store 
call optimistic handling spilled temporaries second chance give temporaries second third chance finding register home 
second chance approach completely generalized provide temporary lifetime potentially new register split lifetime 
optimization perform allocating rewriting 
case create load spilled temporary memory register optimize rewrite process adding store instructions 
evicting temporary register value matches value memory add store perform optimization maintain infor mation consistency value respect value memory home 
load store memory home consistent write value invalidates consistency memory register values 
come point decide evict avoid generation store spill evicted lifetime holes store needed refer ence overwrite current value values memory consis tent 
resolution mentioned earlier aggressive optimizations second chance mecha nism come cost 
giving temporary second chance assigning different registers different points lifetime potentially create conflicts alloca tion assumptions basic block boundaries 
linear processing allocation rewrite phase approach incompletely models program control flow 
maintain pro gram semantics follow allocation rewrite phase traversal cfg edges resolving mismatch allocation assumptions edge 
resolve conflicts allocation assumptions cfg edges inserting appropriate set load store move instructions 
allocation pass maintain map gives information location temporary top bottom basic block 
control flow edge possibilities require resolution 
temporary register bottom predecessor block memory top successor block insert store instruction temporary allocated register memory home inconsistent 
temporary moved memory register insert load instruction 
temporary different registers edge insert move instruction 
processing edge careful model data movement edge manner produces correct resolution instructions semantically correct order case temporaries swap allocated registers 
processing similar replacing ssa nodes set equivalent move operations 
gives simple example resolution 
assume temporaries contain lifetime holes registers 
linear allocation order 
allocator encounters assigns rewrites 
allocator encounters third lifetime spills memory 
encounters inserts load memory time register second chance allocation 
linear scan completes rewriting 
resolution allo inserts store top load bottom 

block head edge single predecessor place resolution code top block 
block tail edge single successor place resolution code bottom block 
edge critical edge split edge safely creating location place resolution code 




example cfg allocation 
cfg contains temporary lifetimes thick lines shown 
mem ld cfg allocation 
instructions associated shown 
allocation assumptions resolution shown sets top bottom block 

example conflict resolution cfg edges 
linear processing cfg lead unnecessary spill loads 
continuing example assume remove shortest lifetime block 
change allocator currently described insert load 
linear ordering assumes left memory bottom block memory top block 
pessimistic assumption control flow edge directly connecting 
able take advantage fact registers unused top till allocate register entire length 
best choice allocate top eliminating gen eration resolution code edge choice require reconstruct binpacking state linear traversal transitions blocks connected control flow edge 
consider expensive operation considering may needed temporary original example 
alternative solution run code motion pass tries sink stores hoist loads meet 
loads stores memory location meet replace operations move 
st 

ld 
live st mem store source register load destination register 
resulting move possibly eliminated subsequent copy propagation dead code elimination passes 
perform dataflow analyses register allocation mini generation improve placement spill code perform resolution phase allocator dataflow analysis correctness 
decide insert store instruction evicting temporary see section assume memory register contents consistent 
assumption may hold paths control flow graph necessarily paths reaching point consistency information 
order determine spill stores need inserted guarantee consistency paths solve fol lowing iterative bit vector dataflow problem 
bit vector analysis requires bits allocation tem live basic block boundaries 
allocation rewrite phase maintain working bit vector called consistent 
bit consistent corresponding temporary set long allocated register contents consistent memory home 
described sec tion write clears load store set generate spill store eviction set 
save local copy consistent basic block 
copy subsequent dataflow analysis 
pass generate local gen kill sets basic block bit vector wrote tr corresponds kill set 
bit wrote tr corresponding temporary initially clear set register allocated written bit vector consistency corre sponds gen set 
bit consistency corresponding temporary initially clear set clear inhibit 
assume liveness information finding lifetimes holes available register allocation begins 
cost gathering storing amortized optimizations typical optimizing compiler 
generation spill store 
words set inhibiting spill store relies assumptions consistency local completed linear scan allocate rewrite phase iterate find fixed point dataflow equations blocks initially set equal consistency 
resolution processing insert spill store temporary pro cessing cfg edge bit set bit consistent clear 
edges represent beginnings paths reaching program points consistency register memory home exploited register memory consistent 
placement spill store fol lows placement rules resolution code 
move optimizations succ consistency wrote tr modern architectures typically impose usage conventions registers 
caller saved registers example preserved procedure calls 
described far algorithm allows temporary assigned register register free temporary entire remaining lifetime 
restriction temporaries live calls compete solely callee saved registers 
algorithm represent constraints register usage considering life time holes intervals register free 
temporary fit inside register lifetime hole temporary lifetime hole 
order overcome problem described algorithm allows temporary assigned reg lifetime hole large contain entire lifetime 
effect letting temporary live register long predetermined conven tions allow 
algorithm heuristically searches largest insufficiently large holes trying leave temporary register long possible 
reg lifetime hole expires check see temporary contained 
evict temporary register point corresponding call site example 
evicting temporary register needed architectural convention insert spill store reloading value time need second chance mechanism 
true register hole contain remaining lifetime 
lifetime fits lifetime hole efficient insert move insert store load provided evicted 
insert move current point find empty register spill store necessary inserted move 
refer mechanism early second chance 
move instruction efficient load store instruction pair want eliminate moves register allocation possible 
linear scan perform check spirit move coalescing attempts assign source destination move register moves eliminated sep peep hole optimization pass 
assign register source move instruction check see register hole starting immediately move source lifetime move destination temporary fits hole 
bypass normal allocation mechanism rewrite move destination register move source 
current implementation performs move optimization source move register allocation phase 
optimization important order satisfy digital alpha calling convention alpha code generator inserts move operations parameter registers symbolic names parameters top procedure 
easily eliminate moves move optimization 
leave instructions code noticeably degrade performance call intensive programs 
straightforward extend implementation attempt move optimization allocation general move source 
heuristics linear scan register allocator invokes heuristic function decide cur rently live temporaries highest priorities belong register 
algorithm consider temporary register lifetime second chance mechanism invoke heuristic decide temporary evicted register order room new lifetime 
cases new temporary receive register current instruction 
cases temporary denied register 
loop entry point temporary lifetime may extend top loop live back edge 
able assign temporary register loop top actual requires regis ter 
case temporary considered register early sec ond chance mechanism described section 
able insert move temporary register needed convention free register 
way avoid store load 
absolutely necessary find register temporary point 
type 
location 
outside candidate lifetime inside candidate lifetime type 
consistent 
consistent 
load load load store load store 
decision tree representing various possible heuristic choices comparing priorities temporaries 
consistency respect temporary considered eviction 
candidate lifetime refers current temporary considered register 
shows decision tree heuristic function 
possible outcomes represented leaves tree selection criteria 
best case labeled occurs free register temporary hole big contain current candidate lifetime 
empty bracket refers null cost decision need evict temporaries facilitate allocation 
similar argument holds choice number 
eviction candidate current candidate lifetime candidate fit hole need insert extra instructions eviction 
temporary current hole need insert store legal value held register 
temporary write need load 
heuristic looks smallest hole type order leave larger holes available longer lifetimes 
hole available algorithm searches largest hole type order postpone evicted candidate long possible 
clear choices described superior rest relative ordering remaining choices clear 
possibilities entail additional spill instructions 
ultimately decision depends instructions added 
example may prefer add store inside deeply nested loop 
creating priority function turn optimal solution local register allo cation problem hints 
problem deciding set temporaries evict register akin problem operating systems domain choosing page evict memory 
provably optimal solution choose page needed furthest postponing page fault long possible 
applied register allocation heuristic called furthest 
linear ordering tries view program basic block local heuristic appropriate 
employ modifications loop depth assess control flow 
actual formula loop depth consistent distance loop depth variable consistent formula value register mem ory values temporary consistent 
term represents cost store temporary value register consistent mem ory 
second term represents cost load read 
divide sum distance implement furthest heuristic 
experience heuristics small changes formula may relatively large impact code difficult settle heuristic best cases 
chose keep heuristic relatively simple 
mentioned earlier code motion optimizations run allocation may successful minimizing better placing spill code 
complexity analysis examine complexity algorithm 
show effectively linear 
running time conflict resolution phase dominated dataflow analysis described section asymptotically linear 
describe dataflow analysis replaced simpler calculation complete linear time 
phases algorithm computation lifetimes holes alloca tion rewriting manifestly linear 
single sweep instructions program compiled 
allocation constant factor proportional number available registers may scan register state order choose assign regis ter 
sweep edges conflict resolution effectively linear real pro grams flow nodes degree number edges grows number nodes quadratically 
equations section solved standard iterative bit vector calculation conflict resolution worst case running time bit vector operations size program 
size bit vectors number temporaries bound cubic total number register candidates typically proportional size program 
common experience standard method terminates iterations brings cost bit vector operations 
implementation time spent dataflow calculation rarely reaches percent time consumed algorithm 
attempted tune phase 
situations strict linearity necessary easily replace iterative dataflow calculation conservative solution 
ensure avoid spill store legal conservatively initialize working copy consistent bit vector top block encountered linear scan 
initialize intersection saved consistent bit vectors bottom predecessor blocks 
assume predecessor uninitialized bit vector clears bits working bit vector 
theorem shows predecessors processed time start allocate block ones start back edge control flow graph 
blocks don complete information loop entrances small minority total num ber blocks 
small number cases solution fact yield correct consistency state top block 
experiments conflict resolution including dataflow analysis con sumed percent total time allocation 
sacrificing strict linearity major impact 
exploring linear model abstracting control flow linear ordering basic blocks linear scan alloca tors run efficiently 
allocation decisions basic block independent decisions blocks order processed blocks immaterial 
fact information register state consistency carried basic block boundaries 
section enumerates possible edges transitions linear ordering effect information 
simplest edge followed linear ordering occurs successors predecessors 
edge example 
edge possible transition state existing bottom hold top kind edge relatively rare compiler usually collapses blocks single 
kind edge occurs multiple successors single predecessor 
split point edge example 
know state reaching bottom hold top edge allocation order carry state 

sample control flow graph 
kind edge presents difficulties 
case single successor multiple predecessors 
say join point edge example 
state leaving certainly reaches state predecessors 
important certain temporary resides different reg bottom different predecessors 
explain section tion mechanism fix edges assumptions don match 
example carry register state block block leaving resolution insert code edge necessary 
decision carry state block block arbitrary 
fact edge may taken time block compared edge block 
profiling infor mation help decide predecessor state take block 
philosophy linear scan algorithm consider expensive allow choice 
implement possibility save reg state bottom block restore enter successor 
possible option introduce considerable complexity maintain information register contents active holes current point pro gram 
multiple successors multiple predecessors kind con hold edge join points described 
final case occurs transition block block control flow edge blocks 
transition blocks example 
sense carry register state non existent edge 
reasons 
believe expensive flush restore register state 
consider example register bottom block register bottom block 
carry state block block need tion move edge 
avoid move restoring state bottom block entering block keeping need resolution move block 
summary clear justified flush restore register state 
simple solution taken fit best efficiency goals allocator 
section discussed consistency information carried basic blocks 
section points possible set consistency bit vector top block equal intersection saved consistency bit vectors bottom predecessors 
sense situation involve high overhead save information bottom blocks case 
implementation try compare approach current dataflow analysis 
chapter experimental evaluation compare fairly linear scan register allocator graph coloring allocator implemented machine suif extension stanford suif compiler system 
suif easy mix match compiler passes 
keeping rest compiler fixed created alternative register allocation passes identical respect central allocation algorithm 
compare allocation approaches dimensions 
assess quality code produced examining run time different benchmarks allocated approach 
instrumenting benchmark executables able collect dynamic instruction counts program run 
compare running time allocators benchmark input 
cost part compile time program 
implementing approaches second chance binpacking graph coloring careful common framework difference performance due strictly different algorithms 
passes example shared ies construct cfgs perform liveness loop depth analyses attaching results cfg prior register allocation 
common set utilities scanning code updating insert spill instructions reflect register assign ments 
loop depth way weight occurrence counts allocators 
coloring method implementation algorithm described george appel 
pure coloring approach style originated chaitin refined briggs 
principal departure style integrates regis ter coalescing copy propagation coloring phase allocation forming repeatedly loop 
register coalescing attempts unify allocation candidates interfere move copy instruc tion connects lifetimes 
usual chaitin briggs method builds new interference graph successful round coalescing 
george appel take costly graph building operation inner loop 
report improves code signifi cantly eliminating copy instructions 
implementation faithful pub algorithm exceptions lower triangular bit matrix hash table record adjacency relation interference graph 
perform liveness analysis allocation round coloring 
linear scan graph coloring temporaries live single basic block excluded dataflow analysis greatly reduces bit vector sizes repeated dataflow analysis unnecessary coloring iterations 
simplification possible linear scan graph coloring temporaries generated spill code insertion live single basic block 
global liveness information affected temporaries 
targeting digital alpha graph coloring allocator deals separately general purpose registers floating point registers 
current alpha implementations data moved register files go memory 
register operand instruction reside file 
coloring non linear costs building interference graph choosing temporaries spill efficient solve smaller problems separately 
approach example compiler george appel designed algorithm 
lin ear scan algorithm hand processes register files 
run times compare quality generated code number benchmarks 
benchmarks spec suite compress ksim spec sort wc unix utilities 
target machine experiments digital alpha running dig unix 
front code generation dead code elimination register allocation copy propagation peep hole optimization dead code elimination finishing peep hole optimization instrumentation assembly linkage profiling executable 
flow compilation passes dynamic instruction counts experiment 
order assess quality code produced allocation approach add instrumentation code collect dynamic instruction counts benchmark 
results obtained halt tool machine suif instrument benchmark code generation 
illustrates sequence passes com pile benchmark 
different points compilation peep hole optimization applied remove unnecessary move instructions collapse pairs adjacent instruc tions possible 
example eliminating move follows add instruction rewriting destination register add 
coloring implemen tation performs register coalescing linear scan approach 
benchmark second chance binpacking instruction counts run copy propagation register allocation 
dead code elimination pass added remove unnecessary instructions basic blocks program 
addition dynamic instruction counts report run times seconds exe cution 
results obtained unix time command lightly loaded alpha 
time best consecutive runs 
table table run time results 
metric calculate ratio result linear scan result graph coloring 
larger ratios mean poorer performance linear scan produced executable 
graph coloring ratio gc alvinn doduc eqntott espresso fpppp li tomcatv wave compress ksim sort wc table comparison dynamic instruction counts executables second chance binpacking approach george appel graph coloring approach 
approach produced executables quality near pro duced coloring 
benchmarks performance degradation linear scan coloring exceed percent 
twelve benchmarks studied allocation approaches produced code virtually identical quality 
sort fpppp benchmarks excess dynamically executed instructions linear scan respectively 
benchmarks contain code high register pres sure observed sensitive small variations heuristic function benchmark second chance binpacking run time sec graph coloring linear scan algorithm 
mention chapter believe passes perform code motion optimizations improve placing spill code 
run time results reported table show similar performance code produced different approaches 
number benchmarks run faster allocated linear scan approach 
timing numbers stable runs believe result unix time command indicator performance dynamic instruction counts report 
help explain variation instruction count results table presents informa tion percentage total dynamic instruction count due spill code inserted register allocator 
count load store move instructions inserted allocation candidates 
benchmarks alvinn li tomcatv compress wc spill code added approach 
sense allocators possible programs 
applications difference dynamic instruction counts table due differences spill code placement 
observed coalescing phase coloring allocator able remove copy move instructions copy propagation pass classical formulation 
ratio gc alvinn doduc eqntott espresso fpppp li tomcatv wave compress ksim sort wc table comparison run times executables second chance binpacking approach george appel graph coloring approach 
benchmark second chance binpacking applications spill code presents detailed look composi tion spill code produced second chance binpacking graph coloring 
doduc ksim binpacking produced spill code coloring 
majority difference due insertion extra spill loads coloring 
binpacking allocator produced spill code coloring eqntott espresso fpppp sort wave 
significant proportion increase appears due extra stores lution eviction 
stores case eqntott lead large number resolution loads 
review output code shows global optimization pass run allocation eliminate unnecessary load store pairs partially redundant spill instructions hoisting sinking techniques 
graph coloring alvinn doduc eqntott espresso fpppp li tomcatv wave compress ksim sort wc table percentage total dynamic instructions due spill code allocation approach 
spill code inserted register allocation percentage reported simply 
order evaluate advantages second chance binpacking traditional pass binpacking created version allocator assigns lifetime memory register 
implementation takes advantage lifetime holes dur ing allocation 
observed classes applications respect performance allocator 
represented best word count wc benchmark contains applications performance degrades substantially binpacking second chance 
wc benchmark ran slower vs dynamic instructions allocated pass binpacking allocated spill code counts normalized binpacking doduc doduc evict loads evict stores evict moves eqntott eqntott espresso espresso resolve loads resolve stores resolve moves fpppp fpppp benchmark scheme sort sort wave wave ksim ksim 
categorization spill code inserted allocator 
results binpacking approach labelled coloring labelled 
benchmark normalize counts total spill code inserted binpacking 
separated eviction spill code inserted linear scan coloring algorithm spill phase resolve spill code inserted resolution phase 
second chance approach 
wc benchmark large number temporaries live loop contains procedure call routine 
second chance mechanism manages allocate temporaries caller saved registers evicting just procedure call avoiding unnecessary stores 
pass binpacking approach able caller saved registers hole caller saved register large contain lifetimes temporaries live call 
evicts temporaries callee saved registers 
algo rithm avoid unnecessary stores costly spill code inserted inside loop 
class applications exemplified eqntott identical performance pass binpacking second chance binpacking vs dynamic instructions 
eqntott benchmark spends majority time proce dure contains small number temporaries requires spilling 
compile times evaluate compilation speed methods timed representative modules benchmark set 
table shows results obtained timing core parts allocators lightly loaded alpha 
particular record time day setup activities common allocators cfg construction loop analysis liveness analysis record time day allocation 
difference recorded times summed procedures compiled module produce times table 
best consecutive runs 
table includes average number register candidates procedure module average num ber edges interference graphs 
module procedure benchmark coloring allocator faster small problems performance rap worse programs competing register candidates 
num bers illustrate coloring allocator slows significantly complexity interference graph increases 
data wave benchmark particularly interesting 
despite shorter time spent allocation linear scan algorithm actual performance resulting code virtually identical code allocated graph coloring see table table 
average number allocation time sec register candidates interference graph edges graph coloring second chance binpacking espresso fpppp fpppp fpppp field wave table comparison allocation times 
average number register candidates interference graph edges refer coloring allocator 
numbers cover coloring iterations 
chapter related phrase linear scan developers dynamic code generator describe register allocator system 
having tried graph coloring developed simpler method scans sorted list lifetimes step con lifetimes currently active competition available registers 
active lifetimes fit longest active lifetime spilled memory scan proceeds 
attempt take advantage lifetime holes allocate partial lifetimes 
context run time code gener ator improvement compilation speed obtained linear scan color ing justifies modest decrease run time performance 
digital equipment linear scan algorithm years gem optimizing code generator compiler back compiler prod 
gem approach binpacking treatment lifetime holes starting points linear scan allocation 
binpacking evolved research done production quality compiler compiler project cmu 
discovery linear scan register allocation digital accident implementation intended throw away module meant replaced elaborate scheme 
throw away turned perform better com replacement shipped product 
digital allocator uses history allows load instructions omitted remembering values memory mirrored registers 
second chance method subsumes history adds dual optimization avoiding store instruction register value shown exist memory needed memory 
laurie hendren group mcgill university experimented alter native representation interference graphs call cyclic interval graphs 
data structure provides fine grain information overlap temporary lifetimes especially extending loop 
hendren algorithm cov ers points maximal pressure fat cover set non overlapping intervals fit register 
idea similar binpacking 
hendren introduces concept chameleon interval temporary assigned different colors registers different points lifetime 
concept related second chance mechanism hendren restricts allocator single basic block perform resolution result multiple register homes 
book bob morgan presents hybrid approach register allocation 
runs limiting pass reduces register pressure introducing spill code temporaries live loops 
runs register allocator phases starts graph coloring allocate temporaries live basic blocks 
uses hendren representation algorithm allocate local tem occupy registers global temporaries 
final phase uses standard local algorithm allocate purely local temporaries 
chapter linear scan methods register allocation fast effective 
enable interprocedural optimization large programs appropriate run time code gen eration 
avoid risk compile time performance degradation graph col oring methods suffer certain program inputs 
studied new implementation linear scan called second chance binpacking 
approach performs register allocation instruction rewriting single pass paying attention spill code minimization linear scan approaches 
fair comparison new method designed coloring algorithm linear scan competitive output quality prone slow complex inputs 
benchmarks studied performance code produced linear scan algorithm worse formance code produced coloring algorithm 
benchmarks formance identical approaches 
results thesis demonstrate valuable lesson algorithm software design understanding trade offs time spent algorithm qual ity output produced important step design efficient systems 
sur efficacy linear scan approach register allocation reminds intricate nature np complete problem space 
craig davidson grove hobbs gem optimizing compiler system digital equipment technical journal 
briggs cooper torczon improvements graph coloring register allocation acm transactions programming languages systems may 
burmeister harris hobbs patent number 
chaitin register allocation coloring computer languages 
chaitin register allocation spilling graph coloring acm sig plan notices june 
cormen leiserson rivest algorithms mit press cambridge ma 
fernandez simple effective link time optimization modula programs acm sigplan notices june 
garey johnson computers intractability guide theory np completeness freedman new york ny :10.1.1.31.6059
george appel iterated register coalescing acm transactions programming languages systems may 
hendren gao altman register allocation framework hierarchical cyclic interval graphs proc 
th international compiler construction conference october 
hobbs personal communication july 
adaptive optimization self reconciling high performance exploratory programming ph thesis stanford university march 
register allocation optimizing compilers ph thesis cmu cs carnegie mellon university february 
morgan building optimizing compiler digital press boston ma 
muchnick advanced compiler design implementation morgan kaufmann publishers san francisco ca 
poletto engler kaashoek tcc system fast flexible high level dynamic code generation acm sigplan notices may 
smith extending suif machine dependent optimizations proc 
suif compiler workshop stanford ca pp 
january 
url www eecs harvard edu 
tanenbaum modern operating systems prentice hall englewood cliffs nj 
wall global register allocation link time acm sigplan notices july 
wilson suif infrastructure research parallelizing optimizing compilers acm sigplan notices may 
url suif stanford edu 
wulf johnsson weinstock hobbs design optimizing compiler american elsevier new york ny 
acknowledgments advisor prof mike smith continuous support project 
stages design implementation involved unwilling compromise quality research experimental results 
learned invaluable lessons compiler design software engineering intricate art evaluating debugging assembly code 
glenn holloway incredible efforts endless patience 
count answers question knowledge com puter science enormous 
glenn implementer graph coloring algorithm comparison chapter 
committee members profs 
harry lewis margo seltzer wish extend time read thesis 
harry lewis taught important lessons theory np completeness algorithmic design mathematical thinking 
number people outside harvard supportive research 
steve hobbs bob morgan digital equipment helpful discussing implementation binpacking gem compiler 
max poletto mit help ful explanation linear scan dynamic code generation 
family friends flora stern particular moral support encouragement months research 

