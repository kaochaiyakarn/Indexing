cache conscious radix decluster projections stefan peter niels nes martin kersten cwi kruislaan sj amsterdam netherlands stefan peter niels nes martin kersten cwi nl cpus powerful moore law memory latencies stay constant impact memory access performance bottleneck continues grow relational operators join exhibit random access memory region larger hardware caches 
cache conscious variants various relational algorithms described previous ignored cost projection columns 
real life joins come projections proper projection column manipulation integral part generic join algorithm 
analyze cache conscious hash join algorithms including projections storage schemes ary storage model nsm decomposition storage model dsm 
turns strategy executing join dealing projection columns post projection dsm combination new finely tunable algorithm called radix decluster outperforms previously reported projection strategies 
result generally applicable outline dsm radix decluster integrated nsm rdbms projection indices 
random memory access outside cpu cache expensive past decade remain 
bottleneck low level database data access shifting memory access 
performance penalty inefficient usage dramatic database field need despair 
decades progress database technology produced host techniques processing data volumes stored large slow memories disks permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings th vldb conference toronto canada making efficient smaller faster memory ram 
research cache conscious query processing focuses transforming techniques level higher memory hierarchy optimize memory access making efficient cpu caches devise new techniques 
build making join operator cache conscious introducing partitioned hash join paired fine grained partitioning operator called radix cluster partition huge relations large number small clusters fit cpu cache just tens kbs :10.1.1.112.263
limitation previous efforts far considered joins thin relations consisting solely join keys producing table matching oid pairs join index 
real life rdbms join query goes accompanied projection non join columns result 
cost handling projection columns depends number type relation cardinalities inputs result 
actual cost impact vary zero realistic case projections totally dominating imagine join thousands projection columns propagate feature vectors multimedia application 
performance evaluation find queries may spend time projection 
efficient handling projections part cache conscious join technique 
problem statement describes optimization cpu generic equi join including projections select larger larger ay smaller smaller bz larger smaller larger key smaller key focal point analysis performance impact amount projection columns ay respectively bz various relation join result sizes 
handling projections efficiently hard smaller larger table tuples individual columns fit cache 
radix decluster algorithm addresses situation 
pre projection result post projection result ay key larger ay key ay bx ay join radix cluster radix cluster key smaller key bx larger ay key bx ay bx join radix cluster radix cluster 
pre vs post projection smaller key commonly applied projection strategy rdbms pre projection see projection columns fetched table scans preceding join projection column values travel extra join keys join pipeline 
contrast radix decluster post projection method join result computed creating partial join index full query result produced computing projection columns 
focus experiments particular join algorithm partitioned hash join radix decluster algorithm independent join method chosen 
ram vs disk optimization mentioned analogy optimizing cpu cache access optimizing disk access instructive point main similarities differences 
similarities disk ram contend high random access latency relative cpu speed increasing exponentially time 
just disk ram block device block cache line sequential data access faster random access random access data block call optimal random access 
effect caused new feature memory subsystems called data prefetching cpu cases memory chipset automatically detect sequential access patterns schedule data loads advance 
complemented advances dram technology keeps banks accessed locations open adjacent locations quickly available 
experimentation platform sequential access obtained stream times faster optimal random access gb vs mb ns latency getting cache line bytes mb 
important difference disk ram disk controlled os interface allowing traditional dbms systems full control buffer cache 
contrast ram cached implicitly hardware lru mechanism limited associativity 
way query processing algorithms influence ram caching indirectly controlling bx data placement access pattern 
second difference small granularity cpu caches 
year gap cpu cache ram sizes problem sizes caches having ram sizes 
means partitioning fit large cpu cache create small partitions classical partitioning fit disk ram 
having manage tens thousands partitions handful expose bottlenecks remained unnoticed disk case see discussion radix cluster algorithm 
experimentation platform reported partly builds research cache conscious query processing monetdb project 
monetdb main memory database system targeted query intensive applications uses vertically fragmented storage scheme called decomposition storage model dsm 
dsm tuple gets unique system generated oid typically densely ascending column dsm table created holds oid value pairs 
comparable oracle monetdb system support implicit columns dubbed void columns virtual oids represent densely ascending oid columns logical level physical storage 
monetdb relational column stored separate void value table 
dsm systems away extra storage oids dsm data layout boils single array column 
dsm cache friendly olap queries need subset table columns case low projectivity 
commonly nsm storage scheme layout tuple contiguously stored means parts cache line 
dsm cache line contains values column relevant columns loaded achieving optimal cache line usage 
second characteristic monetdb column wise query processing model allowed implementation query processing algebra need interpreter evaluate expressions operation performs simple hard coded operation large arrays values producing new column result 
goes conjunction absence low level record attribute lookup data movement functionality columns accessible position arrays homogeneous type 
experiments performed confirm factors give monetdb significant advantage terms raw cpu efficiency strongly linked query execution model 
third main characteristic monetdb query processing 
monetdb birth ground number novel cache conscious algorithms :10.1.1.112.263
radix decluster contribution crucial addition collection 
available www sourceforge net projects monetdb related experimentation platform monetdb dsm system compare approach common counterpart nsm particular preprojection nsm commercial database systems 
research nsm post projection particular slam jive join algorithms 
algorithms assumption join index computed available pre projection option designed mainly setting include nsm comparison radix decluster evaluate usefulness perspective cache conscious query processing 
interesting alternative storage scheme pax basically dsm nsm disk page 
pax cache line usage efficient dsm low projectivity pax wastes bandwidth queries easily cause performance bottleneck 
case radix decluster dsm scaled disk rdbms runs high bandwidth subsystem sized raid array scsi disks controlled pci experimentation limited main memory execution lack expensive setup 
main memory difference pax dsm small limit extremes nsm dsm 
build previous detailed performance modeling hierarchical memory access cost hardware independent formulas parametrized relevant architectural characteristics 
parameters derived automatically run time utility integrated monetdb 
cost formulas easy define consist combination number basic patterns known formulas combined automatically composition functions 
cost models allow quickly analyze behavior various algorithms draw optimal parameter settings 
outline section give short re cap cache conscious partitioned hash join radix cluster basic building blocks research 
section show radix cluster optimize memory access post projections join relations 
order optimize cache usage projections join relations introduce new radix decluster algorithm 
section perform exhaustive experiments preand post projection strategies dsm nsm storage schemes compare non cache optimized strategies radix algorithms jive join 
section case dsm available monetdb cwi nl post projection radix decluster integrated standard rdbms technology discuss directions section 
cache conscious join give short re cap cache conscious join partitioned hash join conjunction radix cluster :10.1.1.112.263
give cost model descriptions algorithms show correctly predict performance see resp :10.1.1.2.2900
figures 
partitioned hash join hash join algorithm considered outer relation scanned sequentially hash table probe inner relation 
nature hashing algorithm implies access pattern inner relation plus hash table random 
partitioned hash join scans relations partitions hashing criterion making inner partition smaller cache size subsequent hash joins corresponding partitions cache behavior 
cursors output partitions partitioning operator inserts tuples scans input need cache line order achieve performance partitioning 
number available cache lines limited especially systems slow tlb cache usually entries number cursors grows size relation bigger relation leads partitions size simple partitioning limited scalability certain relation size partitioning operation performance problem due cache thrashing cursors kept cache anymore 
radix cluster radix cluster algorithm uses incremental multi pass partitioning shown solve operand partitioning problem 
provides efficient partitionings needed large joins passes :10.1.1.112.263
briefly radix cluster radix bits integer hash value join attribute cluster relation partitions 
performing sequential passes bp bits starting left bp radix cluster limits number partitions created pass hp bp hp 
sketches partitioned hash join relations relations clustered partitions bits passes 
pass uses left lower bits create partitions 
second pass partitions sub divided partitions remaining bit 
relations clustered performed matching partitions 
ease pass radix cluster partitioned hash join pass radix cluster black tuples hit lowest bits values parenthesis 
partitioned hash join presentation apply hash function 
practice hash function integer values ensure bits join attribute play bits clustering 
dsm post projection dsm post projection strategy phases 
join index 
access dsm tables storing key columns join find matching pairs tuples join index 

column projections 
construct columns result relation separate dsm table join index fetch values input column stored dsm table 
join index consists oid oid combinations pointers smaller larger input relations 
necessarily implemented pointers may integer record numbers byte offsets combinations disk block numbers byte offsets 
projection operations pointer joins positional joins negligible cpu cost 
monetdb columns stored void value tables implement arrays oid simple integer starting entry positional join equals array lookup 
note dsm post projection join strategy materializes join result 
inevitable called hard join cases join relations fit small fast memory cpu cache 
similar scalable join algorithms sort merge join hybrid hash join applied inner relation exceeds ram buffer size pipelining possible 
columns variable sized types string extra separate memory buffer array simply contains integer offsets 
monetdb join hard individual columns entire smaller relation exceed cpu cache 
called easy cases simple non partitioned hash join building hash table smaller relation generate join index 
join index contain oids larger relation ascending order positional joins projecting input columns result exhibit sequential ram access pattern 
discussed section sequential ram access supported modern hardware 
contrast positional joins projections smaller relation random access pattern 
luckily columns fit cpu cache easy cases cache lines input columns stored stay cached cpu access subsequent adjacent data fetches serviced cache 
attack problem executing hard joins cache conscious manner 
cpu caches limited couple mbs assuming average bytes currently translates joins intermediate relations tuples common relevant problem 
partial radix cluster partitioned hash join described section join relations exceed cpu cache cache conscious manner 
due nature partitioned hash join oids larger smaller relation appear ascending order resulting join index 
standard improvement sort join index order oids larger relation 
monetdb re radix cluster algorithm sort exploiting property oids stem dense domains size relation 
types oid radix cluster transforms value hash function obtain integer bits combat skew 
oids hashing applied oids integers skewed 
means radix cluster significant bits lowermost log bits equivalent radix sort 
radix sort compared traditional run generating sort algorithms partitions data sequential pass iteratively processes partition 
fully sorting join index overkill partial ordering achieve effect 
consists clusters contain oids certain disjoint range positional join projection column sequentially processes cluster processing individual cluster accesses limited region projection column 
region small fits cache algorithm approach optimal cache re usage 
partial clustering possible added possibility indicate radix cluster early ignore certain number lower prior computation join index partial radix cluster radix cluster void zero storage column dashed arrow head indicates xx xx mark join larger spanned cluster size source column chosen fits cache positional joins access randomly result table positional joins clustered access source table 
projection joins partial radix cluster cache size radix bits 
stopping early leaves relation unsorted lowermost bits partially ordered 
benefit partial cluster strategy potential optimize memory performance column projections positional joins just full radix sort clustering cost 
shows partially radix cluster pass radix bit stopping early lowermost radix bit 
resulting oid oid table create void oid larger operator 
right column join larger contains clustered oid column left column consist new densely ascending oid sequence represents join result 
subsequent positional joins join larger view input columns nice sequential access pattern eliminating cache problem 
compute optimal number radix bits ignore bits follows log column log column log denotes number tuples table denotes byte width tuples size cache bytes see 
example cpu cache kb values bytes wide cluster tuples just fit 
source table projections come tuples create clusters arrive mean cluster size largest cluster size 
clusters created partial radix cluster highest significant bits bits log allowing radix sort ignore lowermost bits 
fetching column values source table see join larger clust borders radix decluster xx xx radix count radix cluster partial radix cluster mark clust result clust values join smaller mark positional join clustered access prior computation join index radix cluster partial radix cluster mark clust smaller 

result table source table columns 
optimized dsm post projection radix decluster radix decluster partial radix cluster optimize projections larger relation cache problems occur projections smaller relation 
clear join index join result simultaneously clustered oid orders 
shows performing projections larger relation re cluster view join smaller similar join larger consists fresh densely ascending oids left paired right column clustered join index 
yields temporary oid oid table 
create void oid views clust result clust smaller table mark operator 
left column views fresh void column new ascending oids 
right column clust smaller holds oids join index point smaller table nice clustered order corresponding values right column clust result hold correct position join tuples final result 
step process smaller perform projections cache clust borders cluster outside window cluster positions cluster start positions clust result result column insertion window clust values put advance cluster current element consideration cluster outside window put delete empty cluster put delete empty cluster advance window ready memory access pattern single multi cursor sequential scan clust result clust values cacheable random access result column clustered insertion window repeated sequential scan cluster start array generally small cacheable put advance window reset 
memory access pattern radix decluster efficient positional joins 
produces projection columns denoted clust values correct order 
radix decluster algorithm depicted detail performs task putting correct final result order cache friendly manner 
radix decluster exploits properties right column clust result created radix clustering column order right column radix cluster adds deletes values column form dense sequence sorted 
cluster oids sorted 
happens radix cluster scans input sequentially appends values respective output cluster locally respecting input order 
property implies right column sorted merging sorted clusters 
cpu cost merge tuples partitioned sorted clusters log alternatively property just insert values clust values result array result array index put delete empty cluster advance window reset cluster outside window put advance cluster cpu cost insertions constitute random access pattern larger cpu cache 
obtain best approaches restricting random access insertion window cf 
iteration algorithm processes cluster advancing cursor oids fit window inserting values oid position 
property tells processing cluster positions insertion window filled dense oid sequence 
window shifted positions process repeats cursors reached cluster 
window size preferably larger number clusters iteration cluster multiple tuples fall window 
multiple tuples accessed sequentially clust result clust values 
memory access pattern crucial sequential access fully uses cache lines store columns 
restriction fit memory cache filled random order 
pseudo code algorithm 
type radix decluster type int cardinality type values cardinality oid ids cardinality struct int start cluster type result column malloc cardinality sizeof type int sizeof type int ids cluster start result column ids cluster start values cluster start cluster start cluster cluster cluster delete empty cluster break cluster elements window clusters merge insertion windows fill result return result column 
radix decluster algorithm radix count previously mentioned analyzes partially radix clustered column returns actual sizes clusters 
sizes radix decluster initialize cluster border structure 
radix decluster projection strategy expensive partial cluster strategy discussed earlier 
strategies feature initial radix cluster projection column positional join adds extra radix decluster operation projection column 
getting projection columns table cheaper projections 
input relation join cheapest projection phase depends number projection columns relations data types projection columns number tuples input relations 
performance evaluation section experiments done ghz pentium machine entry tlb latency cycles kb cache byte cache lines latency cycles kb cache byte lines latency cycles latency gb pc main memory ns 
experimentation platform monetdb nsm experiments nsm simulated introducing new atomic types hold integer column values copied projected nsm projection routine iterates record copies selected values 
experiments executed example sql query various dsm nsm query processing strategies described 
relations equal size ranging tuples early cache conscious query processing reported cycle latency observe fold increase years 
consisting integer byte columns 
vary join hit rates project columns relations result 
experiments join relations selection base table selected fraction get sparse projections 
experiments processing happens mainmemory page faults 
dsm post projection experiments analyze performance behavior radix decluster isolation 
shows relationship size insertion window cf section performance 
hardware performance counters obtain detailed information amount tlb misses 
data enabled formulate validate performance model described :10.1.1.2.2900
formula denotes total number insertion windows 
models predict accurately explain happening seen fact dots values obtained experiments lines cost model figures nicely coincide 
look detail see radix decluster faster insertion window larger explained fact larger insertion window leads higher average number tuples processed cluster iteration improving sequential memory bandwidth usage clust result clust values 
insertion window sustains random access pattern bigger cache size kb performance drops sharply due increase misses 
important threshold bigger number pages fit tlb tlb misses start occur inserts 
thresholds drawn 
cause tlb misses number input clusters bigger number tlb entries depicted case radix bits clusters radix decluster iteration cause tlb misses starting process new cluster clust result clust values 
happens tuples impact diminishes quickly increasing window size 
analysis showed choosing sufficient achieve memory bandwidth usage value confirm accuracy model multiple cardinalities radix bits 
turn attention interplay radix cluster positional join radix decluster radix decluster dsm post projection strategy depicted 
section gave formula computing number bits radix clustering join index subsequent positional joins run 
confirms accuracy predictive model positional joins relations multiple cardinalities hit rate clustered varying tlb matches cache sizes misses misses tlb misses milliseconds insertion window size bytes number events elapsed time input clustered bits milliseconds modeled lines vs measured points performance number radix bits total radix cluster positional join radix decluster components total cost best insertion window size 
radix decluster larity radix bits 
setting verify leads lowest number radix bits positional join runs optimally achieves minimal misses 
usually optimal point radix decluster cost increases radix bits 
better fewer radix bits 
performance hit taken positional join compensated cheaper radix cluster 
radix cluster executed positional join projection column usually happens number projection columns low 
perform running cache tlb problems radix decluster limited factors 
need process sufficiently high tuples input cluster exploit sequential memory bandwidth 
saw value choose 
second insertion window size exceed cache size conclude radix decluster handle relations sizes efficiently 
formula resembles similar bound jive join 
analyze dsm post projection strategy generic join query works best circumstances 
note dsm systems matters actual number columns table fragmented vertically distinct columns unused columns stay untouched 
dsm experiment certain holds 
consider strategies identified letter code unsorted positional join join index projection column 
sorted radix sort join index execute positional joins 
partial cluster partially cluster join index 
take number radix bits works best milliseconds unsorted sorted clustered declustered cardinalities number projection attributes larger table unsorted vs sorted vs radix cluster smaller table unsorted vs radix decluster see text details 
dsm post projection platform leads kb clusters 
radix decluster previous positional join followed radix decluster 
summarizes performance various dsm post projection strategies depending amount projection columns cardinality small cardinalities strategies kind reordering lose simple unsorted processing positional joins columns small fit cache anyway 
larger cardinalities unsorted approach loses big margin factor 
small partial clustered processing beats sorted processing 
gap shrinks growing sorted processing wins 
see radix decluster strategy loses partial cluster strategy quite competitive beating unsorted processing large margin 
explained radix decluster second smaller projection table unsorted processing alternative sorting partial cluster applicable projection table 
comparison join strategies shows comparison dsm post projection radix decluster nsm pre projection dsm pre projection nsm post projection variants radix decluster jive join 
variants cache conscious partitioned hash join vary projection strategy 
show effect cache optimizations include nsm pre projection naive non partitioned hash join nsm pre hash 
analyze impact parameters depicts plots varying parameter keeping fixed 
observed similar behavior experiments different values fixed parameters 
milliseconds milliseconds tlb number radix bits cardinalities plots radix cluster tlb number radix bits cardinalities plots radix decluster milliseconds milliseconds tlb number radix bits unclustered partitioned hash join tlb number radix bits left jive join milliseconds milliseconds tlb number radix bits unclustered clustered positional join tlb number radix bits right jive join 
modeled lines vs measured points performance various join phases dsm shows decreased hit rate strategies cheaper due smaller join result dsm post projection explained decreased impact projection phase relatively expensive radix decluster respect cost creating join index partitioned hash join 
shows strategies scale linearly cardinality 
steeper increase dsm post projection dsm post decluster lower range occurs small cardinalities individual columns fit cache relatively expensive radix decluster necessary indicated point types identify projection method left right table letter codes defined section 
pre projection alternatives systems monetdb dsm forms vertical fragmentation transposed files projection indices scan operator scans columns simultaneously called assemble 
factor consider comparisons dsm post projection cpu efficiency advantage alternatives 
due column time execution monetdb operators zero degree freedom implementation hard coded operation hard coded type executed tight inner loop iterates large arrays 
modern compilers handle code achieving high ipc loop pipelining 
strategies handle projection columns simultaneously tuple time deal degree freedom list projection columns passed run time additionally nsm strategies extract column values nsm record looking record offsets stored table header 
code perform cpu overhead additional complexity dependencies inner loops bound hinder compiler getting ipc 
main difference dsm pre projection dsm pre dsm post projection cpu advantage 
second smaller difference pre projection handles projections time join tuples fit clusters created radix cluster quickly needs multiple passes 
compounded cpu milliseconds nsm pre hash nsm post decluster nsm post jive applies plots number projection attributes impact projectivity milliseconds nsm pre dsm pre applies plots join milliseconds impact join hit rate dsm post decluster left right applies plots cardinality impact cardinality dsm post proj 
vs nsm post proj 
radix decluster jive join vs nsm pre proj 
simple partitioned hash join vs dsm pre proj 
error bars indicate sparse dsm post projection performance join relation resp 
selection larger base table 
disadvantage allowing trade extra cpu better memory access pass radix cluster creating clusters wins leaving strategy bad memory access pattern 
difference dsm pre projection nsm pre projection nsm pre mainly better cache line usage dsm 
positive side projections done radix clustering nsm relations access input relation sequentially 
sparsely pain reduced somewhat automatic memory prefetching modern hardware bandwidth problem 
seen impact considerable low 
big difference nsm pre projection non partitioned partitioned hash join explained performance hit taken random memory access 
projectivity increases naive hash join uses cache lines relatively better approaches partitioned hash join occasion surpasses 
nsm post projection alternatives performance nsm pre projection roughly corresponds phase creation join index nsm post projection strategies 
cost considerable giving radix decluster nsm nsm post decluster jive join nsm hard time competing strategies creating join index step 
subsequently need access wide nsm base tables time performing projections 
course different assumed clustered join index accelerator structure 
concentrate large ad hoc joins precomputed 

join performance jive join sorts join index carries special positional join left jive join join input directly re sorts output table 
generates separate outputs order final result order containing containing projection columns join input 
second phase second special positional join right jive join done cluster oids sorted better access second table results written back order result order oids re sorting 
detailed performance results left right jive join figures show left jive join phase may suffer high cluster fanout way single pass radix cluster right jive join may suffer big clusters partitioned hash join 
strategy creating cluster phase refining radix cluster order big clusters right jive join reordering right jive join random access large cluster 
scalability radix decluster jive join limited wheret tuple width 
large cardinalities wide nsm tuples quickly get algorithms cache problems limiting applicability cache conscious join 
sparse projections sparse projections occur join relation selection base table 
shows performance positional join suffers significantly decreasing selection percentage 
issue dsm nsm dsm cache lines hold values multiple consecutive tuples small percentage milliseconds number radix bits unclustered selectivities 
impact selectivity sparse clustered positional join sequential ram bandwidth utilization decreases 
nsm cache lines typically hold values single tuple bandwidth efficiency mainly depends projectivity selectivity 
need show sequential ram bandwidth generous supply latency shows steady progress hardware evolves 
effect sparse projections dsm post projection shown figures error bars 
smallest error bar shows performance selectivity cardinality underlying base table andthe second corresponds selectivity cardinality 
see dsm post projection performance decreases lower selectivity percentage clearly stays better strategy 
note comparison worst case dsm post projection 
brevity omitted sparse access data nsm affected sparse access lesser degree 
second selectivity low cases intermediate relation small making join easy hard case see section 
easy joins dsm post projection strategy significantly improving performance 
dsm radix decluster nsm dbms results strongly suggest rdbms performance enhanced introducing vertical fragmentation accelerator structure projection indices 
dsm subsystem profit olap queries touch tuples columns preferably cpu efficient monetdb hard coded operators manipulate columns time positional join radix cluster radix decluster 
purpose monetdb cache conscious query processing algorithms restrict random access small ranges fit cpu caches 
access dsm fragments sequential bulk reads writes 
evaluation platform algorithms caused read write rates mb mb supported phase radix decluster fill integer array size values variable tuple length 
clust result clust values efficient fast great fast hashing effective phase radix decluster size values copy tuple correct page offset hdr hdr ash hdr allocated buffer manager pages insert fast page header record offsets page size values strlen great strlen hashing strlen fast insertion window phase sequential pass size values creating incremental sums 
page offset computation page page offset sizeof short clust values sizeof page sizeof hdr sizeof short 
handling non continuous addressing variable sized data pci raid consisting scsi disks 
case dbms mixed dsm nsm storage describes updates accommodated efficiently differential files dsm file images 
architecture buffer manager efficient means controlled asynchronous monetdb columns contiguous arrays rdbms columns stored pages various locations buffer pool 
radix decluster technique inserting position insertion window apply directly 
finding correct page offset especially difficult handle variable sized values strings 
shows problems solved buffer manager uses nsm pages storing sequences variable size values 
output space allocated number buffer pages start addresses stored index array 
radix decluster executed insert values just records lengths variable size values extra integer array 
temporary array course addressable position 
second phase lengths summed calculate locations 
third phase radix decluster operation re executed copy values result time correct page offset value calculated computed location accessible position array 
note fixed size values extra passes necessary page offset determined oid result tuple sequence number 
preliminary experiments lightweight data de compression indicate negligible cpu investment half needed bandwidth problems tpc 
bandwidth precious looks worthwhile approach help scale dsm disk scenarios 
investigated problem performing large equi joins projections cache conscious manner 
seen left graph performance may vary order magnitude different relation projectivity proving projection cost strong impact join efficiency 
main contribution radix decluster algorithm crucial tool monetdb process join re order huge tables access pattern terms cpu cache access access virtual memory 
experiments tested various cache conscious join projection strategies nsm dsm storage schemes 
important experiments partitioned hash join significantly improves performance monetdb dsm nsm pre projection strategy standard rdbms products compare non nsm pre hash nsm pre proving algorithm carries generic merit 
performance evaluation shows radix decluster pivotal making dsm post projection efficient strategy 
note radix cluster radix decluster single pass algorithm scalability limit imposed maximum number clusters tuples 
limit depends cpu cache size quite generous assuming column values kb cache pentium xeon allows project relations half tuples scales quadratically cache size mb itanium cache allows tuples 
limitation explains radix decluster successful nsm post projection scalability inversely quadratically related tuple width 
rephrased positively vertical fragmentation dsm column wise execution reduce tuple width fit tuples cpu cache quadratically improve scalability 
nsm find traditional pre projection technique best outperforming alternative nsm post projection strategy jive join intended generic join method exploiting precomputed join indices 
prospects applying dsm radix decluster shelf rdbms products support case systems combine dsm nsm natively simply add dsm normal nsm representation projection indices show disk systems radix algorithms buffer manager 
ailamaki dewitt hill 
weaving relations cache performance 
proc 
vldb conf pages roma italy sept 
ailamaki dewitt hill wood 
dbmss modern processors time go 
proc 
vldb conf pages edinburgh scotland uk sept 
gharachorloo bugnion 
memory system characterization commercial workloads 
proc 
isca barcelona spain june 
batory 
searching transposed files 
tods 

monet generation dbms kernel query intensive applications 
phd thesis uva amsterdam netherlands may 
kersten :10.1.1.112.263
database architecture optimized new bottleneck memory access 
proc 
vldb conf pages edinburgh scotland uk sept 
copeland khoshafian 
decomposition storage model 
proc 
sigmod conf pages austin tx usa may 
hinton sager boggs 
microarchitecture pentium processor 
intel technology journal developer intel com technology feb 
keeton patterson raphael baker 
performance characterization quad pentium pro smp oltp workloads 
proc 
isca pages barcelona spain june 

ultrasparc iii designing rd generation bit platforms 
ieee micro 
li ross 
fast joins join indices 
vldb journal 

understanding modeling improving main memory database performance 
phd thesis uva amsterdam netherlands dec 
kersten 
generic database cost models hierarchical memory systems 
proc 
vldb conf pages hong kong china aug 
nes kersten :10.1.1.2.2900
cache conscious radix decluster projections 
technical report ins cwi amsterdam netherlands june 
available www cwi nl ins publications 

memory bandwidth machine balance current high performance computers 
ieee technical committee computer architecture newsletter dec 
neil quass 
improved query performance variant indexes 
proc 
sigmod conf pages tucson az usa may 
dewitt su 
case mirrors 
proc 
vldb conf pages hong kong china aug 
kant naughton 
cache conscious algorithms relational query processing 
proc 
vldb conf pages santiago chile sept 
sybase whitepaper 
adaptive server iq july 
www 
sybase 
com content iq wp pdf 
valduriez 
join indices 
acm trans 
database systems june 

