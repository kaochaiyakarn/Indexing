compiling standard ml java simon essay university waterloo fulfilment essay requirement degree master mathematics computer science waterloo ontario canada declare am sole author essay 
authorize university waterloo lend essay institutions individuals purpose scholarly research 
authorize university waterloo reproduce essay photocopying means total part request institutions individuals purpose scholarly research 
ii university waterloo requires signatures persons photocopying essay 
please sign give address date 
iii phenomenal success java programming language stands stark contrast reluctance new languages greeted industry 
java popularity attributed superficial similarity importantly massive proliferation java virtual machine jvm java compiled 
java language significant improvement conventional languages standard ml sml incorporates advanced features offered java parametric polymorphism advanced module system type inference algebraic datatypes offers potentially attractive model internet programming 
document describes compiler dispenses java language compiles sml java virtual machine 
wide availability jvm powerful features sml exploited 
compilation sml jvm runs traditional problems compiling functional languages deal advanced implementation techniques employed including representation analysis normalization closure conversion framework type directed compilation strategy 
result compiler demonstrates feasibility compiling high level typed languages jvm utility advanced compilation techniques 
iv family constant moral mention financial support face frequently changing plans years possible 
professor dominic duggan giving opportunity complete waterloo 
professor peter buhr acting supervisor dominic departure providing valuable feedback essay professors bruce simpson peter forsyth excellent instruction encouragement outside classroom 
friends friendship years stay waterloo worthwhile taught value sum academic courses 
contents overview 
standard ml 
java 
java jvm 
compiler architecture 
front 
ml kit 
lambda 
typed intermediate languages 
ml 
lambda ml rep 
optimization 
representation analysis 
traditional approaches 
coercion approaches 
type passing approaches 
hybrid approaches 
implementation 
type translation 
term translation 
normalization 
continuation passing style normal form 
vi ml norm 
closure conversion 
typed closure conversion 
hoisting 
translation java 
type erasing 
type translation 
basic types 
enumerated types 
record types 
sum types 
arrow types 
type variables 
exception types 
recursive types 
code translation 
polymorphic equality 
wrapping unwrapping 
summary summary 


bibliography vii list figures architecture compiler 
lambda types primitives 
lambda expressions programs 
ml rep kinds constructors types 
ml rep unary operators binary operators coercions 
ml rep declarations misc ops 
ml rep expressions 
ml norm declarations expressions 
ml norm statements misc ops 
ml close kinds constructors types 
ml close declarations misc ops 
ml close expressions statements 
viii chapter programming language research received considerable public attention emergence java programming language 
past new programming languages adopted computing community large 
despite years programming language research design development hundreds languages widespread today lists ada apt cobol common lisp fortran pascal prolog smalltalk 
absent list advanced languages standard ml modula haskell periodically appeared failed achieve success outside academic community 
contrast java embraced programmers academia industry alike short space time 
java key features attractive 
syntactically semantically similar meaning experienced programmers learn java quickly :10.1.1.26.9545
furthermore java addresses serious shortcomings making appealing environments requiring robust secure programs world wide web 

java closely associated virtual machine model java virtual machine jvm compiled 
jvm interpreters widely disseminated components web browsers 
feature crucial means programmers write applications java run millions machines world regard architecture memory model operating system miscellaneous barriers portability 
jvm close universal machine seen years 
despite sudden popularity java language tidy subset small step forward language design deliberately 
languages standard ml sml incorporate advanced features absent java offer attractive programming model better suited task internet programming 
chapter 
real innovation java massive proliferation jvm tempted dispense java language altogether jvm universal machine code 
document describes design implementation compiler adopts precisely strategy compiling subset sml jvm 
idea translating non java languages jvm means novel see example ada jvm compiler kawa scheme java compiler sml features translation particularly challenging 
deal issues number advanced compilation techniques employed including normalization representation analysis closure conversion 
compiler described demonstration feasibility compiling advanced languages jvm exploration implementation techniques languages 
chapter overview chapter provides brief summaries languages involved translation standard ml java presents overview compiler architecture 
standard ml standard ml programming language sml succinctly characterized strongly implicitly polymorphically typed impure strict functional language 
sml foremost functional language encourages functional style programming 
purely functional includes support traditional imperative features convenient cause trouble type system 
sml incorporates advanced features characteristic languages developed years including class functions exception handling algebraic data types types advanced module system including facilities parameterized modules functors claim object oriented 
interesting feature sml possesses formal definition static dynamic semantics form definition standard ml accompanying commentary 
definition amended simplify awkward features original language revised language referred sml 
documents provide compiler implementor precise specification compile time analysis static semantics run time behaviour dynamic semantics sml programs 
guides programming sml range skill levels reader referred comprehensive language overview 
broad familiarity sml assumed document 
chapter 
overview java java programming language scheme lisp cleaned variant retaining flavour original language adding features 
obvious difference java java possess pointer types java instances classes heap allocated instances primitive types int double stack allocated 
java incorporates automatic storage management garbage collection feature notably absent 
java object model slightly different ffl addition traditional classes java introduces notion interface essentially class signature 
ffl permits multiple inheritance java allows single inheritance classes may implement multiple interfaces interface may extension multiple interfaces 
ffl java functions methods classes user definable types classes interfaces java restricts programmer purely object oriented mode operation 
possess formal semantics manner sml definition java static dynamic semantics reasonably defined java language specification 
wide variety java programming guides available reader referred language overview see example familiarity java assumed document 
java jvm compilers traditionally translated source language assembly code target platform native code compilers 
approach attractive standpoint performance result considerable development effort source language relatively high level means compiler customized target architecture 
approach translate source language high level language compiler exists 
approach sacrifices performance reduced development time enhanced portability especially widely language target 
major projects adopted approach including compilers fortran pascal standard ml scheme haskell target language 
compilation jvm fall neatly category jvm nominally machine code relatively high level 
particular includes constructs normally assembly code representation classes interfaces chapter 
overview exceptions lacks non local gotos 
jvm includes different operations different operand types giving somewhat flavour typed language distinct traditional assembly code untyped 
compilation jvm takes character source source translation particular type information preserved traditional source assembly translation 
inspection jvm reveals strongly tied java language 
java language constructs including classes interfaces exceptions map directly jvm constructs making task compiling jvm identical compiling java language 
interests simplicity ease development decided compile sml java existing java compiler compile jvm 
note projects independently adopted strategy reasons 
compiler architecture common compilers sml java compiler structured pipeline stages stage passing results transformation 
sml java compiler comprises stages illustrated 
stage compilation traditional front compiler performing lexical analysis parsing type checking elaboration translation intermediate language lambda typed calculus 
stage translation described chapter 
second stage translates lambda somewhat different calculus ml basis intermediate form transformations 
translation described chapter 
stages perform transformations ml intermediate form 
transformation representation analysis discussed chapter deals issues arising sml polymorphic type system 
transformation discussed chapter distinction expressions statements introduced 
final transformation closure conversion discussed chapter sml class functions nested scope dealt 
final stage compiler translates suitably transformed ml intermediate form java code 
process described chapter 
java code generated compiler compiled run existing java compiler interpreter sun java development kit jdk microsoft visual 
chapter 
overview lambda ml representation analysis closure conversion ml java front sml code java code normalization architecture compiler chapter front compilers traditionally separated front back ends front performs lexical syntactic analysis semantic analysis type checking back responsible code generation 
chapter discusses front sml java compiler 
ml kit lexical syntactic analysis sml area significant complexity sml compilers due small part ambiguous grammar definition :10.1.1.55.9444:10.1.1.17.2744
static semantics contrast understood easily translated practice ml kit system includes literal implementation static semantics definition sml full lexer parser revisit problems solved kit implementors sensible kit front simply implement new back translation java 
approach adopted number projects :10.1.1.27.353
sml java compiler front provided ml kit version perform lexical analysis syntactic analysis elaboration 
benefit kit version includes compiler typed calculus lambda performs patternmatching compilation 
issues type checking pattern matching resolved development sml java compiler focus specific issues related translation java 
version kit includes full interpreter sml dynamic semantics definition small compiler 
version kit region inference includes full region compiler 
chapter 
front lambda ml kit lambda language essentially simplified form syntax sml definition pattern matching reduced simpler constructs 
syntax lambda shown figures 
represents integer real number string type name datatype constructor name ex exception constructor name expression variable ff type variable 
kind variable exists name space 
lambda monotype type variable ff function type instance datatype record type theta delta delta delta theta polytype type scheme oe universally quantified monotype 
type instance ae lists types annotate term variable occurrences construction datatypes 
datatype corresponds sml datatype declaration represents sum type constructors possibly carrying type abstracted set type variables ff ff arity datatype defined number abstracted type variables 
types int real string exn treated arity datatypes constructors essentially types bool treated arity datatype constructors true false list treated arity datatype constructors nil cons 
defines group mutually recursive datatype declarations 
represents datatype declarations lambda program 
lambda primitives include injection selection datatypes con decon particular type instance ae injection selection exception packets construction projection records record dereference construction assignment operations types annotated referred type equality inequality testing operations arithmetic comparison operations overloaded integer real types shown subscripts int real respectively operations strings including concatenation length computation operations including print operation overloaded integers strings booleans reals 
lambda expression term ffl variable annotated instantiating type ffl integer string real constant 
ffl abstraction anonymous function ffl binding ffl recursive function definition fix ffl function application ffl primitive application note primitives fully applied chapter 
front monotypes ff theta delta delta delta theta oe ff ff instances ae datatypes ff ff delta delta delta dg dbs dg dg primitives con ae decon ae ex ex record ref int real abs int abs real floor real exp ln sqrt sin cos arctan xi int xi real mod theta int theta real int real gamma int gamma real int real int real int real int real size chr ord explode open close std output open close std input flush lookahead stream print int print real print bool print string lambda types primitives chapter 
front expressions ae oe fix oe oe exception ex raise handle switch default switch default switch default switch default switch ex ex default frame values oe oe ex ex programs pgm dbs body lambda expressions programs chapter 
front ffl exception declaration induced exception declaration sml ffl exception raised type ffl expression associated exception handler ffl switch integers strings reals data constructors exception constructors optional default clause ffl frame corresponding sml structure definition 
lambda program consists set datatype binding groups defines set mutually recursive datatypes followed expression representing body program 
static semantics dynamic semantics lambda standard 
noted translation sml source lambda performed kit system 
example sml program datatype fun fact fact fact fun foo case 

fun bar exception baz int raise baz val fact val foo translated kit lambda program chapter 
front ff ff hff theta ffi body fix fact int int int switch default theta int fact gamma int fix foo ff ff ff ff switch ff decon ff hff theta ffi decon ff ff ff fix bar int 
int int exception baz int switch 
int true raise int baz false int fact real foo real con real record frame values fact int 
int foo ff ff ff int real typed intermediate languages far problem compilation sml java reduced translating typed calculus lambda java 
type directed compilation approach morrisett employed series typed intermediate languages basis compilation :10.1.1.27.353
type directed compilation fairly innovation programming language research incorporated number advanced compiler development projects 
idea simple retain type information long possible compilation discarding early conventional compilers potential benefits technique seen clearly applied languages advanced type systems sml 
translating strongly typed languages sml java opposed conventional compilation strongly typed language untyped assembly natural types source chapter 
front language preserved translation 
stage type directed compiler conventionally translate source language second order typed calculus harper mitchell xml harper ml shao flint harper stone internal language essentially predicative variants girard system :10.1.1.27.353
examples translations harper mitchell transforming core ml core xml harper stone transforming sml including module system internal language 
ml invent new calculus group variants harper ml intermediate forms type directed translation 
variant ml rep ml kit lambda language translated 
transformations add wrapping unwrapping operations introduce distinction statements exceptions add constructs closure representation 
ml rep comprises kinds constructors types expressions shown figures 
abstraction occurs expression constructor levels language constructors order calculus types kinds ml rep ml rep kinds include ffl ground base kind omega gamma representing basic types integers reals functions records sums exceptions ffl kind constructor functions ffl kind constructor tuples theta delta delta delta theta ml rep constructors include ffl constructor variables ff module projections ffl integer real string enumeration exception constructors int real string enum exn ffl array constructor array note types simulated arrays distinct constructor ffl function disjoint sum tuple record constructors delta delta delta mnm theta delta delta delta theta respectively ffl constructors values type introduce eliminate exception packets discussed chapter 
front ffl constructor tuples note carefully distinction constructor tuples tuple constructors projection ffl constructor abstraction ff ff application ffl recursive constructor definition rec ff ff note ml rep morrisett harper calculus isomorphism recursive type unrolling implicit value rolled unrolled term level discussed ffl constructor binding 
types oe include constructors constrained kind omega gamman polymorphic types ff ff oe export types representing module signatures 
ml rep expressions include ffl variables module projections ffl tuples ffl injections th variant sum type inject ffl integer real enumeration string constants enum respectively ffl declarations binding simple values oe simple constructors ff groups mutually recursive term functions corresponding abstractions groups mutually recursive type functions corresponding abstractions ffl abstractions representing anonymous functions terms applications ffl abstractions representing anonymous functions types applications ffl coercion operations including unroll coercing recursive type unrolled form unrolled form rec ff ff defined ff ff chapter 
front kinds omega theta delta delta delta theta constructors ff int real string exn enum array delta delta delta mnm theta delta delta delta theta ff ff rec ff ff ff types oe ff ff oe export types values oe oe ml rep kinds constructors types chapter 
front unary ops op real floor sqrt sin cos arctan exp ln size gamma abs strlen binary ops op xi theta gamma mod xor 

alloc sub strcat coercion ops roll oe unroll enum int int enum oe ml rep unary operators binary operators coercions declarations oe ff fix oe 
oe mnm mnm oe ff ff 
oe ff ff mnm mnm misc ops extern oe ml rep declarations misc ops chapter 
front expressions inject enum ff ff op op switch mnm mnm default raise oe handle exn export types values ml rep expressions chapter 
front ff ff rec ff ff ff example unrolled form type rec hint theta hint theta rec hint theta roll oe coercing recursive type rolled form note possible rolled forms particular type explicit annotation oe rolled type required enum int coercing enumerated type integer int enum oe coercing integer type enumeration attendant range check ffl unary operations including conversions widening integer real truncating real integer real floor bitwise negation integers square root sqrt reals trigonometric operations sin cos arctan reals hyperbolic operations exp ln reals array size computation size projection th field record unary negation gamma absolute value abs operations integer real types string length computation strlen ffl binary operations including arithmetic operations division xi multiplication theta addition subtraction gamma integers reals modulus mod integers comparison operations integers reals equality comparisons integers reals strings chapter 
front bitwise xor operations integers left right shift operation 

integers array allocation alloc subscripting sub operations exception packet elimination takes arguments type creates exception packet type exn carrying value type takes arguments type exn returns variant sum variant returned exception packet type created counterpart second returned string concatenation strcat ffl miscellaneous operations including array update external native java exception construction creates pair type components introduce eliminate exception packets described polymorphic equality inequality testing type ffl switches integer enumerated sum types switch arms sum types example switch sum type delta delta delta appear switch 
th variant sum th arm switch selected bound value carried ffl exceptions raised type oe raise oe ffl guarded expressions exception handler handle exn bound exception thrown subsequently decomposed operations described ffl module definitions export specifying types values exported module 
chapter 
front lambda ml rep observed description main differences lambda ml rep 
ml rep include explicit datatype type datatypes represented basic constructors enumerations recursive sums 
types passed explicitly ml rep translation lambda ml rep deals issues step transformation representations datatypes lambda program ml rep types selected second expression component lambda program translated ml rep expression 
components dealt turn 
datatype translation datatype translation roughly follows scheme suggested morrisett 
datatype translated follows ffl datatype recursive represented rec constructor body sum constructor 
example sml datatype datatype list nil cons list translated lambda datatype list ff nil cons hff theta ff list turn represented ml rep type ff omega gamma rec list hff theta list list note constructor names erased translation 
note constructor level abstraction capture polymorphic nature datatype 
instances list type int list appear applications constructor function ml rep ffl constructors carry value datatype represented enumerated type 
example sml datatype datatype degree phd translated lambda datatype chapter 
front degree phd turn represented ml rep constructor enum ffl constructor carries value datatype represented directly value type 
example sml datatype datatype foo bar int int translated lambda datatype foo bar hint theta inti turn represented ml rep constructor hint theta inti ffl type recursive constructors carries value lambda datatype represented sum constructor 
example sml datatype datatype int real string translated lambda datatype int real string turn represented ml rep constructor int real string note cases datatype polymorphic representation constructor function ml rep translation morrisett employs specialized representation datatypes constructors carries value datatypes constructors carry values 
representations specifically designed efficient assembly code representation benefit translating java additional complication introduce avoided including ml rep chapter 
front expression translation translation expressions lambda ml rep proceeds manner described harper mitchell tolmach morrisett compiling implicitly typed ml language second order calculus :10.1.1.27.353
main feature translation insert type abstraction abstraction ml rep points code type abstraction occurs generalization fix bound variables type application points mention polymorphic variables 
translation straight forward may 
particular tolmach observes evaluation proceed abstraction computation performed bound expression performed binding point repeated point instantiation bound variable 
potentially inefficient point semantically incorrect bound expression causes side effects 
reason wright value restriction restricts polymorphic abstraction values constants abstractions guaranteed cause side effects adopted 
fortunately sml adopts precisely restriction 
translation expressions proceeds follows ffl lambda variable ae translated application types ae 
ae empty application performed 
ffl lambda constants translated directly ml rep counterparts 
ffl lambda abstraction translated ml rep abstraction 
ffl lambda expression oe translated binding ml rep polymorphic bound abstraction abstracting free type variables abstraction introduced 
ffl translation lambda fix construct binding mutually recursive functions complicated fact fix expression may introduce type abstraction 
assumed abstracted type variables bound functions 
abstracted type variables lambda fix translated ml rep fix construct 
note enforced syntactic level expressions fix binding abstractions lambda 
set abstracted type variables non empty ml rep declaration introduced bound variables bound curried function abstracting type variables second term variables 
appearances bound expressions translated type application abstracted chapter 
front type variables 
say binding ff ff appearance translated application ff 
fairly contrived example sml code fun type ff int theta ff theta ff ff translated lambda fix ff 
int ff ff ff int ff ff switch default gamma int 
turn translated ml rep code ff omega gamma 
int ff ff ff ff omega gamma 
int ff ff switch default ff 
ffl application lambda translated directly application ml rep ffl exception expression lambda exception constructor ex gives rise binding ml rep variable ex type ml rep corresponding constructor pair exception 
lambda primitive exception constructor ex expression form ex translated ml rep operation ex arguments expression form ex 
deconstruction handled similarly sum type resulting decomposed aid switch construct 
ffl lambda raise expression translated directly ml rep raise expression 
ffl handle expression lambda translated corresponding handle construct ml rep note ml rep handler function parameter bound chapter 
front thrown exception lambda handler constrained function exceptions necessarily abstraction se translation lambda ml rep ml rep translation lambda handler function applied variable bound caught exception 
ffl lambda switch construct compiled differently different types index integer variant switch straight forward maps directly ml rep switch expression arm functions take parameters 
real string variants switch switch direct counterpart sml type real longer considered equality type sml value switch construct questionable 
switch translated series comparisons ml rep case switch statements ranging enum boolean types 
datatype switch variant switch presents difficulty translation 
ml rep sum indexed switch arms decompose switch argument implicitly explicit decon primitive achieve effect lambda 
proper translation switch depends type argument switch 
noted lambda datatype may represented number ml rep types translation switch depends ml rep representation argument argument type 
case recursive datatype represented recursive sum type ml rep argument unrolled unroll coercion switch arms handled case sum datatype 
case sum datatype fresh variables generated case sum binding decomposed sum type 
name binding stored translation environment optimization decon encountered arm decomposing switch argument replaced bound name 
case enumeration datatype constructor constructor carries type switch translated manner integer indexed switch switch ex construct translated similarly switch described 
ffl con primitive direct counterpart ml rep code generated ml rep depends representation lambda datatype constructed 
case sum representation appropriate inject expression generated 
case recursive sum representation inject expression rolled roll coercion 
chapter 
front enum representation tag constructor introduced enum constant expression 
single constructor datatype represented argument con translated directly 
ffl decon primitive lambda direct counterpart ml rep translation proceeds described case switch save arms constructor default case raises bind exception 
ffl lambda primitive translated operation ml rep component pair ex translated argument 
ffl primitive translated ml rep switch operation switch ex operating expression 
ffl lambda primitives translated obvious manner cases necessary extract type argument properly annotate ml rep operation operator 
optimization order prevent unnecessary effort subsequent stages compiler series simple optimizations ml rep form performed roughly suggested appel jim 
discussion follows expression defined small variable integer real enumeration constant 
expression defined safe execution cause side effects updating array input output cause exception raised 
conservative approximation safeness property assumed expressions safe function application certain unary binary operations cause updates store cause exceptions raised raise expressions expressions sub expressions safe 
optimizations performed include ffl constructs form optimized chapter 
front construct generated quite frequently ml kit pattern matching compiler optimization highly beneficial 
ffl constructs form optimised 
optimization helps prevent unnecessary closure allocation 
ffl small safe occurs free exactly oe optimized fe xg ffl safe occur free oe optimized optimization amounts dead variable elimination particularly useful conjunction optimization 
ffl small theta delta delta delta theta optimized theta delta delta delta theta fe 
ffl simple constant folding integer arithmetic operations cause overflow performed 
chapter representation analysis software engineering standpoint attractive features sml possesses polymorphic type system 
polymorphism broadly defined property values variables program may type 
languages property type systems degree example operators overloaded perform similar operations different types sml type system permits variables values defined range types usually referred parametric polymorphism distinct ad hoc subtype inclusion polymorphism 
parametric polymorphism allows sml programmer write generic routines operate uniformly range types 
ada address issue generic code providing template generic facilities respectively type checked compiled object code instantiation amount little macro substitution 
flexibility power afforded programmer polymorphic type system penalty 
immediate consequence polymorphic type system actual type object may known run time 
compiling polymorphic code requires types representation code mechanism discovering types representations run time 
consider example operation pairing 
sml polymorphic pairing function written type pair fst snd fun pair fst snd val string pair hello val string fst pair type ff ff ff pair type string pair type string 
consider attempt translate java 
defining pair type chapter 
representation analysis class pair object fst object snd pair object fst object snd fst fst snd snd idea pair consist objects note property type lost replaced weaker property subtypes object 
note number basic types excluded pairing java primitive types int double types subtypes object explored 
fortunately example pairs strings string subtype object 
pairing operation look pair object return new pair pair strings created pair hello difficulty arises selecting field naive approach string fst object subtype string 
result fst cast order perform assignment cost run time type check messy code string string fst noted java distinction primitive types int double boolean stack allocated types classes interfaces heap allocated 
say primitive types types subclasses object 
example code construct pairs types call pair illegal int type subtype object 
heap allocated copy java provided wrapper class integer pair new integer extraction field pair cumbersome chapter 
representation analysis int integer fst intvalue result field selection fst cast integer int extracted method invocation 
java name equivalence types translation polymorphism difficult 
consider example pair string values sml type string theta string natural representation string pairs java class string fst string snd string fst string snd fst fst snd snd expect able objects type general type pair employed particular passed polymorphic functions expecting arguments type ff theta ff 
sensible type subtype follow theta theta case java subtyping relation explicitly indicated example definition changed include extends clause indicating subtype pair 
unfortunately objects type string theta string passed functions arguments type ff theta string string theta ff ff subclass distinct types subclasses clearly impractical 
choice representing string pairs pairs instances pair times introducing coercion pair moving monomorphic polymorphic contexts approaches investigated 
clear naive translation sml code java feasible sophisticated scheme deal imposed java type system adopted 
sections follow number approaches described 
worth noting problems unique translating java 
problems arise compilation assembly code different types occupy different amounts space passed different conventions 
common example floating point numbers larger pointers integers bit versus bit stored special purpose floating point registers 
polymorphic pairing function operates equally floating point numbers types passed boxed floating point number order able operate correctly 
chapter 
representation analysis traditional approaches problem polymorphism essentially polymorphic variable uniform representation regardless actual type 
obvious way achieving property represent values uniformly times done untyped languages lisp scheme 
sensible choice uniform representation single word pointer corresponding types java 
scheme values primitive types int double boxed heap allocated counterparts integer double times unboxed passed native functions addition subtraction 
similarly pair types string theta string adopt uniform representation pair types pair type specialized types 
approach clearly unattractive performance standpoint time integer passed function placed data structure integer object allocated time space unnecessary boxing unboxing occur compiler careful 
casts run time type checks extract fields records pair necessary 
interfacing lower level languages example invoking java api functions sml program difficult lower level languages generally unboxed representations times 
somewhat attractive solution create specific instances polymorphic code instantiation program morrison call textual polymorphism way templates generics ada implemented 
finitely different instantiations polymorphic function program possible generate different code instantiation specialized particular instantiating types 
example specialized versions pairing function operated strings integers created 
approach boxing unboxing unnecessary effectively polymorphism removed program 
potential considerable code duplication 
furthermore separate compilation impossible function module compiled separately application known compile time possible instantiations function 
approach space inefficient non general unattractive 
approaches suggested section roughly correspond homogeneous heterogeneous translations odersky pizza language extends java parametric polymorphism algebraic datatypes high order functions 
heterogeneous translation instantiation polymorphic class source gives rise different class definition target corresponds specialization approach 
homogeneous translation type variables polymorphic datatypes functions replaced type object done pairing example 
approach roughly corresponds uniform representation scheme suggested drawback efficient boxed representations types type polymorphically 
example pizza pair chapter 
representation analysis type declared class pair fst snd pair fst snd fst fst snd snd pair function pair return new pair pair type translated java identically pair object object fields 
field extraction pair object involves cast pair polymorphic context 
furthermore creating pairs non objects pairs int requires wrapping procedure described 
result inefficient representation 
coercion approaches novel coercion approach problem polymorphic code suggested leroy building earlier complementing peyton jones 
peyton jones suggested introducing boxing unboxing operations explicitly intermediate language way algebraic data type exposing conventional optimisation 
introduced key restriction polymorphic functions range boxed types order address shao called problem addressed greater detail 
leroy contribution show transformation unrestricted polymorphism sml peyton jones restricted system 
leroy idea keep objects natural unboxed representation possible objects coerced uniform wrapped representation passed polymorphic functions coerced back natural representation returned polymorphic functions primitive values coerced boxed forms passed native functions traditional untyped approach 
wrapped representation normally boxed form value boxed form value fits single word register may elaborate discussed 
chapter 
representation analysis coercions introduced preserve invariant objects type type variable unknown compile time uniform representation coercion wrap coerces natural specialized representation value type uniform representation unwrap coerces uniform representation specialized representation type polymorphic values polymorphic code guaranteed uniform representation monomorphic code leroy claimed majority realistic sml code leaves values natural efficient representation 
key leroy approach introduce coercions uniform wrapped representation appropriate points code 
sml convenient property polymorphic values program bound variables 
consequence sml appropriate points coercions introduced bound variables applied arguments type schemes instantiated 
leroy scheme works adequately simple types tuples functions difficulty mutable recursive types 
difficulty coercion cases involves creating wrapped copy coerced object 
types coerced copying lose update semantics type resulting unsound translation 
recursive values coerced doing require time space proportional size structure coerced clearly impractical 
leroy solution leave recursive types wrapped times polymorphic code 
representation recursive types widely sml form lists relatively inefficient 
leroy points require recursive types wrapped times 
consider example list function having type ff fi ff theta fi list 
ff list theta fi list 
function called operate lists possible type pair example lists type int theta int list int theta int theta int list 
representation types compatible 
known functions value may passed worst assumed representation lists employed allows list passed contexts requiring ff list ff theta fi list int theta ff list 
restriction components wrapped object wrapped introduced 
recursive wrapping full boxing shao calls detracts considerably simplicity leroy scheme 
interestingly leroy suggested may effective leave objects wrapped state times employ local optimizations reduce cost wrapping employ full fledged coercion approach :10.1.1.135.3242
chapter 
representation analysis type passing approaches approach suggested morrisett pass types run time 
approach program discover object representation inspecting run time representation type 
consequence objects remain unboxed state times 
method attractive cope properly efficiently recursive mutable types leaving natural state arbitrarily requiring recursively boxed times 
disadvantage approach additional time space required constructing passing analyzing type descriptors run time 
shao leroy claimed cost heavy weight run time type analysis considerable 
serious problem may impossible call functions different argument types place shao problem 
java example function takes int argument passed int virtual machine permit object type passed regardless size int additional type information accompanies 
occasion issue morrisett passing floating point values fit general purpose registers morrisett deals ad hoc way wrapping floating point values occur arrays 
problem serious java primitive types problem effectively precludes type passing approach 
hybrid approaches shao suggested flexible representation approach basically amounts hybrid aspects coercion type passing approaches employed 
shao seeks employ coercion approach possible resort type passing necessary product problem dealt reasonably neatly 
shao approach introduces type function wrap maps type boxed form value functions wrap maps value boxed form unwrap performs inverse transformation boxed form natural form 
say wrap type ff omega gamma ff wrap ff unwrap type ff omega gamma wrap ff ff 
note meant wrapped form type deliberately defined strengths shao technique works equally definition wrapping unwrapping satisfy certain basic criteria 
wrapping unwrapping coercions introduced source code manner leroy coercion approach 
second order explicitly typed calculus coercions introduced point type application point mention polymorphic variable leroy technique 
chapter 
representation analysis novelty shao definition wrap unwrap depend extent boxing desired programmer 
shao presents schemes define differing levels boxing types ffl full boxing types boxed recursively 
scheme leroy approach 
ffl simple boxing top layer data structure boxed 
ffl partial boxing similar simple boxing save function arguments results boxed 
attraction simple boxing opposed full boxing coercions required certain circumstances run time analysis types may necessary 
partial boxing eliminates cases run time type analysis necessary 
run time shao approach performed wrap unwrap coercions 
effectively shao approach level method wrap unwrap coercions introduced method leroy second wrap unwrap defined terms boxing unboxing operations 
implementation sml java compiler essentially employs shao approach phase translation order achieve fully boxed representation 
fully boxed representation chosen straight forward implement avoiding altogether need run time type analysis 
sml java compiler takes advantage stage nature shao representation analysis break analysis phases 
stage wrap unwrap coercions wrap constructor added ml rep definition deferred final stage compilation translation java 
permits flexibility choosing representation strategy allows java subclassing method override facilities implement wrapping unwrapping need introducing elaborate typecase operation intermediate form 
note commitment representation stage 
translation wrap unwrap operations discussed detail chapter 
point compiler modest revision ml rep syntax required 
particular constructor wrap denoting wrapped form constructor added new term level operations wrap unwrap coerce terms type wrap types wrap respectively introduced 
chapter 
representation analysis type translation shao transformations types defined oe translating type ml rep unwrapped form oe translating type wrapped form 
oe cases identity operation recursive array types unwrapped representation identical wrapped form copying coercions occur 
consequence unwrapped form constructor array array wrap 
recursive types troublesome translate 
consider lists types monomorphic integer list type usual polymorphic list type 
normally declared sml datatype ilist icons int ilist datatype list nil cons list equivalent ml rep types ilist rec il hint theta il il list ff omega gamma rec hff theta respectively 
ilist instantiation ff particular polymorphic code treat int field type ilist int 
true list polymorphic function type ff omega gamma list ff ff example extract element list treat polymorphic type 
unwrapped form ilist require int field wrapped ff component list wrapped coercion required pass list context requiring object type list ff 
difficulty arises considering sml value type int list type list int ml rep type normalization indistinguishable ilist types normalized impossible determine fields datatype instantiations type variables ff list monomorphic int ilist 
possible determine inspection form unwrapped type take 
problem true type passing approach employed morrisett instantiation polymorphic type monomorphic type run time representation 
type passing approach necessary distinguish cases 
chapter 
representation analysis root problem really ml rep calculus overly eager doing away datatypes type level application 
retrospect may sensible employ simpler calculus retained notion polymorphic datatypes dispensing early compilation 
type passing variant lambda example may suitable 
sufficient avoid type normalization coercions introduced treat type level abstraction defined polymorphic datatype 
possible determine fields unwrapped representation recursive datatypes wrapped abstracted 
term translation shao coercions introduced point type application term translated form applied wrapped types 
coercion types relatively straight forward described detail 
points necessary introduce coercions corresponding elimination forms types ffl roll unroll coercions thought elimination forms recursive types 
certain fields recursive types boxed times unwrapped state necessary introduce coercions roll unroll operations unwrapped unrolled form properly converted wrapped rolled form vice versa 
worth noting ml rep type system task deciding fields rolled difficult necessary 
ffl array elimination forms alloc sub require coercion array elements kept wrapped times 
chapter normalization distinction programming languages expressions compute values statements operate values evaluated side effects 
languages restrict type computations permitted expressions 
traditional imperative languages expressions limited arithmetic logical operations constructs selection iteration generally permitted extreme case assembly code numeric constants variables allowed expressions 
functional languages contrast computations belong universal class expressions 
tasks compiling sml java translating view computations expressions conventional view computations statements operating expressions 
example consider case expression argument function sml fun foo int 
sml code 
val val foo case 


obvious translation java int foo int arg 
java code 
int int interesting note algol distinction statements expressions 
chapter 
normalization foo switch break break default break code syntactically valid switch statement expression java arguments methods expressions 
solution name result switch temporary pass temporary function int foo int arg 
int int temp int switch temp break temp break default temp break foo temp difficulty attributed fact functional languages allow results computations including conditionals remain anonymous conventional imperative languages require computations take form statements modify store order useful essentially results named 
appel observes analogous way early imperative languages allowed arithmetic logical relations anonymous expressions contrast assembly code intermediate arithmetic results named 
problem operations explicit conventional languages storing result statement variable implicit functional ones 
continuation passing style normal form technique employed deal problem transform source program continuation passing style cps 
idea cps transformation control data flow explicit name intermediate results resulting form amenable translation machine code 
cps achieves transforming program control flow takes form tail call 
function passed additional argument continuation computation invokes returning 
useful feature cps transformation intermediate results named program cps chapter 
normalization operates named values constants assembly code 
cps basically formalized assembly code straight forward translate machine code 
cps intermediate forms fruitfully employed number compilers functional languages cps significant drawbacks ffl cps functions return cps function invocations translated assembly code way cause stack growth target language cps translated provide form global jump goto 
ffl naive cps translation introduces administrative abstractions eliminated optimization example fi reduction 
particular case translation java point critical problem 
reasons security jvm permit jumps method consequence java language provide goto construct 
calling mechanism available java method invocation causes stack growth unusable cps tail calls 
restriction rule cps transformation 
second problem general concern addressed flanagan :10.1.1.48.8807
observation performing cps transformation optimization phase required eliminate unnecessary administrative abstractions essentially undoing original cps transformation 
say cps compiler go stages 
cps transformation 
fi normalization 
un cps transformation order produce efficient code 
consequence suggested stages replaced single step transformation normal form 
normal form attractive sml java compiler 
reductions lift redexes evaluation contexts switch lifted invocation foo names intermediate results introducing unnecessary abstractions need optimized away 
reason transformation flavor normalization adopted sml java compiler 
ml norm implementation normalization sml java compiler employs modified version ml rep ml norm distinguishes expressions statements shown figures 
kinds constructors types expressions chapter 
normalization separated categories java separation expressions statements 
note traditional normalization considerably restrictive left expression typically names constants 
fact java permits intermediate results arithmetic logical expressions remain unnamed exploited simplify translation 
target translation jvm java aggressive normalization adopted 
statements allowed places bodies functions declarations arms switch guarded block handle importantly assignment 
feature allows results arbitrary statements named provides way translating statement variable expression representing result statement 
return sub statements bindings interpreted assignment nearest enclosing bound variable 
translation ml rep ml norm takes form continuation passing style algorithm manner linear time algorithm flanagan :10.1.1.48.8807
idea define function normalize ml rep expression continuation mapping expressions statements 
ml rep expressions map ml norm expressions translated applying continuation expression produce ml norm statement 
ml rep expressions map ml norm statements translated generating temporary label statement applying continuation label enclosing resulting statement statement binding variable result statement 
interesting cases translation arise translation switch expressions ml rep example ml rep code foo int int int foo switch default translated foo int int int temp int switch return return default return foo temp note result switch bound temp 
handle expression ml rep statement ml norm similar process 
example ml rep code foo int int bar int int 
int 
foo bar handle exn chapter 
normalization declarations oe ff fix oe 
oe mnm mnm oe ff ff 
oe ff ff mn mnm expressions inject enum ff ff op op ml norm declarations expressions chapter 
normalization misc ops extern oe wrap unwrap statements return switch mnm mnm default raise handle exn ml norm statements misc ops chapter 
normalization foo int int 
bar int int 
int 
temp int return bar handle exn return foo temp putting examples consider ml rep code foo int int int 
bar int int 
int 
foo switch default bar handle exn foo int int int 
bar int int 
int 
temp int switch return return default return temp int bar handle exn foo temp temp note order evaluation switch handle preserved 
chapter closure conversion common feature modern programming languages including sml provision facilities treating functions class objects meaning stored data structures passed parameters just object program 
facilities nesting scope functions functions provided 
conventional languages provide example provides ada provides java provides combination languages sml causes difficulty compilation machine code conventional languages 
restrictions functions included conventional languages order preclude computation closures 
closure pairing piece code environment mapping free variables values 
closures arise combination class functions nested scope create situations variables live lexical scope 
consider sml program example val fn int 
val fn int 
val add val add val add val add returns cases variable needed scope 
deal invocation returns closure consisting code binding free variable invocation returns closure consisting code binding free variable 
resulting functions add add may applied declared chapter 
closure conversion val add val fn int 
val add val fn int 
add add simply treated pointers code case free variables consider 
key phase translation high level languages lower level languages assembly closure conversion representation closures target language chosen 
particular free variable environment function explicit additional parameter free variables replaced indices environment 
closure result applying function environment pairing code data 
similar concept object implementation closures java object described chapter 
typed closure conversion typed closure conversion particular form closure conversion types preserved transformation 
approach particularly useful context sml java compiler type information preserved compilation 
minamide harper morrisett give detailed account typed closure conversion second order typed calculi 
approach employed performing closure conversion ml enriched second order calculus 
ml second order calculus closure conversion account free type variables free term variables type value environments mapping type term level variables types values respectively dealt 
closure conversion implemented transformation ml norm ml close closures environments environment projection introduced primitive constructs calculus shown figures 
term level ml close possesses forms function code vcode tcode corresponding abstraction code type value environments 
expression vcode oe oe defines function constructor environment entries kind value environment entries type oe ranging variables type tcode expression similar save chapter 
closure conversion abstracts type variables 
expression form hhe ii represents closure code expression partially applying constructor environment value environment 
expression denotes projection th component value environment 
binding replaces fix constructs ml norm allowing arbitrary expressions particular closure expressions recursively bound identifiers 
type level types vcode tcode introduced denoting types vcode tcode expressions 
constructor level forms closed code code abstracting constructor environment projection constructor environment constructor closure hh ii representing partial application constructor code environment introduced 
kind code classifies code constructors 
note expression level closure expression arrow polymorphic types ff ff oe depending closes value abstraction object type vcode type abstraction object type tcode 
similarly constructor level closure constructor arrow kind 
closure conversion algorithm translating ml norm ml close essentially follows minamide harper morrisett 
recursive traversal ml norm form performed collecting bindings variables manner type checker 
environments maintained 
mapping non local type variables currently scope kinds delta env 
mapping local type variables currently scope kinds delta arg 
mapping non local term variables currently scope types gamma env 
mapping local term variables currently scope types gamma arg abstraction encountered replaced closure expression hh comprising tcode vcode expression current mapping type variables kinds term variables types type value environments current environment values environment component 
entry abstraction entries local environments shifted non local environments replaced local environments formal parameters abstraction 
optimization cost compile time efficiency compiler abstracts variables free abstraction 
term type variable encountered looked local term resp 
type environment left unchanged 
looked non local term resp 
type environment replaced projection environment 
chapter 
closure conversion kinds omega theta delta delta delta theta code constructors ff int real string exn enum array delta delta delta mnm theta delta delta delta theta wrap rec ff ff ff code ff ff hh ii types oe vcode oe oe tcode oe oe ff ff oe ff ff oe export types values oe oe ml close kinds constructors types chapter 
closure conversion declarations oe ff oe 
oe misc ops extern oe wrap unwrap ml close declarations misc ops note effort perform transformations manner minamide harper morrisett closure representation analysis 
relatively straightforward encode primitive closure operations efficiently java straightforward encoding existential types minamide harper morrisett closure representation described chapter 
example consider sml code val fn int 
fn 
val swap val val 
translated ml rep program int 
int int int 
int swap ff omega gamma fi omega gamma 
hff theta fii hfi theta ffi ff omega gamma fi omega gamma 
hff theta fii int int int 
chapter 
closure conversion expressions inject enum vcode oe oe tcode oe oe ff ff hhe ii op op statements return switch 
mnm mnm default raise handle exn export types values ml close expressions statements chapter 
closure conversion closure conversion removing wrapping unwrapping coercions introduced representation analysis clarity int 
int int int int int ii ii swap ff omega gamma fi omega gamma 
hff theta fii hfi theta ffi ff omega gamma fi omega gamma omega gamma omega gamma omega theta ff fi ii ii int int int 
hoisting having performed closure conversion ml close code convenient property piece code self contained independent enclosing scope 
code may hoisted top level program lexical position place taken variable appropriate type 
transformation useful translating languages java place require code named second require code declared top level scope 
hoisting relatively simple transformation 
vcode tcode expressions identified named moved top level program bound name declarations replaced position appearance generated name 
continue example closure hoisting code code vcode omega gamma omega gamma omega theta theta vcode omega gamma omega gamma omega theta 
code tcode ff omega gamma fi omega gamma 
hff theta fii hff theta fii tcode ff omega gamma fi omega gamma ff fi ii code vcode int int int vcode int int code vcode int 
int int vcode int ii int 
int int ii swap ff omega gamma fi omega gamma 
hff theta fii hfi theta ffi ii int int int 
chapter translation java having dealt issues representation analysis normalization closure conversion actual java code generated ml close intermediate representation 
principal difference ml close java stage restrictive nature java type system 
ml close permits anonymous user defined types admits structural equality types java rigidly requires user defined types named user defined types classes interfaces types usual subtyping rules 
java type system life somewhat simpler class definitions visible java compilation unit thought set mutually recursive class type definitions definition recursive types straight forward order type definitions appear immaterial 
type erasing step translating ml close java perform transformation ml box form 
ml box variant ml close considerably simplified type system 
particular distinction constructors types ml close eliminated furthermore type dispatch ml close say typecase construct style morrisett type functions term level may eliminated changing dynamic semantics program tcode constructs absent ml box 
type abbreviations introduced example rec constructors type variables introduced constructor level abstraction type level abstraction term level abstraction equivalents closure conversion essentially place holders unknown types distinguished point 
representation chapter 
translation java known compile time uniform representation adopted 
consequence instances type variables replaced box constructor may suggestive meaning 
final simplification representation recursive types introduced rec constructor changed sml type 
consequence ml close type list ff omega gamma rec hff theta replaced list ref theta ml box 
translation recursive types considerably simpler 
type translation translation ml box java begins translation simplified ml box types java types 
phase translation creates table distinct types appear ml box program non trivial type java type name 
second phase java code type emitted names assigned phase 
ml box type considered turn 
basic types basic ml box types int real string translated direct counterparts java int double string 
enumerated types lack subrange types java translation enumerated types somewhat optimal 
ml box type enum translated java byte type java boolean type 
java byte types inconvenient byte literals byte values introduced way cast int 
record types record types ml box form translated java class comprising fields appropriate types constructor 
example ml box type hint theta inti translated java code chapter 
translation java class record int int record int int sum types sum types ml box form delta delta delta mnm compiled classes base class comprising int tag field sub classes base classes variant sum 
variant class constructor sets tag field appropriately defines fields appropriate types variant example ml box type int hint theta inti translated java code assuming type hint theta inti java class name record int int class sum int record int tag class sum int record extends sum int record int sum int record int tag class sum int record extends sum int record record sum int record record tag chapter 
translation java arrow types arrow type ml box form represented java class defining method invoke appropriate parameter return types 
code instances particular type defined subclasses arrow type seen 
example ml box type int string int translated java code class arrow int int invoke int arg string arg type variables type variables types unknown compile type appear box ml box represented type java 
type instantiation type variable constrained subclass 
note coercions introduced representation analysis phase compilation guarantee type variables instantiated boxed types subtypes 
may sensible predefined type object represent type variables seen desirable add number methods class 
reasons clear section defined subclass exception 
exception types exception declaration sml gives rise types ml box exception packet type exception constructor type exception type constructor pair 
translation ml box java account types way allow java exception system 
exception packet type simply subclass exception may thrown java programs 
exception packets instantiations type variables subclasses see section 
exception packets subclasses exception 
note java permits single inheritance subclass exception vice versa 
exception core java class position class hierarchy changed particular subclass 
alternative subclass exception exception packets subclasses 
chapter 
translation java way exceptions instantiations type variables throwable exceptions 
peculiarity approach sml type throwable 
treatment exception constructor types somewhat tricky 
interface interface interfaces defining methods respectively defined 
record type fields type interface type interface implements interface interface interfaces defines methods defined 
constructor record assigns fields creating single allocation structure pair constructor constructor 
operations translated simply invocation methods record respectively 
example ml box code int theta inti int 
generates java code assuming sum int java name ml box type int interface int data interface sum int exn class extends int data int data data data class implements int data return new data chapter 
translation java sum int exn exn instanceof return new sum int exn data return new sum int new recursive types noted recursive types represented ml box sml ml box type 
translation type simply requires translation referred type care taken avoid infinitely translating referred types 
code translation closure conversion phase compilation chapter code ffl closed respect free variables ffl hoisted top level named 
code emission java involves identifying top level declarations correspond code segments emitting closure class 
closure class consists fields free variable enclosing environment single invoke method 
class defined subclass appropriate arrow type section 
individual expressions translated directly ml box control flow analysis performed earlier ffl ml box variable translated corresponding java variable 
ml box variable names suitably altered represent valid java identifiers 
chapter 
translation java ffl injection sum types inject translated class instance allocation variant sum type 
ffl integer real string expressions translated integer double string literals java 
ffl enumerated constants type enum translated java byte constants unfortunately introduced indirectly cast integer literal boolean constants 
ffl record creation translated class instance allocation appropriate record class type 
ffl function invocation translated invocation invoke method operand corresponding arguments 
external function java api function invoked directly invoke method 
ffl unary binary expressions translated direct equivalents java exist give rise calls methods java math library certain hand coded java order detect overflow exceptional conditions required sml 
record selection translated accessing appropriate field record object 
ffl environment projection translated field access appropriate environment field 
ffl ml box closure expression hh gives rise class instance allocation closure class referenced operation appropriate environment arguments constructor 
note hoisting guarantees code segment named closure operation named 
translation statements similarly straight forward ffl translation ml box return statement depends current context 
translating binding return translated assignment bound variable 
translating function return translated java return statement 
ffl declaration translation somewhat involved particularly case recursive function definitions 
problem arises essentially recursive environment structure built functions fix refer 
achieved allocating closures functions fix dummy null arguments environment entries functions fix 
closures allocated updated assigning allocated closures environment slots defined function 
example section clarifies procedure 
chapter 
translation java ffl translation switch construct ml box java switch statement causes essentially difficulty translation lambda switch construct ml box switch save reverse ml box switch construct implicitly decomposes argument switching sum types java lambda 
translation integer indexed switches straight forward decomposition performed 
translation enumeration indexed switches depends type argument 
argument type enum switch operating boolean type translated construct java 
switch operating java byte type 
case java lack enumerated subrange types hinders translation requiring switch include default case switch may provably exhaustive 
translation sum indexed switches requires decomposition argument performed 
switch arm selected inspection tag field sum type 
arm translated preamble assigns variables fields appropriate sum arm 
java possess enumeration subrange types default case included simply invokes fatal method pre defined general class signaling internal compiler error 
ffl raise statement ml box translated throw statement java 
ffl handle statement ml box straight forward translate java provides mechanism binding handled exception identifier guise try catch construct manner ml box 
sml code illustrates clearly mutually recursive functions compiled java fun true odd odd false odd val java translation look follows class arrow int bool boolean invoke int arg class extends arrow int boolean chapter 
translation java arrow int boolean arrow int boolean odd arrow int boolean arrow int boolean odd odd odd int invoke int switch case return true default return odd invoke class extends arrow int boolean arrow int boolean arrow int boolean odd arrow int boolean arrow int boolean odd odd odd int invoke int switch case return false default return invoke class main public static void main string args new null null odd new null null chapter 
translation java odd odd odd odd odd odd boolean invoke polymorphic equality issue proved troublesome past implementations sml polymorphic equality 
sml allows certain non trivial types compared equality particular datatypes record types fields equality types may compared just basic types int real string 
adding complexity objects unknown type type type variable known equality types may compared 
number possible approaches exist deal problem 
adopted ml kit generate lambda code comparing equality type defined user 
code course translated java stages considerable cost efficiency compiler legibility intermediate code 
keeping type passing approach morrisett suggests type passing equality function essentially function eq type ff ff ff bool inspects type parameter run time dispatch appropriate code perform actual possibly recursive comparison 
approach attractive requires machinery intermediate form particular typecase construct provided 
issue polymorphic equality dealt java translation stage compilation 
idea essentially class representing sml type subclass define equals method single argument enforced making equals method 
sml java compiler guarantees argument equals method type object method invoked classic deficiency object oriented type systems lacking self types restriction specified java 
penalty lack feature run time cast necessary get object appropriate type comparison 
record types equals method recursively invoked field record 
sum types equals method checks way instanceof test parameter clear desirable compare real values equality 
chapter 
translation java passed variant method class recursive field analysis performed false returned immediately 
exception function types sml admit equality equals methods invoked safeguard invoke fatal method general class 
desirable move code polymorphic equality earlier stage compilation example may exposed optimization felt additional machinery required added considerable complexity compiler comparatively little gain 
wrapping unwrapping noted chapter representation analysis sml java compiler dealt phases 
phase wrap unwrap coercions inserted code appropriate points second wrap unwrap elaborated actual definition terms boxing unboxing 
presentation shao typecase construct define wrapping unwrapping transformations boxing schemes full boxing partial boxing simple boxing 
ml include typecase construct definition wrapping unwrapping transformations deferred point translation java 
stage virtual method invocation achieve essentially effect 
reasons simplicity full boxing approach implemented 
partial boxing efficient execution time requires wrapping unwrapping defined terms un boxing un covering operations 
full boxing contrast defines un wrapping transformation recursive application un boxing 
extent unclear additional benefit partial boxing may require addition virtual method invocations wrapping operation 
full boxing implemented java adding methods subclass method wrap transforms object recursive invocation wrap necessary fully boxed form static method unwrap object type method defined basically specialized java constructor type 
fully boxed form class different type class type extraction time boxed form type defined 
done replacing field record sum exception packet type component type represented heap allocated object 
wrapping operation performs recursive full boxing object creating instance boxed counterpart 
field record sum exception packet recursively wrapped invocation wrap method passed constructor boxed type 
unwrapping reverses procedure type casts required extract actual types types coerced wrapping 
chapter 
translation java full java translation ml box type hint theta inti follows class record record wrap return static record unwrap return record boolean equals record record return equals equals class record int int record int int wrap return new record new new static record unwrap record record chapter 
translation java return new record unwrap unwrap boolean equals record record return chapter summary summary emergence java language virtual machine created unique opportunity development truly portable code 
exploiting potential technologies moment depends java language unfortunately ignoring great wealth programming language research years 
document presents alternative java language jvm vehicle deployment standard ml potentially superior platform internet web development 
compiler demonstrates developments functional language community type directed compilation representation analysis normalization typed closure conversion fruitfully applied realistic compiler implementation 
compiler described document viewed step development true sml jvm compiler 
particular number points require attention 
importantly compiler described implements core sml language address compilation modules 
module compilation jvm raises number important issues especially naming types concerned 
development proper module compiler probably necessary step developing type safe interface java apis example signatures java packages defined 
chapter 
summary 
issue tail recursion elimination addressed 
suggestion versions jvm include constructs proper recursion stack growth languages java typically encourage recursive programming style pressure industry incorporate feature 
sensible investigate strategies resources available example kawa scheme jvm compiler uses jvm local goto instruction perform limited tail recursion elimination strategy employed sml java compiler require re targeting compiler emit jvm bytecode java 
elegant efficient solutions involve jvm example labelled loops conceivable 

sml java compiler currently performs modest optimizations suffers fairly poor performance 
efficient compilation sml requires considerably aggressive optimization competitive languages large body knowledge sml optimization see example tarditi thesis draw 
experience java intermediate form suggest typed languages offer safety reliability considerable extent artificial obstacles compilation 
particular compilation polymorphism java highly troublesome due largely restrictive nature java type system 
lack features enumerated types variable argument functions compilation java difficult necessary 
despite limitations despite difficulties posed java sml java compiler serves demonstrate feasibility compiling high level languages jvm utility advanced compilation techniques 
bibliography mart abadi luca cardelli 
theory objects 
monographs computer science 
springer verlag 
mart abadi luca cardelli 
theory primitive objects untyped order systems 
information computation march 
alfred aho ravi sethi jeffrey ullman 
compilers techniques tools 
addison wesley 
andrew appel 
compiling continuations 
cambridge university press 
andrew appel 
critique standard ml 
journal functional programming october 
andrew appel trevor jim 
continuation passing closure passing style 
sixteenth acm symposium principles programming languages january 
andrew appel trevor jim 
making lambda calculus smaller faster 
technical report cs tr princeton university november 
andrew appel david macqueen 
standard ml new jersey 
technical report cs tr princeton university june 
ken arnold james gosling 
java programming language 
addison wesley 
joel bartlett 
scheme portable scheme compiler 
technical report wrl research report digital western research laboratory january 
lars birkedal nick rothwell mads tofte david turner 
ml kit version 
technical report diku tr university copenhagen march 

kawa compiling scheme java 
available www cygnus com kawa html 
bibliography luca cardelli peter wegner 
understanding types data abstraction polymorphism 
acm computing surveys 
martin elsman 
portable standard ml implementation 
master thesis technical university denmark 
feldman david gay mark 
fortran converter 
technical report computing science technical report bell laboratories march 
cormac flanagan amr sabry bruce duba matthias felleisen :10.1.1.48.8807
essence compiling continuations 
acm sigplan conference programming language design implementation pages june 
dave 
pascal translator version 
available ftp cs caltech edu pub tar jean yves girard yves lafont paul taylor 
proofs types 
number cambridge tracts theoretical computer science 
cambridge university press 
james gosling bill joy guy steele 
java language specification 
addisonwesley 
robert harper john mitchell 
type structure standard ml 
acm transactions programming languages systems november 
robert harper christopher stone 
interpretation standard ml type theory 
technical report cmu cs carnegie mellon university june 
peyton jones launchbury 
unboxed values class citizens pages 
number lecture notes computer science 
springer verlag september 
simon peyton jones cordy hall kevin hammond partain phil 
glasgow haskell compiler technical overview 
proceedings uk joint framework information technology technical conference 
david kranz richard kelsey jonathan rees paul hudak james philbin norman adams 
orbit optimizing compiler scheme 
proceedings acm sigplan symposium compiler construction pages june 
xavier leroy 
efficient data representation polymorphic languages 
research report inria 
bibliography xavier leroy 
unboxed objects polymorphic typing 
proceedings th acm sigplan sigact symposium principles programming languages pages january 
xavier leroy :10.1.1.135.3242
effectiveness type unboxing 
proceedings workshop types compilation june 
tim lindholm frank yellin 
java virtual machine specification 
addisonwesley 
robin milner mads tofte 
commentary standard ml 
mit press 
robin milner mads tofte robert harper 
definition standard ml 
mit press 
robin milner mads tofte robert harper david macqueen 
definition standard ml revised 
mit press 
minamide greg morrisett robert harper 
typed closure conversion 
proceedings rd acm sigplan sigact symposium principles programming languages january 
greg morrisett 
compiling types 
phd thesis carnegie mellon university 
morrison dearle connor brown 
ad hoc approach implementation polymorphism 
acm transactions programming languages systems july 
martin odersky philip 
pizza java translating theory practice 
proceedings th acm sigplan sigact symposium principles programming languages pages january 
paulson 
ml working programmer 
cambridge university press second edition 
jean 
hopl hopl ii years programming language development 
thomas richard gibson editors history programming languages pages 
addison wesley 
zhong shao 
flexible representation analysis 
proceedings acm sigplan conference functional programming 
zhong shao 
overview flint ml compiler 
proceedings acm sigplan workshop types compilation 
bibliography zhong shao andrew appel 
type compiler standard ml 
proceedings acm sigplan conference programming language design implementation pages june 
bjarne stroustrup :10.1.1.26.9545
programming language 
addison wesley second edition 
tucker taft 
programming internet ada 
march 
tarditi morrisett stone harper lee 
til type directed optimizing compiler ml 
proceedings acm sigplan conference programming language design implementation pldi pages may 
david tarditi 
design implementation code optimizations type directed compiler standard ml 
phd thesis carnegie mellon university 
david tarditi anurag acharya peter lee 
assembly required compiling standard ml technical report cmu cs carnegie mellon university november 
mads tofte 
type inference polymorphic 
information computation november 
mads tofte lars birkedal martin elsman niels tommy olesen peter sestoft peter bertelsen 
programming regions ml kit 
technical report diku tr university copenhagen april 
andrew tolmach 
tag free garbage collection explicit type parameters 
acm conference lisp functional programming pages june 
jeffrey ullman 
elements ml programming 
prentice hall 
van wijngaarden peck koster 
report algorithmic language algol 
mathematisch centrum 
van wijngaarden peck koster lindsey meertens editors 
revised report algorithmic language algol 
number mathematical centre tracts 
mathematisch centrum 
david watt brian william 
ada language methodology 
prentice hall 
andrew wright 
polymorphism imperative languages imperative types 
technical report tr rice university february 
