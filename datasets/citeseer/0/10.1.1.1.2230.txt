general flexible access control system web bauer michael schneider edward felten secure internet programming laboratory department computer science princeton university felten cs princeton edu describe design implementation performance new system access control web 
achieve greater flexibility forming policies particular allow better interoperability administrative boundaries base system ideas proof carrying authorization pca 
extend pca notion goals sessions add module system proof language 
access control system possible locate pieces security policy distributed arbitrary hosts 
provide mechanism allows pieces security policy hidden unauthorized clients 
system implemented modules extend standard web server web browser proof carrying authorization control access web pages 
web browser generates proofs mechanically iteratively fetching proof components proof constructed 
provide iterative authorization server require browser prove series challenges 
implementation includes series optimizations speculative proving caching proofs demonstrates goals generality flexibility interoperability compatible reasonable performance 
appeared proceedings th usenix security symposium august 
supported part nsf ccr 
supported fannie john hertz graduate fellow ship 
short period curiosity web quickly important medium discussion commerce business 
holding just information entire world see web pages access email financial records personal proprietary data meant viewed particular individuals groups 
necessary design mechanisms restrict access web pages 
widely mechanism user prompted username password allowed see content page 
web administrator decides certain page visible user enters correct username password pair resides appropriate database file web server 
successful response result client browser cookie visits related web pages cookie accepted proof fact user demonstrated right see pages won challenged prove 
organization university may require people wishing see restricted web page visit centralized login page handles authentication organization web sites 
cookie placed client browser contains information organization web servers verify legitimately issued organization authentication service 
cases functions authentication verifying identity authorization granting access separated distinct processes 
modern methods controlling access web pages separate functions optimization basic element design 
increasingly systems certificate kerberos ticket certificate obtained user band means web browser web server augmented web browser pass certificate web server web server certificate authorize user access certain page 
advantage mechanisms addition providing secure implementations protocols similar basic web authentication possible host different services authorize access token 
organization provide single point authentication access web pages file systems unix servers 
growing increasingly common notably due kerberos new versions windows operating system systems gained wide acceptance 
partly don adequately deal requirements authorization web undeniable advantages may sufficient justify cost 
chief weaknesses systems providing interoperability administrative domains especially different security policies authorization systems 
having centralized authentication server issues user certificate works large number web servers willing trust particular authentication server university example trust absent universities bear benefit 
attempts build systems cross administrative divide problem awaits practical solution 
built system addresses issue design implementation performance results 
system authorization authentication allowing superior interoperation administrative domains expressive security policies 
implementation consists web server module local web proxy 
server allows access pages web browser demonstrate authorized view 
browser local proxy accomplishes mechanically constructing proof challenge sent server 
system supports arbitrarily complex delegation implement framework lets web browser locate pieces security policy delegation statements distributed arbitrary hosts 
system built controlling access web pages relatively easily extended encompass access control applications file systems 
goals design designing system access control web pages criteria wanted address interoperability expressivity ease implementation integration web servers web browsers efficiency convenience user applicability spheres web access control 
interoperability expressivity flexible current systems web access control limited ability interoperate administrative boundaries especially different security policies authorization systems 
main reasons attempt separate functions authorization authentication overwhelmingly continue express security policy definition entities authorized view certain web page terms identities users 
web server isn entity authenticates user identity basing security policy identity difficult provide access users authenticated server administrative domain 
way choose resolve issue making security policy completely general access page described arbitrary predicate 
predicate need linked verification identity particular security policy access people able proof fermat theorem 
facts needed satisfy arbitrary authorization predicate include just verification identity access control system replace authentication servers general fact servers 
scenario problem deciding particular client granted access particular web page general distributed authentication problem solve adapting previously developed techniques field 
distributed authentication systems provide way implementing complex security policies distributed multiple hosts 
methods distributing assembling pieces security policy described logics distributed authentication systems built designing appropriate logic implementing system 
general logics allows expressing widest range security policies introduced appel felten af logic 
af logic higher order logic differs standard ones inclusion rules defining operators lemmas suitable security logic 
higher order logic af logic decidable means decision procedure able determine truth true statement axioms imply 
af logic unsuitable traditional distributed authentication frameworks server set credentials decide access 
problem avoided server making client responsibility generate proofs 
server check proof valid difficult undecidable logic leaving complicated task assembling proof client 
server common underlying af logic check proofs clients regardless method generate proof proof structure 
technique proof carrying authorization pca perfectly satisfies goal interoperability long server bases access control policy af logic interoperation systems different administrative hierarchies difficult interoperation local ones 
convenience implementation important goal web access control system practical implementable modification existing infrastructure web browsers web servers 
access control system involves types players web browsers web servers fact servers issue tokens certify successful authentication ordinary authentication servers type fact store 
enable web browser understand authorization protocol implementing local web proxy 
proxy intercepts browser request protected page executes authorization protocol generate proof needed accessing page web browser sees result page user attempted access appropriate failure message 
user unique cryptographic key held proxy 
users identities established name key certificates stored fact servers 
keys unnecessary prompt user password making authorization process quicker transparent user 
tighter integration browser better performance proxy packaged browser plugin 
portable different plugin written type browser feel scope prototype implementation 
web server part system built unmodified web server 
web server servlet intercepts handles pca related requests 
basic tasks take place server side authorization transaction generating proposition needs proved verifying proof provided client correct 
performed separate component proposition generator checker respectively 
fact servers hold facts client gather construct proof 
fact signed statement af logic 
implement offline utility signing statements lets standard web server fact server 
fact server restrict access facts pub servlet manner web server 
efficiency access control process completely transparent user 
practical efficient 
assembling facts necessary construct proof may involve transactions network 
actual construction proof cryptographic operations done protocol proof checking potential performance bottlenecks 
system prototype production quality performance acceptable practice 
heavy caching limits need fetch multiple facts network speculative proving possible shorten conversation web proxy servlet 
generality best current web authorization mechanisms characteristic limited providing access control web pages strength provide unified method regulates access resources file systems 
system implemented specifically access control web extended manner 
idea proof carrying authorization specific web access control mechanisms develop implemented web proxy servlet easily modified provide access control resources 
implementation section running example alice trying access midterm html describe implementation system detail 
describe part system relevant follow example text indented italicized 
alice request midterm html bob request acl proof request cert 
alice cs challenge registrar cs midterm html cert 
authority registrar 
alice wants read midterm html 
practice caching messages shown unnecessary 
example overview consider scenario 
bob professor teaches cs 
put web page answers midterm exam class just took 
wants access web page restricted students class doesn want web page accessible alice student bob class 
wants access web page server midterm html bob put 
web browser contacts server requests page midterm html 
receiving request server constructs challenge statement logic proven requested url returned 
server returns authorization required message step includes challenge prove server says ok read midterm html alice receives response examines challenge attempts construct proof 
unfortunately attempt fails alice idea go proving ok read midterm html 
sends request server please tell read midterm 
html step 
server reply step tells students cs registrar list may access page long give information construct proof 
contacts registrar step gets certificate asserting semester alice cs step 
information prove alice allowed access file 
proof generated alice sends request midterm html server step 
time includes request challenge proof 
server checks proof valid alice proved correct challenge 
checks succeed server returns requested page step 
logic authorization system proof carrying authorization systems core logic application specific logic defined top 
application specific logic define operators rules useful writing security policies web access control case standard operators says sufficient 
traditional distributed authorization systems operators primitive proof carrying authorization systems operators implemented definitions core logic 
possible system seamlessly administrative domains long share common core logic operators application specific logic regarded merely abbreviations 
operators applicationspecific logic informal definitions encodings af logic 
says principal says statement true 
says formula formula true imply formula says allows principal draw beliefs 
says operator delegation 
principal speaks principal says spoken principal authority 

says says principal new principal created local name space string principal controls says 
example principal registrar creates principal registrar cs signs formula key alice registrar cs student class 
operator break recursion definition 
definition looks complicated true function behaves local name returns true function generates principal authority delegate 
operators explicitly defined obeys set rules require definition somewhat complicated adds complexity proofs lemmas 

says says rules operators proved lemmas transient core logic 
operators defined prove rules states says follows implication says says says imp core logic variant af logic rules appendix 
rules aren standard rules higherorder logic allow reason digital signatures time implication inside says operator 
client proxy server job proxy server intermediary web browser knowledge pca protocol web server 
attempt browser access web page results dialogue proxy server houses page 
dialogue conducted pca enhanced augmented headers allow convey information needed authorization pca protocol 
browser completely unaware dialogue sees web page returned 
alice requests see page server midterm html browser forms request sends local proxy step 
proxy server forwards request modifying step 
secure transmission session identifiers session identifier shared secret client server 
identifier challenges proofs including digitally signed formulas proofs specific single session 
important server caches previously proven challenges allows clients session identifier token demonstrates provided server proof 
session identifier string generated server cryptographic pseudorandom number generator 
implementation uses bit value stored base encoding 
bits chosen value converts evenly base encoding 
session identifier may sufficient gain access resource stealing session identifier akin stealing proof system goals unique compromises security system 
order keep session identifier secret communication client server uses secure protocol https normal cases session identifier sent 
client attempts standard request pca protected page server replies special authorization required message directs client switch https retry request 
alice proxy contacts server asking midterm html 
page pca protected proxy server rejects request 
proxy switches https sends request 
request challenge reply 
challenge 
try prove proved 

purged 
purge assumptions fetch facts done 
client flowchart 
new facts 
fail server proposition generator iterative authorization client attempts access pca protected web page server replies statement theorem wants client prove granting access 
statement proposition generated autonomously depends pathname file client trying access syntax logic encoded 
web browser client server proxy prover fact server server proposition generator provides server list propositions 
server returns client unproven proposition 
client successfully proves proposition subsequent request server reply unproven proposition challenge 
process proving receiving challenge list unproven propositions called iterative authorization 
processes client server shown flowcharts 
process iterative authorization terminates client gives prove propositions successfully proven propositions case access allowed 
client presents proof fails server checks simply discarded 
case challenge returned client twice 
client receives challenge twice knows successfully constructed proof challenge proof rejected server 
means client assumptions incorrect 
client may choose discard assumptions retry proof process 
system generates proposition directory level url specified client request 
ensures client permission access full path just standard access control hierarchical file system 
server returns identical challenges regardless requested object exists returning challenge reveals information existence 
components system 
objects server 
prop 
gen server checker isolating proposition generator rest server easy adapt server applications pca application may require changing proposition generator 
receiving second encrypted request server generates session id sid 
passes request id proposition generator 
proposition generator returns list propositions alice prove allowed see midterm html key server says goal server sid key server says goal server midterm html sid purposes example deal second challenge 
reality alice prove allowed access server try prove allowed access server midterm html 
benefit iterative authorization allows parts security policy hidden unauthorized clients 
challenge proven client able access facts needs prove challenge 
context application means example client prove allowed access directory find goal prove facts gather gain access particular file directory 
generate challenges proof supplied 
challenges 
get challenge proof cached 

server flowchart 
check proof proof ok add cache return requested page return challenge server challenges client proofs authorization request server proposition generator generates list propositions proven access granted 
proposition contains url session identifier 
server checks proposition see previously proven client checking cache previously proven challenges 
propositions proven access allowed immediately 
unproven proposition returned client challenge 
unproven propositions discarded 
server constructs reply status code unauthorized standard response code 
response includes required header field www authenticate authentication scheme pca unproven proposition single parameter 
client constructed proof challenge https request done tcp connection allowed keep alive containing challenge proof 
challenge included authorization request header field proof included series pca proof request header fields 
server checks proof proves supplied challenge adds challenge cache proven propositions begins checking process proposition 
proposition example stating server says ok read server 
server checks proven moves 
remember purposes example re concentrating second proposition authorization process identical 
proposition states server says ok read server midterm html 
hasn proven server constructs response includes proposition challenge sends alice 
step 
client prover course pca conversation server proxy needs generate proofs demonstrate server client allowed access particular file 
task independent rest authorization process convenient separate component 
pca conversation client may need prove multiple statements process proving left prover 
core prover system twelf logical framework 
proofs generated automatically logic program uses tactics 
goal proven encoded statement theorem 
axioms helpful proving theorem added assumptions 
logic program generates derivation theorem proof proxy sends server 
tactics define prover roughly correspond inference rules applicationspecific logic 
algorithm uses tactics comprise decision procedure generates proofs system find proofs true statements decision procedure decidable 
tactic proving find proofs transitivity lemma 
tactics guide search subgoals 
order tactics applied affects effectiveness 
care taken avoid situations tactics guide prover infinite finite time consuming branches don lead proof 
restricted set rules interested prover system able automatically generate proofs exist 
part generating proof goal proxy prover job find assumptions required proof 
assumptions needed generate proof include statements server allowed access particular file statements clock skew statements principals delegate authority principals statements goal 
known proxy provided prover need obtained web pages 
fetching assumptions web relatively time consuming process hundreds milliseconds long time single step interactive authorization transparent user prover caches assumptions 
prover periodically discards assumptions successful proofs 
client iterative proving client responsible proof generation 
client may able generate proof challenge try 
may need obtain additional information signed delegations facts proof completed 
process fetching additional information retrying proof process called iterative proving 
process affect server terminates proof successfully generated 
proof generation divided phases 
phase facts gathered 
second phase straightforward prover rules test facts sufficient prove challenge 
proof returned 
phases repeated gathering additional facts proof successfully generated new facts 
fact gathering phase involves client gathering basic types facts 
self signed assumptions type facts comes client 
client sign statements private key may useful constructing proofs 
example necessary client sign part challenge assumption proof 
alice sign statement goal server midterm html sid applying signature axiom statement yield key alice says goal server midterm html sid armed assumption far alice tries prove challenge 
attempt fails client proof constructed sent server alice realizes assumption isn sufficient generate proof tries collect facts 
steps 
goal oriented facts second type facts typically necessarily provided web server 
generating propositions checking proofs conceptually main parts server side infrastructure pca enabled server may want carry number tasks 
managing pieces security policy 
generate proof authorized access particular web page client know principals access 
information describes principals direct access particular goal call goal oriented facts 
implementation server keeps information access control lists 
entries lists encoded manner suitable assumptions provided client demand 
indiscriminately 
providing goal oriented fact server uses additional pca exchange check client authorized access fact 
system client queries server facts challenge needs prove 
goals described urls server requires pca authorization directory return goal oriented facts describe access files directories inside directory 
goal oriented fact describes access root directory freely returned client 
way client forced iteratively prove authorization directory level server 
attempt generating proof didn succeed alice sends message server requesting goal oriented facts server midterm html 
receiving request server checks alice demonstrated access server 
generating list assumptions single assumption list checking alice proven 
determining alice allowed access root directory server gives alice signed version statement server imp key registrar cs says goal server midterm html sig imp goal server midterm html sig alice translates server says cs student says ok read midterm html ok read midterm html fetching acl entry server described steps 
server time order generate proofs include expiring statements client guess server clock 
third type facts client guess time showing server clock instant proof checking 
client incorrect guess successfully generate proof rejected server 
incorrect guess server clock reason rejecting properly formed proof fact server accept 
case client adjusts guess server clock begins proof generation process 
order goal oriented assumption received server alice know current time 
clock guesses server believes time corresponds assumption server server armed self signed assumption assumption assumption time alice tries proving access midterm html 
discovers doesn facts construct proof 
knows registrar cs access file doesn know extend access privilege 
key oriented facts fourth type facts come hints embedded keys enable facts stored separate centralized distributed server 
concatenated public key list urls may contain facts relevant key 
fact fetching step client examines keys referenced facts fetched 
key examined embedded hints 
client fetches new facts hint urls 
needed new facts examined additional hint urls fetched process continue needed facts 
way client breadth search new facts alternating searching additional depth level attempting construct proof current set facts 
proof didn succeed alice hints facts try find additional facts help proof 
bob server key registrar key embedded facts alice collected 
key encoded url describes location owner key publishes additional facts 
bob server key heretofore key server form key server server hints 
giving alice prover follows urls see find new facts help 
shown step 
hint registrar key alice downloads signed statement translates assumption key registrar says registrar semester imp key alice key registrar cs fact delegates alice right speak behalf registrar cs registrar says semester alice says weight registrar cs said hint bob server key alice obtains new fact tells clock skew bob server registrar 
alice facts generate proof demonstrates authorized read server midterm html 
alice final request access server midterm 
html time including full proof 
server proof checking theory 
learns proposition prove client generates proof sends server 
proof correct server allows client access requested web page 
proofs checked twelf 
proof provided client encoded lf term 
type programming languages sense term statement proof body term proof derivation 
checking derivation correct amounts type checking term represents proof 
term typed client succeeded proving proposition 
case client twelf proof checking overkill type checking algorithm 
proof checker part trusted computing base system 
minimize likelihood contains bugs compromise security small simple possible 
minimal lf type checkers shortly implemented serve proof checker system 
lf terms explicit type implicitly typed 
explicitly typed version may need introduce type annotation variable lead exponential increase size proofs 
implicitly typed version concise suffers different problem type inference algorithm server need run undecidable cause correct proofs accepted server tied complicated proof 
lf community currently developing type checker semi explicitly typed lf terms solve problems 
type inference algorithm decidable level type ascription require cause exponential code blowup 
available system require proofs explicitly typed 
practice 
checking proof provided client quite simple just passing lf type checker 
body lf term proof proposition represented type 
term type ascription body represents axiom 
axiom may type check mean want allow part proof 
client respond challenge sending axiom asserted proposition needed prove obviously wouldn want accept statement proof challenge 
addition server verify digital signatures sent proof 
solve problems server preprocesses client proof passing type checker 
preprocessor sure terms proof type body 
proof contains illegal axioms rejected 
special types axioms inserted proof necessary 
type propositions digital signatures second type propositions regarding time 
required proof checker check digital signatures time statements directly 
client inserts proof place holders types axioms 
server sure axiom holds generates lf declaration represents replaces placeholder declaration 
digital signatures client inserts proof proposition special form signature key formula sig 
server checks sig valid signature key key formula formula 
signature statement replaced axiom asserting key signed formula 
statements time client inserts proposition special form 
preprocessing stage replaces axiom asserting current time 
axioms form necessary signed propositions include expiration date example 
proof parsed sure contains axioms special axioms forms reintroduced proof checked sure proves challenge 
proof perfectly valid proof challenge 
final check succeeds proof passed lf type checker case twelf 
checks succeed challenge inserted server cache proven propositions 
server allow access page challenge server list return challenge client 
server receives alice request midterm 
html generates list propositions need proven access granted 
proposition unproven proof included alice request 
server expands signature propositions sends proof type checker 
proof checks successfully server inserts cache alice won prove proposition 
server checks alice proved correct challenge 
propositions left proven alice successfully proven authorized read server midterm html 
server sends requested page alice 
optimizations performance results caching modularity authorization protocol involves number potentially lengthy operations transferring data network verifying proofs 
caching client server alleviate performance penalty operations 
client side inevitable side effects security policy distributed multiple hosts client communicate 
delegation statements security policy may force communication happen sequentially client fetch piece data discover needs 
little done improve worstcase scenario series sequential fetches network subsequent fetches facts eliminated caching client 
facts reside cache may expire easy client check valid checked removed cache band proof generation process 
server side avoid re checking proofs correctly proven propositions cached 
may time dependent premises correct checked false 
proofs retransmitted cache premises checked authorization accepted 
proofs kept cached long session id associated kept alive 
proofs sparse basic core logic re need lemmas definitions expressing proofs concise way 
clients lemmas proofs proofs fact include basic set lemmas 
added proof language simple module system allows lemmas individual proofs 
having include lemmas proof module system allows imported statement include server lemmas elf 
lemma trans example resides module referenced body proof trans 
managed individually client abstracting lemmas modules allows maintained published third party 
instance maintain single set lemmas employees import trying prove allowed access payroll records 
examples previous section understandable omitted modules 
reality proof sent client server prefixed include statement module contained definitions example says lemmas manipulate basic lemmas 
aside administrative advantages important practical benefit abstracting lemmas modules increased efficiency bandwidth consumed proof transmission resources expended proof checking 
transmitting proof thousands lines lemmas client merely inserts include declaration tells checker url currently support modules accessible module containing lemmas 
proof transmitted client server label module imported modified contains hash semantic content hash somewhat independent variable names formatting imported module 
way checker knows find module verify prover checker agree contents 
checker processing proof encounters include statement checks module url imported 
hash previously imported module matches hash proof proof checking continues normally proof readily lemmas declared imported module 
hashes match module hasn imported checker accesses url fetches module 
module imported validated checker way proof 
re identified content hashes multiple versions module url coexist checker cache 
checker takes appropriate precautions guard proofs may contain modules endlessly import modules cyclical import statements similar attacks 
speculative proving running example web proxy waited server challenge began process constructing proof 
practice proxy keeps track visited web pages protected pca 
log proxy tries guess sends data page user trying access pca protected server challenge 
case try prove challenge server call prove ahead speculative proving 
proof sent server part original request 
client guessed correctly server accept proof sending challenge client 
web proxy facts necessary constructing proof reduce amount communication network single round trip client server 
single round trip necessary case just fetch requested web page words proof piggybacked top fetch message 
performance numbers protocol stage ms fetch url attempt https fetch url attempt proof failed proof attempt fetch file fact failed proof attempt fetch key fact successful proof attempt fetch url attempt empty server cache failed proof attempt fetch file fact successful proof attempt fetch url attempt server cached module total 
worst case performance 
protocol stage ms fetch url attempt proof failed proof attempt fetch file fact successful proof attempt fetch url attempt server cached module total 
typical performance 
expect performance system varies greatly depending information protocol stage ms construct proof cached facts fetch url attempt server cached module total 
fully cached performance 
protocol stage ms fetch url attempt authorized total 
performance valid session id cached proxy server 
relevant metric amount time takes fetch protected web page 
evaluated system example alice trying access midterm html see figures comparison shows length time fetch page protected actual example obtained performance data include facts time 
slowest scenario detailed caches empty attempt fetch protected page incurs initialization overhead server attempt fetch url takes long proof isn included 
case takes seconds proxy fetch necessary facts construct proof fetch desired page 
typical situation user attempts access protected page previously visited site 
case user proven server allowed access server directory prove allowed access requested page 
case probably needs fetch single file goal fact process takes second 
speculative proving eliminate overhead attempted fetch protected page proof saving seconds 
client knows file fact length access cut seconds 
user wants access page accessed session identifier dur protocol stage ms fetch url attempt page protected total 
access control turned 
ing previous successful attempt valid access granted just possession identifier takes milliseconds 
alice proof complicated example example contain chain delegations 
link chain alice discover couldn construct proof fetch relevant fact attempt construct proof system currently take seconds 
performance results show facts assembled generating proofs slow ms grows slower user learns facts 
fundamental bottleneck performance prover order magnitude slower need 
production strength implementation implemented theorem prover java 
capabilities twelf far greater need impose severe performance penalty custom theorem prover required functionality lightweight 
impacts proof checking performance specialized checker faster 
describe authorization system web browsers web servers solves problem interoperability administrative trust boundaries allowing arbitrarily complex security policies 
system implemented add modules standard web browsers web servers demonstrates feasible proof carrying authorization framework basis building real systems 
improve previous proof carrying authorization adding framework notion state enhancing pca logic goal constructs module system 
additions state call sessions goals instrumental making pca practical 
introduce mechanisms allow servers provide selective access security policies concept wholly absent original 
addition refine core logic useful expressing interesting application specific logics define particular application specific logic capable serving security logic real distributed authorization system 
application allows pieces security policy distributed arbitrary hosts 
process iterative proving client repeatedly fetches proof components able construct proof 
mechanism allows server policy arbitrarily complex controlled large number principals spread arbitrary network machines secure way 
proof components protected system avoids releasing entire security policy unauthorized clients 
iterative authorization allowing server repeatedly challenge client new challenges single authorization transaction provides great deal flexibility designing security policies 
performance results demonstrate possible reduce inherent overhead level system efficient real 
system uses speculative proving clients attempt guess server challenges generate proofs ahead time drastically reducing exchange client server 
client caches proofs proof components avoid expense fetching regenerating proofs 
server caches proofs avoids need client produce proof time tries access particular object 
module system proof language allows shared lemmas comprise bulk proofs transmitted server processed saving bandwidth overhead 
ongoing includes investigating oblivious transfer protocols fetching proof components revealing unnecessary information refining security logic reduce trusted base increase generality 
addition allowing clients import lemmas third party devise method allowing import actual proof rules 
exploring idea higherorder logic bridge existing non higherorder security logics way enable authentication frameworks different logics interact share resources 
intend significantly improve performance system particular specialized prover proof checker 
acknowledgments authors andrew appel advice anonymous reviewers helpful comments 
availability information system authorization including downloadable version prototype implementation available www cs princeton edu sip projects pca 
abadi 
sdsi linked local name spaces 
journal computer security october 
abadi burrows lampson plotkin 
calculus access control distributed systems 
acm transactions programming languages systems september 
abadi wobber burrows lampson 
authentication taos operating system 
proceedings th acm symposium operating system principles pages systems research center src dec dec 
acm sigops acm press 
proceedings acm operating systems review 
appel felten 
proof carrying authentication 
proceedings th acm conference computer communications security singapore november 
balfanz dean spreitzer 
security infrastructure distributed java applications 
th ieee computer society symposium research security privacy oakland ca may 
blaze feigenbaum strauss 
compliance checking policymaker system 
proceedings nd financial crypto conference volume lecture notes computer science berlin 
springer 


certificate discovery spki sdsi certificates 
master thesis massachusetts institute technology may 
ellison lampson rivest thomas 
spki certificate theory september 
rfc 
erdos cantor 
architecture draft 
middleware internet edu docs nov 
fielding gettys mogul frystyk masinter leach berners lee 
hypertext transfer protocol 
ietf network working group internet society june 
rfc 
fu sit smith feamster 
dos don ts client authentication web 
proceedings th usenix security symposium washington dc aug 
halpern van der meyden 
logic sdsi linked local name spaces 
proceedings th ieee computer security foundations workshop pages italy june 
harper honsell plotkin 
framework defining logics 
journal association computing machinery jan 
international telecommunications union 
itu recommendation directory authentication framework 
technical report itu 
honeyman coffman 
credential translation solution web access control 
proceedings th usenix security symposium washington dc aug 
necula 
compiling proofs 
phd thesis carnegie mellon university oct 
available technical report cmu cs 
neuman ts kerberos authentication service computer networks 
ieee communications sept 
pfenning sch rmann 
system description twelf meta logical framework deductive systems 
ganzinger editor proceedings th international conference automated deduction cade volume lnai pages berlin july 
springer 
samar 
single sign cookies web applications 
proceedings th ieee workshop enabling technologies infrastructure collaborative enterprises pages palo alto ca 
stump barrett dill 
cvc cooperating validity checker 
submitted th conference computer aided verification 
stump dill 
faster proof checking edinburgh logical framework 
th international conference automated deduction 
axioms core logic axioms higher order core logic pca system 
standard inference rules higher order logic 
imp occurring forall imp refl congr signature pubkey sig key pubkey says key says imp key says key says key localhost says signed gt forall key imp 
