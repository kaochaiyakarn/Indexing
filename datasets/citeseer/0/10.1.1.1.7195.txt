acm conference object oriented programming systems languages applications oopsla october lazy modular upgrades persistent object stores chandrasekhar boyapati barbara liskov shrira chuang hue moh steven richman mit computer science artificial intelligence laboratory technology square cambridge ma liskov lcs mit edu persistent object stores require way automatically upgrade persistent objects change code storage representation 
automatic upgrades challenge systems 
upgrades performed way cient space time application access store 
addition approach modular allow programmers reason locally correctness upgrades similar way reason regular code 
provides solutions problems 
rst de nes upgrade modularity conditions upgrade system satisfy support local reasoning upgrades 
describes new approach executing upgrades eciently satisfying upgrade modularity conditions 
approach exploits object encapsulation properties novel way 
describes prototype implementation shows upgrade system imposes small overhead application performance 
categories subject descriptors software engineering maintenance enhancement software engineering program veri cation programming languages language constructs general terms design veri cation languages keywords software upgrades objects ownership types shrira address department computer science brandeis university waltham ma 
research supported part darpa contract nsf iis ntt 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla october anaheim california usa 
copyright acm concerned providing ecient automatic upgrades objects persistent object store 
persistent object stores provide simple powerful programming model allows applications store objects reliably shared applications 
store acts extension objectoriented programming language java allowing programs access long lived objects manner analogous manipulate ordinary objects lifetime determined program 
persistent objects may live long time may need upgrade change code storage representation 
upgrade improve object implementation correct errors change interface face changing application requirements 
providing satisfactory way upgrading objects persistent object store long standing challenge 
natural way de ne upgrades programmers provide transform function class objects need upgraded :10.1.1.11.1440
transform function initializes new form object current state 
system carries upgrade transform functions transform objects classes replaced 
way handling upgrades introduces problems 
system provide semantics programmers reason transform functions locally making easy design correct upgrades 

system run upgrades eciently space time 
provides solutions problems 
rst introduces set upgrade modularity conditions constrain behavior upgrade system 
upgrade system satis es conditions guarantees transform function runs encounters object interfaces invariants existed upgrade de ned 
conditions allow transform functions de ned modularly transform function considered extra method class replaced reasoned rest class 
natural assumption programmers implicitly upgrade system conditions provide grounding assumption 
way upgrade system provides semantics programmers design upgrades 
describes ecient way executing upgrades satisfying upgrade modularity conditions 
previous approaches provide satisfactory solution problem 
upgrade system satisfy conditions keeping old versions objects old versions preserve old interfaces old object states 
versions expensive practical upgrade system avoid time 
earlier systems avoid versions severely limiting expressive power upgrades transform functions allowed method calls limit number versions world approach shuts system upgrade discards versions upgrade complete satisfy upgrade modularity conditions enable programmers reason upgrades locally :10.1.1.11.1440
approach provides ecient solution problem 
perform upgrades lazily don prevent application access persistent objects stopping world transform objects just accessed application 
requiring versions time 
impose limitations expressive power transform functions 
provide semantics upgrade system satis es upgrade modularity conditions supports local reasoning 
approach exploits fact transform functions behaved access object transformed encapsulated subobjects 
transform functions behaved runtime system provides ecient way enforce upgrade modularity conditions maintaining versions 
aren provide additional mechanism triggers control order transform functions satisfy conditions 
triggers insucient versions cases needed 
determining transform function behaved straightforward understanding encapsulation 
programmers informal reasoning check property 
alternatively compiler ensure property static checking provided programming language extended support ownership types sketch extension appendix :10.1.1.11.1440:10.1.1.11.1440:10.1.1.23.2115:10.1.1.59.6498:10.1.1.59.6498:10.1.1.1.5802:10.1.1.1.5802
ownership types er promising approach making objectoriented programs reliable may part object oriented languages 
implemented prototype lazy modular upgrade infrastructure thor highly optimized objectoriented database 
describes prototype discusses design trade optimize performance common case 
presents performance results indicate infrastructure low cost 
negligible impact applications objects need upgraded 
expect common case upgrades rare week day 
results show upgrades needed overhead transforming object small 
organized follows 
section presents upgrade modularity conditions 
section describes system executes upgrades 
section shows system satis es upgrade modularity conditions 
section describes implementation section presents performance results 
section discusses related 
section concludes 
appendix describes ownership types check statically transform functions behaved 
semantics upgrades section describes upgrade model 
de nes upgrade modularity conditions explains easy programmers reason upgrades 
system model assume persistent object store object oriented database contains conventional objects similar nd object oriented programming language java 
objects refer interact calling methods 
objects belong classes de ne representation methods 
class implements type 
types arranged hierarchy 
type subtype types 
class implements type implements supertypes type 
assume applications access persistent objects atomic transactions necessary ensure consistency stored objects transactions allow concurrent access mask failures 
application transaction consists calls methods persistent objects local computation 
transaction terminates committing aborting 
commit succeeds changes persistent 
transaction aborts changes ect persistent objects 
upgrades persistent object store improve object implementation run faster correct error 
extend object interface providing additional methods change object interface incompatible way object longer behaves removing methods rede ning method 
incompatible upgrades probably common important face changing application requirements 
de ning upgrades upgrade de ned describing happen classes need changed 
information class changing captured class upgrade 
class upgrade tuple hold class new class tfi class upgrade indicates objects belonging transformed transform function tf objects new class 
tf takes old class object newly allocated new class object initializes new class object old class object 
upgrade system causes new class object take identity old class object objects refer old class object refer new class object 
mechanism preserves object state identity 
preservation crucial point persistent store maintain object state 
objects upgraded state survive albeit modi ed form needed new class 
furthermore great deal object state captured web object relationships 
information expressed having objects refer objects 
object upgraded retain identity objects referred prior upgrade refer 
upgrade set class upgrades 
upgrade changes interface class objects longer behave may ect classes including subclasses classes types longer implements 
ected classes upgraded new system remains type correct 
complete upgrade contains class upgrades classes need change due class upgrade upgrade :10.1.1.11.1440
completeness checked rules analogous type checking 
system accepts upgrade complete 
point say upgrade installed 
upgrade installed ready run 
upgrade executed running transform functions ected objects objects belonging old classes 
upgrade modularity conditions mentioned upgrade system guarantee transform function runs encounters interfaces existed time upgrade installed states satisfy object invariants 
guarantee means transform function writer need concerned reasoning correctness upgrades object interfaces object invariants existed past exist 
transform function thought extra method old class writer assume invariants interfaces assumed methods 
job upgrade system run upgrades way supports modularity property 
different problems solved 
question order upgrades relative application transactions upgrades 
second issue order transform functions belonging single upgrade 
ordering upgrades requirement ordering entire upgrades simple upgrades transactions serialized relative application transactions upgrade appear run earlier 
upgrade transaction transforms objects old classes 
view transform function running transaction transform transaction execution transform function object 
entire upgrade transaction consists execution transform transactions upgrade 
state serializability requirement 
similar condition :10.1.1.11.1440
notation mean ran :10.1.1.11.1440

tf application transaction serialized tf upgrade installed transform function upgrade ect tf 
upgrade system stops world run upgrade transaction allows application transactions continue transaction completes satis es condition trivially order tf won occur application transactions upgrades 
upgrade system doesn world ensure runs transform serialized ect ran opposite order 
order upgrades condition says upgrade system chooses ordering transforms upgrade 
conditions constrain order 

tf tf upgrade tf transitively uses tf tf ect tf tf 

tf tf upgrade tf transitively tf transitively tf tf ect tf tf 
tf uses tf reads writes eld calls method transitively uses means action may occur uses intermediate objects tf calls method calls method condition states transform function tf uses object behavior system tf ran tf 
condition states unrelated objects behavior system independent order transforms ran case upgrade system choose order wants transforms 
upgrade systems satisfy condition versions tf runs sees old version approach taken 
avoid problem altogether limiting expressive power transforms method calls 
third possibility direction follow satisfy controlling order transforms tf uses transformed conditions ensure upgrade modularity transform functions encounter expected interfaces object invariants upgrades run upgrade order application transactions interfere transform functions transform functions unrelated objects interfere transform functions related objects appear run pre determined order object appears transformed subobjects 
conditions allow transform functions reasoned locally extra methods old classes 
writers transform functions assume invariants interfaces assumed methods old classes 
executing upgrades section describes lazy upgrade system 
stopping world run upgrade undesirable system unavailable applications long time 
system avoids delaying applications running upgrade incrementally just time 
system runs transform function individual transaction 
transactions interleaved application transactions 
application transaction object due transformed system interrupts runs transform function point way ensure application transactions observe untransformed objects 
transform transaction serialized commit order uses transformed object initialized reads modi es object modi ed modi es object read system aborts highly abort discuss techniques avoid having abort sections 
nishes executing commits 
system continues running aborted system require earlier upgrade complete upgrade starts delay upgrade long time 
upgrades progress transforms may pending object 
system runs pending transforms object upgrade order 
running transform transaction system encounter object pending transforms upgrades earlier de ned case system interrupts just interrupted run pending transforms 
enforcing modularity conditions lazy approach described section ensures transforms individual objects run upgrade order applications running upgrade observe objects need transformed 
enforce upgrade modularity conditions discussed section provide desired semantics allow programmers reason locally transform functions 
example possible application transaction stack object encapsulated linked list object encapsulation hierarchy uses object causing transformed changing interface uses tf runs uses encounters unexpected interface 
system provide semantics prevent kind occurrence 
approach object encapsulation 
object encapsulation important object oriented program gives programmers ability reason locally program correctness 
upgrade system object encapsulation provides additional bene allows system support upgrade modularity conditions needing versions 
object encapsulation reasoning class object oriented program involves reasoning behavior objects belonging class 
typically objects point subobjects represent containing object 
local reasoning class correctness easy subobjects encapsulated subobjects accessible containing object 
condition supports local reasoning ensures outside objects interact subobjects calling methods containing object 
containing object control subobjects 
encapsulation subobjects needed local reasoning 
encapsulation required subobjects containing object depends object depends subobject reads writes elds calls methods furthermore reads writes calls expose mutable behavior way ects invariants stack implemented linked list depends list items contained list 
code outside manipulate list invalidate correctness stack implementation 
code outside safely items contained stack stack doesn call methods depends identities items identities change 
similarly set depend elements invokes equals ensure elements set equal provided elements immutable 
general object encapsulate objects directly transitively depends object encapsulates object maintains encapsulation boundary object encapsulates inside boundary furthermore outside boundary access 
object accesses object pointer methods obtain pointer 
shows stack object implemented linked list 
nodes linked list encapsulated stack object outside objects directly access list nodes 
items stored stack encapsulated stack object 
encapsulation relation forms hierarchy 
shows example objects encapsulated object encapsulated object encapsulated 
encapsulation upgrades encapsulation facilitates modular upgrades system imposes order transforms 
encapsulated applications access transformed means tf runs see proper interface tf accesses object referred directly indirectly encapsulated encounter unexpected interface state 
system provides semantics versions transforms don 
transforms satisfy condition tf uses objects encapsulates 
say transforms behaved 
condition checked informal reasoning understanding encapsulation boundaries 
understanding boundaries fundamental part establishing correctness classes general correctness requires object depended encapsulated 
asking programmer done 
checking condition onerous programmer viewing transform extra method old class 
reasonably simple programmer determine holds 
manual checks avoided programming language extended support ownership types case checking done compiler 
ownership types declare dependencies object depends class declare owns ownership type system guarantee accessed outside objects doesn directly transitively :10.1.1.11.1440:10.1.1.11.1440:10.1.1.11.1440:10.1.1.23.2115:10.1.1.59.6498:10.1.1.59.6498:10.1.1.1.5802:10.1.1.1.5802
ownership types combined ects clauses allow compiler track objects transforms 
de ned extension java supports ownership types effects clauses include brief overview type system appendix :10.1.1.11.1440:10.1.1.11.1440
system place compiler check condition compile time 
ensuring upgrade modularity section shows system ensure conditions assuming condition holds tfs 
object ected upgrade system guarantees accessed object encapsulated system ensures conditions 
tf runs uses object encapsulated application transaction ran tf upgrade installed transform function upgrade 

tf tf upgrade encapsulated tf runs tf 
give informal proofs holds ensure conditions hold 
proofs consider adjacent transactions sucient reorder sequences containing intervening transactions achieve adjacency 
tf application transaction serialized tf upgrade installed transform function upgrade ect tf 
proof ran tf know object encapsulates 
furthermore know tf uses objects encapsulates 
read write sets tf object common ect tf ran tf tf upgrade tf transitively uses tf tf ect tf tf 
proof tf transitively uses know encapsulates know tf runs tf 
condition holds trivially order tf tf occur 
tf tf upgrade tf transitively tf transitively tf tf equivalent tf tf 
proof tf tf commute object read tf modi ed 
object exists know encapsulate 
existence implies encapsulated encapsulated encapsulated encapsulated know encapsulating object object encapsulates 
whichever object encapsulates tf object violates assumption tf uses object 
holds get bene recall section system abort interrupted transaction read write con ict tf 
holds con icts 
interrupted transaction object pending transform function rst causing pending transform function run 
triggers versions consider happens tf violates condition condition states tf objects encapsulated reasons condition hold 
rst reason tf objects depend directly transitively 
example depends relation section intentionally limited include immutable subobjects correctness require encapsulation subobjects 
subobjects longer immutable upgrade transform function reads subobjects condition violated 
upgrades happen practice 
second reason condition may hold object encapsulate subobjects depends 
occur cyclic objects 
occur case iterators similar constructs 
consider example iterator set iterator job return di erent element set time method called elements set returned 
job eciently iterator needs direct access objects represent implemented linked list iterator able access nodes linked list directly 
iterator encapsulated objects outside allow ecient implementation iterators set object encapsulate linked list depends 
iterator outside object access list 
fact really happening iterators object depends shared subobject 
example iterators depend linked list 
encapsulation violations sort prevent local reasoning object oriented programs long code shared dependencies module 
code modularized correctness reasoned locally considering module 
example iterator implemented inner class set class modular reasoning possible :10.1.1.11.1440:10.1.1.11.1440
encapsulation violations lead violation handling violations condition violated possible solutions explicitly order transform functions conditions violated versions 
decision approach requires understanding program behavior programmer instruct system 
explicit ordering transform functions possible objects tf encapsulated containing object 
example suppose linked list class upgraded result set iterators transformed 
containing object encapsulates set object iterator objects force set iterators transformed linked list attaching trigger class containing object 
trigger function takes object argument returns list objects needing upgraded 
triggers de ned part upgrade addition class upgrades de nition identi es class triggered provides code trigger 
system runs trigger object class rst upgrade installed processes list list order runs pending transform functions objects list 
trigger object restricted objects depends furthermore read objects 
uses restriction ensures trigger reasoned modularly read restriction guarantees trigger ect system state 
restrictions triggers provide control order provide tf tf tf occur 
containing object way ensure correct order transforms group objects cyclic dependencies transformed fall back versions 
case keep old versions object transform function tf object keep versions objects depends 
transform functions restricted modify old versions objects 
restriction transform functions versions provide immutable versions preserve old interfaces object states 
triggers versions ensure transform con ict interrupted transactions 
furthermore system interact user prior installing upgrade help user include needed triggers versions 
system highly running transform cause interrupted transactions abort 
speeding upgrades approach executing transforms delays execution object 
want execute sooner 
example dirty page containing persistent objects written back disk want run pending transforms objects page 
want background process read pages transform objects done conjunction garbage collection 
hand proofs conditions depend running transforms correct order 
speci cally need careful condition tf uses pending transform upgrade transform transform upgrade ecting ecting constraint comes condition 
transforms eagerly 
accomplished constructing upgrade graph 
graph shows ordering old classes arrow old class old class transforms objects objects 
nodes graph arrows indicate classes objects transformed eagerly 
graph allows opportunistic transforms part processing object page 
persistent store maintains extents sets list contain objects class provide speed allowing system nd objects eligible transform 
furthermore objects class transformed node class removed graph result classes may eligible transform 
implementation section describes implement upgrades 
describe general strategy provide details implementation works thor object oriented database 
sketch alternative approach persistent object systems 
thor client server system persistent objects reside servers application transactions run client machines cached copies persistent objects 
thor uses optimistic concurrency control 
client machines track objects modi ed transaction 
transaction attempts commit client sends commit request containing information objects states new modi ed objects servers 
server decides transaction commit phase commit transaction objects server informs client decision 
information thor 
installing upgrades upgrades installed interacting servers 
server checks upgrade completeness 
interacts user determine condition holds doesn may result trigger version added upgrade 
versions needed described class upgrades marked requiring versions 
needed information added upgrade server noti es clients servers new upgrade 
information transforms triggers versions attached class objects old classes 
old class object points transform function 
running upgrades mentioned interrupt application transactions transform transactions encounter objects need upgraded triggers attached 
processing involves steps 
time application transaction transform transaction tt uses object check object needs transformed attached trigger 
interrupt tt start transaction run transform code object 
step insures application code encounters fully upgraded objects pending transforms encounter objects expected versions 

run transaction con icts interrupted transaction reads modi es modi ed object modi es read object abort interrupted transactions including 

completes create version objects modi es indicated 

triggered transforms run provided de ned upgrades upgrade caused run 
note nished executing point don interrupt run additional transforms 

triggered transforms left run continue running interrupted tt aborted 

processing complete ready commit forced abort commit completed transactions completion order 
transaction commit fails abort haven committed rerun order 
rerun application transaction aborted 
implementation thor section describes approach takes advantage runtime infrastructure thor 
describe alternate approach section assume infrastructure system 
information thor upgrade implementation contained 
objects thor refer 
particular servers identify page server object number page 
expensive running transactions thor client machines swizzle pointers rst followed ef ciently locate object referred client cache 
swizzling done indirection table called rot resident object table 
swizzled pointer points entry rot 
entry points object client cache empty 
interesting part implementation technique keep cost step 
step critical requires test method call determine object method called due upgraded attached trigger 
system perform test inexpensive 
reduce cost test maintaining invariant 
application transaction running nonempty entries rot date objects triggers ran 
invariant means running application transaction discover upgrades triggers ll empty rot entries 
rot entries lled avoid need test upgrades triggers normal case running method calls objects rot 
part lling rot entry look object class object discover pending transform 
client machine establishes follows 
learns new upgrade clears rot entries objects upgrade aborts current transaction objects classes 
processing expensive expense acceptable upgrades installed infrequently hour day 
invariant ensure correct behavior running transforms objects rot may transform transformed due upgrade 
case object versioned transform needs nd appropriate earlier version 
part making method call test running application transaction transform transaction 
test fast involves looking boolean variable frequently ends register fastest hardware cache 
test indicates running transform transaction system extra processing nd version needed 
transform transaction completes old versions rot placed needed run transform 
old versions removed rot point 
versions transform transaction commits system determines version needed 
stores new object page old room 
new object bigger old stored page logical physical rot allows client machine move objects cache 
new version big page original object changed special small surrogate object points new object 
version needed original object changed surrogate points old new versions new version placed object page possible 
commits part committing application transaction client sends servers information objects transformed processing transaction 
transformed object sends new state plus state surrogate needed 
objects sent containing pages thor uses 
alternative approach approach described requires thor infrastructure 
particular relies fact indirection table cleared client machine learns new upgrade 
systems rot require di erent approach 
section sketches technique environment 
approach quite straightforward 
objects typically point dispatch vector containing entry methods 
objects class point dispatch vector 
take advantage dispatch vector handle upgrades 
class due upgrade old class part installing upgrade modify dispatch vector point special versions methods 
method runs know object due upgraded attached trigger needs run 
method carries check step checks boolean determine call coming application transaction transform transaction 
case proceeds discussed section 
additionally methods upgraded objects older versions check called transform carry processing get right version 
approach dispatch vectors avoids version checks done implementation checks done objects due upgraded upgraded objects earlier versions 
performance evaluate approach extended thor system support upgrades conducted performance study 
goal study evaluate overhead imposed upgrade infrastructure application performance 
thor basis study performs 
earlier studies showed delivers comparable performance highly optimized persistent object system im plemented system support transactions 
evaluated kinds overhead baseline overhead transform overhead 
baseline overhead main concern 
overhead occurs normal case execution system encounter objects need upgraded overhead due checks determine upgrade needed 
transform overhead overhead running transforms 
upgrade system costs concern transform overhead reasonable 
evaluated overhead comparing performance application running systems original thor system prototype prototype supports upgrades 
prototype include upgrade installation server subsequent noti cation client 
con gured client sequence dormant upgrades activated upgrades running applications 
application workloads single user oo benchmark benchmark intended capture characteristics various cad applications model speci application 
oo standard benchmark measuring object storage system performance 
oo database contains tree assembly objects leaves pointing composite parts chosen randomly objects 
composite part contains graph atomic parts linked bidirectional connection objects reachable single root atomic part atomic part connections 
small oo database con guration composite part contains atomic parts 
small database world approach acceptable sucient allow measure baseline transform overheads 
workload choice conservative overhead study oo accesses large number small objects expect overhead proportional number objects accessed 
considered read read write transaction workloads analysis upgrades di erent commit cost workloads modi cations 
read dense traversal performs depth rst traversal entire composite part graph touching atomic part read write traversal performs traversal modifying atomic parts 
experiments system con guration single client single server running machine 
test machine mhz intel pentium iii processor mb memory ran linux 
baseline section considers baseline overhead imposed upgrade infrastructure system encounter objects need upgraded 
baseline experiments evaluate types application accesses fast access traversal elapsed time seconds full rot full rot empty rot empty rot baseline upgrade traversal times object installed rot slower access object needs installed rot 
upgrade infrastructure introduces small extra cost access object resident rot check global ag indicates current transaction application transform transaction 
access object isn resident rot upgrade code introduces larger extra cost includes expense checking trigger transform needs run object 
evaluate costs compared application execution times environments fully populated rot initially empty rot 
full rot comparison expected case application executions 
conversely empty rot comparison represents worst case baseline performance maximum amount performed object access 
case expect occur normally typically empty rot encountered transaction runs 
shows execution times experiments 
gure shows costs running traversals 
include cost committing transactions wanted focus extra costs running traversals 
experiments hot cache cost fetching objects cache dominate execution time 
case upgrade infrastructure introduces minimal overhead 
overhead similar dispatch vector approach section 
executing upgrades experiments measure transform overhead 
installed upgrade ran database traversal encounters objects need transformed 
speci upgrade experiments upgrades atomic part class 
goal measure transform overhead upgrade uses trivial transform minimizes application speci costs transforms de ned programmers computations 
new atomic part class methods elds old class transform just copies elds old object new 
experiments hot cache 
estimate transform cost compared traversal execution times upgrades atomic part upgrade installed just traversal 
experiments traversals visit atomic part multiple times version check transform cost incurred rst visit 
counting number objects transformed traversals read read write cases computed average cost running transform types traversals sec sec 
cost includes processing start transform cost check transform con icts interrupted transaction steps section 
cost estimate overhead includes overhead running transform 
calculation re ect entire cost upgrades include cost committing transaction activates upgrades 
commit cost associated transformed object 
cost low object modi ed application transaction assuming new object ts page require version application modi cations shipped server anyway 
transformed objects modi ed transaction incur additional cost sent server commit message 
estimate average extra commit cost compared commit times upgrades 
read transformed object incurs extra commit cost sent server average commit cost upgraded object sec 
modi es transformed object additional commit cost upgraded object sec 
time object sec transform commit table extra upgrade cost table summarizes extra upgrade costs 
results indicate overhead transform reasonable 
re ects costs incurred lazy upgrade system 
system identify objects needing transformed run transforms commit changes 
related research software upgrades data transformation covering broad range research topics 
schema class versioning considers multiple existing versions schema class :10.1.1.11.1440
object instance evolution considers selective transformation objects class 
hot swapping modules concerned updating class executing code objects class considers issues type safe access object multiple potentially incompatible interfaces enforce upgrade modularity conditions allow programmers reason locally correctness upgrades 
focus schema evolution persistent object stores object oriented databases closely related 
systems database logical schema modi cations class de nitions applied object instances converted eagerly lazily forever conform latest schema 
schema evolution approach orion gemstone objectivity db pjama systems approach available commercial rdbms :10.1.1.11.1440
extensive survey previous schema evolution systems 
previous schema evolution systems provide way executing upgrades eciently space time allowing programmers reason locally correctness upgrades 
practical systems avoid keeping old versions objects times 
earlier systems avoid versions severely limiting expressive power upgrades transform functions allowed method calls 
limit number versions world approach shuts system upgrade discards versions upgrade complete systems support lazy conversion complex fully expressive transforms 
rst identify problem posed deferred complex transforms incompatible upgrades :10.1.1.11.1440
introduced upgrade modularity condition equivalence lazy eager conversion 
condition weaker conditions consider interleavings transforms upgrade 
ensures type safety deferred complex transforms screening approach similar versioning 
approach analysis take encapsulation account 
incompatible upgrade occurs complex transform installed activates eager conversion avoids transform interference keeping versions objects 
approach unnecessarily conservative switches eager execution holds 
solve problem applications modifying objects transforms earlier upgrades unsafe violates condition 
implementation details commercial systems supporting lazy conversion complex transforms generally available 
limited information information mechanisms supporting atomicity individual transforms performance impact upgrade support normal case operation 
screening approach locates versions upgraded objects physically near new version object 
requires database reorganization versions created 
contrast system require location object versions allows preserve clustering non upgraded objects database reorganization furthermore able preserve clustering upgraded objects 
preserving clustering important system performance impact disk access 
implementation issues caused complex user de ned transforms arise eager lazy systems support arbitrary order transforms access potentially incompatible transformed objects 
pjama system keeps old new versions solve problem 
provide recoverability reduce memory demands converting large datasets performs incremental partitioned conversion creates partitions old new versions conversion deletes old copies copying converted partitions 
system pjama uses write ahead logging support conversion atomicity recoverability 
persistent object stores provide simple powerful programming model allows applications store objects reliably shared applications 
providing satisfactory way upgrading objects persistent object store longstanding challenge 
upgrades performed way ecient space time application access store 
addition approach modular allow programmers reason locally correctness upgrades similar way reason regular code 
provides solutions problems 
de nes upgrade modularity conditions upgrade system satisfy support local reasoning upgrades 
conditions general earlier de nitions apply lazy world upgrade systems apply systems versions systems don :10.1.1.11.1440
describes new approach executing upgrades eciently satisfying upgrade modularity conditions 
approach exploits object encapsulation properties novel way 
proves upgrade system satis es upgrade modularity conditions transforms behaved 
show conditions hold triggers versions 
describes prototype implementation supports fully expressive modular lazy upgrades 
implementation done thor 
describes alternate implementation approach persistent object system 
presents results performance study indicating infrastructure low cost 
negligible impact applications objects need upgraded 
expect common case upgrades rare week day 
results show upgrades needed overhead transforming object small 
describes complete solution problem upgrading persistent objects 
acknowledgments grateful dorothy curtis helping implementation upgrade system 
daniel jackson viktor butler lampson anonymous referees providing useful comments 
adya gruber liskov maheshwari 
ecient optimistic concurrency control loosely synchronized clocks 
acm sigmod international conference management data may 
agesen freund mitchell :10.1.1.11.1440
adding type parameterization java language 
object oriented programming systems languages applications oopsla october 
aldrich chambers 
alias annotations program understanding 
object oriented programming systems languages applications oopsla november 
atkinson bancilhon dewitt dittrich maier zdonik 
object oriented database system manifesto 
sigmod conference may 
atkinson hamilton 
scalable recoverable implementation object evolution pjama platform 
persistent object systems pos september 
atkinson jordan spence 
design issues persistent java type safe object oriented orthogonally persistent system 
persistent object systems pos may 
banerjee kim kim korth 
semantics implementation schema evolution object oriented databases 
acm sigmod international conference management data may 
bertino 
object evolution object databases 
pareschi editors dynamic worlds kluwer academic publishers 
boyapati 
distributed persistent java system 
sm thesis massachusetts institute technology september 
boyapati lee rinard 
safe runtime downcasts ownership types 
ecoop international workshop aliasing con nement ownership object oriented programming july 
boyapati lee rinard 
ownership types safe programming preventing data races deadlocks 
object oriented programming systems languages applications oopsla november 
boyapati liskov shrira :10.1.1.11.1440:10.1.1.11.1440
ownership types object encapsulation 
principles programming languages popl january 
boyapati liskov shrira 
ownership types safe lazy upgrades object oriented databases 
technical report tr mit laboratory computer science july 
boyapati rinard 
parameterized type system race free java programs 
object oriented programming systems languages applications oopsla october 
boyapati jr rinard 
ownership types safe region memory management real time java 
programming language design implementation pldi june 
bracha odersky stoutamire wadler 
making safe past adding genericity java programming language 
object oriented programming systems languages applications oopsla october 
gemstone data management system 
kim lochovsky editors object oriented concepts databases applications 

carey dewitt kant naughton 
status report oo oodbms benchmarking ort 
object oriented programming systems languages applications oopsla october 
castro adya liskov myers 
hac hybrid adaptive caching distributed storage systems 
symposium operating system principles sosp october 
editor 
object database standard odmg 
morgan kaufmann 
cheung 
lazy schema evolution object oriented databases 
sm thesis massachusetts institute technology september 
:10.1.1.11.1440
type evolution instance adaptation 
technical report cmu cs carnegie mellon university june 
clarke 
object ownership containment 
phd thesis university new south wales australia july 
clarke drossopoulou 
ownership encapsulation disjointness type ect 
object oriented programming systems languages applications oopsla november 
clarke potter noble 
ownership types exible alias protection 
object oriented programming systems languages applications oopsla october 
jensen lee rundensteiner 
consistent schema version removal optimization technique object oriented views 
ieee transactions knowledge data engineering tkde march 
day gruber liskov myers 
subtypes vs clauses constraining parametric polymorphism 
object oriented programming systems languages applications oopsla october 
zicari 
design integrity consistency checker icc object oriented database system 
european conference object oriented programming ecoop july 
deux story 
ieee transactions knowledge data engineering tkde march 

safe class data evolution large long lived java applications 
technical report tr sun microsystems august 
drossopoulou damiani dezani ciancaglini giannini 
fickle dynamic object re classi cation 
ecoop 
duggan :10.1.1.11.1440
type hot swapping running modules 
technical report sit cs stevens institute technology nj october 

schema database evolution object database system 
proceedings st international conference large data bases vldb 
meyer zicari 
measuring performance immediate deferred updates object database systems 
proceedings oopsla workshop object database behavior benchmarks performance 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 
hicks moore nettles 
dynamic software updating 
programming language design implementation pldi june 
gray 
dynamic classes lightweight mechanism update code running program 
usenix annual technical conference june 
leino nelson 
data abstraction information hiding 
research report compaq systems research center november 
leino poetzsch ter zhou 
data groups specify check side ects 
programming language design implementation pldi june 
lerner habermann 
schema evolution database reorganization 
object oriented programming systems languages applications oopsla october 
liskov castro shrira adya 
providing persistent objects distributed systems 
european conference object oriented programming ecoop june 
liskov moh richman shrira cheung boyapati :10.1.1.11.1440
safe lazy software upgrades object oriented databases 
technical report tr mit laboratory computer science june 
liskov snyder atkinson scha ert 
abstraction mechanisms clu 
communications acm cacm august 
lucassen gi ord 
polymorphic ect systems 
principles programming languages popl january 
myers bank liskov 
parameterized types java 
principles programming languages popl january 
object design objectstore advanced api user guide release 
objectivity objectivity technical overview version 
stein 
class modi cation gemstone object oriented dbms 
object oriented programming systems languages applications oopsla october 
skarra zdonik 
management changing types object oriented database 
object oriented programming systems languages applications oopsla november 
object technology 
user manual 

parametric polymorphism java approach translation re ective features 
object oriented programming systems languages applications oopsla october 
zicari :10.1.1.11.1440
framework schema updates object oriented database systems 
international conference data engineering icde april 

object owner 

owner object world 

owner object change time 

ownership relation forms tree rooted world 
ownership properties world ownership relation appendix ownership types ownership types provide statically enforceable way specifying object encapsulation 
idea object subobjects depends preventing accessible outside 
ownership types statically check condition section 
section presents overview type system details :10.1.1.11.1440:10.1.1.11.1440
key type system concept object ownership 
object owner 
owner object special owner called world 
type system statically guarantees ownership properties shown 
presents example ownership relation 
draw arrow owns gure special owner world owns objects owns owns owns 
ownership allows program statically declare encapsulation boundaries capture dependencies object objects depends 
system enforces encapsulation inside encapsulation boundary outside access 
object accesses object pointer methods obtain pointer 
inside encapsulation boundary outside access 
object allowed access objects owns ancestors ownership tree objects globally accessible objects objects owned world 
access objects gure 
note analogy nested procedures proc fvar proc fvar proc ggg 
say xn pn children pn pn access pn children ancestors pn children global variables procedures 
class tstack tnode head null void push value tnode newnode new tnode value head head newnode pop head null return null value head value head head return value class tnode tnode value tnode tnode value value return value tnode return class class void test tstack new tstack tstack new tstack tstack new tstack tstack new tstack stack objects head tnode tstack tnode head tstack head tnode tnode head tstack head tnode tnode head head value head value head value head value head value head value world ownership relation owner polymorphism type system context java language augmented ownership types 
class definition parameterized owners 
rst owner parameter special identi es owner corresponding object 
owner parameters propagate ownership information 
parameterization allows programmers implement generic class objects di erent owners 
owner instantiated world owner parameter 
objects owned encapsulated objects accessed outside 
objects owned world accessed 
shows example 
tstack stack objects 
implemented linked list 
tstack example shows type annotations written explicitly 
automatically inferred 
see details 
class 
tstack clauses constrain owners class parameterized towner 
owns tstack object towner owns objects contained tstack 
code speci es tstack object owns nodes list list nodes accessed outside tstack object 
type tstack instantiated owner parameters 
means tstack owned object created objects 
tstack owned object objects owned world 
tstack owned world objects 
ownership relation depicted assuming stacks contain elements 
dotted line indicates object transitively owned world 
constraints owners type hx multiple owners type system statically enforces constraint ng 
recall ownership relation forms tree rooted world 
notation means descendant ownership tree 
notation means descendant ownership tree 
type tstack illegal world 
method xk object type hx restriction kg 
constraints needed provide encapsulation presence subtyping 
illustrates point example 
check ownership constraints modularly necessary programmers specify additional constraints class method parameters 
example type legal towner 
allow programmers specify additional constraints clauses type system enforces constraints 
example class speci es towner 
instantiation satisfy constraint illegal 
subtyping rule declaring subtype rst owner parameter supertype subtype addition course supertype satisfy constraints owners 
rst owners match special corresponding objects 
subtype 
subtype rst owners match 
inner classes inner classes similar member inner classes java 
inner class de nitions nested inside classes 
class tstack tnode head null 
tstackenum elements return new tstackenum class tstackenum implements tenumeration tnode current tstackenum current tstack head getnext current null return null current value current current return boolean hasmoreelements return current null class void test tstack new tstack tenumeration elements tenumeration elements interface tenumeration getnext boolean hasmoreelements tstack iterator shows example 
inner class tstackenum implements iterator tstack elements method tstack provides way create iterator tstack 
tstack code similar 
recall owner instantiated world owner parameter 
inner class owner instantiated outer class 
feature allows inner object access objects encapsulated outer objects 
owner current eld instantiated tstack 
current eld accesses list nodes encapsulated outer tstack object 
inner class parameterized owners just regular class 
system outer class parameters automatically visible inside inner class 
inner class uses outer class parameter explicitly include outer class parameter declaration 
tstackenum declaration includes owner parameter towner outer class 
towner visible inside tstackenum 
tstackenum declaration include 
visible inside tstackenum 
note example elements method parameterized 
allows program create different iterators di erent owners 
elements returns iterator type 
type legal case towner 
requirement captured clause 
class tstack tnode head null 
class tstackenum implements tenumeration tnode current 
getnext writes reads tstack 
boolean hasmoreelements reads 
interface tenumeration getnext writes reads world boolean hasmoreelements reads tstack iterator ects encapsulation theorem system provides encapsulation property theorem 
access object owned 

inner class object proof 
consider code class chf ho variable type ho declared static scope class owner world formal class parameter formal method parameter outer class 
show rst cases constraint holds 
rst cases constraint holds trivially 
cases constraint holds 
fth case 
object class access object owned rst cases inner object fth case 
ects clauses system contains ects clauses useful specifying assumptions hold method boundaries enable modular reasoning checking programs 
ects ownership types check condition described section 
system allows programmers specify reads writes clauses 
consider method speci es writes wn reads rm 
method write object call methods write ng 
method read object call methods read ng mg 
allow method read write objects named writes clause 
shows tstack iterator uses ects similar tstack iterator 
example hasmoreelements method reads object 
getnext method reads objects owned tstack writes reads object 
ects clauses conjunction subtyping ects overridden method subsume ects class int int size reads return void add int writes 
class intstack vec new void push int writes vec add void intstack writes reads int size push assert size reasoning aliasing side ects overriding method 
dicult specify precisely ects method 
example dicult specify precisely read ects getnext method tenumeration class tenumeration expected supertype subtypes tstackenum tenumeration name speci objects getnext methods subtypes 
accommodate cases allow escape mechanism method include world ects clauses 
ownership types ects locally reason side ects method calls presence subtyping object oriented languages 
consider example code shows intstack implemented vec 
adopted example 
example method receives arguments intstack condition assert statement true aliased vec 
example method uses clause specify 
ownership relation forms tree see constraint implies aliased vec 
furthermore size declares reads objects owned intstack push declares writes reads objects owned intstack 
possible reason locally size push interfere condition assert statement true 
support modular upgrades ownership types statically check property similar condition section check transform function uses owned objects 
system handles inner classes specially ensure condition discussed section 
upgrade ects class attach triggers inner classes done automatically part installing upgrade 
inner class object trigger causes outer object transformed 
applications ownership type systems prevent data races deadlocks multithreaded programs prevent memory errors programs region memory management aid program understanding 
ownership types require little programming overhead type checking fast scalable provide bene ts er promising approach making object oriented programs reliable 

