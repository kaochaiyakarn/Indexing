calculus cryptographic protocols spi calculus mart abadi digital equipment systems research center ma pa dec com andrew gordon university cambridge computer laboratory adg cl cam ac uk december introduce spi calculus extension pi calculus designed description analysis cryptographic protocols 
show spi calculus particularly studying authentication protocols 
pi calculus extension suffices protocols spi calculus enables consider cryptographic issues detail 
represent protocols processes spi calculus state security properties terms coarsegrained notions protocol equivalence 
contents security pi calculus protocols restricted channels basics 
outline pi calculus 
examples restricted channels 
example 
example channel establishment 
discussion 
protocols cryptography spi calculus shared key cryptography 
examples shared key cryptography 
cryptographic example 
example key establishment 
complete authentication example flaw 
complete authentication example repaired 
discussion 
formal semantics spi calculus reaction relation 
testing equivalence 
semantic notions useful proofs commitment relation 
auxiliary equivalences 
strong bisimilarity 
barbed equivalence 
barbed congruence 
underpinning relation 
proofs examples proofs example section 
proofs example section 
proofs example section 
formalisation attack section 
proofs example section 
cryptographic primitives hashing 
public key encryption digital signatures 
appendices encoding encryption pi calculus proofs commitment proofs replication proofs equivalences testing equivalence 
barbed equivalence 
barbed congruence 
proofs underpinning security pi calculus spi calculus extension pi calculus mpw cryptographic primitives 
designed description analysis security protocols authentication electronic commerce 
protocols rely cryptography communication channels properties authenticity privacy 
accordingly cryptographic operations communication channels main ingredients spi calculus 
pi calculus extension describing protocols level 
pi calculus primitives channels simple powerful 
channels created passed example authentication servers clients 
scoping rules pi calculus guarantee environment protocol attacker access channel explicitly scoping basis security 
sum pi calculus appears fairly convenient calculus protocols secure communication 
pi calculus express cryptographic operations commonly implementing channels distributed systems include constructs encryption decryption easy represent 
cryptography notoriously error prone prefer away 
define spi calculus order permit explicit representation cryptography protocols 
notations describing security protocols 
long authentication literature fairly clear connection intended implementations protocols see ns lie 
main shortcoming provide precise solid basis reasoning protocols 
notations ban formal relation implementations may subtle 
spi calculus middle ground directly executable precise semantics 
semantics spi calculus precise intelligible spi calculus provides setting analysing protocols 
specifically express security guarantees equivalences spi calculus processes 
example say protocol keeps secret piece data stating protocol equivalent protocol equivalence means equivalence eyes arbitrary environment 
environment interact protocol tempting create confusion different messages sessions 
definition equivalence yields desired properties security applications 
interestingly take standard bisimilarity relation notion equivalence 
equivalence hard prove demonstrate carrying analysis small protocols 
definition equivalence environment need give model environment explicitly 
main advantages approach 
writing model tedious lead new arbitrariness error 
particular difficult express environment invent random numbers lucky guess random secrets protocol depends 
resolve conflict letting environment arbitrary spi calculus process 
approach similarities approaches reasoning protocols 
temporal logics process algebras gm low sch method builds standard concurrency formalism obvious advantages implies method intuitive ad hoc formalisms ban 
modal logics ablp emphasise reasoning channels utterances 
state transition models dy mcf mil kem mea interested characterising knowledge environment 
unique features approach reliance powerful scoping constructs pi calculus radical definition environment arbitrary spi calculus process representation security properties integrity secrecy equivalences 
model protocols simpler poorer models developed informal mathematical arguments br spi calculus include notion probability complexity 
interesting bridge gap spi calculus models giving probabilistic interpretation results 
contents section introduces pi calculus method specifying authenticity secrecy properties equations 
section extends pi calculus primitives shared key cryptography 
sections define formal semantics spi calculus associated proof techniques respectively 
section uses techniques proofs properties stated earlier 
section discusses add primitives public key cryptography pi calculus section offers 
appendices contain proofs sketches partial encodings spi calculus pi calculus 
note said perl language looks clear encrypted 
pi calculus fortiori spi calculus far perl respect 
get lost formal passages cleartext nearby may help hopefully informal explanations convey gist accomplished 
protocols restricted channels section review definition pi calculus informally 
give formal presentation section 
introduce new application pi calculus study security 
basics pi calculus small extremely expressive programming language 
important result search calculus serve foundation concurrent computation way lambda calculus foundation sequential computation 
pi calculus programs systems independent parallel processes synchronise message passing handshakes named channels 
channels process knows determine communication possibilities process 
channels may restricted certain processes may communicate 
respect pi calculus similar earlier process calculi csp hoa ccs mil 
sets pi calculus apart earlier calculi scope restriction program text channel may may change computation 
process sends restricted channel message process outside scope restriction scope said enlarges embrace process receiving channel 
processes pi calculus mobile sense communication possibilities may change time may learn names new channels scope extrusion 
channel transferable capability communication 
central technical idea restriction operator scope extrusion pi calculus formal model possession communication secrets cryptographic keys 
features pi calculus essential descriptions security protocols 
outline pi calculus fact versions pi calculus 
review syntax semantics particular version pi calculus choices relatively uncontroversial 
differences versions orthogonal concerns 
assume infinite set names communication channels infinite set variables 
range names range variables 
set terms defined grammar terms name pair zero suc successor variable standard pi calculus names terms 
convenience added constructs pairing numbers suc distinguished variables names 
distinction simplifies treatment equivalences 
set processes defined grammar processes hni output input composition restriction replication match nil pair splitting case suc integer case name bound variable bound variables bound case suc variable bound second branch write outcome replacing free occurrence process term identify processes renaming bound variables names 
adopt abbreviation hni 
intuitively constructs pi calculus meanings ffl basic computational step synchronisation mechanism pi calculus interaction term communicated output process input process named channel output process ready output channel interaction occurs term communicated process runs 
input process ready input channel interaction occurs communicated process runs 
general forms output input allow channel arbitrary term useful cases name variable gets instantiated name 
ffl composition behaves processes running parallel 
may interact channels known outside world independently 
ffl restriction process new private name may occur behaves ffl replication behaves infinite number copies running parallel 
ffl match behaves provided terms stuck 
ffl nil process 
added pairs integers new process forms ffl pair splitting process behaves term pair stuck 
ffl integer case process case suc behaves term suc stuck 
write mean behaviours processes indistinguishable 
words processes may different internal structure third process distinguish running parallel running parallel far tell properties precisely safety properties 
define relation section form testing equivalence 
suffices understand informally 
examples restricted channels show express security protocols pi calculus 
security protocols common find channels set principals allowed send data listen 
set principals may expand course protocol run example result channel establishment 
remarkably easy model property channels pi calculus restriction operation expansion set principals access channel corresponds scope extrusion 
provide systematic translation language describing protocols pi calculus show examples protocols written directly pi calculus informal descriptions kind commonly security literature 
introduce fairly systematic approach stating properties protocols pi calculus equivalences 
example example extremely basic 
example principals share channel ab send data listen channel 
protocol simply uses ab sending single message informal notation may write protocol follows message ab pi calculus description protocol delta ab hmi delta ab inst delta ab processes describe principals inst describes instance protocol 
channel ab restricted intuitively achieves effect access ab definitions inst processes parameterised formally say inst abstractions treat left delta bound parameters 
roughly abstractions functions map terms processes 
section contains precise definition abstractions 
abstractions course instantiated applied example instantiation yields ab 
standard rules substitution govern application forbidding parameter captures example expanding inst ab require renaming bound occurrence ab definition inst pi calculus description protocol may little futile input 
useful general description says runs process input 
revise definitions follows delta ab hmi delta ab inst delta ab informally simply result applying formally abstraction instantiation abstraction 
adopt convention bound parameters protocol case ab occur free protocol important properties ffl authenticity integrity applies message sends attacker cause apply message 
ffl secrecy message read transit reveal protocol reveal secrecy property stated terms equivalences inst inst 
means indistinguishable protocol message indistinguishable protocol message sensible ways formalising authenticity property 
particular may possible notions refinement suitable program logic 
choose write authenticity equivalence economy 
equivalence compares protocol protocol 
intent protocol serves specification 
case specification delta ab hmi spec delta ab inst spec delta ab spec principal usual principal replaced variant spec variant receives input acts receives may say spec magical version knows message sent similarly inst spec magical version inst specification protocol similar structure specification evidently correct protocol 
take equivalence authenticity property inst inst spec summary authenticity inst inst spec secrecy inst inst equivalences means processes equated indistinguishable active attacker environment 
equivalences hold restriction channel ab prove equivalences section contains proofs examples 

data new channel gamma gamma gamma gamma gamma gamma 
new channel 
new channel structure wide frog protocol example channel establishment interesting variant example obtained adding channel establishment phase 
phase communication data principals obtain new channel help server different ways establishing channel level 
describe inspired wide frog protocol ban basic structure shown 
consider simplified version wide frog protocol 
version deal channels keys simplified channel establishment data communication happen need timestamps 
section show treat keys allow instances protocol arbitrary number messages 
informally version message ab message ab sb message ab channel share initially sb channel share initially ab channel creates communication passing channel ab sends message ab note channel transmits 
pi calculus formulate protocol follows delta ab hc ab ab hmi delta sb hxi delta sb inst delta sb write represent message receives previous example 
restrictions channels sb ab reflect expected privacy guarantees channels 
salient new feature specification scope extrusion generates fresh channel ab sends scope written description formalisms ccs csp pi calculus important 
discussing authenticity introduce specification delta ab hc ab ab hmi delta sb hxi spec delta sb inst spec delta sb spec specification message communicated magically process applied message sends independently happens rest protocol run 
obtain authenticity secrecy properties authenticity inst inst spec secrecy inst inst properties hold scoping rules pi calculus 
discussion believe examples just encouraging 
indicate pi calculus natural language describing security protocols 
particular restriction operator scope extrusion allow convenient representations possession communication channels 
wish suggest pi calculus enables describe security protocols level 
example protocols rely asymmetric channels channels kind implemented publickey cryptography dh rsa 
may possible represent asymmetric channels pi calculus extending pi calculus may simpler effective 
cases pi calculus notion scoping useful 
protocols cryptography just versions pi calculus versions spi calculus 
differ particular cryptographic constructs include 
section introduce relatively simple spi calculus pi calculus extended primitives shared key cryptography 
write protocols shared key cryptography calculus 
section presentation informal 
sections contain formal definitions 
refer calculus section spi calculus define versions spi calculus section 
spi calculus shared key cryptography syntax spi calculus extension pi calculus 
order represent encrypted messages add clause syntax terms terms section shared key encryption order represent decryption add clause syntax processes processes section case shared key decryption variable bound intuitively meaning new constructs follows ffl term represents ciphertext obtained encrypting term key shared key cryptosystem des des 
ffl process case attempts decrypt term key ciphertext form process behaves 
process stuck 
implicit definition standard significant assumptions cryptography ffl way decrypt encrypted packet know corresponding key 
ffl encrypted packet reveal key encrypt 
ffl sufficient redundancy messages decryption algorithm detect ciphertext encrypted expected key 
assumed messages contain information allows principal recognise messages cf 
ban 
semantics spi calculus formalised way semantics pi calculus 
carry formalisation section 
interesting issues formalisation concern notion equivalence 
write mean behaviours processes indistinguishable 
notion indistinguishability complicated presence cryptography 
example complications consider process delta process simply sends new key public channel key transmitted 
intuitively able say indistinguishable observer discover tell sent hand clearly different transmit different messages fine grained equivalence standard strong bisimilarity distinguish 
equivalence coarse grained unwanted distinction 
examples shared key cryptography spi calculus enables detailed descriptions security protocols pi calculus 
pi calculus enables representation channels spi calculus enables representation channel implementations terms cryptography 
section show example cryptographic protocols 
pi calculus scoping basis security spi calculus 
particular restriction model creation fresh cryptographic keys 
restriction model creation fresh nonces sort challenge response exchanges 
security properties expressed equivalences notion equivalence delicate discussed 
cryptographic example example cryptographic version example section 
consider principals share key kab addition assume public channel ab communication way secure 
protocol simply sends message kab ab informally write protocol follows message ab spi calculus write delta ab delta ab case inst delta kab definition sends ab listens message ab message attempts decrypt kab decryption succeeds applies result 
assumption share kab gives rise restriction kab syntactically legal meaningful kab channel 
hand ab restricted public channel 
principals may send messages ab may attempt decrypt message encrypted kab case protocol get stuck 
concerned possibility easy avoid writing slightly elaborate program specification delta ab spec delta ab case inst spec delta kab spec obtain properties authenticity inst inst spec secrecy inst inst intuitively authenticity holds key kab compromised 
factors contribute key compromise example incompetence part protocol participants brute force part attackers 
model factors model deliberate key publication sense extreme 
suffices small change definitions spec send kab public channel receiving change preserves authenticity equation clearly secrecy equation 
apparent correspondence protocol section section cryptography 
informally may say cryptographic implementation protocol section 
precisely conjecture protocol implementation parallel composition protocol section ab hni 
notion implementation testing preorder see section 
role ab hni send decoy message ab decoy needed environment detect ab absence decoy distinguish protocol section section 
study implementation relations 
believe relations important deserve attention field security 
view example implementation relation intriguing novelty suggests possibility hierarchical development cryptographic protocols non cryptographic specifications 

data new key kab gamma gamma gamma gamma gamma gamma 
new key kab kas 
new key kab sb sketch wide frog example key establishment cryptographic protocols establishment new channels means exchange new keys 
methods flawed key exchange 
example cryptographic version section uses simplified form wide frog key exchange 
example represented 
wide frog protocol principals share keys kas sb respectively server want communicate securely creates new key kab sends server kas server forwards sb communication protected encryption happen public channels write sb ab informally simplified version protocol message gkas message gk sb sb message ab spi calculus express message sequence follows delta kab gkas ab delta case sb sb delta sb case sb ab case fwg inst delta kas sb process representing rest behaviour receiving message notice essential scope extrusion generates key kab sends scope usual pattern introduce specification discussing authenticity delta kab gkas ab delta case sb sb spec delta sb case sb ab case fwg inst spec delta kas sb spec may concerned apparent complexity specification 
hand despite complexity specification evidently correct protocol 
particular evident spec applies data message chosen result error attack 
obtain usual properties authenticity secrecy authenticity inst inst spec secrecy inst inst complete authentication example flaw examples discussed far channel establishment data communication happen 
demonstrate simple matter programming remove restriction represent sophisticated examples sessions principals 
examples increases opportunity error 
construed limitation approach sign intrinsic difficulty mistakes authentication protocols arise confusion sessions 
consider system server principals 
terms suc suc suc 
abbreviate 
names principals 
assume principal input channel input channels public names 
assume server shares pair keys principal key direction principal uses key send key si receive extend standard example system principals message sequence message fb kab gkas message fa kab gk sb message range principals 
names appear messages order avoid ambiguity names appear clear function hints help recipient choose appropriate key decryption rest message 
intent protocol pair principals arbitrarily concurrent runs allowed 
stands protocol seriously flawed correct protocol appears section 
flaws fixes clear readers knowledgeable security 
continue discuss protocol order explain method representing spi calculus 
spi calculus representation convenient abbreviations 
firstly rely pair splitting input decryption delta case fx gn delta case variable fresh 
secondly need standard notation composition finite set processes 
finite family processes way composition delta delta delta omit inner brackets encrypted pair form simply write fn gn common informal descriptions 
informally instance protocol determined choice parties message sent key establishment 
formally instance triple principals message 
say source address destination address instance 
assume abstraction representing behaviour principal receipt message protocol 
instance runs intended argument triple 
instance process corresponds role send delta fj kgk sending process creates key sends server names principals instance 
sending process sends name put messages parallel somewhat arbitrarily putting sequence effect 
process corresponds role principal recv delta cipher case cipher key gk sj cipher case cipher fz plain key xa plain receiving process waits message cipher server extracts key key message waits message cipher key applies name xa presumed sender name contents plain message 
variables xa intended name sending process expected match 
server instances delta xa cipher case cipher key gk key gk sj variable xa intended name sending process xb name receiving process key new key cipher encrypted part message protocol 
code server program way branch name xa parallel composition processes indexed program way branch name xb similarly 
casual multiple threads characteristic pi calculus practice branch implemented efficiently interested behaviour server efficient implementation 
define system parameterised list instances protocol sys delta sj send delta delta delta send recv delta delta delta recv sj stands ns sn 
expression sys represents system instances protocol 
server replicated addition replication receiving processes means principal willing play role receiver number runs protocol parallel 
runs protocol simultaneous involve principals 
write specification modifying protocol 
specification revise sending process receiving process server send spec delta send recv spec delta cipher case cipher key gk sj cipher case cipher fz plain key plain hi sys spec delta sj send spec delta delta delta send spec recv spec delta delta delta recv spec specification sending process instance implementation sends fresh channel name runs receives message receiving process specification identical implementation plain replaced plain hi symbol represents fixed arbitrary message 
variable plain bound fresh name corresponding instance protocol 
receiving process signal triggering execution appropriate process 
crucial property specification occurrences bundled description sending process 
applied desired parameters 
obvious instance cause execution despite complexity specification obviously correct implementation 
previous examples protocol authenticity property sys sys spec instances 
unfortunately protocol vulnerable replay attack invalidates authenticity equation 
consider system sys 
attacker replay messages instance get mistaken messages instance causing passed twice sys execute copies 
contrast matter attacker sys spec run 
authenticity equation hold 
disprove formally section 
leave discussion secrecy example 
complete authentication example repaired improve protocol previous section adding nonce handshakes protection replay attacks 
wide frog protocol uses timestamps handshakes 
treatment timestamps spi calculus possible requires additional elements including rudimentary account clock synchronisation 
protocols handshakes fundamentally self contained protocols timestamps handshakes clearer examples 
informally new protocol message message message fa kab gkas message message nb message fs kab nb gk sb message messages request challenge challenge respectively 
challenge nonce created nonce purpose 
obviously nonce secret unpredictable attacker simulate challenge replay response 
message says communicate kab receipt components kab appear explicitly message safety elided 
presence message proves freshness message 
message represents fixed arbitrary message uses signal ready nonce challenge nb message says says communicate kab receipt nb field encrypted portions messages included order distinguish messages serves direction bit 
message transmission data kab messages protocol components 
spi calculus representation convenient generalise syntax pairs pair splitting arbitrary tuples 
standard abbreviations inductively delta delta variable fresh 
spi calculus represent nonces protocol newly created names 
obtain spi calculus expressions send delta hii nonce fi nonce gk delta xa hn cipher case cipher xb key nonce gk nonce hi nonce hfs key nonce gk sj recv delta nb cipher case cipher fx xa xb key nonce gk sj nonce nb cipher xa case cipher fz plain key plain sys delta sj send delta delta delta send recv delta delta delta recv names nb represent nonces 
variable subscripts hints indicate corresponding variables represent example xa ya expected name sending process nonce nonce expected nonces generated respectively 
definition sys spec exactly analogous previous section omit 
obtain authenticity property sys sys spec instances 
property holds nonces 
particular attack described section longer distinguish sys sys spec 
secrecy property express way external observer tell apart executions system identical participants different messages 
secrecy property assert protocol reveal information contents exchanged messages revealed key exchange 
order express information revealed key exchange introduce definition 
say pair instances indistinguishable instances source destination addresses 
definition secrecy pair 
jm indistinguishable sys sys jm 
means observer distinguish systems parameterised sets indistinguishable instances 
property holds protocol 
summary authenticity sys sys spec instances 
secrecy sys sys jm pair 
jm indistinguishable 
ask property anonymity source destination addresses instances protected eavesdroppers 
anonymity holds protocol current practical protocols 
easy specify anonymity relevant 
discussion examples obvious writing protocol spi calculus little harder writing informal notations common literature 
hand spi calculus versions detailed 
clear messages sent messages generated checked 
aspects spi calculus descriptions add complexity enable finer analysis 
recall example mistakes ccitt protocol omit timestamp check ban 
obvious writing protocol spi calculus essentially analogous writing programming language suitable communication encryption libraries 
main advantage spi calculus formal precision 
noted spi calculus similarities differences formalisms analysis security protocols 
examples section exhibit similarities differences 
say spi calculus tool finding flaws logics authentication 
hand spi calculus rest ground yields convincing proofs correctness 
formal semantics spi calculus section start formal treatment spi calculus 
section introduce reaction relation means reaction subprocesses take step process reaction basic notion computation pi calculus spi calculus 
section give precise definition equivalence relation expressing security properties 
syntactic conventions grammar spi calculus sections 
syntactic categories terms ranged processes ranged metavariables range infinite set names 
metavariables range disjoint infinite set variables 
write fn fn sets names free term process respectively 
similarly write fv fv sets variables free respectively 
say term process closed mean free variables 
able communicate externally process free names 
set proc fp fv set closed processes 
reaction relation reaction relation concise account computation pi calculus introduced milner mil inspired chemical machine berry boudol bb 
thinks process consisting chemical solution molecules waiting react 
reaction step arises interaction adjacent molecules follows react inter just stir chemical solution allow non adjacent molecules react define relation structural equivalence allows processes rearranged react inter applicable 
define reduction relation closed processes red repl red match red red zero case suc red suc case suc suc red decrypt case reduction relation previous accounts pi calculus introduce useful definition commitment section structural equivalence relation closed processes satisfies equations rules struct nil struct comm struct assoc struct switch struct drop struct extrusion fn struct red struct refl struct symm struct trans struct par struct res complete formal description reaction relation 
reaction relation relation closed processes satisfies react inter rules react struct react par react res 
definition reaction relation corresponds informal description process behaviour sections 
example definition reaction relation show behaviour protocol section inst kas sb 
kas sb kab ab sb gk sb 
kas sb kab ab ab case 
kas sb kab step calculation justified general convention bound parameters protocol including case kas sb kab occurs free testing equivalence order define equivalence define predicate describes channels process communicate 
barb fi input output channel name representing input name representing output 
closed process define predicate exhibits barb fi written fi axioms barb barb rules barb par fi fi barb res fi fi fm mg fi barb struct fi fi intuitively fi holds just closed process may input output immediately barb fi 
convergence predicate fi holds closed process exhibits fi reactions conv barb fi fi conv react fi fi test consist closed process barb fi 
closed process passes test fi 
notion testing gives rise testing preorder testing equivalence set proc closed processes delta test fi fi fi delta idea testing equivalence comes de nicola hennessy dh 
tests processes contain distinguished name 
parameterised barb fi 
superficial difference show relation version de nicola hennessy may testing equivalence 
de nicola hennessy explained may testing corresponds partial correctness safety testing corresponds total correctness 
security literature focuses safety properties definitions 
advantages testing equivalence basis specifications authenticity secrecy simple definition terms convergence predicate 
test neatly formalises idea generic experiment observation process attacker perform process testing equivalence concisely captures concept equivalence arbitrary environment 
definitions closed processes testing equivalent respective parallel compositions third process behave similarly 
follows interchangeably context just parallel 
precisely testing equivalence congruence equivalence relation property closed context 
closed context closed process single hole outcomes filling hole respectively 
proposition structural equivalence implies testing equivalence 
testing equivalence reflexive transitive symmetric 
testing equivalence congruence closed processes 
proposition essential equational reasoning testing equivalence 
proof appendix show testing equivalence remains congruence extended open processes 
testing equivalence sensitive choice language 
processes testing equivalent calculus may testing equivalent new constructs added calculus 
boreale de nicola shown bn testing equivalence finer grained presence mismatch construct 
calculus include mismatch construct need writing protocols construct sensible yields better definition testing equivalence 
true negative constructs check term name number pair encrypted key 
believe results remain valid range reasonable extensions calculus leave study extensions 
semantic notions useful proofs section develops proof techniques spi calculus earlier pi calculus 
section defines commitment relation providing particular characterisation reaction relation 
section reviews notions strong bisimulation barbed equivalence barbed congruence ms 
section introduces underpinning relation shows proofs secrecy 
order prove testing equivalence directly need consider arbitrary tests arbitrary sequences reactions 
structural equivalence define reaction elegant proofs little awkward 
purposes section obtain direct inductive characterisation reaction appeal structural equivalence inductive method proving testing equivalence 
commitment relation original semantics pi calculus mpw notion reaction labelled transition system 
define labelled transition semantics spi calculus imitating milner lecture notes mil 
despite differences style semantics essentially equivalent section proofs semantics 
need new syntactic forms 
abstraction expression form bound variable process 
concretion expression form hmip term process names 
bound write concretions hmip simply hmip 
agent abstraction process concretion 
metavariables stand arbitrary agents 
extend restriction composition operators arbitrary agents follows 
abstraction set delta delta assuming fv 
concretion set delta fn hmi delta hmi assuming ng ng fn 
define dual composition symmetrically 
abstraction concretion ng fn define interactions closed processes delta delta abstraction may write instantiation 
notation 
action name name distinguished silent action action barb commitment relation written ff gamma 
closed process ff action closed agent 
define relation inductively rules comm gamma 
comm gamma 
hmip comm inter gamma 
gamma 
gamma 
comm inter gamma 
gamma 
gamma 
comm par ff gamma 
ff gamma 
comm par ff gamma 
ff gamma 
comm res ff gamma 
ff fm mg ff gamma 
comm red ff gamma 
ff gamma 
intuitively comm says abstraction residue input commitment comm says concretion residue output commitment comm inter comm inter say combination abstraction concretion gives interaction 
commitment relation straightforward structural definition main appeal 
ff gamma 
action ff name name just agent process abstraction concretion respectively 
commitment relation indexed gamma binary relation closed processes 
write gamma 
reflexive transitive closure gamma 
write gamma exists process gamma 
propositions connect commitment relation formal notions section exhibiting barb reaction testing 
proposition fi exists agent fi gamma proposition gamma proposition passes test fi exist agent process gamma 
fi gamma 
proofs propositions appendix auxiliary equivalences section describe equivalences processes approximate testing equivalence 
particular section define barbed congruence stronger relation testing equivalence easier prove directly 
strong bisimilarity recall definition strong bisimulation mil 
relation closed processes define relation closed agents iff iff closed hmip iff permutation strong simulation binary relation proc theta proc ff gamma 
exists ff gamma 
relation strong bisimulation converse gamma strong simulations 
strong bisimilarity written greatest strong bisimulation union strong bisimulations 
strong bisimilarity finegrained equivalence spi calculus 
instance discriminates processes gk wish equate explained section 
strong bisimilarity useful justifying particular steps proofs 
barbed equivalence intuitively way weakening strong bisimilarity ignore messages sent channels record channels 
informal idea leads concepts defined section 
barbed simulation binary relation proc theta proc implies barb fi fi fi exists jsj jsj means exist barbed bisimulation relation gamma barbed simulations 
barbed equivalence written delta greatest barbed bisimulation 
prove basic facts barbed equivalence appendix proposition barbed equivalence reflexive transitive symmetric 
structural equivalence implies barbed equivalence 
strong bisimilarity implies barbed equivalence 
barbed equivalence preserved restriction 
follows facts particular delta exists delta order establish barbed equivalence convenient milner standard technique bisimulation mil mpw 
barbed simulation delta binary relation proc theta proc implies barb fi fi fi exists delta delta delta delta means exist delta delta barbed bisimulation delta relation gamma barbed simulations delta generally barbed simulation delta restriction binary relation proc theta proc implies barb fi fi fi exists exist names delta delta barbed bisimulation delta restriction relation gamma barbed simulations delta restriction 
proposition barbed bisimulation delta restriction delta fortiori barbed bisimulation delta delta proof proposition appendix barbed equivalence stepping stone 
reason processes barbed equivalent strongly bisimilar testing equivalent 
barbed equivalence far congruence closed composition seen comparing 
barbed congruence barbed congruence written relation proc obtained strengthening barbed equivalence follows delta proc delta barbed equivalence barbed congruence implies testing equivalence 
wishes prove testing equivalence secrecy equation suffices prove barbed congruence 
establish properties barbed congruence appendix proposition barbed congruence reflexive transitive symmetric 
barbed congruence congruence closed processes 
structural equivalence implies barbed congruence 
strong bisimilarity implies barbed congruence 
barbed congruence implies testing equivalence 
converses implications parts hold show 
barbed congruence imply structural equivalence fairly evident 
prove establishing general property barbed congruence 
say closed process stuck ff ff gamma 
words stuck reactions barbs 
proposition stuck 
proof assuming stuck need show delta closed process holds barb reaction due 
proposition implies example case fxgk case fxgk stuck ciphertext encrypted rules structural equivalence allows derive case fxgk barbed congruence imply structural equivalence 
secondly barbed congruence imply strong bisimilarity 
instance processes gk strongly bisimilar barbed congruent prove section 
spi calculus different ccs pi calculus barbed congruence coincides strong bisimilarity ms 
hand spi calculus higher order pi calculus strong bisimilarity finer grained barbed congruence san 
thirdly testing equivalence imply barbed congruence 
setting delta mhi fn fv obtain testing equivalence 
prove equivalence appendix 
hand hold general 
barbed congruence sensitive branching structure processes testing equivalence 
underpinning relation order reason attackers knowledge introduce underpinning relation 
say gammag gammag pn underpins agent roughly agent may contain occurrences variables 
occurrences names 
write gammag gammag pn intention represents attacker variables 
represent ciphertexts attacker may intercepted encrypted keys 
attacker 
take keys names suffices purposes general case key arbitrary term interesting 
give formal definition underpinning relation 
environment finite list entries form gammag variable name variables distinct names need 
dom set variables mentioned entries keys set names mentioned entries environment term agent define iff fv dom fn keys iff fv dom fn keys relation underpinning relation 
gammag occurs environment intend stands ciphertext form fmg closure substitution fixes variables appropriate ciphertexts precisely closure substitution oe closed ciphertexts variables oe derivable rules closure closure oe dom fv gammag oe fmg represents empty environment empty substitution empty set oe fmg extension oe maps fmg prove secrecy properties show process underpinned environment acts uniformly matter ciphertexts substituted variables environment 
sight think oe oe oe oe reasoning unwrap ciphertexts oe oe behave closed 
hold presence matching language 
example gammag gammag ph oe gm oe gm meet conditions oe may output oe stuck 
act contingently ciphertexts decrypt 
insist oe oe injective xoe similarly oe obtain oe oe informal arguments lead results 
lemma suppose oe oe injective 
oe process fv fv fn fn qoe oe oe injective oe qoe 
oe ff gamma 
agent fv fv fn fn aoe oe oe injective oe ff gamma 
aoe proof lemma appendix proposition suppose oe oe oe oe injective 
oe oe pg barbed bisimulation 
proof consider commitment oe ff gamma 
lemma agent aoe oe ff gamma 
aoe barb oe exhibited oe reaction oe may matched oe barbed simulation 
symmetry barbed bisimulation 
proposition provides easy way prove equivalences demonstrate small proof familiar secrecy property 
prove gk struct extrusion proposition suffices prove delta gk fn 
follows proposition gammag oe oe fm gk 
proofs examples having defined semantics spi calculus developed proof techniques revisit examples half 
prove authenticity secrecy properties claimed examples 
proofs quite easy special purpose formalisms ban somewhat clearer status 
techniques tools proofs routine 
proofs example section example section simplest relies restricted channels 
main definitions inst delta ab ab hmi ab inst spec delta ab ab hmi ab prove authenticity property inst inst spec exhibiting simple barbed bisimulation 
proposition closed term inst inst spec 
proof commitments inst inst spec inst gamma 
ab inst spec gamma 
ab follows inst inst spec inst inst spec proposition inst inst spec proposition 
turning secrecy prove restricted version secrecy property claimed section lemma inst inst chi closed terms proof commitment inst inst gamma 
ab chi clearly inst inst 
previous proof inst inst follows 
little calculation yields full secrecy property proposition inst inst closed terms proof write inst chi inst special case chi lemma note case inst inst spec literally identical 
assuming fresh name fresh variable write chi 
closed ab chi ab commitments processes ab chi ab gamma 
ab ab gamma 
obtain equation inst spec inst chi follows inst spec ab ab hni ab ab ab hni ab ab ab hni ab chi ab ab hni ab chi inst chi making law proposition facts testing equivalence congruence proposition strong bisimilarity implies testing equivalence proposition 
equation lemma authenticity property proposition assumption justify calculation inst inst spec inst chi inst chi inst spec inst proofs example section example section main definitions delta ab delta ab case inst delta kab spec delta ab case inst spec delta kab spec example section cryptography proof authenticity simply proof strong bisimilarity 
proceed analogously example section fact inst inst spec strongly bisimilar prove inst inst spec barbed congruent 
proposition closed term inst inst spec 
proof prove inst inst spec claim follows barbed congruence implies testing equivalence proposition 
suppose arbitrary closed process arbitrary closed term 
loss generality assume kab fn 
show ab delta ab spec proposition follows kab ab delta kab ab spec kab fn inst kab ab similarly inst spec kab ab spec barbed equivalence respects structural equivalence proposition obtain inst delta inst spec definition barbed congruence conclude inst inst spec remains give proof equation 
proof oe introduce relation psq iff oe spec oe gammag kab intuitively process oe represents attacker kab prove delta barbed bisimulation 
amounts showing psq match barbs reactions 
psq exists oe spec oe gammag kab barbs ab fi oe fi 
clearly exhibits barbs 
reactions oe ab gamma 
case oe gamma 

calculate reactions commitment relation proposition 
loss generality assume names fresh 
case match reactions reactions delta case suffices show delta lemma exists gammag kab oe form hn ir oe oe gammag kab gammag kab gammag kab oe oe ciphertext encrypted kab case case case case decryption gets stuck appeal propositions get case delta delta case cases obtain delta proposition 
reactions delta spec suffices show delta delta lemma exists gammag kab oe sq jsj identical reasoning shows match barbs reactions conclude delta barbed bisimulation delta order derive equation ab hxi obtain ab oe spec oe ab spec equation follows delta proposition 
proving secrecy adopt general strategy section 
prove restricted version secrecy property lemma inst inst chi closed terms proof exactly proof proposition suffices prove equation ab delta ab hfm closed process kab fn closed terms proof equation oe oe fm introduce relation psq iff oe oe gammag kab relation oe oe gammag kab barbed bisimulation proposition 
prove delta barbed bisimulation 
amounts showing psq match barbs reactions 
psq exists oe oe gammag kab barbs ab fi oe fi 
clearly exhibits barbs oe oe barbed bisimulation 
reactions oe ab gamma 
case chi oe gamma 

proof proposition assume names fresh 
case match reactions lemma exists gammag kab oe oe ab gamma 
hn oe ir oe form hn ir oe oe gammag kab gammag kab oe ab gamma 
hn oe ir oe delta case oe chi oe suffices show delta gammag kab oe oe fm respectively oe oe ciphertexts encrypted kab case case chi chi chi oe delta chi oe case fm chi oe step chi delta chi oe justified proposition gammag kab chi 
case decryption gets stuck appeal propositions get case chi delta oe delta oe delta case oe chi oe step delta oe justified proposition gammag kab 
cases obtain delta proposition 
lemma exists gammag kab oe oe gamma 
oe delta oe clearly sq jsj proof match barbs reactions symmetric 
conclude delta barbed bisimulation delta order derive equation ab hxi obtain ab oe oe ab hfm equation follows delta proposition 
full secrecy property follows 
proposition inst inst closed terms proof proof exactly analogous proposition relies proposition lemma equation inst spec inst chi proofs example section definitions example section rephrased follows delta kab gkas ab delta case sb sb delta sb case sb delta ab case fwg spec delta sb case sb spec spec delta ab case fwg inst delta kas sb inst spec delta kas sb spec proof authenticity uses techniques section complex 
proposition closed term inst inst spec 
proof barbed congruence implies testing equivalence proposition suffices show processes barbed congruent inst delta inst spec closed process loss generality assume names kas sb kab occur free construct relation delta pairs gkas ab spec gkas ab processes barbed equivalent 
barbed equivalence closed restriction proposition follows kas sb kab gkas ab kas sb kab spec gkas ab barbed equivalent 
equation follows facts processes structurally equivalent inst inst spec respectively names kas sb kab occur free barbed equivalence respects structural equivalence proposition 
remains define relation pairs processes 
purpose environment substitution oe follows delta gammag kas gammag sb gammag kab oe delta gkas gk sb set delta delta oe spec oe fv fx gg delta oe spec oe delta kab oe spec kab oe relation pairs processes take hx ab hx relation pairs processes desired 
intuitively relation concerns state class states reachable participants protocol 
oe represents observer possession messages sent participants 
cases participants viewed part observer process 
ffl concerns initial state states reachable observer receives messages gkas ffl concerns states reachable receives message need include residue explicitly 
particular residue sb gk sb may considered part observer process oe ffl concerns states reachable receives message gk sb sb 
definition need consider states reachable receives message ab point resulting processes evidently barbed equivalent 
condition implies keys kas sb kab occurs implies fv fx depending variable occurs free observer process oe possesses ciphertext gkas gk sb respectively 
complete proof suffices establish delta purpose invoke proposition show delta barbed bisimulation delta delta identity relation closed processes 
light proposition show implies barb exhibited exhibited vice versa reaction delta delta delta vice versa 
condition obviously true implies identical structure 
show condition consider turn 
ffl suppose oe spec oe fv fx ways reaction may derived receives message gkas oe receives message oe receives message oe oe reacts 
case sb gk sb residue oe oe gamma 
gkas ic 
lemma form oe sb gk sb oe take sb gk sb spec oe obtain delta delta letting sb hx case invoke lemma showing message received ciphertext encrypted kas lemma implies oe gamma 
may assume names fresh process term oe oe 
form fn gkas kab gets stuck barbed equivalent oe propositions 
take spec oe obtain delta delta letting noting implies case invoke lemma showing time message received ciphertext encrypted sb case lemma says oe sb gamma 
may assume names fresh process term oe oe addition fv fv fv 
form fn gk sb gets stuck barbed equivalent oe propositions 
take oe obtain delta case form lemma oe fv fv 
oe take spec oe obtain delta delta ffl suppose oe spec oe ways reaction may derived receives message gk sb oe receives message oe oe reacts 
case kab residue oe oe sb gamma 
gk sb ic 
lemma form oe kab oe take spec kab oe obtain delta delta letting case invoke lemma showing message received ciphertext encrypted sb lemma implies oe sb gamma 
may assume names fresh process term oe oe 
form fn gk sb kab gets stuck barbed equivalent oe propositions 
take oe 
obtain delta case form lemma oe oe take spec oe obtain delta delta ffl suppose kab oe spec kab oe ways reaction may derived receives message oe receives message oe oe reacts 
case process oe ab gamma 
ic 
take obtaining delta case invoke lemma showing message received ciphertext encrypted kab lemma implies oe ab gamma 
may assume names fresh agent term oe oe 
form fn gets stuck barbed equivalent oe propositions 
take oe 
obtain delta case form kab lemma oe kab oe take spec kab oe obtain delta delta show similar reasoning delta delta delta prove simplified secrecy property step full secrecy property 
lemma inst inst chi closed terms proof exactly proof proposition suffices exhibit relation delta pairs gkas ab gkas ab hfm closed process names kas sb kab occur free obtain relation definitions delta gammag kas gammag sb gammag kab oe delta gkas gk sb oe delta gkas gk sb fm delta oe oe fv fx gg delta oe oe delta kab oe kab oe delta relation pairs processes take hx ab hx 
relation pairs processes 
case analysis proposition broadly similar argument obtain delta show implies barb exhibited exhibited vice versa reaction delta delta delta vice versa 
condition true implies identical structure differences substitutions affect barbs show condition consider turn 
ffl suppose oe oe fv fx ways reaction may derived receives message gkas oe receives message oe receives message oe oe reacts 
case sb gk sb residue oe oe gamma 
gkas ic 
lemma gkas ic written form hn oe sb gk sb oe take sb gk sb oe lemma oe gamma 
hn oe ir oe oe gkas oe gkas oe gamma 
gkas oe obtain delta delta letting sb hx case invoke lemma showing message received ciphertext encrypted kas lemma implies oe gamma 
may assume names fresh process term oe oe 
form fn gkas kab gets stuck barbed equivalent oe propositions 
take oe lemma oe gamma 
hn oe ir oe addition oe form fn gkas 
obtain obtain delta delta letting noting implies case invoke lemma showing time message received ciphertext encrypted sb case lemma says oe sb gamma 
may assume names fresh process term oe oe addition fv fv fv 
form fn gk sb gets stuck barbed equivalent oe propositions 
take oe lemma oe sb gamma 
hn oe ir oe addition oe form fn gk sb 
obtain obtain delta proposition oe oe injective oe oe barbed equivalence greatest barbed bisimulation 
case form oe gamma 
lemma oe fv fv 
oe take oe lemma oe gamma 
oe delta delta ffl suppose oe oe ways reaction may derived receives message gk sb oe receives message oe oe reacts 
case kab residue oe oe sb gamma 
gk sb ic 
lemma gk sb ic written form hn oe kab oe take kab oe lemma oe sb gamma 
hn oe ir oe oe gk sb oe gk sb oe sb gamma 
gk sb oe obtain delta delta letting case invoke lemma showing message received ciphertext encrypted sb lemma implies oe sb gamma 
may assume names fresh process term oe oe 
form fn gk sb kab gets stuck barbed equivalent oe propositions 
take oe 
lemma oe sb gamma 
hn oe ir oe addition oe form fn gk sb 
obtain obtain delta proposition oe oe injective oe oe barbed equivalence greatest barbed bisimulation 
case form oe gamma 
lemma oe oe take oe lemma oe gamma 
oe delta delta ffl suppose kab oe kab oe ways reaction may derived receives message oe receives message oe oe reacts 
case chi process oe ab gamma 
ic 
lemma ic written form hn oe addition oe ab gamma 
hfm ir oe take chi oe obtaining obtain delta proposition oe oe injective chi oe chi oe barbed equivalence greatest barbed bisimulation 
case invoke lemma showing message received ciphertext encrypted kab lemma implies oe ab gamma 
may assume names fresh agent term oe oe 
form fn gets stuck barbed equivalent oe propositions 
take oe 
lemma oe ab gamma 
hn oe ir oe addition oe form fn 
obtain obtain delta proposition oe oe injective oe oe barbed equivalence greatest barbed bisimulation 
case form kab oe gamma 
lemma oe kab oe take kab oe lemma oe gamma 
oe delta delta symmetry proof delta delta delta full secrecy property follows 
proposition inst inst closed terms proof argument similar proposition 
authenticity property proposition specialised secrecy property lemma prove inst spec inst chi formalisation attack section prove authenticity equation discussed section hold 
formalising replay attack sketched 
definitions sys sys spec section 
prove proposition different closed terms exists sys sys spec 
proof define new name 
definition testing equivalence suffices construct test fi sys passes fi sys spec pass fi 
fi take name occur free sys spec 
take hui hui hxi hxi process duplicates message sent message sent receives messages sends message equal 
intuitively process understood attacker replays encrypted key encrypted data signals replay attack may worked identical messages appear parallel composition sys may eventually exhibit may equal result message duplications sys passes fi 
contrast parallel composition sys spec exhibits transmitted match 
sys spec pass fi 
proofs example section section consider system server principals call 
prn metavariables range prn 
principal input channel input channels names 
server shares pair keys principal principal uses key send key si receive prn 
system parameterised list instances 
indexed set ins single abstraction process instance 
metavariable range ins instance informal description protocol message message message fi kab gk message message nb message fs kab nb gk sj message rephrase formal description protocol definitions delta hii delta kab fi delta prn hn delta case fz gk prn delta hi delta hfs sj delta nb nb delta case fy gk sj prn delta case sys delta prn sj prn ins prn rephrase specification spec delta spec delta phi sys spec delta prn sj prn ins spec prn spec section prove stated authenticity secrecy properties sys sys spec instances 
sys sys jm pair 
jm indistinguishable 
proposition instances sys sys spec proof list instances ins reducing problem involving finite compositions replications give bisimulation proof reduction 
group replications sys sys spec proposition sys prn sj prn ins prn sys spec prn sj prn ins spec prn spec apply proposition right hand sides proposition implies prove sys sys spec suffices prove spec delta prn sj prn ins prn spec delta prn sj prn ins spec prn spec eliminated replications 
reformulate pulling restrictions top level inserting certain additional steps 
purpose auxiliary definitions delta hii delta fi delta prn hni delta hni lemmas yield kab kab kab kab nb nb equation yields spec kab kab introduce sets names fp fn ss rg prn rg names listed assumed distinct fresh 
short abstraction obtain prn sj prn kabk ins ss nbjt prn ins kabk ss prn nbjt spec prn sj prn ins kabk ins ss nbjt prn ins kabk ins ss prn spec nbjt proof steps 
expose restrictions processes spec rewriting equations 
second rules structural equivalence group restrictions top level processes 
third law proposition insert step call 
step useful corresponds interaction precedes call spec 
reduced property claimed proposition equation turn reduced equation equivalence right hand sides equations arbitrary number 
prove equivalence invoke proposition show composed closed process right hand sides barbed bisimilar 
loss generality may assume names bound outermost restrictions occurs free structural equivalence barbed equivalence may scope restrictions include barbed equivalence preserved restriction proposition suffices prove processes barbed equivalent ins kabk ss prn nbjt ins ins kabk ins ss prn spec nbjt closed sj kabk ss nbjt occurs free 
removed outermost restrictions sake notational simplicity 
hand necessary retain restriction simplified process input barbs matched process 
remainder proof consists constructing relation jsj relates processes establishing barbed bisimulation delta restriction processes barbed equivalent 
lead definition preliminary definitions ffl world tuple snd srv rcv oe oe spec environment oe oe spec substitutions process ins snd srv rcv finite maps snd fa sent closed terms srv fs stuck sent prn ins closed terms rcv fb stuck run done ins prn theta symbols sent stuck stuck run done string tags short pair sent pair sent similarly tags 
intuitively just instance may complete protocol 
maps snd srv rcv represent states senders servers receivers respectively participate protocol 
ffl world snd srv rcv oe oe spec ins prn theta define processes spec spec delta kabk snd spec delta kabk snd delta ss srv ss srv kabk srv delta nbjt rcv nbjt rcv kabk rcv rcv run spec delta spec nbjt rcv spec nbjt rcv spec kabk rcv hi rcv run intuitively process sender left run state snd 
similarly context specification spec process sender left run state snd process include treated separately 
definitions deal analogously replicas server receivers 
world snd srv rcv oe oe spec ins prn theta roe ins ins spec prn theta spec roe spec intuitively process system left run state described corresponding process specification 
ffl world maps snd srv rcv define instance sets subsets ins ins iff snd iff prn snd sent ss ss srv fs iff srv iff srv sent nbjt nbjt rcv fb iff rcv iff rcv run intuitively message protocol numbered received instance instance set represents instances having completed protocol step away running ffl world snd srv rcv oe oe spec possible conditions hold sets pairwise disjoint 
union subset 
ins terms srv srv sent snd sent ss ss 
ins prn rcv rcv run exists srv sent nbjt nbjt 
ins terms name snd sent implies 
ins terms name srv sent implies 
environment gammag ins snd sent gammag kabk ins snd sent gammag sj srv sent substitution oe fi kabk ins snd sent ins snd sent fs kabk sj srv sent substitution oe spec fi kabk gk ins snd sent fp ins snd sent fs kabk gk sj srv sent process contains free occurrence names sj kabk satisfies ffl define relation follows delta possible world wg possible world snd srv rcv oe oe spec conditions imply oe oe spec determined components world oe oe spec hold 
oe injective show 
suppose variables oe maps term 
oe maps variables ciphertexts keys disjoint families distinguish possible cases ffl ins 
oe form fi kabk oe textually contains kabk similarly oe textually contains kabk position 
ffl ins 
oe form oe textually contains kabk similarly oe textually contains kabk position 
ffl ins oe fs kabk sj srv sent 
oe oe exists srv sent 
condition obtain snd sent ss ss snd sent ss ss 
oe maps variables term oe injective 
argument oe spec injective 
consider world snd srv rcv ins delta ins hii snd ins srv rcv prn theta conditions possible satisfied 
particular equal ins instance sets empty 
furthermore processes related structurally equivalent processes respectively 
show delta follow processes barbed equivalent 
prove delta rely proposition show barbed bisimulation delta restriction 
prove possible world snd srv rcv oe oe spec barb exhibited exhibited vice versa reaction possible world names delta delta vice versa 
treat conditions symmetric conditions established symmetric treatment 
condition holds identical structure names appear process occurring outermost restriction prevents exhibited barbs 
show condition recall ins prn theta roe ins ins spec prn theta spec roe spec usual appeal proposition order analyse reactions terms possible commitments 
processes input commitments arbitrary process roe may input output commitments 
reaction arise ways interaction output commitment roe ff gamma 
hl ir input commitment kinds process kabk ins snd ss srv ss srv kabk srv nbjt prn theta rcv nbjt prn theta rcv kabk prn theta rcv commitment gamma 
rcv run commitment roe gamma 
case may assume bound names fresh 
possible follows oe oe spec oe oe injective substitutions 
commitment roe ff gamma 
hl ir lemma guarantees agent fv fv fn fn hl ir aoe roe spec ff gamma 
aoe spec hl ir aoe follows hl ir oe oe 
examine input commitments kinds process ordered enumeration messages informal description protocol exhibit case possible world delta delta names generated commitment reaction ins prn oe hn ss ss prn theta oe arises ff input commitment ss gamma 
prn hn ss ss srv argue cases prn oe prn oe simplify follows ins ss prn theta hn ss oe set snd srv rcv oe oe spec hn ss srv identical srv srv 
definition form oe oe implies oe spec 
remains prove world possible 
conditions instance sets hold instance sets equal possible 
conditions concern servers states sent hold continue hold servers entered states 
conditions continue hold senders receivers changed state 
conditions concerning oe oe spec hold possible senders entered left sent state servers entered left sent state 
condition hn ss contains free occurrence names sj kabk hn ss holds condition holds know fn hl ir fn names fresh hl ir possible world 
prn oe simplify follows delta ins prn theta oe set snd srv rcv oe oe spec srv identical srv srv stuck definition delta form oe oe spec oe implies oe spec prn 
letting delta ins ins spec prn oe spec hn ss ss prn theta spec oe spec obtain delta case remains show world possible 
conditions concern instance sets fk snd sent ss ss follows instance sets equal conditions hold hold rest proof world possible case prn oe 
reaction ins fi kabk oeg prn theta oe arises ff input commitment kabk gamma 
fi kabk ins snd 
set snd srv rcv oe oe spec hx snd identical snd snd sent oe oe spec delta gammag gammag kabk oe delta oe fi kabk oeg oe spec delta oe spec fi kabk oe spec gk definition 
remains show world possible 
consider instance sets equal gamma fkg fkg prn oe oe spec ss srv fs conditions hold hold condition holds names range oe oe spec name oe oe spec oe oe spec conditions hold follows easily continue hold 
reaction ins prn theta oe oe case fz gk prn ss hi arises ff input commitment ss gamma 
case fz gk prn ss hi srv 
argue cases oe pair component second component ciphertext containing ss field 
condition oe component component 
similarly fn fn ng second component oe ciphertext containing ss second component variable ins snd sent ss case second component oe fi kabk ss gk 
oe determines uniquely presence kabk condition ss snd sent ss ss form oe oe spec equal fi kabk ss gk 
conversely form oe spec determines form oe 
assuming oe pair form described simplify follows ins prn theta kabk oe hi defined explained 
set snd srv rcv oe oe spec hi srv identical srv srv 
definition 
remains show world possible 
instance sets equal gamma fk snd sent ss ss fkg particular conditions hold conditions hold follows easily continue hold condition fact snd sent ss ss 
hand oe form described simplify follows delta ins prn theta oe set snd srv rcv oe oe spec srv identical srv srv stuck definition delta letting delta ins ins spec oe spec prn theta spec oe spec omitted code gets stuck obtain delta case easy check world possible 
instance sets equal fk snd sent ss ss 
reaction ins prn theta gammaf nbjt oe arises ff input commitment nbjt gamma 
nbjt prn theta rcv set snd srv rcv oe oe spec rcv identical rcv rcv definition 
possible world particular instance sets equal reaction ins prn theta hfs kabk oeg sj oe arises ff input commitment kabk gamma 
hfs kabk sj srv 
set snd srv rcv oe oe spec hz srv identical srv srv sent oe oe spec delta gammag sj oe delta oe fs kabk oeg sj oe spec delta oe spec fs kabk oe spec gk sj definition 
remains show world possible 
note srv srv condition 
instance sets equal gamma fkg fkg unimportant conditions hold satisfies conditions trivially 
condition implies snd sent ss ss follows condition holds condition holds names ranges oe oe spec name oe oe spec oe oe spec conditions easy consequences corresponding conditions reaction ins prn theta gammaf oe case oe fy gk sj prn nbjt arises ff input commitment nbjt gamma 
case fy gk sj prn nbjt prn theta rcv argue cases oe ciphertext sj containing nbjt field 
condition fn fn ng oe ciphertext sj containing nbjt variable srv sent nbjt case oe fs kabk sj 
oe determines uniquely presence kabk condition nbjt srv sent nbjt nbjt oe oe spec equal fs kabk sj conversely form oe spec determines form oe 
assuming oe form described simplify follows ins prn theta gammaf kabk oe set snd srv rcv oe oe spec rcv identical rcv rcv 
definition 
remains check world possible 
instance sets equal gamma fk srv sent nbjt nbjt fkg particular conditions hold conditions hold follows easily continue hold condition holds srv sent nbjt nbjt 
hand oe form described simplify follows delta ins prn theta gammaf oe set snd srv rcv oe oe spec rcv identical rcv rcv stuck definition delta letting delta ins ins spec prn theta gammaf spec case oe fy gk sj oe spec omitted code gets stuck obtain delta case easy check world possible 
instance sets equal gamma fk srv sent nbjt nbjt 
reaction ins prn theta gammaf oe oe case arises ff input commitment kabk gamma 
case ins prn theta rcv argue cases oe pair component second component ciphertext kabk condition oe component component 
similarly fn fn ng second component oe ciphertext kabk second component snd sent case second component oe form oe equals oe spec equals fp 
conversely form oe spec determines form oe 
assuming oe pair form described simplify follows ins prn theta gammaf oe set snd srv rcv oe oe spec rcv identical rcv rcv run 
definition 
order check world possible consider instance sets argue suffices show rcv fact condition says exists srv sent nbjt nbjt rcv exists srv sent nbjt nbjt 
condition says snd sent ss ss snd sent ss ss 
conclude obtain instance sets equal gamma fkg fkg conditions hold conditions hold follows easily continue hold hand oe form described simplify follows delta ins prn theta gammaf oe set snd srv rcv oe oe spec rcv identical rcv rcv stuck definition delta letting delta ins ins spec prn theta gammaf spec oe oe spec omitted code gets stuck obtain delta proof possible identical just case change completes case 
case reaction ins prn theta gammaf roe arises commitment gamma 
prn theta rcv run ins 
note rcv run implies set snd srv rcv oe oe spec rcv identical rcv rcv done gamma fkg 
definition ins ins prn theta spec roe spec ins ins prn theta gammaf spec hi roe spec 
ins ins prn theta gammaf spec roe spec order check world possible argue suffices show rcv run fact condition says exists srv sent nbjt nbjt rcv run exists srv sent nbjt nbjt 
condition says snd sent ss ss snd sent ss ss 
conclude obtain instance sets equal gamma fkg conditions hold conditions hold follows easily continue hold condition rely fact closed process contain free occurrences names sj kabk 
abstraction contain free occurrences names general convention bound parameters protocol occur free term part arguments sys sys spec case reaction ins prn theta arises commitment roe gamma 
lemma implies process fv fv fn fn oe roe spec gamma 
oe spec set snd srv rcv oe oe spec definition possible world 
concludes proof authenticity property proposition 
proposition strong obtain secrecy property corollary proposition pair 
jm indistinguishable sys sys jm proof pair indistinguishable 
fact testing equivalence congruence proposition obtain spec spec pair 
jm indistinguishable propositions permit calculation sys sys spec prn sj prn ins spec prn spec prn sj prn ins spec prn spec sys spec jm sys jm completes proof secrecy property 
cryptographic primitives far discussed shared key cryptography kinds cryptography easy treat spi calculus 
section show handle cryptographic hashing public key encryption digital signatures 
add syntax operations spi calculus give semantics 
provide evidence ideas applicable wide range security protocols rely shared key encryption 
believe may able deal similarly techniques secret sharing 
protocols oblivious transfer zero knowledge proofs example probably scope approach 
hashing cryptographic hash function properties expensive recover input image find inputs image 
functions sha ripe md generally believed properties sch 
represent hash functions spi calculus pretend operations expensive altogether impossible 
simply add construct syntax terms spi calculus terms section hashing syntax processes unchanged 
intuitively represents hash absence construct recovering corresponds assumption inverted 
lack equations corresponds assumption free collisions 
public key encryption digital signatures traditional public key encryption systems key pairs 
normally keys pair private principal key public 
principal encrypt message public key principal private key decrypt message 
assume key recovered 
just easily deal case public key derived private 
section assume way decrypt encrypted packet know corresponding private key encrypted packet reveal public key encrypt sufficient redundancy messages decryption algorithm detect ciphertext encrypted expected public key 
arrive syntax spi calculus public key encryption 
syntax concise memorable 
terms section public part gamma private part public key encryption processes section case decryption represents key pair represents public half gamma represents private half 
public key term represents result public key encryption case variable bound construct useful private key gamma binds exists 
common key pairs digital signatures 
private keys signing public keys checking signatures 
represent digital signatures extended syntax terms fmg private key signature processes case fxg signature check private key term fmg represents result signature variable bound construct case fxg construct dual case new construct useful public key binds fmg gamma exists 
assuming recovered result signing difficulty dropping assumption 
formally semantics new constructs captured new rules reduction relation red public decrypt case gamma red signature check case fmg gamma fxg believe basic theoretical results spi calculus apply 
small example write public key analogue protocol section delta ab hf fh gamma delta ab case gamma case fzg inst delta ka kb protocol sends channel ab signed private key encrypted public key signature applied hash 
receipt message ab decrypts private key checks signature public key checks hash applies body message 
key pairs ka kb restricted harm sending public parts public channel 
undoubtedly formalisations public key cryptography possible desirable 
particular represented cryptographic operations level attempt model closely properties algorithm 
concerned public key encryption digital signatures general rsa implementations say 
rsa system satisfies equations formalisation capture 
example rsa system ff gamma equals leave treatment equations 
applied standard pi calculus new spi calculus description analysis security protocols 
examples chose protocols sort commonly authentication literature 
showed represent protocols express security properties prove properties 
model protocols takes account possibility attacks require writing explicit specifications attacker 
particular express secrecy properties simple equations mean indistinguishability point view arbitrary attacker 
knowledge sharp treatment attacks previously possible 
examples small instructive 
techniques developed may amenable automation experience process algebras encouraging 
fundamental difficulty writing kinds examples protocols electronic commerce 
unfortunately specifications protocols fully understood informal terms mao 
pi calculus spi calculus restriction scope extrusion play central role 
pi calculus provides treatment channels spi calculus expresses cryptographic operations usually underlie channels systems distributed security 
pi calculus spi calculus appropriate different levels 
levels related 
particular discussed briefly specify security protocol abstractly implement cryptography 
similarly may give api application programming interface secure channels implement top api cryptography 
formal terms possible define cryptographic implementations pi calculus translating restricted channels public channels encryption 
implementation relations useful practice worth studying 
peter sewell phil wadler suggested improvements draft 
appendices encoding encryption pi calculus inventing spi calculus considered rejected schemes encoding encryption pi calculus 
obvious idea represent keys channels encrypted communication communication restricted channels 
scheme works reasonably examples clear turn general encoding 
example straightforward represent data encrypted keys 
milner shown represent piece data process located channel process listening channel second scheme encoding encryption extends milner idea 
pi calculus abstraction process abstracted name represents data 
represent encrypted located abstraction delta channel right hand side process inputs pair channel key runs abstracted variable instantiated 
words offers access provide secret key represent abstraction attempts decrypt encrypted datum located locates result parameter follows decrypt delta mh locate abstractions names obtain reactions decrypt representation certainly prevents anybody accessing know allows attacks agent possesses secret key transmit process representing encrypted data 
simple scheme described attacker impersonating encrypted data obtaining corresponding secret key 
decryption guarantee message returned really encrypted secret key 
attacker masquerade piece encrypted data provide incorrect message asks 
third scheme mild extension pi calculus channels may multi names tuples names 
modify encoding encrypted process inputs multi name channel 
decryption amounts sending multi name 
synchronisation pair guarantees simultaneously parties know location data secret key attacks longer possible 
scheme attractive enables remain close standard pi calculus 
unfortunately scheme account protocols keys hashing data instance 
fourth scheme relies process global cryptographic device gcd short trusted participants gcd mediates encryption decryption global list encrypted messages 
scheme private channel participant gcd participant invoke encryption decryption 
decrypt message participant send necessary secret key gcd purported encrypted message 
reluctant pursue scheme complexity 
having syntax processes data spi calculus gives advantages schemes 
avoid having encode data processes 
addition axiomatise encryption decryption shared key public key cryptography directly operational semantics 
higher level approach appears convenient approach encodings retaining fundamental ideas pi calculus 
proofs commitment section prove propositions section connect relations reaction commitment exhibition barb 
lemma relates free names process free names agent commits 
lemma gamma 
fn fn 
gamma 
fmg fn fn 
gamma 
fmg fn fn ng fn 
proof induction derivation commitment 
purpose lemma show gamma 
implies half proposition 
lemma gamma 
names pg closed 
gamma 
names pg fn pg 
gamma 
proof case induction derivation commitment key fact need direction proposition structural equivalence strong bisimulation 
lemma implies ff gamma 
ff gamma 
ff gamma 
ff gamma 
structural equivalence strong bisimulation 
proof induction derivation consider possibility instance basic equations structural equivalence 
show representative cases 
struct switch case trivial 
case distinct examine commitments determine commitments ffl gamma 
fm ng commitment 
commitments gamma 
gamma 
closed done 
ffl gamma 
commitments gamma 
gamma 
ffl gamma 
may assume set bound names ng disjoint fm ng 
fm ng commitment 
commitment gamma 
hmi fv fv gamma 
hmi fv fv gamma 
hmi fv fv gamma 
fv fv 
case commitment matches commitment case gamma 
definition allows restricted names permuted 
permutation allowed struct switch prevent structural equivalence strong bisimulation 
cases lemma parts follow 
struct drop 
commitments trivially satisfy parts 
cases struct nil struct comm simple 
cases struct extrusion struct assoc involve larger case analyses harder cases shown 
second consider possibility obtained inference rules structural equivalence 
struct red inspecting definition reduction relation see commitment rule applies comm red 
ff ff gamma 
iff ff gamma 
reflexive parts follow 
struct refl parts follow 
struct symm obtained part induction hypothesis supplies part proved part induction hypothesis supplies part 
struct trans obtained intermediate process part suppose ff gamma 
induction hypothesis implies agent ff gamma 
induction hypothesis implies agent ff gamma 
transitive completing proof part 
part follows symmetry 
struct par obtained part suppose ff gamma 
cases consider 
comm inter ff gamma 
gamma 

induction hypothesis exists gamma 
closed 

comm inter gamma 
processes 
comm inter ff gamma 
hmip gamma 

induction hypothesis exist gamma 
permutation 
comm inter gamma 
struct switch struct res comm par ff gamma 
induction hypothesis exists ff gamma 
comm par ff gamma 
processes abstractions concretions implies 
comm par ff gamma 
comm par ff gamma 
process abstraction concretion implies completes proof part part follows symmetry 
struct res obtained symmetry need consider part 
suppose ff gamma 
rule comm res yield commitment restriction 
ff gamma 
ff fm mg induction hypothesis ff gamma 
struct res ff gamma 
processes abstractions concretions implies part follows 
prove propositions claimed section 
proof proposition fi iff fi gamma 

proof entirely trivial relation defined structural equivalence transition relation fi gamma 

easily show fi gamma 
implies fi induction derivation fi gamma 
barb struct necessary 
hand show fi implies fi gamma 
induction derivation fi 
case barb struct needs fact fi gamma 
fi gamma 
follows lemma 
proof proposition iff gamma proof backwards direction suppose gamma 
lemma react struct 
show implies exists gamma 
induction derivation interesting case react struct 
suppose follows induction hypothesis gamma 
lemma structural equivalence strong bisimulation gamma 
previous equations gives required 
proof proposition passes test fi iff exist agent process gamma 
fi gamma 
proof definition passes test fi iff fi holds iff fi barb struct lemma propositions equivalent gamma 
fi gamma 
proofs replication section devoted lemmas concerning interaction replication commitment reaction convergence 
lemma gamma 
gamma 
closed 
gamma 
gamma 
gamma 
gamma 
proof induction derivation gamma 
commitment derived gamma 
comm red red repl 
commitment derived comm par comm par 
case gamma 
done 
second case gamma 
induction hypothesis gamma 
closed closed done 
induction derivation gamma 

commitment derived gamma 
comm red red repl 
commitment derived comm par comm par 
case immediately gamma 
second case gamma 
induction hypothesis gamma 

induction derivation gamma 
commitment derived gamma 
comm red red repl 
rules yield commitment 
comm par gamma 
may derive gamma 
comm par 
comm par gamma 
induction hypothesis gamma 
done 
comm inter gamma 
gamma 
hmip 
part gamma 
comm inter gamma 
calculate step uses struct extrusion fact may assume bound names ng occur free 
comm inter gamma 
hmip gamma 

part gamma 
comm inter gamma 
calculate step uses struct extrusion fact may assume bound variable bound names ng free completes proof part 
intuitively part states reaction obtained copies running parallel 
pierce sangiorgi ps remarked strengthen part require copy stronger property fail extended language choice construct 
claim copies remain true extended language 
lemma suppose gamma 
gamma 
proof case analysis rules yield gamma 

comm par gamma 
lemma gamma 
comm par gamma 

comm par gamma 
comm par twice gamma 
comm inter gamma 
gamma 

lemma gamma 

comm par comm inter gamma 
may assume bound names ng bound variable occur free 
comm inter gamma 
hmip gamma 

lemma gamma 
hmip 
comm par comm inter gamma 
mean delta delta delta processes 
lemma 
fi fi 
proof induction case assume claim holds prove 
suppose induction hypothesis proposition implies gamma 
lemma follows gamma 
proposition follows react par obtain fi fi 
previous part fi fi lemma proposition 
react par obtain fi fi 
proposition 
proof assume 
consider arbitrary test fi suppose passes test fi 
may assume loss generality bound names occur fi 
lemmas exists fi 
hypothesis fi 
lemma yields fi passes fi 
passes tests 
symmetrically passes tests 
conclude 
proposition proof prove suppose fi arbitrary test fi 
lemma exists fi 
lemma fi 
lemma fi 
lemma fi 
passes tests 
second prove 
suppose fi arbitrary test fi 
applying lemma twice obtain exist fi 
lemma fi lemma yields fi 
passes tests proofs equivalences testing equivalence auxiliary facts needed proofs section 
lemma fi imply fi 
fi implies fi 
gamma 
gamma 

fi fi fi fm mg 
fi iff fi fi fm mg 
proof analysis rule derivation fi 
case conv barb fi 
barb struct fi 
conv barb fi 
case conv react fi 
react struct conv react fi 
induction derivation fi rules barb par react par 
comm res rule yield gamma 
gamma 

proposition fi gamma 
commitment derived comm res fi gamma 
fi fm mg 
proposition obtain fi 
suppose fi fi fm mg 
fi 
proposition gamma 
repeated comm res gamma 

proposition fi barb res 
fi 
fi fi 
proposition gamma 
repeated part gamma 
barb struct fi implies fi part yields fi fi fm mg 
gamma 
implies proposition combining fi obtain fi 
lemma 
proof lemma says fi fi 
result follows definition terms 
relation closed processes open extension ffi relation arbitrary processes pr ffi oe qoe substitution oe closed terms variables oe qoe closed 
congruence closed processes equivalence relation closed processes implies closed context similarly congruence open processes equivalence relation open processes implies context notion precongruence analogous precongruence preorder equivalence relation 
give alternative characterisation congruence precongruence avoids contexts 
relation open processes compatible refinement relation open processes rules 
lemma suppose preorder 
precongruence closed arbitrary contexts iff see gor proof similar proposition 
lemma open extension testing equivalence ffi congruence 
proof ffi clearly preorder suffices show ffi ffi open processes assume ffi prove ffi proof show test fi substitution oe free variables oe passes fi oe passes fi 
proposition suffices assume comp hni hni comp comp par comp res comp repl comp match comp nil comp split comp case suc case suc comp decrypt case case rules compatible refinement exist process agent oe gamma 
fi gamma 
prove exist process agent oe gamma 
fi gamma 
argument case analysis rules define ffi 
comp suppose ffi exist agent process oei oe gamma 
fi gamma 
examining definition commitment relation distinguish cases ffl oe fi oe fi gamma 
hn simply oe hn ffl gamma 
fi gamma 
oe oe ffl gamma 
commitment oe gamma 
abstraction oe oe gamma 
proposition implies oe passes test oe 
ffi obtain qoe passes test oe 
proposition exist qoe oe gamma 
fi gamma 
gamma 
oe gamma 
qoe oe gamma 
imply oe gamma 

comp suppose ffi loss generality assume oe defined 
exist agent process oe oe gamma 
fi gamma examining definition commitment relation distinguish cases ffl oe fi oe fi gamma 
qoe simply oe qoe ffl gamma 
fi gamma 
oe oe ffl gamma 
commitment oe gamma 
delta delta delta concretion delta delta delta delta delta delta oe gamma 
lemma form delta delta delta oe gamma 
proposition lemma fi fi fm proposition implies oe passes test ffi obtain qoe passes test proposition exist qoe gamma 
fi gamma 
delta delta delta obtaining delta delta delta qoe gamma 
fi gamma 
gamma 
oe gamma 
delta delta delta delta delta delta qoe gamma 
imply oe gamma 

comp par suppose ffi ffi oe passes fi oe passes oe fi 
ffi obtain oe passes oe fi 
equivalently oe passes oe fi 
ffi obtain oe passes oe fi 
oe passes fi 
comp res suppose ffi may assume bound name occur free oe oe 
oe passes fi oe fi 
lemma follows oe fi 
lemma follows oe fi fi fn ng 
ffi obtain qoe fi 
lemma follows qoe fi 
lemma conclude oe fi 
oe passes fi 
comp repl suppose ffi oe fi 
lemma oe fi 
case comp par follows qoe fi 
lemma obtain qoe qoe fi 
qoe qoe qoe conclude qoe fi lemma oe passes fi 
comp match suppose ffi oe oe equal oe oe oe qoe result follows lemma assumption ffi oe oe stuck barbed congruent proposition proposition follows oe oe 
comp nil suppose 
reflexive oe oe ffi 
comp decrypt suppose case case ffi loss generality assume oe defined 
oe fn gm oe oe oe oe qoe result follows lemma assumption ffi oe oe stuck barbed congruent proposition proposition follows oe oe 
cases comp split comp similar 
obtain proof proposition structural equivalence implies testing equivalence 
testing equivalence reflexive transitive symmetric 
testing equivalence congruence closed processes 
proof structural equivalence implies testing equivalence said lemma 
relation closed processes ffi congruence open processes congruence closed processes 
remainder section concerns testing equivalences reasoning protocols 
proposition closed process proof show proposition passes test fi gamma 
fi 
induction length computation gamma 
show computation gamma 
fi 
passes test fi 
roughly speaking second computation copy contributes reacting include gamma 
second computation proceed computation 
similar argument lemma fv fxg distinct names proof just commitment abstraction gamma 
gamma 
strongly bisimilar testing equivalent proposition 
lemma name possibly open term fn ig set distinct closed terms fp ig set possibly open processes finite set indices 
ffi proof definition ffi suffices consider substitution instances claimed equivalence 
show terms processes closed propositions 
hand proposition 
testing equivalent fn ig barbed equivalence proof proposition barbed equivalence reflexive transitive symmetric 
strong bisimilarity implies barbed equivalence 
structural equivalence implies barbed equivalence 
barbed equivalence preserved restriction 
proof usual show identity relation barbed bisimulation composition barbed bisimulations yields barbed bisimulation converse barbed bisimulation barbed bisimulation 
show strong bisimilarity barbed bisimulation 
propositions easy 
lemma structural equivalence strong bisimulation 
part contained barbed equivalence 
suffices show delta qg barbed bisimulation 
proof straightforward 
proof proposition barbed bisimulation delta restriction delta fortiori barbed bisimulation delta delta proof prove proposition generalisation standard technique mpw alternative modular framework developed sangiorgi san 
construct relation larger show barbed bisimulation 
relation defined delta delta 
delta delta observe enjoys properties star star res star delta delta delta property star follows easily definition reflexivity delta 
property star res holds implies delta delta delta delta implies delta delta turn implies property star delta holds delta delta implies delta delta delta delta transitivity delta delta delta order establish barbed bisimulation prove induction delta delta implies barb fi fi fi exists base case delta delta 
suppose fi 
delta fi 
fi definition barbed bisimulation delta restriction 
delta fi 
suppose delta delta definition barbed bisimulation delta restriction names delta delta star star res star delta delta delta delta delta obtain star delta 
inductive case delta delta exist delta delta delta delta 
suppose fi 
delta fi 
fi fi fm mg 
induction hypothesis delta delta implies fi 
fi fm mg fi 
delta fi 
suppose delta delta lemma proposition induction hypothesis react res 
delta delta star res delta delta obtain star delta 
completes proof induction 
definition yields barbed bisimulation delta star conclude delta barbed congruence main task section show ffi ffi follows ffi congruence 
adaptation proof pierce sangiorgi ps 
lemmas concerning replication commitment 
lemma ffi ffi proof need show ffi implies oe delta oe closed substitution oe fv fv dom oe 
analysis comp gamma rule derive ffi 
comp ffi oe oei oe oe oei qoe 
relation oe oe rg equation follow show delta barbed bisimulation 
clearly oe oe barbs 
rules commitment see oe commitment interaction oei oe case oe match commitment delta respectively 
comp ffi oe oe oe oe oe qoe bound may assume dom oe 
previous case set oe oe rg show delta barbed bisimulation follows similar argument 
comp par assumptions ffi ffi properties barbed equivalence proposition calculate equation follows 
oe oe oe oe delta oe oe oe oe delta oe oe oe oe comp res assumption ffi proposition calculation equation 
oe oe delta qoe qoe comp repl ffi prove oe qoe rg barbed bisimulation delta equation follow proposition 
clearly sides barbs 
consider reaction oe lemma process reaction oe oe oe assumption ffi calculate 
qoe qoe qoe delta oe qoe qoe qoe oe delta oe qoe oe qoe oe oe qoe definition delta reaction qoe delta qoe oe qoe delta satisfied condition bisimulation delta 
comp match ffi oe oe oe oe oe qoe rg 
equation follows easily showing delta barbed bisimulation 
comp decrypt case case ffi bound may assume dom oe oe case oe oe case qoe 
oe oe rg 
easy see delta barbed bisimulation equation holds 
cases comp nil comp split comp similar 
prove basic facts barbed congruence claimed section 
proof proposition barbed congruence reflexive transitive symmetric 
barbed congruence congruence closed processes 
structural equivalence implies barbed congruence 
strong bisimilarity implies barbed congruence 
barbed congruence implies testing equivalence 
proof delta equivalence relation 
lemma yields open extension barbed congruence ffi congruence open processes 
follows barbed congruence congruence closed processes 
follows part know lemma structural equivalence implies strong bisimilarity 
suffices check relation barbed bisimulation strongly omit routine proof involves commitment relation analyse possible barbs reactions showing match 
suppose consider test fi 
definition barbed congruence delta 
fi implies fi 
proofs underpinning need fact underpinning injective substitutions 
lemma suppose oe 
oe injective oe oe implies proof induction structure ffl suppose variable dom oe 
oe xoe ciphertext say fm gk keys 
fn 
oe fm gk variable dom oe xoe 
oe injective ffl suppose name set names defined distinct set variables oe similarly oe follows ffl suppose ciphertext fm gm oe fm oeg oe oe 
variable dom oe fn gn oe oe 
induction hypothesis required 
suppose xoe ciphertext fn gk oe oe oe oe keys 
fn fm gk contradiction 
ffl suppose pair 
oe oe oe range oe includes ciphertexts 
previous case oe oe 
induction hypothesis required 
cases suc similar 
proof lemma suppose oe oe injective 
oe process fv fv fn fn qoe oe oe injective oe qoe 
oe ff gamma 
agent fv fv fn fn aoe oe oe injective oe ff gamma 
aoe proof analysis rules may yield oe 
red decrypt case oe fm gn oe roe may assume bound variable domain range oe 
oe fm gn oe variable dom oe ciphertext fm gm case fm gn oe oe member keys name say range oe consists ciphertexts name keys fn contradicts assumption fm gm follows oe oe oe 
lemma 
follows 
fv fv fv fv fn fn fn fn 
injective oe oe oe case fm oe gn oe oe roe roe oe oe oe qoe required 
red match oe oe qoe 
lemma follows 
part fv fv fn fn 
injective oe oe oe oe oe qoe qoe required 
cases routine ciphertext range oe 
induction derivation oe ff gamma 

comm oe ff qoe may assume bound variable domain range oe 
oe name name ciphertexts range oe 
follows 
fv fv gamma fxg fv fn fn fn 
qoe aoe 
injective oe oe oe qoe gamma 
qoe aoe required 
comm inter oe gamma 
oe gamma 
ff induction hypothesis oe fv fv fn fn oe gamma 
oe injective oe oe induction hypothesis coe fv fv fn fn oe gamma 
coe injective oe oe interaction defined commutes substitution aoe oe coe follows fv fv fv fv fv fv fn fn fn fn fn fn 
injective oe oe oe oe oe gamma 
oe coe oe commitment follows comm inter facts oe gamma 
oe oe gamma 
coe obtained oe gamma 
aoe required 
comm red oe ff gamma 
part fv fv fn fn qoe oe qoe injective oe oe qoe ff gamma 
induction hypothesis fv fv fn fn aoe qoe ff gamma 
aoe oe transitivity fv fv fn fn 
injective oe oe obtained oe qoe qoe ff gamma 
aoe comm red oe ff gamma 
aoe required 
case comm similar comm 
case comm inter comm inter 
comm par comm par comm res simple uses induction hypothesis 
lemma hold spi calculus mismatch operator mentioned section 
case mismatch part red match similar appeal lemma 
ablp abadi burrows lampson plotkin 
calculus access control distributed systems 
acm transactions programming languages systems 
abadi needham 
prudent engineering practice cryptographic protocols 
ieee transactions software engineering january 
ban burrows abadi needham 
logic authentication 
proceedings royal society london 
preliminary version appeared digital equipment systems research center report february 
bb berry boudol 
chemical machine 
conference record seventeenth acm symposium principles programming languages pages 
bn boreale de nicola 
testing equivalence mobile processes 
information computation august 
br bellare rogaway 
provably secure session key distribution party case 
proceedings th annual acm symposium theory computing 
des data encryption standard 
fed inform 
processing standards pub 
national bureau standards washington dc january 
dh diffie hellman 
new directions cryptography 
ieee transactions information theory november 
dh de nicola hennessy 
testing equivalences processes 
theoretical computer science 
dy dolev yao 
security public key protocols 
proc 
th ieee symposium foundations computer science pages 
gm gray mclean 
temporal logic specify verify cryptographic protocols progress report 
proceedings th ieee computer security foundations workshop pages 
gor gordon 
bisimilarity theory functional programming 
mini course 
brics notes series ns brics aarhus university 
full version mfps 
hoa hoare 
communicating sequential processes 
prenticehall international 
kem kemmerer 
analyzing encryption protocols formal verification techniques 
ieee journal selected areas communications 
lampson abadi burrows wobber 
authentication distributed systems theory practice 
acm transactions computer systems november 
lie 
authentication distributed systems bibliography 
acm operating systems review 
low lowe 
breaking fixing needham schroeder public key protocol fdr 
tools algorithms construction analysis systems volume lecture notes computer science pages 
springer verlag 
mao mao 
proposals line payments open networks problems solutions 
ieee symposium security privacy pages 
mcf millen clark freedman 
interrogator protocol security analysis 
ieee transactions software engineering se february 
mea meadows 
applying formal methods analysis key management protocol 
journal computer security 
mil milner 
communication concurrency 
prentice hall international 
mil milner 
functions processes 
mathematical structures computer science 
mil millen 
interrogator model 
ieee symposium security privacy pages 
mil milner 
calculus 
undergraduate lecture notes cambridge university 
mpw milner parrow walker 
calculus mobile processes parts ii 
information computation pages september 
ms milner sangiorgi 
barbed bisimulation 
proceedings th international colloquium automata languages programming icalp volume lecture notes computer science 
springer verlag 
ns needham schroeder 
encryption authentication large networks computers 
communications acm december 
ps pierce sangiorgi 
typing subtyping mobile processes 
logic computer science 
full version appear mathematical structures computer science 
rsa rivest shamir adleman 
method obtaining digital signatures public key cryptosystems 
communications acm february 
san sangiorgi 
expressing mobility process algebras firstorder higher order paradigms 
phd thesis university edinburgh 
available technical report cst computer science department university edinburgh 
san sangiorgi 
bisimulation proof method 
technical report ecs lfcs laboratory foundations computer science department computer science university edinburgh august 
sch schneier 
applied cryptography protocols algorithms source code john wiley sons 
sch schneider 
security properties csp 
ieee symposium security privacy pages 

