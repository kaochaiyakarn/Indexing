technical report key tool wolfgang thomas baar bernhard beckert richard martin reiner wolfram menzel wojciech mostowski andreas roth steffen peter schmitt department computing science chalmers university technology teborg university teborg sweden teborg research reported partially supported det dfg 
jointly carried department computer science university karlsruhe karlsruhe germany 
technical report computing science chalmers university technology teborg university technical report issn department computing science chalmers university technology teborg university teborg sweden teborg sweden key tool provides facilities formal specification verification programs commercial platform uml software development 
key tool formal methods object oriented development techniques applied integrated manner 
formal specification performed object constraint language ocl part uml standard 
key provides support authoring formal analysis ocl constraints 
target language key development java card proper subset java smart card applications embedded systems 
key uses dynamic logic java card express proof obligations provides state art theorem prover interactive automated verification 
apart integration uml software development characteristic feature key formal specification verification introduced incrementally 
keywords object oriented design formal specification formal verification uml ocl design key tool development high quality object oriented software 
key idea tool provide facilities formal specification verification programs software development platform supporting contemporary design implementation methodologies 
key tool empowers users perform formal specification verification part software development unified modeling language uml 
achieve system realised extension commercial uml computer aided software engineering tool case tool 
consequence specification verification performed extended case tool 
deep integration formal specification verification modern software engineering concepts serves purposes 
formal methods object oriented development techniques applicable proper combination 
second formal specification verification accessible developers object oriented design methodology 
key allows lightweight usage provided formal techniques specification verification performed time desired degree 
target language key driven software development java 
specifically verification facilities key restricted code written java card 
java card proper subset java programming language excluding certain features threads cloning dynamic class loading reduced api 
java card language platform provided sun microsystems enable java technology run smart cards devices limited memory embedded systems 
uml software development puts emphasis activity designing targeted system 
increasingly accepted design stage power prevent system failing 
suggests formal specification verification different ways closely tied design phase design documents design tools 
way combining object oriented design formal specification attach constraints class diagrams 
appropriate notation purpose offered uml standard includes object constraint language ocl 
briefly point major roles ocl constraints key key tool supports creation constraints 
user free general formulate desired constraint take advantage automatic generation constraints feature realised key tool extending case tool design pattern instantiation mechanism 
key tool supports formal analysis constraints 
relations classes design imply relations constraints analysed regardless implementation 
key tool supports verification implementations respect constraints 
theorem prover interactive automatic operation modes check consistency java implementations constraints 
mechanisms interaction features provided underlying case tool described detail 
key tool realises full integration certain formal techniques widely spread techniques 
usage specification verification facilities requires additional effort skill motivated 
software industry residual defect ratio number bugs remain shipped product normally lies defects lines non commented source code 
number justifies undertake extra effort depends damage caused system failures 
application areas damage known particularly high include safety critical applications railway switches security critical applications access control electronic banking cost critical applications example run large number non devices phone cards legally critical applications falling digital signature laws 
applications intended run smart cards similar devices 
java card target language key tool highly significant 
time technical restrictions java card verification full language feasible 
stress key restricted development smart card applications java applications features excluded java card 
general key tool particularly valuable minimisation software defects important issue 
article organised follows sect 
describes general architecture key system 
different scenarios system discussed sect 

sect 
introduce example rest 
sect 
describes key specific embedding formal specifications uml design process 
formal analysis relationship specifications sect 
implementation sect 
discussed 
sect 
describes resulting proof obligations processed interactive automated theorem proving 
brief look implementation issues sect 
describe case studies performed key sect 

summarise current state key project sect 
sect 
draw 
updated extended completely rewritten version 
architecture key tool key system built top commercial case tool 
integrating system existing tool obvious advantages 
features existing tool need reimplemented 

software developer familiar new design development tool 
furthermore developer required change tools development needed integrated tool 
case tool suited purposes easily extensible extensions fit nicely tool providing uniform user interface 
decided control center referred 
tools market suitable purposes 
state art development uml support including basic support textual specifications extended possible way java modules offers access internals means java open api see sect 

fundamental obstacle adding key extensions similar case tools 
fig 
shows screenshot key system extensions 

key system extensions architecture key system shown fig 

briefly describe components interactions 
modelling component upper part fig 
consists case tool extensions formal specification 
case tool allows software model contain ocl specifications support create process ocl specifications simply handled textual annotations 
extension comes play 
allows user create process prepare ocl specifications model implementation processed passed deduction component 
manipulating ocl specifications done employing external programs libraries pattern mechanism instantiate specifications ocl specification templates see sect 

case tool provides functionality uml modelling project development responsible user interactions project 

verification middleware link modelling deduction component 
translates model uml implementation java specification ocl java dynamic logic proof case tool verification middleware deduction component extension formal specification uml ocl java dynamic logic automated interactive 
architecture key system obligations passed deduction component 
java dynamic logic program logic key prover deduction component see sect 

verification component responsible storing managing proofs development process 

deduction component construct proofs java dynamic logic proof obligations generated verification component 
interactive verification system combined powerful automated deduction techniques 
components fully integrated data structures 
components implemented java fully integrated open api resulting uniform user interface 
addition components key tool stand ocl java dynamic logic translator prover see sect 

uniform implementation java key tool portable 
mentioned key system extensions optionally switched developer decision 
key tool cases key tool various scenarios people widely differing skills formal methods 
section sketch main scenarios key tool key development process industrial software particular demands security key development security critical software key education training 
fig 
shows appropriate level skill formal methods environment 
stated aim key project integration formal methods industrial software development process 
important target user group key tool people experts formal methods 
cases users reservations formal methods 
consequence reach goal project crucial importance key tool allows gradual verification software engineers including low experience level formal methods may benefit 
particular existence full formal specification prerequisite productive key tool 
software engineer free determine amount formal methods willing utilise 
main key industrial environment necessarily full formal verification formal modelling 
implementations undergo frequent alterations warrant formal verification exceptional application environment development security critical software education industrial software little medium high skills formal methods 
key application environments corresponding skill levels 
cases specifications prone changes 
benefits formal specifications obvious 
experience shows bugs contained specifications mere formalisation exhibits 
motivate users skills formal methods reservations key tool provides automatic support creating formal specifications ways see sect 

example key tool contains templates needed ocl constraints call key idioms 
key idioms easily instantiated user corresponding ocl constraints generated automatically 
addition instantiating key patterns extensions certain known design patterns possibility obtain specification having know ocl syntax 
authoring tool ocl constraints offers assistance generating specifications helps understand ocl constraints rendering automatically natural language 
currently integrated key tool 
believe user support provided key tool help overcome reservations formal methods hopefully increases willingness developers give formal methods try 
second possible field application key tool development including formal verification security critical software 
high risks emanate faulty implementations warrant effort formal verification 
interesting possibility provision formally verified implementation 
claim full formal software verification possible skills formal methods application scenario pertains formal methods experts 
key tool integrated system uniform user interface modelling specification implementation verification software development process 
advantage key tool conventional verification tools example 
integration tools typically incompatible interfaces deployed cover steps design verification 
advantage integrated tool enables efficient cooperation developers skills formal methods differs significantly high 
final important scenario mention key education training 
modular architecture allows certain components stand advantage 
deduction component example may stand teaching interactive theorem proving order predicate logic program logic 
authoring tool ocl constraints ocl syntax checker support teaching write formal specifications 
integrated tool formal methods course 
important effect emphasise formal software development complementary alien conventional methods 
currently developing teaching unit undergraduate level formal methods courses key tool 
stand components suitable self study particular authoring tool ocl constraints 
running example integer debit sum integer query sum integer boolean integer debit sum integer query integer query sum integer boolean query account bonus integer account debit sum integer query bonus sum integer integer query sum integer boolean 
simple credit card scenario account balance integer running example simple concisely illustrate key concepts mechanisms 
consists credit card application class diagram depicted fig 
simplest form 
assume familiarity reading uml class diagrams 
quick uml recommend 
main feature diagram fig 
class 
sequel abbreviation bcc name class 
class offers operation debit charge certain sum credit card 
operation permitted long credit limit exceeded 
operations allow query attributes account debit operation 
operations modify system state labelled uml stereotype query 
things little bit interesting included model subclasses stricter credit limit debit operation addition usual function may increase bonus points stored bonus attribute depending result operation bonus 
class modelled rudimentary 
embedding formal specification design process process models industrial contexts software development popular take advantage mainly graphical modelling notations uml 
modelling notations vary aspects tailored special purposes 
turns software developers difficulties practical application modelling notations developers understood notations mean purposes 
overcome problem seen best practice follow certain guidelines notation applied software developers phase project 
guidelines known process models 
example extreme programming xp rational unified process rup boehm spiral model include basic phases software development inception analysis design implementation test deployment maintenance 
modern process models tend cycle basic phases iterative model development step information available artefacts created previous development steps 
main concern process model twofold 
increase productivity software developer 

improve quality delivered software including documentation facilitate adaptations maintenance phase 
main goal key project formal methods industrial setting software development 
step formalisation imported form precise models obtained usage textual ocl 
focus application ocl class diagrams describe stage process model users take advantage ocl constraints 
ocl constraints domain model result inception analysis phase domain model target system 
domain model ought give overview concepts identified important relationships 
sake flexibility changeability phases domain model detailed 
hand certain properties domain classes evident phase 
example class diagram fig 
contain information want included model 
meaning bank credit line may clear human reader mirrored model far analysis tool goes syntactic checks 
exactly purpose express information kind ocl included uml see quick current language specification ocl 
ocl allows add invariants context inv self inv self account balance class 
intention constraint satisfied system states reserved implicitly quantified existing objects class 
experience software developers working industrial context showed aware constraints documented informal way tool 
closer questioning reveals software developers constraints mind formulate formal language ocl 
key tool offers simple powerful mechanism start authoring formal constraints gentle way 
users generate formal constraints immediate need learn specific syntax keywords 
key idioms key tool contains library predefined constraints called key idioms 
users may choose idiom library instantiate current target model setting idiom specific parameters 
desired constraint automatically generated context target model 

instantiation key invariants class example generated idiom 
calling key idiom library class results dialog displayed fig 

filling values shown returns exactly invariant 
invariants pre postconditions generated way 
attached operations classes 
library idioms extensible means simple scripting language 
experienced users formal methods expert development team write project specific idioms 
addition generated ocl constraints course manually changed 
generation constraint skeletons may useful situations 
key tool offer facility reverse engineer ocl constraints find idiom constrained generated 
reverse engineering provide correspondence possibly large complex ocl constraints descriptive understandable idioms 
possibilities attain similar goals 
may simply change idioms way suitable comments name current idiom generated addition ocl constraints 
second possibility usage authoring tool simultaneous development natural language ocl constraints 
currently integrated key tool 
help tool example rendered english german swedish supported invariant holds greater equal zero possible textual rendering linearisation dependent type object 
example write bank line enhance readability 
automatic translation arbitrary natural language texts ocl unrealistic direction feasible 
result elegant quite helpful example automatic rendering english making changes ocl 
opens possibility single source technology informal formal specifications 
foresee massive synchronisation maintenance problems formal specifications nontrivial size 
key idioms help software developers faster acquainted syntax formal language 
provide little help decide invariants pre postconditions added model 
remains task software developer characterise roles played classes domain model responsibilities assigned 
key tool ocl generally follow design contract approach 
refer chapter heuristics find useful constraints 
key patterns design phase domain model transformed detailed model order meet new requirements intentionally ignored phase 
running example fig 
requirement change kind credit card dynamically customer applies bonus program bank current credit card type turns card type 
transformation sparsely structured domain model fine grained appropriate model design phase facilitated application design patterns 
running example new requirements best captured application decorator page ff pattern 
terms decorator pattern type change class object seen attaching additional responsibilities object 
technically done wrapping object type revised model applying decorator pattern displayed fig 

case tool offers special support pattern application 
applying pattern user indicate roles existing classes applied pattern 
example class assigned role concrete component class role concrete decorator 
assignments automatically generates classes parts implementation pattern definition 
example class implementation generated public return component key tool idea pattern application support extended 
key patterns known gof patterns contain constraints written ocl formally characterise important aspects application scenarios 
key patterns instantiated way patterns user selects addition appropriate textual constraints instantiated 
case key idioms library key patterns extended user 
predefined version key decorator pattern supports generation formal constraints complex properties object inner component type 
terms decorator pattern means responsibilities attached object 
simpler example generated constraint postcondition ensure implementation specification operation generated application key pattern match idea instantiating textual constraints goes back technique successfully contexts 
example proposed language description uml process instantiating constraints called stamp mechanism 
integer debit sum integer query integer query sum integer boolean query account account balance integer interface debit sum integer query integer query sum integer boolean query account concrete component integer concrete decorator debit sum integer query sum integer boolean component decorator debit sum integer query integer query sum integer boolean query account bonus integer 
credit card diagram decorator pattern concrete decorator debit sum integer query bonus sum integer integer query sum integer boolean context integer post result self component instantiation key patterns facilitates creation specification ways 
case idioms difficulties formal language ocl hidden user 
important support obtaining complete specification key patterns extend known gof patterns scenarios 
listing predefined constraints useful context reminds user aspects forgotten specification far 
cases constraints attached pattern contradict choosing result inconsistent design 
key tool automatically detect clashes chosen constraints 
provides possibilities computer assisted analysis resulting constraints see sect 

analysing specifications section look verification tasks performed specification possible existing implementation 
called horizontal verification 
subsection describe tasks currently supported subsection outline tasks dealt key system 
proof obligations formal modelling supported key system ocl constraints allow characterise precisely relationship classes attributes operations 
simple example ocl constraint invariants sect 

proceed discussing examples give overview kinds constraints expressible ocl important subtleties language ocl 
formal modelling supported key system ocl constraints allow characterise precisely relationship classes attributes operations 
simple examples ocl constraints previous section 
proceed discussing examples give overview kinds constraints expressible ocl 
discuss subtleties language ocl 
constraints refer running example fig 

subclass contains class attribute scope attribute individual objects class 
requirements want attribute fulfil described invariants context inv inv account balance inv junior value attribute exceed non negative account drop 
note take advantage declaring local results readable ocl constraint 
invariants ocl allows add pre postconditions operations 
context debit sum integer pre sum post account balance account balance pre sum pre sum post account balance account balance pre pre true post pre ocl construct pre applicable postconditions causes feature refer value start operation 
admissible operation constraints specified query class diagram fig 

ocl language definition quite precise regarding meaning multiple pre postcondition pairs 
constraint pre postcondition pairs convenient shorthand constraints respectively pair 
furthermore multiple pre postcondition pairs equivalently translated constraint just postcondition precondition true 
constraint translation context debit sum integer pre true post pre pre sum account balance account balance pre sum account balance account balance pre ocl offers predefined variable result refer possible return value operation 
particularly useful query operations fully specified fixing return value 
context sum integer boolean pre true post result account balance sum note need pre suffix attributes statement know query property pre post values coincide 
pre postconditions viewed usual design contract paradigm chapter parts contract 
client calling operation sure precondition satisfied supplier operation guarantees terminates termination postcondition holds 
class diagram supplemented ocl invariants pre postconditions useful analyse mutual dependencies 
simplest requirement called structural subtyping check conjunction invariants subclass implies invariants superclass 
quick glance invariants shows true subclass invariants sect 

design methodology require operations preserve invariants operation op class precondition op invariant logically implies invariant successor state 
precondition postcondition pair operation implication course proved pair 
operation debit class preserve invariant account balance 
computation establishing straightforward done fully automatic key tool 
returning fig 
debit operation subclass additional functionality supposed increase number bonus points sum yielding constraint context debit sum integer pre sum post account balance account balance pre sum bonus bonus pre bonus sum pre sum post account balance account balance pre bonus bonus pre pre true post pre allows illustrate condition required design methodologies called behavioural subtyping liskov principle 
applies operation occurs class precondition pre postcondition post subclass class class precondition pre postcondition post 
behavioural subtyping requires implications pre pre post post logically valid 
requirements justified accepts subclass relation entails object class circumstances object class 
trivial observation behavioural subtyping regime holds true subclass respect 
behavioural subtyping preservation invariants supported key tool 
proving obligations user selects structural subtyping invariant preservation task key extension menu verification condition formalised dynamic logic generated passed key deduction system 
information contained uml class diagram ocl constraints translated dynamic logic 
translation fixes particular semantics uml ocl 
quite number papers name just published doing fixing formal semantics translating uml diagrams known formal system 
despite voiced need precise semantics uml informal semantics description lead major discrepancies class diagrams touching issues meta model 
ocl situation satisfactory 
trouble arose meta model integration rest uml 
issues rigorously resolved submission uml awaiting approval 
formal semantics phd thesis 
describe translation uml class diagrams ocl constraints typed dynamic logic way example 
full account 
summaries parts published :10.1.1.18.5551
step translation fix vocabulary logical side 
straight forward class uml model type logic built ocl types mapped corresponding data types 
attributes associations query operations mapped functions obvious manner 
class attributes turn constants 
gloss details naming disambiguating conventions unlabelled association ends get default name class attached bcc account set bcc 
selection vocabulary class diagram fig 
shown fig 

second invariant sect 
reads logic follows bcc 
account balance decided stick logical side dot notation opposed traditional notation brackets formula read bcc 
balance account 
way types category names model types bcc account ocl basic types integer boolean 
ocl collection types set bcc sequence integer 
functions name signature bcc integer balance account integer bonus integer integer account bcc account bcc account set bcc bcc integer bcc integer boolean 
vocabulary simple credit card scenario fig 
possible keep track ocl constraints interactive theorem prover see fig 

establish structural subtyping property subclass formula proved tautology 
account balance account balance look new invariant class account fig 
context account inv bcc select size account may different credit cards 
constraint says credit cards credit limit exceeding share account 
translation order logic reads account 
bcc select size select set bcc set bcc new function symbol depending expression select 
type set bcc insert type bcc set bcc set bcc constructors data type set bcc definition select reads select insert select insert select insert select select formulas passed deduction system 
translation pre construct requires order logic explained sect 

verifying correctness implementations supporting analysis specification key provides functionality checking correctness java implementation respect uml ocl specification 
particular key allows prove running method method post condition holds prove method preserves class invariant program correctness requires public methods preserve invariants 
dynamic logic instance dynamic logic dl seen extension hoare logic logical basis key system software verification component 
deduction dl symbolic program execution simple program transformations close programmer understanding java 
dl software verification systems kiv vse artificial imperative programming languages 
kiv system supports fragment java language 
systems dl successfully applied verify software systems considerable size 
dl seen modal logic modality program allow sequence legal java card statements refers successor worlds called states dl framework reachable running program standard dl states worlds programs non deterministic java programs deterministic exactly world terminates world terminate 
formula expresses program terminates state holds 
formula valid state satisfying pre condition run program starting terminates terminating state post condition holds 
formula similar hoare triple 
contrast hoare logic set formulas dl closed usual logical operators hoare logic formulas pure order formulas dl contain programs 
dl allows involve programs descriptions resp 
states 
example program easy specify data structure cyclic impossible pure order logic 
java constructs available dl description states including loops recursion 
necessary define data type state represent states terms type dl formulas give partial description states flexible technique allows concentrate relevant properties state 
syntax java card dl said dynamic logic constructed extending non dynamic logic modal operator addition dual operator 
non dynamic base logic dl typed order predicate logic 
describe detail types logic basically identical java types exactly terms formulas built 
definitions 
note terms call logical terms different java expressions side effects 
order reduce complexity programs occurring formulas introduce notion program context 
context consist java card program sequence class interface definitions 
syntax semantics java card dl formulas defined respect context programs java card dl formulas assumed contain class definitions 
programs java card dl formulas basically executable java card code 
verification program thought symbolic code execution 
detailed rule calculus java card dl specifies execute particular java statement possibly additional restrictions 
loop recursive method call encountered necessary perform induction suitable data structure 
follow symbolic execution paradigm verification evident certain amount runtime infrastructure represented java card dl 
possible clumsy inefficient achieve purely logical means 
introduced additional construct handling method calls available plain java card 
methods invoked syntactically replacing call method implementation 
handle return statement right way necessary record object field variable result assigned mark boundaries implementation body substituted method call 
purpose allow statements form method frame body occur dl programs 
note harmless extension additional construct proof purposes occurs verified java card programs 
proof obligations turn translation ocl constraints java card dl proof obligations 
prove method arg 
argn class satisfies pre post condition pair ocl conditions translated order formulas pre self arg 
argn post self arg 
argn respectively described section 
formulas key constructs java card dl proof obligation pre self arg 
arg self arg 
arg post self arg 
arg self arg 
arg program variables implicitly universally quantified initial value 
example pre postcondition pair operation section transformed sum true debit sum account balance account balance pre sum call operation debit translated java card dl program debit sum appears angle brackets formula 
furthermore balance pre new function symbol signature balance 
possibilities ensure function balance pre intended semantics see detailed account 
simplest way adding definition balance pre formula account 
balance pre balance sum true debit sum account balance account balance pre sum similarly prove method arg 
argn preserves invariant proof obligation inv self pre self arg 
arg self arg 
arg inv self constructed inv self order translation invariant 
deductive calculus proving obligations rule java card dl calculus java card programming construct rules 
describe important rules exemplary respective class rules 
active statement program rules calculus operate active command program 
non active prefix consists arbitrary sequence opening braces labels beginnings try try catch blocks beginnings method frame 
method invocation blocks 
prefix needed keep track blocks active command part abruptly terminating statements throw return break continue handled appropriately 
postfix denotes rest program non active prefix part program rule operates 
example rule applied java block operating active command non active prefix rest indicated parts block try assignment rule handling state updates java object oriented programming languages different object variables refer object 
phenomenon called aliasing causes serious difficulties handling assignments calculus java card dl 
example formula holds symbolic execution assignment depends refer object 
java assignments symbolically executed syntactic substitution 
solving problem naively doing case split effect assignment unclear inefficient leads heavy branching proof tree 
java card dl calculus different solution 
notion updates 
state updates form loc val put front formula 
semantics loc val loc val 
difference update assignment syntactical 
expressions loc val simple sense loc program variable var field access obj attr array access arr val logical term free side effects 
complex expressions allowed updates 
syntactical simplicity loc val semantical consequences 
particular computing value val side effects 
key system uses special simplification rules compute result applying update logical terms formulas containing programs 
computing effect update program formula delayed symbolically executed rules calculus 
case distinctions delayed avoided completely updates simplified effect computed effect computed maximal amount information available symbolic execution program 
assignment rule takes form stands arbitrary sequence updates loc val loc val just adds assignment list updates course solve problem computing effect assignment 
problem postponed solved rules simplifying updates 
assignment rule course expression val logical term 
rules applied evaluate val evaluation may side effects 
example rules replace dl versions simple artificial programming languages prefixes needed formula form pq replaced 
calculus splitting pq possible prefix empty valid program formula semantics general different pq 
formula 
view rules fly program transformations 
effect local fairly obvious user understanding proof obfuscated 
rule example rule premiss rule statement 
true false premisses rule correspond cases statement 
semantics rules premisses true state true state 
particular premisses valid valid 
practice rules applied bottom top old proof obligation new proof obligations derived 
rule demonstrates applying rule bottom top corresponds symbolic execution program verified 
rule loops rule unwinds loops 
application prerequisite symbolically executing loop body 
unwind rules allow handle loops induction schemata primitive user defined data types 
new labels result simultaneously replacing ln ln break li break label loop target break continue li continue label loop target break list ln usually empty element general loop label 
unwound instance loop body label new target break statements new target continue statements loop target 
results desired behaviour break abruptly terminates loop continue abruptly terminates current instance loop body 
continue label handled rule directly occur loops transformed break loop rules 
target break continue statement label loop immediately encloses 
rules try throw rules allow handle try catch blocks throw statement 
simplified versions actual rules apply case exactly catch clause clause 
instanceof exc try exc try throw exc catch instanceof exc throw exc try throw exc catch predicate instanceof exc semantics instanceof operator java 
evaluates true value exc assignable program variable type dynamic type sub type rule applies exception exc thrown instance exception class exception caught exception caught rule applies 
interactive automated proof construction existing interactive theorem provers tactical theorem provers 
tactics systems named programs act proof tree applications primitive rules small fixed set 
user constructs proof selecting tactics run 
writing new tactic certain purpose support new data type theory requires expert knowledge theorem prover 
key prover tactics primitive rules replaced concept 
combines logical content sequent rule pragmatic information indicates 
contrast usual fixed set primitive rules easily added system 
formulated simple pattern matching replacement schemas 
instance typical read follows find heuristics simplify means implication left side sequent may replaced formula appears left side sequent 
apart logical content keyword find indicates attached implication formula interactive selection see sect 

clause heuristics simplify indicates rule part heuristic named simplify meaning applied automatically possible heuristic activated see sect 

complex typically minimalistic primitive rules tactical theorem provers constitute tactical programming language 
conditional statements procedure calls loop constructs 
easier understand easier formulate tactics 
conjunction appropriate mechanism application heuristics powerful permit interactive theorem proving convenient efficient way 
principle prevents formulating represents unsound proof step 
possible generate order proof obligation involving dl 
formula proven restricted set primitive new guaranteed correct derived rule 
primitive handling java programs dl possible show correctness isabelle formalisation java oheimb 
introduced name schematic theory specific rules 
proof visualisation key prover window see fig 
consists panes left tabs 
tab called proof contains tree representing current proof state 
nodes tree correspond sequents goals different proof stages 
click node see corresponding sequent rule applied proof step node leaf 
leaf nodes open proof branches coloured red leaves closed branches coloured green 
tab named goals lists open proof goals 
clicking goal change active goal displayed right pane 
active goal open closure applying proof rules interactively activating automated proof search 
key prover allows user proof obligations simultaneously 
third tab named proof obligations keeps track currently open proofs lets user switch 
support interactive proof construction 
key prover window 
depending mouse pointer moved sub formula sub term goal focus term highlighted example fig 
diamond operator program contains focus term 
precisely term put focus pointing top level symbol 
pressing left mouse button displays list proof rules currently applicable focus term example method call rule applicable 
selected applied interactively generating new proof goal 
automated proof search automated proof search performed applying heuristics seen collection rules suited certain task 
example heuristic simplify boolean contains rules simplify boolean expressions 
user activate de activate heuristics depending state proof goal wants tackle 
automatic application heuristics easily switched proof construction 
implementation issues user perspective key tool extension commercial case tool produced 
open api allows key tool add items case tool contextual menus classes methods api possible modify currently open uml model instance pattern instantiation see sect 

technology key tool implemented java programming language 
choice advantages obvious portability 
java language easy link key tool written java 
generally java suited interaction tools written java 
particular imperative nature language leads comparatively natural native code interface contrast logic functional programming languages preferred deduction purposes 
java choice construction graphical user interface important aspect key tool 
previous experiments interactive automated theorem proving shown advantages language outweigh additional effort implementing term data structures unification simple form parametric genericity implementation 
instance usual interfaces set list interfaces semi automatically generated templates 
approach leads certain code bloat improves readability type safety 
apart key tool various third party software 
parsers generated antlr javacc 
framework read analyse java programs 
dresden ocl parser parse type check ocl constraints 
junit framework unit testing development 
structure implementation fig 
shows infrastructure key tool implementation level 
entities shown cylinders represent external files rectangular ones programs 
parts rendered thick lines bold type provided key project 
mechanism instantiating key patterns idioms described sect 
extension pattern instantiation provided 
patterns represented java programs construct required classes associations api 
key patterns generated entities annotated ocl constraints 
generated ocl template files belonging pattern 
complying single source philosophy ocl constraints stored comments user java files 
syntax type checking transformation dl dresden ocl parser 
type checking requires information uml model exported xmi format part uml standard 
consequence single source philosophy uml model corresponds structure java implementation 
alternatively model information required ocl parser extracted xmi facility java code 
additional information uml model example associations obtained api 
key prover reason java programs parsed system 
resolve determine variable declaration method declaration identifier referring 
actual proof different data structures explained section 
proof obligations typically generated ocl constraints 
translated dl formulas see sect 
data structures provided dresden ocl parser 
implementation theorem prover key prover permits automated interactive construction proofs dl formulas 
central data structure proof tree extended rule applications 
node proof tree contains sequent sets formulas 
typical rule application sequent calculus sequent changed 
reduce memory consumption data structures allow formula representations shared goals branches proof tree 
rule applications usually affect small part formulas programs act sharing sub formulas possible 
sharing implies non destructive persistent tree data structures terms formulas programs 
data structures ubiquitous functional logic programming unusual oo programming 
shared representation java programs achieved hierarchy classes derived data structures 
proof rules including automated simplification goals encoded see sect 

described textual representations collected external file processed prover start time 
built rules key prover 
consist matching part action part 
interactive user specifies formula term sequent applied 
requires finding match specific position sequent 
automated heuristic match sequent automatically selected 
matching potentially expensive operation large number different java constructs various data types 
speed process finding applicable kept indexing structure permits fast key patterns idioms java ocl key java datastructures base cc key prover ocl templates key patterns ocl template uml view xmi dresden ocl parser key ocl dl translator proof obligations proofs 
key tool infrastructure 
access subset potentially matching 
typically top predicate function symbol find applicable case dl formulas type statement 
stand versions general key tool designed case tool 
recognised parts system useful independently 
possible invoke ocl dl translation sect 
separately uml model xmi format 
furthermore possible key prover case tool 
stand prover parses dl proof obligations files 
case studies section discuss case studies test viability theoretical approach key implementation key tool 
case study consists partial specification verification various programs specifically java collection framework software access control pam authentication ibutton software computation speed restrictions deutsche ag german railway 
sections describe case studies detail outline results 
java collection framework java collection framework provides application programming interface api plus implementation lists sets trees related data structures 
data structures java programs realised obvious main interest key 
case study mainly investigate refinement techniques 
special attention paid question reconcile points view view collections data types functional viewpoint second implementational view example realised implementation 
general development process starts model level 
model stepwise refined implementational level relationship uml java classes exists 
refinement process visualised fig 

uml model ocl constraints dl formulas show implication refined formulas uml model ocl constraints dl formulas 
schema typical refinement step 
usually wants assure ocl constraints refinement level satisfy constraints level constraints level pertain possibly changed usually enlarged name space level 
changes model level level plus constraints level compute constraints name space level 
approach took directly ocl constraints formulas resulting translation dynamic logic 
explain way example fig 
shows uml model list similar 
list add object refines list add object element refines element entry element element 
refinement levels list upper part models lists level simple aggregation class list element class element 
class list contains usual methods adding removing membership test elements 
lower part models lists detailed level showing implementation details inner structure lists particular elements linked 
way connect levels define refinement relation different abstractions 
refinement relation denoted graphically uml dependencies stereotype refines plus additional textual description 
developer defined refinement relation drawing dependencies giving mapping dynamic logic formulas obtained ocl constraints level transformed concrete level serve proof obligations show refined model correct 
technique sketched successfully applied parts 
complete account case study 
pam authentication ibutton application allows linux user authenticate system ibutton smart card password 
application consists parts 
pluggable authentication module pam running host system 
module realised pam library plug written particular java card devices embedded button shaped case seehttp www ibutton com 

java card running user java card device 
contrast case studies consider genuine java card application 
original java card application rewritten cleaned case study 
redesign pam preceded analysis system requirements guided questions 
system administrator user owner applet pin code 

different deployment states applet life cycle look 

ensured applet sound state ibutton reader soundness properties specified 
applet life cycle states captured uml state diagrams fig 

diagram lists possible commands state triggered state transitions detail 
setting state diagrams portions code skeleton code generated 
install applet applet selectable applet dead applet personalised applet locked 
life cycle states 
development process ocl specifications parts applet created modified adjusted help key system 
main challenge rip properties 
problem specifying boils general problem expressing atomicity properties 
turns requires extension java card dl certain modal operators 
suggested modal operator named pronounced 
formula means holds atomic step program java card specification atomic step update variable single object field 
sequence operations bundled single atomic step called transaction programmer 
important able state necessarily hold inside transaction 
main obstacle capture semantics properties operator java card dl calculus 
extension dynamic logic calculus programs operator done 
extension java card dl design calculus ongoing 
full pam authentication ibutton case study development process see 
computation restriction speeds trains behalf deutsche ag german railway trains driving germany day 
called german informs engine driver speed limits complied point route 
obviously crucial safe speedy travel 
include general information technical properties trains example minimal braking power needed applicable 
train route combination exists 
possible respond flexible way available technology train example tilting technology german 
prevented rigid speed instructions private vehicles roads 
available engine driver printed electronic form 
software compute developed serves starting point study 
provided current version product description written natural language 
includes algorithm speed computation 
software written smalltalk visualworks dialect encompasses classes 
study concentrated part system responsible speed brake power computation 
number classes specified verified cross translated java reduced 
translation smalltalk java deal certain problems arising strict object orientation smalltalk semantic differences languages 
consequence reimplementation java required key result case study verified program behaviour compared original program 
means correctness original program ensured correctness computed verified implementation 
looked available product specification describes algorithm speed computation semi formal way natural language enriched uml class diagrams 
task formalise description uml ocl 
resulted formal specification analysis level 

uml model system analysis level 
analysis model abstracts away implementational details contains necessary constituents system 
order get impression degree refinement show fig 
incomplete part infrastructure model implementation level 
corresponding fragment analysis level shown fig 

relationship specifications currently worked refinement technique described see sect 

intermediate result writing formal specification discovered presence ambiguities incompleteness product specification 
verification way 
technical terms specification german exact translation non trivial possible stick german expressions particularly figures 
summary 
view infrastructure implementation level 
case studies discussed differ considerably respect nature target programs respect objectives 
show key approach flexible cope varying demands 
case studies respectively intermediate results obtained far demonstrate viability usability key approach 
current state current state core key tool finished tool minor restrictions successfully applicable 
case studies described sect 
prove 
show possible verify average java method consisting lines code minutes 
key prover automatically establish correctness code contain loops case user provide loop invariant interactively 
current implementation activities include integration tools developed standalone prototypes 
mention tool generating counter examples failed proof attempts authoring tool ocl constraints 
tool generating counter examples failed proofs assists user identifying solving errors implementation 
theoretical framework counter example generation data types 
usefulness approach shown prototype model generation theorem prover 
current version key tool downloaded athttp www ira uka de key download htm 
step improve usability key tool integration authoring tool ocl constraints 
tool available stand version offers assistance generating specifications helps understand ocl constraints rendering automatically natural language 
believe integration tool helps overcome reservations formal methods 
important aspect currently working support proof re 
technique diminishes amount spent verification minor change specification implementation 
count essential point prejudices program verification costly usable practice 
proof re feasible check automatically periodically implementation complies properties expressed ocl constraints 
situation similar automatic periodic runs unit tests proven best practice software development 
periodical checks prevent specifications outdated major common problem specifications merely available informal text 
obvious direction includes support uml diagram types class diagrams state chart sequence diagrams 
allow specify temporal behaviour programs possible class diagrams 
software verification scale larger programs necessary module concept possible independently verify modules program 
modules understood imperative languages supported languages 
unfortunately object oriented languages including java lag somewhat 
research efforts look module concept java compatible requirements formal verification 
aware formal verification option formal methods extreme 
approaches interpretation order model checking static analysis extended static checking integrated key tool 
improve user interface theorem prover fundamental way recall view verification key symbolic program execution 
may see single branch proof tree program execution symbolic start values 
intend reformulate verification possible established paradigm symbolic source code debugging 
think formal verification debugging increase acceptance verification result massive improvement efficiency elements modern debuggers break points watches spy points inspectors navigation eminent sense symbolic execution paradigm 
contrast conventional debuggers key evaluate expressions guards symbolically 
sets key tool apart efforts formal software specification verification systematic attempt conceive formal technique extension established industrial methods software development 
unfortunately parts formal methods community past popular industrial software development methods consideration 
views lack knowledge industrial software production conflation scientific formal 
contrast believe formal methods tightly integrated conventional development processes order immediately useful developers designers 
see prerequisite fulfilled formal methods possibly catch 
visible point philosophy just sketched interface key tool appears state art conventional case tool 
formal specifications added anytime design development having change tool paradigm 
machine assistance generating formal specification form key idioms patterns help users get started 
integration informal formal methods corner stones key approach 
second consequent choice design formal tools maximise usability 
example program logic transparent respect target language supports symbolic execution proof paradigm 
convinced pragmatics usability formal tools important soundness theoretical adequacy 
stress integration scaling formal methods spawned considerable number theoretically interesting questions documented technical papers 
vice versa formalisation uml ocl led clarifications extensions 
discuss briefly frequently heard counter argument software verification 
goes full functional verification push button technology sine qua non formal methods catch industry 
produce model checker verification hardware system designs prevail agree formal software verification extremely fully automated red herring assessment twofold misunderstanding stumbling block industrial users applying formal methods interactivity 
problem current formal approaches idiosyncratic require special skills 
usability threshold simply high 
widely established methods tools symbolic debuggers testing methods code reviews far automated 
accepted useful integral parts processes mastered reasonable effort 
second called push button technologies notably symbolic model checking far automated system requirements captured formally temporal logic model checkers tweaked cope larger problems 
summary real challenge formal methods software development useful people possible 
key project 

deductive search errors free data type specifications model generation 
voronkov editor automated deduction cade th international conference automated deduction copenhagen denmark volume lncs 
springer verlag 
baar beckert menzel schmitt 
key approach integrating object oriented design formal verification 
de guzm brewka pereira editors proc 
th european workshop logics ai jelia volume lncs pages 
springer verlag oct 
baar beckert menzel mostowski schmitt 
key system integrating object oriented design formal methods 

weber editors fundamental approaches software engineering fase part joint european conferences theory practice software etaps grenoble volume lncs pages 
springer verlag 
antlr homepage 
www antlr org 
baar 
ground meta circular ocl descriptions set theoretic approach 
clark evans lano editors proceedings fourth workshop rigorous object oriented methods london 
baar beckert schmitt 
extension dynamic logic modelling ocl pre operator 
proceedings fourth andrei ershov international conference perspectives system informatics russia lncs pages 
springer 
baar 
integrated metamodel ocl types 
france rumpe whittle editors proc 
oopsla workshop refactoring uml search core minneapolis mi usa oct 
baar sattler schmitt 
von ocl constraints 
mehlhorn snelting editors trends informatik pages 
springer verlag sept 
german 
reif 
formal system development kiv 
maibaum editor fundamental approaches software engineering volume lncs 
springer verlag 
beck 
embracing change extreme programming 
computer oct 
beckert 
dynamic logic formal verification java card programs 
jensen editors java smart cards programming security 
revised papers java card international workshop cannes france volume lncs pages 
springer verlag 
beckert keller schmitt 
translating object constraint language order predicate logic 
proceedings verify workshop federated logic conferences floc copenhagen denmark 
available ati www ira uka de key doc 
ps gz 
beckert mostowski 
program logic handling java card transaction 

submitted 
beckert 
sequent calculus order dynamic logic trace modalities 
gor nipkow editors proceedings international joint conference automated reasoning siena italy lncs pages 
springer 
boehm 
spiral model software development enhancement 
ieee computer 

pam authentication ibutton 
www users rwth aachen de 
pam ibutton html 
breu grosu huber rumpe 
precise semantics object oriented modeling techniques 
bosch mitchell editors object oriented technology ecoop post conference workshop reader jyv skyl finland volume lncs 
springer verlag 

formale und software mit dem key system eine aus dem 
diplomarbeit fakult informatik universit karlsruhe dec 
german appear 
chen 
java card technology smart cards architecture programmer guide 
java series 
addison wesley june 
cook daniels 
designing object systems object oriented modelling 
object oriented series 
prentice hall 
dresden ocl homepage 
dresden ocl sourceforge net 
evans 
france lano rumpe 
making uml precise 
andrade moreira deshpande kent editors proceedings oopsla workshop formalizing uml 


finger 
design implementation modular ocl compiler 
diplomarbeit technische universit dresden fakult informatik mar 
fowler scott 
uml 
applying standard object modeling language 
addison wesley 
france 
problem oriented analysis basic uml static requirements modeling concepts 
proceedings acm sigplan conference object oriented programming systems languages applications pages 
acm press 
fujita hasegawa 
model generation theorem prover kl ramified stack algorithm 
furukawa editor proceedings th international conference logic programming paris france pages 
mit press 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley reading ma 

incremental closure free variable tableaux 
gor nipkow editors proc 
intl 
joint conf 
automated reasoning siena italy volume lncs pages 
springer verlag 

interactive theorem proving schematic theory specific rules 
technical report fakult informatik universit karlsruhe 
www ira uka de key doc ps gz 

authoring tool informal formal requirements specifications 

weber editors fundamental approaches software engineering fase part joint european conferences theory practice software etaps grenoble volume lncs pages 
springer verlag 
harel 
dynamic logic 
gabbay guenthner editors handbook philosophical logic volume ii extensions classical logic chapter pages 
reidel dordrecht 
harel kozen tiuryn 
dynamic logic 
mit press 
holzmann 
economics software verification 
proc 
workshop program analysis software tools engineering snowbird utah usa june 
acm 
hutter siekmann stephan 
deduction verification support environment vse 

gaudel woodcock editors proceedings formal methods europe industrial benefits advances formal methods 
springer 
jacobson rumbaugh booch 
unified software development process 
object technology series 
addison wesley reading ma 
javacc homepage 
www com products java cc 
junit homepage 
junit sourceforge net 
keller 
von ocl constraints einer logik java 
diplomarbeit fakult informatik universit karlsruhe 
german 
kozen tiuryn 
logics programs 
van leeuwen editor handbook theoretical computer science volume formal models semantics chapter pages 
mit press 
mellor souza clark evans kent 
infrastructure superstructure unified modeling language response uml rfp 
technical report submission omg 
meyer 
object oriented software construction 
prentice hall englewood cliffs second edition 
mostowski 
rigorous development javacard applications 
clark evans lano editors proc 
fourth workshop rigorous object oriented methods london 
url www cs chalmers se papers room ps gz 
object modeling group 
unified modelling language specification version sept 
response uml ocl rfp june 
omg document ad 
owre rajan rushby shankar srivas 
pvs combining specification proof checking model checking 
alur henzinger editors computer aided verification cav volume lncs pages 
springer verlag july august 
paulson 
isabelle generic theorem prover volume lncs 
springer verlag 
pratt 
semantical considerations floyd hoare logic 
proceedings th annual ieee symposium foundation computer science 
homepage 
sourceforge net 
richters 
precise approach validating uml models ocl constraints volume monographs 
logos verlag 
phd thesis universit bremen 
roth 
am beispiel des java collections frameworks 
diplomarbeit fakult informatik universit karlsruhe june 
german 
schmitt 
model theoretic semantics ocl 
beckert france jacobs editors proceedings workshop precise modelling deduction object oriented software development siena italy pages 
technical report dii dipartimento di ingegneria dell informazione universit degli studi di siena 

verification javacard programs 
technical report institut informatik universit augsburg germany 
available athttp www informatik uni augsburg de swt fmg papers 
sun microsystems palo alto ca 
java card language subset virtual machine specification oct 
sun microsystems palo alto ca usa 
java card platform specification sept 
homepage 
www com 
von oheimb 
axiomatic semantics java light drossopoulou eisenbach jacobs leavens ller poetzsch heffter editors proceedings formal techniques java programs workshop ecoop cannes france 
von oheimb 
analyzing java isabelle hol 
phd thesis institut informatik technische universit nchen januar 
warmer kleppe 
ocl constraint language uml 
journal object oriented programming mar 
