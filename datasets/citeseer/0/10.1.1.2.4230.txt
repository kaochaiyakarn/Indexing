java bytecode veri cation model checking joachim posegga harald vogt deutsche telekom ag security darmstadt tel 
fax telekom de 
provide interpretation java bytecode programs build nite state models programs 
describe bytecode constraints ctl formulas checked nite models standard model checker 
see practical way perform bytecode veri cation formal basis help achieve higher security open door extensions prove additional properties java bytecode 
java bytecode veri cation aims proving bytecode program compiled java method conforms certain security requirements intended protect executing platform malicious code 
reasons ciency necessary checks performed program executed runtime 
current implementations process techniques data ow analysis assure required properties 
exists formalization process bytecode veri cation gol thorough implementation bytecode veri er implementation built rigid formal description 
goal show veri cation implemented solving model checking problem aiming standard model checker tool smv mcm able describe bytecode veri cation high level terms ctl formulas 
gives distinct description problem cient implementation 
ideas introduced pv context java smart cards demand security isvery high 
treat bytecode instructions detail concentrate jsr ret instructions implementing opinions expressed solely authors necessarily re ect views deutsche telekom ag 
idea implementing data ow analysis model checking problem rst published ste 
joachim posegga harald vogt subroutines bytecode programs 
rarely treated literature raise special problems bytecode veri cation 
sa deals instructions tracking subroutine calls structure 
take idea introduce structure recording active subroutines program point 
bytecode subroutines impose certain di culties bytecode veri cation 
variables subroutine appropriate types subroutine limits variables code subroutine call 
approach easily solved instruction type variables checked way regardless path instruction reached 
second ret instruction structured way variable ret contains valid return address 
additionally subroutines may called recursively subroutines completed returning inner subroutine call 
list structure record active subroutines program point able decide execution jsr ret instructions possibly violating constraints 
start introducing interpretation bytecode instructions programs section 
interpretation nite allowing build nite state system bytecode program amenable model checking 
section show build system smv model checker description 
properties nite state system constructed section 
interpretation bytecode bytecode programs operational semantics bytecode instructions terms transition rules state system 
employing formalism state machines gur describe bytecode programs 
rule instruction bytecode program compose rule program 
program sequence instructions 
rule ri bytecode instruction semantics bytecode program block rule pc ri pc ri pc rin rules rii instantiations rule schemes respective instructions certain placeholders denoting goal jsr instruction substituted concrete values 
semantics instructions supply generic asm rule rule scheme considered bytecode instruction 
rule ri composition rules si si denotes rule java bytecode veri cation model checking gives standard semantics bytecode instruction gives extension standard semantics 
explain instructions behave additional state variables subroutine call chain records active subroutines 
required rules clash rules si may perform contradictory updates 
rules updates additional state variables guaranteed 
standard semantics bytecode instructions rules jsr push pc pc ret pc loc astore loc top pop pc pc extension standard semantics rules jsr sr sr ret sr split sr loc sr sr serves placeholder goal jsr instruction 
replaced concrete address program point rule instantiated build asm bytecode program 
underscore statement denotes anonymous variable value subsequently 
functions push pop top common operations stacks 
plus sign denotes addition natural numbers 
subroutine call chain implemented sequence labels denoting empty sequence operator adding label sequence 
predicate true label occurs sequence split function splits sequence parts location pointed rst occurrence value suppose split uav ua 
function external static asm 
means updated asm rules part dynamic aspects asm 
build nite abstraction asm required give nite abstractions functions 
joachim posegga harald vogt concrete types abstraction providing nite abstractions external functions rules de ne corresponding rules translated nite state system 
create nite state system bytecode program represented corresponding composite asm rule necessary restrict universes asm rule nite sets give nite interpretations functions 
describe concrete types 
bytecode program number variables xed 
numbered onwards index range interval natural numbers starting 
nat denotes natural numbers 
universe word contains values primitive types 
type identi ers left column state components internal asm functions right pc nat pc pc loc word loc loc opd stack word opd opd sr nat sr sr give nite abstractions types left column 
structure generic size depends bytecode program 
xed computed bytecode program 
maximum height operand stack xed bytecode program supplied header bytecode program 
suppose bytecode instructions array code length codelength 
pc pc loc opd lab fl ex 
code jsr lg sr lab pc explicitly restricted possible addresses instructions code array extended special value undef denoting invalid address 
word lab substitutes natural numbers nat sr universes su cient purpose consider limited set instructions 
extended instructions needed 
asms value undef contained universe default 
include value explicitly clear values properly included description nite state system 
structure instruction rules changed building nite asm 
external functions substituted nite abstractions 
give de nitions abstracted functions push pop top split java bytecode veri cation model checking juj fvg av fag av fmg codelength wa wav substituting de nitions asm rule program get nite asm universes nite universe extensions occur 
asm seen description nite state system state space de ned possible values internal functions 
note general case functions nondeterministic nondeterministic functions subset bytecode instructions consider 
right hand sides de ning equations sets possible values 
execution asm rule possible values chosen determine successor state 
note abstracted functions homomorphic concrete functions condition fh hold 
ensures conditions proven hold system carry concrete system 
ctl applies formulas quanti ed execution paths forbid quanti er stating existence path specifying bytecode properties 
see cgl details :10.1.1.116.9247
building finite state system approach unlabelled transitions bytecode program takes input execution 
choice successor state depends internal state program 
program executed deterministically vm 
abstracting nite types conditional branches nondeterministic choices branching depends concrete values accessible anymore 
joachim posegga harald vogt successor state nondeterministically chosen system set possible successor states determined transition relation 
de ne nite state systems follows 
de nition 
nite state system tuple nite set states transition relation set initial states 
translation asm rules model checking interested representation state system necessary computations performed ciently 
model checker smv example takes propositional formula input description transition relation variable sets occur 
variables denote current values state variables denote successor values 
internally representing propositional formula bdd transition relation concisely represented boolean operations computed ciently 
state space consists asm functions pc loc opd sr smv variables represent state variables pc pc loc array loc opd stack positions holding current size sr positions list sr holding current size sr 
note just suggestion state space represented smv 
possibilities translate nite asm smv model 
initial state determined follows 
pc set 
loci variables set initial values signature bytecode program 
initialized undef set 
matches initializations jvm starting execute bytecode program 
feed transition relation represented asm rule model checker translate propositional formula transition relation represented formula ful ll condition rule res results tg cient algorithm construct representation rule set currently implemented 
atomic propositions state properties described terms propositional formulas built atomic propositions 
smv atomic propositions essentially equations java bytecode veri cation model checking integer comparisons 
common propositional connectives may 
require negations occur level state propositions formulas ctl quanti ers able carry properties system concrete see cgl :10.1.1.116.9247
security properties constraints bytecode programs informally described ly 
give formalization terms ctl formulas argue meet informal description 
show semi formally correspond equivalent descriptions gol qia sa 
concentrate jsr ret instructions 
recursion assured subroutine recursively called 
recording active subroutines sequence sr constraint expressed pre condition jsr instruction sr write condition ctl formula smv syntax expand predicate propositional formula 
predicate coded follows sr false sr sr sr 
program point code jsr formula ag pc sr preceding quanti er ag says formula hold state execution path 
antecedent pc implication restrict succedent states represent program point jsr instruction 
returning subroutines constraint ret instruction executed contain return address value respective subroutine active 
expressed pre condition ret instruction sr joachim posegga harald vogt code jsr set valid return addresses associated respective subroutine entry labels 
formula expands smv formula straightforward way 
ctl formula program point ret instruction occurs ag pc related approach formal semantics java bytecode 
description builds mainly original description ly aware existing formalizations ber zg bs qia 
notations bs state machines describe java virtual machine goal de ning platform correct compilation java code 
remains connect approach formalizations bytecode veri cation gol 
lead higher con dence approach reveal aws formalizations 
providing generic tool takes interpretation bytecode semantics formulas describing system properties hope extend bytecode veri cation check properties bytecode programs 
candidate especially important eld java smart cards resource consumption bytecode programs 
take certain garbage collection strategies smart cards check bytecode program leaves objects heap give appropriate interpretation bytecode instructions appropriate formulas 
ber peter bertelsen 
semantics java byte code 
www dina dk march 
bs egon borger wolfram schulte 
de ning java virtual machine platform provably correct java compilation 
rd international symposium mathematical foundations computer science lncs 
springer verlag 
cgl clarke grumberg long :10.1.1.116.9247
model checking abstraction 
acm trans 
prog 
languages systems 
gol allen goldberg 
speci cation java loading bytecode veri cation 
www kestrel edu html people goldberg bytecode ps gz 
gur yuri gurevich 
evolving algebras guide 
egon borger editor speci cation validation methods 
oxford university press 
ly lindholm yellin 
java virtual machine speci cation 
addison wesley 
mcm kenneth mcmillan 
symbolic model checking 
kluwer academic publishers 
java bytecode veri cation model checking pv joachim posegga harald vogt 
byte code veri cation java smart cards model checking 
th european symposium research computer security lncs 
springer verlag 
qia qian 
speci cation java virtual machine instructions objects methods subroutines 
jim alves foss editor formal syntax semantics java lncs 
springer verlag 
sa raymie stata martin abadi 
atype system java bytecode subroutines 
proc 
th acm symp 
principles programming languages 
acm press 
emin gun sirer arthur gregory brian bershad 
java system architecture 
cs washington edu 
ste bernhard ste en 
data flow analysis model checking 
ito meyer editors theoretical aspects computer software volume lecture notes computer science pages 
springer verlag september 
zg wolf zimmermann 
state machine java byte code june 
