open modules proposal modular reasoning aspect oriented programming jonathan aldrich institute software research international carnegie mellon university forbes avenue pittsburgh pa usa jonathan aldrich cs cmu edu version march revised july cmu aspect oriented programming aop new programming paradigm goal cleanly modularize crosscutting concerns logging synchronization event notification scattered system tangled functional code 
aop languages provide promising ways separate crosscutting concerns break conventional encapsulation mechanisms making difficult reason code aid external tools 
investigate modular reasoning presence aspects tinyaspect small functional language directly models aspect oriented programming constructs 
define open modules module system tinyaspect enforces reynolds abstraction theorem strong encapsulation property 
open modules open external aspects advise functions pointcuts interface providing significant aspect oriented expressiveness missing non aop systems 
order guarantee modular reasoning system places limits advice external aspects may advise function calls internal module calls explicitly exposed pointcuts module interface 
abstraction property system ensures module implementation changed affecting clients provides insight formal reasoning modular analysis tool support aspect oriented programming 
keywords open modules modular reasoning abstraction aspect oriented programming tinyaspect types modules logical relations equivalence bisimulation 
seminal parnas laid classic theory information hiding developers break system modules order hide information change 
change anticipated reasonable accuracy system evolved local global system modifications easing software maintenance tasks 
furthermore correctness module verified isolation modules allowing developers independently different sub problems 
aspect oriented programming aop developed insight conventional modularity encapsulation mechanisms flexible capture concerns change 
concerns effectively hidden information hiding boundaries crosscut underlying functional decomposition program 
result code implementing concerns tends scattered placed system tangled unrelated code 
example consider problem enforcing global constraint simulation framework ensuring objects simulation overlap 
way enforcing constraint check time object simulation moves 
conventional system code moving spread different functions system 
function involved moving objects call constraint checking code meaning calls scattered methods tangled code moving objects 
scattering tangling constraint checking concern evolving difficult error prone engineer find calls constraint checker change consistent way 
constraint checking calls missed defect result 
aspect oriented programming systems provide mechanisms crosscutting concerns constraint checking 
example shows simulation invariants checked modular way constructs aspectj widely aspect oriented programming language example assumes kind graphical simulation shows classes representing points representing rectangles :10.1.1.21.5662
classes moves shapes screen 
separate package constraint checking aspect defined check certain invariants simulation time shape moves 
pointcut defined show set places base simulation code constraint checking applied 
case pointcut refers calls method shape classes 
pointcut triggered advice bottom aspect invoked 
advice advice meaning run call completes 
body advice simply invokes method shown checks invariants simulation hold 
aspect oriented technology capture constraint checking concern code concern eas example illustrates aspectj syntax object oriented 
remainder focus aspects setting functional languages 
package shape public class point extends shape public void int dx int dy dx dy public class rectangle extends shape public void int dx int dy dx dy dx dy package constraints aspect pointcut moves call void shape moves simulation code shows definition shapes graphical simulation framework aspect checks global simulation invariants scene changes 
aspect defines pointcut representing calls methods shapes advice checks simulation invariants shape moves 
ier understand evolve 
code concern constraint checking aspect function programmer easily understand code just looking places 
contrast concern implemented conventional language calls scattered methods shape classes 
aspect oriented implementation developer change implementation advice pointcut showing applies place aspect oriented technology change spread making developer relevant places code 
aop definition filman friedman defined aspect oriented programming quantification obliviousness 
quantification idea write statements effect non local places programming system example pointcut quantifies implementations method system :10.1.1.28.287
obliviousness idea places quantifications applied specifically prepared receive enhancements example methods specifically prepared calling advice directly callback order affected advice :10.1.1.28.287
aspects information hiding example illustrates aspect oriented tech nology provide better information hiding crosscutting concerns making easier understand evolve code dealing concerns 
unfortunately aspect technology edged sword software evolution difficult coupling aspects tightly code advise 
aspectj systems allow aspects reach encapsulation boundaries breaking information hiding principles 
example constraint checking aspect tightly coupled implementation details package break implementation details changed 
consider happens rectangle modified store coordinates pair points pairs integer values 
body rectangle changed read dx dy dx dy moves pointcut invoked moves constituent points move 
scene invariants checked middle rectangle operation 
simulation invariants need true intermediate state motion additional checking lead spurious invariant failures 
aspect violates information hiding boundary shape package placing advice method calls package 
means implementor freely switch semantically equivalent implementations external aspect may break implementation changed 
aspect violates information hiding evolving shape package difficult error prone 
aspectj language considered isolation violates information hiding principles tool support aspectj plugin eclipse help address problem described investigate purely language solution information hiding problem 
solution gives expressiveness aop provides insight tool support essential pure aop improved limitations 
contributions contributions reasoning aspect oriented programming systems 
define tinyaspect functional core language aspect oriented programming 
tinyaspect formal model aspects extremely small models aspect oriented constructs directly defined standard small step operational semantics 
combination properties easy investigate aspect oriented language extensions prove theorems 
second contribution extension tinyaspect open modules module system open forms aspect oriented extension guarantees abstraction theorem strong encapsulation property 
open modules design principle module may choose expose internal semantic events pointcuts clients clients may depend gregor kiczales pointing implementation details part semantics module interface 
design interface open module exposes set values functions pointcuts 
pointcuts represent internal events semantically important clients advise pointcuts modules implement interface pointcuts way 
clients advise functions interface module advice affects external calls functions calls module 
clients observe depend way implementation module uses functions exposed interface 
example module system require pointcut apply calls module 
abstraction property precise define bisimulation relation programs 
tinyaspect module system ensures modules implement module interface implementations obey bisimulation relation respect interface matter client code written interface behave way matter module implementation 
property developers reason separately correctness implementation clients module 
outline outline rest follows 
section introduce tinyaspect language series examples formal static dynamic semantics 
section extend tinyaspect open modules 
section define equivalence relation programs show module system guarantees abstraction 
section discusses implications abstraction property formal methods modular analysis tool support aop 
section discusses related section concludes 

formally modelling aspects formal model aspect oriented programming order study language extensions module system discussed section 
researchers denotational semantics big step operational semantics translation systems study semantics aspect oriented programming operational semantics advantage providing simple direct semantics amenable syntactic proof techniques 
jagadeesan proposed operational semantics core aspectj incorporating different kinds pointcuts advice object oriented setting 
features ideal modeling aspectj complexity model tedious prove properties system 
walker propose simpler formal model incorporating just lambda calculus advice labeled hooks describe advice may apply :10.1.1.10.7635
foundational calculus fulfill obliviousness requirement aop advice applied specifically labeled locations intended model source level aop constructs directly 
calculus provides set primitives source level oblivious aop constructs translated useful names expressions fn declarations val pointcut pointcuts call types unit pc tinyaspect source syntax studying compilation strategies aop languages defining aop languages translation 
calculus walker considerably lower level existing languages aspectj properties true source level language may hold foundational calculus 
formal model models source level aspect constructs directly effective way investigate properties aop languages 
tinyaspect developed new functional core language aspect oriented programming intended proofs source level properties straightforward possible 
name suggests tinyaspect tiny containing lambda calculus units declarations pointcuts advice 
tinyaspect directly models aop constructs similar aspectj making source level properties easy specify prove small step operational semantics standard syntactic techniques 
working aspect oriented functional setting system design inspired featherweight java successfully study number object oriented language features :10.1.1.109.1141
shows syntax 
syntax modeled ml tinyaspect programs easy read understand 
names tinyaspect simple identifiers extend paths add module constructs language 
expressions include monomorphic lambda calculus names functions function application 
core add primitive unit expression base case types 
add primitive booleans integers completely standard way 
constructs orthogonal aspects omit 
aspect oriented programming languages including aspectj pointcut advice constructs declarative 
accurate source level model program sequence declarations 
declaration defines scope includes declarations 
declaration empty declaration value binding pointcut binding advice 
declaration gives static name value may advised declarations 
pointcut declaration names pointcut program text 
pointcut refers call function value defined declaration pointcut form just alias previous pointcut declaration real language pointcut forms include basic possible form order keep val fib fn int call fib int fib fib proceed advice cache calls fib val fn val fn val fn pointcut call fib int proceed fibonacci function written tinyaspect aspect caches calls 
language minimal 
declaration names pointcut describing calls function binds variable argument function specifies advice run place original function 
inside body advice special variable proceed bound original value function choose invoke original function desired 
tinyaspect types include unit type function types form pointcut types representing calls function type 
fibonacci caching example illustrate language writing fibonacci function writing simple aspect caches calls function increase performance 
compelling example aspects standard literature simple language 
shows tinyaspect code fibonacci function 
assume integers booleans added illustrate example 
tinyaspect recursion primitive language fib function includes just base case fibonacci function definition returning 
advice calls fib handle recursive cases 
advice invoked client 
advice invoked client calls fib 
body advice checks see argument greater returns sum fib fib 
recursive calls intercepted advice original function allowing recursion properly 
case argument advice invokes proceed original number scope advice declaration special refers advised definition function 
call proceed forwarded original definition returns 
lower half aspect caches calls fib allowing normally exponential function run linear time 
assume cache data structure functions checking result cache expression values fn pointcut values pv call declaration values dv val dv pointcut pv dv evaluation contexts val val pointcut pv tinyaspect values contexts value looking argument cache storing new argument result pair cache 
caching code reusable declare pointcut names function calls cached case calls fib 
advice pointcut checks see cache 
advice gets result cache returns 
value cache advice calculate result call stores result cache returns result 
semantics advice declared declaration invoked 
client calls fib caching advice invoked 
caching advice calls proceed advice recursively defines fib invoked 
advice turn calls proceed original function definition invoked 
advice recursive call fib call intercepted caching advice 
cache works exactly expect invoked recursive calls able effectively avoid exponential cost na way 
operational semantics define semantics tinyaspect precisely set small step reduction rules 
rules translate series source level declarations values shown 
expression level values include unit value functions 
advice applies declarations functions 
need keep track declaration usage program text declaration represented label 
operational semantics auxiliary environment keeps track advice applied declaration 
pointcut value take form calls particular declaration 
formal system model execution declarations replacing source level declarations declaration values distinguish symbol binding 
shows contexts reduction may occur 
reduction proceeds left hand side application right hand side 
reduction occurs value declaration proceeding declarations 
pointcut declarations atomic define evaluation context declarations follow 
describes operational semantics tinyaspect 
machine state pair ad fn app lookup domain val val val pointcut call pointcut call call pointcut fn proceed domain context tinyaspect operational semantics vice environment mapping labels values expression advice environments similar stores keep track mapping declaration labels declaration values modified advice declarations 
notation order look value label denote functional update environment 
reduction judgment form read advice environment expression reduces expression new advice environment rule function application standard replacing application body function substituting argument value formal normally treat labels values want avoid looking advised 
position invoke function represented label rule lookup look label value current environment 
rules reduce declarations declaration values val declaration binds value fresh label adds binding current environment 
substitutes label variable subsequent declaration leave binding reduced expression type preservation easier prove easy extend tinyaspect module system need retain bindings 
declaration simply substitutes pointcut value variable subsequent declaration 
declaration looks advised declaration current environment 
places old value binding fresh label re binds original body advice 
inside advice body special variable proceed replaced refers original value advised declaration 
original declaration redirected advice advice invoke original function 
rule shows reduction proceed var call pc label unit unit fn empty fn app val val val pc pc pointcut pc pc pointcut pc vpc pc proceed tinyaspect typechecking context defined 
env pc typechecking describes typechecking rules tinyaspect 
typing judgment expressions form read variable context declaration context expression type maps variable names types maps labels types similar store type 
rules expressions standard 
look types variables labels respectively 
standard rules give types expression functions applications 
interesting rules declarations 
give declaration signatures declarations sequence variable type bindings 
base case empty declaration empty signature 
val bindings ensure expression typed type typecheck subsequent declarations assuming bound variable type 
pointcuts similar rule ensures expression typed pointcut denoting calls function type 
val pointcut binding value typing rule subsequent declarations see bound variable substituted 
advice rule checks declared type matches argument type pointcut checks body typed assuming proper types variables 
judgment states formed environment typing values types 
judgment analogous store typings languages 
type soundness state progress preservation theorems tinyaspect 
theorems quantify expressions declarations metavariable quantify types declaration signatures metavariable progress property states expression welltyped value take step new expression 
theorem progress value exists 
proof induction derivation type preservation property states expression typed reduces expression new environment new expression environment typed 
theorem type preservation exists proof induction derivation 
proof relies standard substitution weakening lemmas 
progress type preservation imply type soundness 
soundness means way typed tinyaspect program get stuck go wrong gets bad state 
type soundness theorem slightly stronger previous result walker guarantee type safety lack run time errors 
walker model advice lower level exception construct soundness theorem includes possibility program terminate uncaught exception :10.1.1.10.7635

open modules open modules module system allows programmers enforce abstraction boundary clients implementation module 
module system modeled closely names 
declarations 
structure modules struct functor types 
sig decl 
values dv 
structure module values mv struct dv functor contexts 
structure structure mv struct mv module system syntax values contexts ml providing familiar concrete syntax design advanced module system 
shows new syntax modules 
names include simple variables qualified names module expression 
declarations include structure bindings types extended module signatures list variable type bindings module signature 
order module expressions include name list declarations expression seals module signature hiding elements listed signature 
expression functor describes functor takes module signature argument returns module may depend functor application written function application form 
module system include types abstraction property enforce implementation independence representation independence 
underlying problem cases external aspects able observe internal behavior module functions 
conjecture solution implementation independence problem enforce representation independence types added standard ways 
fibonacci revisited shows reusable caching aspect defined functors 
functor accepts module single element pointcut calls function signature int int 
advice advises pointcut argument 
fib function encapsulated inside math module 
module implements caching instantiating cache module structure binds pointcut calls fib 
math module sealed signature exposes function clients 
sealing module sealing operation effect type system level operational level 
type level structure cache functor sig pc int int struct int 
definition structure math struct val fib fn int call fib int fib fib proceed structure cache struct pointcut call fib sig fib int int fibonacci open modules structure shape struct val fn val fn val animate fn 
pointcut moves call sig description shape shape location unit animate shape path unit moves pc shape location unit shape library exposes position change pointcut hides members module signature respect similar sealing ml module system 
sealing operational effect hiding internal calls module clients advise module explicitly exports corresponding pointcut 
example clients math module able tell caching applied placed advice math fib 
math sealed external advice math fib invoked external calls function internal recursive calls 
ensures clients affected implementation module changed example adding removing caching 
exposing semantic events pointcuts shows shape example described modeled tinyaspect 
clients shape library advise internal functions module sealed 
allow clients observe internal semantically important events motion animated shapes module exposes events signature moves pointcut 
clients advise pointcut depending internals shape module 
module implementation changed moves pointcut updated client aspects triggered way 
sealing enforces abstraction boundary module clients allowing programmers reason change independently 
system allows module export semantically important internal events allowing clients extend observe module behavior principled way 
solution called pointcut interfaces originally proposed kiczales engineering technique ease software evolution decoupling aspect code advises 
related demeter project traversal strategies isolate aspect code advises 
provide technical definition open modules distinguish contribution previous definition open modules module system allows external aspects advise external calls functions interface module allows external aspects advise pointcuts interface module allow external aspects advise calls module functions module including exported functions 
operational semantics shows operational semantics open modules 
rules module values mv mean struct declaration values dv functor 
path lookup rule finds selected binding declarations module 
assume bound names distinct rule easy ensure renaming variables appropriately 
modules advised need create labels structure declarations just substitute structure value variable subsequent declarations 
rule functor application uses substitution 
rule sealing uses auxiliary judgment seal generate fresh set labels bindings exposed signature 
fresh set labels insures clients affect external calls module functions advising new labels advise calls internal sealed module 
bottom diagram rules defining sealing operation 
operation accepts old environment list declarations sealing declaration signature 
operation computes new environment new list declarations rules structured declaration list rule handles declaration appeals recursively definition sealing handle remaining declarations 
empty list declarations sealed empty signature resulting empty list declarations unchanged environment 
second rule allows declaration bind bind represents val bind dv struct dv path structure mv structure mv mv structure functor seal dv struct dv sig struct seal empty seal seal seal bind omit seal domain seal val val seal seal pointcut call pc pointcut call seal ds seal seal structure struct ds sig structure struct seal seal structure functor structure functor module system operational semantics pointcut omitted signature clients see 
rule sealing value declaration generates fresh label maps old value variable binding returns declaration mapping variable 
client advice new label affect external calls internal refer old label clients change 
rule pointcuts passes pointcut value clients unchanged allowing clients advise label referred pointcut 
rules structure declarations recursively seal internal struct declarations leave functors unchanged 
typechecking typechecking rules shown largely standard 
qualified names typed binding signature module structure bindings declaration signature signature bound module 
rule struct simply puts sig wrapper declaration signature 
rules sealing functor application allow module passed context supertype signature expected 
sig name structure structure struct sig struct seal functor functor open modules typechecking sub reflex sub trans sig sig sub sig sub omit sub decl sub contra signature subtyping shows definition signature subtyping 
subtyping reflexive transitive 
subtype signatures may additional bindings signatures constituent bindings covariant 
subtyping rule functor types contravariant 
type soundness extended open modules tinyaspect enjoys type soundness property base system 
theorems proofs similar omit 
expressiveness open modules sacrifice amount obliviousness order support better information hiding 
base code completely oblivious aspects author module expose relevant internal events pointcuts aspects advise 
design preserves important cases obliviousness module completely oblivious aspects advise external calls interface 
module expose interesting implementation events pointcuts oblivious aspects interested events 
pointcuts interface module defined respect rest module implementation pointcut operations available aop languages 
possible concern strategy adding pointcut interface base module may impossible source code module changed 
case modularity benefits open modules achieved environmental support associating external pointcut base module 
base module updated maintainer pointcut responsible pointcut ensure semantics invalidated changes base module 
experiment 
companion performed applying ideas open modules space war small demonstration application distributed aspectj 
experiment far small provide definitive results 
open modules support nearly aspects program changes minor changes code 
concern system handle extremely invasive debugging aspect 
debugging inherently non modular activity view positive sign module system support 
practical system debugging supported external tools compiler flag exception encapsulation rules debugging activity 
comparison non aop techniques 
way evaluate expressiveness open modules compare non aop alternatives 
alternative wrappers aspects intercept incoming calls module callbacks pointcuts module interface 
aspect oriented nature open modules provides advantages wrapper callback solution formalism supports simple pointcuts design open modules compatible quantification constructs languages aspectj allowing functions module advised single declaration :10.1.1.28.287
implementing similar functionality conventional wrappers quantification far tedious wrapper explicitly applied function 
open modules locally defined aspect implement crosscutting concern extending interface number modules 
wrappers capture concerns modular way target module individually wrapped 
callbacks invasive respect implementation module implementation explicitly invoke callback appropriate points 
contrast pointcut interfaces non invasive pointcut defined orthogonally rest module implementation providing better support separation concerns 
advantages illustrate quantification oblivious extension provided open modules distinguish proposal solutions aspects 

abstraction example programs section helpful understanding benefits module system intuitive level 
able point concrete property enables separate reasoning clients implementation module 
reynolds abstraction property fits requirements natural way 
intuitively abstraction property states module implementations semantically equivalent client tell difference 
property important benefits software engineering 
enables reasoning properties module isolation 
example implementation module known correct prove second implementation correct showing semantically equivalent implementation 
second abstraction property ensures implementation module changed semantically equivalent affecting clients 
abstraction property helps programmers effectively hide information change suggested parnas classic 
tinyaspect state abstraction property follows 
modules logically equivalent module signature client declarations typed assuming variable type client behaves identically executed module 
intuitively modules logically equivalent bound functions module equivalent 
functions equivalent produce equivalent results equivalent arguments client advises functions pointcuts exported module 
illustrates importance sealing limit scope client advice 
modules sealed proved equivalent assuming clients advise exported pointcuts 
sense module sealing enables separate reasoning impossible 
formalizing abstraction define abstraction formally judgments logical equivalence values written read context set private labels value environment logically equivalent value environment type similar judgment form logically equivalent expressions 
judgments depend set labels private abstractions protected advice labels may advised client order expressions logically equivalent labels way 
rules logical equivalence values defined 
rules straightforward example unit value values type unit equivalent 
logical equivalence defined coinductively greatest fixed point value rules expression rules 
fl fl coinductive definition logical equivalence expressions interesting rule function values 
function values equivalent logically equivalent argument values refer private labels produce equivalent results 
similar rule logical equivalence functors 
empty declarations equivalent label equivalent long set private labels 
val declarations equivalent bind variable label labels generated fresh declaration choose equal proving equivalence 
label exposed val declaration visible private set labels 
pointcut structure declarations just check equality components 
declaration forms ensure subsequent declarations equivalent 
order modules equivalent declarations inside equivalent 
define equivalence environments rule equivalent labels 
shows rules logical equivalence expressions 
expressions equivalent equivalent values 
expressions bisimilar respect set labels 
look sequence labels ignoring hidden set labels diverging reducing logically equivalent values clients advice observe lookups label 
formalize rules 
allows expressions take number steps include lookup labels labels 
represent evaluation relation identical rule lookup may applied labels 
resulting machine configurations logically equivalent respect 
second rule states expressions look label long argument values equivalent long surrounding contexts treat returned values equivalent ways 
property defined final rule stating contexts equivalent equivalent argument values execute unit fn fn iff fl fl fn fn iff val dv val iff dv pointcut call dv iff dv pointcut call pc structure mv dv iff mv structure dv struct dv struct sig iff dv iff fl fl iff domain domain domain domain domain coinductive definition logical equivalence values logically equivalent way 
note logical equivalence coinductively defined expressions diverge logical equivalence rules logically equivalent 
true inductive definition fixed point rules requires value base case greatest fixed point includes infinite sequences logically equivalent expressions 
coinduction essential making definition meaningful definition logically equivalent values expressions mutually dependent 
defined logical equivalence state abstraction theorem theorem abstraction mv structure mv structure proving abstraction section outline proof abstraction tinyaspect 
order prove abstraction theorem need definition equivalence includes logical equivalence special case explicitly relates structurally equivalent expressions set client declarations abstraction theorem 
define structural bisimilarity relation written structural equality expressions closed expressions values embedded corresponding places expressions may logically equivalent 
bisimilarity judgment labeled complexity roughly exactly denoting number steps derivation 
formal definition largely straightforward shown 
variable bisimilar complexity value bisimilar logically equivalent value complexity 
equivalent non value expressions equivalent complexity 
allow bisimilar expressions nested logically equivalent contexts 
important complexity judgment complexity underlying expression bisimilarity judgment adding equivalent contexts bisimilar expressions execute parallel need add additional contexts increasing complexity judgment 
rest bisimilarity definitions straightforward example functions bisimilar bodies important lemma proof shows labels matter definitions bisimilarity logical equivalence 
intuitively property allows clients apply advice label add new labels environment affecting equivalence relations underlying program 
lemma extension domain domain proof extension induction structure cases var empty trivially satisfied 
cases equiv ctx follow directly induction hypothesis 
remaining cases depend corresponding property holding true logical equivalence values contexts respectively 
prove considering set expression pairs var val values values fv fv fn fn app bind bind empty path equiv ctx fn bind values struct struct struct seal fv fv functor functor bisimulation relation context pairs similarly 
wish show satisfying conditions 
showing rules logical equivalence expressions values contexts closed respect cross product expression pairs environment pairs 
means cross product fixed point rules coinduction principle greatest fixed point 
proof case analysis rule conclude cases easy depend 
fact rule rule lows evaluation relation 
rela tion allows dependencies labels assumed identical new environments proof complete 
show bisimulation preserved substitution logically equivalent values 
lemma substitution proof substitution induction complexity judgment defined subscript induction simultaneous corresponding inductions pointcut substitution preservation equivalence lemmas 
simultaneous induction necessary lemmas interdependent lemma depends lemmas complexity equivalence lemma depends preservation lemma complexity induction founded 
base case complexity 
nested induction derivation judgment case analysis rule result complexity subcase var substitution variable equal variable expression case holds values substituted equivalent judgment remains complexity 
expressions stay remain bisimilar complexity 
subcase val values closed expressions stay remain bisimilar complexity 
subcase equiv judgments relate closed expressions expressions values able take step 
implies expressions closed unaffected substitution remaining bisimilar complexity 
subcase ctx nested induction hypothesis substitution underlying expression preserve equivalence complexity 
contexts closed unaffected substitution apply ctx rule show substitution expressions bisimilar complexity 
inductive case assume complexity judgment 
assume truth substitution preservation lemmas size prove substitution lemma size nested induction derivation case analysis rule 
subcase ctx ctx subcase base case 
subcase fn induction hypothesis implies bodies functions functors remain bisimilar substitution complexity 
functions functors closed values substitution apply rules fn show functors bisimilar complexity 
functions functors closed values result substitution show values logically equivalent 
definition logical equivalence function functor values show execute logically equivalent way invoked pair logically equivalent argument values appropriate type 
induction hypothesis show substitution argument values preserves bisimilarity function bodies complexity 
apply bisimilarity implies equivalence lemma complexity show function bodies logically equivalent 
functions logically equivalent bisimilar complexity 
cases cases hold trivially applying induction hypothesis 
version substitution lemma pointcuts lemma pointcut substitution pc pc call call proof pointcut substitution induction complexity judgment defined subscript cases proof 
critical lemma proof abstraction states structural bisimilarity preserved reduction lemma bisimilarity preservation values exist exist proof bisimilarity preservation induction complexity judgment induction simultaneous corresponding induction substitution lemma 
base case complexity 
nested induction derivation judgment case analysis rule result complexity subcase var apply welltyped environment variable bindings 
subcase val values subcase equiv perform case analysis definition 
apply assumption values 
second corresponds exactly second case bisimilarity preservation observing resulting expressions logically equivalent bisimilar complexity 
third states expressions take step corresponding third case bisimilarity preservation result logically equivalent bisimilar expressions complexity 
subcase ctx nested induction hypothesis bisimilarity preservation hold subexpressions perform case analysis cases bisimilarity preservation subexpressions 
case analysis equiv apply values 
applicable possibly repeated application rule context show entire expression takes reduction steps subexpressions contexts place 
resulting nested expressions values equivalent induction hypothesis know definition logically equivalent contexts values substituted contexts logical equivalence 
resulting nested expressions values know ctx rule applies resulting expressions bisimilar 
inductive case assume complexity judgment 
assume truth preservation substitution lemmas size prove lemma size nested induction derivation case analysis rule 
subcase ctx ctx subcase base case 
subcase fn apply assumption expressions closed rules apply open expressions 
subcase app subexpressions values logically equivalent corresponding values 
label labels refer logically equivalent values bisimilarity preserved complexity reduction step 
function definition logical equivalence implies function application result logically equivalent expressions bisimilar complexity 
similar analysis applies functor 
subexpressions value rule apply 
apply logic rule ctx induction hypothesis show subexpressions remain bisimilar concluding applications remain bisimilar complexity subcase bind subexpressions values analysis rule ctx applies 
values binding rules applies 
case analysis applies val values bound logically equivalent definition bisimilarity 
apply extension lemma logical equivalence values show extending environments bound values preserves bisimilarity logical equivalence environments 
apply substitution lemma show substitution new label definitions preserves bisimilarity 
subcase completed noting resulting val declarations bisimilar rule bind 
pointcut apply pointcut substitution lemma show substituted declarations remain bisimilar 
subcase completed noting resulting pointcut declarations bisimilar rule bind 
structure substitution lemma shows resulting expressions remain bisimilar 
free expression values maps logically equivalent 
substitution lemma expressions declaration remain bisimilar substitution 
bisimilarity implies equivalence lemma complexity constructed functions logically equivalent 
apply extension lemma logical equivalence original constructed functions show extending environments preserves bisimilarity logical equivalence environments 
subcase path module subexpression value analysis rule ctx applies 
value assumption corresponding values structure logically equivalent apply rule path case holds 
subcase struct assumption declarations values 
rule context applies analysis rule app 
subcase seal module subexpression value analysis rule app applies 
value rule seal applies 
easy see new labels logically equivalent pointers corresponding old labels known logically equivalent assumption 
applying extension lemma see extended environments remain logically equivalent simple applications bind rules see generated module values bisimilar complexity equal show structural bisimilarity implies logical equivalence lemma bisimilarity implies equivalence proof bisimilarity implies equivalence induction simultaneous lemmas 
apply bisimulation preservation theorem show bisimilar expressions complexity remain bisimilar application rules type preservation theorem show result typed 
figures coinductively define logical equivalence logical equivalence greatest fixpoint rules set bisimilar expressions complexity fixpoint rules follows coinduction principle set bisimilar expressions complexity set logically equivalent expressions greatest fixpoint rules 
final lemma stating identical expressions bisimilar necessary final abstraction proof 
lemma reflexivity bisimulation fl proof reflexivity bisimulation induction structure case analysis syntactic construct 
case trivial rule syntactic construct 
prove abstraction theorem proof abstraction mv know definition reflexivity bisimulation structure structure 
complete proof applying bisimilarity implies equivalence lemma show original expressions logically equivalent 
applying abstraction abstraction theorem definition logical equivalence ensure changes implementation module application preserve application semantics 
example consider replacing recursive implementation fibonacci function implementation loop 
aspectj module system include dynamic semantics sealing operation seemingly innocuous change preserve semantics application aspect broken fact fib longer calls recursively 
open modules ensure change affect enclosing application abstraction theorem prove 
module sealed fib bound fresh label forwards external calls internal implementation fib 
show implementations module logically equivalent showing matter argument value fib function called function returns results invokes external label way 
external label fresh unused function reduces proving ordinary function equivalence easily done induction argument value 
apply abstraction theorem show clients unaffected change 

discussion formal methods 
abstraction theorem definition logical equivalence open modules broader implications modular reasoning aspect oriented programming 
example ask specify required behavior module prove module meets behavior presence aspects 
definition logical equivalence implies complete behavioral specification include just preand post conditions functions module interface ordered trace pointcuts triggered calling function interface 
trace include argument passed advice pointcut specification pointcut 
abstraction states show implementation bisimilar trace specification implementation indistinguishable implementations meet specification 
modular analysis 
interesting question perform modular analysis presence open modules 
typically modular analysis run module producing summary analyzing modules 
definition logical equivalence suggests analysis summary describe properties functions interface terms interact exposed pointcuts 
example modular escape analysis conclude function interface module capture argument provided advice capture argument 
tool support 
aspectj plugin eclipse provides integrated development environment support programming aspectj 
important feature showing function aspects apply function 
means programmer effectively predict composed behavior function aspects ensure changes code preserve behavior 
open modules abstraction theorem provide insight ide support helpful aspectj 
description aspects apply functions pointcut interface module 
just open modules developer sure semantics pointcut maintained module evolves aspectj developer ensure changes package adversely affect aspects apply 
open modules suggest way improve tool support 
order support effective software evolution tool project editable view pointcut interface modules applies 
way developer change module locally change affected pointcuts semantics maintained 
local changes propagated original pointcut definition 
module developer reason evolve module exactly open module system aspect developer take advantage full expressiveness aspectj 
scenario assumes tool see edit aspects apply piece base code 
tool provide full solution information hiding problem setting monolithic application library developed tightly integrated team 
general setting component development tool predict possible aspects client component 
difficult sure changes component affect clients ensure safety properties component hold matter aspects client apply 
open modules describe ways component may extended clients hiding implementation specific details protecting component properties 
clients obey open modules specification component get guarantee changes component break programs aspects violate important invariants component 
clients turn module checking bypass open modules interface lose guarantees 
open modules complement tool support aspectoriented programming providing benefits information hiding setting component development allowing developers integrated team gain full benefits aspects 

related formal models 
closely related formal models foundational calculus walker model aspectj jagadeesan discussed section :10.1.1.10.7635:10.1.1.10.7635
formal systems aspect oriented programming mmel provides big step semantics method call interception extension object oriented languages 
wand give untyped denotational semantics advice advice dynamic join points 
kiczales describe general model crosscutting structure implementations scheme give semantics model 
tucker krishnamurthi show scoped continuation marks untyped higherorder functional languages provide static dynamic aspects 
aspects modules 
walker currently extending calculus walker support module system 
type system includes novel feature controlling advice read change arguments results advised functions 
design pointcuts class providing flexibility compared second class pointcuts tinyaspect 
design choice breaks abstraction theorem means pointcut escape module explicitly exported module interface 
system functions advised function declaration explicitly permits system oblivious respect 
contrast tinyaspect allows advice function declarations functions exported module providing significant oblivious extensibility compromising abstraction 
lieberherr describe aspectual collaborations construct allows programmers write aspects code separate modules compose third module 
propose full aspect oriented language system richer flexible semantics formally defined 
module system encapsulate internal calls exported functions enforce abstraction property 
researchers studied modular reasoning explicit module systems 
example clifton leavens propose engineering techniques reduce dependencies concerns aspect oriented code 
module system standard ml 
tinyaspect sealing construct similar freeze operator close module extensions module calculi jigsaw related systems 
name open modules indicates modules open advice functions pointcuts exposed interface 
open classes related term indicating classes open addition new methods 

described tinyaspect minimal core language reasoning aspect oriented programming systems 
tinyaspect source level language supports declarative aspects 
small step opera tional semantics language proven type system sound 
described proposed module system aspects formalized module system extension tinyaspect proved module system enforces abstraction 
abstraction ensures clients affect depend internal implementation details module 
result programmers separate concerns code reason concerns separately 

acknowledgments gregor kiczales mira mezini ralf mmel mitch wand karl lieberherr david walker tim curtis clifton derek dreyer todd millstein robert harper anonymous reviewers comments material 

aldrich 
open modules reconciling extensibility information hiding 
aosd workshop software engineering properties languages aspect technologies splat march 
ancona zucca 
calculus module systems 
journal functional programming march 
bracha 
programming language jigsaw mixins modularity multiple inheritance 
ph thesis dept computer science university utah 
clifton leavens 
observers assistants proposal modular aspect oriented reasoning 
foundations aspect languages april 
clifton leavens chambers millstein 
multijava modular open classes symmetric multiple dispatch java 
object oriented programming systems languages applications october 
walker 
aspects information hiding modularity 
princeton university technical report tr 
filman :10.1.1.28.287
aspect oriented programming revisited 
advanced separation concerns july 
filman friedman 
aspect oriented programming quantification obliviousness 
advanced separation concerns october 
kiczales 
addressing practical software development issues aspectj pointcut interface 
advanced separation concerns july 
igarashi pierce wadler 
java minimal core calculus java gj 
object oriented programming systems languages applications november 
jagadeesan jeffrey 
untyped calculus aspect oriented programs 
european conference object oriented programming july 
kiczales hilsdale hugunin kersten palm griswold :10.1.1.21.5662
overview aspectj 
european conference object oriented programming june 
kiczales lamping mendhekar maeda lopes 
loingtier irwin 
aspect oriented programming 
european conference object oriented programming june 
mmel 
semantical approach method call interception 
aspect oriented software development apr 
lieberherr lorenz 
aspectual collaborations combining modules aspects 
computer journal september 
kiczales 
modeling crosscutting aspect oriented mechanisms 
european conference object oriented programming july 
milner tofte harper macqueen 
definition standard ml revised 
mit press cambridge massachusetts 
orleans lieberherr 
dj dynamic adaptive programming java 
reflection meta level architectures separation crosscutting concerns september 
parnas 
criteria decomposing systems modules 
communications acm december 
reynolds 
types abstraction parametric polymorphism 
information processing 
tucker krishnamurthi 
pointcuts advice higher order languages 
aspect oriented software development march 
walker zdancewic :10.1.1.10.7635
theory aspects 
international conference functional programming 
wand kiczales 
semantics advice dynamic join points aspect oriented programming 
transactions programming languages systems appear 
