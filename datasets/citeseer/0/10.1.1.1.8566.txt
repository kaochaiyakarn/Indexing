acm symposium principles programming languages popl january ownership types object encapsulation chandrasekhar boyapati laboratory computer science massachusetts technology cambridge ma chandra lcs mit edu barbara liskov laboratory computer science massachusetts technology cambridge ma liskov lcs mit edu shrira department computer science brandeis university waltham ma cs brandeis edu ownership types provide statically enforceable way specifying object encapsulation enable local reasoning program correctness object oriented languages 
type system enforces strict object encapsulation constraining allow ecient implementation important constructs iterators 
argues right way solve problem allow objects classes de ned module privileged access representations show inner classes 
approach allows programmers express constructs iterators supports local reasoning correctness classes class inner classes reasoned module 
sketches variant ownership types enable ecient software upgrades persistent object stores 
categories subject descriptors programming languages language constructs software engineering program veri cation general terms languages veri cation theory keywords ownership types object encapsulation software upgrades ability reason locally program correctness crucial dealing large programs 
local reasoning allows correctness dealt module time 
module speci cation describes expected behavior 
goal prove module satis es research supported part darpa contract nsf iis ntt 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
popl january new orleans louisiana usa 
copyright acm speci cation speci cations code modules 
way complexity proof ort formal informal kept control 
local reasoning approach sound separate veri cation individual modules suces ensure correctness composite program 
key sound local reasoning object oriented languages object encapsulation 
consider example stack object implemented linked list 
local reasoning correctness stack implementation possible objects outside directly access list nodes list nodes encapsulated presents variant ownership types specifying statically enforcing object encapsulation 
ownership types program declare owns list nodes 
type system statically ensures list nodes encapsulated type system enforces strict object encapsulation constraining allow ecient implementation important constructs iterators 
consider example iterator mentioned stack object iterator encapsulated outside iterator encapsulated directly access list nodes run eciently 
previous ownership type systems constraining support constructs iterators permissive support local reasoning example allowed objects outside mentioned stack object temporarily get direct access list nodes :10.1.1.59.6498:10.1.1.1.5802
argues right way solve problem provide special access privileges objects belonging classes module show inner classes 
variant ownership types allows inner class objects privileged access representations corresponding outer class objects 
principled violation encapsulation allows programmers express constructs iterators inner classes supports local reasoning correctness classes 
system supports local reasoning class inner classes reasoned module 
describes variant ownership types enables ecient software upgrades persistent object stores 
interest software upgrades led ownership types 
shows ownership types ensure code upgrading objects observe broken invariants interfaces unknown time written possible programmers reason correctness upgrades 
organized follows 
section discusses object encapsulation 
section describes variant ownership types enforcing object encapsulation 
section presents formal description type system 
section shows ownership types enable modular upgrades 
section discusses related section concludes 
object encapsulation object encapsulation important provides ability reason locally program correctness 
reasoning class object oriented program involves reasoning behavior objects belonging class 
typically objects point subobjects represent containing object 
local reasoning class correctness possible subobjects fully encapsulated subobjects accessible containing object 
condition supports local reasoning ensures outside objects interact subobjects calling methods containing object 
containing object control subobjects 
full encapsulation needed 
encapsulation required subobjects containing object depends 
object depends subobject calls methods furthermore calls expose mutable behavior way ects invariants stack object implemented linked list depends list items contained list 
code outside manipulate list invalidate correctness stack implementation 
code outside safely items contained doesn call methods depends identities items identities change 
similarly set immutable elements depend elements invokes equals ensure elements set equal elements immutable 
local reasoning class possible objects class encapsulate object depend 
strict object encapsulation constraining prevents ef cient implementation important constructs iterators 
example run eciently iterator abovementioned stack object needs access list nodes provide access allow objects iterators violate encapsulation 
local reasoning possible provided violations encapsulation limited code contained module 
example stack iterator 
object owner 

owner object world 

owner object change time 

ownership relation forms tree rooted world 
ownership properties world ownership relation mented module reason correctness locally examining code module 
ownership types encapsulation ownership types provide statically enforceable way specifying object encapsulation :10.1.1.59.6498:10.1.1.1.5802
idea object subobjects depends preventing accessible outside 
section presents ownership type system 
system similar described main di erence support constructs iterators type system allows temporary violations encapsulation 
disallow violation 
support constructs iterators inner classes 
key type system concept object ownership 
object owner 
owner object special owner called world 
type system statically guarantees ownership properties shown 
presents example ownership relation 
draw arrow owns gure special owner world owns objects owns owns owns 
ownership allows program statically declare encapsulation boundaries capture dependencies 
object objects depends 
system enforces encapsulation inside encapsulation boundary outside access 
object accesses object pointer methods obtain pointer 
inside encapsulation boundary outside access 
object allowed access objects owns ancestors ownership tree objects globally accessible objects objects owned world 
access objects gure 
note analogy nested procedures proc fvar class tstack tnode head null void push value tnode newnode new tnode value head head newnode pop head null return null value head value head head return value class tnode tnode value tnode tnode value value return value tnode return class class void test tstack new tstack tstack new tstack tstack new tstack tstack new tstack stack objects head tnode tstack tnode head tstack head tnode tnode head tstack head tnode tnode head head value head value head value head value head value head value world ownership relation owner polymorphism type system context java language augmented ownership types 
class definition parameterized owners 
rst owner parameter special identi es owner corresponding object 
owner parameters propagate ownership information 
parameterization allows programmers implement generic class objects di erent owners 
parameterization similar parametric polymorphism parameters owners types :10.1.1.21.2609
owner instantiated world owner parameter 
objects owned encapsulated objects accessed outside 
objects owned world accessed 
proc fvar proc ggg 
say xn pn children pn pn access pn children ancestors pn children global variables procedures 
class 
tstack clauses constrain owners shows example 
tstack stack objects 
implemented linked list 
tstack class parameterized towner 
owns tstack object towner owns objects contained tstack 
code speci es tstack object owns nodes list list nodes accessed outside tstack object 
type tstack instantiated owner parameters 
means tstack owned object created objects 
tstack owned object objects owned world 
tstack owned world objects 
ownership relation depicted assuming stacks contain elements 
dotted line indicates object directly indirectly owned world 
constraints owners type hx multiple owners type system statically enforces constraint ng 
recall ownership relation forms tree rooted world 
notation means descendant ownership tree 
notation means descendant ownership tree 
type tstack illegal world 
constraint 
extend parameterized methods 
method xk object type hx restriction kg 
constraints needed provide encapsulation presence subtyping 
illustrates point example :10.1.1.1.5802
check ownership constraints modularly necessary programmers specify additional constraints class method parameters 
example type legal towner 
allow programmers specify additional constraints clauses type system enforces constraints 
example class speci es towner 
instantiation satisfy constraint illegal 
subtyping rule declaring subtype rst owner parameter supertype subtype addition course supertype satisfy constraints owners 
rst owners match example shows type annotations written explicitly 
automatically inferred 
see section details 
class tstack tnode head null 
tstackenum elements return new tstackenum class tstackenum implements tenumeration tnode current tstackenum current tstack head getnext current null return null current value current current return boolean hasmoreelements return current null class void test tstack new tstack tenumeration elements tenumeration elements interface tenumeration getnext boolean hasmoreelements tstack iterator special corresponding objects 
subtype 
subtype rst owners match 
inner classes inner classes similar member inner classes java 
inner class de nitions nested inside classes 
shows example 
inner class tstackenum implements iterator tstack elements method tstack provides way create iterator tstack 
tstack code similar 
recall owner instantiated world owner parameter 
inner class owner instantiated outer class 
feature allows inner object access objects encapsulated outer objects 
owner current eld instantiated tstack 
current eld accesses list nodes encapsulated outer tstack object 
inner class parameterized owners just regular class 
system outer class parameters automatically visible inside inner class 
inner class uses outer class parameter explicitly include outer class parameter declaration 
tstackenum declaration includes owner parameter towner outer class 
towner visible inside tstackenum 
tstackenum declaration class tstack tnode head null 
class tstackenum implements tenumeration tnode current 
getnext writes reads tstack 
boolean hasmoreelements reads 
interface tenumeration getnext writes reads world boolean hasmoreelements reads tstack iterator ects include 
visible inside tstackenum 
note example elements method parameterized 
allows program create different iterators di erent owners 
elements returns iterator type 
type legal case towner 
requirement captured clause 
note tstackenum declared subtype 
allows create iterator encapsulated tstack program pass objects outside 
general inner classes implement wrappers expose limited interface outer object 
program create wrapper encapsulated subobject pass wrapper object outside encapsulation boundary 
encapsulation theorem system provides encapsulation property theorem 
access object owned 

inner class object proof 
consider code class chf ho variable type ho declared static scope class owner world formal class parameter formal method parameter outer class 
show rst cases constraint holds 
rst cases constraint holds trivially 
cases constraint holds 
fth case 
object class access object owned rst cases inner object fth case 
class int int size reads return void add int writes 

class intstack vec new void push int writes vec add 
void intstack writes reads int size push assert size reasoning aliasing side ects discussion variant ownership types supports local reasoning provided programmer declares depended objects owned 
theorem implies owned objects accessed inside owner inner objects 
ownership captures depends relation described section local reasoning correctness class possible class inner classes reasoned module 
ownership types expressive 
allow cient implementation constructs iterators wrappers 
furthermore allow programs create wrappers contexts underlying object inaccessible 
ability illustrated iterator globally tstack iterating 
rst ownership type system support constructs iterators generally accessible wrappers ensuring local reasoning 
discuss section 
ects clauses system contains ects clauses useful specifying assumptions hold method boundaries enable modular reasoning checking programs 
ects ownership types enable modular upgrades describe section 
system allows programmers specify reads writes clauses 
consider method speci es writes wn reads rm 
method write object call methods write ng 
method read object call methods read ng mg 
allow method read write objects named writes clause 
shows tstack iterator uses ects similar tstack iterator 
example hasmoreelements method reads object 
getnext method reads objects owned tstack writes reads object 
defn defn class extends constr body body eld meth owner formal world cn constr owner owner owner owner defn meth arg ects constr feg ects reads owner writes owner eld fd arg int formal new new arg feg fd fd cn class names fd eld names mn method names variable names owner names grammar ects clauses conjunction subtyping ects overridden method subsume ects overriding method 
dicult specify precisely ects method 
example dicult specify precisely read ects getnext method tenumeration class tenumeration expected supertype subtypes tstackenum tenumeration name speci objects getnext methods subtypes 
accommodate cases allow escape mechanism method include world ects clauses 
ownership types ects locally reason side ects method calls 
consider example code shows intstack implemented vec 
adopted example 
example method receives arguments intstack condition assert statement true aliased vec 
example method uses clause specify 
ownership relation forms tree see constraint implies aliased vec 
furthermore size declares reads objects owned intstack push declares writes reads objects owned intstack 
possible reason locally size push interfere condition assert statement true 
type system section presents formal description type system 
simplify presentation key ideas describe type system context core subset java known classic java 
add inner classes classic java augment type system ownership types 
approach extends java similar languages 
type checking presents grammar 
core type system set rules reasoning typing judgment prog defn defn world world defn class cnhf def cnhf cn def cnhf owner constr wf cnhf eld meth class cnhf extends constr eld meth constr world owner world constr env constr constr owner refl owner trans ng mg owner owner world owner world owner formal owner owner owner cn owner cn type int int type object owner type class cnhf constr 
owner constr fn ij ij ij ij subtype class cnhf extends cn ho cn hf 
cn ho cn hf fn subtype refl subtype trans wf env wf env wf dom wf env owner wf dom owner wf env constr constr constr wf owner constr constr wf meth method declared class cnhf meth meth cnhf method inherited meth cnhf class cn hg extends 
meth fn cn hg method method owner constr arg wf arg reads writes constr feg eld field declared class cnhf 
eld eld cnhf field inherited eld cnhf class cn hg extends 
eld fn cn hg eld field fd exp type world world exp sub exp ref fd fd exp ref assign fd fd exp new new exp new new exp var exp arg arg arg fe exp invoke reads writes constr feg cnhf fm owner fm constr fm fm fm type checking rules judgment meaning program yields type defn defn formed class class owner owner constr constraint constr satis ed ect subsumed ect formed type subtype wf typing environment formed eld class declares inherits eld meth class declares inherits meth eld eld formed eld meth meth formed method expression type expression type read write ects subsumed typing judgments program checked included provide information class de nitions 
environment providing types free variables subsume read write ects type de ne typing environment owner constr de ne effects de ne type system judgments 
rules judgments 
rules number predicates shown 
predicates similar predicates 
simplicity treat outermost classes rules inner classes class 
denote cn hf cn hf kn soundness type system type checking rules ensure program typed program respects properties described 
complete syntactic proof type soundness constructed de ning operational semantics extending operational semantics classic java proving typed programs reach error state generalized subject reduction theorem holds typed programs 
subject reduction theorem states semantic interpretation term type invariant reduction 
proof straightforward tedious omitted 
type inference type system explicitly typed principle onerous fully annotate method extra type information 
combination inference chosen defaults signi cantly reduce number annotations needed practice 
describe intraprocedural type inference algorithm default types similar approach 
lines code changed express java programs ownership type system 
emphasize approach inference purely intraprocedural infer method signatures types instance variables 
uses default completion partial type speci cations cases minimize required annotations 
approach permits separate compilation 
predicate meaning cycles class hierarchy class declared twice class contains inner classes name declared inherited class contains elds name declared inherited class contains methods name overriding methods return type parameter types methods overridden 
read write ects overriding method superseded overridden methods predicates type checking rules runtime overhead system described purely static type system 
ownership relations compile time type checking preserved runtime 
consequently programs runtime overhead compared regular java programs 
fact way compile run program system convert regular program type checking removing owner parameters constraints owners ects clauses 
language java purely statically typed 
java allows downcasts checked runtime 
suppose object declared type downcast ei 
result operation depends information available runtime type checker verify compile time right owner parameter assume object vector 
safely support downcasts system keep ownership information runtime 
similar keeping runtime information parameterized types 
describes eciently ownership keeping runtime information objects potentially involved downcasts types multiple parameters 
upgrades persistent object stores section shows ownership types ects clauses enable modular reasoning correctness upgrades persistent object store 
desire achieve reasoning motivation ownership types encapsulation 
persistent object store contains conventional objects similar nd object oriented language java :10.1.1.10.7303
applications access persistent objects atomic transactions necessary ensure consistency stored objects transactions allow concurrent access mask failures 
upgrades needed system improve object implementations correct errors change interfaces face changing application requirements includes incompatible changes interfaces new interface support methods old 
providing satisfactory solution upgrades persistent object stores long standing challenge 
upgrade persistent object store de ned set class upgrades class objects need change 
class upgrade triple hold class new class tfi 
indicates objects belonging old class transformed transform function tf provided programmer objects new class 
tf takes old class object newly allocated new class object initializes new class object old class object 
upgrade infrastructure causes new class object take identity old class object objects point old class object point new class object 
upgrade executed transforming objects classes replaced 
transforms interfere application access store performed eciently space time 
addition done safely important persistent state corrupted 
previous approaches provide satisfactory solution challenges application access database running upgrade keep copies database limit expressive power transforms transform functions allowed method calls 
system provides ecient solution 
performs upgrades lazily 
object transformed just application accesses application transaction interrupted run transform function 
transform runs transaction transaction commits application transaction resumed 
system allows upgrades run parallel earlier ones 
object pending transforms run upgrade order 
furthermore transform transaction encounters object pending transform earlier upgrade interrupted just application transform run pending transform continues execution pending transform commits 
details :10.1.1.1.7195
ownership types safe upgrades upgrade system ecient expressive delay application transactions avoids versions copies objects limit expressive power transform functions 
needs support modular reasoning correctness transform functions 
possible transform function encounters object interfaces invariants existed upgrade started reality transform function run application transactions transform transactions 
variant ownership types enable modular reasoning correctness transform functions 
system checks statically transform functions satisfy constraint ownership ects declarations ects clauses state objects tfs access 
tf accesses objects owns directly transitively 
transform functions satisfy ownership frequently captures depends relation discussed section typically transform functions access objects 
discuss support modular reasoning transform functions hold 
implementation ensures 
object ected upgrade accessed object owned ensure mechanisms 
owned object encapsulated type system guarantees accessed rst 
owned object shared inner class object system causes accessed just inner class object rst upgrade 
mechanism described detail 
holds prove order processing transforms cause problems 
particular show applications interfere transform functions transform functions unrelated objects interfere transform functions related objects run pre determined order object transformed owned subobjects 
proofs 
holds ensure transform functions encounter expected interfaces invariants 
supports modular reasoning transform function reasoned extra method old class 
related euclid rst languages considered problem aliasing 
stressed need better treatment aliasing object oriented programs :10.1.1.30.5600
early islands balloons focused fully encapsulated objects subobjects object access accessible outside object 
universes enforces full encapsulation read 
full encapsulation signi cantly limits expressiveness needed 
esc java pointed encapsulation required subobjects containing object depends esc java unable enforce encapsulation 
ownership types encapsulation ownership types provide statically enforceable way specifying object encapsulation 
proposed formalized 
systems enforce strict object encapsulation signi cantly limiting expressiveness 
require subtype owners supertype 
subtype 
support iterators 
prfj scj joe extended ownership types support natural form subtyping :10.1.1.1.5802
violating encapsulation joe introduces constraint type multiple owners rst owner owners 
result joe program create pointer object object owned 
prfj scj allow object contain pointers subobjects owned di erent object ects clauses prevent program pointers 
systems ectively enforce encapsulation object elds 
support constructs iterators allow method local variables violate encapsulation 
support local reasoning 
uses ownership types aid program understanding 
ownership type systems allows programmers ownership information reason aliasing 
exible ownership type systems 
ownership type systems enforce encapsulation properties 
illustrated example :10.1.1.1.5802
ownership types extended inner classes 
systems enforce property stated section support local reasoning 
ownership types enforce properties 
parameterized race free java prfj uses ownership type system prevent data races multithreaded programs 
safe concurrent java scj extends prevent data races deadlocks :10.1.1.1.5802
systems combined approach enforce object encapsulation prevent data races deadlocks 
sketches way doing :10.1.1.1.5802
combines region types type system statically ensure object encapsulation safe region memory management :10.1.1.10.8871:10.1.1.1.3704
related type systems linear types unique pointers control object aliasing :10.1.1.16.5732:10.1.1.31.5002
linear types low level languages support safe explicit memory deallocation track resource usage :10.1.1.14.7406:10.1.1.14.663
linear types unique pointers orthogonal ownership types conjunction provide expressive systems 
prfj rst system combines ownership types conventional unique pointers 
proposes better approach allows program specify unique external pointer object internal pointers object subobjects 
ects clauses useful specifying assumptions hold method boundaries 
ects enable modular checking programs 
prfj rst system combine ects ownership types statically prevent data races 
combine ects ownership preventing deadlocks program understanding :10.1.1.1.5802
uses ects ownership enable lazy upgrades 
data groups name groups objects ects clause write modular speci cations presence subtyping 
ownership types provide alternate way writing modular speci cations 
ownership types name groups objects ects clause name owner name objects transitively owned owner 
presents example expressed ownership types 
data groups implemented theorem prover principle exible 
pivot uniqueness imposes drastic restrictions pivot elds 
ownership types impose restrictions require owner object unique 
owner exclusion constraint hard coded 
system programmers specify arbitrary constraints owners clauses owner exclusion default 
systems tvla pale roles specify shape local object graph detail ownership types 
tvla verify properties input program tree output tree 
pale verify data structures expressed graph types 
roles verify global properties participation objects multiple data structures 
roles support compositional interprocedural analysis 
contrast systems take exponential time veri cation ownership types provide lightweight practical way constrain aliasing 
object encapsulation enables sound local reasoning program correctness object oriented languages 
ownership types provide way specifying statically enforcing object encapsulation 
type system enforces strict object encapsulation constraining allow ecient implementation important constructs iterators 
argues right way solve problem allow objects classes de ned module privileged access representations 
show inner classes 
variant ownership types allows objects inner classes privileged access representations corresponding objects outer classes 
principled violation encapsulation allows programmers express constructs iterators wrappers inner classes 
system allows wrappers global contexts objects wrap 
system supports local reasoning correctness classes class inner classes reasoned module 
describes rst ownership type system expressive support iterators wrappers supporting local reasoning 
addition describes application technique enable modular reasoning upgrades persistent object stores 
ownership types purposes preventing data races deadlocks safe region memory management 
ownership types require little programming overhead type checking fast scalable provide bene ts er promising approach making object oriented programs reliable 
acknowledgments daniel jackson viktor greg nelson martin rinard alexandru useful discussions comments earlier drafts 
agesen freund mitchell 
adding type parameterization java language 
object oriented programming systems languages applications oopsla october 
aldrich chambers 
alias annotations program understanding 
object oriented programming systems languages applications oopsla november 
almeida 
balloon types controlling sharing state data types 
european conference object oriented programming ecoop june 
atkinson hamilton 
scalable recoverable implementation object evolution pjama platform 
persistent object systems pos september 
atkinson jordan spence 
design issues persistent java type safe object oriented orthogonally persistent system 
persistent object systems pos may 
banerjee naumann 
representation independence con nement access control 
principles programming languages popl january 
banerjee kim kim korth 
semantics implementation schema evolution object oriented databases 
acm sigmod international conference management data may 
vitek 
con ned types 
object oriented programming systems languages applications oopsla october 
boyapati 
distributed persistent java system 
sm thesis massachusetts institute technology september 
boyapati lee rinard 
safe runtime downcasts ownership types 
technical report tr mit laboratory computer science june 
boyapati lee rinard :10.1.1.1.5802
ownership types safe programming preventing data races deadlocks 
object oriented programming systems languages applications oopsla november 
boyapati liskov shrira 
ownership types safe lazy upgrades object oriented databases 
technical report tr mit laboratory computer science july 
boyapati liskov shrira moh richman 
lazy modular upgrades persistent object stores 
submitted publication november 
boyapati rinard 
parameterized type system race free java programs 
object oriented programming systems languages applications oopsla october 
boyapati jr rinard 
ownership types safe region memory management real time java 
submitted publication november 
bracha odersky stoutamire wadler 
making safe past adding genericity java programming language 
object oriented programming systems languages applications oopsla october 
gemstone data management system 
kim lochovsky editors object oriented concepts databases applications 

carey persistent applications 
acm sigmod international conference management data may 
clarke 
object ownership containment 
phd thesis university new south wales australia july 
clarke drossopoulou 
ownership encapsulation disjointness type ect 
object oriented programming systems languages applications oopsla november 
clarke noble potter 
simple ownership types object containment 
european conference object oriented programming ecoop june 
clarke potter noble 
ownership types exible alias protection 
object oriented programming systems languages applications oopsla october 
clarke 
external uniqueness 
workshop foundations object oriented languages fool january 
crary walker morrisett 
typed memory management calculus capabilities 
principles programming languages popl january 
day gruber liskov myers 
subtypes vs clauses constraining parametric polymorphism 
object oriented programming systems languages applications oopsla october 
deline fahndrich 
enforcing high level protocols low level software 
programming language design implementation pldi june 
deline fahndrich 
adoption focus practical linear types imperative programming 
programming language design implementation pldi june 
detlefs leino nelson 
rep exposure 
research report compaq systems research center july 
deux story 
ieee transactions knowledge data engineering tkde march 
flanagan freund 
type race detection java 
programming language design implementation pldi june 
flatt krishnamurthi felleisen 
classes mixins 
principles programming languages popl january 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley 
gosling joy steele 
java language speci cation 
addison wesley 
greenhouse boyland 
object oriented ects system 
european conference object oriented programming ecoop june 
grossman morrisett jim hicks wang cheney 
region memory management cyclone 
programming language design implementation pldi june 
hogg 
islands aliasing protection object oriented languages 
object oriented programming systems languages applications oopsla october 
hogg lea wills de :10.1.1.30.5600
geneva convention treatment object aliasing 
oops messenger april 
javasoft 
inner class speci cation february 
available java sun com products jdk 
klarlund schwartzbach 
graph types 
principles programming languages popl january 
lam rinard 
role analysis 
principles programming languages popl january 
lampson horning london mitchell popek 
report programming language euclid 
sigplan notices february 
leino 
data groups specifying modi cation extended state 
object oriented programming systems languages applications oopsla october 
leino nelson 
data abstraction information hiding 
research report compaq systems research center november 
leino poetzsch ter zhou 
data groups specify check side ects 
programming language design implementation pldi june 
lerner habermann 
schema evolution database reorganization 
object oriented programming systems languages applications oopsla october 
liskov castro shrira adya 
providing persistent objects distributed systems 
european conference object oriented programming ecoop june 
liskov moh richman shrira cheung boyapati 
safe lazy software upgrades object oriented databases 
technical report tr mit laboratory computer science june 
liskov snyder atkinson scha ert 
abstraction mechanisms clu 
communications acm cacm august 
lucassen gi ord 
polymorphic ect systems 
principles programming languages popl january 
madsen moller pedersen nygaard 
object oriented programming beta programming language 
addison wesley 
minsky :10.1.1.16.5732
alias free pointers 
european conference object oriented programming ecoop july 
moeller schwartzbach 
pointer assertion logic engine 
programming language design implementation pldi june 
muller poetzsch ter 
universes type system controlling representation exposure 
poetzsch ter meyer editors programming languages fundamentals programming 

myers bank liskov 
parameterized types java 
principles programming languages popl january 
noble 
iterators encapsulation 
technology object oriented languages systems tools june 
object design objectstore advanced api user guide release 
stein 
class modi cation gemstone object oriented dbms 
object oriented programming systems languages applications oopsla october 
sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
transactions programming languages systems toplas january 
boyapati jr rinard 
type system safe region memory management real time java 
technical report tr mit laboratory computer science november 
tofte talpin 
region memory management 
information computation february 

parametric polymorphism java approach translation re ective features 
object oriented programming systems languages applications oopsla october 
wadler :10.1.1.31.5002
linear types change world 
broy jones editors programming concepts methods 

wright felleisen 
syntactic approach type soundness 
information computation november 

