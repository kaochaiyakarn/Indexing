scheduling timed automata oded maler may document phd thesis author defended grenoble november 
verimag av 
de france maler imag fr contents contribution 
related 
job shop scheduling problem 
disjunctive graph representation 
constrained optimization formulations 
enumerative methods 
approximation methods 
discrete verification graph algorithms reachability 
shortest paths 
adding time automata explicit modeling time 
clock variables 
basics timed automata 
deterministic job shop scheduling formal definitions 
modeling timed automata 
modeling jobs 
modeling job shop specifications 
runs schedules 
shortest path timed automata reachability 
laziness non laziness 
lazy schedule 
immediate lazy runs 
search algorithm 
reducing search space 
domination test 
best search 
sub optimal solutions 
experimental results 
contents preemptive job shop scheduling modeling stopwatch automata 
modeling jobs 
global model 
runs schedules 
efficient schedules 
searching efficient runs 
experimental results 
task graph scheduling problem 
modeling timed automata 
adding deadlines release times 
experimental results 
scheduling uncertainty problem 
hole filling strategy 
adaptive scheduling 
modeling timed automata 
optimal strategies timed automata 
implementation 
experimental results 
chapter contribution develops new methodology posing solving scheduling problems 
essence approach model system timed automaton schedules correspond paths automaton optimal schedules correspond shortest paths 
methods propose inspired existing bodies knowledge 
algorithmic verification methodology goal prove properties concerning runs discrete transition system automaton 
verification algorithms way graph algorithms explore paths transition graph 
slightly richer models numerical weights assigned arcs nodes graph formulate solve shortest path algorithms find minimal cost path nodes 
goal algorithms find optimal schedules order need find way extend shortest path algorithms problems cost associated path time elapsed 
part document start short survey job shop problem chapter techniques traditionally solution 
chapter give survey basic algorithms exploring directed graphs 
chapter review naive approach expressing passage time weighted automata move timed automata 
second part concerns approach 
model classical job shop problem chapter extend model treat preemption chapter partially ordered tasks chapter scheduling problems temporal uncertainty chapter 
problems develop algorithms implement test performance benchmark examples 
document contribution theory practice scheduling analysis timed automata 
related viewed context extending verification methodology orthogonal directions verification synthesis qualitative quantitative evaluation behaviors 
verification check existence certain paths automaton synthesis automaton design choices remove transitions necessary choices property satisfied 
add quantitative dimension chapter 
case duration path verification transformed evaluation worst performance measure paths synthesis restriction automaton optimal paths 
idea applying synthesis timed automata explored wh 
algorithm safety controller synthesis timed automata operation zones reported mps amp example simple scheduler amps 
algorithm generalization verification algorithm timed automata hnsy acd kronos bdm 
works treating scheduling problems synthesis problems timed automata agp emphasis properties existence feasible schedule presence uncontrolled adversary 
transition quantitative evaluation criteria cy timed automata compute bounds delays real time systems ccm variants shortest path problems solved timed model weaker timed automata 
knowledge quantitative synthesis timed automata am problem solved timed automaton controlled uncontrolled transitions restrict automaton way configuration worst case time reach target state minimal :10.1.1.43.6815
adversary problem corresponds finding shortest path 
due presence adversary solution am employs backward computation dynamic programming iterative computation function indicates minimal time reaching target state 
implementation forward algorithm developed viewed iterating function indicates minimal time reach initial state 
reachable states augmented clock space relational representation time framework vhs verification hybrid systems project simplified model steel plant case study bs 
model features job shop scheduling problem upper bounds time steps transportation problems proposed timed automaton model plant feasible schedules extracted 
direction concerned vhs case study cyclic experimental batch plant dortmund optimal dynamic scheduler derived ny 
idea heuristic search useful shortest path problems verification timed automata verification general evaluation function guide search target goal 
possibilities investigated bfh classes examples including job shop scheduling problems various search procedures heuristics explored compared 
shown order find shortest paths timed automaton sufficient look acyclic sequences symbolic states fact need due acyclicity job shop automata algorithm forward reachability introduced 
generalization shortest path problem investigated bfh atp model different price staying state total cost associated run progresses different slopes path 
proved problem finding path minimal cost solvable 
chapter job shop scheduling job shop problem popular problems scheduling theory 
hand simple intuitive hand general domain exhibits difficulty combinatorial optimization 
difficulty theoretical constrained versions problem np hard practical instance problem jobs machines proposed fisher thompson remained unsolved years spite research effort spent 
rest section give informal presentation problem mention methods suggested past solution 
problem job shop problem consists finite set 
jobs processed finite set 
mm machines 
job finite sequence steps executed step pair form indicating required utilization machine time duration machine process step time due precedence constraints step job may processed time 
steps preempted started 
objective determine starting times step order minimize total execution time jobs time step terminates 
problem denoted scheduling community cmax cmax maximum completion time called makespan 
example consider jobs scheduled machines 
job consists steps lasts time units carried machine second lasts time units machine 
schedules depicted length length optimal schedule 
schedules represented gantt diagram showing evolution job machines 
chapter 
job shop scheduling schedules represented gantt diagram disjunctive graph representation lack resource conflicts job uses distinct set machines optimal schedule achieved letting job execute steps soon possible start immediately step move step soon previous step terminates 
case minimal makespan maximal jobs sum step durations 
difficult interesting part problem comes conflicts job want start step corresponding machine occupied job 
optimal schedule need greedy principle start step soon enabled globally better wait leave machine free step job 
type decisions distinguishes schedule seen intuitive manner disjunctive graph model introduced roy sussman rs 
disjunctive graph associated job shop problem graph set nodes corresponding steps problem additional fictitious nodes start 
positive weight associated node equivalent duration corresponding step 
precedence constraints steps job represented set directed edges indicates step immediate predecessor step resource conflicts represented set undirected edges step step machine clearly equivalence relation denote em subset corresponding machine orientation subset machine linear order 
orientation seen defining priority relation steps requiring machine 
examples orientation graph appears job priority job machine orientation corresponding schedule opposite orientation schedule 
chapter 
job shop scheduling start start orientations corresponding schedules vij node corresponding step job orientation length longest path start equal length shortest schedule schedules satisfy corresponding priority relation 
finding optimal schedule reduces finding priority relation associated orientation leads minimal longest path 
finitely priority relations problem solvable number exponential problem intractable 
note partial choices priorities priorities redundant example job uses early step job uses machine case priority relation need stated explicitly 
constrained optimization formulations alternative formulation problem constrained linear optimization problem combinatorial difficulty manifested non convexity set feasible solutions 
purpose formulation write job sequence steps mi di mi di 
mim dim tij denote start time step job global termination time 
job shop problem formulated mathematically form chapter 
job shop scheduling minimize tim maximal makespan subject 
tik tik precedes mik dik mik tik dik tik djk mik dik precedes djh djh precedes mik dik see question priority appears form disjunction 
transform constraints disjunctive normal form disjunct correspond priority relation problem transforms trivial linear programming problem 
attempt avoid enumeration priority relation stay framework linear programming transform problem mixed integer linear programming milp format manne ma 
milp problem linear program variables integers 
job shop problem integer variables binary model disjunctive constraints 
minimize tim maximal makespan subject 
tik mk tik precedes mik dik mik tik dik tik djk big number compact mathematical formulations large number constraint required ma number integer variables grows exponentially 
thompson hlp mention integer programs led practical methods solutions french gt expresses view integer programming formulation scheduling problems computationally infeasible 
best results obtained mathematical formulation due lagrangian relaxation lr approaches fr ft decomposition methods dr results indicate solutions usually poor quality 
enumerative methods embedding problem continuous optimization framework approaches enumeration search space feasible solutions 
order avoid exhaustive search enumerative methods clever elimination techniques reduce number solutions need explored 
general framework search called branch bound bb best explained example 
suppose search space consists priority relations permutations 
create permutations incrementally example decide 
choice amounts choosing subset possible permutations permutation corresponds leaf search tree 
crucial component bb ability evaluate quality partial choice non leaf node approximation 
general chapter 
job shop scheduling idea choose full branches search tree evaluate 
gives upperbound problem minimization quality solution 
search conducted tree cutting branches estimated evaluation worse upper bound 
search space priority relations applications bb job shop problem proposed balas followed including carlier carlier pinson cpp cook brucker bjs clausen pc boyd bb martin ma 
computational study indicates improvements achieved bb methods mainly attributed improvement computer technology techniques 
approximation methods approximation methods guarantee optimal solutions attain near optimal solutions moderate computing time adequate large problems 
main categories approximation techniques priority dispatch rules heuristics constraint satisfaction local search methods 
approximation applied job shop problem developed basis priority dispatching rule pdr 
method step operations available scheduled assigned priority operation highest priority chosen sequenced 
usually runs pdrs order achieve valid results 
best results due technique sb 
deviations optimum high results suggest pdrs suitable initial solution technique 
shifting bottleneck sb procedure decomposes job shop problem series subproblems 
schedules machines focuses bottleneck machines 
example approach shifting bottleneck procedure adams 
abz general weakness sb approaches level programmer sophistication required 
constraint satisfaction techniques aim reducing effective size search space applying constraints restrict order variables selected sequence possible values assigned variable 
value assigned variable inconsistency arising removed 
chapter 
job shop scheduling techniques applied solve job shop problem bpn cy na pt np 
chapter discrete verification graph algorithms reachability domain verification concerned proving systems computer programs digital circuits behave required contain bugs conceivable circumstances 
typically component system modeled automaton system finite set states transitions states corresponds events actions performed component 
framework job job shop problem modeled automaton states represent progress job sequence steps transitions correspond initiation termination steps 
automaton characterizing system obtained composing automata components obtaining automaton states elements cartesian product state sets components 
set possible behaviors system represented set paths transition graph size grows exponentially number components 
technically problem verification reduced problem checking existence certain paths directed graph transition graph automaton 
simplest type properties verification applied reachability properties properties verified path depending visits specific states 
cases want check behaviors avoid set bad states example state machine jobs want behaviors get stuck proceed final state example state jobs terminated 
properties examples safety liveness properties respectively 
algorithmic approach verification known model checking uses graph algorithms order explore paths automaton show satisfy complex properties 
sequel survey basic algorithms exploring directed graphs starting solve reachability problems 
assigning numerical weights automaton transitions associate real numbers length cost runs search runs optimal sense shortest path algorithms 
automata directed graphs describe essentially objects terminology notation automata theory 
definition finite state automata finite state automaton pair finite set states transition relation 
finite run automaton starting state sequence states qi qi 

qk forms compositions depending mode interaction components features scope document 
chapter 
discrete verification graph algorithms graph theoretic terminology states vertices nodes transitions edges arcs runs paths 
succ re denote sets successors predecessor state succ re 
useful concept visualizing possible runs automaton starting state unfolding automaton tree constructed starting adding nodes transitions successors repeating procedure recursively nodes 
automaton contains cycles paths leading state unfolding infinite 
finite size exponential size automaton 
automaton depicted initial part unfolding shown 
automaton unfolding automaton chapter 
discrete verification graph algorithms demonstrate various approaches graph searching order solve reachability problem automaton states path leading 
clearly answer question positive unfolding automaton starting contains node labeled simplest algorithm doing breadth search bfs algorithm described 
algorithm maintains data structures set explored states successors encountered ordered list waiting states need explored called frontier search 
algorithm terminates reaching answering computing states reachable reaching termination algorithm guaranteed finiteness algorithm reachability bfs waiting explored reached reached waiting pick waiting explored succ explored reached insert waiting insert explored remove waiting return reached note bfs explores unfolding automaton levels order explores nodes tree consistent distance root distance means number transitions 
addition answer want obtain path exists modify algorithm storing inserted node path led inserting waiting inserting bfs algorithm advances parallel paths depth search dfs algorithm attempts reach path move 
technically difference algorithms place new nodes added waiting list bfs dfs 
words list fifo bfs lifo dfs 
algorithm reachability dfs chapter 
discrete verification graph algorithms waiting explored reached reached waiting pick waiting explored succ explored reached insert waiting insert explored remove waiting return reached note algorithms specified component order successors node explored 
see examples choice may affect behavior algorithms especially dfs case path exists 
example consider automaton depicted reachability problems reachable reachable answer negative search algorithms computing states reachable 
see behavior algorithms exploration ordering successors succ succ 
dashed nodes indicate places search stopped nodes successors explored explored paths 
chapter 
discrete verification graph algorithms breadth search depth search explored search bfs dfs trees problem 
search trees successor ordering see 
bfs finds shortest terms transitions path dfs ordering finds longer run 
sensitivity dfs ordering successors demonstrated show behavior algorithm successors ordered 
bfs finds shortest path exploration dfs finds path 
chapter 
discrete verification graph algorithms breadth search depth search search trees 
breadth search search trees 
depth search certain application domains useful evaluation function states sophisticated search procedure 
example state space automaton consists boolean tuples dynamics defined certain way hamming distance state give indication close goal 
algorithm keeps waiting list ordered measure called best search algorithm extensively job shop problem 
algorithms described far explore automaton forward direction starting alternatively backwards starting state computing predecessors reaching exhausting test set state reached 
way backward search automaton construct automaton inverse transition relation 
solving reachability problem equivalent solving reachability problem backward search 
chapter 
discrete verification graph algorithms important mention transition graphs automata treated verification typically big stored explicitly computer memory generated fly search 
successors global state generated choosing time transition components components transition common component transforming global state effect transition 
shortest paths automata construct job shop problem answer reachability problem obvious absence constraints deadlines path initial state job started final state jobs terminated 
fact infinitely paths corresponding different feasible schedules optimization problem choose shortest makespan 
done techniques shortest path algorithms originally applied weighted automata graphs 
weighted automata associate cost energy time transitions 
nodes correspond physical locations weight associated edge correspond length route vertices 
formally weighted automaton function assigns transition weight wq 
finite run associate cost 
wk qk 
wk shortest path states run minimal assume positive shortest path states cycles 
unfolding weighted automaton tree labeled pairs starting generating node successors form wp 
clearly node tree corresponds distance corresponding path 
weighted automaton unfolding appear figures 
finding shortest path equivalent finding node minimal unfolding automaton 
weighted automaton chapter 
discrete verification graph algorithms unfolding weighted automaton bfs algorithm reaching exists shorter path tran sitions 
example bfs reach path shorter path 
bfs algorithm applied automata exists known algorithm due dijkstra 
gives shortest path state graphs positive weights 
dijkstra algorithm viewed iterating function iteration length shortest path having transitions 
reachable steps 
algorithm terminates holds length shortest path algorithm dijkstra algorithm chapter 
discrete verification graph algorithms repeat min re chapter adding time automata models finite state automata express qualitative temporal relations events system 
say events precedes specify natural way quantity time separates 
application domains real time programming circuit timing analysis correctness system depends relative speeds system environment 
need formalism express quantitative timing features systems response time programs propagation delays logical gates constraints inter arrival times external events 
context scheduling problems express duration step job constraint time elapsed initiation termination transitions 
proposals extending verification methodology model quantitative time proposed late timed automaton model alur dill acd ad turned useful 
model rich express timing problems practical interest basic reachability problems solved algorithmically hnsy extensions graph search algorithms section chapter :10.1.1.26.7422
timed automata viewed special class hybrid systems systems combine discrete transitions continuous evolution type usually described differential equation 
intuition easy grasp reading 
timed automata incrementally investigating straightforward approaches adding quantitative time automata 
explicit modeling time consider processes execution times time units respectively 
process basic modes waiting starting active executing finished having passed time active mode 
state process active mode determined amount time process started 
fix time granularity time unit model processes automata 
states initial state indicating process inactive final state 
states represent amount time elapsed active mode 
automaton types transition immediate transitions start consume time special time passage transition tick indicating passage time unit 
behaviors processes runs automaton consisting sequences states types transitions 
example behavior waits time unit starts captured run tick start tick tick tick discrete formalism quantitative timing information added petri nets quite popular modeling manufacturing systems 
chapter 
adding time automata corresponding duration number tick transitions 
tick tick start tick tick tick start tick tick tick tick automata corresponding automata run parallel automaton take immediate transitions independently tick transitions synchronized process takes transition need take 
effect tick transition active process state move state 
automaton shown 
starts initial state processes waiting 
processes start executing number ticks possible behaviors system correspond runs example behavior processes wait time units start time captured run tick tick start start tick tick tick behavior starts immediately starts time units represented run start tick tick start tick tick fact behaviors independent immediate transitions occur time usually represented run run corresponding different interleaving concurrent transitions 
example run fragment start start replaced start start 
chapter 
adding time automata behavior starts immediately starts unit terminates represented run start tick tick tick start tick tick tick duration run time initial state just number ticks run units respectively 
processes choose perform start transition independently possible combination clock values possible reflecting different choice past 
lead state explosion number processes grow 
addition refinement time scale letting events occur time instants multiples increase number states automaton 
advantage representation allows stay familiar framework automata apply standard reachability shortest path algorithms timed systems assigning weight tick transitions immediate transitions chapter 
adding time automata tick tick tick start start start start tick start tick start tick tick start tick tick tick start tick tick clock variables tick tick global automaton 
tick start compact representation automata achieved special auxiliary variables represent time passage encoding elapsed time explicitly inside states 
clock variables counters reset zero active state entered incremented tick tick chapter 
adding time automata tick value tested transitions leave active states 
shows done automata adding clock variables 
state configuration augmented automaton pair form explicit state value variable 
clock variables range non negative integers special value indicating clock active state 
run look tick tick tick tick tick tick tick tick start start tick tick automata clocks variables 
note difference approaches purely syntactic 
expand automata adding clock values states obtain automata isomorphic see 
chapter 
adding time automata tick tick start tick tick tick start tick tick automata expanded explicit representation clock values state 
compose obtain global automaton looks simpler 
simplicity transition graph misleading 
consider example state processes active 
transitions leaving state guarded conditions respectively 
state tell transitions taken depends values clocks turn depends previous history clocks reset zero 
worst case reachability algorithms need expand modeling clock variables change worst case complexity reachability problem allows symbolic methods arbitrary time granularity 
tick tick chapter 
adding time automata tick tick start tick tick start tick tick start start start tick start global automaton tick symbolic implicit representation methods applied variables belong mathematical domain integers 
representing set states explicitly table represented formula 
suppose example processes durations respectively enter respective active states time units 
set reachable clock values form 
size depends 
formula characterizes set size depends 
fact characterize reachable states assume fixed time granularity dense time 
way may allow events happen real time axis view clocks differently continuous variables evolve derivative inside active states 
timed automata see figures seen limit process time steps associated tick transitions infinitesimal 
tick chapter 
adding time automata start start start timed automata start basics timed automata start start start start definition timed automata timed automaton tuple finite set states finite set clocks transition relation consisting elements form chapter 
adding time automata states transition guard boolean combination formulae form clock integer bounded interval states initial final states respectively 
definition clock valuation clock valuation function equivalently dimensional vector 
denote set clock valuations configuration automaton pair consisting discrete state called location clock valuation 
subset induces reset function reset defined clock valuation clock variable reset reset resets zero clocks leaves clocks unchanged 
denote unit vector 
zero vector 
definition steps runs step automaton discrete step reset 
time step exists satisfies 
run automaton starting configuration finite sequence steps tn qn vn 
logical length run metric length tn 
useful augment time automaton additional clock active state reset zero 
call obtained automaton extended automaton runs called extended runs represents absolute time reachable iff reachable time note omit transition labels start previous section runs need sequel duration 
formal definition clocks evolve uniformly derivative states states certain clock values important paths starting states tested reset zero example clock state 
say clock inactive state writing value symbol 
run automaton corresponds case started time units started time units note definition run allows split time steps example step written 
useful features timed automata ability analyze system temporal uncertainty 
automaton see transition happen value interval 
verification algorithm explore chapter 
adding time automata infinitely runs correspond choice major result timed automata ad hnsy acd state space infinite reachability verification problems timed automaton solvable 
basic idea reachability computation timed automata 
sets reachable configurations stored unions symbolic states form discrete state subset clock space 
computation successors symbolic state done phases 
time successors computed leading consists clock valuation reachable letting time progress amount 
intersected transition guard transition determine configuration transition take place reset operations applied configurations 
timed automaton 
consider automaton 
starting symbolic state letting time pass reach symbolic state 
intersection guard transition gives resetting leads restart time passage 
computation automaton appears 
fundamental result concerning timed automata sets clock valuations symbolic states belong special class polyhedra called zones finite automaton 
definition zones symbolic states zone subset consisting points satisfying conjunction inequalities form ci cj ci symbolic state pair discrete state zone 
denotes set configurations 
definition successors timed automaton symbolic state 
time successor set configurations reachable letting time progress ost 
say time closed ost 
chapter 
adding time automata transition successor set configurations reachable transition ost reset 
successor time closed symbolic state set configurations reachable transition followed passage time succ ost ost 
successors set successors succ succ 
equipped operations transform zones zones solve reachability problems timed automata graph search algorithms simulation graph graph nodes symbolic states connected successor relation 
approach verifying timed automata proposed hnsy implemented tool kronos :10.1.1.26.7422
see chapter timed automata modeling job shop problems special structure particular acyclic 
generic algorithm computes reachable configuration automata starting configuration 
algorithm forward reachability acyclic timed automata waiting ost waiting pick waiting succ insert waiting remove waiting chapter 
adding time automata forward reachability computed automaton automaton acyclic algorithm terminate keep list explored states 
performance reasons tests important see especially paths lead discrete state 
untimed automata reachable sets computed backwards computing predecessors symbolic state 
definitions similar successors fact need compute inverse images reset functions 
definition predecessors timed automaton symbolic state 
time predecessors set configurations reached letting time progress re 
say time closed re 
transition predecessor set configurations reachable transition re reset 
predecessors set configuration reachable transition followed passage time re re re 
chapter 
adding time automata algorithm computes set states final state reachable 
algorithm backward reachability acyclic timed automata waiting waiting pick waiting re insert waiting remove waiting backward reachability computed automaton chapter deterministic job shop scheduling chapter model job shop scheduling problem special class acyclic timed automata 
finding optimal schedule corresponds finding shortest terms elapsed time path automaton 
representation provides new techniques solving optimization problem 
algorithms heuristics finding shortest paths timed automata test implementation numerous benchmark examples 
formal definitions definition job shop specification finite set resources machines 
job specification set resources triple number steps indicates resource step specifies length step 
job shop specification set 
jobs 
assumption machine exactly job 
assumption simplifies presentation maintains inherent complexity 
denote abuse 


definition feasible schedules feasible schedule job shop specification 
relation indicates job busy doing th step time occupies machine 
feasible schedule satisfy conditions 
ordering implies steps job executed order 

covering non preemption set nonempty set form step executed continuously completion 

mutual exclusion steps different jobs execute time machine 
start time time step job min chapter 
deterministic job shop scheduling length schedule maximal optimal schedule job shop specification feasible schedule shortest length 
relational definition schedules derive commonly definition 
machine allocation function stating job occupies machine time defined 
task progress function stating machine job time defined machine allocation task progress function partial machine job idle certain times 
machine idle job idle step job enabled di 
example consider jobs schedules depicted machine allocation task progress forms 
length optimal schedule 
chapter 
deterministic job shop scheduling feasible schedules visualized machine allocation function task progress function 
note job idle time precedence constraints satisfied machine needed time available 
see schedule machine available time remains idle time 
execute steps soon enabled obtain longer schedule 
ability achieve optimum waiting starting immediately increases set feasible solutions need explored major source complexity scheduling 
modeling timed automata modeling jobs construct job timed automaton clock states 
step states timed automata state indicates job waiting start step state indicating job executing step 
initial state state job started final state state job terminated steps 
clock inactive states entering reset zero tested 
automaton leave state time elapsed done testing clock larger equal 
auxiliary function definition timed automaton job job 
associated timed automaton 


initial state 
transition relation consists tuples true chapter 
deterministic job shop scheduling automaton corresponding job 
modeling job shop specifications construct timed automaton job shop specification need compose automata individual tasks 
composition standard particular feature enforcement mutual exclusion constraints forbidding conflicting states global states automata state corresponding resource definition conflicting states tuple 
said conflicting contains components 
job shop specification ci timed automaton job compose automata obtain time automaton clocks 
states composition cartesian product states individual automata excluding conflicting states 
definition mutual exclusion composition 
job shop specification automaton corresponding mutual exclusion composition automaton chapter 
deterministic job shop scheduling restriction 
non conflicting states 

transition relation contains tuples form 







non conflicting 







timed automaton corresponding job shop specification 
seen definition discrete transition corresponds transition automaton 
called interleaving semantics technical convenience 
schedule automata transitions time instant corresponding run fragments automaton 
example consider jobs corresponding automata jobs depicted composition 
job shop timed automaton acyclic diamond shaped initial state job started final state jobs terminated 
run automaton called complete starts terminates transitions global timed automaton indicate component moving active inactive state guarded conditions form ci component moving active state labeled resets ci called transitions 
transitions outgoing state represent choice scheduler example transitions outgoing initial state represent decision give resource move move 
scheduler decide start job idle see transitions outgoing state 
scheduler starts job machine time pass clock satisfies guard chapter 
deterministic job shop scheduling move 
hand duplication paths just artifacts due interleaving example paths outgoing practically equivalent 
recall timed automaton transition graph misleading transitions entering discrete state transitions enter different clock valuations lead different continuations 
automata corresponding jobs 
chapter 
deterministic job shop scheduling runs schedules global timed automaton jobs 
section show tight correspondence feasible schedules runs automaton 
definition derived schedule derived schedule run schedule absolute time start transition claim automaton generated job shop specification definitions 

complete run derived schedule feasible 
feasible schedule complete run proof proof induction lengths run schedule 
partial schedule schedule restricted interval 
partial run run reaching section schedule time tuple respectively sets waiting active chapter 
deterministic job shop scheduling finished steps function indicating time elapsed active state 
formally 
define correspondence configurations automaton sections schedule 

qn 
vn extended configuration 
associated section defined defining qi iff qi iff vi inductive hypothesis partial run reaching corresponds partial schedule feasible section matches 
true initial state time easily shown preserved discrete transitions time passage 
proof direction similar progressing ordered set start time points 
schedules appearing figures correspond respectively complete runs timed automaton 
schedule chapter 
deterministic job shop scheduling schedule corollary job shop scheduling timed automata optimal job shop scheduling problem reduced problem finding shortest path timed automaton 
shortest path timed automata reachability section show symbolic forward reachability algorithm find shortest path solve optimal job shop scheduling problem 
extended timed automaton obtained adding absolute clock runs respectively extended runs 
value additional clock reachable configuration represents time reach configuration run particular value final state represents length run 
consequently find shortest path timed automaton need compare value reachable extended configurations form 
set reachable configurations standard forward reachability algorithm acyclic timed automata algorithm 
common method reachability algorithms reducing number explored symbolic states inclusion test 
fact implies succ succ chapter 
deterministic job shop scheduling 
new symbolic state generated compared waiting list inserted removed list 
allowing job shop automaton stay indefinitely state explored zones upward closed respect absolute time increases significantly effectiveness inclusion test 
shows simulation graph extended timed automaton 
final symbolic state simulation graph extract length minimal run runs share qualitative path length optimal schedule min min reachable 
construct optimal schedule sufficient find run length running reachability algorithm guaranteed find minimal schedule 
chapter 
deterministic job shop scheduling simulation graph extended job shop timed automaton laziness non laziness section show point inside zone symbolic state sufficient finding optimal schedule 
chapter 
deterministic job shop scheduling lazy schedule definition lazy schedules schedule job step say exhibits laziness exists interval enabled 
schedule non lazy exhibits laziness 
laziness captures phenomenon useless waiting job step enabled waiting job profits waiting 
prove schedule transformed increasing length 
consider schedule exhibiting laziness 
starting step earlier obtain schedule new occurrences laziness 
removed yielding laziness removing obtain non lazy schedule claim non lazy optimal schedules lazy schedule transformed non lazy schedule 
job shop specification admits optimal non lazy schedule 
proof schedule set steps preceded laziness laziness 
sets left dashed lines 
pick lazy step shift start time backward obtain new feasible schedule lazy 
schedule verifies 
applying procedure successively increase step due finiteness set steps laziness removal procedure terminates 
chapter 
deterministic job shop scheduling removing laziness schedule 
dashed line indicates frontier rest steps immediate lazy runs having shown optimal schedule non lazy ones modify search procedure look runs automaton corresponding schedules non lazy 
define weaker notion immediate runs non lazy schedule corresponds immediate run immediate runs non lazy 
definition immediate runs immediate run run transitions taken soon enabled 
run contains fragment chapter 
deterministic job shop scheduling transition taken enabled clearly derived schedule non immediate run exhibits laziness 
corollary order find optimal schedule sufficient explore finite set immediate runs 
qualitative path timed automaton may correspond infinitely runs 
example family runs corresponds schedule 
run immediate schedule lazy 
corollary allows explore 
note derived schedule immediate run necessarily non lazy 
feasible schedule figures derived run lazy schedule run immediate run 
chapter 
deterministic job shop scheduling definition lazy runs lazy run job shop timed automaton run containing fragment 

transition enabled states 

immediate run lazy due fragment 
start transition taken continuously enabled 
claim set non lazy schedules job shop specification automaton 
si sl sets derived schedules immediate non lazy runs respectively sl si 
corollary job shop scheduling timed automata optimal job shop scheduling problem reduced problem finding shortest non lazy path timed automaton 
search algorithm corollary build search algorithm explores non lazy runs 
clarity start showing generate immediate runs reduce search space obtain set non lazy runs 
definition domination point symbolic state extended timed automaton 
say reachable configuration domination point earliest arrival time max vi 
vi 
vn 
point reachable immediate run 
restricting search algorithm points successor algorithm efficient 
working symbolic state form zone represented dbm size computing successors non trivial operation point representation size passage time simple vector addition 
define timed successor succ discrete successor succ configuration follows maximal amount time elapse configuration transition enabled min vi ci active 
timed successor configuration result letting time progress terminating terminate time succ 
qn 
vn 

chapter 
deterministic job shop scheduling transition qi vi qi vi 
discrete successors successors immediate start transition set successors succ 
succ succ succ enabled successor operator reachability algorithm discrete graphs compute immediate runs timed automaton 
shows immediate runs automaton 
immediate runs timed automaton restrict search non lazy runs eliminates useless waiting 
done follows 
state choose take time successor transition associated step enabled mark component marking propagated successors removed transition disabled enabled job took released machine question 
configuration restrict set successors transitions non components 
duration step started terminate conflicting chapter 
deterministic job shop scheduling transition enabled taken immediately case remaining step needs machine 
successor computation implemented annotated configurations form set components initialized empty set 
successors computed follows succ succ set components transition enabled set components transition releases machine waiting succ transition transition enabled block job succ succ succ succ succ applying operators reachability algorithm obtain set non lazy runs 
shows non lazy runs automaton 
non lazy runs timed automaton chapter 
deterministic job shop scheduling reducing search space points zones reduces significantly computational cost inherent combinatorial explosion remains 
section describe methods reduce search spaces preserve optimal solutions provide sub optimal ones 
domination test configurations share state different clock values 
reached time value smaller run continuing reach continuing 
successors discarded missing optimum 
definition domination reachable configurations 
say dominates clearly dominates complete run going run traverses longer 
best search order apply best search explore promising directions need evaluation function configurations 
configuration job automaton lower bound chapter 
deterministic job shop scheduling time remaining reached configuration min evaluation global configurations defined 
qn 
vn max qi vi note max gives optimistic estimation remaining time assuming job wait 
best search algorithm guaranteed produce optimal path stops exploration clear unexplored states lead schedules better far 
algorithm best forward reachability waiting succ best waiting best succ best min best insert waiting remove waiting waiting sub optimal solutions best algorithm improves performance combinatorial explosion remains 
avoid algorithm mixture breadth best search fixed number explored nodes level automaton 
level take best states generate successors explore best 
number main parameter technique number explored states grows monotonically quality solution solution smaller better larger experimental results implemented prototype models job shop problem timed automaton generates non lazy runs 
applying domination test best search solve problems jobs machines seconds 
employ sub optimal heuristic 
tested heuristic algorithm problems notorious job shop scheduling problems 
note pathological problems large variability step durations constructed demonstrate hardness job shop scheduling 
problems applied algorithm different choices table compare best results problems best results reported table survey jm results best known chapter 
deterministic job shop scheduling methods compared 
see results typically optimum 
problem heuristic opt name time length deviation length ft la la la la la la la la la table results hard problems bounded width heuristic 
columns give problem name 
jobs 
machines steps 
results time seconds length best schedule deviation optimum appear appreciate contribution fact points zones due non laziness look performance zone versions algorithms table largest problem solved exactly size jobs machines 
problem size inclusion domination best ds tree time time time table results jobs tasks 
columns ds tree show respectively number jobs number discrete states automaton number different reachable symbolic states close number nodes unfolding automaton tree 
rest table shows performance terms number explored symbolic states time seconds algorithms employing progressively inclusion test domination test best search indicates memory overflow 
chapter preemptive job shop scheduling chapter extend results deterministic job shop scheduling problem preemptible jobs jobs machine time resume stopped 
situations common example machines computers 
example set resources job specification 
feasible schedules appear 
schedule job preempted time machine give machine job terminated job restarts 
length optimal schedule 
schedule visualized machine allocation function task progress function 
definition job shop specification definition feasible schedule definition remains relaxation non preemption constraint definition 
means step set union intervals sum lengths equal step duration 
chapter 
preemptive job shop scheduling modeling stopwatch automata timed automaton model proposed chapter valid express preemption step 
job automaton leave execution state step terminate 
model preemption need additional state preempt automaton move back forth execute preempt 
time spent execute counts value transition guard termination 
solution add additional clock measuring preemption time updating time execution resumes 
operation reset operation allowed timed automata 
start preempt terminate alternative natural solution extend model timed automata clocks certain states words clocks derivative zero 
automata called integration graphs studied models duration calculus chr 
results included undecidability reachability problem automata decision procedure special sub classes reducing problem linear constraint satisfaction 
similar automata investigated mv cl implementation approximate verification algorithm described 
definition stopwatch automata stopwatch automaton tuple finite set states finite set clocks assigns constant slope state transition relation consisting elements form states transition guard boolean combination formulae form clock interval states initial final states respectively 
modeling jobs construct job stopwatch automaton clock step states waiting state active state state indicating job preempted having started 
entering clock reset zero measures time spent preemption resumption modeled transitions state clock progress 
clock value reaches automaton leave chapter 
preemptive job shop scheduling waiting state 
auxiliary functions definition stopwatch automaton job job 
associated automaton 



slope defined uq uq 
transition relation consists types tuples type true pause true resume true initial state 
generic stopwatch automaton job stopwatch automata corresponding jobs example depicted 
chapter 
preemptive job shop scheduling automata corresponding jobs 
global model obtain stopwatch automaton modeling preemptive job shop problem need compose automata jobs mutual exclusion composition described chapter 
part automaton obtained composing automata appears 
omitted preemption resumption transitions paths 
non preemptive job shop automaton automaton cyclic due possibility preempt resume step moment 
chapter 
preemptive job shop scheduling fm runs schedules ff part global stopwatch automaton jobs 
correspondence runs feasible schedules similar non preemptive problem 
claim stopwatch automaton preemptive job shop specification complete run corresponds feasible schedule length equal metric length run 
schedules correspond runs chapter 
preemptive job shop scheduling corollary optimal preemptive job shop scheduling problem reduced problem finding shortest path stopwatch automaton 
trying find shortest path automaton encounter problems 
general reachability problems stopwatch automata known undecidable 

global stopwatch automaton cyclic infinite number qualitative runs 
show known result concerning optimal preemptive schedules problems overcome 
efficient schedules definition conflicts priorities feasible schedule 
set time instants job executing jth step ei di di time interval enabling step termination 
say job conflict job machine denoted respective steps ei ei 
say priority conflicting job denoted finishes di di 
definition efficient schedules schedule efficient job step job uses time interval times job uses 
words efficiency means step uses machine machine step terminates earlier 
times chapter 
preemptive job shop scheduling inefficient schedule 
interval inefficiency indicated dashed lines schedules feasible schedules example 
see schedules inefficient schedules 
definition deduce problem priority relation jobs machine time intervals schedule job machine time interval starts job uses machine 
schedule job machine time interval job occupies machine chapter 
preemptive job shop scheduling schedule job machine time interval job occupies machine show problem admits optimal schedule corresponds fixed priority relation jobs machine step job executes soon enabled times conflict higher priority job 
preemption occurs step higher priority executing step enabled 
number finite 
theorem efficiency preemptive job shop specification admits efficient optimal schedule 
proof proof showing inefficient schedule transformed efficient schedule 
interval inefficiency occurs job machine modify schedule shifting occupied job give time slot liberated termination step delayed modification happens anyway terminates step 
illustration consider schedules appearing enabled interval 
inefficiency eliminated letting free time slot arrival second inefficiency occurs uses machine waiting removed 
inefficiency waiting idle removed 
removal inefficiency result reduces set candidates optimality non countable set feasible schedules finite set efficient schedules corresponds fixed priority relation 
potentially kn 
priority relations fraction needs considered conflict concerning priority influence schedule 
chapter 
preemptive job shop scheduling searching efficient runs order find shortest paths stopwatch automata take advantage theorem restrict search runs corresponding schedules efficient 
definition efficient runs run stopwatch automaton efficient discrete transitions taken soon enabled conflicts resolved fixed priority relation 
efficient run allow 
restrict search immediate runs 

restrict number qualitative paths finite avoiding loops useless resumption 
precise jobs conflict concerning machine highest priority table depicts potential conflict situations resolved 
state action new state start start preempt resume resume impossible continue continue impossible table resolving conflicts situations waiting machine occupied takes 
situations reached example third job higher priority releasing finishing prior step entering situation similar occupying preempted reach situation 
situation preempted executing contradicts priority reachable 
situations executing preemption action taken 
situation violates mutual exclusion 
claim stopwatch automaton preemptive job shop specification complete efficient run corresponds feasible efficient schedule length equal metric length run 
corollary preemptive scheduling stopwatch automata optimal preemptive job shop scheduling problem reduced problem finding shortest efficient run stopwatch automaton 
restriction efficient runs shortest path problem decidable enumerate priority relation check length induced efficient run 
chapter 
preemptive job shop scheduling non preemptive case search algorithm employ unfolding automaton generates priorities fly jobs come conflict 
example conflict encountered state may choose options continue time passage preempt case fix priority finish considering preemption anymore second case priority move transition back forbidden 
continue time pass releases 
formalize define valid successors relation tuples form global configuration extended automaton partial priority relation 
start transitions enabled succ succ succ timed successor defined non preemptive case 
start transitions enabled succ immediate transition non conflicting belongs job priority respective machine higher competing jobs 
addition conflict involving new job priority compared job having highest priority far determined mi 
successor represent choice prefer priority relative waiting preempted jobs determined terminates represents choice preferring jobs 
search tree generated algorithm example appears 
chapter 
preemptive job shop scheduling efficient runs timed automaton experimental results best algorithm able find optimal schedules system jobs machines discrete states clocks 
test heuristic proposed case deterministic job shop problem difficult job shop scheduling problems problems applied algorithms different choices takes average minutes problem 
table compare best results problems results reported le pape pb pb problem solved state art constraint satisfaction techniques 
chapter 
preemptive job shop scheduling problem non preempt preemptive name optimum optimum pb pb stopwatch deviation la ft abz abz orb orb orb orb orb la la la la la la la table results implementation benchmarks 
columns indicated number jobs machines followed best known results non preemptive scheduling known optimum preemptive case results le pape followed results deviation optimum 
chapter task graph scheduling chapter apply methodology suggested job shop problem different problem task graph scheduling parallel identical machines 
problem fixed number parallel identical machines execute set tasks linked set precedence constraints represented task graph 
task executed predecessors graph completed 
job shop problem particular case graph set linear chains chain representing precedence relation job 
task graph 
numbers represent task durations contrary job shop problem task executed idle machine pair tasks priori conflict tasks conflict machine 
significant parameter problem identity occupied machines number occupied machines 
problem task graph triple 
pm set tasks partial order relation function assigns duration task 
denote set immediate predecessors set 
mn parallel identical machines need find schedule minimizes total execution time respects conditions chapter 
task graph scheduling task executed predecessors completed 
machine process task time 
tasks preempted 
machines want optimal schedule obtained starting task soon predecessors terminate 
case length optimal schedule length maximal path minimal maximal element schedule optimal schedule task graph number machines unlimited 
notice machines sufficient construct schedule tasks enabled simultaneously see 
optimal schedule task graph number machine unlimited 
optimal schedule task graph machines 
hand machines number enabled tasks may exceed number machines 
see schedules occupying enabled 
give remaining machine give 
chapter 
task graph scheduling feasible schedules task graph machines 
case infinitely machine similarly job shop problem optimal schedule may obtained executing task soon enabled 
example schedule achieves optimum starting task soon possible 
modeling timed automata goal translate problem timed automaton run corresponds feasible schedule shortest run gives optimal schedule 
task build state automaton clock set states waiting state task starts active state task executes final state indicating task terminated 
transition resets clock taken tasks final states 
transition taken 
automata task graph appear 
order model task graph composition timed automata need modify bit definition transition relation include tuples form combination clock inequalities formula specifying states automata 
definition timed automaton task task graph 
task associated timed automaton initial state final state transition relation consists transitions chapter 
task graph scheduling automata task graph job shop problem global automaton representing feasible schedules obtained composition individual task automata composition takes care number tasks active global state exceed number machines 
terms number reachable global states automaton get features analysis impractical improved 
global states tuples large number clocks 
reality presence infinitely machines number tasks active simultaneously bounded width task graph maximal number elements incomparable respect definition chain chain partially ordered set subset definition chain cover chain covering partially ordered set set chains 
hk satisfying 
hi linearly ordered subset 
hi hj 
hi example chain cover task graph appears 
structure chain similar job fact tasks chain depend termination tasks chains 
external predecessors task hi hi 
chapter 
task graph scheduling start transition enabled hj automaton state denote condition apply methodology developed chapter built automaton chain compose chain automata apply search algorithms 
worth mentioning chain covers related width partial order dilworth theorem 
theorem dilworth width partial order equal minimal number chains needed cover 
computation width associated cover polynomial compute exactly fast simple algorithm approximate 
chain covering task graph chapter 
task graph scheduling automata chain cover timed automaton represents part timed automaton obtained composing automata machines 
automaton clocks number chains cover 
initial state tasks waiting possible successors start state start state 
transition state disabled task terminated 
start transition taken machines occupied state 
chapter 
task graph scheduling timed automaton obtained composing automata case machines 
runs corresponding schedules indicated dashed dotted lines respectively 
chapter 
task graph scheduling adding deadlines release times model extended include additional feature task graph scheduling problems deadlines release times 
task pj deadline indicates task imperatively terminate time 
release time indicates task executed time 
feasible schedule respect new constraints pj pj 
pj pj 
features easily integrated model making additional clock measuring absolute time seen 
way complete run corresponds feasible schedule respecting additional constraints run fragment violating deadline completed 
results concerning non lazy schedules hold setting 
worth mentioning results hold add relative deadline constraints form 
automaton task release time deadline 
experimental results test approach taken benchmark problems yi having thousands tasks 
applied simple algorithm finding chain cover built automata applied heuristic sub optimal shortest path algorithm 
execution time algorithm minute problem results close best known results reported table 
chapter 
task graph scheduling name tasks machines yi ta table computation optimal schedules benchmark problems 
results appear ta column chapter scheduling uncertainty models previous chapters deterministic sense tasks durations known advance scheduler 
non determinism problem specification comes scheduler decisions chosen system exhibits unique run schedule pre determined start times task 
chapter extend framework treat challenging problem scheduling uncertainty 
ways introduce uncertainty model chosen natural ones uncertainty duration tasks 
problem variation job shop scheduling problem duration task known inside interval form 
external environment chooses time number task 
assignment number uncertainty interval called instance environment 
running example consider jobs uncertainties concern durations task second task instance pair 
example resource conflict order usage decision scheduler needs take 
instance defines deterministic scheduling problem depicts optimal schedules instances 
course optimal schedule generated scheduler knows instance advance 
realization 
chapter 
scheduling uncertainty optimal schedules instances 
optimum obtained third worst case performance care find optimal schedule worst instance extract start time task stick schedule regardless actual instance 
behavior static schedule instance depicted see wasteful instances 
intuitively prefer smarter adaptive scheduler reacts evolution environment uses additional information revealed execution schedule 
essential difference schedule plan feed forward controller scheduling strategy reactive plan feedback controller 
mechanism observes state system tasks terminated executing decides accordingly 
uncertainty scheduler knows exactly state time instant strategy reduced simple assignment start times tasks 
chapter 
scheduling uncertainty static schedule worst instance 
gives length instances 
hole filling strategy simplest ways adaptive 
choose nominal instance find schedule optimal instance 
literally extract qualitative information order conflicting tasks utilize resource 
example optimal schedule worst instance associated ordering 
execution start task soon predecessors terminated provided ordering violated 
shows strategy better instances 
takes advantage earlier termination second task shifts forward start times tasks follow 
hand instance benefit early termination shifting forward violate ordering 
chapter 
scheduling uncertainty behavior hole filling strategy instance 
note hole filling strategy restricted worst case 
nominal instance shift tasks forward backward needed maintaining order 
hand static schedule worst case static schedule nominal instance may assume resource available time point reality occupied 
hole filling strategy shown optimal instances optimal schedule ordering nominal instance instances radical form adaptiveness required 
look optimal schedules see decision execute second task done cases qualitative state executing terminated 
difference time elapsed execution decision point 
adaptive scheduler base decisions quantitative information case timed automata models represented clock values 
adaptive scheduling consider approach initially find optimal schedule nominal instance 
execution task terminates time assumed reschedule residual problem assuming nominal values tasks terminated 
example build optimal schedule 
task terminated time residual problem indicates scheduled immediately assume preemption 
problem optimal solution start likewise terminates optimal schedule consists waiting termination starting property schedules obtained way moment execution optimal chapter 
scheduling uncertainty respect nominal assumption concerning 
approach involves lot online computation solving new scheduling problem time task terminates 
alternative approach propose chapter expressing scheduling problem timed automata synthesizing control strategy line 
framework amps am agp strategy function states clock valuations controller actions case starting tasks 
computing strategy representing properly execution schedule may proceed keeping track state corresponding automaton 
task terminates optimal action quickly computed strategy look table results identical obtained online re scheduling 
notations similar partial order precedence chapter examples consist linearly ordered jobs 
definition uncertain job shop specification uncertain job shop specification finite number tasks finite set machines partial order precedence relation tasks assigns tasks machines assigns integer bounded interval task subset immediate tasks consisting minimal elements 
set typically empty initial definition problem need define residual problems 
denote projection lower upper bounds interval respectively 
set denotes predecessors tasks need terminate starts 
standard job shop scheduling problem decomposes disjoint union chains linear orders called jobs 
instance environment function set instances admits natural partial order relation environment instance induces naturally deterministic instance denoted classical job shop scheduling problem 
worst case defined maximal instance definition schedule uncertain job shop specification deterministic instance 
feasible schedule function defines start time task satisfying 
precedence max 

mutual exclusion 
immediacy 

order adaptive need scheduling strategy rule may induce different schedule definition simple need restrict causal strategies strategies base decisions information available time 
case value revealed terminates 
definition state schedule state schedule downward closed subset indicating tasks terminated set active tasks currently executed function indicates time elapsed activation set enabled tasks consisting predecessors set possible states denoted similar idea model predictive control time actions current real state re optimized assuming nominal prediction 
chapter 
scheduling uncertainty definition scheduling strategy state scheduling strategy function 
words strategy decides state time pass choose enabled task conflict active task start executing 
operational definition interaction strategy instance timed automata intuitively see evolution state schedule consists types transitions uncontrolled transitions active task terminates time moves leading possibly adding new tasks decision scheduler start enabled task 
combination strategy instance yields unique schedule say state reachable occurs 
formalize notion residual problem specification remains done intermediate state execution 
definition residual problem state 
residual problem starting js respectively restrictions constructed letting definition optimal strategies instance 
strategy optimal instance reachable state produces optimal schedule js 
exactly property online re scheduling approach described informally previous section 
modeling timed automata task construct timed automaton ad captures instances task automaton stay active state long leave soon represents possible behaviors task isolation ignoring precedence resource constraints 
transition waiting state triggered decision scheduler time transition depends instance 
instance automaton ad transition happens exactly time 
automaton ad computing optimal strategies terminate soon stay chapter 
scheduling uncertainty start start start ad ad ad generic automaton ad task 
automaton ad deterministic instance 
automaton ad computing optimal strategies 
staying conditions true omitted 
timed automaton job shop specification corresponding example appears 
automaton viewed specifying game scheduler environment 
environment decide take transition terminate active task scheduler decide take enabled start transition 
strategy function maps configuration automaton transition successors waiting action 
example choice moving giving waiting terminates letting environment take automaton conflict concerning resolved possible ways 
strategy optimal configuration reachable ad gives shortest path final state 
section simplified form definitions algorithm am find strategies 
chapter 
scheduling uncertainty fm fm fm fm global automaton job shop specification 
automata left upper parts partial compositions automata tasks respectively 
optimal strategies timed automata job shop specification ad automaton corresponding instance transitions guarded conditions form ci pi 
ff chapter 
scheduling uncertainty function length minimal run assuming uncontrolled transitions taken function admits recursive backward definition min 
words minimum successors time takes satisfy transition guard plus time reach resulting configuration 
am shown ranges class nice functions closely related zones class founded computation terminates automata cycles fact need computed sweep paths final initial state :10.1.1.43.6815
illustrate computation example 
write function form denote cases value corresponding clock irrelevant task active 
start time reach time takes satisfy guard value depends values clocks determine terminate shorter path goes 
min min note state outgoing transitions uncontrolled transition decision scheduler required 
procedure goes higher higher graph computing state space particular state need decide start wait obtain min extraction strategy straightforward optimum obtained controlled transition obtained uncontrolled transition 
optimal strategy meaning time units give time units wait terminates give machine note assume chapter 
scheduling uncertainty started tasks simultaneously value entering exactly duration instance 
results chapter 
concerning non lazy schedules imply optimal strategies additional property words enabled controlled transition gives optimum taken soon possible 
fact implementation strategy 
theorem computability optimal strategies uncertain job shop specification instance possible compute optimal scheduling strategy 
result special case result am 
implementation existing algorithms timed automata sets functions order apply computation construction 
auxiliary automaton augmented clock representing absolute time 
clearly reachable initial state reachable time positive integer larger longest path automaton 
starting doing backward reachability construct relational representation precisely backward reachable extended timed automaton forward reachable time 
applying standard backward reachability algorithm timed automata compute set backward reachable symbolic states 
order able extract strategies store tuples form zone successor reached backwards 
set gives sufficient information implementing strategy 
transition done execution look symbolic states discrete state find min 
successor controlled transition move wait task terminates uncontrolled transition taken 
non laziness guarantees need revise decision wait transition 
experimental results implemented algorithm zone library kronos bdm strategy algorithm exponential distribution 
benchmark took problem jobs machines static worst case schedule problem 
applied algorithm find optimal strategies instances correspond respectively optimistic realistic pessimistic predictions 
defined dmin dmax chapter 
scheduling uncertainty generated random instances compared results abovementioned strategies optimal scheduler knows advance static worst case scheduler 
table compares performance instances durations drawn uniformly intervals 
turns pessimistic adaptive strategy dmax robust 
gives schedules average longer produced scheduler 
comparison static worst case strategy deviates optimum average 
hand realistic optimistic strategies usually inferior instances worse static schedule 
explained fact schedules rely minimal prediction executed planned 
hole filling strategy worst case prediction achieves performance longer optimum modest computational effort results hole filling realistic predictions bad shown table 
inst opt static max avg min hole avg domain called online algorithms common compare performance algorithms receive inputs progressively algorithm relation performances called competitive ratio 
chapter laid foundations automaton scheduling methodology 
step attacked problems job shop problem solved existing techniques order see performance timed automata technology acceptable 
turned standard zone algorithms timed automata heavy led discovery non lazy schedules runs 
points zones compete techniques insight may useful standard verification timed automata 
step consider preemption cyclic nature automaton poses problems techniques 
number bounded bound number variables corresponding constrained optimization problem 
led rediscovery jackson schedule call efficient 
result point search algorithm applied leading performance 
shows undecidability results stopwatch automata relevant 
generalization task graph problem straightforward significant new feature decomposition partial order form chain cover adaptation mutual exclusion condition identical machines 
performance algorithm worse state art domain 
treatment uncertainty chapter supposed domain advantages state approach visible 
definition computation adaptive strategies hard perform insight coming automaton model 
consider results far partial success backward reachability algorithm current form explore state space best search forward reachability expensive zone technology 
implies size problems treated smaller deterministic case 
needed extend scope scheduling strategy synthesis 
hand adaptive strategy hole filling easily implemented top solution deterministic problem 
envisage major research directions concerned improving performance extending models treat complex scheduling situations 
direction include 
new search heuristics deterministic problems 

new techniques compositional scheduling 
basic idea jobs grouped subsets optimal schedule subset 
obtained schedule subset seen job composition super jobs defines new scheduling problem 
clearly technique guaranteed give optimal solution may suggest practical approach treating large number jobs 
chapter 

combination forward backward reachability strategy synthesis 
hardness strategy synthesis priori strategy computed reachable configuration definition reachable configuration depends strategy 
consequently current algorithm computes strategy reachable configuration strategy 
clear strategies especially lazy ones chosen 
forward analysis restrict set states need compute strategy restrict significantly computation time 
accept sub optimal strategies refrain computing strategy reachable states default actions states reached actual schedule 
possible extensions scheduling problems mention 
job shop problems steps executed different machines different speeds 

problems identity step executed depends result current step 
situation occur example computer programs 

problems structure tasks depends previous choices scheduler 
example machines distributed geographically different choices machines imply different steps transportation 
likewise task graph scheduling communication added tasks execute machine 

problems complex timing constraints laziness results hold 
example problem relative deadlines synchronization constraints task graph scheduling 
believe regardless current applicability techniques real life industrial size problems framework developed adds new perspective scheduling problems viewed understood solved 
bibliography maler task graph scheduling timed automata proc 

aam asarin maler optimal scheduling uncertainty proc 
tacas springer 
am maler preemptive job shop scheduling stopwatch automata katoen stevens eds tacas lncs springer 
am maler job shop scheduling timed automata berry comon finkel eds proc 
cav lncs springer 
atp alur la torre pappas optimal paths weighted timed automata proc 
lncs springer 
agp pnueli sifakis tripakis yovine framework scheduler synthesis 
proc 
rtss ieee 
am asarin maler soon possible time optimal control timed automata proc 
lncs springer 
amps asarin maler pnueli sifakis controller synthesis timed automata proc 
ifac symposium system structure control elsevier 
amp asarin maler pnueli symbolic controller synthesis discrete timed systems hybrid systems ii lncs springer 
ad alur dill theory timed automata theoretical computer science 
acd alur courcoubetis dill model checking dense real time information computation 
abc applegate cook computational study job shop scheduling problem orsa journal computing spring 
abz adams balas shifting bottleneck procedure job shop scheduling management science march 
decomposition approach machine scheduling problem international journal production research 
bfh behrmann larsen pettersson efficient guiding cost optimality uppaal proc 
tacas lncs springer 
bibliography bfh behrmann larsen pettersson vaandrager minimum cost reachability linearly priced timed automata proc 
lncs springer 
bs vhs case study modelling verification scheduling steel plant draft 
bdm maler olivero tripakis yovine kronos model checking tool real time systems proc 
cav lncs springer 
bb boyd parallel algorithm solving difficult job shop scheduling problems operations research working department industrial engineering texas university college station texas usa 
bpn le pape nuijten constraint optimization approximation job shop scheduling aaai sigman workshop intelligent manufacturing systems th international joint conference artificial intelligence montr qu bec canada aug pp 

bjs brucker branch bound algorithm job shop scheduling problem discrete applied mathematics vol balas machine scheduling disjunctive graphs implicit enumeration algorithm operations research vol bowman schedule sequencing problem operations research vol 
cl larsen impressive power palamidessi ed 
proc 
concur lncs springer 
ccm campos clarke computing quantitative characteristics finite state real time systems proc 
rtss ieee 
cy caseau laburthe improved clp scheduling task intervals van hentenryck 
ed iclp proceedings eleventh international conference logic programming mit press 
cpp chu splitting approach simplify job shop scheduling problems international journal production research 
algorithmic problems analysis real time system specifications ph thesis university latvia riga 
chr hoare ravn calculus durations information processing letters 
cy courcoubetis yannakakis minimum maximum delay problems realtime systems proc 
cav lncs springer 
cp carlier pinson practical jackson preemptive schedule solving job shop problem annals operations research 
carlier machine sequencing problem european journal operational research vol 
bibliography dy yovine reducing number clock variables timed automata proc 
rtss ieee 
dr della croce solving real world project scheduling problem genetic approach belgian journal operations research statistics computer science dijkstra note problems connexion graphs numerische mathematik 
dilworth decomposition theorem partially ordered sets ann 
math 

scheduling steel plant timed automata proc 

fr french sequencing scheduling mathematics job shop ellis horwood john wiley sons new york 
fisher optimal solution scheduling problems lagrange multipliers part operations research vol 
fisher optimal solution scheduling problems lagrange multipliers part ii symposium theory scheduling applications springer berlin 
ft fisher thompson probabilistic learning combinations local job shop scheduling rules muth thompson eds industrial scheduling prentice hall englewood cliffs new jersey ch 
gj garey johnson computers intractability guide theory np completeness freeman 
gt thompson algorithms solving production scheduling problems operations research 
hnsy henzinger nicollin sifakis yovine symbolic model checking realtime systems information computation :10.1.1.26.7422
hlp practical approach job shop scheduling problems ieee trans rob autom feb 
jm jain meeran deterministic job shop scheduling past european journal operational research 
jackson scheduling production line minimize maximum tardiness research report management sciences research project ucla 
kesten pnueli sifakis yovine decidable integration graphs information computation 
kr ger werner heuristic decomposition algorithm scheduling problems mixed graphs journal operational research society vol 
maler problem task scheduling draft february 
bibliography ma martin time oriented approach computing optimal schedules job shop scheduling problem ph 
thesis school operations research industrial engineering cornell university ithaca new york august 
mps maler pnueli sifakis 
synthesis discrete controllers timed systems proc 
stacs lncs springer 
mv varaiya suspension automata decidable class hybrid automata dill ed proc 
cav lncs springer 
manne job shop scheduling problem operations research vol 
tripakis yovine minimum time reachability timed automata ieee control conference 
ny yovine computing optimal operation schemes chemical plants multi batch mode proc 
lncs springer 
np nuijten le pape constraint job shop scheduling ilog scheduler journal heuristics march 
na nuijten aarts computational study constraint satisfaction multiple capacitated job shop scheduling european journal operational research vol 
pb le pape constraint branch bound algorithm preemptive job shop scheduling proc 
int 
workshop production planning control belgium 
pb le pape experimental comparaison constraint algorithms preemptive job shop problem cp workshop industrial constraint directed scheduling 
pt pesch tetzlaff constraint propagation scheduling job shops forms journal computing spring 
pc clausen parallel branch bound methods job shop scheduling problem working university copenhagen copenhagen denmark 
rs roy les probl mes avec contraintes note bis sema paris france 
sb beam search algorithm job shop scheduling problem research report department industrial engineering faculty engineering bilkent university ankara turkey european journal operational research 
van de velde machine scheduling lagrangian relaxation ph 
thesis cwi amsterdam netherlands 
wh wong toi hoffmann control dense real time discrete event systems technical report stan cs stanford university 
bibliography yi yu kwong benchmarking comparison task graph scheduling algorithms 
journal parallel distributed computing 
yovine kronos verification tool real time systems int 
software tools technology transfer 
