practical suffix tree construction sandeep tata richard patel large string datasets common number emerging text biological database applications 
common queries datasets include exact approximate string matches 
queries evaluated efficiently suffix tree index string dataset 
suffix trees constructed quickly memory small input datasets constructing persistent trees large datasets challenging 
explore suffix tree construction algorithms wide spectrum data sources sizes 
show modern processors cache efficient algorithm complexity outperforms popular ukkonen algorithm memory construction 
larger datasets disk requirement quickly bottleneck algorithm performance 
address problem buffer management strategy algorithm creating new disk construction algorithm scales sizes larger previously described literature 
approach far outperforms best known construction algorithms 
querying large string datasets increasingly important number emerging text life sciences applications 
life science researchers interested explorative querying large biological sequence databases genomes large sets protein sequences 
biological datasets growing exponential rates example sizes sequence datasets genbank doubling permission copy fee part material granted provided copies distributed direct commercial advantage vldb copyright notice title publication date appear notice copying permission large data base endowment 
copy republish requires fee special permission endowment 
proceedings th vldb conference toronto canada university michigan beal avenue ann arbor mi usa eecs umich edu teen months 
consequently methods efficiently querying large string datasets critical success emerging database applications 
suffix trees versatile data structures help execute queries efficiently 
fact suffix trees useful solving wide variety string problems 
instance exact substring matching problem solved time proportional length query suffix tree built database string 
suffix trees solve approximate string matching problems efficiently 
bioinformatics applications oasis exploit suffix trees efficiently evaluate queries biological sequence datasets 
suffix trees widely high cost construction 
show building suffix tree moderately sized datasets single chromosome human genome takes hours best known existing disk construction technique 
contrast techniques develop reduce construction time factor inputs size 
suffix trees currently widespread rich history algorithms constructing suffix trees 
large focus previous research linear time suffix tree construction algorithms 
algorithms suited small input strings tree constructed entirely main memory 
growing size input datasets requires construct suffix trees efficiently disk 
algorithms proposed disk construction poor locality 
poor locality causes large amount random disk data structures longer fit main memory 
naively main memory algorithms disk suffix tree construction process may take day single human chromosome 
large rapidly growing size string datasets underscores need fast disk suffix tree construction algorithms 
research efforts considered problem approaches scales large datasets large chromosome entire eukaryotic genome 
new approach efficiently construct suffix trees disk 
philosophy similar 
forgo suffix links return better memory pattern translates better scalability performance large trees 
main contributions follows 
introduce top disk tdd approach building suffix trees efficiently wide range sizes input types 
technique includes suffix tree construction algorithm called sophisticated buffer management strategy 

compare performance tdd popular ukkonen algorithm memory case data structures needed building suffix trees memory resident datasets small 
interestingly show ukkonen better worst case theoretical complexity tdd outperforms ukkonen modern cached processors tdd incurs significantly fewer processor cache misses 

systematically explore space data sizes types highlight advantages disadvantages tdd respect construction algorithms 

experimentally demonstrate tdd scales gracefully increasing input size 
tdd process able construct suffix tree entire human genome hours single processor machine 
knowledge suffix tree construction input string size symbols approx 
reported literature 
remainder organized follows section discusses related 
tdd technique described section analyze behavior algorithm section section presents experimental results section presents 
related linear time algorithms constructing suffix trees described weiner mccreight ukkonen 
ukkonen popular algorithm easier implement algorithms 
memory construction algorithm clever observation constructing suffix tree performed iteratively expanding leaves partially constructed suffix tree 
suffix links provide mechanism quickly traversing sub trees suffix tree expanded simply adding character leaves suffix tree built previous characters 
algorithm relies suffix links traverse sub trees main tree expanding outer edges input character 
poor locality traverse suffix tree nodes random fashion 
leads poor performance cached architectures construct disk suffix trees 
developed buffering strategy called top improves performance ukkonen algorithm uses suffix links constructing disk suffix trees 
different approach suggested hunt authors drop suffix links algorithm better locality 
pass string index suffixes prefix inserting disk subtree managed pjama java object store 
construction independent subtree requires full pass string 
log algorithms constructing suffix trees described 
top approach suggested 
authors explore benefits lazy implementation suffix trees 
approach authors argue avoid paying full construction cost constructing subtree accessed time 
approach useful small number queries posed string dataset 
executing large number queries tree materialized case approach perform poorly 
previous research produced theoretical results understanding average sizes suffix trees theoretical complexity sorting build suffix trees different computational models ram pram various external memory models 
suffix arrays alternative suffix trees specific string matching tasks 
general suffix trees versatile data structures 
focus suffix trees 
solution uses simple partitioning strategy 
sophisticated partitioning method proposed complement existing partitioning method 
tdd technique suffix tree construction algorithms scale due prohibitive disk requirements 
high overhead quickly causes data structures main memory poor locality efficient buffer management difficult 
new disk construction technique called top disk technique referred simply tdd 
tdd scales gracefully existing techniques reducing mainmemory requirements strategic buffering largest data structures 
tdd technique consists suffix tree construction algorithm called related buffer management strategy described sections 
algorithm component tdd technique suffix tree construction algorithm called partition write top 
algorithm algorithm suggested kurtz 
improve string ca ca ca ca ca ca suffix tree representation algorithm partitioning phase allows immediately build larger independent sub trees memory 
explain details algorithm briefly discuss representation suffix tree 
suffix tree represented linear array 
compact representation average bytes symbol indexed 
illustrates suffix tree string tree corresponding array representation memory 
shaded entries array represent leaf nodes entries representing non leaf nodes 
lower right hand corner entry denotes rightmost child 
branching node represented integers 
index input string character index starting character incoming edge label 
length label deduced examining children current node 
second entry points child 
note leaf nodes second entry 
leaf node requires starting index label label string terminating character 
see detailed explanation 
algorithm consists phases 
phase partition suffixes input string partitions alphabet size string depth partitioning 
partitioning step executed follows 
input string scanned left right 
index position subsequent characters determine partitions 
index written calculated partition buffer 
scan partition contain suffix pointers suffixes prefix size 
illustrate partition step consider example 
partitioning string create partitions suffixes symbol alphabet 
ignore final partition consisting just string terminator symbol 
suffix partition character algorithm string phase scan string partition suffixes symbols suffix phase partition 
start 
populate suffixes current partition 
sort suffixes symbol temp 
output branching leaf nodes tree 
push nodes pointing unevaluated range stack stack empty 
pop node 
find longest common prefix lcp suffixes range checking string 
sort range suffixes symbol temp 
write branching nodes leaf nodes tree push nodes pointing unevaluated range stack 
tdd algorithm representing suffixes aca 
suffix partition character representing suffixes 
phase algorithm build suffix tree partition top construction 
pseudo code algorithm shown 
partitioning phase simple algorithm phase warrants discussion 
illustrate algorithm example 
example illustrating algorithm algorithm requires data structures constructing suffix trees input string array suffix array temporary array suffix tree 
discussion follows name structures string suffixes temp tree respectively 
suffixes array populated suffixes partition discarding characters 
example string consider construction suffixes array 
suffixes partition positions 
suffixes share prefix add offset produce new suffix array 
step involves sorting array suffixes character 
characters suffix 
sorting done efficient algorithm called count sort linear time constant alphabet size 
single pass character suffixes lru main memory replacement policy lru string buffer temp tree buffer mru lru string file size tree file disk suffixes file size temp file size size buffer management schema alphabet count number occurrences character character suffix copy suffix pointers temp array 
see count count counts 
counts determine character group boundaries group start position entries group start position entry 
single pass temp array produce suffixes array sorted character 
suffixes array 
group members branching node 
suffixes completely determine sub tree node 
space reserved tree write non leaf node expanded node pushed stack 
group member leaf node immediately written tree 
children need processed additional entries added stack node popped 
node popped stack find longest common prefix lcp nodes group 
examine position position determine lcp 
suffix pointer incremented lcp result processed 
computation proceeds nodes expanded stack empty 
shows complete suffix tree array representation 
discussion algorithm observe phase operates subsets suffixes string 
string symbols size suffixes array temp array needed bytes assuming byte integers pointers 
partitioning phase amount memory needed suffix arrays run just important point partitioning decreases main memory requirements suffix tree construction allowing independent sub tree built entirely main memory 
suppose partitioning symbol string alphabet size 
decrease space requirement suffixes temp arrays mb mb tree array mb mb 
unfortunately savings entirely free 
cost partition increases linearly 
small input strings sufficient main memory structures skip partitioning phase entirely 
necessary continue partitioning suffixes temp arrays fit memory 
large datasets human genome partitioning levels beneficial 
buffer management suffix trees order magnitude larger size input data string suffix tree construction algorithms require large amounts memory may exceed amount main memory available 
large data sets efficient disk construction methods needed scale large input sizes 
strength tdd transitions data structures gracefully disk necessary uses individual buffer management polices structure 
result tdd scale gracefully handle large input sizes 
recall algorithm requires data structures constructing suffix trees string suffixes temp tree 
shows structures separate memory buffer caches 
appropriately allocating memory right buffer replacement policy structure tdd approach able build suffix trees extremely large inputs 
buffer management policies summarized discussed detail 
largest data structure tree buffer 
array stores suffix tree intermediate stages final computed result 
tree data structure typically times size input string 
pattern tree consists mainly sequential writes children node recorded 
occasionally pages revisited unexpanded node popped stack 
access pattern displays temporal spatial locality 
clearly majority structure placed disk managed efficiently simple lru replacement policy 
largest data structures suffixes temp arrays 
suffixes array accessed follows sequential scan copy values temp array 
sort operation scan causes random writes temp array back suffixes array 
locality pattern writes writes start character group boundary proceed sequentially right 
limited locality expects lru perform reasonably 
sort temp array referenced linear scans copy suffixes suffixes array second copy back suffixes array sorted order 
pattern replacing page mru works best 
string array smallest main memory requirement data structures worst locality ac disk accesses string buffer suffixes buffer temp buffer tree buffer buffer size file size sample page curves cess 
string array referenced performing count sort find longest common prefix sorted group 
count sort portions string referenced suffix pointers accessed 
positions string accessed left right order 
function find longest common prefix group similar pattern observed 
case find lcp function iteration access characters string symbol right previously referenced 
case count sort operation set suffixes sorted subset current set 
observations conclude lru policy best management policy 
summarize choice buffer management policies structures 
shown string suffixes tree arrays lru replacement policy temp array mru replacement policy 
experiments section confirm choices 
buffer size determination obtain maximum benefit buffer management policy important divide available memory data structures appropriately 
careful available memory data structures affect execution time dramatically 
rest section describe technique divide available memory buffers 
know access pattern data structures devise algorithm partition memory minimize number buffer cache misses 
note need access pattern string representative class dna sequences protein sequences fact experimentally access patterns similar wide range datasets discuss results detail section illustrative graph buffer cache pattern data structure shown 
axis represents number pages allocated buffer percentage total size data structure 
axis shows number cache misses 
representative biological sequences derived actual experiments section 
see section buffer allocation strategy needs estimate relative magnitudes slopes curve position knee start curve 
full curve shown needed algorithm 
useful facilitate discussion 
tdd heuristic allocating buffers know cache behavior buffer approximately linear memory allocated minimum point 
identify points allocate minimum buffer size necessary structure 
remaining memory allocated order decreasing slopes buffer curves 
know arguments section string poor locality 
infer string data structure require buffer space 
know tree array locality buffer space needs small fraction full size 
suffixes temp know temp array locality suffixes array require memory 
suffixes temp require smaller fraction pages resident buffer cache compared string 
exploit behavior design heuristic memory 
suggest minimum number pages allocated temp suffixes arrays 
sort phase know suffixes array accessed different positions correspond character group boundaries 
incremental benefit adding page high pages expect see change slope point 
allocating pages avoid penalty operating initial high rate region 
tdd heuristic chooses allocate minimum pages suffixes temp 
suggest allocating pages tree array 
pages allow parent node possibly written previous page pushed stack processing accessed replacing current active page 
saves large amount choosing buffer size page 
remaining pages allocated string array 
pages left allocated suffixes temp tree order 
reasoning heuristic borne graphs 
string locality highest slope largest magnitude 
suffixes temp lower magnitude gradual slope indicating improvement additional page allocated smaller 
tree excellent locality nearly zero 
curves knee initial point estimate choosing minimum allocations 
memory small dataset partial disk medium dataset disk large dataset string suffix temp tree percentage main memory scaling buffer allocation example allocation example demonstrates allocate main memory buffer caches 
assume system buffer pages available building suffix tree small string requires pages 
assume alphabet size byte integers 
assuming partitioning done suffixes array need pages integer character string temp array need pages tree need pages 
allocate pages suffixes temp 
allocate pages tree 
left pages 
allocate pages string fitting entirely memory 
remaining pages suffixes temp allocated fit memory final pages tree 
allocation shown pictorially row 
similarly second row allocation medium sized input pages 
heuristic allocates pages suffixes temp pages tree 
string pages 
remaining pages suffixes producing second allocation 
third allocation corresponds large string pages 
suffixes temp tree allocated minimums respectively rest memory pages string 
note entire string fit memory portions swapped memory disk needed 
interesting observe heuristic allocates memory size input string increases 
trend indicated 
input small structures fit memory space occupied largest data structure tree 
input size increases tree pushed disk 
large strings fit memory string pushed disk string nearly memory 
pushing structures better locality disk tdd able scale gracefully large input sizes 
note heuristic need actual utility curves calculate 
estimates knee curve algorithm assumes curve linear rest region 
analysis section analyze advantages disadvantages tdd technique various types sizes string data 
describe design choices tdd overcome performance bottlenecks proposed techniques 
benefits approach authors best memory algorithm ukkonen basis disk algorithm theoretically efficient algorithm 
major difference algorithms ukkonen algorithm sequentially accesses string data updates suffix tree random traversals tdd approach accesses input string randomly writes tree sequentially 
disk construction algorithms random access performance bottleneck access entire page potentially read disk efficient caching randomly accessed disk pages critical 
appearance may simply trading random disk os random disk os input string smallest structure construction algorithm suffix tree largest structure 
tdd place suffix tree small buffer cache writes entirely sequential leaves remaining memory free buffer randomly accessed smaller input string 
algorithm requires smaller buffer cache contain randomly accessed data 
conversely amount buffer cache cache randomly accessed pages allowing construct suffix trees larger input strings 
main memory analysis build suffix trees small strings data structures fit memory disk incurred 
case memory construction expect linear time algorithm ukkonen perform better tdd approach average case complexity nlog 
consider just computational complexity understand execution time algorithms 
traditionally accesses main memory considered equally disk performance bottleneck 
programs require little disk performance bottleneck shifts main memory hierarchy 
modern processors typically employ data caches improving access times memory lot spatial temporal locality access patterns 
processor cache analogous database buffer cache primary difference user control replacement policy 
reading data processor data cache order magnitude faster reading data main memory 
speed processor increases mainmemory latency result latency random memory accesses grow processors 
linear time algorithms ukkonen require large number random memory accesses due linked list traversals tree structure 
majority cache misses occur traversing suffix link new subtree examining child new parent 
traversal suffix link sibling sub tree subsequent search destination node children require random accesses memory large address space 
span memory large fit processor cache access high probability incurring full main memory latency 
array representation pointers children stored array element symbol alphabet reduce number cache misses 
representation uses lot space lead higher run time anyway 
observe alphabet size input string grows number children non leaf node increase proportionately 
children examined find right position insert character cache misses incurred 
ukkonen method incur increasing number processor cache misses increase alphabet size 
tdd alphabet size opposite effect 
branching factor increases working set suffixes temp arrays quickly decreases fit processor cache sooner 
majority read misses tdd algorithm occur calculating size character group line 
character suffix read little spatial locality reads 
algorithms perform random accesses main memory incur expensive cache misses properties tdd algorithm suited inmemory performance access pattern sequential memory random memory access independent accesses accesses known priori 
accesses input data string sequential memory address space hardware data prefetchers may able identify opportunities prefetching cache lines 
addition proposed techniques overlapping execution main memory latency software pipelining easily incorporated tdd 
effect alphabet size data skew properties input string affect execution time suffix tree construction techniques size alphabet skew string 
average case running time constructing suffix tree uniformly random input strings log size input alphabet length input string 
intuition average case time follows 
log levels tree count normalized lcp value lcp histogram swp level suffixes array divided parts 
part count sort find lcp functions run 
running time count sort linear 
find longest common prefix set suffixes uniformly distributed string expected number suffixes compared mismatch slightly 
find lcp function return just comparisons time 
cases actual lcp scan suffixes required 
case uniformly distributed data find lcp function expected run constant time 
gives rise running time log 
interestingly longest common prefix label incoming edge node corresponds range suffixes 
average computed building tree equal average length labels edge non leaf node 
real datasets dna strings skew particular 
nature dna consists large repeating sequences different symbols occur frequency certain patterns occur frequently 
result average lcp higher uniformly distributed data 
shows histogram longest common prefixes generated constructing suffix trees swissprot mb human dna sequence 
notice sequences high probability lcp greater 
biological datasets differences quite dramatic 
dna sequence greater compared protein sequence versus 
important note lcp histograms dna protein sequences shown represent strings particular results highlight differences expect input sets 
data lot repeating sequences find lcp function able complete constant amount time 
scan characters suffixes range actual lcp 
case cost find lcp actual lcp number suffixes range function examining 
result algorithm take longer complete 
note average case complexity remains nlog 
inputs lot repeated sequences dna decrease performance tdd may perform algorithms similar ukkonen ukkonen algorithm exploit repeated subsequences terminating insert phase duplicate suffix tree 
happen frequently case input string dna long repeating sequences providing computational savings ukkonen algorithm 
unfortunately advantage offset random pattern poor choice larger input string cached architectures 
size input alphabet important effect 
larger input alphabets advantage tdd running time log size alphabet 
larger input alphabet implies larger branching factor suffix tree 
turn implies working size suffixes temp arrays shrinks rapidly fit cache entirely lower depth 
ukkonen larger branching factor imply average siblings examined searching right place insert 
leads longer running time ukkonen 
hash array approaches alleviate problem cost consuming space tree 
larger representation naturally implies limited building trees smaller strings 
experimentally demonstrate effects section 
note case ukkonen advantage tdd short input strings small alphabet high skew repeat sequences 
tdd better bet cases 
summary analysis section discussed construction algorithm tdd technique amenable disk suffix tree construction algorithm ukkonen 
algorithm trades random accesses input string size sequential accesses tree data structure size manage tree structure fraction main memory required techniques 
property provides fundamental advantage disk approaches disk performance primarily dependent smallest data structure dependent largest data structure case techniques 
argued small strings structures fit main memory algorithm ukkonen best choice 
behavior algorithm respect processor caches important show section tdd outperforms existing methods memory case 
explored effects alphabet size skew input string tdd 
argue tdd performs better larger alphabet sizes skew string 
algorithms ukkonen hand poor larger alphabet sizes advantage skewed data 
point section experimental verification claims 
experimental evaluation section results extensive experimental evaluation different suffix tree construction techniques 
addition tdd compare ukkonen algorithm memory construction performance hunt algorithm disk construction performance 
ukkonen hunt algorithms considered best known suffix tree construction algorithms memory case disk case respectively 
experimental implementation tdd algorithm uses separate buffer caches main structures string suffixes array temporary working space count sort suffix tree 
fixed size pages reading writing disk 
buffer allocation tdd done method described section 
amount memory required size buffer cache structure loaded cache accesses data bypassing buffer cache logic 
tdd written compiled gnu compiler version full optimizations activated 
implementation ukkonen algorithm version 
textbook implementation ukkonen algorithm gusfield description written algorithm operates entirely main memory persistence 
representation uses bytes node 
implementation hunt algorithm oasis search tool part project 
oasis implementation uses shared buffer cache persistent java object store pjama described original proposal 
buffer manager employs clock replacement policy 
oasis implementation performed better implementation described 
surprising pjama incurs overhead running java virtual machine 
disk experiments follow stated raw devices buffering operating system reads writes disk synchronous blocking 
provides unbiased accounting performance disk construction operating system buffering positively affect performance 
results worst case performance disk construction 
asynchronous writes expected improve performance algorithm results 
raw device accesses single partition maxtor atlas execution time sec hit branch tlb inst resource unif swp unif input set tdd vs ukkonen execution time breakdown iv drive 
disk drive controller lsi ultra scsi controller 
experiments performed intel pentium processor ghz clock speed gb main memory 
processor includes level cache hierarchy 
level caches named cache instructions data respectively 
single cache stores instructions data 
data cache kb way set associative cache byte line size 
instruction cache trace cache way set associative 
cache kb way set associative cache byte line size 
operating system linux kernel version 
pentium processor includes event counters available recording micro architectural events number instructions executed 
access event counters library 
events measured include clock cycles executed instructions micro operations executed cache accesses misses tlb misses branch mispredictions 
comparison memory algorithms evaluate performance tdd technique inmemory construction chose compare performance time ukkonen algorithm 
evaluate hunt algorithm section designed memory technique 
experiment different data sources chromosome drosophila genbank slice swissprot dataset having symbols text collection project gutenberg 
chose strings contain uniformly distributed symbols alphabet size 
data summarized table 
shows execution time breakdown algorithms grouped data source tdd performance left ukkonen performance right 
note memory case tdd reduces data description symbols source chr 
dna gutenberg project year english text swp slice swissprot protein unif char alphabet uniform distrib 
unif char alphabet uniform distrib 
table main memory data sources just algorithm 
experiments data structures fit memory 
total execution time decomposed time executing microarchitectural events bottom top instructions executed plus resource related stalls tlb misses branch mispredictions cache hits cache misses mainmemory reads 
cache component large contributor execution time algorithms 
algorithms show similar breakdown small alphabet sizes dna data unif 
alphabet size increases symbols symbols swissprot symbols unif cache component ukkonen algorithm increases dramatically cache component tdd algorithm remains low 
reason discussed section ukkonen algorithm incurs lot cache misses suffix link new portion tree traversing children trying find right position insert new entry 
observe dataset tdd outperforms ukkonen algorithm performance difference increases alphabet size 
expected discussions section 
instance dna dataset tdd faster ukkonen factor 
swp protein dataset tdd faster factor 
unif tdd faster factor 
results demonstrate despite having time complexity tdd technique significantly outperforms ukkonen algorithm cached architectures 
buffer management tdd section evaluate effectiveness various buffer management policies data structure tdd algorithm analyze performance lru mru random clock page replacement polices wide range buffer cache sizes 
facilitate analysis wide range variables employed buffer cache simulator 
simulator takes input trace address requests buffer cache page size 
simulator outputs disk statistics desired replacement policy 
data shown temp array mru performs worst far shown figures section 
generate traces address requests built suffix data structure swissprot human dna size pages size pages string suffixes temp tree table array sizes trees swissprot database mbps slice human chromosome database 
partitioning phase 
size arrays datasets summarized table 
page size order determine page size buffers conducted experiments 
observed larger page sizes produced fewer page misses alphabet size large protein datasets instance 
smaller page sizes slight advantage case input sets smaller alphabets dna sequences 
observed page size bytes performed wide range alphabet sizes 
interest space omit details page size study 
experiments described section page size kb 
buffer replacement policy results showing effect various buffer replacement policies data structures shown figures 
figures axis buffer size shown percentage original input string size axis number buffer misses incurred various replacement policies 
observe string buffer lru random clock perform similarly 
fact random small advantage limited locality pattern string 
arrays buffer size fixed fraction total size structure string incurs largest number page misses 
surprising structure accessed random fashion 
case suffixes buffer shown policies perform similarly small buffer sizes 
case temp buffer pattern consists linear scan left right copy suffixes suffixes array scan left right copy suffixes back suffixes array sorted order 
clearly mru best policy case shown results 
interesting observe space required temp buffer smaller space required suffixes buffer keep number misses level array sizes 
tree buffer see small buffer sizes lru clock outperform random 
advantage lost moderate buffer sizes 
important fact despite data description symbols source swp entire protein swissprot chr mbps slice human chromosome dna directory gutenberg project english text trembl trembl protein chr entire human chromosome dna entire gutenberg collection english text hg entire human genome dna table disk data sources data symbols hunt tdd speedup source min min swp chr trembl chr hg hrs table performance comparison largest data structure requires smallest amount buffer space takes relatively insignificant number misses policy 
tree buffer choose implement cheapest policy random replacement policy 
comparison disk algorithms section compare performance technique technique proposed hunt currently considered best disk suffix tree construction algorithm 
experiment datasets described table 
suffix tree construction times algorithms shown table 
table see case tdd performs significantly better hunt algorithm 
example trembl database tdd faster factor 
human chromosome tdd faster factor 
large text dataset gutenberg collection tdd nearly times faster 
largest dataset human genome hunt algorithm complete reasonable amount time 
reason tdd performs better hunt algorithm traverses disk tree construction tdd 
construction node tree written 
careful management buffer sizes buffer replacement policies disk tdd brought 
buffer misses buffer misses lru random clock buffer size file size swissprot buffer size file size swissprot buffer misses lru random clock buffer size file size chr buffer misses lru random clock buffer size file size swissprot buffer misses string buffer suffix buffer lru mru random clock buffer misses lru mru random clock buffer size file size chr buffer misses lru random clock buffer size file size swissprot temp buffer tree buffer comparison tdd top proposed top technique constructing suffix trees 
top new low overhead buffer management method ukkonen construction algorithm 
goal researchers invent buffer management technique require modifying existing memory construction algorithm 
contrast tdd hunt algorithm take approach modifying existing suffix tree construction algorithms produce new disk suffix tree construction algorithm 
research focus top different tdd hunt algorithm natural ask top method compares approaches 
compare tdd top obtained copy top code authors 
version code supports building suffix tree indices dna sequences 
recommendation buffer pool internal nodes leaf nodes maximum memory allocation possible top code 
mbp human chromosome top took minutes 
contrast conditions tdd took minutes faster factor 
entire human chromosome top took minutes approach takes minutes 
case tdd faster orders magnitude 
suffix tree construction large character sequences virtually intractable 
existing approaches excessive memory requirements poor locality buffer misses lru random clock buffer size file size chr lru random clock buffer size file size chr scale moderately sized datasets 
address problems unlock potential powerful indexing structure introduced top disk tdd technique disk suffix tree construction 
tdd technique includes suffix tree construction algorithm accompanying buffer cache management strategy 
demonstrate advantage ukkonen algorithm factor memory datasets 
extensive experimental evaluations show tdd scales gracefully dataset size increases 
tdd approach lets build suffix trees large frequently sequence datasets trembl minutes 
algorithms construct suffix trees scale knowledge mentioned literature 
tdd approach outperforms popular disk suffix tree construction method hunt algorithm factor 
fact demonstrate strength tdd show slightly main memory input string suffix tree constructed entire human genome hours single processor machine 
input sizes orders magnitude larger datasets previously published approaches 
researchers proposed buffer management strategies disk suffix tree construction method unique larger data structures required suffix tree construction accessed efficiently small number buffer pages 
behavior leads highly scalable aspect tdd 
part plan making tdd amenable parallel execution 
believe tdd technique extremely parallelizable due partitioning phase employs 
partition source independent subtree complete suffix tree 
partitions independent multiple processors simultaneously construct sub trees 
research supported national science foundation iis research gift donations ibm microsoft 
reviewers vldb hunt valuable comments earlier drafts 
jayant providing copy top code 
andersson nilsson 
efficient implementation suffix trees 
software practice experience spe 
bairoch wu barker ferro huang lopez martin donovan yeh 
universal protein knowledgebase 
nucleic acids research 
atkinson jordan 
providing orthogonal persistence java 
european conference object oriented programming ecoop 

engineering fast online persistent suffix tree construction 
icde 
blumer ehrenfeucht haussler 
average sizes suffix trees 
discrete applied mathematics 
carvalho freitas oliveira 

parallel algorithm extraction structured motifs 
acm symposium applied computing 
chen ailamaki gibbons mowry 
improving hash join performance prefetching 
icde 

cheng cheung 

approximate string matching dna sequences 
eighth international conference database systems advanced applications pages 
ferragina 
theoretical experimental study construction suffix arrays external memory applications 
algorithmica 
delcher kasif peterson white salzberg 
alignment genomes 
nucleic acids research 
delcher carlton salzberg 
fast algorithms large scale genome alignment comparision 
nucleic acids research 
farach colton ferragina muthukrishnan 
sorting complexity suffix tree construction 
acm 
genbank ncbi 
www ncbi nlm nih gov genbank 
giegerich kurtz 
ukkonen mccreight weiner unifying view linear time suffix tree construction 
algorithmica 
giegerich kurtz stoye 
efficient implementation lazy suffix trees 
proceedings third workshop algorithm engineering 
gusfield 
increment approach suffix arrays trees 
technical report cse computer science division university california davis 
gusfield 
algorithms strings trees sequences computer science computational biology 
cambridge university press 
hunt atkinson irving 
database index large biological sequences 
vldb 
intel 
ia intel architecture optimization manual 
intel order number 
intel 
ia intel architecture software developer manual volume system programming guide 
intel order number 
kurtz 
reducing space requirement suffix trees 
software practice experience 
kurtz delcher shumway salzberg 
versatile open software comparing large genomes 
genome biology 
kurtz 
fast computation maximal repeats complete genomes 
bioinformatics 
mccreight 
space economical suffix tree construction algorithm 
acm 
meek patel 
oasis online accurate technique local alignment searches biological sequences 
vldb 
navarro baeza yates 
indexing methods approximate string matching 
ieee data engineering bulletin 
patel 
role declarative querying bioinformatics 

pettersson 
linux performance counters driver user uu se linux 
project gutenberg www gutenberg net 
szpankowski 
average case analysis algorithms sequences 
john wiley sons 
growth genbank ncbi 
www ncbi nlm nih gov genbank html 
ukkonen 
constructing suffix trees line linear time 
algorithms software architecture information processing 
weiner 
linear pattern matching algorithms 
proceedings th annual symposium switching automata theory 

ansi implementation suffix tree cs haifa ac il shlomo suffix tree 
