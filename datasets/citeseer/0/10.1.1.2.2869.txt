timeline high performance archive distributed object store chuang hue moh barbara liskov mit computer science artificial intelligence laboratory describes timeline cient archive service distributed storage system 
timeline allows users take snapshots demand 
archive stored online easily accessible users 
enables time travel user runs computation earlier system state 
archiving challenging storage distributed 
particular key issue provide consistent snapshots avoid stopping user access stored state snapshot taken 
defines properties archive service ought provide describes implementation approach provides desired properties cient 
timeline designed provide snapshots distributed persistent object store 
properties implementation approach apply file systems databases 
timeline implemented results experiments evaluate performance 
experiments show computations past run archive store nearby lan connected high speed link 
results show snapshots negligible impact cost concurrently running computations regardless archived data stored 
describes timeline cient archive service storage system 
timeline allows users take snapshots system state demand issuing command running program requests snapshots periodically hours 
archive containing snapshots stored online easily accessible users 
access archive time 
snapshot assigned timestamp reflecting time requested 
archive enables time travel users run computations past 
user indicates time computation run 
snapshot run computation latest timestamp greater specified time 
chose time interface believe matches user needs 
note users easily build directory structures allow associate names snapshots 
timeline designed provide access old states objects thor persistent object store thor 
thor distributed system storage resides servers designed scale large size large number servers geographically distributed 
thor allows users run computations access current states objects timeline extends interface users run computations access earlier states objects 
key issue providing archive providing consistent snapshots disrupting user access stored state snapshot taken 
issue arises kind storage system just persistent object store 
consistency disruption easy provide storage resides single server challenging storage distributed 
knowledge timeline archive distributed storage system provides consistent snapshots disruption 
archive systems disrupt user access greater lesser extent snapshot taken :10.1.1.130.3029
elephant cause disruption distributed system 
addition elephant snapshots data snapshots command reduce archive storage cpu costs associated snapshots 
timeline implemented results experiments evaluate performance 
experiments show snapshots negligible impact cost running computations current system state 
results showing cost snapshots running computations past 
experiments show computations past run archive state colocated current system state 
necessarily desirable locate storage archived state large 
looked range options shared storage snapshots 
results show performance computations past possible shared archive storage provided reasonably close lan connected high speed link 
results show cost running computations archiving occurring insensitive archived data stored 
remainder organized follows 
section discusses requirements archive system describes approach providing consistency disruption 
sections describe timeline implementation 
section presents performance results section discusses related 
conclude section 
snapshot requirements section defines requirements archive service describes approach satisfying 
archive provide global consistency consistency 
snapshot record state existed moment time 
typically application controls order writes completing modification starting ensuring modification happens 
snapshot record state second modification occurred 
ord disrupt activities users non disruption 
snapshot minimal impact system access users able access system parallel snapshot performance user interactions close achieved system snapshots 
note non disruption typically requirement backup system backups tend scheduled times little user activity 
contrast system allows snapshots taken users want isn implemented properly impact concurrent users unacceptable 
way get consistent snapshot freeze system 
distributed system freezing requires twophase protocol protocol :10.1.1.130.3029
phase node notified snapshot underway 
node receives message suspends processing user requests notes modifications happened point snapshot ones 
coordinator protocol waits receives acks nodes 
phase notifies nodes freeze lifted 
freezing provides consistency ensures modification reflected snapshot modification delayed phase modification happened included snapshot 
freezing necessary node delay modification snapshot observe modification happened modification modification doing snapshots freezing system obviously satisfy non disruption goal 
approach particularly problematical large scale distributed system nodes may widely distributed time required run protocol large 
storage node communicating freeze long time 
alternative implementation record information snapshot server server check information carrying modification 
approach desirable freezing delays modification 
avoid problems system records information happens 
accomplished follows node includes local time message sends node perform modification time clock time heard 
protocol variation proposed 
example user reads information server writes server information server timestamp flow server server delay performing modification clock larger server clock performed modification note approach cheap implement practice modifications delayed provided server clocks loosely synchronized 
assuming timestamps just described implement snapshots follows 
single server acts snapshot coordinator 
take snapshot user communicates server 
server assigns timestamp snapshot reading local clock 
information snapshot flows servers done background 
timestamp determines modifications contained snapshot snapshot includes modifications occurred earlier time occurred time 
nodes need track modifications happen 
done associating time modified timestamp object fact information modifications needed discussed section 
approach provides consistency disruption 
snapshot requires communication snapshot coordinator communicating 
communication needed storage single server case increase availability standard replication 
snapshot coordinator snapshots ordered relative modifications vector clocks entry coordinator 
approach possible users notice anomalies snapshot fail include modification person knows happened include modification person knows happened 
anomalies require communication outside system 
bob takes snapshot told alice certain modification snapshot modification 
anomalies highly current time synchronization technologies ntp synchronize clocks tightly prevent 
timestamp assigned bob snapshot highly greater alice modification 
similar loosely synchronized clocks avoid anomalies proposed 
creating snapshots timeline provides snapshots objects thor 
section provides brief overview thor describes happens user requests snapshot 
overview thor thor persistent object store clientserver model 
servers provide persistent storage objects call object repositories ors 
user code runs client machines interacts thor clientside code called front fe 
fe contains cached copies objects 
user interacts thor running atomic transactions 
individual transaction access read modify objects 
transaction terminates committing aborting 
commits modifications persistent aborts changes reflected persistent store 
thor employs optimistic concurrency control provide atomicity 
fe keeps track objects current transaction 
user requests commit transaction fe sends information new states modified objects ors 
decides commit possible runs phase commit protocol transaction objects multiple ors 
thor uses timestamps part commit protocol 
timestamps globally unique timestamp pair consisting time clock node produced node unique id transaction assigned timestamp commit serialized transactions earlier timestamps transactions timestamps 
thor provides highly available reliable storage objects replicating storage multiple nodes primary backup replication careful disk storage 
snapshot create snapshot user communicates ors acts snapshot coordinator 
refer ssc assigns timestamp snapshot reading local clock 
ssc serializes snapshot requests snapshot unique timestamp assigns timestamps snapshots 
maintains complete snapshot history list assigned timestamps records information persistently 
snapshot request processed ssc information snapshot flow ors happen quickly usually ors date information snapshots 
propagate snapshot information having ssc send information ors request information frequent communication ssc approaches impose large load ssc lots ors 
propagate history information gossip history information piggybacked message system 
problem gossip timestamp snapshot piggybacked history old mean snapshot taken mean piggybacked information date 
distinguish cases having ssc include current time snapshot history indicating information gossip cause snapshot history information propagate fast 
speed things superimpose distribution tree ors 
start information flowing ssc notifies subset ors second level tree time creates new snapshot periodically seconds 
ors fall back querying ssc snapshot information propagated fast 
ssc unreachable period time network partition design see section ensures ors function correctly 
timestamps snapshots able serialize snapshots respect user transactions snapshot reflects modifications user transactions smaller timestamps 
serializing snapshots gives atomicity stronger consistency 
example guarantee snapshots observe modifications user transaction 
approach timestamps works system provides atomicity individual modifications way group modifications multi operation transactions 
snapshot messages time snapshot history large 
usually history needs sent recipient date history 
piggybacked snapshot messages contain portion snapshot history 
addition snapshot message contains timestamps ts curr ts prev bound information message message contains timestamps snapshots happened ts prev ts curr accept snapshot message ts prev equal ts curr previous snapshot message accepted 
typically ts prev chosen sender small receiver highly able accept message 
ts prev quite far past number snapshot timestamps message small 
fact expect common case message contain snapshot timestamps rate snapshots low relative frequency history information propagated 
node unable accept snapshot message request missing information node sender 
storing snapshots section follow describe main functions timeline 
section saves snapshot information archive 
section describes archive service stores snapshot information requested ors provides access previously stored snapshots 
section describes timeline carries user commands run computations past 
design overview timeline provides snapshots combination current pages ors pages stored archive 
particular page modified snapshot occurred copy disk contains proper information 
hand page modified previous state needs written archive disk copy overwritten 
copy scheme specialized snapshots 
create snapshot page needs know snapshots timestamps maximum timestamp transaction modification recorded disk overwriting page 
fundamental problem gossip scheme history information completely date 
know snapshots timestamps particular gossip takes time arrive won know timestamps snapshots taken 
solve problem creating snapshot pages just case needed expensive especially time won needed 
avoid unnecessary creation snapshot pages 
accomplish delaying overwriting pages disk know snapshot pages needed 
approach details implementation discussed section 
thor ors section describes relevant details thor ors implemented 
thor stores objects kb pages 
typically objects small page 
page belongs particular 
object identified uniquely bit bit unique 
contains pageid object page object set page 
fe responds cache fetching entire page modified objects shipped back fe transaction commits 
means order write modifications page disk usually need installation read obtain object page disk 
read part committing transaction degrade system performance 
uses volatile modified object bu er mob store modifications transaction commits writing disk immediately 
approach allows disk reads writes deferred convenient time enables write absorption accumulation multiple modifications page modifications written page single disk write 
mob reduces disk activity improves system performance 
mob compromise correctness system correctness guaranteed transaction log modifications written transaction log persistent transaction committed 
entries removed mob respective modifications installed pages pages written back disk 
removal mob entries clean ing mob done flusher thread runs background 
thread starts run mob fills pre determined high watermark removes entries mob small 
flusher processes mob log order facilitate truncation transaction log 
modification encounters reads modified object page disk installs modifications mob objects page writes updated page back disk 
flusher finishes pass cleaning mob removes entries transactions completely processed transaction log 
volatile page bu er uses satisfy fe fetch requests 
returning page requesting fe updates bu er copy contain modifications mob page 
ensures pages fetched reflect committed transactions 
pages flushed page bu er needed lru 
dirty pages simply discarded written back disk flusher thread part system modifies pages disk 
anti mob implementation takes advantage mob delay writing snapshot pages snapshot history su ciently date 
know create snapshot pages needs know current snapshot status pages 
information kept snapshot page map stores timestamp page 
snapshot page page created due snapshot corresponding snapshot page map entry updated timestamp snapshot page map entries initially zero 
snapshots page created timestamp order snapshot page map entry page timestamp greater snapshot created snapshot copy page snapshot 
stores knows snapshot history gmax highest ssc timestamp received 
recall time pages overwritten disk mob cleaned 
create snapshot pages part cleaning mob 
doing important advantages 
allows benefit installation read done flusher thread 
second flusher runs mob full works transactions committed past 
time transaction modifications processed flusher highly snapshot information know snapshot pages required 
simple strategy start page read flusher thread mob obtain right state snapshot page 
example suppose mob contains modifications transactions modified page suppose snapshot snapshot page created timestamp greater need apply modifications page writing archive 
simple strategy doesn handle situations arise reasons 
page processed flusher thread page bu er flusher read disk 
case page reflects modifications mob including transactions snapshot 
get pre states modifications re reading page disk undesirable 
need way revert modifications 
second problem transaction modifies object entry mob due older transaction old mob entry overwritten new 
may need overwritten entry create snapshot page 
mob processed encounter modifications belong transactions committed gmax normally avoid doing flusher process mob entries recording modifications transactions timestamps greater gmax flusher process entries propagation snapshot history stalled 
happens able continue processing mob unable continue committing transactions 
need place store information mob storage area anti mob storage area heap itable anti mob mob object wrappers 
structure anti mob pre image page overwritten disk 
uses memory bu er called anti mob store overwritten mob entries transaction pre images 
anti mob mob records information objects 
shown anti mob entry contains pointer object pre image heap shares mob 
entry contains timestamp pre image transaction transaction caused pre image stored 
example overwrites object written pointer older version object stored anti mob timestamp 
note don copy old version just move pointer mob anti mob 
information written anti mob needed needed 
anti mob usually needed object overwritten committing transaction certain timestamp larger gmax page read disk response fetch request fe modification installed due transaction old timestamp knows pre state needed 
addition time object overwritten may create additional anti mob entry transaction original write 
entry pointer pre image set null indicates preimage transaction page disk 
example suppose transaction modified object transaction modifies adds modified version mob stores anti mob indicate value created pre image furthermore modification modification object transaction currently recorded mob snapshot requires snapshot page page adds null anti mob indicating proper value currently stored disk 
flusher thread snapshot thread mob anti mob transaction log data pages snapshot log archive store 
snapshot subsystem creating snapshot pages describe snapshot pages created 
shows design snapshot subsystem works tandem mob transaction log 
snapshots done partly flusher thread partly snapshot thread works background 
snapshot pages produced mob apply modifications anti mob revert modifications mentioned install modification mob flusher thread reads page disk necessary 
goes mob applies modification page memory copy provided transaction modification timestamp bound 
typically bound gmax occasionally history information old larger 
applying modification page flusher decides pre image needed 
pre image needed transaction modification timestamp greater gmax needed knows snapshot timestamp transaction entry page snapshot page map snapshot 
pre image flusher copies current value modified object page heap overwriting object 
entry anti mob transaction caused modification creates entry points value heap 
anti mob entry containing null flusher modifies entry points value heap 
page modified page cache flusher applies modifications copy 
copy contains modifications appropriate preimages exist anti mob put part carrying fetch request page 
flusher applied modifications page assuming snapshot required page copy page uses anti mob revert page proper state 
undo modifications page needed snapshot timestamp scans portion anti mob timestamps scan set objects scanned page snapshot initialized entry anti mob transaction timestamp timestamp scan scan scan install endif 
algorithm creating snapshot pages greater pre images corresponding modifications installs algorithm creating snapshot pages shown 
contain pre images corresponding single object 
pre image oldest transaction snapshot contain correct version object snapshot 
algorithm uses scan set keep track pre images scanned ensure correct pre image corresponding object encountered creating snapshot page 
snapshot page belongs snapshot timestamp earliest transaction pre image placed page 
know snapshot timestamp gmax snapshot pages produced condition holds 
section discusses happens cleans mob gmax snapshot page persistent disk copy page overwritten 
discuss point section 
discarding anti mob entries entries discarded anti mob soon longer needed making snapshot pages 
flusher snapshot pages snapshot knows pages modifies part pass cleaning mob 
pass entries snapshot pages deleted anti mob 
entries timestamp equal gmax snapshot pages snapshots gmax point 
new snapshot information arrives updates gmax re evaluate entries discarded 
specifically advances gmax scans anti mob entries timestamps entry discarded corresponding snapshot page snapshot timestamp smaller created 
usually entries removed snapshot 
persistence failure recovery page modified disk anti mob place pre images exist snapshot pages require pre images written archive 
anti mob volatile lost failed 
normally snapshot pages created part cleaning mob avoid need information anti mob persistent delaying overwrite page disk snapshot pages written archive 
decided implement things way write archive slow snapshot page stored node far away network distance 
cases need overwrite page making snapshot pages propagation snapshot history stalls see section 
decided snapshot log way ensuring persistence pre images 
pre images inserted snapshot log reverting pages get appropriate snapshot page 
creation snapshot page causes number entries page added snapshot log 
entries record pre images objects page modifications need reverted recover snapshot page 
page overwritten disk snapshot log entries containing pre images modifications page flushed disk backups 
snapshot page written archive asynchronously 
note write snapshot log entries disk large group covering snapshot pages amortize cost flush 
entries removed snapshot log associated snapshot pages saved archive 
recovery snapshot information recovers failure recovers snapshot history communicating initializes mob anti mob empty initializes snapshot page map entries undefined 
reads transaction log places information modified objects mob 
may create anti mob entries objects overwritten 
reads snapshot log adds entries anti mob 
snapshot log processed working backwards 
example suppose required snapshot pages snapshots respectively 
recover system reads disk applies entries snapshot log applies entries point resume normal processing doesn correct information snapshot page map 
obtains information archive 
example adds entry mob entry page snapshot page map undefined requests snapshot information archive 
done asynchronously time information needed cleaning mob highly know 
anti mob overflow propagation snapshot history information stalls clean mob gmax cause anti mob overflow memory space allocated 
cleaning push current contents anti mob snapshot log force log disk 
clear anti mob continue inserting new entries 
gets updated snapshot information advances gmax processes anti mob blocks previous written snapshot log 
processing backward written block earliest block 
block processed backward 
course learns new snapshots taken avoid processing just discard blocks 
backward processing soon reaches block entries transactions earlier earliest new snapshot just heard 
process block appropriate page image 
time encounters entry particular page current page disk 
needs page modified 
uses table records information pages processed far 
pages stored memory possible disk 
snapshot pages written archive removes anti mob blocks snapshot log discards temporary pages processing blocks 
archiving snapshots section describes design archive store 
require archive provide storage reliable available thor provides current states objects 
example thor ors replicated snapshot pages degree replication 
archive store abstraction table shows interface archive 
provides operations put get 
put operation store page archive 
arguments provide value snapshot page identity giving pageid timestamp snapshot created 
operation returns page operation description put pageid ts ss page ss stores snapshot page page ss archive get pageid ts ss retrieves snapshot page archive 
pageid retrieves latest timestamp page 
table 
interface archive stored reliably written disk written su cient number replicas 
get operation retrieve page archive 
arguments identify page giving pageid timestamp snapshot interest 
archive contains page identity timestamp returns 
snapshot page page returns oldest 
returns null 
correct return snapshot page way produce snapshot pages produce pre images modifications 
snapshot page required timestamp means changes page requested snapshot earliest snapshot information stored snapshot correct snapshot 
operation takes pageid arguments 
returns latest timestamp snapshot page identified page returns zero snapshot page 
reinitialize snapshot page map recovers failure 
archive store implementations considered alternatives implementing archive store local archive store network archive store local area network archive store servers distributed wide area network 
local archive store archives snapshot pages created 
discuss section snapshot pages fetched 
approach provide best performance transactions snapshots compared implementations 
hand archive potentially large 
addition ors may di er widely archive space require may desirable allow sharing archive storage 
network archive store snapshots archived specialized storage node located close group ors lan 
design allows sharing high storage node nodes node disk array provides high reliability 
impact network archive store performance fetching snap local archive store separate disk maps timestamp page map snapshot associated timestamp top level map maps pageid location page archive store identical original page map thor second level map archive marker 
storage system archive store node shot pages depends speed underlying network connection 
example gigabit lan expect performance network archive store close local archive store 
distributed archive store implemented set storage nodes distributed wide area network 
ors share archive store approach allows sharing network archive store 
proper design system provide excellent reliability automatic load balancing self organization features similar achieved peer peer systems :10.1.1.105.3673
downside scheme data may located far away ors making costly run transactions snapshots 
expect choice place archive store mainly ect cost running computations snapshots 
designs perform similarly respect snapshots writing snapshot pages archive done asynchronously 
implementation details section describe archive store implementations 
local archive store snapshots stored separate disk disks requests read write snapshot pages don interfere normal activity fetching current pages 
disk organized log shown 
snapshots pages appended log identifier pageid timestamp snapshot snapshot page created 
organization writing snapshot pages disk fast speed writing multiple pages log 
directory structure maintained primary memory provide fast access snapshot pages 
identifier information log allows recover directory log failure 
network archive store uses log structured organization disk 
runs client proxy receives calls archive operations put turns messages communicates storage server udp 
storage node distributed archive store uses log structured organization 
nodes may ors separate storage nodes combination 
runs client proxy handles calls archive operations 
proxy interesting 
main issue designing distributed archive store deciding allocate snapshot pages storage nodes 
decided base design consistent hashing 
approach storage node distributed archive store assigned identifier nodeid large bit space organized ring 
nodeids chosen space evenly populated 
snapshot page identifier 
map snapshot page storage node successor function chord node nodeid succeeds snapshot page responsible archiving page :10.1.1.105.3673
note deterministic function chosen closest node id space pastry 
snapshot page sha hash page pageid 
way snapshot pages page mapped storage node 
choice implementation get cient implemented single node 
interact archive client proxy ors needs map nodeid node responsible page interest ip address 
systems consistent hashing typically multi step routing algorithm mapping shows routing done step :10.1.1.105.3673
routing important concern client proxy cache ip addresses nodes responsible snapshot pages 
population storage nodes change frequently cache hit rate high 
cost distributed storage just cost sending receiving data storage node 
chose consistent hashing number reasons 
node ids snapshot ids distributed reasonably provides load balancing 
property allowing nodes join leave system local disruption data needs redistributed happens nodes nearby id space ected 
course snapshot pages need replicated allow storage nodes leave system losing data 
snapshot page need archived nodes 
slow system generate network tra benefit replication snapshot pages retrieved parallel replicas copy arriving satisfy request 
result cost retrieving snapshot page cost fetching nearest replica 
transactions snapshots users run transactions snapshot specifying time past transaction execute 
allow read transactions don want transactions run past able rewrite history 
snapshot timestamp equal specified timestamp snapshot transaction 
fe uses timestamp fetch snapshot pages 
fe needs determine timestamp specified user gmax fe 
section provide overview fe 
describe fe support read transactions snapshots 
thor front section contains brief overview fe 
information 
speed client transactions fe maintains copies persistent objects fetched memory cache 
uses page map locate pages cache page pageid 
transaction uses object isn cache fe fetches object page 
transaction commits modified objects shipped back 
pages fetched stored page size page frames 
page evicted cache room incoming page hot objects retained moving compacted frame stores objects 
objects ors refer recall identifies object 
avoid fe having translate memory location time follows pointer pointer swizzling time replaced information allows object ciently located fe cache 
swizzled changed point entry resident object table rot 
entry points object cache 
way finding object cache cheap cheap discard pages cache move objects compacted pages 
snapshots user requests run transaction past fe cache contain pages belonging time lines 
similarly user switches back running past running fe cache contain snapshot pages 
case fe ensure user transaction uses appropriate objects objects current pages running objects snapshot pages requested snapshot running past 
approach ensuring right objects clear fe cache time user switches running di erent time 
approach forces fe discard hot objects cache degrade transaction performance 
happen user switches repeatedly current database snapshot back current database 
chose di erent approach 
extended fe cache management scheme fe caches pages multiple snapshots time 
fe manages cache transaction sees objects correct version 
implementation optimized little impact running transactions expect common case 
user switches time line entries rot refer objects belonging time line previously 
ensure transaction run objects 
accomplish setting entry rot null turn causes rot misses subsequent accesses objects 
rot happens fe performs lookup page map locate page cache 
ensure find right page belonging time line currently running transaction extend page map store timestamp page current pages null timestamp 
page map lookup find right page timestamp associated currently running transaction 
lookup succeed appropriate page cache 
lookup fails fe fetch page 
fetching snapshot pages fe fetches snapshot page requesting stores page 
reason snapshots consist current pages pages archive provide current page appropriate fetches required page archive 
page fetch requests fes ors extended contain snapshot timestamp null fe transaction running 
timestamp null uses determine correct snapshot page consulting snapshot page map 
snapshot page map stores snapshot timestamp page 
timestamp request equal timestamp stored map requested page requests snapshot page archive returns result fetch fe 
create snapshot page moment 
page copy disk page bu er plus information mob anti mob 
returns resulting page fe 
addition snapshot page di erent current page stores page archive updates snapshot page map avoids creating snapshot page 
experiments section performance evaluation snapshot service 
comparing performance original thor thor ss version thor supports snapshots 
thor basis study performs 
earlier studies showed delivers comparable performance highly optimized persistent object system implemented system support transactions 
experiments show thor ss slightly costly run thor 
thor ss complete implementation design absence failures includes making anti mob persistent recovery mechanism 
implementation su cient allow measure performance common case failures 
experimental methodology oo benchmark benchmark intended capture characteristics various cad applications 
oo database contains tree assembly objects leaves pointing composite parts chosen randomly objects 
composite part contains graph atomic parts linked bidirectional connection objects reachable single root atomic part atomic part connections 
employed medium oo database configuration composite part contains atomic parts 
entire database consumes approximately mb 
oo traversals experiments 
read measures raw traversal speed performing depth search composite part graph touching atomic part 
read write updates atomic part composite part 
single fe single experiments 
fe ran separate dell precision workstations pentium iii mhz mb ram quantum atlas wls scsi hard disk linux kernel 
identical machine network storage node network archive store running simulator developed sfs toolkit simulating node wide area archive store 
machines connected mbps switched ethernet 

baseline comparison thor vs thor ss foreground costs set experiments compares foreground cost running thor thor ss 
particularly looked extra cost committing transactions thor ss mob cleaning occurring 
experiments mb mob ensure mob cleaning happen 
thor ss extra committing transaction overwrites previously modified objects 
overwriting occurs thor writes modified objects mob modifies mob table point new entry 
occurs thor ss addition thor ss add previous entry anti mob 
case foreground doesn respond fe commit request done 
measured average execution times 
case traversal executed times run separate transaction 
experiments done hot fe cache contained objects traversal 
way eliminated cost fetching pages cost fetching pages dominate execution time 
number pages traversals identical thor thor ss 
results experiments shown 
shows significant di erence running read traversal thor case writing mob anti mob occurs 
objects modified causes overwrites mob overwrite leads object moved anti mob leading slowdown 
cpu time commit transaction seconds thor seconds thor ss 
di erence time taken thor ss extra storing overwritten objects anti mob data show takes approximately secs update anti mob overwritten object 
workload generated realistic representation expect users users repeatedly modify objects modify objects database 
developed workload realistic 
workload modified version traversal randomly updates objects traversal objects original modifies 
overwriting traversal overwrites average objects 
shown little di erence performance thor thor ss traversal 
impact snapshot page creation section look additional mob cleaned 
thor cleans mob background low priority process flusher running small time slices 
heavily loaded cleaning show user observable slowdown 
ect thor ss snapshot pages created 
thor cleans pages 
amortize disk seek time works segments kb contiguous regions disk containing pages 
thor read write segment cheaply reading writing page page segment modified cleaning costs lower approach 
results section obtained running modified 
experiment ran times committed transactions 
ran experiments cleaning 
avoid cleaning mb mob cause cleaning occur mb mob 
mb mob cleaning begins th traversal commits 
remaining traversals segments cleaned pages modified average modified objects consuming kb installed segment 
continued mb cache disk activity occurred cleaning part experiment 
get sense load due cleaning measured cpu time required cleaning 
results experiments shown table 
case measurement started point flusher thread decided segment needs updated 
point segment memory 
measurement thor stops modifications installed segment entries removed mob segment written disk 
results show average cost cleaning segment 
table shows measurements thor ss 
case snapshots need thor ss extra entries need removed anti mob 
second measurement thor ss snapshot pages 
case measurement includes cost creating snapshot pages reverting changes writing pre images snapshot log measurement stops system cleaning time thor ms thor ss snapshot ms thor ss snapshot ms table 
time taken clean segment 
cost snapshots snapshot log forced disk flusher wait complete 
worst case experiment page requires corresponding snapshot page represents case snapshot just requested 
impact users additional cleaning activity thor ss depends load 
hope spare cycles run thor ss cleaning snapshot pages entirely background just thor cleaning done background case 
reasonable expectation showed table thor ss requires modest amount time cleaning case page requires snapshot page 
shows results experiments 
thor thor ss experiments compare cost running traversals cleaning 
performance traversals identical viewpoint user transaction cleaning mob cause slowdown 
particular case page cleaned requires snapshot page slowdown 
running transactions snapshots section examine performance running transactions past 
compare performance running transactions 
experiments traversal allow read transactions run past 
ran cold fe cache page fetched 
running causes snapshot pages fetched 
empty page cache 
cold fe cache empty page cache provide uniform setup measure slowdown caused running snapshot compared 
performance snapshot running current database 
discussed section fe cache fe fetches missing page 
true fe requires snapshot page current page 
shows results 
shows running past slightly slower approximately slower running snapshots stored disk 
slowdown due entirely processing fe particular due additional level indirection fe page map ects transactions past 
shows happens archive store located 
slowdown relatively small snapshot pages archived nearby node connected mbps network cost send kb data storage node ms case time taken run secs 
performance degraded time required send kb data increases ms heavily loaded slower mbps lan performance slower order magnitude secs 
performance degraded archive farther away 
results imply remote storage node close connected gigabit network performance running snapshot essentially identical storing archive remote node 
performance running snapshots degrades substantially storage moves farther away remote shared storage may best choice advantage shared facility 
related number systems provided snapshots recovering failure provide ability look past state 
large body systems take checkpoints 
compare timeline systems provide snapshots closely related 
plan file system server system provides atomic dump operation backups 
dump operation memory cache flushed file system frozen blocks modified dump operation queued disk writing worm storage 
system delays access file system dump taken 
write file layout file system designed nfs server appliance provides snapshot feature 
time page modified snapshot taken writes page new location preserving old disk copy snapshot modifies disk copy directory block points page 
block needs duplicated eagerly snapshot root inode block 
snapshot includes current values dirty pages cache page modified written disk proper snapshot value page known 
avoid problem blocks incoming requests modify dirty data cache moment snapshot requested 
block requests 
frangipani distributed file system built petal distributed storage system :10.1.1.130.3029
frangipani uses petal snapshot features create point time copy entire distributed file system 
point time copy copied tape worm device backup 
maintain consistency snapshot backup process requests exclusive lock system 
requires stopping system servers learn snapshot 
hears snapshot server flushes cache disk blocks new file system operations modify data 
operations remain blocked lock released 
point backup service takes petal snapshot server create point time copy 
done copy write delaying user requests 
petal doesn block take snapshot supports single writer 
plan frangipani require system block users snapshot 
furthermore timeline distributed system plan 
frangipani distributed requires global lock take snapshot lead substantial delay 
elephant file system maintains versions uses timestamps provide consistent snapshot 
version file defined updates open close operation file 
file inode duplicated file opened copy write create version file 
concurrent sharing file supported copying inode open appending inode log close 
timeline similar elephant timestamps distributed system elephant server system 
addition timeline snapshots command elephant takes automatically 
snapshots command reduces size archive storage 
arguably provides useful information users decide snapshots want having contend huge amounts data hard relate activities interest 
database systems provide access historical information 
systems allow queries time information provided explicitly user implicitly system 
time field overwritten old value record retained 
alternative design snapshots store undo redo log materialize snapshot demand undo log current state rolled backward desired time line redo log initial state roll forward 
logs pioneered database system early postgres storage manager proposed keeping entire state redo log 
approach subsequently rejected cost materializing current system state 
results taken show materializing snapshot state practical snapshots available huge delay describes timeline cient archive service distributed storage system 
timeline allows users take snapshots demand 
archive stored online easily accessible users 
enables time travel user runs computation earlier system state 
timeline allows snapshots taken disruption user access store delayed snapshot requested 
scheme provides consistent snapshots fact provides atomicity stronger consistency 
techniques timeline system provides atomicity individual modifications 
furthermore timestamps order snapshots system implements logical clocks logical clocks easy cheap implement 
timeline provides consistent snapshots minimum impact system performance storing snapshot pages occurs background 
scheme scalable snapshots requested communicating single node information propagated nodes system gossip 
main performance goal system snapshots interfere transactions current database degrade performance 
additional goal provide reasonable accesses snapshots computations run past 
experiments show computations past run fast archive state located current system state run reasonably shared archive storage close lan connected high speed link 
results show snapshots negligible impact cost concurrently running computations regardless archived data stored 
authors gratefully acknowledge help received shrira rodrigo rodrigues sameer shepherd je chase referees 
research supported ntt nsf ani 
carey dewitt naughton 
oo benchmark 
sigmod record 
castro adya liskov myers 
hac hybrid adaptive caching distributed storage systems 
proceedings th acm symposium operating systems principles sosp saint malo france october 
demers greene hauser irish larson shenker sturgis terry 
epidemic algorithms replicated database maintenance 
proceedings th acm symposium principles distributed computing vancouver canada august 
elnozahy alvisi wang johnson 
survey rollback recovery protocols message passing systems 
technical report cmu cs carnegie mellon university june 
ghemawat 
modified object bu er storage management technique object oriented databases 
phd thesis massachusetts institute technology cambridge ma usa september 
gi ord 
information storage decentralized computer system 
technical report csl xerox parc march 
gupta liskov rodrigues 
hop lookups peerto peer overlays 
proceedings th workshop hot topics operating systems hotos hawaii may 
hitz lau 
file system design nfs file server appliance 
proceedings usenix winter technical conference san francisco ca usa january 
karger lehman leighton levine lewin 
consistent hashing random trees distributed caching protocols relieving hot spots world wide web 
proceedings th acm symposium theory computing el paso tx may 
ladin liskov shrira ghemawat 
providing high availability lazy replication 
acm transactions computer systems november 
lamport 
time clocks ordering events distributed system 
communications acm july 
lee thekkath 
petal distributed virtual disks 
proceedings th international conference architectural support programming languages operating systems asplos boston ma october 
liskov adya castro day ghemawat gruber maheshwari myers shrira 
safe cient sharing persistent objects thor 
proceedings acm sigmod conference montreal canada june 
liskov castro shrira adya 
providing persistent object distributed systems 
proceedings th european conference object oriented programming lisbon portugal june 
lomet salzberg 
temporal databases theory design implementation pages 
addison wesley march 
lowell chandra chen 
exploring failure transparency limits generic recovery 
proceedings th symposium operating system design implementation san diego ca october 

topics distributed computing impact partial synchrony modular decomposition algorithms 
phd thesis massachusetts institute technology 
lynch 
distributed algorithms 
morgan kaufmann march 
mazieres 
toolkit user level file systems 
proceedings usenix annual technical conference boston ma june 
mills 
network time protocol version specification implementation analysis 
technical report network working group report rfc university delaware newark de usa march 
oki liskov 
replication general primary copy 
proceedings th symposium principles distributed computing podc toronto ontario canada august 
ozsoyoglu snodgrass 
temporal real time databases survey 
ieee transactions data engineering august 
parker popek stoughton walker walton chow edwards kline 
detection mutual inconsistency distributed systems 
ieee transactions software engineering se may 
pike presotto dorward thompson trickey 
plan bell labs 
computing systems summer 

pastry scalable distributed object location routing large scale peer peer systems 
proceedings ifip acm conference distributed systems middleware heidelberg germany november 
feeley hutchinson veitch 
deciding forget elephant file system 
proceedings th acm symposium operating systems principles sosp charleston sc usa december 
steiner norrie 
implementing temporal databases object oriented systems 
proceedings th int conference advanced information systems engineering barcelona spain june 
stoica morris karger kaashoek :10.1.1.105.3673
chord scalable peer peer lookup service internet applications 
proceedings acm sigcomm conference san ca usa august 
stonebraker 
design postgres storage system 
proceedings th international conference large data bases brighton england uk september 
stonebraker hellerstein editors 
readings database systems chapter 
morgan kaufmann publishers rd edition 
thekkath mann lee :10.1.1.130.3029
frangipani scalable distributed file system 
proceedings th acm symposium operating systems principles sosp malo france october 
