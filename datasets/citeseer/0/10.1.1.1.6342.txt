type indexed data types ralf hinze johan jeuring andres institut informatik iii universit bonn bonn germany ralf informatik uni bonn de www informatik uni bonn de ralf institute information computing sciences utrecht university box tb utrecht netherlands andres cs uu nl www cs uu nl andres open university netherlands polytypic function function instantiated data types obtain data type specific functionality :10.1.1.41.125:10.1.1.41.125
examples polytypic functions functions derived haskell show read 
advanced examples functions digital searching pattern matching unification rewriting structure editing 
problems define polytypic functionality type indexed data type data type constructed generic way argument data type 
example case digital searching define search tree type induction structure type search keys 
shows define type indexed data types discusses examples type indexed data types shows specialize type indexed data types 
approach implemented generic haskell generic programming extension functional language haskell 
polytypic generic type indexed function function instantiated data types obtain data type specific functionality 
examples polytypic functions functions derived haskell show read :10.1.1.46.223
see backhouse polytypic programming :10.1.1.41.1824
advanced examples polytypic functions functions digital searching pattern matching unification rewriting structure edit preprint submitted elsevier science july ing :10.1.1.41.125:10.1.1.41.125:10.1.1.37.2565:10.1.1.46.223
problems define polytypic functionality type indexed data type data type constructed generic way argument data type 
instance case digital searching define search tree type induction structure type search keys 
current strongly typed programming languages support type indexed data types examples appear literature implemented ad hoc fashion implemented 
shows define type indexed data type discusses examples type indexed data types shows specialize data type 
specialization illustrated example translations haskell 
approach implemented generic haskell generic programming extension functional language haskell 
generic haskell obtained www generic haskell org 
revised version 
example digital searching 
digital search tree trie search tree scheme employs structure search keys organize information 
searching useful various data types allow keys information data type 
means construct new kind trie key type 
example consider data type string defined data string nil cons char string 
represent string indexed tries associated values type follows data fmap string trie string fmap string fmap stands finite map 
trie strings typically index texts 
component constructor trie string contains value associated nil 
second component trie string derived constructor cons char string string 
assume suitable data structure associated look function char characters predefined 
naming convention names fmap string underscore separates name types instances entities 
goal describe generate types automatically generic definition 
compound names examples haskell :10.1.1.46.223
deviating haskell universal quantification types explicit means type 
assume type function predefined defined user 
definitions string fmap string define look function strings follows lookup string string fmap string lookup string nil trie string tn tc tn lookup string cons trie string tn tc lookup string tc 
look non empty string cons look obtaining trie recursively searched look functions result type reverse monadic composition monad called compose lookup string lookup char 

case just consider data type bush binary trees characters leaves data bush leaf char fork bush bush 
bush indexed tries represented data type data fmap bush trie bush fmap bush fmap bush 
components store values constructed leaf values constructed fork 
corresponding look function lookup bush bush fmap bush lookup bush leaf trie bush tl tf tl lookup bush fork bl br trie bush tl tf lookup bush bl lookup bush br tf easily recognize look functions data types tries instances underlying generic pattern 
section show define trie associated functions generically arbitrary data types 
material taken hinze repeated serves nice simple example type indexed data type 
example pattern matching 
polytypic functions maximum segment sum problem pattern matching labelled data types :10.1.1.41.125:10.1.1.46.223:10.1.1.46.223:10.1.1.46.223
labelled data types introduced store node subtree rooted node set patterns trees variables matching subtree example data type labelled bushes defined data lab bush label leaf char label fork lab bush lab bush constructed bush data type extending constructor additional field store label :10.1.1.41.125:10.1.1.46.223:10.1.1.46.223:10.1.1.46.223
section show define labelled data type generically data type specification generic pattern matching program 
example zipper 
zipper data structure represent tree subtree focus attention focus may move left right tree :10.1.1.41.1824:10.1.1.46.223
example zipper corresponding data type bush called loc bush defined type loc bush bush context bush data context bush top context bush bush bush context bush 
type locations efficiently navigate tree 
example bush loc bush loc bush bush leaf leaf bush fork tl tr tl tr right bush loc bush loc bush right bush tl tr tr tl right bush navigation function bush moves focus attention leftmost subtree current node right bush moves focus right sibling 
huet defines zipper data structure rose trees data type bush gives generic construction words :10.1.1.46.223
section describe zipper detail show define zipper arbitrary data type 
examples 
examples number examples type indexed data types appeared literature :10.1.1.46.223
expect type indexed data types useful generic dtd transformations :10.1.1.41.125:10.1.1.46.223
generally believe type indexed data types important type indexed functions 
background related 
little related data types 
type indexed functions introduced decade ago :10.1.1.41.125:10.1.1.46.223
approaches type indexed functions see dubois jay yang mentions user defined type indexed data types yang mention types usually called dependent types :10.1.1.41.1824:10.1.1.130.789:10.1.1.130.789:10.1.1.22.8611
type indexed data types appear intensional type analysis :10.1.1.46.223
intensional type analysis typed intermediate languages compilers polymorphic languages able optimize code polymorphic functions 
differs aspects typed intermediate languages expressive complex languages intended programmers compiler writers generic haskell built top haskell problem combine user defined functions data types type indexed functions data types 
problem appear typed intermediate languages typed intermediate languages interpret representation type argument run time specialization technique described require passing representations type arguments originally typed intermediate languages restricted data types kind 
building hinze weirich generalized intensional type analysis higher order kinded types 
higher order intensional type analysis support type indexed data types 
organization 
rest organized follows 
show define type indexed data types section hinze approach polytypic programming :10.1.1.41.125:10.1.1.41.1824
section illustrates process specialization means example 
section shows type indexed data types possess kind indexed kinds provides theoretical background specialization type indexed data types functions arguments data types 
section provides details zipper example 
section summarizes main points concludes 
defining type indexed data types section shows define type indexed data types 
section briefly reviews concepts polytypic programming necessary defining data types 
subsequent sections define type indexed data types problems described 
assume basic familiarity haskell type system particular concept kinds :10.1.1.41.1824
thorough treatment reader referred hinze :10.1.1.41.125:10.1.1.41.1824
type indexed definitions central idea polytypic programming called type indexed generic programming provide programmer ability define function induction structure types 
haskell type language involved mutually recursive types parameterized types nested types type constructors higher order kinds sounds hard nut crack 
fortunately show polytypic function uniquely defined giving cases limited set types type constructors 
instance define generic function types kind need cases unit type sum type constructor product type constructor 
types required modelling haskell data construct introduces sum products 
treat data declarations data data inl inr data 
additionally want generic functions primitive types char float defined means haskell data statement need include additional cases types 
purposes assume char primitive type 
polytypic function definition inductive char 
example polytypic equality function 
emphasis type index enclosed angle brackets 
equal bool equal true equal char equal inl inl equal equal inl inr false equal inr inl false equal inr inr equal equal equal equal simple definition contains ingredients needed specialize equal arbitrary data types 
note definition mention type abstraction type application fixed points 
instances polytypic functions types constructions generated automatically just cases 
example equal data type bush generated specialization behave exactly hand written code 
equal bush bush bush bool equal bush leaf leaf equal bush fork fork equal bush equal bush equal bush false discuss generation specializations generic functions detail section 
want able refer name constructor 
add special type constructor case defined generic function value type kind 
value represents name constructor 
case omitted definition polytypic function poly function equal assume poly poly purposes assume type string 
example constructor names generic function give simple variant polytypic show function computes textual representation value show string show show char showchar show inl show show inr show show show show show show 
string string string stands string concatenation 
polytypic function specific data type implicitly view data type constructed unit type sum product marker constructors 
example haskell data type natural numbers data nat zero succ nat represented nat zero succ nat data type bushes data bush leaf char fork bush bush viewed bush leaf char fork bush bush :10.1.1.41.125
details type representation section 
functions equal show indexed type kind 
polytypic function may indexed type constructors kind course type constructors kinds needed sequel 
need slightly different base cases generic functions operating types kind id denotes abstraction type level 
constant functor lifts type kind kind 
need char general primitive types 
overload lifted versions previously defined counterparts 
new type index set indices kind identity functor id hinze shows types normal forms types kind :10.1.1.41.125:10.1.1.41.1824
known example indexed function mapping function applies function element type structure type map 
map id map map char map inl inl map map inr inr map map map map map instance define generic versions cata anamorphisms :10.1.1.41.125
assume data types fixed points called pattern functors 
haskell fixed point combinator defined follows newtype fix fix 
follows constructor destructor types fix fix fix fix example defined type bushes bush fix bushf data bushf char easy convert data type defined fixed point original type definition bushes 
cata anamorphisms cata 
fix cata map cata ana 
fix ana map ana 
note functions parameterized pattern functor fixed point fix example catamorphism functor bushes bushf defined cata bushf 
bushf fix bushf cata bushf map bushf cata bushf map bushf instance generic function map defined equivalent map bushf 
bushf bushf map bushf map bushf bl br bl br 
cata ana called generic abstractions generic functions defined induction base types terms generic functions 
generic haskell supports generic abstractions 
tries tries isomorphisms known laws exponentials 
fin fin fin fin fin fin fin laws exponentials ones need definition tries 
fin denotes type finite maps isomorphisms defining equations give type indexed definition data type fmap finite maps generalizes fmap string arbitrary data types 
example type indexed data type 
fmap fmap fmap char fmap fmap fmap fmap fmap fmap definition type indexed data type similar definition type indexed function seen previous subsection 
note name type indexed data type starts capital letter 
give cases char cases sufficient information subsequently fmap data type kind 
note fmap id monad exception handling case partially defined finite map 
assume suitable data structure associated lookup function char characters predefined 
generic look function definition 
lookup fmap lookup lookup char lookup inl lookup lookup inr lookup lookup lookup lookup sums look function selects appropriate map products composes look functions component keys :10.1.1.41.125
second argument look function element type indexed type defined 
note definition lookup relies fact second argument pair case nested finite map case 
generic look function generalization type specific look functions strings bushes seen 
generic function produce empty trie data type empty fmap empty empty char empty empty empty empty empty empty value type 
empty function serves simple example function constructs values generic way 
generic pattern matching pattern matching problem exact patterns informally specified follows pattern text find occurrences pattern text 
pattern text may lists may trees section specifies generic pattern matching program data types specified fixed points pattern functors 
specification inefficient program transformed efficient program 
efficient program generalization knuth morris pratt algorithm lists arbitrary data types 
pattern value type extended variables 
example data type bush extended constructor variables follows data var bush var int var leaf char var fork var bush var bush 
general want extend data type fixed point functor fix case variables 
perform extension functor directly parametrize functor question data var int val 
definition fix extension fix variable case interested 
particular easily define isomorphisms confirm fix bushf equivalent previously defined type var bush 
establish want store patterns extended data types define abbreviation type pattern fix 
construct specification pattern matching steps firstly define generic function match matches pattern complete value 
particular look occurrences pattern substructures value secondly systematically compute substructures value generic function suffixes 
match suffixes combined function pattern match looks pattern value 
turns need type indexed type store results suffixes pattern match 
start function match matches pattern value 
pattern matches value variable top level constructor value children match pairwise 
bush example match bush bush var bush bool match bush var true match bush leaf var leaf match bush fork var fork match bush match bush match bush false 
general case function zipwith match children constructor pairwise match fix pattern bool match var true match val case match false just zipwith generalizations list processing functions defined haskell prelude 
bushf function zipwith defined follows zipwith bushf 
bushf bushf bushf zipwith bushf just zipwith bushf just zipwith bushf 
course zipwith defined generically types kind zipwith 
zipwith id just zipwith just zipwith char just zipwith inl inl zipwith return inl zipwith inl inr zipwith inr inl zipwith inr inr zipwith return inr zipwith zipwith zipwith return 
bushf function defined follows bushf bushf bool bool bushf true bushf generic definition bool bool id true char true inl inr having defined match need define suffixes computes suffixes data structure generically 
lists suffix tail list 
example string suffix string 
generalize concept suffixes way set patterns generic patternmatching problem require finding suffix subset patterns matching sense match suffix 
compute suffixes value data type 
lists suffixes list represented list tails computed tails standard haskell function defined follows tails tails tails xs tails xs 
value arbitrary data type construct value new data type labelled data type store suffixes 
labelled data type extension data type store information internal nodes value 
data type labelled labels data type pattern functor labelled labelled fix label 
generic abstraction see section type level 
idea generic abstractions functions 
type indexed data type label adds label type constructor data type 
definition fact haskell data type viewed sum constructor applications fields constructor form product 
label traverse sum structure add label type reach constructor 
recursive calls constructor case product fields traversed case needed 
want label data type label recursively 
compute fixed point label labelled 
label label label label label type indexed function suffixes defined labels value data type subtree rooted node 
uses helper function add adds label value type returning value type label type indexed type label omit case add function inspects sum structure constructors data type 
add label add inl inl add add inr inr add add function suffixes defined recursive function adds subtrees rooted level tree 
adds argument tree top level applies suffixes children means function map 
generalization function tails arbitrary data types 
suffixes fix labelled fix suffixes add map suffixes 
specify generic pattern matching program 
suffix compute set patterns matches suffix 
pattern match pattern fix labelled pattern pattern match pats map labelled filter match pats suffixes data type labelled introduced section applications instance generic maximum segment sum problem requires finding subtree tree maximum sum :10.1.1.41.125:10.1.1.46.223:10.1.1.46.223:10.1.1.46.223
examples translations haskell semantics type indexed data types means specialization 
section gives examples formal rules provided section 
illustrate main ideas translating digital search tree example haskell 
translation shows particular type indexed data types specialized generic haskell haskell code automatically generated generic haskell compiler 
example structured sections translation data types translation type indexed data types translation type indexed functions operate data types 
translating data types general type indexed function translated functions user defined data type 
instances slightly different isomorphic data type types 
call isomorphic type generic representation type data type 
applying transformation concepts usually built haskell data statement data type having multiple constructors variable number fields constructor replaced just type abstraction type application basic type constructors 
implies course values user defined data types translated generic representation types 
example type nat natural numbers defined data nat zero succ nat translated type nat appears conversion functions 
type nat nat nat nat nat nat zero inl nat succ inr nat nat nat nat inl zero nat inr succ conversion functions nat nat transform top level structure natural number recursive 
furthermore mapping data types generic representation types translates ary products ary sums binary products binary sums 
revealed looking complex data type instance data tree empty node tree tree constructor node takes arguments 
generic representation type tree type tree tree tree conversion functions tree tree tree tree empty inl tree node inr tree tree tree tree inl empty tree inr node convenience pair conversion functions data iso iso iso nat iso nat nat iso nat iso nat nat iso tree iso tree tree iso tree iso tree tree 
conversion functions affect top level structure data type 
recursive data types generic representation type contains original data type 
isomorphisms translation data types type indexed functions move structural view original data type needed 
function recursive operates recursive data type conversion functions applied recursively 
translating type indexed data types type indexed data type translated haskell type case definition 
translation proceeds similar fashion hinze types values 
example product case takes argument types returns type product 
recall type indexed data type fmap defined fmap fmap char fmap fmap fmap fmap fmap fmap 
equations translated newtype fmap unit fmap unit newtype fmap char fmap char newtype fmap fma fmb fmap fma fmb newtype fmap product fma fmb fmap product fma fmb 
constructor names generated automatically 
implies value type indexed data type constructed means generic function 
type indexed data type viewed type 
data type want trie generate suitable instance fmap type fmap nat fmap fmap unit fmap nat newtype fmap nat fmap nat nat fmap nat note newtype fmap nat possible define recursive types haskell :10.1.1.41.125
types fmap nat fmap nat easily converted means pair isomorphisms iso fmap nat iso fmap nat fmap nat iso fmap nat iso nat fmap nat 
translating type indexed functions type indexed data types translation type indexed function takes type indexed data type argument generalization translation ordinary functions 
translation consists parts translation type indexed function specialization data type type indexed function conversion function 
type indexed function translated generating function type signature case definition 
type indices kind char generate types instances type generic function 
occurrences type index replaced instance type occurrences type indexed data types replaced translation type indexed data type type index 
example generic function lookup type lookup fmap instances obtained replacing char replacing fmap fmap unit fmap char respectively 
function lookup user supplied equations lookup lookup char translated lookup unit fmap unit lookup unit fmap unit lookup char char fmap char lookup char fmap char note wrap trie constructors second argument function 
type indices kind generate types take functions arguments corresponding instances generic function arguments return function combined type see hinze 
example lines lookup inl lookup lookup inr lookup lookup lookup lookup translated functions lookup fma fmb 
fma fmb fmap fma fmb lookup lua lub inl fmap fma fmb lua fma lookup lua lub inr fmap fma fmb lub fmb lookup product fma fmb 
fma fmb fmap product fma fmb lookup product lua lub fmap product lua lub translation involves replacing recursive invocations lookup lookup function arguments lua lub 
generate specialization type indexed function data type 
example nat lookup nat nat fmap nat lookup nat conv lookup nat lookup lookup unit lookup nat 
expression lookup lookup unit lookup nat generated directly type nat defined nat type constants replaced corresponding case specialization lookup function type application translated value application 
unfortunately expression type require lookup nat type type signature type nat fmap nat type isomorphic type need nat isomorphic nat fmap nat isomorphic conversion function conv lookup nat witnesses isomorphism conv lookup nat nat fmap nat nat fmap nat conv lookup nat lu fmt lu iso nat iso fmap nat fmt 
note functions iso nat fmap nat right hand side definition conv lookup nat 
values type nat fmap nat built result function 
look instance empty nat different situation 
empty nat fmap nat empty nat conv empty nat empty empty unit empty nat conv empty nat fmap nat fmap nat conv empty nat iso fmap nat generally specialization generic function conversion function generated uses relevant isomorphism pairs appropriate positions dictated generic representation type type want obtain instance 
section shows done systematic way 
implementing fmap type classes alternatively multi parameter type classes functional dependencies implement type indexed data type fmap haskell 
example 
type classes recursive invocations generic functions passed explicit type arguments lua lub definition lookup lookup product 
remain implicit class context task haskell compiler pass implicit contexts necessary 
explicit style introduced section rest 
specializing type indexed types values section gives formal semantics type indexed data types means specialization 
examples translation previous section 
specialization concrete data type instances removes type class fmap fma fma lookup fma instance fmap lookup fm fm data fmap fma fmb fmap fma fmb instance fmap fma fmap fmb fmap fmap fma fmb lookup inl fmap fma fmb lookup fma lookup inr fmap fma fmb lookup fmb data fmap product fma fmb fmap product fma fmb instance fmap fma fmap fmb fmap fmap product fma fmb lookup fmap product fma lookup lookup fma fig :10.1.1.41.125

implementing fmap haskell directly 
arguments type indexed data types functions 
words data types functions run time cost type arguments removed compile time 
specialization seen partial evaluation type indexed functions type index static argument 
specialization obtained lifting semantic description type indexed functions hinze level data types :10.1.1.41.125
type indexed data types type indexed functions take types arguments return types functions respectively 
formal description type indexed data types functions semantics extension polymorphic lambda calculus described section 
section briefly discusses form type indexed definitions 
description specialization divided parts section deals specialization type indexed data types section deals specialization type indexed functions involve type indexed data types 
section shows gap formal type language haskell data types bridged section summarizes 
polymorphic lambda calculus section briefly introduces kinds types type schemes terms 
kind terms formed kind kind types function kind 
distinguish type terms type schemes language type terms comprises types may appear type indices language type schemes comprises constructs required translation generic definitions polymorphic types 
type terms built type constants type variables type application type abstraction 
type type constant type variable type abstraction type application typographic simplicity omit kind annotation especially abbreviate nested abstractions 
am 
am order able model haskell data types set type constants include types char known constructors program 
furthermore include family fixed point operators indexed kind fixt examples omit kind annotation fixt 
may additionally add function space constructor universal quantifiers set type constants see section example 
type schemes formed scheme type term functional type polymorphic type 
terms formed term constant variable abstraction application universal abstraction universal application 
denotes universal abstraction forming polymorphic value denotes universal application instantiating polymorphic value 
syntax value abstraction value variable universal abstraction type variable 
assume set value constants includes polymorphic fixed point operator fix 
suitable functions type constants inl inr case outl outr 
improve readability usually omit type argument fix 
omit standard typing rules polymorphic lambda calculus 
form type indexed definitions type indexed definitions section implicitly define catamorphism language types 
specialization catamorphisms explicit 
section describes different views definitions 
inductive definitions type indexed functions data types section take form catamorphism cata cata cata char cata cata cata cata cata cata cata cata cata cata 
equations implicitly define family functions cata cata cata sequel assume type indexed functions data types explicitly defined catamorphism 
example digital search trees fmap fmap fmap inductive definitions definition label argument types right hand sides 
functions called paramorphisms characterized para para para char para char para para para para para para para para para para para :10.1.1.46.223
fortunately paramorphism transformed catamorphism tupling identity 
likewise mutually recursive definitions transformed simple catamorphisms tupling 
section describes specialize type indexed data types type indices appear set type constants char 
type indices id char lifted versions 
type indexed data types type indices specialized 
specialization type indexed data types higher order type indices proceeds fashion section 
essentially process lifted higher order type indices 
details lifting process see hinze section :10.1.1.41.125:10.1.1.41.1824
specializing type indexed data types amazingly process specialization type indexed functions type indexed data types phrased interpretation simply typed lambda calculus 
interpretation constants char obtained definition type indexed data type catamorphism 
remaining constructs interpreted generically type application interpreted type application albeit different domain abstraction abstraction fixed points fixed points 
thing generalize type type indexed data type 
previous sections type indexed data types fixed kind example fmap 
type application interpreted application fmap list fmap list fmap list kind extend domain fmap giving kind indexed kind way fmap list 
generalizing example type indexed data type possesses kind indexed kind form data :10.1.1.130.789
type kinds 
note definition data indicated box complete definition kind indexed kind 
definition data functional kinds dictated specialization process 
type application interpreted type application kind type functional kind functional 
example kind type indexed data type fmap type kind fmap 
noted process specialization phrased interpretation simply typed lambda calculus 
interpretation constants char obtained definition type indexed data type catamorphism interpretation application abstraction fixed points environment model type indexed data type 
environment model applicative structure app const domain structure app mapping interprets functions const maps constants domain structure 
order qualify environment model applicative structure extensional satisfy called combinatory model condition 
precise definitions concepts mitchell 
arbitrary type indexed data type applicative structure type app const 
domain applicative structure kind equivalence class set types kind appropriate set equations type terms equality fixt fixt kinds type constructors kind application equivalence classes types denoted equivalence class application types 
definition constants obtained definition catamorphism 
verified applicative structure defined environment model 
remains specify interpretation fixed point operators type indexed data types const fixt 
specializing type indexed values type indexed value possesses kind indexed type poly data 
data poly general form poly data data poly data 
xn data polya data 
xn data data 
data polya 

xn 
note equation poly complete definition kind indexed type 
definition poly functional kinds dictated specialization process 
presence type indexed data types slightly complicates type type indexed value 
hinze poly takes arguments kind poly takes possibly different type arguments obtained type indexed data type arguments 
example type look function idt lookup fmk fmk id identity function kinds 
definition generic look function obtain equations lookup lookup idt fmap lookup fmk fmk lookup fma lookup fmb lookup case inl lookup inr lookup lookup fma fmb kl kr fmk case fmb kl fmk just fmk kr fmk fma fmk fmk 
just type indexed data types type indexed values type indexed data types specialized means interpretation simply typed lambda calculus 
environment model specialization somewhat involved section 
domain environment model dependent product type component equivalence class terms type poly 
dn depends components equivalence classes type schemes 
dn kind 
note application operator applies term component argument type term components second argument 
scheme data 
dn scheme term poly dn app 
rn 
sn 
rn sn 
sn const data 
data poly 
interpretation fixed points different type indexed values const fixt fix data 
poly fixt poly fixt poly fixt 
fn poly poly 
fn fix poly fix data 
fn 
conversion functions seen example section interpret type indexed functions data types haskell data types directly slightly different isomorphic types 
furthermore haskell allow recursive type synonyms introduce newtype specialisation type indexed data type creating different isomorphic type interested 
consequence generate conversion functions mediate isomorphic types 
conversion functions easily generated type indexed values data types stored pairs values type iso 
difficult task plug right positions 
problem solved lifting conversion functions type specialized generic function 
generic program section function displayed omit type arguments function idt idt iso idt idt iso id id iso id id iso ab case ab inl inl inr inr ab case ab inl inl inr inr iso iso ab ab ab ab iso iso id id iso id id fig :10.1.1.41.125:10.1.1.41.125

lifting isomorphisms generic function 
composition identity functions 
consider generic function poly poly data 
data denote iso tt idt iso data tt 
conversion function derived conv poly poly iso data 
isodata 
example conversion function specialization lookup nat conv lookup nat lookup iso nat iso fmap nat extensionally function section 
note definition include case quantifier lookup polymorphic type 
specific case polymorphic type indices easily handled see 
details exactly type indexed values omitted :10.1.1.41.125
summary generic haskell program including type indexed types generic haskell compiler 
data type corresponding generic representation type generated pair isomorphisms 
type indexed type translated series newtype statements case 
analogously case type indexed function translated ordinary function definition 
call generic function replaced call appropriate specialization 
sufficient specialize generic functions type constants 
assign semantics generic functions interpretation simply typed lambda calculus calls generic functions type argument complex type term simplified 
instance expression lookup list char simplified lookup list lookup char specializations lookup list char required 
generic functions involve type indexed types specializations needed 
observation holds type indexed types specializations type constants suffice 
obvious additional code size translated program order number generic functions times number data types program 
careful analysis calls appear program reduce number specializations generated 
advanced example zipper section shows define called zipper arbitrary data type 
complex example demonstrating full power type indexed data structure number type indexed functions working 
zipper data structure represent tree subtree focus attention focus may move left right tree 
zipper tools user interactively manipulates trees instance editors structured documents proofs programs 
important note focus zipper may move recursive components 
consider example data type tree data tree empty node tree tree 
left subtree node constructor current focus moving right means moving right tree label 
implies recursive positions trees play important le definition generic zipper data structure 
obtain access recursive positions explicit fixed points data type definitions 
zipper data structure defined induction called pattern functor data type 
tools zipper allow user repeatedly apply navigation edit commands update focus accordingly 
section define type indexed data type locations consist subtree focus context define navigation functions locations 
basic idea zipper pointer reversal 
follow pointer subterm pointer reversed point subterm parent go 
location pair consisting current subterm pointer parent 
upward pointer corresponds context subterm 
represented follows 
constructor recursive subcomponents introduce context constructors 
km 
consider location 
tm 
go left context 
tm old context represent combined context simply plug hole obtain 
tm 
new location 
tm 
picture illustrates idea filled circle marks current cursor position :10.1.1.41.125
tm locations tm left right tm location subtree context encodes path top original tree selected subtree 
type indexed data type loc returns type locations argument pattern functor 
loc loc fix context fix context context fix ctx data lifted version 
type loc defined terms context constructs context parameterized original tree type 
context value empty represented type path root tree 
path constructed means argument type type indexed data type ctx 
type indexed data type ctx defined induction pattern functor original data type 
seen derivative calculus pattern functor :10.1.1.41.125
derivative denoted const void follows definition ctx need access type arguments right hand side definition 
ctx ctx id ctx void ctx char void ctx ctx ctx ctx ctx ctx definition understood follows 
possible descend constant constant cases contribute result type denoted empty type void type values 
id case denotes recursive component possible descend 
may occur context 
descending value sum type follows structure input value 
ways descend product descending left adding contents right node context descending right adding contents left node context 
example natural numbers pattern functor id trees type bush pattern functor bushf represented char id id obtain context id fix context char id id fix data void data void 
note context natural number isomorphic natural number context context bush applied data type bush isomorphic type context bush introduced section 
mcbride defines type indexed zipper data type :10.1.1.41.125:10.1.1.22.8611
zipper slightly deviates huet zipper navigation functions mcbride zipper constant time anymore 
observation context data type derivative calculus due mcbride 
navigation functions define type indexed functions type indexed data types loc context ctx navigating tree 
functions act locations 
basic functions zipper 
function 
function type indexed function moves leftmost recursive child current node child exists 
current node leaf node returns location unchanged 
loc loc instantiation data type bush section 
function satisfies property function goes tree 
going tree identity function locations possible go 
moves leftmost recursive child current node inverse equality id hold general 
exist natural number right function right goes right tree 
properties completely specify function 
properties satisfy selected subtree leftmost tree child selected subtree context context extended leftmost tree child function defined follows 
case just find leftmost recursive child pattern match pattern functor find occurrence id helper function type indexed function possibly returns leftmost recursive child node context value type ctx selected child 
function turns context value type context inserting right non top component sum means applying fixed point constructor 
ctx id return char inl cx return inl cx inr cy return inr cy cx return inl cx cy return inr cy 
return obtained monad operator standard monadic plus called mplus haskell just just function returns value context leftmost id position 
product case tries left component fails tries right component 
definitions functions right left simple definition defined pattern matching context tree 
just define functions right leave function left exercise 
function 
function moves parent current node current node top node 
loc loc case ft insert extract return ft 
remember denotes empty top context 
navigation function uses helper functions insert extract 
returns context parent current node 
note element type ctx component easy inductive argument marks context parent current node 
generic function extract extracts context 
extract ctx extract id return extract extract char extract inl cx extract cx extract inr cy extract cy extract inl cx extract cx extract inr cy extract cy 
note extract polymorphic function insert takes context tree inserts tree current focus context effectively turning context tree 
insert ctx insert id return insert insert char insert inl cx insert cx return inl insert inr cy insert cy return inr insert inl cx insert cx return insert inr cy insert cy return 
note extraction insertion happening identity case id cases pass results 
id locations possible go expect similar equalities functions extract insert 
computation ft extract ft insert return ft ft returns true locations possible go 
function right 
function right moves focus right sibling tree exists 
context moved accordingly 
instance right data type bush section 
function right satisfies property right left right going right tree left identity function locations possible go right 
course dual equality holds locations possible go left 
furthermore selected subtree right sibling right selected subtree context right context context replaced selected subtree subtree right context replaced context function right defined pattern matching context 
impossible go right top tree 
try find right sibling current focus 
right loc loc right case case just helper function type indexed function returns location recursive value right selected value focus 
just exists function left left right id locations possible go right exists function previous previous return returns true locations possible go right 
define function omit definition function previous 
ctx ctx id char inl cx cx cx return inl cx inr cy cy cy return inr cy inl cx cx cx return inl cx extract cx insert cx cy return inr cy inr cy cy cy return inr cy 
lines definition show impossible go right identity constant context 
context argument value sum select element appropriate component sum 
product case interesting 
context right component pair returns value context properly combined left component tuple 
hand context left component pair value may left component context may right component value 
value left component returned line definition product case 
extracts context context parent left context cx inserts value context cx giving tree value selects component right component pair extracted context new context 
new context obtained combined context selected tree 
shown define type indexed data types examples type indexed data types digital search trees generic patternmatching labelled data type zipper 
furthermore shown specialize type indexed data types type indexed functions take values type indexed data types arguments 
treatment generalizes specialization type indexed functions hinze implementation generic haskell generic programming extension functional language haskell see www generic haskell 
org 
technical overview compiler de wit thesis :10.1.1.41.1824
current release generic haskell contains experimental implementation type indexed data types 
syntax type indexed types current generic haskell compiler differs syntax places 
tutorial hinze jeuring explains syntax implementation 
type indexed data type defined similar way type indexed function 
difference type type indexed data type kind type 
note type indexed data type may type constructor need necessarily type kind 
instance label indexed types kind yields types kind 
approach taken powerful sets mutually recursive type indexed data types 
uses mutually recursive type indexed data types specify data types holes generic editor 

due dave clarke ralf mmel doaitse swierstra anonymous referees comments previous versions 
jan de wit suggested improvement labelling functions 
peyton jones editor hughes editor augustsson barton boutel burton fraser fasel hammond hinze hudak johnsson jones launchbury meijer peterson reid runciman wadler haskell non strict purely functional language available www haskell org definition feb :10.1.1.41.125:10.1.1.46.223
backhouse jansson jeuring meertens generic programming swierstra oliveira eds advanced functional programming vol :10.1.1.41.1824
lncs springer verlag pp :10.1.1.41.125

hinze generalizing generalized tries journal functional programming :10.1.1.41.125:10.1.1.41.125:10.1.1.41.125
url citeseer nj nec com hinze generalizing html jeuring polytypic pattern matching conference record fpca sigplan sigarch wg conference functional programming languages computer architecture acm press pp 
:10.1.1.130.789
jansson jeuring functional pearl polytypic unification journal functional programming :10.1.1.41.125:10.1.1.41.125
claessen typed logical variables haskell proceedings haskell workshop :10.1.1.41.125
jansson jeuring framework polytypic programming terms application rewriting jeuring ed workshop generic programming ponte de lima portugal july pp :10.1.1.41.125:10.1.1.41.125
utrecht technical report uu cs :10.1.1.41.125
framework developing generic xml tools master thesis department information computing sciences utrecht university :10.1.1.41.125
hinze jeuring type indexed data types proceedings th mathematics program construction conference mpc vol :10.1.1.41.125
lncs pp :10.1.1.41.125
:10.1.1.41.125
bird de moor hoogendijk generic functional programming types relations journal functional programming :10.1.1.41.125:10.1.1.46.223:10.1.1.46.223:10.1.1.46.223
huet zipper journal functional programming :10.1.1.41.125:10.1.1.46.223
huet linear contexts sharing functor techniques symbolic computation ed years automating mathematics kluwer :10.1.1.41.125:10.1.1.41.1824:10.1.1.46.223
chakravarty keller types nested data parallel programming proceedings icfp international conference functional programming acm press pp :10.1.1.41.125:10.1.1.46.223
:10.1.1.41.125
harper morrisett compiling polymorphism intensional type analysis nd symposium principles programming languages popl pp :10.1.1.46.223
:10.1.1.41.125
gibbons polytypic downwards accumulations proceedings mathematics program construction vol :10.1.1.46.223
lncs springer verlag pp 
:10.1.1.41.125:10.1.1.41.125
genetic algorithms haskell polytypic programming teborg university gothenburg sweden available polytypic programming www page :10.1.1.41.125:10.1.1.46.223
mmel format evolution mayr eds proc :10.1.1.41.125:10.1.1.46.223
th international conference reverse engineering information systems vol :10.1.1.41.125:10.1.1.41.125
books pp :10.1.1.41.125

malcolm data structures program transformation science computer programming :10.1.1.41.125:10.1.1.41.125:10.1.1.41.125:10.1.1.46.223
meertens paramorphisms formal aspects computing :10.1.1.46.223
fokkinga law order algorithmics ph thesis university twente dept inf enschede netherlands :10.1.1.41.125
jansson jeuring polyp polytypic programming language extension conference record popl th acm sigplan sigact symposium principles programming languages acm press pp :10.1.1.41.125:10.1.1.130.789
:10.1.1.41.125:10.1.1.41.125
dubois weis extensional polymorphism nd symposium principles programming languages popl pp :10.1.1.41.1824

jay bell moggi functorial ml journal functional programming :10.1.1.41.125:10.1.1.130.789
yang encoding types ml languages proceedings icfp international conference functional programming acm press pp :10.1.1.130.789:10.1.1.22.8611
:10.1.1.41.125
url citeseer nj nec com encoding html crary weirich morrisett intensional polymorphism type erasure semantics proceedings icfp international conference functional programming acm press pp 
:10.1.1.41.125
crary weirich flexible type analysis proceedings icfp international conference functional programming acm press pp 
:10.1.1.130.789
url citeseer nj nec com crary flexible html trifonov saha shao fully reflexive intensional type analysis proceedings icfp international conference functional programming acm press pp :10.1.1.41.125:10.1.1.41.125:10.1.1.41.125

url citeseer nj nec com saha fully html weirich encoding intensional type analysis european symposium programming vol :10.1.1.41.125
lncs springer verlag pp :10.1.1.41.125
:10.1.1.41.125
url link springer de link service series tocs htm weirich higher order intensional type analysis le tayer ed proceedings th european symposium programming esop vol :10.1.1.41.125
lecture notes computer science pp :10.1.1.41.125

hinze new approach generic functional programming conference record popl th acm sigplan sigact symposium principles programming languages acm press pp :10.1.1.41.125:10.1.1.41.125:10.1.1.41.125

url citeseer nj nec com hinze new html hinze polytypic values possess types backhouse oliveira eds mathematics program construction vol 
lncs springer verlag pp :10.1.1.41.125:10.1.1.41.125
:10.1.1.41.125:10.1.1.41.125
mccracken investigation programming language polymorphic type structure ph thesis syracuse university june :10.1.1.41.125:10.1.1.41.1824
meijer fokkinga paterson functional programming bananas lenses envelopes barbed wire hughes ed fpca functional programming languages computer architecture vol 
lncs springer verlag pp 
:10.1.1.130.789
clarke generic haskell specifically gibbons jeuring eds generic programming vol 
ifip kluwer academic publishers pp :10.1.1.41.125:10.1.1.130.789

knuth morris pratt fast pattern matching strings siam journal computing :10.1.1.41.125:10.1.1.41.125
jones type classes functional dependencies smolka ed proceedings th european symposium programming esop berlin germany vol :10.1.1.41.125
lncs springer verlag pp :10.1.1.41.125:10.1.1.41.125
:10.1.1.41.125:10.1.1.130.789
hinze generic programs proofs bonn university :10.1.1.41.125:10.1.1.41.125
mitchell foundations programming languages mit press 
hinze peyton jones derivable type classes hutton ed proceedings acm sigplan haskell workshop vol :10.1.1.41.125
electronic notes theoretical computer science elsevier science preliminary proceedings appeared university nottingham technical report :10.1.1.41.125
mcbride derivative regular type type hole contexts unpublished manuscript :10.1.1.41.125
altenkirch ghani mcbride derivatives containers typed lambda calculi applications tlca vol :10.1.1.41.125
lncs springer verlag pp :10.1.1.41.125:10.1.1.41.125:10.1.1.41.125
:10.1.1.41.125
de wit technical overview generic haskell master thesis department information computing sciences utrecht university :10.1.1.41.125:10.1.1.41.1824
hinze jeuring generic haskell applications appear :10.1.1.41.125
jansson www home page polytypic programming available www cs chalmers se poly :10.1.1.41.125

