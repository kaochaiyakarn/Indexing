alias types frederick smith david walker greg morrisett october linear type systems allow destructive operations object deallocation imperative updates functional data structures 
operations ability reuse memory different types essential low level typed languages 
traditional linear type systems restrictive low level code necessary exploit pointer aliasing 
new typed language allows functions specify shape store expect track flow pointers computation 
type system expressive represent pointer aliasing safely permit destructive operations 
linear type systems give programmers explicit control memory resources 
critical invariant linear type system linear value exactly 
single linear value dead system immediately reclaim space reuse store value 
single invariant enables compile time garbage collection imperative updates functional data structures limits linear values 
example twice expression fst snd linear type consequently deallocated early 
authors extended pure linear type systems allow greater flexibility 
wadler example introduced new form permits variable non linear value times albeit restricted fashion linear value 
similarly kobayashi replaced linear values pseudo linear values locally number times deallocated 
concurrent clean production quality lazy function language uses related notion called uniqueness types enable static garbage collection 
solutions focused high level user programming languages emphasized simple typing rules programmers understand typing rules admit effective material supported part afosr national science foundation 
eia 
opinions findings recommendations expressed publication authors reflect views agencies 
type inference techniques 
issues concern low level typed languages designed compiler intermediate languages secure mobile code platforms java virtual machine proof carrying code typed assembly language tal :10.1.1.24.6526
languages designed machine human consumption 
implementation strongly typed low level languages requires variety new type theoretic mechanisms 
particular experience tal revealed new challenges 
low level languages require destructive operations high level counterparts 
high level languages location stamped single type lifetime program 
failing maintain invariant resulted unsound type systems witness interaction parametric polymorphism ml covariant arrays java 
low level languages aim expose resource constraints underlying machine invariant untenable 
instance machines contain limited number registers register stamped single type 
stack allocated objects disjoint lifetimes compilers naturally reuse stack space objects different types 
low level language exposing initialization simplest objects change type 
example pair type int int may created sequence instructions malloc type junk junk type int junk type int int type systems low level languages support values types change 

efficient natural low level code copies values 
fact job register allocator copy values stack registers intelligently 
pointer values copied objects point shared stack stack object copy register object sharing eliminated invalidating copies presumably pointer stack 
pointer live possible keep register rest lifetime 
example imagine current stack frame assume top stack contains pointer spill register 
untyped calculus spilling operation need copy pointer back stack register allocator easily remember pointer stored stack 
unfortunately type system forces invalidate copies perform extra copy 
pointer aliasing data sharing occur naturally data structures introduced compiler 
example compilers top stack pointer frame pointer point data structure 
compiling language pascal displays generalizes problem having arbitrary statically known number pointers data structure 
examples flexible type system allow aliasing ensure inconsistencies arise 
type systems low level languages represent sharing 
overview devised new type system capable tracking sharing data structures admits operations memory reuse different types object initialization deallocation 
formalizes type system provides theoretical foundation safely integrating operations depend pointer aliasing type systems include polymorphism higher order functions 
main new feature language collection aliasing constraints 
aliasing constraints describe shape store function uses specify store expects 
current store conform constraints specified type system ensures function called 
illustrate constraints concrete store consider example sp stack true sp pointer stack frame allocated heap done sml nj compiler instance 
frame contains pointer second object pointed register 
program model heap allocated object occupies particular memory location 
example stack frame occupy location second object occupy location order track flow pointers locations accurately reflect locations type system pointer location singleton type ptr 
singleton type contains exactly value pointer question 
property allows type system reason pointers fine grained way 
fact allows represent graph structure example store precisely sp ptr ls ls stack int bool ptr lo lo int represent picture formal syntax declaring program variable sp type ptr andr type ptr 
store described constraints int bool ptr int denotes memory block containing values types ptr lo constraints form reasonable starting point abstraction store 
precise useful general purpose programs 
consider example simple function deref retrieves integer cell 
immediate problems demand code call deref store shape described int 
deref location example problem easily solved adding location polymorphism 
exact name location usually unimportant need establish dependence pointer type constraint 
specify deref requires store int location variable specific location 
second constraint int specifies store exactly location may want dereference single integer sea heap allocated objects 
deref modify able away size shape rest store 
accomplish task store polymorphism 
appropriate constraint function deref int constraint variable may instantiated constraint 
third main feature constraint language capability distinguish linear constraints non linear constraints linear constraints come additional guarantee location left hand side constraint aliased location 
invariant maintained despite presence location polymorphism store polymorphism 
intuitively safely deallocate memory change types values stored 
key property system expressive traditional linear systems aliasing constraints may linear pointer values flow computation 
direct restriction copying reuse pointers 
example illustrates type system uses aliasing constraints singleton types track evolution store series instructions allocate initialize deallocate storage 
example instruction malloc allocates storage bound variable instruction binds 
trust malloc implemented returns fresh location instantiate 
free instruction deallocates storage 
deallocated storage type junk type system prevents space 
instructions constraints initially constraints 
malloc sp junk junk sp ptr 
sp int junk 
malloc int junk junk ptr 
sp int ptr junk 
int ptr int 
free int ptr junk 
free sp junk junk intuitively think sp stack pointer register holds alias object stack 
notice line initialization updates type memory location 
effect simultaneously updating type sp 
paths similarly affected freed instruction 
despite presence dangling pointer sp type system allow pointer 
singleton types accurately track pointers linear constraints model shape store type system represent aliasing simultaneously ensure safety presence destructive operations summary extended typed assembly language tal implementation features described 
quite straightforward augment existing type system basic mechanisms including polymorphism singleton types type constructor language 
popcorn optimizing compiler safe language generates code new tal type system uses alias tracking features type system 
formalizing type system context tal ideas terms familiar lambda calculus 
section describes core language including linear aliasing constraints 
section extend language non linear constraints 
nonlinear constraints admit destructive operations aliasing information contain useful 
particular code performs dynamic type test possible refine types aliases simultaneously 
explore application section 
section show compile simple imperative language displays language locations 
key feature translation stack explicitly allocated deallocated 
section section discuss related 
language locations section describes new type safe language locations syntax language appears 
values instructions programs program pair store list instructions 
store maps locations values 
normally values held store memory blocks memory location deallocated location point unusable value junk 
values include integer constants variables course pointers ptr 
main instructions manipulate memory blocks 
discussed instruction malloc allocates memory block size new location binds variable pointer ptr binds location variable concrete location 
allocation components new memory block uninitialized filled junk 
memory access instructions 
instruction substitutes ith component memory block pointed considered bound expression scope extends rest instruction sequence 
instruction stores ith component block pointed final memory management primitive free deallocates see www cs cornell edu latest software release 
locations locations constraints types int junk ptr value constructor program values junk ptr vn fix instructions malloc free vn halt stores vn programs language locations syntax storage pointed pointer ptr deallocation modeled updating store location maps junk 
example shows evaluation program allocate initialize deallocate pair integers empty store store instructions malloc allocate new location substitute ptr junk junk ptr initialize field junk ptr initialize field free ptr free storage junk sequence instructions ends halt instruction stops computation immediately function application vn 
order simplify language typing constructs functions return 
higher level language contains call return statements compiled language locations performing continuation passing style cps transformation 
possible define direct style language doing elegant 
choice force adopt awkward syntax allows functions return portions store 
cps style control flow transfers handled symmetrically calling continuation 
functions defined form fix 
functions recursive may appear 
context specifies pre condition satisfied function invoked 
type context binds set type variables occur free term collection aliasing constraints statically approximates portion store assigns types free variables 
call polymorphic function code instantiate type variables value malloc junk junk ptr free ptr junk vn ptr vi vi vn vn ptr vi vn vn cm vn xn cm fix xn dom ranges language locations operational semantics form 
forms treated values type application computational effect types constraints compile time checking erased executing program 
formally defines operational semantics 
notation cn xn denotes capture avoiding substitution cn variables xn type constructors kinds type constructors locations types aliasing constraints 
simplest types base types chosen integers int 
pointer singleton type ptr 
value type ptr ptr type ptr aliases 
memory blocks types describe contents 
collection constraints establishes connection pointers type ptr andthe contents memory blocks point 
main form constraint written models store single location containing value type 
collections constraints constructed primitive constraints join operator 
empty constraint denoted 
abbreviate 
static semantics store typing central invariant maintained type system current constraints faithful description current store write store typing invariant judgment intuitively location contains value type constraints meta variable denote concrete locations denote location variables denote 
specify location maps equivalent type 
formally vn vn distinct 
instruction typing 
judgment states instruction sequence formed 
related judgment ensures value formed type 
presentation typing rules instructions focuses rule maintains invariant 
invariant mind consider rule projection ptr pre condition ensures pointer 
second uses determine contents location pointed precisely requires equal store description 
store unchanged operation final pre condition requires rest instructions formed collection constraints examine rule assignment operation ptr value pointer location 
type contents block type time store changed remaining instructions checked appropriately modified constraint 
type system ensure new constraints correctly describe store 
type contents location type describes contents location update accurately 
avoid situation continues contain outdated type contents location 
task may appear trivial search occurrences constraint update mappings appropriately 
unfortunately presence location polymorphism approach fail 
suppose value stored location current constraints 
determine aliases final constraint set 
solution uses technique literature linear type systems 
linear type systems prevent duplication assumptions disallowing uses contraction rule 
analogous restriction definition constraint equality join operator associative commutative idempotent 
ensuring linear constraints duplicated prove example aliases 
equality rules unsurprising 
empty constraint collection identity syntactic alpha conversion bound variables modulo equality constraints 
int bool bool int int bool int int bool equality rules prove update store value new type store typing invariant preserved lemma store update denotes store extended mapping provided appear left hand side elements 
function typing rule function application vn rule expect 
general value form cn function polymorphic locations constraints type constructors cn instantiate polymorphic variables 
substituting cn polymorphic variables current constraints equal constraints expected function check guarantees duplication property preserved function calls 
see consider polymorphic function foo type context constraints int int fix foo ptr ptr cont int 
free constraints int ok ptr int free constraints cont return continue function deallocates arguments calling continuation contents easy check function type checks 
foo called state aliases run time error result second instruction executed location pointed deallocated 
fortunately type system guarantees foo called state 
suppose store currently contains single integer 
store described constraints int 
programmer attempts instantiate label function call foo ptr fail type check constraints int equal pre condition int int 
contains typing rules values instructions 
int junk junk ptr ptr vn vn xn fix xn xn junk junk ptr malloc ptr junk free ptr ptr vn vn halt language locations value instruction typing soundness typing rules enforce property typed programs enter stuck states 
state stuck reductions operational semantics apply halt theorem captures idea formally theorem soundness stuck state 
prove soundness syntactically style wright felleisen 
full proof appears appendix non linear constraints linear type systems contain class non linear values completely unrestricted fashion 
system similar admits non linear constraints written characterized axiom constraints previous section non linear constraints may duplicated 
sound deallocate memory described non linear constraints different types 
strictly fewer operations non linear constraints linear constraints natural subtyping relation extend subtyping relationship single constraints collections constraints rules reflexivity transitivity congruence 
example assume add type int int ptr ptr consider code instructions constraints initially malloc junk ptr int add int int int typing rules non linear constraints 
non linear constraints dynamic type tests data structures described non linear constraints deallocated store objects varying types take advantage sharing implied singleton pointer types 
specifically code weak constraints perform dynamic type test particular object simultaneously refine types aliases object 
ptr ptr vn vn language locations non linear constraints demonstrate application extend language discussed previous section simple form option type see 
options may null memory block operation associates name null instruction injects value location containing null memory block location option type typing rules ifnull annotation may indicates non linear constraint empty annotation indicates linear constraint 
ifnull construct tests option determine null 
assuming type ptr check branch constraint null second branch constraint appropriate non null variant 
imagine sp stack pointer contains integer option 
constraints ptr int sp ptr sp ptr ifnull halt null check constraints ptr int notice single null test refines type multiple aliases alias stack sp integer clause 
loads alias perform null check 
proven additional features language sound 
compiling displays pascal distinctive features supports lexical scoping nested functions treats functions second class citizens functions returned stored data structures 
syntax operational semantics static semantics types null values null instructions ifnull null ptr null ifnull ptr null vn ifnull ptr vn null null null ptr ptr null ptr ptr null ifnull language locations extensions option types types int int int int declarations functions xn fm dk values instructions vn return simple lexically scoped imperative language sil feature permits display look variables residing outer scopes 
description aho sethi ullman display heap allocated array pointers dynamically closest enclosing activation record stack frame 
function lexical depth accesses stack frame pointed display 
display maintained function entry exit 
entry function depth saves contents display stack overwrites display pointer stack frame 
exit function restores display 
possible track aliases created displays precisely alias types 
demonstrate fact show compile simple imperative language making displays language locations way heap allocated stack frames safely explicitly deallocated 
order highlight issues regarding displays sil kept extremely simple 
shows syntax 
sil arguments results integer type 
furthermore declarations may mutually recursive 
design sil interesting feature supports lexical scoping nested functions 
typing rules dynamic semantics language easy define omitted 
remainder section show sil terms compiled language locations 
translation assumes terms renamed variable names distinct program text available 
order simplify presentation extend language locations new binding construct operational effect substituting value obvious type checking rule 
caveats believe translation type preserving semantics preserving formal proof 
table shows naming conventions shows snapshot translated program execution 
display bound variable xd current stack frame xf 
translation denote maximum lexical depth program 
shown display array elements 
translation broken type value declaration function instruction sub translations 
continuing define notation 
definition notation variable function variable integer xf name description location current stack frame xf ptr sp location previous stack frame sv location saved display slot parent lexical depth sp sp sv sv parent lexical depth rest store location display xd ptr xcont continuation ptr sp ptr sv arguments locals table variable naming conventions ptr ptr snapshot stack display execution translated program 
xd 
syntactic shorthand xd 
variables compound subscripts sp corresponds sp sp 
depth lexical depth defined program 

offset offset stack frame 

locals number local variable declarations body important part translation type translation encodes dynamic invariants shows language locations able track sharing aliases 
definition type translation helper functions andm denote integers 

sp sp sv translated typing context function lexical depth variables sp sv needed give types enclosing stack frames mention locations 
variables give type display 

ptr sp junk int intn junk junk argument function containing local variables entry 

types correspond types enclosing stack frames 
represents constraint ties types stack frames locations 
types needed variables outer scope reside stack frames accessible 

dm ptr ptr dm constraint giving type display program maximum lexical depth type translation depends aspects program context globally maximum lexical scope types stack frames lexically enclosing functions number local variables contained function type translating definition type translation int int int intn int dm ptr ptr cont cont junk dm ptr int translated types precise capture invariants translation 
type current stack frame function entry ptr sp junk int int junk junk indicating caller allocate callee stack frame possible functions statically known 
furthermore caller put arguments positions install pointer position 
continuation demands junk forcing callee free stack frame wishes return 
type display unchanged cont continuation called set stack frames display contents frames may changed 
typing error callee forget restore display returning 
remaining translations obvious ones constraints placed type translation intended semantics 
value translation produces sequence instructions value 
formally defined instruction sequences halt function call 
purpose translation allow sequences arbitrarily 
notation denote empty sequence instructions 
definition value translation fresh variables 
xd depth offset declaration translation similar value translation variables 
difference initializing variable current stack frame access variable display 
definition declaration translation xf offset stated earlier function translation needs bind name nested function body parent 
keeping language locations simple include binding form 
introduce convenience 
definition function translation denote fresh variables 
xn fm dk ptr sp ptr sv int intn cont type translation 
fix dm xf ptr xd ptr xcont cont 
save display slot xd xf xd xf translate nested functions fm initialize local variables dk translate body instruction translation straightforward lexical depth greater lexical depth function instruction occurs see function translation 
bound see definition 
represented similar problems occur sv sp problems lead special casing translation function application depending call function outer scope immediate child 
definition instruction translation instruction translated follows 
denote fresh variables 


xd depth offset 
depth locals vi vm allocate new stack frame malloc initialize parameters initialize new frame back pointer xf call xd fix fcont junk dm xd ptr int 
xf xd xd depth offset definitions vary depending sp sv sp sp sv 

related return load return value restore saved display slot xf xd free xf call continuation xcont xd type system constructed standard type theoretic building blocks including linear singleton types relatively straightforward implement ideas modern type directed compiler 
typed assembly language tal implementation contained required constructors 
particular singleton types enable array bounds check elimination style xi pfenning run time type analysis may soon facilitate static checking expressive security policies 
tal type directed compilers til flint rich kind structure adding location store polymorphism just involved adding base kinds 
ways new mechanisms simplify previous 
previous versions tal possessed separate mechanisms initializing data structures :10.1.1.12.4086
uninitialized heap allocated data structures stamped type 
hand stack slots overwritten values arbitrary types 
new system allows treat memory uniformly 
fact new language encode stack types similar described morrisett activation records allocated heap conventional call stack 
report shown new language compile simple imperative language way explicitly manages memory stack uses display 
believe encode exception handling mechanisms described morrisett 
development language inspired calculus capabilities cc 
cc provides alternative region type system developed tofte talpin 
safe region deallocation requires aliases cc tracks region aliases 
new language adapt cc techniques track object aliases object type information 
close connections research alias analyses 
aims facilitate program optimizations require aliasing information order correct 
optimizations necessarily harder check safety resulting program 
attempts determine programs written unsafe languages perform potentially unsafe operations 
goals closer application differ interested compiling safe languages producing low level code proven safe single pass program 
main result new analysis technique represent check results analysis particular represent aliasing low level compiler introduced data structures represent aliasing source level data 
discussed principle advantage techniques integrated smoothly efficiently polymorphic higher order type systems tal 
language locations flexible framework reasoning sharing destructive operations type safe manner 
date step area investigating number extensions 
instance functions destructively modify arguments may indifferent sort constraint require 
augmented type system polymorphism sort constraint linear non linear preserve sort constraint function calls 
bounded polymorphism provides expressive power allows linear constraints temporarily viewed non linear constraints recovering linear information 
working integrating recursive types type system 
recursive types allow capture regular repeating structure store 
think possible integrate collection features language unsure precise form take 
combined believe mechanisms provide safe rich reusable set memory abstractions 
alfred aho ravi sethi jeffrey ullman 
compilers principles techniques tools 
addison wesley 
andrew appel david macqueen 
standard ml new jersey 
martin wirsing editor third international symposium programming language implementation logic programming pages new york august 
springer verlag 
volume lecture notes computer science 
erik barendsen smetsers 
conventional uniqueness typing graph rewrite systems extended 
thirteenth conference foundations software technology theoretical computer science pages bombay 
ed springer verlag lncs 
karl crary david walker greg morrisett 
typed memory management calculus capabilities 
sixth acm symposium principles programming languages pages san antonio january 
karl crary stephanie weirich 
flexible type analysis 
acm international conference functional programming pages paris september 
alain deutsch 
interprocedural may alias analysis pointers limiting 
acm conference programming language design implementation pages orlando june 
dor michael rodeh mooly sagiv 
detecting memory errors static pointer analysis preliminary experience 
acm workshop program analysis software tools engineering paste montreal june 
david evans 
static detection dynamic memory errors 
acm conference programming language design implementation philadelphia may 
naoki kobayashi 
quasi linear types 
sixth acm symposium principles programming languages pages san antonio january 
tim lindholm frank yellin 
java virtual machine specification 
addison wesley 
greg morrisett karl crary neal glew david walker 
stack typed assembly language 
second international workshop types compilation pages kyoto march 
published xavier leroy atsushi ohori editors lecture notes computer science volume pages 
springer verlag 
greg morrisett david walker karl crary neal glew :10.1.1.24.6526
system typed assembly language 
acm transactions programming languages systems may 
george necula 
proof carrying code 
fourth acm symposium principles programming languages pages paris 
martin odersky philip wadler 
pizza java translating theory practice 
fourth acm symposium principles programming languages pages paris january 
plotkin 
call name call value lambda calculus 
theoretical computer science 
john reynolds 
definitional interpreters higher order programming languages 
conference record th national acm conference pages boston august 
sagiv reps wilhelm 
solving shape analysis problems languages destructive updating 
acm transactions programming languages systems january 
shao 
overview flint ml compiler 
workshop types compilation amsterdam june 
acm 
published boston college computer science dept technical report 
steensgaard 
points analysis linear time 
third acm symposium principles programming languages january 
tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
acm conference programming language design implementation pages philadelphia may 
mads tofte 
type inference polymorphic 
information computation november 
mads tofte jean pierre talpin 
region memory management 
information computation 
david turner philip wadler christian mossin 
type 
acm international conference functional programming computer architecture san diego ca june 
philip wadler 
linear types change world 
broy jones editors programming concepts methods sea israel april 
north holland 
ifip tc working conference 
david walker 
type system expressive security policies 
seventh acm symposium principles programming languages boston january 
appear 
wright 
simple imperative polymorphism 
lisp symbolic computation december 
andrew wright matthias felleisen 
syntactic approach type soundness 
information computation 
hongwei xi frank pfenning 
eliminating array bound checking dependent types 
acm conference programming language design implementation pages montreal june 
proof type soundness section states proves theorem soundness type system language 
syntactic proof technique popularized wright felleisen 
central lemmas required proof technique preservation states formed programs step formed programs progress states formed programs take step halted gracefully halt instruction 
order technique intermediate steps computation type check 
case type system defined body 
intermediate programs may fail type check defined relationship types null similarly instruction relate types locally correspondence lost type checking remaining instructions 
maintain information introduce subtyping relationship 
added rules type system strictly programs type check 
type soundness new type system implies type soundness original system 
new rules follow 
typing rules entirety appendix 
sub null null sub eq sub tuple sub trans sub notational conveniences appendix 
meta variable range constraint flags empty flag denotes linear constraint flag denotes non linear constraint 
meta variable range location variables constraint variables 
meta variable range locations constraints notation denote syntactic equality objects conversion bound variables 
exception store denotes syntactic equality alpha conversion bound variables re ordering elements store 
definitional equality preceded typing context notation denotes store extended mapping 
undefined appears domain rest appendix gives formal statement proof type soundness theorem 
definition stuck state state stuck halt exist state 
theorem soundness evaluation sequence stuck state 
proof prove soundness induction length evaluation sequence 
progress initial state stuck 
assume evaluation sequences length fori states 
suppose evaluation sequence length 
preservation states exists induction 
proofs preservation progress rely number supplementary lemmas 
aid reading proof broken lemmas various subsections 
subsection presents standard lemmas describing formedness substitution canonical forms 
second subsection establishes key properties constraint equality subtyping 
third section proves lemmas relate store constraints 
fourth section presents proofs preservation progress 
standard lemmas section begins number standard substitution lemmas various kinds variables 
case lemma states substitution preserves formedness 
proofs induction typing derivation question omitted 
lemma type substitution orc orc 





lemma substitution 


lemma substitution 


lemma substitution 

group lemmas describes series standard derived rules formedness object formedness object 
lemma 



proof parts proven simultaneous induction height typing derivations 
part proven induction typing derivation follows part 
lemma rng 
proof proof induction typing derivation values 
cases rules immediate follow directly induction hypothesis 
rules employ type substitution lemma lemma induction hypothesis 
lemma assuming formed types null proof induction subtyping derivation 
lemma types hold 

null 
proof proof proceeds induction height derivation 
lemma canonical forms proof ptr implies ptr junk implies junk null implies null implies vn implies fix cm xn implies null vn proof proceeds induction height typing derivation 
ptr rules sub generate form 
rule rule derivation inspection rule reveals ptr 
rule sub rule derivation know ptr inspection rules equality subtyping conclude ptr 
induction conclude ptr 
junk junk sub form 
case junk immediate 
case sub proceeds similarly argument ptr 
null null sub form 
case junk immediate 
case sub proceeds similarly argument ptr 
tuple sub form 
case tuple immediate 
case sub proceeds similarly argument ptr 
multiple rules generate types form fix sub 
case fix immediate 
case sub proceeds similarly argument ptr 
consider case rule rule similar induction fix cm xn result follows trivially 
particular fix cm rules form opt sub 
opt induction hypothesis vn giving desired result 
sub follows subtype null lemma value types ptr implies ptr junk implies junk null implies null exists vn implies exists vi fix cm implies xn substitution cm proof different value proof induction height typing values 
values ptr typing rules apply value sub rule 
height derivation rule result immediately 
height greater rule sub 
inspection equality subtyping rules reveals sub preserves shape type question 
induction result 
value fix xn cm rules fix sub appeared 
rule fix sub appeared argument case ptr applies 
rule rule appeared result follows induction 
values null rules apply 
consider case value null case similar 
base case null trivial 
rule sub null null induction know null inspection equality subtyping rules deduce shapes types preserved null lemma furthermore proof proof proceeds cases possibilities lemma 
types equal proof complete transitivity subtyping 
remaining cases option type null lemma null vn null lemma option type null 
proof complete 
option type equal lemma 
vn lemma tuple type option type 
option type argument previous case 
tuple types lemma common ancestor definition equality tuples properties constraints preservation relies aliasing constraints remaining faithful description store operations free malloc 
prove relationship maintained execution reason aliasing constraints related types change 
define notion substitution uniformly changes type associated location 
constraint primitive constraint replaced definition constraint defined follows 
definitions provide useful abstractions prove facts constraints 
id set types equal sup set supertypes 
appears types equal image words im 
set contains constraints generated replacing occurences set types definition id sup sets types defined follows 
id sup definition im set types defined follows 
im im im id im im im im definition set constraints defined follows 
lemmas specify properties interactions im ands 
lemma constraint type 
id im id 
sup im sup proof directions shown induction structure lemma locations constraints 
im im 

im exists type im 
proof part induction height equality derivation 
part induction height subtyping derivation 
lemma locations types constraints 



proof part induction height equality derivation 
part induction height subtyping derivation 
lemma locations types constraints ifc id sup 
proof induction structure non trivial case case rule sub imply lemma constraints 
id sup 
proof lemma im thereisa im assumption lemma part conclude im id conclude im sup result lemma part 
cardinality lemmas conclude occuring linear constraint occurs exactly left hand side constraint definition integer defined follows 
lemma constraints location 

proof part proven induction height derivation 
part proven part case sub eq similar induction argument 
lemma constraints 


proof parts proven induction height derivation 
cases trivial 
exception case rule sub trans part 
case facts 
lemma part know deduce cardinalities fact equal induction sub derivation conclude subsequently induction second sub derivation result 
relating stores constraints lemma proof induction height derivation assume final rule derivation base 
inspection rule see free variables hand assume rule sub final rule derivation induction lemma conclude lemma proves useful 
basically says derivation need application base application sub 
lemma cbase cbase derivable rule base cbase proof induction derivation transitivity subtyping constraints sub trans 
lemma exists 
proof induction typing derivation lemma dom 
proof proof induction derivation case base true definition 
case sub assume induction know 
fact congruence rules subtyping conclude completing proof 
lemma states simply values type type store way regardless value store 
lemma proof induction typing derivation lemma formally encapsulates central idea 
location store values different types 
need stamp location single type 
types store identical modification single location 
lemma update 
proof simplify presentation separate proof parts 
prove 
second prove equality syntactic equality 
facts imply result 
lemma constraint cbase cbase derivable rule base cbase 
parts 
lemma cbase 
rule sub obtain 

rule base applied conclude cbase definition base 
furthermore lemma 
note cbase cbase cbase 
inspection definition reveals fact equal 
apply lemma conclude 
facts means exactly occurence occurences 
lemma describes property store require progress proof location appears constraint appears store contains value appropriate type 
lemma formed store furthermore proof lemma cbase derived base cbase lemma im cbase 
inspection definition im constraint cbase inspection rule base occurence dom exist 
inspection rules subtyping conclude 
consequently rule sub result 
lemma store subtype proof represent represent lemma constraint cbase derived base cbase lemma im cbase 
inspection rule base occurs cbase im cbase id 
loss generality assume appears cbase constraint equal 
apply lemma conclude 
case proven parts 
part show cbase 
inthe second part show results rule sub conclude desired result definition 
proof cbase 
lemma cbase 
fact cbase syntactically equal cbase 
cbase 
definition show syntactically equal 
equalities cbase conclude cbase 
proof lemma part fact cbase id cbase 
cbase lemma sup 
definition fact rewritten sup definition sup conclude sup 
furthermore sup follows sup inspection definitions shows id 
facts allow apply lemma conclude 
inspection rule base conclude base base cbase prove base cbase rules cong sub 
transitivity base consequently derivation base base type appears base obviously reflexivity reason case obtain result preservation progress lemma preservation proof proof proceeds cases structure 
case begins stating operational rule shape 
states relevant parts typing derivation instruction td specialized particular case store std considered 
simplify presentation judgements form ptr ptr occur typing derivation td implicitly lemma conclude 
malloc malloc junk junk ptr td std junk junk ptr malloc show new store junk junk typed junk junk 
typing rules tuple junk conclude junk junk junk junk lemma know second need prove new instruction sequence formed 
td lemma substitution conclude junk junk ptr junk junk formed 
apply second substitution lemma lemma obtain final result similar case malloc 
ptr junk junk ptr vn ptr vn vi td ptr ptr ptr std resulting store initial store requirement trivially satisfied 
second requirement std subtyping condition td store typing rule sub conclude consequently lemma canonical forms vn vi td fact apply lemma substitution obtain required result vi ptr vres vi vi vn 
vn ptr std vres vn possible typing derivations term 
split case parts 
td ptr ptr ptr prove vres lemma exists type vn 
lemma form vj typing judgement td fact conclude inspection rule tuple vres std conclude vres second obligation prove follows immediately td 
res 
td ptr ptr res ptr proof obligation show vres res 
std equality td rules sub sub eq prove vn 
lemma tuple vres res 
apply lemma conclude vres res 
second proof obligation res follows directly td 
free ptr similar assignment 
possible typing rules 
coalesce rule shape null corresponding corresponding 
td ptr std judgement ptr conclude exists ptr lemma lemma 
facts proceed prove obligation 
std td rule sub eq recall null rules sub cong sub conclude sub trans second proof obligation follows directly td ifnull ptr operational rules may applied ifnull ifnull 
show preservation branch taken 
alternative similar 
null ifnull ptr null constraints appear typing judgement may linear constraints nonlinear constraints 
case linear constraints follows argument similar arguments rules free 
assume constraints judgement non linear constraints td ptr ptr null ifnull ptr std null obligation prove null null td std rules sub sub eq conclude null lemma conclude null null second obligation show null immediate typing derivation td 
vn vn cm vn xn cm andv fix xn td vn std vn proof obligation show trivial std typing derivation states rule sub 
second proof obligation show function body type checks cm vn xn lemma appropriate function type body type checks assumptions precondition 
induction number type applications repeated andx substitution lemmas body type checks result 
lemma progress halt 
proof proof case analysis shape 
formed stores lemma lemma conjunction canonical forms lemmas lemma ensure store allows triggered rule evaluate 
follows write cf canonical forms lemma wfs formed stores lemma malloc malloc applies 
static semantics rule ptr lemma free location variables 
cf ptr 
sub vn operational rule applies 
instruction type checked 
case ptr exactly way previous case conclude ptr ands vn 
applies 
free rule free ptr previous cases conclude ptr 
consequently rule free applies 
vn complicated instruction step easy 
app vn cf fix cn 
suffices apply app 
halt result holds trivially 
applies 
applies 
ifnull ifnull ptr may conclude 
wfs cf ptr null case ifnull applies second case ifnull applies 
complete rules appendix contains complete description language locations 
syntax locations locations constraints types int junk ptr null value contexts constructor contexts values junk ptr vn fix null instructions malloc free vn halt ifnull stores vn programs static semantics wf type fv wf loc fv wf con fv standard equality alpha conversion bound variables modulo equality constraints 
rules omitted 
sub null null sub tuple sub eq reflex sub trans trans assoc atom comm symm cong sub eq sub sub forget sub trans sub cong int int sub junk junk junk var ptr ptr null null null fix tuple vn vn xn fix xn xn sub malloc junk ptr malloc free ptr junk free ptr ptr ptr app vn vn null ptr base ifnull ptr null ptr ptr null ifnull sub vn vn distinct operational semantics malloc malloc junk ptr free vn free ptr junk vn ptr vi vi vn vn ptr vn vi app vn cm fix xn cm vn xn dom ranges null ptr ifnull null ifnull ptr null ifnull vn ifnull ptr vn 
