linear programming formulation global inference natural language tasks dan roth wen tau yih department computer science university illinois urbana champaign yih uiuc edu typical processing paradigm natural language processing pipeline approach learners level outcomes features second level predictions 
addition accumulating errors clear sequential processing crude approximation process interactions occur levels stream decisions interact previous decisions 
develops general approach inference outcomes predictors presence general constraints 
allows breaking away pipeline paradigm performing global inference outcome different predictors potentially learned evaluated partial information domain task specific constraints outcomes predictors 
inference level existence mutual constraints simultaneous outcomes predictors results modifying predictions optimize global task specific constraints 
develop linear programming formulation problem evaluate context simultaneously learning named entities relations 
approach allows efficiently incorporate domain task specific constraints decision time resulting significant improvements accuracy human quality inferences 
natural language decisions depend outcomes different mutually dependent predictions respect input 
predictions need respect constraints arise nature data domain task specific conditions require level inference top predictions 
example visual processing domain exemplifies point consider problem counting number people image people partly occluded large number body part detectors scene interpretations predictors come play inference procedures takes account making final decision 
similarly interpreting natural language sentences requires multitude abstractions context dependent depend intricate ways 
efficient solutions problems sort constraints predictors sequential 
variations hmms conditional models sequential variations random markov fields provide efficient solutions :10.1.1.120.9821:10.1.1.32.9330
important situations structure problem general resulting computationally intractable problem 
problems sorts studied computer vision inference typically done low level measurements higher level predictors 
context natural language typical processing paradigm pipeline approach learners level outcomes features second level predictions 
example typical learn part speech tagger evaluate outcome features research supported nsf itr iis itr iis iis onr muri award 
task learning identify phrases say previous outcomes features learning semantic predicates name entities learning identify relations entities 
sequential type approach pipeline paradigm viterbi algorithm 
addition accumulating errors clear sequential processing crude approximation process interactions occur levels stream decisions interact previous decisions 
develops general approach inference outcomes predictors presence general constraints 
allows breaking away pipeline paradigm performing global inference outcome different predictors potentially learned evaluated partial information domain task specific constraints outcomes predictors 
inference level existence mutual constraints simultaneous outcomes predictors results modifying predictions optimize global task specific constraints 
develop models context natural language inferences evaluate problem simultaneously recognizing name entities relations 
problem recognizing kill oswald relation sentence oswald murdered jfk task requires making local decisions identifying name entities sentence order support relation identification 
example may useful identify oswald people jfk location 
turn may help identify kill action described sentence 
time relation kill constrains arguments people locations helps enforce oswald people jfk 
model learn collection local predictors entity relation identifiers 
decision time sentence produce global decision optimizes suggestions classifiers active sentence known constraints potentially domain tasks specific constraints relevant current decision 
study fairly general setting 
problem defined terms collection discrete random variables representing binary relations arguments seek optimal assignment variables presence constraints binary relations variables relation types 
brute force algorithm may feasible short sentences number entity variable grows computation intractable quickly 
entities sentence possible relations 
assume variable entity relation take labels labels 
ln possible assignments large small key insight technical solution suggest comes techniques developed context approximation algorithms 
develop linear programming formulation show cast problem 
need integral solution formalisms guarantee 
general need resort rounding methods necessarily satisfy constraints 
turns despite general nature problem graph structure represents collection binary relations arguments constraints binary relations arguments relation types optimal solution integer 
able prove case developed theoretical understanding experimental results decisive get optimal solution integral values 
evaluated simultaneous learning name entities relations approach provides significant improvement predictors accuracy importantly provides coherent solutions 
statistical methods stupid mistakes human show approach improves quality inference significantly 
approach similar nature different technical approach generality approaches attempt learn different classifiers derive global decisions inference outcomes :10.1.1.32.9330
contrasted approaches sequential inference general markov random field approaches :10.1.1.120.9821
key difference approaches model learned globally constraints imposed domain 
approach predictors need learned context decision tasks learned contexts incorporated background knowledge 
believe right conceptual framework motivating applications nlp computer vision described 
way technical approach allows incorporation constraints decisions dynamic fashion support task specific inferences 
significance clearly shown experimental results 
relational inference problem consider relational inference problem reasoning classifiers paradigm 
paradigm investigates decisions depend outcomes different mutually dependent classifiers 
classifiers outcomes need respect constraints arise sequential nature data domain specific conditions requiring level inference top predictions 
way variables considered fact outcomes learned classifiers learned large number variables features abstracted away interest inference process 
information contained classifiers outcome 
study specific fairly general instantiation problem motivated problem recognizing named entities persons locations organization names relations located live 
consider sets consists types variables set variables en ranges le 
value called label assigned ei denoted fei le 
second set variables rij viewed binary relations specifically pair entities ei ej rij rji denote binary relations ei ej ej ei respectively 
set labels relations lr label assigned relation rij lr 
apparently exists constraints labels corresponding relation variables entity variables 
instance relation live entity person second entity location 
correspondence relation entity variables represented bipartite graph 
relation variable rij connected entity ei second entity ej 
denote entity variables relation rij 
specifically ei rij ej rij addition define set constraints outcomes variables le lr constraints values argument relations 
defined similarly constrains second argument relation take 
example born person entity relation born person second entity location person 
note define constraints boolean formalisms fact allows stochastic constraints 
note define large number constraints lr lr constrain types relations fact clear sec 
language defining constraints rich linear equations exemplify framework problem simultaneous recognition named entities relations sentences 
briefly assume learning mechanism recognize entity phrases sentences local contextual features 
similarly assume learning mechanism recognize semantic relation phrases sentence 
seek inference algorithm produce coherent labeling entities relations sentence satisfying best possible recommendation entity relation classifiers satisfying natural constraints exist specific entities argument specific relations relations occur time information available inference time suppose known entity represent location may incorporate additional constraint prevents inference type lives live 
note large number problems modeled way 
examples include problems chunking sentences coreference resolution sequencing problems computational biology :10.1.1.32.9330
fact components problem separate task recognizing named entities sentences task recognizing semantic relations phrases modeled way 
goal specifically consider interacting problems different levels resulting complex constraints exhibit power method 
direct way formalize inference problem formalism markov random field mrf theory 
doing computational reasons fairly standard transformation mrf discrete optimization problem see details 
specifically weak assumptions view inference problem optimization problem aims minimize objective function sum cost functions 
assignment cost costs deviating assignment variables classifiers 
specific cost function defined follows label assigned variable marginal probability estimation fu assignment cost cu log constraints cost cost imposed breaking constraints neighboring nodes 
specific cost function defined follows consider entity nodes ei ej corresponding relation node rij ei rij ej rij 
constraint cost indicates labels consistent constraints 
particular fei fei fei similarly force consistency second argument relation 
seeking probable global assignment satisfies constraints cost function optimize global labeling variables cu fu rij fei computational approach relational inference unfortunately hard see optimization problem computationally intractable placing assumptions cost function 
computational approach adopt linear programming formulation problem 
provide integer linear programming formulation eq 
relax linear programming problem 
linear programming relaxation lpr technique general find non integer solutions 
round solutions integer solutions needed 
assumptions cost function hold case exist rounding procedures guarantee optimality 
rounding procedures exist 
discuss issue integer solutions linear programs provide evidence target problems rounding required linear program optimal integer solution 
linear programming formulation methods proposed 
objective function eq linear function terms labels introduce new binary decision variables represent different possible assignments original variable represent objective function linear function binary variables 
variable defined variable labeled le lr 
example label entity label relation 
rij ei variable indicating relation rij assigned label argument ei assigned label 
instance means label relation label argument 
similarly rij ej indicates rij assigned label second argument ej assigned label 
definitions optimization problem represented integer programming problem 
min ce cr le ei ej ei ej lr le lr practice large number 
rij ei lr le rij ej subject le lr lr le le lr lr le equations require entity relation variable assigned label 
equations assure assignment entity relation variable consistent assignment neighboring variables 
integral constraints binary variables 
apply linear programming relax integral constraints 
replacing le lr lr le solve optimization problem efficiently 
obviously general solution linear programming solver may integral 
rounding procedure may needed order generate integer solution 
problem general outcomes rounding procedure may legal solution problem conditions hold shown rounded solution approximation optimal solution 
studying rounding take different route study theory integer solutions linear programs 
turns conditions coefficient matrix linear program canonical form shown optimal solution linear program fact integral 
motivated decisive results experimental study sec 
investigated direction 
definition matrix rank called unimodular entries integers determinant square submatrix order 
theorem dantzig integral matrix full row rank polyhedron ax integral integral vector unimodular 
theorem indicates linear programming problem standard form regardless cost function integral vector optimal solution integer iff coefficient matrix unimodular 
reason basic feasible solution linear program form non singular square submatrix order optimal solution appears basic feasible solutions linear programming problem integer solutions 
linear programming formulation standard form coefficient matrix full row rank 
number entities le number entity labels lr number relation labels 
eliminate rows theorem 
theorem coefficient matrix linear programming formulation le lr lr matrix entries 
addition rank le lr full rank matrix derived eliminating rows rows elimination corresponding vector linear programming formulation nice property entry entries 
combining results know linear programming formulation properties get optimal integer solution 
unimodular 
column 
ar non singular submatrix order rank rank ai integers 
constraints problem forbid non integer solutions 
find problems properties 
don properties examining coefficient matrix observe non integer solution happen integer solutions optimal cost 
point looking proof conjecture 
conjecture non integer basic feasible solution problem convex combination integer basic feasible solutions 
yk 
cost function convex function linear exists yi yi 
optimal yi 
note practice optimal solutions 
mentioned cases experimented requires rounding 
experiments describe experiments problem simultaneously recognizing entities relations 
view task knowledge acquisition task system read sentences identify entities relations 
difficult task may require quite information sentence consider forced decision task simulate question answering situation ask system say killed evaluate identifying correctly relation arguments known sentence relation active 
addition evaluation exhibits ability approach incorporate task specific constraints decision time 
experiments trec data set consists articles wsj ap annotated named entities relations 
order effectively observe interaction relations entities picked sentences active relation 
sentences entities pairs entities binary relations 
entity labels include persons locations organizations 
relation labels include located live kill 
note pair entities active relation 
relation significantly 
examples relation label constraints relation variable entity arguments shown follows 
relation entity entity example located loc loc new york org bill gates microsoft org loc hp palo alto live loc bush kill oswald jfk order focus evaluation inference procedure assume problem segmentation phrase detection solved entity boundaries input concentrate classification :10.1.1.11.8199
evaluate linear programming global inference procedure lpr simpler approaches third information learning time 
basic tests entity relation classifiers trained independently local features 
particular relation classifier know labels entity arguments entity classifier know labels relations sentence 
moving describe approaches describe basic classifiers approaches 
entity classifier set features extracted words size window target phrase 
words part speech tags conjunctions bigrams trigrams mixture words tags 
addition features extracted target phrase including symbol explanation icap character word capitalized characters word capitalized characters word capitalized suffix suffix word ing ment bigram bigram words target phrase len number words target phrase place phrase known place name prof phrase professional title lt name phrase known person name pattern example arg arg san jose ca arg arg prof john smith manager arg arg officials province said arg prof arg cnn reporter david mckinley arg native arg elizabeth native salisbury arg arg leslie mart troy mich said table patterns relation classification relation classifier sets features features similar entity classification extracted argument entities relation conjunctions features arguments patterns extracted sentence arguments 
features category number words arg arg arg arg word arg sentence words consist capitalized characters arg arg represent second argument entities respectively 
addition table presents patterns 
learning algorithm variation winnow update rule incorporated snow multi class classifier specifically tailored large scale learning tasks 
snow learns sparse network linear functions targets entity classes relation classes case represented linear functions common feature space 
snow classifier predicts winner take mechanism activation value target classes rely directly raw activation value outputs weighted linear sum active features estimate posteriors 
verified resulting values monotonic confidence prediction provide source probability estimation 
softmax raw activation values conditional probabilities 
specifically suppose number classes raw activation values class acti 
posterior estimation class derived equation 
pi acti collect names famous places people popular titles data sources advance 
pipeline mimics typical strategy solving complex natural language problems separating task stages solving sequentially 
example named entity recognizer may trained different corpus advance relation classifier tool extract features 
approach trains entity classifier described basic approach uses prediction entities addition local features learn relation identifier 
note true labels entities known training relation identifier may case general nlp problems 
predictions entity classifier 
lpr global inference procedure 
takes input constraints relation entity arguments output estimated probability distribution labels basic classifiers 
note lpr may change predictions entity labels relation labels pipeline fully trusts labels entity classifier relation predictions may different basic relation classifier 
words lpr able enhance performance entity classification impossible pipeline 
final approach omniscience tests conceptual upper bound entity relation classification problem 
trains classifiers separately basic approach 
assumes entity classifier knows correct relation labels similarly relation classifier knows right entity labels 
additional information features training testing 
note assumption totally unrealistic 
may give hint global inference achieve 
results approach person organization location rec 
prec 
rec 
prec 
rec 
prec 
basic pipeline lpr omniscient table results entity classification approach located rec 
prec 
rec 
prec 
rec 
prec 
basic pipeline lpr omniscient approach live kill rec 
prec 
rec 
prec 
basic pipeline lpr omniscient table results relation classification tables show performance approach 
results show lpr performs consistently better basic pipeline entities relations 
show lack space enhances recall precision reflected 
note lpr apply learning outperforms pipeline uses entity predictions new features learning 
results omniscient classifiers reveal room improvement 
option apply learning tune better cost function lpr approach 
significant results experiments believe improvement quality decisions 
mentioned sec 
incorporating constraints helps avoid stupid human perspective mistakes classification 
interesting examine mistakes happen global inference see effectively global inference enhances 
purpose define quality decision follows 
active relation label classified correctly argument entities predicted correctly count coherent prediction 
quality number coherent predictions divided sum coherent incoherent predictions 
basic pipeline approaches global view labels entities relations certain amount predictions incoherent 
quality 
hand global inference procedure lpr takes natural constraints account generates incoherent predictions 
relation classifier correct entity labels features learner learn constraints 
result quality omniscient lpr 
experiment forced decision test boosts kill relation 
consider sentences kill relation active force system determine possible relations sentence pair entities relation 
realistic situation context question answering adds external constraint time learning classifiers evaluates ability inference algorithm cope 
results exhibit expectations correct 
fact believe natural situations number constraint apply larger observing algorithm performs specific forced decision tasks verifies lpr reliable situation shown performs better omniscience information learning time adapt situation decision time 
discussion approach global inference situations decisions depend outcomes different mutually dependent classifiers outcomes need respect domain tasks specific constraint 
shown presence fairly general constraint structure deviating sequential nature typically studied develop optimal efficient inference procedure 
technical approach formulating discrete inference problem linear program arguing admits integer solution 
developed theoretical understanding claim far overwhelming experimental evidence attempt top agenda 
key advantage linear programming formulation generality flexibility particular supports ability incorporate classifiers learned contexts hints supplied decision time constraints reason best global prediction 
sharp contrast typically pipeline framework formulation blindly trust results classifiers able overcome mistakes classifiers help constraints 
experiments demonstrated advantages considering interaction entity relation classifiers 
fact classifiers added framework 
example coreference resolution available possible incorporate form constraints force labels referred entities course allowing global solution reject suggestion classifiers 
consequently may enhance performance entity relation recognition time correct possible coreference resolution errors 
example chunking information better relation identification suppose example available chunking information identifies subj verb verb object phrases 
sentence verb murder may conclude subject object verb kill relation 
chunking information global inference procedure information contribute enhancing performance robustness relying having constraints overcoming possible mistakes classifiers 
interactive environment user supply new constraints question answering situation framework able new information enhance performance decision time retraining classifiers 
show formulation supports improved accuracy improves human quality decisions 
believe potential powerful way supporting natural language inferences 
punyakanok roth :10.1.1.32.9330
classifiers sequential inference 
nips conference advances neural information processing systems pages 
mit press 
lafferty mccallum pereira 
conditional random fields probabilistic models segmenting labeling sequence data 
proc 
th international conf 
machine learning pages 
morgan kaufmann san francisco ca 
levin yair weiss 
learning perceive transparency statistics natural scenes 
nips conference advances neural information processing systems 
boykov veksler zabih 
fast approximate energy minimization graph cuts 
ieee transactions pattern analysis machine intelligence november 
ratnaparkhi 
learning parse natural language maximum entropy models 
machine learning 
chekuri khanna naor 
approximation algorithms metric labeling problem new linear programming formulation 
symposium discrete algorithms pages 
dan klein joseph nguyen christopher manning 
named entity recognition character level models 
walter daelemans miles osborne editors proceedings conll pages 
edmonton canada 
pieter koller 
discriminative probabilistic models relational data 
uncertainty artificial intelligence proceedings eighteenth conference uai pages san francisco ca 
morgan kaufmann publishers 
roth 
reasoning classifiers 
proc 
european conference machine learning pages 
li 
markov random field modeling image 
springer verlag 
kleinberg tardos 
approximation algorithms classification problems pairwise relationships metric labeling markov random fields 
ieee symposium foundations computer science pages 

linear integer programming theory practice 
marcel dekker january 
schrijver 
theory linear integer programming 
wiley interscience series discrete 
john wiley sons december 
abney 
parsing chunks 
abney berwick editors principle parsing computation psycholinguistics pages 
kluwer dordrecht 
roth 
learning resolve natural language ambiguities unified approach 
proc 
aaai pages 
roth yih 
probabilistic reasoning entity relation recognition 
coling th international conference computational linguistics pages 
bishop 
neural networks pattern recognition chapter modelling conditional distributions page 
oxford university press 
