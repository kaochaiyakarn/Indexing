automatic generation program specifications jeremy nimmer michael ernst mit lab computer science technology square cambridge ma usa lcs mit edu producing specifications dynamic runtime analysis program executions potentially unsound analyzed executions may fully characterize possible executions program 
practice accurate results dynamic analysis 
describes results investigation question determining specifications generalized program runs changed order verified static checker 
surprisingly small test suites captured nearly program behavior required specific type static checking static checker guaranteed implementations satisfy generated specifications ensured absence runtime exceptions 
measured verification task generated specifications scored precision measure soundness recall measure completeness 
positive result testing suggests dynamic analyses capture semantic information interest certain applications 
experimental results demonstrate specific technique dynamic invariant detection effective generating consistent sufficient specifications static checker 
research shows combining static dynamic analyses program specifications benefits users technique guaranteeing soundness dynamic analysis lessening annotation burden users static analysis 

investigates combining dynamic static analyses task recovering formal program specifications 
evaluates accuracy dynamic analysis measuring static verifiability result 
accuracy dynamic analysis interest accuracy affects utility 
recovering specifications valuable goal specifications useful testing debugging verification maintenance optimization tasks frequently absent programs software engineers benefits 
dynamic runtime analysis obtains information program executions examples include profiling testing 
modeling state program dynamic analysis uses actual values computed program executions 
dynamic analysis efficient precise results may generalize program executions 
potential unsoundness dynamic analysis inappropriate certain uses may users reluctant depend results contexts uncertainty reliability 
contrast static analysis operates examining program source code reasoning possible executions 
builds model state program possible values variables 
static analysis conservative sound theoretically complete cc 
inefficient produce weak results case theorem proving program verification require explicit goals annotations 
selecting goal annotating programs input static checker difficult tedious 
combining techniques overcomes weaknesses dynamically detected invariants annotate program provide goals static verification easing tedious annotation static verification confirm properties proposed dynamic tool mitigating unsoundness 
combined system better relying tools performing error prone hand analysis 
evaluate effectiveness combined analysis measuring dynamically generated specifications changed order verified static checker 
static checker guarantees implementation satisfies generated specification ensures absence runtime exceptions 
checker assess specifications reflect programmer intent 
measured verification requirement generated specifications scored precision measure soundness recall measure completeness 
results demonstrate non trivial useful aspects program semantics test executions measured verifiability generated specifications 
results demonstrate technique dynamic invariant detection effective capturing information results effective task verifying absence runtime errors 
furthermore imperfect specifications 
instance current systems trouble postulating verification goals 
users may find starting partial nearly true specifications easier various tasks including program verification starting specifications 
approach formal program specifications investigate relationship dynamically statically available information program accuracy 
approach extract specifications program runs ern ecgn determine sufficient machine verifiability specification code checker generator push elt isempty false proof generation checking program specifications results specification proof consistency code 
generator daikon invariant detector checker esc java static checker 
absence runtime errors 
formal specification precise description program behavior 
appendix discusses alternate definitions 
specifications state properties data structures object invariants relate variable values pre state procedure call post state values procedure call 
specification procedure records maximum argument variable max include arg max max arg max max max represents value time procedure invoked max represents value variable procedure returns 
typical specification contains clauses simple mathematical statements involving values implications 
clauses conjoined produce full specification 
specification clauses called invariants 
single best specification program different specifications include fewer clauses assist different tasks 
likewise single correct specification program correctness measured relative standard designer intent task program verification 
generated specifications consist program invariants 
specifications partial describe constrain behavior provide full input output mapping 
specifications unsound described section properties guaranteed hold 
specifications describe program actual behavior may vary programmer intended behavior 
aspects generated specification suggest certain uses limiting 
research shows specification useful verifying lack runtime exceptions 
contrast template automatic test case generation add little value specification reflects program behavior test suite 
program correct nearly generated specification near intended behavior corrected reflect programmer intent 
likewise generated specification corrected verifiable static checker guaranteeing absence certain errors adding confidence maintenance tasks 
users need mimic evaluation strategy statically verifying generated specifications uncorrected specifications useful 
generated specifications useful program refactoring theorem proving test suite generation har anomaly bug detection ecgn rks hl dod 
tasks accuracy generated specification degree matches code affects effort involved performing task 
evaluates accuracy specifications respect verification esc java 
evaluate accuracy generated specifications integrated dynamic invariant detector daikon ern ecgn invariants instrumented program original program test suite run instrument data trace database detect invariants overview dynamic detection invariants implemented daikon invariant detector 
static verifier esc java lns resulting system produces machine verifiable specifications see 
system operates steps ne 
runs daikon outputs list invariants obtained running target program test suite 
term test suite inputs executions analyzed inputs need satisfy particular properties regarding code coverage fault detection 
second inserts invariants target program annotations 
third runs esc java annotated target program report invariants statically verified 
steps completely automatic users may improve results editing re running test suites adding removing specific program annotations hand 
remainder organized follows 
section provides background dynamic specification generator static verifier system 
section presents methodology experiments section presents results 
section notes challenges arose building running system 
section discusses lessons learned experiments 
section relates research previous section concludes 

background section briefly describes dynamic detection program invariants performed daikon tool static checking program annotations performed esc java tool 
full details techniques tools appear 
daikon specification generation dynamic invariant detection ern ecgn discovers invariants program executions instrumenting target program trace variables interest running instrumented program test suite inferring invariants instrumented values 
inference step tests set possible invariants values captured instrumented variables invariants tested sufficient degree falsification reported programmer 
dynamic approaches testing profiling accuracy inferred invariants depends part quality completeness test cases 
daikon invariant detector language independent currently includes java ioa 
daikon detects invariants specific program points procedure entries exits program point treated independently 
invariant detector provided variable trace contains execution program point values variables scope point 
set possible invariants tested various combinations traced variables 
scalar variables computed constants examples checked invariants equality constant small set constants fa cg lying program size number invariants accuracy program loc ncnb meth 


prec 
recall description set represented bitvector disjoint sets supporting union find stackar stack represented array queue represented array graph generic graph data structure pair points earth rational number collection numeric ranges vector java util vector array ratpoly polynomial rational numbers driving directions query processor total summary invariants detected daikon verified esc java 
loc total lines code 
ncnb non blank lines code 
meth number methods 
number reported invariants esc java verified 
number reported invariants esc java failed verify 
number invariants reported daikon required esc java verification 
prec precision reported invariants ratio verifiable verifiable plus invariants 
recall recall reported invariants ratio verifiable verifiable plus missing 
range non zero modulus mod linear relationships ax ordering functions fn 
invariants involving sequence variable array linked list include minimum maximum sequence values lexicographical ordering element ordering invariants holding elements sequence membership 
sequences example checked invariants elementwise linear relationship lexicographic comparison subsequence relationship 
daikon detect implications null value disjunctions value limit left 
ignore invariants inexpressible esc java input language example sequence invariants ignored 
variable tuple variables scope program point potential invariant tested 
potential unary invariant checked variables potential binary invariant checked pairs variables forth 
potential invariant checked examining sample tuple values variables tested turn 
soon sample satisfying invariant encountered invariant known hold checked subsequent samples 
false invariants tend falsified quickly cost detecting invariants tends proportional number invariants discovered 
invariants inexpensive test require full fledged theorem proving 
invariant reported adequate statistical evidence 
particular inadequate number observations observed patterns may mere coincidence 
consequently detected invariant daikon computes probability property appear chance random set samples 
property reported probability smaller user defined confidence parameter ecgn 
daikon invariant detector available pag 
lcs mit edu daikon 
esc static checking esc det ln extended static checker implemented modula java 
statically detects common errors usually detected run time null dereference errors array bounds errors type cast errors 
esc intermediate power ease theorem provers aims lightweight comparison 
proving complete program correctness esc detects certain types errors 
programmers write program annotations similar flavor assert statements need interact checker processes annotated program 
esc issues warnings annotations verified potential run time errors 
esc performs modular checking checks different parts program independently check partial programs modules 
assumes specifications supplied missing unchecked components correct 
esc implementation uses internally 
discuss esc checking strategy detail research treats esc black box 
distributed binary form 
esc java successor esc modula 
esc java annotation language see section simpler slightly weaker 
keeping philosophy tool easy useful programmers extraordinarily powerful difficult programmers shy away 
esc java sound instance model arithmetic overflow track aliasing assumes loops executed times permits user supply assumptions 
esc java provides approximation soundness issues false warnings relatively infrequently successful verification increases confidence piece code 
essentially verification process programs contains unsound step hidden step performed human model creation 
uses esc java lightweight technology detecting restricted class runtime errors tool verifying representation invariants method specifications 
chose esc java aware equally capable technology statically checking properties runnable code 
verifiers operate specifications models research aims compare combine dynamic static techniques code artifact 
versions esc publicly available research compaq com src esc 

methodology analyzed programs listed 
stackar come data structures text original test suite augmented test suite size size coverage time size coverage time program ncnb ncnb calls stmt branch instr daikon ncnb calls stmt branch instr daikon stackar graph sys sys sys vector ratpoly characterization test suites 
ncnb non comment non blank lines code program original accompanying test suite column sys indicates system test focused specified program tests higher level system contains program see section 
ncnb number lines added yield results described section 
calls dynamic number method calls received program test test suite internally 
stmt branch indicate statement branch coverage test suite 
instr runtime instrumented program 
daikon runtime daikon invariant detector 
times wall clock measurements seconds 
book wei vector part java standard library remaining programs solutions assignments programming course mit 
described section system runs daikon inserts output target program esc java annotations 
measured different reported invariants set annotations enables esc java verify run time errors occur esc java verifies annotations potentially sets esc java verifiable annotations program 
order perform evaluation choose goal 
correct best specification program different specifications support different tasks 
instance set esc java annotations ensure run time errors occur set ensure representation invariant maintained set guarantee correctness respect externally imposed requirements 
chose goal task verifying absence run time errors 
sets invariants enable esc java prove condition selected goal set required smallest number changes daikon output 
distance goal set measure minimal expected effort needed verify program esc java starting set invariants detected daikon 
choice measure different reported invariants set consistent sufficient esc java checking objective measure program semantics captured daikon executions 
set invariants reported daikon changes necessary verification counted number reported verified invariants column reported invariants column necessary invariants column 
computed precision recall standard measures information retrieval sal vr numbers 
precision measure soundness defined recall measure completeness defined example daikon reported invariants verifiable verified set contained invariants reported daikon plus added hand precision recall 
determined hand daikon invariants redundant logically implied invariants 
users need remove redundant invariants order tool removed invariants consideration appear measurements reasons 
daikon attempts avoid reporting redundant invariants tests perfect results indicate improved tool achieve 
importantly redundant invariants verifiable including redundant invariants inflated results 
test suites shows relative sizes test suites programs experiment 
test suites smaller programs larger comparison code size test suite unreasonably sized 
programs vector came test suites textbook grading 
wrote test suites vector 
textbook test suites properly characterized examples calling code contained just calls method exercise program full functionality 
extended deficient test suites easy task see section necessary programs realistic test suites 
generated test suite augmentation minutes 
augmentation took hours due hour round trip time evaluate changes 
examining daikon output greatly eased task 

experiments section gives quantitative qualitative experimental results 
results demonstrate dynamically inferred specifications precise complete machine verifiable 
section summarizes experiments sections discuss example programs detail characterize generated specifications provide intuition output system 
section summarizes problems system may encounter 
summary performed eleven experiments shown 
described section daikon output inserted target program annotations edited necessary result verifies 
program verifies implementation meets generated edited specification runtime errors guaranteed absent 
programs non comment non blank lines code precision measure soundness recall measure completeness respectively 
sections describe specific problems lead missing invariants summarize imperfections 
invariants correctly described program proved due limitations esc java 
limitations design appeared bugs esc java 
missing invariants scope daikon 
verification required certain complicated predicates element type annotations non list collections daikon currently provide 
stackar array stack stackar array stack implementation wei 
source contains non comment lines code methods comments describe behavior class mention representation invariant 
run unannotated version stackar esc java issues warnings potential runtime errors null dereferences array bounds errors 
system generated specifications operations class addition detected invariants esc java issues warnings successfully checks stackar class avoids runtime errors verifies implementation meets generated specification 
daikon invariant detector reported invariants including representation invariant method preconditions modification targets postconditions 
addition system heuristically added annotations involving aliasing array 
shows part automatically annotated source code stackar 
annotations describe representation invariant array non null contains elements arbitrary run time type array index legal unused array elements null 
annotations specify constructor 
daikon detects construction elements array null property implied representation invariant fact topofstack daikon report property 
invariants specify method 
elements topofstack modified topofstack increases 
topofstack originally non negative decremented non null result returned 
ratpoly polynomial rational numbers second example illustrates results provides examples verification problems 
ratpoly implementation rational coefficient polynomials support basic algebraic operations 
source contains non comment lines code classes methods 
informal comments state representation invariant method specifications 
system produced nearly verifiable annotation set 
additionally annotation set reflected properties programmer specification informal comments 
shows daikon reported invariants program verify added 
invariants true missing invariants prevented verified 
instance ratpoly implementation maintains object invariant zero value coefficients explicitly stored daikon reported get method returns zero 
esc java annotations may elements java collection classes public class stackar invariant null invariant typeof type object invariant topofstack invariant topofstack invariant forall int null invariant forall int topofstack null private object private int topofstack requires capacity ensures capacity length ensures topofstack public stackar int capacity new object capacity topofstack modifies topofstack ensures forall int old ensures topofstack ensures old topofstack topofstack old topofstack ensures old topofstack result old topofstack ensures old topofstack result null public object isempty return null object top topofstack null return 
object invariants method specifications annotated stackar java file wei 
esc java annotations comments starting produced automatically daikon automatically inserted source code system automatically verified esc java 
clarity wraps lines omits auxiliary annotations irrelevant specification required esc java inserted system 
object invariant expressible get method failed verify 
similarly mul operation exits immediately polynomials undefined determination condition required annotations accessing java collections 
esc java prove helper methods mul operated undefined coefficients reported daikon 
provided test suite invariants detected daikon suppressed lack statistical justification 
small test suite augmentations extensively exercised code caused invariants printed 
alternately command line switch daikon sets justification threshold 
test suite augmentations invariant edited hand counting missing integer lower bound weakened esc java incompleteness prevented proof true subtle stricter bound 
driving directions final example illustrates results 
application computes driving directions addresses provided user real world geographic data 
source contains non comment lines code classes compute specifications classes 
omitted classes classes frequently loading databases recording traces offline processing infeasible due space limitations 
class entry point called times data available inference 
classes little variance data inference tiny database loaded 
class complex inheritance hierarchy prevented local reasoning hindered modular static analysis 
problems overcome invariant detector runs online allowing larger data sets processed varied database loaded 
verified classes methods lines 
verified classes include data types priority queue algorithms dijkstra shortest path user interface various file utilities 
shows daikon reported invariants verify added 
invariants capabilities esc java exposed bugs tools 
largest cause missing invariants esc java incompleteness 
modular analysis incomplete knowledge java semantics forced annotations added required object invariants inexpressible 
invariants missing outside scope daikon 
daikon currently report invariants non list java collections invariants type information collections required esc java verification 
daikon missed invariants instrument interfaces invariants local variables instrumented 
currently enhancing daikon inspect interfaces collection classes 
missing annotations needed suppress esc java warnings exceptions 
handles catastrophic failure filesystem errors raising unchecked exception 
user disable esc verification exceptions proven absent 
step requires user intervention matter tool specifying catastrophic errors ignore engineering decision 
remaining missing invariants arose distinct causes generalized individually add insight 

remaining challenges fully automatic generation checking program specifications possible 
section categorizes problems encountered experimental investigation 
limitations fall general categories problems target programs problems test suites problems daikon esc java tools 
target programs challenge verification invariants likelihood programs contain errors falsify desired invariant 
goal previously identified errors textbooks programs testing research 
case desired invariant true invariant program 
program errors may prevent verification error falsify necessary invariant 
test suite may reveal error correct specification generated 
fail verify static checker discover possible executions violate invariant 
experiments revealed error vector class jdk 
tostring method throws exception vectors null elements 
original code coverage complete test suite reveal fault daikon reported vector elements non null entry tostring leading discovery error 
error corrected jdk 
aware error time experiments 
example error detected object invariants stackar states unused elements stack null 
pop operations maintain invariant approximately doubles size code operation 
noticed expected object invariant inferred corrected error version stackar 
test suites challenge generation deficient missing test suites 
general realistic test suites tend produce verifiable specifications poor verification results indicate specific failures testing 
executions induced test suite characteristic program general behavior properties observed testing may generalize 
key results research limited test suites capture partial semantics program 
surprising small programs reliably inferring patterns small datasets difficult 
furthermore larger programs necessarily better components may test suite 
example main routine may run 
system tests tests check behavior system tended produce invariants immediately confirming earlier experiences ecgn 
system tests exercise system containing module examined testing just module 
unit tests tests check specific boundary values procedures single module isolation successful 
may counter intuitive unit tests achieve code coverage generally attempt cover boundary cases module 
specifically targeting boundary cases unit tests utilize module ways statistically application throwing statistical techniques daikon 
equally importantly unit tests tend contain calls preventing statistical inference 
initial test suites came textbooks unit tests grading contained just calls method 
methods tested 
corrected test suites attempt minimal 
corrections difficult 
failed esc java verification attempts indicate test suite deficient invariants specify unintended property programmer suggestion improve tests 
example original tests div operation ratpoly exercised wide range positive coefficients tests negative coefficients numerator 
examples included certain stack operations performed full empty stack queue implemented array wrapped 
properties detected reported system extending tests cover additional values effortless 
test suites important part programming effort time invested improvement wasted 
experience creating test suite induces accurate invariants little difficult creating general test suite 
short poor verification results indicate specific failures testing reasonably sized realistic test suites able accurately capture semantics program 
inherent limitations tool tool contains bias grammar properties detect verify 
properties grammar insurmountable obstacles automatic verification specifications capabilities particular tool 
instance class daikon negate method preserves denominator negates numerator 
verifying property require detecting verifying gcd operation called constructor effect numerator denominator argument relatively prime 
daikon include invariants insufficiently general applicability esc java verify property 
users add new invariants daikon detect writing java class satisfies interface methods 
example daikon esc java operates invariants strings 
result combined system detect verify object invariants hold exit constructor method interprets string argument system showed methods maintain invariant 
final example class guarantees unused storage set null 
representation invariants maintain property missing daikon output conditioned predicate complicated daikon currently attempts forall int null front back front back back omission prevented verification method postconditions 
daikon aside problems inherent analysis tool tools evaluation exhibited additional problems prevented immediate verification 
daikon deficiencies 
daikon examine contents non list java collections maps sets 
prevents reporting type properties elements properties needed esc java verification 
second daikon operates offline examining traces written disk instrumented version program test 
methods instrumented program long running storage processing requirements exceed available capacity 
daikon uses ajax determine comparability variables java programs 
variables incomparable invariants relating generated tested 
ajax fails large programs variables considered comparable spurious invariants generated printed constraining unrelated quantities 
problems currently addressed re engineering efforts 
esc java esc java input language variant java modeling language jml lbr lbr interface specification language specifies behavior java modules 
jml variant accepted input esc java 
express certain properties daikon reports 
annotations include method calls ones side effect free 
daikon uses obtaining vector elements predicates implications 
daikon express closure operations elements linked list 
requires object invariants hold entry exit methods warned object invariants daikon reported violated private helper methods 
worked problem inlining method program 
full jml language permits method calls assertions includes reach expressing reachability transitive closure specifies object invariants hold entry exit public methods 
functionality missing esc java designed proving general program properties lightweight method verifying absence runtime errors 
investigations revealed examples verification required missing capabilities 
cases esc java users may able restructure code problems 
users insert unchecked pragmas cause esc java assume particular properties proof permitting complete verification despite limitations 

discussion surprising result research specifications generated program executions reasonably accurate form set nearly self consistent self sufficient measured verifiability automatic specification checking tool 
result obvious priori 
expect dynamically detected invariants suffer serious unsoundness expressing artifacts test suite fail capture formal semantics program 
positive result implies dynamic invariant detection effective domain investigation 
second broader executions relatively small test suites capture significant amount information program semantics 
detected information verifiable static analysis 
theoretical model explain predict test suite program semantic space explore datapoint set experiments explicate phenomenon suggest may generalize 
reason results generalize daikon esc java operate modularly class time 
generating verifying specifications single class large system harder doing system consisting single class 
speculate factors may contribute success 
specification generation technique attempt report properties happen true test run 
produces partial specifications intentionally omit properties universally true 
uses statistical algorithmic heuristic tests judgment 
second information esc java needs verification may particularly easy obtain dynamic analysis 
esc java requirements modest need full formal specifications aspects program behavior 
verification require specifications input output relations 
system verified additional detected properties strictly necessary esc checking provided additional information program behavior 
third test suites acceptable quality 
unit tests inappropriate produce poor invariants see section 
daikon output extremely easy improve test suites indi deficiencies 
furthermore existing system tests adequate exist easier produce 
dynamic invariant detection successful application domains believe truly successful program analysis requires static dynamic components 
properties difficult obtain dynamic analysis apparent examination source code properties state art static analysis easily checked runtime 
plan integrate static analysis system particularly daikon 
example dynamic analysis need check properties discovered static analysis dynamic analysis focus code properties static analysis 
goal producing program specifications important worthwhile consider approaches 
research suggests novel approach complement existing ones generate specification check resulting specification verification soundness limitations verifier 
believe unsound specifications advantage situations expand applicability utility specifications provide benefits sound specifications situations 
full input output relations hard generate automatically universally true properties especially implications characterize relation step right direction 
benefits integration static dynamic analyses complementary strengths weaknesses combining great promise dynamic analysis propose program properties verified static analysis 
integrating dynamic invariant detection static verification benefits tools 
static verifier augment dynamic invariant detection overcomes potential objection possibly unsound output classifies output proven true potentially incorrect permit programmers effectively permits verified invariants contexts input certain programs demand sound input may improve performance output dynamic invariant detection 
result programmers take advantage dynamically detected invariants variety contexts 
may eventually lead limitations noted section overcome fewer bugs introducing fewer detecting better documentation time wasted program understanding better test suites effective validation program changes efficient programs 
dynamically detected invariants bootstrap static verification providing initial program annotations goals intermediate assertions 
programmers enjoy annotating programs time consuming tedious error prone task 
automation may speed adoption static analysis tools lessening user burden remains user 
user study performed supports hypothesis nim 
dynamically detected invariants check refine existing specifications indicate properties programmers overlooked 
improvements lead prevention earlier detection errors aiding production robust reliable correct computer systems 

related research aware dynamically generated statically verified program specifications information investigate amount information program semantics available test runs 
component techniques known 
dynamic analysis variety programming tasks instance inductive logic programming ilp qui coh produces set horn clauses order rules run program traces bg limited success 
programming example chk similar requires close human guidance version spaces compactly represent sets hypotheses 
value profiling cfe ss efficiently detect certain simple properties runtime 
event traces generate finite state machines explicate system behavior bg cw 
program spectra bal capture aspects system runtime behavior 
techniques successful daikon generating specifications programs valuable domains 
static inference techniques exist including interpretation implemented symbolic execution dataflow analysis model checking theorem proving 
space limitations prohibit complete review 
sound conservative static analysis reports properties true program run theoretically detect sound invariants run convergence cc 
static analyses omit properties true uncomputable properties program context 
control time space complexity especially cost modeling program states ensure termination approximations introduce inaccuracies weakening results 
instance accurate efficient alias analysis infeasible specific applications contexts assumptions efficient pointer analyses sufficiently accurate das 
loop project verified object invariant java vector class hjv 
technique involved automatic translation java pvs ors user specified goals user interaction pvs 
tools esc java statically check specifications pfe det 
examples static verifiers connected real programming languages include lclint acl km loop java pathfinder hp bandera cdh 
systems different strengths weaknesses esc java polish integration real programming language 
currently integrating daikon ioa formal language describing computational processes modeled automata lt 
ioa toolset theory 
lcs mit edu tds ioa html permits ioa programs run provides interface larch prover gg interactive theorem proving system order logic 
daikon proposes goals lemmas intermediate assertions theorem prover 
representation invariants assist proofs properties hold reachable states representations possible states representations 
tedious error prone people specify representation invariants proved current systems trouble postulating researchers consider task harder performing proof weg bls bbm 
preliminary experiments users daikon substantial help proving peterson process mutual exclusion algorithm leading new proof obtained cache coherence protocol lamport paxos algorithm 
houdini research closely related integrated system houdini fl fjl annotation assistant esc java 
similar system proposed rintanen rin 
houdini motivated observation users reluctant annotate programs invariants attempts lessen burden providing initial set 
houdini takes candidate annotation set input computes greatest subset valid particular program 
repeatedly invokes checker removes refuted annotations annotations refuted 
candidate invariants possible arithmetic comparisons fields interesting constants array lengths null elements initial set mutually contradictory 
houdini find bugs programs 
guessed annotations verified tends reduce number esc java warnings factor 
daikon candidate invariants richer houdini daikon outputs implications disjunctions base invariants richer including complicated arithmetic sequence operations 
required invariant missing houdini eliminates invariants depend 
houdini attempt eliminate implied redundant invariants daikon reducing output size order magnitude ecgn difficult interpret numbers invariants produced houdini 
houdini user interface permits users ask candidate invariant refuted capability orthogonal proposal candidates 
houdini publicly available perform direct comparison 
combining approaches useful 
instance daikon output form input houdini permitting houdini spend time eliminating false invariants 
prototype dynamic essentially dynamic invariant detector built fl details results provided 
houdini different intent daikon houdini try produce complete specification annotations people missing annotations permit programs cluttered respect similar type inference 
daikon output place houdini 
invariants true depend missing invariants verifiable esc java eliminated users closer completely annotated program need eliminate invariants hand 

proposed experimentally assessed novel approach producing specifications generate program executions verify 
knowledge system dynamically detect statically verify program specifications 
experiments indicate limited test suites accurately characterize general execution properties generate specifications consistent sufficient automatic verification little change 
surprising result suggests runtime properties may unreliable general opinion holds effective method extracting 
principled description static characteristics test suite result high quality generated specification simple system tests sufficient 
experiments demonstrate effectiveness dynamic invariant detection 
tests daikon implementation generated specifications high precision recall measured task static verification esc java 
validates approach producing invariants program executions 
results justify unsound techniques appropriate ways program development suggest may extended program specifications traditionally required complete correctness pre implementation creation 
integrating static dynamic techniques system produces benefits direction complementary strengths weaknesses 
acknowledgments members daikon group particularly nii michael harder ben morse contributions project 
fruitful conversations chandra boyapati stephen garland william griswold daniel jackson josh rustan leino greg nelson david notkin gregg rothermel james saxe kevin sullivan 
presentation improved comments stephen garland william griswold rachel pottinger steven wolfman anonymous referees 
research supported part nsf ccr ccr gift ntt 
david abramson ian foster john 
relative debugging new methodology debugging scientific applications 
communications acm november 
bal thomas ball 
concept dynamic analysis 
esec fse pages september 
bbm bjrner browne zohar manna 
automatic generation invariants intermediate assertions 
theoretical computer science february 
bg ivan bratko marko grobelnik 
inductive learning applied program construction verification 
jose editor pages 
north holland 
bg bernard patrice godefroid 
automatic synthesis specifications dynamic observation reactive programs 
tacas pages twente april 
bls bensalem lakhnech saidi 
powerful techniques automatic generation invariants 
cav pages july august 
cc patrick cousot radhia cousot 
automatic synthesis optimal invariant assertions mathematical foundations 
proceedings acm symposium artificial intelligence programming languages pages rochester ny august 
cdh james corbett matthew dwyer john hatcliff corina pasareanu robby shawn laubach hongjun zheng 
bandera extracting finite state models java source code 
icse pages june 
cfe brad calder peter feller alan eustace 
value profiling 
micro pages december 
chk allen cypher daniel david henry lieberman david brad myers alan editors 
watch programming demonstration 
mit press cambridge ma 
coh william cohen 
grammatically biased learning learning logic programs explicit antecedent description language 
artificial intelligence august 
cw jonathan cook alexander wolf 
event detection concurrency 
fse pages november 
das das 
unification pointer analysis directional assignments 
pldi pages june 
det david detlefs 
overview extended static checking system 
proceedings workshop formal methods software practice pages january 
david detlefs rustan leino greg nelson james saxe 
extended static checking 
src research report compaq systems research center december 
dod nii 
selecting predicates conditional invariant detection cluster analysis 
master thesis mit dept eecs 
ecgn michael ernst adam william griswold david notkin 
quickly detecting relevant program invariants 
icse pages june 
ecgn michael ernst jake cockrell william griswold david notkin 
dynamically discovering program invariants support program evolution 
ieee tse february 
previous version appeared icse pages los angeles ca usa may 
david evans john guttag james horning yang meng tan 
lclint tool specifications check code 
fse pages december 
ern michael ernst 
dynamically discovering program invariants 
phd thesis university washington department computer science engineering seattle washington august 
fjl cormac flanagan rajeev joshi rustan leino 
annotation inference modular checkers 
information processing letters february 
fl cormac flanagan rustan leino 
houdini annotation assistant esc java 
formal methods europe volume lncs pages berlin germany march 
gg stephen garland john guttag 
lp larch prover 
stickel editor proceedings tenth international conference automated deduction volume lncs kaiserslautern west germany 
springer verlag 
carlo ghezzi mehdi jazayeri dino mandrioli 
fundamentals software engineering 
prentice hall englewood cliffs nj edition 
stephen garland nancy lynch 
ioa language specifying programming validating distributed systems 
technical report mit laboratory computer science 
har michael harder 
improving test suites generated specifications 
master thesis mit dept eecs may 
hjv marieke huisman bart jacobs joachim van den berg 
case study class library verification java vector class 
international journal software tools transfer 
hl monica lam 
tracking software bugs automatic anomaly detection 
icse may 
hp klaus havelund thomas 
model checking java programs java pathfinder 
international journal software tools technology transfer 
mary jean harrold gregg rothermel rui wu liu yi 
empirical investigation program spectra 
paste pages june 
bart jacobs joachim van den berg marieke huisman martijn van ulrich hendrik 
reasoning java classes 
oopsla pages vancouver bc canada october 
michael ernst william griswold david notkin 
automated support program refactoring invariants 
icsm pages november 
km matt kaufmann strother moore 
industrial strength theorem prover logic common lisp 
ieee tse april 
lam david alex lamb 
software engineering planning change 
prentice hall englewood cliffs nj 
lbr gary leavens albert baker clyde ruby 
jml notation detailed design 
haim kilov bernhard rumpe ian simmonds editors behavioral specifications businesses systems pages 
kluwer academic publishers boston 
lbr gary leavens albert baker clyde ruby 
preliminary design jml behavioral interface specification language java 
technical report iowa state university department computer science february 
see www cs iastate edu leavens jml html 
lau pedro domingos daniel weld 
version space algebra application programming demonstration 
icml stanford ca june 
lg barbara liskov john guttag 
program development java abstraction specification object oriented design 
addison wesley boston ma 
ln rustan leino greg nelson 
extended static checker modula 
compiler construction pages april 
lns rustan leino greg nelson james saxe 
esc java user manual 
technical report compaq systems research center palo alto california october 
lt nancy lynch mark tuttle 
input output automata 
cwi quarterly september 
lori clarke leon osterweil matthew dwyer 
verification concurrent software 
icse pages may 
ne jeremy nimmer michael ernst 
static verification dynamically detected program invariants integrating daikon esc java 
proceedings rv workshop runtime verification paris france july 
nim jeremy nimmer 
automatic generation checking program specifications 
master thesis mit dept eecs may 
toh ne win michael ernst 
verifying distributed algorithms dynamic analysis theorem proving 
technical report mit lab computer science may 
robert callahan 
generalized aliasing basis program analysis tools 
phd thesis carnegie mellon university pittsburgh pa may 
ors owre rushby shankar 
pvs prototype verification system 
proceedings th international conference automated deduction cade volume pages saratoga springs ny june 
sam owre john rushby natarajan shankar friedrich von henke 
formal verification fault tolerant architectures prolegomena design pvs 
ieee tse february 
special section best papers fme formal methods europe 
pc david parnas paul clements 
rational design process fake 
ieee tse se february 
pfe frank pfenning 
dependent types logic programming 
frank pfenning editor types logic programming chapter pages 
mit press cambridge ma 
pre roger pressman 
software engineering practitioner approach 
mcgraw hill new york third edition 
qui ross quinlan 
learning logical definitions relations 
machine learning 
thomas reps thomas ball das james larus 
program profiling software maintenance applications year problem 
esec fse pages september 
rin jussi rintanen 
iterative algorithm synthesizing invariants 
aaai iaai pages austin tx july august 
rks orna raz philip koopman mary shaw 
semantic anomaly detection online data sources 
icse may 
sal gerard salton 
automatic information organization retrieval 
mcgraw hill 
sem semiconductor industry association 
national technology roadmap semiconductors 
san jose ca 
som ian sommerville 
software engineering 
addisonwesley wokingham england fifth edition 
ss sohi 
empirical analysis instruction repetition 
asplos pages october 
vr van rijsbergen 
information retrieval 
butterworths london second edition 
weg ben wegbreit 
synthesis loop predicates 
communications acm february 
wei mark allen weiss 
data structures algorithm analysis java 
addison wesley longman 
specifications specifications different stages development requirements engineering maintenance 
furthermore specifications take variety forms verbal description customer requirements set test cases executable prototype 
fact consensus regarding definition specification lam 
research uses formal specifications 
define formal behavioral specification precise mathematical abstraction program behavior lg som pre 
definition standard specifications novel 
specifications generated automatically executable implementation exists 
typically software engineers directed write specifications implementation implementation guides simply obtain benefit having analyzed requirements early design stage som 
despite benefits having specification implementation practice programmers write formal informal specifications coding 
useful produce documentation fact pc 
obtaining specification point development cycle better having specification 
post hoc specifications fields engineering 
example speed binning process fabrication microprocessors tested determine fast run sem 
chips single batch may sold variety specified clock speeds 
authors define specification priori description intended desired behavior prescribed ways lam 
purposes useful categorize particular logical formula specification wrote mental state 
event 
readers prefer alternative definition may replace term specification description program behavior invariant program property text 
believe great promise extending specifications traditional genesis pre implementation expressions requirements 
contributions research insight possible desirable evidence back claim 
