executable structural operational semantics maude alberto narciso mart oliet technical report departamento de sistemas inform universidad de madrid september describes detail bridge gap theory practice implementing maude structural operational semantics described rewriting logic transitions rewrites inference rules conditional rewrite rules rewrites conditions possible new features maude 
validate technique case studies functional language fpl evaluation computation semantics including machine imperative languages evaluation computation semantics nondeterminism computation semantics kahn functional language mini ml evaluation natural semantics milner ccs strong weak transitions full lotos including act data type specifications 
addition top ccs develop implementation hennessy milner modal logic describing local capabilities processes lotos build entire tool full lotos specifications entered executed user knowledge underlying implementation semantics 
compare method transitions rewrites transitions judgements 
keywords rewriting logic maude executability structural operational semantics metalanguage ccs lotos act 
context proposing rewriting logic logical semantic framework illustrated different ways mapping inference systems rewriting logic 
general possibility map inference rule form 
sn rewrite rule form 
sn rewrites multisets judgements si 
mapping correct point view justified thinking terms executability rewrite rules appropriate consider rewrite rules form 
sn rewrite multisets judgements go premises rewriting rules corresponds searching proof bottom way 
mapping correct cases intuitive idea rewriting relation corresponds horizontal bar separating premises typical textbook presentation inference rules 
call method transitions judgements 
research supported cicyt projects formal de sistemas en viles tic para el la de software tic 
mappings applied wide variety inference systems explained including sequent systems logics structural operational semantics definitions languages 
operational semantics case judgements si typically form kind transition pi qi states sense consider possibility mapping directly transition relation states rewriting relation terms representing states 
thinking way inference rule form conditional rewrite rule form 
pn qn 
pn qn condition includes rewrites 
way semantic rules conditional rewrite rules transition main rewrite rule transitions premises rewrite conditions 
call method transitions rewrites 
rules form considered meseguer seminal rewriting logic 
logical level mapping correct careful take account mapping additional information appearing transitions operational semantics 
example structural operational semantics process algebras essential transitions labelling information provides mechanism synchronization 
solve details particular case milner ccs shown 
papers showed properties semantic mapping ccs 
availability rewriting logic language maude possible put practice approach transitions rewrites maude allows conditional rules rewrites conditions rewrites solved execution time means built search mechanism 
undertook project carefully implementing fully executable way ccs operational semantics order practically assess ideas summarized theoretically elegant correct 
ccs taken example desired solutions search executability general handle operational semantics definitions considering approach transitions rewrites conditional rules rewrites conditions 
validate approach far considered different operational semantics programming languages 
hand implemented evaluation big step computation small step semantics hennessy functional imperative programming languages including variants call value versus call name substitutions versus extending environment 
describes full detail 
functional language semantics implemented kahn mini ml letrec syntactic construct language requires special treatment deserves consideration 
hand addition operational semantics ccs process algebra implemented maude symbolic semantics lotos technique transitions rewrites 
case process algebras show implementation semantics develop formal analysis tools 
ccs case integrate implementation hennessy milner modal logic describing local capabilities processes lotos case integrate translation act data type specifications functional modules maude building entire tool full lotos specifications entered executed user knowledge underlying implementation semantics 
opinion approach transitions rewrites really simpler transitions judgements closer mathematical textbook presentation operational semantics general requires auxiliary structures operations 
need bridge gaps theory practice case new frozen attribute available maude played important role described detail section 
declaration operator frozen forbids rewriting arguments providing way controlling rewriting process 
important outstanding characteristic implementations provided maude language system integration framework specification levels necessary implement detail semantics language 
writing grammar syntax language corresponds defining algebraic signature corresponding algebraic specification 
data corresponding operations necessary implementation described means equational specifications 
top dynamic semantics language defined means rewrite rules described 
treat possible describe static semantics language type checking example techniques case approach transitions judgements may appropriate 
addition control necessary user reflection go metalevel instance section define semantics modal logic requires considering possible rewrites transitions 
integration aspects precisely allows development semantics full lotos act data type specifications translated functional maude modules 
furthermore metalanguage features maude allow build fully integrated way tool full lotos includes input output parsing account user definable syntax act specifications execution pretty printing way maude definition hidden user needs know full lotos specifications executed 
concerning implementation operational semantics methods describe assume correct structural operational semantics language 
course possible develop implementation precisely purpose prototyping proposed semantics modify information obtained tests execution 
assuming semantics step consists identifying structure necessary build lefthand righthand sides rewrites 
may simple cases examples see usually additional structure taken account environments case functional languages put lefthand side synchronization labels case process algebras put righthand side 
having done general translating semantics rules rewrite rules quite systematic process 
sure rules executable execute expects 
example ccs example see frozen attribute ensure rewriting takes place top state rewrite conditions give rise non terminating executions 
example mathematical rule letrec construct mini ml executable existential variable condition appears lefthand righthand sides rewrite principle know instantiate 
examples provide full details treatment semantics 
brief review main features maude section sections develop details case studies functional language fpl evaluation computation semantics variants machine imperative language evaluation computation semantics imperative nondeterministic language computation semantics kahn functional language mini ml evaluation natural semantics milner ccs strong weak transitions plus hennessy milner logic full lotos including act data type specifications complete tool 
section summarizes transitions judgements approach compares transitions rewrites 
section reviews related section concludes describing ideas 
results previously reported conference papers phd 
thesis 
rewriting logic maude rewriting logic introduced meseguer unified model concurrency known models concurrent systems represented common framework 
done rewriting logic logical semantic framework different logics models computation wide range languages including formal specification languages represented precise semantics executed 
advantages rewriting logic may emphasize simple formalism rules deduction easy understand justify 
flexible expressive capable representing change systems different structure 
allows user definable syntax complete freedom choose operators structural properties appropriate problem 
intrinsically concurrent representing concurrent change supporting reasoning change 
supports modelling concurrent object oriented systems simple direct way 
initial models intuitively understood providing junk confusion realizable wide spectrum logical language maude supporting executable specification programming 
maude high level language high performance system supporting equational rewriting logic computation 
maude new version greater generality expressiveness particular maude allows rewrite conditions essential implementation semantic definitions going 
rewriting logic maude data hand state system formally specified algebraic data type means equational specification 
kind specifications define new types means keyword sort subtype relations types subsort operations op building values types giving types arguments result may attributes associative assoc commutative comm example equations eq identify terms built operators 
functional module syntax fmod endfm defines natural numbers addition operation fmod natural numbers sort nat op nat op nat nat op nat nat nat assoc comm 
vars nat eq eq endfm equations assumed confluent terminating equations reduce term unique canonical form equivalent represent value 
maude uses expressive version equational logic membership equational logic addition allows statement membership assertions mb characterizing elements sort 
example extend natural numbers module memberships mb mb defining subsort natural numbers 
notice fly declaration variable sort 
maude variable identifier composed name colon sort name way variables declared variable declarations declarations allowed convenience 
membership equational logic notion implicit error called kinds maude explicitly declared represented sort names square brackets 
kinds declare partial operations level sorts example integer division operation natural numbers op div nat nat nat notice possible way treating partiality membership equational logic 
example define subsort nznat non zero natural numbers declare div total operation op div nat nznat nat dynamic behaviour distributed system specified rewrite rules form describe local concurrent transitions system 
part system matches pattern transformed corresponding instance pattern rewrite rules included system modules syntax mod endm 
example module defines non deterministic natural numbers non deterministic choice 
module import include definitions module means keyword short including 
mod nondeterministic natural numbers natural numbers sort subsort nat op assoc comm 
var nat var nd rl choice nd endm multiset natural numbers regarded non deterministic natural number sort number multiset 
operation denotes union non deterministic natural numbers associative commutative choice rule provides non deterministic choice 
rewrite rules take general possible form variant rewriting logic built top membership equational logic form ui vi wj sj pk qk restriction new variables may appear righthand side condition 
conditions rules formed associative conjunction connective allowing equations ordinary equations matching equations new variables occurring instantiated matching memberships rewrites conditions 
full generality execution system module require strategies control metalevel instantiation extra variables condition righthand side 
quite general class system modules called admissible modules executable maude default interpreter 
essentially admissibility requirement ensures extra variables eventually instantiated matching 
executing conditional rule satisfaction conditions attempted sequentially left right notice fact matches equational conditions may possible due presence equational axioms deal fact solving rewrite conditions requires search including searching new solutions previous ones fail satisfy subsequent conditions 
default interpreter supports search computations 
search command looks rewrites term match pattern satisfying condition see examples section 
maude feature important intended semantics applications frozen attribute 
operation declared frozen arguments rewritten rules possible declare operations arguments frozen generality 
important situations rewriting process happen top operational semantics process algebras ccs see section reasons frozen attribute related general avoiding situations non termination execution rewrite conditions explain detail section 
maude viewed metalanguage syntax semantics computational models languages formally defined entire environments languages built including parsers execution environments pretty printing input output 
see environment kind built lotos section 
reflection main feature achieve powerful metalanguage functionalities 
rewriting logic reflective finitely rewrite theory universal sense represent finitely rewrite theory including terms terms equivalence intuitively means theories data metalevel combining manipulating controlling rewriting process 
maude key functionality universal theory efficiently implemented functional module meta level maude terms reified elements data type term maude modules reified terms data type module process reducing term normal form reified function process applying rule system module subject term reified function 
basic operations combined build strategies control process rewriting 
search reified metalevel means operation metasearch section receives arguments module starting term search pattern search side condition kind search may zero rewrites rewrites 
matching normal forms depth search required solution number index possible solutions 
returns term matching pattern type substitution produced match 
creating environment language maude need generic syntax definition meta pretty printing capabilities deal expressions language including languages maude modules user definable syntax 
need general facility input output customized language interest 
section explains done maude reflective design application techniques development tool full lotos 
functional language fpl description implement structural operational semantics maude simple functional language 
fpl functional programming language language arithmetic 
syntactic categories prog op op var dec bop bop bx bvar exp num bexp 
definitions 
xk 
xk op bop op 
ek bx bop equal syntax fpl 
boolean expressions local variable declarations function declarations defined user possibility mutual recursion function calls 
describe implementation different semantics fpl quite evaluation semantics detailed computation semantics concrete semantics uses machine 
different functional language mini ml implemented section 
functional syntax definition syntax fpl obvious intuitive meaning described 
program consists expression declaration intuitively supplies definitions function names membership axioms define program correct functions defined done order simplify presentation 
syntax implemented functional module fpl syntax 
note signature structure corresponds grammar structure defined syntax language prec attribute associate precedence values different operators parentheses necessary disambiguate terms 
addition expected really executable semantics fill details textbook presentation left definition natural numbers case 
fmod fpl syntax protecting qid sorts var num op exp bvar boolean bop bexp varlist prog dec op qid var subsort var exp subsort num exp op bv qid bvar subsort bvar bexp subsort boolean bexp op fv qid ops op op num op num num subsort exp op assoc prec op exp op exp exp prec op bexp exp exp exp prec op var exp exp exp prec op exp prec ops boolean ops bop op bexp bop bexp bexp prec op bexp bexp prec op equal exp exp bexp subsort var varlist op varlist varlist varlist assoc prec subsort varlist subsort num op assoc prec subsort op exp dec prog op nil dec op varlist exp dec prec op dec dec dec assoc comm id nil prec op exdec dec eq exdec fv fac equal fv fac fv rem equal equal fv rem fv double endfm predefined quoted identifiers sort qid representing variable identifiers language fpl 
declaring sort subsort var qid represent boolean variables constructors bv transform values sorts var bvar respectively 
arithmetic constants natural numbers peano notation constructors addition complete syntax fpl module includes constant exdec set function declarations 
syntax fpl common semantic definitions going see sections 
order easier representation maude different semantics changes done module fpl syntax 
changes done prefer different versions order point small differences 
define functional module ap operation ap application binary operator evaluated arguments 
module supplies details usually left textbook presentation semantics 
third functional module env define environments associate values variables arithmetic boolean 
modules independent concrete representation semantics 
fmod ap protecting fpl syntax op ap op num num num vars num eq ap eq ap ap eq ap eq ap ap ap eq ap eq ap eq ap ap op ap bop boolean boolean boolean var bv bv boolean eq ap bv bv eq ap bv eq ap bv eq ap bv bv endfm fmod env protecting fpl syntax sorts value variable subsorts num boolean value subsorts var bvar variable sort env op mt env op variable value env prec op env env env assoc id mt prec op env variable value op env value variable env prec op remove env variable env vars variable var value var rho env eq rho rho fi eq rho remove rho eq remove mt mt eq remove rho rho remove rho fi endfm operations mt module env build empty environments singleton environments union environments respectively 
operation look value associated variable environment defined recursively means equation 
operation modify binding variable value environment defined means auxiliary operation remove eliminates variable environment 
evaluation semantics evaluation semantics fpl means relations corresponding respectively arithmetic boolean expressions 
evaluating arithmetic expression need environment assigns concrete values variables occurring set declarations giving context function names judgements semantics form happens boolean expressions function calls arithmetic expressions expressions build boolean expressions cr opr ifr op ap op ei vi 
vk xk 
ek 
xk evaluation semantics fpl bv bv bop ap bop bv bv equal equal bx bx evaluation semantics boolean expressions means equal operator 
judgements evaluating boolean expressions form bv 
definition semantic rules transition relation shown corresponding ones transition relation 
rule says evaluating 
ek arguments evaluated body definition evaluated environment formal parameters bound values corresponding actual parameters 
mechanism known call value 
see alternative known call name 
semantics uses operation ap applying binary operator arguments implemented module ap 
variable environments operation modification bindings implemented module env 
module evaluation rewrite rules representing evaluation semantics fpl arithmetic boolean expressions 
mod evaluation protecting ap protecting env order represent semantic rules maude elements sides arrow judgement represented terms maude 
semantics left set declarations environment expression 
elements represented term sort statement 
right arithmetic boolean expression list arithmetic expressions see moment 
notice sort statement ensure sides rewrite rules going common sort 
sort statement subsorts num boolean statement op dec env exp statement prec op dec env bexp statement prec op dec env statement prec axioms semantic rules premises translated unconditional rewrite rules transition simply rewrite rule 
rules cr examples 
vars dec var rho env var num var var var bx bvar var num var bv bv boolean var op op vars exp vars bexp var bop bop var var el var xl varlist var vl rl cr rho rl rho rho rest semantic rules premises translated conditional rewrite rules main rewrite corresponds transition rewrites conditions correspond transitions premises 
conditions ordered remember checked sequentially left right information flow condition happens rule value obtained condition second 
crl opr rho op ap op rho rho crl ifr rho rho rho crl ifr rho rho rho crl rho rho rho rule presents problem number premises fixed depends concrete function call evaluated specifically number arguments 
solve problem considering list actual parameters new syntactic category consisting non empty lists arithmetic expressions write semantic rule evaluates lists expressions 
modified rule new rule evaluation lists expressions el vl vl xl el xl el vl el vl representation rewrite rules follows call value crl rho el rho el vl xl rho vl xl crl rho el vl rho rho el vl note condition xl rule extracts set declarations declaration corresponding function resolution conditions matching modulo associativity commutativity binds variables xl 
semantic rules boolean expressions represented way 
semantic rule side condition second rule represented condition rewrite rule see rule 
rl rho rl rho rl rho bx rho bx crl rho bop ap bop bv bv rho bv rho bv crl rho rho crl rho rho crl rho equal rho rho crl rho equal rho rho endm module evaluation admissible module directly executable maude 
show examples 
semantics illustrated example program rem declaration function rem calculates remainder dividing set declarations exdec module fpl syntax section includes recursive declaration function rem recursive declaration factorial function fac 
command evaluates program maude implementation 
maude rew exdec mt fv rem rewrites ms cpu ms real rewrites second result num maude takes approximately milliseconds rewriting term quite simple seconds calculating factorial maude rew exdec mt fv fac rewrites ms cpu ms real rewrites second result num adapted output decimal representation 
time equations operation ap 
modify syntax predefined sort nat subsort num predefined builtin operations definition ap efficiency profit considerable examples show maude rew exdec mt fv fac rewrites ms cpu ms real rewrites second result nznat maude rew exdec mt fv fac rewrites ms cpu ms real rewrites second result nznat search command check expression reduced unique value semantics deterministic 
maude search exdec mt fv fac num solution state num solutions 
command useful prove transition possible semantics derivable semantic rules 
example execution proves judgement fac derivable fpl evaluation semantics fac factorial function 
maude search exdec mt fv fac solution state empty substitution solutions 
ask maude trace rewriting process showing order rules applied 
order able show result trace simple example 
trace modified hand clarify steps shows evaluation semantics rules applied calculate factorial 
numbers enumerate rule applications correspond numbers enumerate different judgements derivation tree 
tree show set function declarations change proof 
maude rew exdec mt fv fac rule cr exdec mt rule exdec rule cr exdec rule exdec equal rule exdec mt eq eq 
fac fac eq fac mt fac derivation tree fac call value 
rule exdec rule cr exdec rule opr exdec ap rule exdec rule cr exdec rule exdec equal rule cr exdec rule ifr exdec equal fv fac rule exdec fv fac rule opr exdec fv fac ap rule ifr exdec equal fv fac rule exdec mt fv fac rewrites ms cpu ms real rewrites second result num said rule corresponds call value 
alternative call name evaluate parameters simply substitutes directly body definition 
rule describing behaviour 
ek xk 
ek 
xk simultaneous substitution operation substitute expressions 
ek actual parameters variables 
xk expression definition substitution operation take account peculiarities free bound variables avoid capture variables way free variables substituted 
substitution may introduce new variables appear functional module substitution defines operation 
case simultaneous substitution 
ek xk assume substituted variables occur reduced simple substitutions 
operation new finite set variables vs returns variable vs obtain value variables tried variable set 
new variable needed substituting expression declares variable occurring substituting expression 
fmod substitution protecting fpl syntax protecting string protecting number conversion sort varset op mt varset subsort var varset op varset varset varset assoc comm id mt eq idempotency fvar returns set free variables expression 
op fvar exp varset op fvar bexp varset op fvar varset op var varset bool op var varset bool op varset varset varset op new varset var op new varset nat var op newvar nat var var num vars var vars exp var op op var var bx bvar vars bexp var bop bop var el vars vs vs varset var nat var xl varlist eq fvar mt eq fvar eq fvar op fvar fvar eq fvar fvar fvar fvar eq fvar fvar fvar eq fvar el fvar el eq fvar el fvar fvar el eq fvar mt eq fvar mt eq fvar fvar eq fvar bop fvar fvar eq fvar bx mt eq fvar equal fvar fvar eq mt false eq vs vs eq vs vs eq mt vs mt eq vs vs vs vs vs vs vs fi eq newvar qid string eq new vs new vs eq new vs newvar vs newvar new vs fi substitution expression variable op exp exp var exp op bexp exp var bexp op exp var eq fi eq eq op op eq eq ceq fvar ceq fvar new fvar fvar eq el el eq el el eq eq eq bx bx eq bop bop eq eq equal equal multiple simultaneous substitution op exp varlist exp eq el xl el xl endfm substitution defined write rewrite rule implements call name call name crl rho el xl rho el xl test semantics program rem evaluated command maude rew exdec mt fv rem rewrites ms cpu ms real rewrites second result num trace evaluation ac check computation expression affected change 
corresponding derivation tree shown 
maude rew exdec mt fv fac rule cr exdec mt rule cr exdec mt rule exdec mt equal rule cr exdec mt rule cr exdec mt rule cr exdec mt rule opr exdec mt ap mt mt mt eq mt mt mt mt mt mt eq mt mt eq fac mt fac mt fac mt eq fac mt fac derivation tree fac call name 
rule cr exdec mt rule exdec mt equal rule cr exdec mt rule ifr exdec mt equal fv fac rule exdec mt fv fac rule opr exdec mt fv fac ap rule ifr exdec mt equal fv fac rule exdec mt fv fac rewrites ms cpu ms real rewrites second result num computation semantics section implement computation small step semantics language fpl describes sequence primitive operations evaluation expression gives rise 
evaluation semantics variable environments function declarations needed 
semantic judgements evaluate arithmetic boolean expressions semantic rules define judgements shown respectively 
implementation semantics module fpl syntax section modifications 
expressing easiness clarity rule need operation building lists expressions identity element empty list shall see subsort exp op nil op assoc id nil prec op ap op op op op op ei 
ei 
ek 

ek 
vk 
vk xk 
xk bx bx computation semantics fpl bv bop bv ap bop bv bv bop bop bop bop equal equal equal equal equal equal computation semantics boolean expressions modules ap env substitution modification 
module computation contains implementation new semantic rules 
techniques previous section 
note rule expresses non deterministic choice arguments rewritten means pattern matching list arguments pattern el el modulo associativity identity empty list 
pattern includes cases arguments handled making empty lists 
mod computation protecting ap protecting env protecting substitution sort statement subsorts num boolean statement op dec env exp statement prec op dec env bexp statement prec vars dec var rho env vars exp var bx bvar vars num vars bv bv boolean var op op var var vars bexp var xl varlist var vl vars el el var bop bop var computation semantics fpl rl rho rho rl rho op ap op crl rho op op rho crl rho op op rho crl rho rho rl rho rl rho crl rho rho rl rho crl rho el el el el rho crl rho vl vl xl xl computation semantics boolean expressions rl rho bx rho bx rl rho bv bop bv ap bop bv bv crl rho bop bop rho crl rho bop bop rho crl rho rho rl rho rl rho crl rho equal equal rho crl rho equal equal rho crl rho equal crl rho equal endm implementation computation semantics evaluating expression rem considered previous section 
maude rew exdec mt fv rem rewrites ms cpu ms real rewrites second result exp equal equal fv rem obtained resulting expression step 
module computation admissible directly easy way know final value expression evaluated 
reason working computation semantics rule rewrite represents step 
righthand sides rewrite rules expressions lefthand sides terms sort statement set declarations environment expression 
way application rules concatenated transitivity rule rewriting logic apply rule resulting term longer match lefthand side rule 
hand structure lefthand side ensures rules applied top avoiding undesired rewrite steps inside expressions example 
solve problem implementing reflexive transitive closure transitions consider implemented follows rl zero rho step crl rho rho step rho rest executability problems rules zero try resolve condition rule giving rise infinite loops 
avoid problem different constructors build terms lefthand side rules 
way control rules applied resolve conditions 
op dec env exp statement prec op dec env bexp statement prec rl zero rho crl rho rho rho rl zero rho bv bv crl rho bv rho rho bv complete implementation evaluating expression rem 
maude rew exdec mt fv rem rewrites ms cpu ms real rewrites second result num show trace produced ac evaluated 
simplify show transitions relations removed applications rule zero rule times trace 
maude rew exdec mt fv fac rule exdec mt fv fac equal fv fac rule exdec mt equal rule exdec mt equal fv fac fv fac rule exdec mt fv fac fv fac rule exdec mt ap rule exdec mt fv fac fv fac nil nil rule exdec mt fv fac fv fac rule exdec mt fv fac equal fv fac rule exdec mt fv fac equal fv fac rule exdec mt equal rule exdec mt equal fv fac num fv fac rule exdec mt equal fv fac ei 
ei 
ek 

ek 
vk 
xk vk 
xk modification rules substitutions 
fv fac rule exdec mt fv fac rule exdec mt fv fac rule exdec mt ap rewrites ms cpu ms real rewrites second result num semantic rules syntactic substitution values variables expression 
environments precisely introduced purpose keeping bindings variables values preferable hiding part goal substitutions 
way removing substitutions define semantic rules done 
rewrite rules implement new semantic rules 
auxiliary operation build result expression second rule 
specifically operation takes arguments list 
xn variables list 
vn values vi value variable xi bound expression returns expression 
xk vk equations define recursively received lists 
op varlist exp exp eq nil nil eq eq xl vl xl vl crl rho rho crl rho rho rl rho crl rho el el el el 
syntactic categories st states control num stack env env bv boolean assoc cons constants 
definitions st env bv cons cons op bop equal pop env env bx bv bv states machine fpl 
rho crl rho vl xl vl xl evaluate expression rem new semantics 
result obviously coincides obtained previously 
maude rew exdec mt fv rem rewrites ms cpu ms real rewrites second result num machine fpl section concrete operational semantics fpl machine 
obtain way formal interpreter language executed virtual machine 
states machine tuples env stack values env environment finite list bindings variables values case control sequence 
syntax states shown 
describe machine works define relation states env env semantic rules define relation shown figures 
rules premises predicates env point value associated variable environment env 
show obvious definition predicates implemented means operations lookup module abs machine semantics 
functional module abs machine syntax defines syntax states machine 
fmod abs machine syntax protecting ap states machine fpl sorts constants assoc env stack control states op stack env control states prec op mts stack opm env op env op env bop env bop ifm env env env env env env env env env equal env equal analysis rules machine 
opm env op ap op env bv bv env bop ap bop bv bv env env env env env bx bv env bx bv env env env env bv bv env env env env env env equal env env equal env ifm env env env env env env env pop env env pop pop env pop env application rules machine 
op num stack stack op boolean stack stack op mtc control op exp control control prec op bexp control control prec op constants control control prec subsort op bop constants op var exp constants op exp exp constants op constants op equal constants op pop constants subsort constants op mte env subsort assoc env op env env env assoc id mte op var num assoc op bvar boolean assoc op var exp assoc endfm system module abs machine semantics implements analysis rules application rules machine 
note rules module rewrites conditions semantic rules figures premises transitions 
mod abs machine semantics protecting abs machine syntax op lookup env var num op lookup env bvar boolean op lookup env constants vars var vars num vars bx bx bvar vars bv bv boolean vars fv fv vars exp var op op var bop bop var bexp var env env var stack var control eq lookup env lookup env fi eq lookup bx bv env lookup env eq lookup fv env lookup env eq lookup env bx lookup env bx eq lookup bx bv env bx bx bx bv lookup env bx fi eq lookup fv env bx lookup env bx eq lookup env fv lookup env fv eq lookup bx bv env fv lookup env fv eq lookup fv env fv fv fv lookup env fv fi analysis rules machine rl opm env op env op rl opm env bop env bop rl env env rl env equal env equal rl ifm env env rl env fv env fv rl env env application rules machine rl opm env op ap op env rl opm bv bv env bop ap bop bv bv env crl env env lookup env crl env bx bv env bv lookup env bx rl env env rl env bv bv env rl env env rl env env crl env equal env crl env equal env rl ifm env env rl ifm env env endm crl env fv env pop lookup env fv rl env env pop rl pop env pop env calculating factorial see machine works 
rewrites semantics completely deterministic rewrite conditions rules lefthand side rewrites done top level 
reason modified trace produced maude order show sequentiality 
written dec complete declaration function fac show command rew introduced maude 
maude rew mts fv fac equal fv fac fv fac mtc mts dec fv fac mtc rule mts dec fv fac mtc rule mts dec fv fac mtc rule mts dec equal fv fac pop mtc rule ifm mts dec equal fv fac pop mtc rule mts dec equal fv fac pop mtc rule mts dec equal fv fac pop mtc rule mts dec equal fv fac pop mtc rule mts dec fv fac pop mtc rule ifm mts dec fv fac pop mtc rule opm mts dec fv fac pop mtc rule mts dec fv fac pop mtc rule mts dec fv fac pop mtc rule opm mts dec fv fac pop mtc rule mts dec fv fac pop mtc rule mts dec fv fac pop mtc rule opm mts dec fv fac pop mtc rule mts 
dec equal fv fac pop pop mtc rule ifm mts 
dec equal fv fac pop pop mtc rule mts 
dec equal fv fac pop pop mtc rule mts 
dec equal fv fac pop pop mtc rule mts 
dec equal fv fac pop pop mtc rule mts 
dec fv fac pop pop mtc rule ifm mts 
dec pop pop mtc rule mts 
dec pop pop mtc rule pop mts dec pop mtc rule opm 
syntactic categories prog com var op op bop bop bx bvar exp bexp num 
definitions skip op op bop bx bop equal mts dec pop mtc rule pop mts dec mtc syntax 
rewrites ms cpu ms real rewrites second result states mts dec mtc imperative language section operational semantics simple imperative programming language called 
program sequence commands modify memory collection addresses values stored 
done functional language fpl describe implementation evaluation semantics implementation computation semantics language 
implement semantics guarded command language generalization language obtained allowing non determinism 
imperative syntax definition syntax language shown implemented module syntax 
notice signature structure faithfully corresponds grammar structure defined syntax language 
fpl add definition natural numbers 
fmod syntax protecting qid sorts var num op exp bvar boolean bop bexp com prog op qid var subsort var exp subsort num exp op num op num num ops op op exp op exp exp prec op bv qid bvar subsort bvar bexp cr opr op ap op bx bx subsort boolean bexp 
bv bv bop ap bop bv bv equal equal evaluation semantics ops boolean ops bop op bexp bop bexp bexp prec op bexp bexp prec op equal exp exp bexp op skip com op var exp com prec op com com com assoc prec op bexp com com com prec op bexp com com prec subsort com prog endfm evaluation semantics evaluation semantics means relations corresponding syntactic categories exp arithmetic expressions bexp boolean expressions com commands 
environments keep value variables 
variables play quite different role played functional language fpl represent memory addresses said computation proceeds modifying contents memory 
reuse maude code module env memory terminology text 
evaluation relation arithmetic expressions takes pair containing expression memory returns value result evaluating expression memory 
happens relation boolean expressions 
definitions shown 
module evaluation exp implements relations 
sort statement describe structure rule lefthand side consisting memory expression 
num boolean subsorts statement ensuring sides rule common sort 
mod evaluation exp protecting env protecting ap sort statement subsorts num boolean statement op exp env statement op bexp env statement var num var var var st env vars exp var op op vars num var bx bvar vars bv bv boolean var bop bop vars bexp evaluation semantics expressions rl cr st rl st st crl opr op st ap op st st rl st rl st rl bx st st bx crl opr bop st ap bop bv bv st bv st bv crl equal st st st crl equal st st st crl st st crl st st endm evaluation relation commands takes pair containing command memory returns new memory 
intuitively returned memory result modifying initial memory means executed command 
way judgement means command executed memory execution finishes final state memory definition relation shown implemented module evaluation 
mod evaluation ifr skip protecting evaluation exp subsort env statement 
asr op com env statement var var vars st st st env var exp var num var bexp vars com evaluation semantics crl asr st st st rl skip st st 
evaluation semantics crl ifr st st st st st crl ifr st st st st st crl st st st st st st crl st st st crl st st st st st endm example application rules consider program equal skip skip computation semantics skip termination predicate 
calculates product saves result execute starting memory 
maude rew equal rewrites ms cpu ms real rewrites second result env computation semantics basic commands assignments modify memory changing value associated variable 
computation semantics describe basic operations command order 
judgement means command execute basic operation changes memory remainder executed 
section assume interested arithmetic boolean expressions computed define relations evaluation relations previous section 
rules defining relation commands shown indicates execution command finished 
definition termination predicate shown 
implementation semantic rules shown module computation 
termination predicate implemented means rules rewrite pair containing command memory constant tick 
rewrite rules needed equations predicate definition uses transitions premises rules 
mod computation protecting evaluation exp op com env statement sort statement op com env statement op tick statement var var vars st st env var exp var num var bexp vars com computation semantics crl st skip st st crl st st st st st crl st st st st st crl st st st st crl st st st tick st st crl st skip st st crl st st st termination predicate rl skip st tick crl st tick st st tick crl st tick st st tick crl st tick st tick st tick endm note rule example condition 
needed resolution condition st st means rewriting st zero times pattern st matched 
st bound condition solved attempt consists zero rewrites case matches st 
avoid case want step require 
execute example program previous section 
maude rew 
syntactic categories prog exp com bexp gc 
definitions skip gc fi gc od gc gc gc syntax 
equal rewrites ms cpu ms real rewrites second result statement skip command rew applies rewrite rules default strategy rule applied 
obtained result corresponds value returned evaluation semantics semantics deterministic 
need implement explicitly reflexive transitive closure transition section computation semantics fpl lefthand righthand sides rewrite rules form application rules concatenated 
command rew see obtained expression application rules 
example applications rules variable set loop unfolded 
maude rew equal rewrites ms cpu ms real rewrites second result statement equal language generalization language allows non determinism called 
language defined originally dijkstra convenient language development programs verification 
non determinism considered quite useful allows program designer delegate decisions taken account programmer compiler 
syntax language shown 
new syntactic category guarded commands appears elements general form 
ck 
module implements syntax having structure corresponding grammar 
fmod syntax protecting qid sorts var num op exp bvar boolean bop bexp com prog op qid var subsort var exp subsort num exp op num op num num ops op op exp op exp exp prec op bv qid bvar subsort bvar bexp subsort boolean bexp ops boolean ops bop op bexp bop bexp bexp prec op bexp bexp prec op equal exp exp bexp op skip com op var exp com prec op com com com assoc prec op fi com prec op od com prec op bexp com prec op assoc prec subsort com prog endfm guarded command boolean expression bei guards corresponding command ci executed control goes guard bei bei evaluated true 
command gc fi command associated true guard executed 
guard true considered execution error produced 
way command gc od generalization command 
guarded command gc executed repeated way guards true 
termination takes place guards false 
intuitive ideas formalized computation semantics defines transition relations gc uses evaluation semantics arithmetic boolean expressions 
formalize fact boolean guards guarded command false failure predicate needed 
defined inductive way 
termination predicate case simpler defined 
module computation implements computation semantics language 
mod computation protecting env protecting ap protecting evaluation exp op com env statement op env statement skip gc gc gc fi gc gc gc od gc od gc gc gc gc gc gc gc fails gc od skip gc gc gc gc gc computation semantics gc 
fails gc fails gc fails gc gc fails failure predicate 
skip termination predicate 
sort statement op com env statement op tick statement op env statement op fails statement var var vars st st env var exp var op op vars num var bexp vars com vars gc gc computation semantics crl st skip st st crl gc fi st st gc st st crl st st st st crl st st st tick st st crl gc od st gc od st gc st st crl gc od st skip st gc st fails crl st st st crl gc gc st st gc st st crl gc gc st st gc st st failure predicate crl st fails st crl gc gc st fails gc st fails gc st fails termination predicate rl skip st tick crl st tick st tick st tick endm non determinism appears means rules 
lefthand side applied assuming gc gc true guard 
failure termination predicates implemented means rules previous section 
case necessary rewrite rules define termination predicate rewrites conditions refer predicate 
way define predicate means boolean operation 
notice attribute define predicate cases easy way 
op tick com env bool eq skip st tick true ceq st tick true st tick st tick eq st tick false predicate rule modified way crl st st st tick st st illustrate semantics execute command borrowed page od start execute command memory assuming appropriate rules operation different states reached 
ask maude show final reachable states command search version allow steps find desired term 
maude search od skip st env solution state st solution state st solution state st solutions 
mini ml section implement evaluation semantics natural semantics functional language mini ml described kahn 
syntax defined 
notice syntax presentation closer signature algebraic specification 
syntax defines calculus extended products letrec 
expression pattern identifier variable pair patterns pattern 
mini ml syntax implemented means module fmod mini ml syntax protecting qid sort nats var op nats op nats nats ops true false op id qid var sorts exp ident pat subsorts exp ident constructors patterns pat ident pat pat pat expressions number exp false exp true exp ident ident lambda pat exp exp exp exp exp exp exp exp exp apply exp exp exp pat exp exp exp letrec pat exp exp exp sorts exp value pat lambda subsorts var pat op op pat pat pat op var var var subsorts nats value op value value value syntax mini ml 
subsorts value var lambda exp op exp exp op exp exp exp prec op exp exp op exp exp exp op exp exp exp exp prec op exp exp exp op exp exp exp prec op pat exp lambda prec op pat exp exp exp prec op letrec pat exp exp exp prec endfm mini ml semantics defined means judgements form mini ml expression environment result evaluation 
functions number true true false false true val ident ident false letrec evaluation semantics mini ml 
handled value example passed parameters functions returned value expression 
semantic values integer values boolean values true false closures pattern expression environment pairs semantic values form course pairs giving rise trees semantics values 
semantic rules mini ml shown 
implementation environments semantic rules operator letrec problematic treated quite straightforward ideas described previous sections shown modules 
sort statement describe structure side rule including environment lefthand side 
operation val obtain value associated identifier environment 
fmod env including mini ml syntax sort pair op pat value pair prec sort env subsort pair env op nil env op env env env assoc id nil prec op clos lambda env value endfm mod mini ml semantics including env sort statement op env exp statement prec op val env var statement prec subsort value statement vars ro ro env vars nats vars pat vars exp vars qid vars value rl number ro crl add ro ro ro sum op sum nats nats nats eq sum eq sum sum rl true ro true true rl false ro false false rl lambda ro clos ro crl id ro id ro val id crl ro ro true ro crl ro ro false ro crl pair ro ro ro crl app ro ro clos ro ro ro crl ro ro ro set val rl val ro id val id crl val ro id val id ro id crl val ro val id ro val id endm evaluate expressions examples 
example illustrate block structure language patterns expression evaluated 
maude rew nil id id id id id id id result nats higher order functions succ twice twice succ maude rew nil id succ id 
id id twice id 
id 
id id id id twice id succ result nats semantic rule operator letrec implemented direct way rule crl letrec ro letrec ro ro admissible due fact variable rewrite condition new variable appears side righthand side rewrite condition value obtained matching 
requires modify textbook presentation semantic rule defines operator 
call value doing sense allow recursive definitions abstractions kind values guarantee termination abstraction evaluates directly closure 
case reynolds presents page rule letrec variable parameter letrec letrec intuitive idea premise recursive definition unfolded 
call value argument letrec evaluated function evaluated closure 
generalized rule mini ml case definitions patterns letrec form regarding nesting contains abstractions form body function substituted letrec done previous simple case 
implementation maude equivalent corresponding formal definition op pat exp exp exp eq 
letrec eq crl letrec ro letrec ro ready evaluate examples letrec odd true odd false 
maude rew nil letrec id id odd id 
id true id odd id id 
id false id id id result false ccs section describe detail implementation structural operational semantics milner calculus communicating systems ccs 
main novelty respect implementation previous languages frozen attribute 
see maude implement kinds semantics illustrated semantics hennessy milner logic top ccs logic example need maude metalevel 
provide brief ccs 
assume set names elements set called names members disjoint union labels naming ordinary actions 
function extended defining special action called silent action denoted intended represent internal behaviour system particular synchronization processes means complementary actions set actions 
set processes intuitively defined follows inactive process 
action process process performs subsequently behaves processes process may behave processes represents running concurrently possible communication synchronization pair ordinary actions process finite relabelling function process behaves actions assuming 
process finite set ordinary actions process behaves actions prohibited 
process process identifier def defining equation may recursively involve process behaves intuitive explanation precise terms structural operational semantics shown defines labelled transition system ccs processes 
simplify presentation assumed operators summation parallel composition commutative associative syntax eliminating need symmetric cases corresponding rules 
ccs syntax define ccs syntax maude 
quoted identifiers represent labels process identifiers 
notice attributes assoc comm summation parallel composition operators 
non constant operators building processes defined frozen explain reason section 
pref rel par sum def res ccs operational semantics rules 
fmod ccs syntax including qid sorts label act process subsorts qid label act subsorts qid process op label label eq label label op tau act op process op act process process frozen prec op process process process frozen assoc comm prec op process process process frozen assoc comm prec op process label label process frozen prec op process label process frozen prec endfm def represent full ccs including possibly recursive process definitions means contexts 
defined contexts operations module ccs context 
includes constant context keep definitions process identifiers ccs specification 
fmod ccs context including ccs syntax sort context op def process context prec op nil context op context context context assoc comm id nil prec op context bool op def context process op context context vars var process vars context cmb def context eq nil false eq def eq def def def fi endfm notice union contexts partial operation defined level kinds context 
union contexts correct context defined process identifiers disjoint 
conditional membership axiom cmb establishes fact auxiliary operation 
implementation ccs operational semantics order implement ccs semantics maude transitions rewrites want interpret ccs transition rewriting logic rewrite 
rewrites labels essential ccs semantics label part resulting term obtaining way rewrite form value sort supersort process 
module admissible module directly executable includes ccs semantics implementation 
mod ccs semantics protecting ccs context sort subsort process op act frozen vars label var act vars process var prefix rl pref summation crl sum composition crl par crl par tau relabelling crl rel crl rel crl rel restriction crl res definition crl def context def context endm semantic representation rewrite rules property sort increasing rewrite sort bigger sort restrict terms formed sense assigned sort kind rule applied resulting term formed sort 
example correct transition derive righthand side term formed 
way rewrites allowed happen top process term inside term 
mechanism block undesired sort increasing rewrites implemented current maude system term rewriting happen level kinds level sorts 
solution declare syntax operators frozen prevents arguments corresponding operators rewritten rules see module ccs syntax section 
necessary previous sections additional structure environments put lefthand side rules directly disallowed application rewrite rules inside terms congruence rule rewriting logic applied concatenation rewrites transitivity rule 
presence rewrite conditions infinite processes infinite number successors frozen attribute useful going see right 
rewrite condition assume attribute frozen tried rewritten possible way result matched pattern instance correct application rule form rewritten result rejected 
problem appears recursive processes built search tries satisfy rewrite condition infinite terminate 
example recursive rewritten 
results going rejected formed 
rewrites correspond transition ccs semantics transitions occur top process 
frozen attribute solves previous problem appears want know possible rewrites process form sort process section implement modal logic semantics 
case rewritten rewrite matches pattern declare operator frozen 
summary frozen attribute ensure rewrites happen top avoid infinite loop search process know search unsuccessful search may unsuccessful different reasons built terms formed reason syntax operators frozen terms match pattern reason frozen 
disadvantage shape rewrite rules ccs semantics constructor operators declared frozen lost ability proving process perform sequence actions trace rules obtain step successors 
congruence rule rewriting logic operators frozen transitivity rule rules rewrite form rule pattern lefthand side 
problem want semantics definition modal logic semantics step successors needed 
solve extending semantics rules generate transitive closure ccs transitions follows sort subsort op process frozen crl refl crl tran ap ap notice dummy operator 
lefthand side rules lefthand side head rule rewrites conditions variables match term rule order solve condition giving rise infinite loop 
addition dummy operator declared frozen order avoid useless rewrites example 
dummy operator control rules want applied resolve conditions rules refl tran 
similar technique section different operator represent reflexive transitive closure transition relation resulting representation ccs rules semantically correct sense ccs process processes 
pk ak pk rewritten ak pk see 
maude search command find possible step successors process successors performing action 

refl weak tran ccs weak transition 
maude search ap solution state ap solution state ap solution state ap tau solutions 
maude search ap solution state ap solutions 
add equation module ccs semantics defining recursive process proc ccs context prove proc perform trace eq context proc def proc maude search proc process solution state process proc asked maude search way term proc rewritten pattern process 
search command performs breadth search conceptual tree possible rewrites term proc solution finds 
asked search solutions search terminate solutions search tree infinite 
proc proc proc proc 
extension weak transition semantics important transition relation defined ccs observe transitions 
defined row denotes reflexive transitive closure defined indicated second row 
implement transition relation means rewrites transition represented rewrite transition represented rewrite introduce dummy operators prevent undesired uses new rewrite rules verification rewrite conditions 
proposed implementation follows sorts act process op tau process act process frozen op act process frozen sort 
tt iff iff iff iff iff iff modal logic satisfaction relation 
subsorts act process op process frozen op process frozen rl refl tau crl tran tau tau tau crl weak tau tau notice new semantics operators tau dummy operators declared frozen reasons explained section 
search command look weak successors process performing action maude search tau tau ap solution state ap tau solution state ap solutions 
hennessy milner modal logic want implement hennessy milner modal logic describing local capabilities ccs processes 
formulas built grammar tt ff finite set actions 
satisfaction relation describing process satisfies property denoted inductively defined 
process satisfies formula tt satisfies formula ff 
process satisfies formula satisfies satisfies formula satisfies 
process satisfies formula built universal box modal operator step successors performing action set satisfy formula 
hand process satisfies formula built existential diamond modal operator successors satisfies 
definition satisfaction relation uses transitions ccs try implement level rules ones rl phi psi true phi true psi true rl dia phi true phi true implement behaviour conjunction existential modal operator 
rules correct exactly represent satisfaction relation modal logic expresses 
example condition second rule represents exists process definition diamond modal operator 
variable implicitly existentially quantified rule condition 
find problem definition box modal operator uses universal quantifier possible transitions process 
want possible step rewrites term need go metalevel 
operation metasearch defined operation succ returns successors process performing actions finite set 
definition operation succ module succ uses auxiliary operations 
evaluation returns step rewrites term skipping solutions match pattern rules module mod ccs semantics denoted term ccs semantics module succ shown 
evaluation filter ts returns processes term ts 
order look term term set compare terms module mod 
different terms qid act represent action module ccs semantics 
operation filter definition succ ts remove successors process processes reached performing action set ts 
having defined operations general form implement operation returns weak successors operations 
fmod succ including meta level op mod module eq mod ccs semantics sort termset subsort term termset op mt termset op termset termset termset assoc comm id mt op isin term termset bool op term machineint term termset op filter qid termset termset termset op succ term termset termset op term termset termset var module var qid vars term var machineint vars ts termset eq isin mt false eq isin ts mod true bool isin ts eq filter mt mt ceq filter ts isin mt fi filter ts eq metasearch mod nil failure mt metasearch mod nil fi eq succ ts filter ap ts eq ts filter ts endfm operations succ equationally implemented satisfaction relation modal logic 
notice semantics modal operators defined unfolding conjunction disjunction successors process 
fmod modal logic protecting succ sort ops tt ff ops ops termset ops termset ops forall exists termset bool op term bool var term vars ps termset vars phi psi eq tt true eq ff false eq phi psi phi psi eq phi psi phi psi eq phi forall succ phi eq phi exists succ phi eq phi forall phi eq phi exists phi eq forall mt phi true eq forall ps phi phi forall ps phi eq exists mt phi false eq exists ps phi phi exists ps phi endfm examples show prove maude modal formula satisfied ccs process 
example deals vending machine ven defined ccs context follows eq context ven def def big ven def little ven process ven may accept initially coin 
coin deposited big button may pressed big item collected 
coin deposited little button may pressed little item collected 
item collected vending machine goes back initial state 
properties vending machine satisfies buttons pressed initially coin inserted 
prove maude ven big little ff maude red ven qid big act little act ff result bool true satisfies coin deposited corresponding button pressed item big little collected 
maude red ven qid act act big act little act act act tt result bool true prove process satisfy formula 
example prove inserting coin vending machine possible press button big collect big item 
maude red ven qid act big act act tt result bool false second example deals railroad crossing system specified follows eq context road def car road rail def train green red rail signal def green red signal signal crossing def road rail signal green red system consists components road rail signal 
actions car train represent approach car train opens gates car car crossing closes gates green receipt green signal train train crossing red sets light red 
process crossing satisfies car train arrive crossing exactly possibility cross 
maude red crossing qid car act train act act tt act tt result bool true maude red crossing qid car act train act act tt act tt result bool false full lotos section go step implementation structural operational semantics presenting complete tool implemented maude full lotos specifications entered executed 
formal description technique lotos developed iso formal specification open distributed systems 
behaviour description part process algebras borrowing ideas ccs csp mechanism defining data types act 
union behaviour data type description parts known full lotos normally term lotos refer language 
lotos international standard lotos describe hundreds systems success due existence tools specifications executed compared analyzed 
lot done regarding lotos implementations 
standard defines lotos semantics means labelled transition systems data variable instantiated possible value 
reason tools ignore restrict data types 
calder defined symbolic semantics lotos gives meaning symbolic data parameterised processes see section avoids infinite branching 
section focus rewriting logic maude implement transitions rewrites approach complete formal tool symbolic semantics lotos specifications executed having impose restrictions data types 
reflective features rewriting logic properties maude metalanguage possible implement tool semantic framework 
specifically obtained efficient implementation operational semantics behaviour part lotos integrated act specifications automatically translated functional modules maude built entire environment parsing pretty printing input output processing lotos specifications 
aim implement formal tool knowledge concrete implementation semantics representation sufficiently level understood modified anybody familiar operational semantics 
lotos symbolic semantics implementation lotos symbolic semantics calder 
symbolic semantics lotos associating symbolic transition system lotos behaviour expression calder define symbolic transition systems sts transition systems separate data process behaviour making data symbolic 
sts labelled transition systems variables nat nat gx nat tt hy symbolic transition system 
tt hx states transitions conditions determine validity transition 
symbolic transition system consists non empty set states 
state associated set free variables denoted fv 
distinguished initial state 
set transitions written event boolean expression fv fv fv fv fv fv 
symbolic semantics open behaviour expressions label states example transitions offer variables conditions conditions determine set values may substituted variables 
intuition key features semantics axioms inference rules lotos operator 
representation maude section 
shows example sts 
see section obtained representation executable values apart predefined booleans 
lotos symbolic semantics parameterized set values data expressions 
want build usable formal tool need handle data types specified act 
defining data type representing act modules maude operations represent reduction process act implemented automatic translation act modules functional modules maude 
able maude highperformance reduction engine conservative way 
section translation show modules extended semantics 
section show semantics implementation act modules translation integrated build entire environment formal tool lotos specifications complete freedom data types possibly recursive process definitions entered executed means user interface completely hides concrete implementation details 
lotos symbolic semantics maude order implement lotos symbolic semantics maude transitions rewrites approach interpret lotos transition rewriting logic rewrite rewriting logic arrow labels write part righthand side term ccs case see section 
maude modules abbreviated due space reasons complete code 
lotos syntax different types syntax concrete syntax specifier see full details syntax semantic definition implementation introduced section 
defined maude functional module lotos syntax includes syntax 
predefined quoted identifiers build lotos variable sort gate process identifiers 
booleans predefined data type 
lotos syntax extended user definable way act data types specifications 
values data types extend type 
shall see done section 
fmod syntax protecting qid sort varid op qid varid sort subsort varid lotos variable data expression 
subsort bool booleans predefined data type 
endfm fmod lotos syntax protecting syntax sorts procid op qid op qid op qid procid sort op op exit op action frozen prec op frozen prec op frozen prec op hide frozen prec 
endfm lotos symbolic semantics implementation define contexts keep definitions processes introduced lotos specification 
order execute process instantiation process definition looked context 
actual context built lotos specification entered tool see done section 
semantics constant context assumed representing collection process definitions 
say semantics parameterized constant instantiated concrete specification 
fmod context protecting lotos syntax sort context op context context 
endfm implement lotos symbolic semantics 
show operations semantic definition problems implementing solved problems maude 
semantics set new var fresh variable names assumed 
mentioned strictly speaking set requires context variable names occurring far 
complicating implementation context preferred predefined maude utility imported module oracle constant defined 
time rewritten rewritten different quoted identifier 
definition set fresh variable names 
op new var varid eq new var data substitution written substituted easy implement equationally equations showing substitution operation distributes syntax behaviour expressions 
want allow user definable data expressions means act specification completely define operation know point syntax data expressions 
describe section module containing new syntax automatically extended define operation new data expressions 
op varid op varid vars var var offer var sp var varid var var gil var var event vars eq eq 
eq 
operation vars obtain variables occurring behaviour expression gives rise problem define completely level data expressions syntax user definable 
see section extended automatically new data expressions 
sort varset subsort varid varset op mt varset op varset varset varset assoc comm id mt eq idempotency op vars varset op vars varset eq vars mt eq vars vars eq vars vars vars eq vars 
mentioned transition behaviour expressions transition condition event represented rewrite righthand side term sort 
sort subsort op event frozen section rewrite rules sort increasing rewrite terms sort terms supersort 
avoids appearance bad formed terms subterms lotos operator behaviour expressions 
operator build values righthand side rewrite rules representing semantic rules declared frozen 
reason avoid undesired rewrites lead infinite searches 
way command search metalevel operation metasearch obtain step successors behaviour expression 
lotos symbolic semantics consists rules 
rules representation rewrite rules complete set rules 
show inference rules ease comparison mathematical maude representations 
inference rules exactly ones generalized allow multiple event offers action 
rules prefix operator show axioms represented rewrite rules conditions 
choice range rule shows non deterministic choice rewrite rules 
hide rules show side conditions inference rules added conditions rewrite prefix axioms tt 
dn tt ge 
dn sp sp ge ei di ei xi di xi si choice range rule gi 
gn gi rl true rl true rl sp sp op offer eq 
eq 
eq choice 
gn crl choice gil select gil gi gi sort 
subsort 
op select 
rl select rl select gil rl select gil select gil hide rules hide 
gn hide 
gn hide 
gn crl hide gil hide gil name gil crl hide gil hide gil name gil hide 
gn general parallelism rule synchronising 
gn 
gn ge 
en 
dom disjoint zi xi ei xi xi vars zi new var 
crl gil sp vars sp vars sp vars gil name gil delta name 
gn name 
gn name 
gn semantics rules implementation maude 
rules 
general parallelism rule shows external definitions defining substitution shown 
having implemented semantics rules behaviour expressions conservativity result lotos behaviour expression transition condition event behaviour expression rewritten rules 
concept term defined consisting sts paired substitution 
transitions terms defined 
implemented transitions way similar implementation transitions behaviour expressions see 
execution example maude search command find possible transitions behaviour expression 
maude search solution state true solution state true solutions 
maude search solution state true solutions 
write behaviour expressions syntax gate identifier data expressions apart predefined booleans introduced act specification 
specifications part full lotos specification user definable 
see sections give semantics act specifications integrated previous lotos semantics implementation 
act modules translation want able introduce tool user defined act specifications translated internally maude functional modules 
define act syntax 
maude syntax definition language accomplished defining data type done flexible user definable mixfix syntax mirror concrete syntax particularities lexical level accommodated user definable bubble sorts tailor adequate notions token identifier language question 
bubbles correspond pieces module language parsed grammar introduced signature module available 
specially important user definable syntax case act 
grammar act defined module grammar 
idea syntax language allows modules including syntactic characteristics defined user seen natural way syntax different levels call top level syntax language user definable introduced module 
bubble sorts allow reflect levels 
order illustrate concept consider act specification defining natural numbers modulo type nat sorts nat opns nat nat nat eqns nat boxed character sequences part top level syntax act 
fact parsed grammar associated signature specification nat 
having defined module act syntax metalevel operation receives arguments representation module representation list tokens returns parsed term parse tree may bubbles list tokens signature step consists defining operation translate receives parsed term returns functional module semantics introduced act specification 
syntactic analysis possible bubbles done second step 
translate notice start list quoted identifiers obtained user input see section 
translation achieve result act specification sp terms sp sp tm translate grammar sp tm representations presenting detail translation implemented see steps performed previous example module nat 
execute operation module grammar contains top level syntax act list quoted identifiers type nat sorts nat opns nat nat nat eqns nat obtain term includes tokens bubbles type token nat qid sorts token nat qid opns token qid token nat qid token qid token nat qid token nat qid eqns token nat qid bubble qid qid qid qid bubble qid tokens bubbles arguments lists quoted identifiers values sort 
values parsed going level representation user defined syntax opns part act specification 
execute operation commented obtain maude functional module sort fmod nat including syntax sorts nat subsort varid nat subsort nat op nil nat op nat nat eq nat nat endfm functional module translation maude nat specification act seen section 
translation performed operations defined metalevel op term op term op term operation main 
receives argument term returned returns translation functional module 
uses generalized operation arguments act specification translated maude module translation maude module signature translated part 
vars term vars module eq including syntax eq type token type token operation goes list declarations inside data type specification adds second argument translation element 
example act sort declaration sort translated maude sort declaration sort declare type subsort sort values declared type behaviour expression communicated sort lotos variables varid declared subsort type lotos variables build data expressions type 
done way want integrate act modules lotos specifications translation useful provides tool maude act specifications entered executed 
eq sorts token subsort subsort varid type naturals sorts nat opns nat nat nat nat nat nat eqns forall nat nat fmod naturals including syntax sorts nat subsort varid nat subsort nat op nat op nat nat op nat nat nat eq nat nat eq nat nat nat nat endfm act specification translation 
show translation example 
act specification left translated functional module right 
module extensions section saw operation performs syntactic substitution operation extracts variables occurring behaviour expression completely defined 
reason define completely defining semantics cases presence data expressions user definable syntax unknown moment 
know act specification translated functional module define operations data expressions new syntax 
due metaprogramming features maude automatically 
defined operations take module return module equations defining substitution extraction variables expressions built signature added 
example operation applied module naturals adds equations eq vars mt eq vars nat vars nat eq vars nat nat vars nat vars nat notice principle natural way defining operation nat terms constructors sort nat think equations 
defining operation expressions contain lotos variables third equation needed 
explain operation implemented 
argument module corresponding translation act specification 
operations declared build lotos expressions certain sort 
operation goes list operator declarations adds equation defining variables extracted terms top operator 
module unit includes operations building modules components sort declarations operations equations rules fmod module extensions protecting unit op module module op module module op qid typelist qid module module op typelist machineint termlist op qid termlist termlist var module vars op qid var args typelist var term var tl termlist var atts var ods var machineint eq eq eq op op args atts ods ods op args eq op nil eq vars conc op conc mt varset eq op args eq vars op args args nil vars args vars args fi eq conc conc index eq args args eq op op eq op tl op op tl endfm equations added operation equation eq vars saw section define extract variables lotos data expressions built user defined syntax 
building lotos user interface want implement formal tool complete lotos specifications act data type specifications main behaviour expression process definitions entered executed 
order execute simulate specification want able traverse symbolic transition system generated main behaviour expression symbolic semantics instantiated data types act process definitions 
main ideas implementation full details 
module defines commands tool 
fmod lotos tool sign protecting lotos sign sort op show process op show transitions op show transitions 
op cont 
machineint op cont op show state endfm command show current process 
second third commands show possible transitions defined symbolic semantics current explicitly process start execution process 
fourth command continue execution possible transitions indicated argument command 
command cont shorthand cont 
sixth command show current state execution current condition trace possible transitions 
lotos input processing lotos behaviour expressions introduced part specification tool command transformed elements data type module lotos syntax section 
parse tree returned module lotos grammar may bubbles data expressions may appear parsed userdefined syntax 
syntax obtained translating types defined act functional modules explained 
behaviour define new syntax declare new lotos variables means offers variables may appear expressions 
example processing behaviour expression nat data expression parsed fact variable sort nat 
operation perform translation 
takes arguments term returned representing behaviour expression module data types syntax obtained act specification set free variables may appear behaviour expression 
returns behaviour expression bubbles 
uses operation term action bubbles returns variables declared action 
operation takes expression bubbles module syntax expression parsed set lotos variables may appear expression expression scope variables 
order correctly parse expression bubbles information variables included expression maude variables 
resulting term may maude variables transformed lotos variables form quoted identifier 
operation build context includes definitions processes declared specification 
tool state handling tool persistent state system single object maintains tool state 
object attributes semantics keep actual module behaviour expressions executed module lotos semantics section extended syntax semantics new data expressions keep behaviour expression labels node symbolic transition system reached execution transitions keep set possible transitions trace keep sequence events performed path root sts current node condition keep conjunction transition conditions path input output handle communication user 
declare class notation classes object oriented modules class semantics module term transitions trace term condition term input output describe means rewrite rules behaviour tool lotos specification different commands entered system 
example rule processes lotos specification entered system 
allow lotos specifications arguments name specification act specification defining data types main behaviour expression list process definitions act specification list processes empty 
local declarations allowed 
specification entered semantics attribute set new module built follows act part specification translated functional module equations defining extraction variables substitution added explained section resulting module joined module lotos semantics equation defining constant context section definitions processes specification added 
attribute updated behaviour expression introduced specification having converted term sort rest attributes initialized 
rl spec input specification behaviour token output nil semantics transitions ts trace condition atts input output introduced specification getname semantics eq context context syn sem syn mt transitions mt trace nil trace condition true bool atts tool commands handled rules 
example rule handles show transitions command 
modifies transitions attribute operation receives module semantics implementation extended syntax semantics data expressions term representing behaviour expression returns sequence terms representing possible transitions uses operation metasearch represents metalevel search command section 
lotos tool environment input output specifications commands accomplished predefined module loop mode provides generic read eval print loop 
module operator seen persistent object input output channel third arguments respectively state second argument 
complete flexibility defining state 
tool object class 
written maude prompt enclosed parentheses placed slot loop object list quoted identifiers 
parsed adequate grammar parsed term put input attribute tool state object 
rules describing tool state handling process 
output handled reverse way list quoted identifiers placed third slot loop printed terminal 
execution example give example interaction lotos tool 
simple example tool execute larger examples including alternating bit protocol sliding window protocol lines code 
tool proved quite practical giving answer entered commands milliseconds 
maude specification spec type naturals shown behaviour 
nat 
maude show transitions trace nil condition true transitions 
true 
maude cont trace condition transitions 
true maude cont trace condition transitions comparison lotos tools concurrency workbench new century cwb nc automatic verification tool systems specification languages executed analyzed 
regarding lotos cwb nc accepts basic lotos support value passing process algebras 
design system exploits language independence analysis routines localizing procedures enables users change system description language process algebra compiler translates operational semantics definitions sml code 
followed similar approach tried keep semantics representation level losing executability 
implemented semantics hennessy milner modal logic ccs section subset full corresponding logic lotos 
implementations follow idea operation calculate onestep successors process turn uses operational semantics definitions 
implementation formal analysis algorithm representation maude modal logic semantics cases resulting similar achievements cwb nc keeping separated language specific features general ones 
caesar aldebaran development package cadp toolbox protocol engineering functionalities interactive simulation tool formal verification 
order support different specification languages cadp uses low level intermediate representations forces implementer new semantics write compilers generate representations 
cadp implement full severe restrictions finite types standard semantics lotos symbolic full 
transitions judgements mentioned general possibility represent rewriting logic operational semantics consists mapping inference rule form 
sn rewrite rule form 
sn rewrites multisets judgements going premises rewriting rewrite rules corresponds searching proof bottom way 
summarize main ideas approach transitions judgements inference rules rewrites 
illustrate ideas evaluation semantics fpl section 
implementation ccs operational semantics hennessy milner modal logic approach 
directly modules fpl syntax syntax fpl ap definition application operation ap semantics env definition environments variables section independent operational semantics representation 
order represent semantic rules judgement represented term rho sort judgement built means operator important confuse arrow part operator arrow rewrite rule sort judgement op dec env exp num judgement prec general semantic rule set premises represented means judgement 
need data type representing sets judgements sort subsort judgement op op assoc comm id prec union constructor written empty syntax declared associative assoc commutative comm empty set identity element id 
matching rewriting take place modulo properties allowing way treatment syntax 
semantic rule implemented rewrite rule singleton set consisting judgement representing rewritten set consisting judgements representing premises 
axiom schemas semantic rules premises cr represented means rewrite rules rewrite representation empty set judgements 
semantic rule side condition represented boolean condition conditional rewrite rule 
show examples rl cr rho crl rho rho crl opr rho op rho rho ap op rl ifr rho rho rho rl ifr rho rho rho fact text comment maude rules displayed way emphasize correspondence usual presentation textbooks case horizontal line 
notice rules opr suffered modification order avoid patterns rho ap op lefthand side rewrite rule 
side condition 
way start transition proved valid backwards rewriting process maintaining set transitions fulfilled order prove correctness initial transition 
initial transition rewritten empty set valid transition operational semantics 
problems working approach 
new variables appear premises example rule opr new variables righthand side 
rules kind directly maude default interpreter metalevel strategy instantiate extra variables 
second problem rules applied rewrite judgement general possibilities lead empty set judgements 
deal computation tree possible rewrites judgement searching see branches leads 
general solutions problems modifying semantics representation object level controlling rewriting process means strategy metalevel 
presence new variables solved concept explicit metavariables similar context explicit lack knowledge new variables righthand side rewrite rule represent 
semantics explicit metavariables bind concrete values values known 
introduced semantics representation mechanisms deal bindings propagate judgements bound metavariable may 
modified representation rules new variables righthand side localized 
strategy controls rewriting process see charge instantiating variables order build new metavariables 
problem non deterministic application rewrite rules solved general search strategy defined metalevel 
strategy traverses conceptual tree possible rewrites term built rewrite rules representing semantics searching term representing empty set judgements 
transition represented root tree valid semantic transition 
ccs case extended operational semantics implementation including metavariables processes needed metavariables actions 
start search strategy judgement process righthand side ccs transition metavariable search reaches empty set metavariable bound step successors process lefthand side performing action extending search strategy find way reach empty set possible ways implemented operation returns successors process performing action 
operation implement hennessy milner modal logic ccs processes techniques dealing new variables non determinism ccs semantics defining rewrite rules rewrite modal logic judgement set judgements satisfied specified logic semantics 
search strategy check modal logic judgement true 
time strategy module rewrite rules defines search tree 
obtained levels representation 
ccs semantics rules level 
controlled search strategy second level operation returns successors process modal logic semantics defined 
modal logic semantics controlled search strategy third level 
comparison transitions rewrites approach transitions judgements approach marked role prover rewriting process corresponds finding proof initial judgement rewritten 
intuitively idea start transition proved valid backwards rewriting process goal directed way maintaining set transitions fulfilled order prove correctness initial transition 
set empty conclude initial transition correct transition initial transition rewritten empty set valid transition operational semantics 
hand transitions rewrites approach leads implementations marked role interpreters environment expression rules rewrite value reduced operational semantics 
maude allows implementation role prover interpreter 
metavariables solve problem new variables righthand side rule mentioned adaptation representation deal metavariables lateral effect obtained representation transitions judgements approach interpreter calculates expression value evaluated having start complete judgement includes value 
example want evaluate expression set declarations environment rho rewrite judgement rho result result metavariable 
rewriting process judgement metavariable bound result evaluating section saw search command useful transitions rewrites implementation prover check judgement derivable semantics rules 
opinion implementation transitions rewrites approach advantages 
implementation closer mathematical logical presentation semantics 
operational semantics rule establishes transition possible transitions premises possible precisely interpretation conditional rewrite rule rewrite conditions 
alternative approach needs auxiliary structures multisets judgements proved valid mechanisms generation new metavariables propagation concrete values known 
forced implement metalevel search strategy checks multiset reduced empty set generates new metavariables time needed 
necessity new metavariables strategy unavoidable 
search command maude handle rewrite rules new variables righthand side bound conditions happens kind implementations 
transitions rewrites approach necessity searching appears rewrite conditions maude system solves problem able handle conditions new variables bound condition 
differences things done object level level semantics representation metalevel reflection 
transitions judgements approach search strategy traverses conceptual tree possible rewrites term moving continuously object level metalevel 
implementations described search occurs completely object level considerably faster simpler 
related find literature works dedicated representation implementation operational semantics 
cite related 
probably closely related braga phd 
thesis describes interpreter specifications context peter mosses modular structural operational semantics 
interpreter implementation approach transitions rewrites making extension maude implemented reflective features maude allows conditional rules rewrites conditions 
maude obtaining considerable efficiency enhancement 
line continued integrating methods proposed order develop general method achieve modularity semantic definitions programming languages specified rewrites theories 
mentioned rich tradition rewriting logic give semantic definitions languages variety styles including lambda calculus prolog languages narrowing babel unity language calculus concurrent logic programming language programming language active networks plan uml metamodel specification language cryptographic protocols mobile agents system maude extension mobile computations mobile maude resource description framework rdf semantic web 
exhaustive bibliography subject refer 
exception applies calculus techniques applied ccs section papers rewrite rules rewrites conditions rules executed previous versions maude 
attempts get direct implementations operational semantics formal language representing inference rules operational semantics 
programs compiled prolog build executable type interpreters specifications 
implementations follow respects logic programming style great advantage maude consists possibility working hand data types defined user hand algebraic specifications modulo equational axioms 
strategies different depth search keeping underlying specification 
disadvantages inefficiency fact implementation specifications structural operational semantics prolog attractive due lack appropriate type system prolog authors higher order language prolog avoid problem 
reasons language rml relational meta language designed language executable specification natural semantics 
study properties natural semantics specifications identified determinable static way allowing optimizations implementation 
rml strong type system style standard ml supports inference rules natural semantics data type definitions means structural induction 
specifications rml translated intermediate representation easily optimized implemented style cps continuation passing style 
intermediate representation compiled efficient code 
theorem provers isabelle hol coq build models languages operational semantics 
isabelle hol nipkow formalize operational denotational semantics programming languages 
logical frameworks theorem provers represent inference systems 
interactive proof development environment coq calculus constructions extended inductive types represent calculus calculus applied ccs 
coq encode natural semantics 
works approach different obtaining executable representations focus getting models verified 
shown transitions rewrites approach implement wide variety structural operational semantics maude executable semantic framework 
needed precise details mathematical definition semantics ellipsis 
appears premises semantic rule 
maude facilities defining syntactic operators including associativity identity attributes pattern matching modulo properties allowed precise details clear easy way resolving example non deterministic choice arguments function call reduced 
able define level semantics syntactic substitution operation semantics definitions including generation new variables expression evaluated order avoid free variable capture 
mini ml example semantic rule corresponding letrec operator implemented directly 
problem original semantics operational moment need guess value want calculate order infer 
certainly kind semantic rule usual meaning intuitive 
solution consists finding alternative semantic rule implementable 
successfully representing semantics shown maude commands obtain kinds information 
higher control possible transitions needed implementation hennessy milner modal logic ccs reflection meta level predefined module provide valuable tool 
implement complete tools execute user language hide concrete representation semantics done full lotos 
want study analyze prove properties obtained semantics representations confluence termination 
properties refer concrete programs written language semantics represented applicable program general 
proved structural induction rules define semantics 
respect intend study extensions theorem prover 
symbolic semantics lotos section symbolic bisimulation modal logic full defined 
plan extend tool check processes bisimilar process satisfies modal logic formula 
implemented subset full data values techniques implement hennessy milner modal logic ccs processes section integrated tool 
part logic data values deserves study think kind theorem proving needed 
rewriting logic maude proved highly valuable subjects 
joint jos meseguer designing strategy language allows specifying strategy order rewrite term 
basic strategy rule labels meaning particular rule applied 
rule conditional rewrites conditions strategy expression may describe conditions resolved 
rewrite condition strategy say rewritten order find term matches particular say rewrite rules applied rewriting process 
basic strategies combined build greater strategies union concatenation disjunction means generalized iteration language able solve different elegant way problems section defining reflexive transitive closure computation semantics relation fpl section defining reflexive transitive closure ccs transition relation 
foresee strategy language quite useful implementation execution parallel functional language eden intend study different execution strategies influence semantics properties 
strategy language applicable operational semantics representations executable specifications general 
acknowledgments braga roberto francisco dur steven eker david de jos meseguer fernando orejas yolanda ortega miguel helpful comments previous presentations jos meseguer encouraging supporting research executable semantic frameworks 
caldwell mishra 
specifying checking fault tolerant agent protocols maude 
gordon hinchey editors international workshop md usa april 
revised papers volume lecture notes artificial intelligence pages 
springer 

jouannaud meseguer 
specification proof membership equational logic 
theoretical computer science 
bradley mart oliet 
transforming information rdf rewriting logic 
pe moreno editors sobre 
pages 
braga 
rewriting logic semantic framework modular structural operational semantics 
phd thesis departamento de inform tica cia universidade cat lica rio de janeiro brazil sept 
braga hermann meseguer mosses 
maude action tool reflection map action semantics rewriting logic 
rus editor amast th international conference algebraic methodology software technology volume lecture notes computer science pages 
springer 
braga meseguer 
modular rewriting semantics programming languages 
manuscript university illinois urbana champaign 
ortega mall pe mar 
eden paradise functional concurrent programming 
euro par volume lecture notes computer science pages 
springer 

implementing modal logic data processes 
kim pages 
calder 
adequate logic full lotos 
oliveira zave editors fme formal methods increasing software productivity volume lecture notes computer science pages 
springer 
calder 
symbolic semantics bisimulation full lotos 
kim pages 
degano gadducci 
ccs semantics proved transition systems rewriting logic 
kirchner kirchner pages 
clavel 
reflection rewriting logic metalogical foundations metaprogramming applications 
csli publications 
clavel 
tool 
quesada editors logic language information 
proceedings workshop logic language pages 
kronos 
clavel dur eker lincoln mart oliet meseguer quesada 
maude metalanguage 
kirchner kirchner 
clavel dur eker lincoln mart oliet meseguer quesada 
maude specification programming rewriting logic 
theoretical computer science 
clavel dur eker lincoln mart oliet meseguer talcott 
maude manual 
version 
computer science laboratory sri international june 
maude cs uiuc edu manual 
clavel dur eker lincoln mart oliet meseguer talcott 
maude system 
nieuwenhuis editor rewriting techniques applications th international conference rta valencia spain june proceedings volume lecture notes computer science pages 
springer 
clavel meseguer 
reflection membership equational logic sorted equational logic horn logic equality rewriting logic 
gadducci montanari pages 
cleaveland sims 
generic tools verifying concurrent systems 
science computer programming 
degano gadducci priami 
causal semantics ccs rewriting logic 
theoretical computer science 
denker millen 
integrated protocol environment 
editors proceedings darpa information survivability conference exposition discex hilton head island south carolina january pages 
ieee computer society press 
com discex 
despeyroux 
executable specification static semantics 
kahn macqueen plotkin editors semantics data types volume lecture notes computer science pages 
springer 
despeyroux 
formalism implement natural semantics 
research report inria 
dijkstra 
discipline programming 
prentice hall 
dur eker lincoln meseguer 
principles mobile maude 
kotz mattern editors agent systems mobile agents applications second international symposium agent systems applications fourth international symposium mobile agents asa ma zurich switzerland september proceedings volume lecture notes computer science 
springer sept 

executing lotos specifications smile tool 
vissers editors software development lotos 
kluwer academic publishers 
ehrig mahr 
fundamentals algebraic specification equations initial semantics 
eatcs monographs theoretical computer science 
springer 
felty gunter hannan miller nadathur scedrov 
lambda prolog extended logic programming language 
lusk overbeek editors proceedings th international conference automated deduction volume lecture notes computer science pages 
springer 
fern ndez 
cadp protocol validation verification toolbox 
alur henzinger editors proceedings eighth international conference computer aided verification cav volume lecture notes computer science pages 
springer 
fern ndez 
intuition rigorous 
foundations uml model verification tools 
editor international symposium software reliability engineering pages san jos california oct 
ieee press 
fern ndez 
seamless formalizing uml semantics metamodels 
halpin editors unified modeling language systems analysis design development issues pages 
idea group publishing 
furio honsell 
calculus inductive type theory 
theoretical computer science 
gadducci montanari editors 
proceedings fourth international workshop rewriting logic applications pisa italy september volume electronic notes theoretical computer science 
elsevier 
www elsevier nl locate entcs volume html 
logrippo 
validation environment lotos 
editors protocol specification testing verification xiii pages 
holland 
hussein logrippo 
executing large lotos specifications 
aggarwal editors protocol specification testing verification viii pages 
north 
hennessy 
semantics programming languages elementary structural operational semantics 
john sons 
hennessy lin 
symbolic bisimulations 
theoretical computer science 
hennessy milner 
algebraic laws nondeterminism concurrency 
journal acm jan 
ortega mall operational semantics parallel language eden 
parallel processing letters 

full formalisation calculus theory calculus constructions 
proc 
th international theorem proving higher order logic conference volume lecture notes computer science pages 
springer 
hoare 
communicating sequential processes 
prentice hall 
huet kahn paulin mohring 
coq proof assistant tutorial version 
technical report inria 
ishikawa meseguer watanabe futatsugi nakashima 
semantics object oriented specification concurrent reflective language rewriting logic 
proceedings imsa pages 
information technology promotion agency japan 
iso iec 
lotos formal description technique temporal ordering observational behaviour 
international standard international organization standardization information processing systems open systems interconnection geneva sept 
kahn 
natural semantics 
technical report inria sophia antipolis feb 
kim chin kang lee editors 
proceedings forte st international conference formal techniques networked distributed systems 
kluwer academic publishers 
kirchner kirchner editors 
proceedings second international workshop rewriting logic applications pont france september volume electronic notes theoretical computer science 
elsevier 
www elsevier nl locate entcs volume 
html 
mart oliet meseguer 
rewriting logic logical semantic framework 
gabbay guenthner editors handbook philosophical logic second edition volume pages 
kluwer academic publishers 
mart oliet meseguer 
rewriting logic roadmap bibliography 
theoretical computer science 
meseguer 
conditional rewriting logic unified model concurrency 
theoretical computer science 
meseguer 
membership algebra logical framework equational specification 
parisi presicce editor trends algebraic development techniques th international workshop wadt italy june selected papers volume lecture notes computer science pages 
springer 
milner 
communication concurrency 
prentice hall 
mosses 
foundations modular sos 
editors mathematical foundations computer science th international symposium mfcs poland september proceedings volume lecture notes computer science pages 
springer 
full version appears technical report rs brics dept computer science university aarhus 
nipkow 
winskel right mechanized semantics textbook 
formal aspects computing 
nipkow paulson wenzel 
isabelle hol proof assistant higher order logic volume lecture notes computer science 
springer 
pettersson 
rml new language implementation natural semantics 
hermenegildo editors programming language implementation logic programming th international symposium plilp volume lecture notes computer science pages 
springer 
pettersson 
compiler natural semantics 
editor compiler construction th international conference volume lecture notes computer science pages 
springer 
reynolds 
theories programming languages 
cambridge university press 

verified model checker modal calculus coq 
steffen editor tools algorithms construction analysis systems volume lecture notes computer science pages 
springer 

stehr 
cinni generic calculus explicit substitutions application calculi 
futatsugi editor proceedings third international workshop rewriting logic applications kanazawa japan september volume electronic notes theoretical computer science pages 
elsevier 
www elsevier nl locate entcs volume html 

stehr meseguer 
pure type systems rewriting logic 
proc 
workshop logical frameworks meta languages paris france sept 

stehr talcott 
plan maude specifying active network programming language 
gadducci montanari pages 
stirling 
modal temporal logics processes 
moller birtwistle editors logics concurrency structure vs automata volume lecture notes computer science pages 
springer 

encoding natural semantics coq 
editor proceedings fourth international conference algebraic methodology software technology volume lecture notes computer science pages 
springer 
sen mart oliet 
executable specification asynchronous pi calculus semantics may testing maude 
gadducci montanari pages 
fern ndez 
formally modeling uml evolution holistic approach 
smith talcott editors proceedings ifip conference formal methods open object distributed systems iv september stanford california usa pages 
kluwer academic publishers 
turner 
formal description techniques estelle lotos sdl 
john wiley sons 

building tools lotos symbolic semantics maude 
peled vardi editors formal techniques networked distributed systems forte nd ifip wg international conference houston texas usa november proceedings volume lecture notes computer science pages 
springer 

tool full lotos maude 
technical report 
sistemas inform universidad de madrid apr 
www ucm es sip alberto 

maude como marco sem 
phd thesis universidad de madrid 
mart oliet 
implementing ccs maude 
editors formal methods distributed system development 
forte ifip tc wg joint international conference formal description techniques distributed systems communications protocols forte xiii protocol specification testing verification xx october pisa italy pages 
kluwer academic publishers 
mart oliet 
implementing ccs maude 
gadducci montanari pages 

input output elan 
meseguer editor proceedings international workshop rewriting logic applications asilomar california september volume electronic notes theoretical computer science pages 
elsevier sept 
www 
elsevier nl locate entcs volume html 
vittek 
elan un cadre logique pour le de langages de programmation avec contraintes 
phd thesis universit henri poincar nancy nov 

wang meseguer gunter 
specification formal analysis plan algorithm maude 

editor international workshop distributed system validation verification pages 

