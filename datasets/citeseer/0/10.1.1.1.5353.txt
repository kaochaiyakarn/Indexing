sina scalable incremental processing continuous queries spatio temporal databases mohamed xiong walid aref department computer sciences purdue university west lafayette aref cs purdue edu introduces scalable incremental hash algorithm sina short new algorithm evaluating set concurrent continuous spatio temporal queries 
sina designed goals mind scalability terms number concurrent continuous spatiotemporal queries incremental evaluation continuous spatio temporal queries 
sina achieves scalability employing shared execution paradigm execution continuous spatio temporal queries abstracted spatial join set moving objects set moving queries 
incremental evaluation achieved computing updates previously reported answer 
introduce types updates positive negative updates 
positive negative updates indicate certain object added removed previously reported answer respectively 
sina manages computation positive negative updates phases hashing phase invalidation phase joining phase 
hashing phase employs memory hash join algorithm results set positive updates 
invalidation phase triggered seconds memory fully occupied produce set negative updates 
joining phase triggered invalidation phase produce set positive negative updates result joining memory data disk data 
experimental results show sina scalable efficient index spatio temporal algorithms 

increasing number computer applications rely large spatio temporal data sets essential provide efficient query processing techniques spatiotemporal databases 
examples applications supported part national science foundation iis eia iis iis eia 
permission digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
sigmod june paris france 
copyright acm 

clude location aware services traffic monitoring enhanced service 
traditional databases spatiotemporal databases concerned objects continuously change locations shapes time 
consequence adding temporal dimension spatiotemporal databases highly dynamic environments 
traditional applications spatio temporal applications location aware services distinguishing characteristics large number mobile stationary objects consequently large number mobile stationary queries 
spatio temporal queries continuous nature 
snapshot queries evaluated continuous queries require continuous evaluation query result invalid change information query database objects 
delay query response results obsolete answer 
example consider query asks moving objects lie certain region 
query answer delayed answer may outdated objects continuously changing locations 
distinguished characteristics call special spatio temporal query processing algorithms achieve scalability efficient evaluation continuous spatio temporal queries 
propose scalable incremental algorithm sina short continuously evaluating dynamic set continuous spatio temporal queries 
sina exploits main paradigms shared execution incremental evaluation 
utilizing shared execution paradigm continuous spatio temporal queries grouped joined set moving objects 
utilizing incremental evaluation paradigm sina avoids continuous reevaluation spatio temporal queries 
sina updates query results time units computing sending updates previously reported answer 
distinguish types query updates positive updates negative updates 
positive updates indicate certain object needs added result set certain query 
contrast negative updates indicate certain object longer answer set certain query 
result having concept positive negative updates achieve goals fast query evaluation compute update change answer answer 
typical spatiotemporal application location aware services traffic monitoring query results sent customers satellite servers 
limiting amount data sent positive negative updates query answer saves network bandwidth 
sina introduces general framework deals mutability combinations objects queries 
applicable stationary queries moving objects continuously report cars miles home moving queries stationary objects continuously report gas stations miles location moving queries moving objects continuously report police cars miles car location 
simplicity sina context continuous spatio temporal range queries 
discussed section sina applicable broad class continuous spatio temporal queries nearest neighbor aggregate queries 
general contributions summarized follows 
utilize shared execution paradigm means achieve scalability continuous spatio temporal queries section 

propose sina new algorithm incrementally evaluating set concurrently executing continuous spatio temporal queries 
incremental evaluation achieved computing positive negative updates previously reported answer section 

prove correctness sina proving completeness query results produced sina 
uniqueness sina produces duplicate free results 
sina reports updates previously reported answer section 

provide experimental evidence sina outperforms tree algorithms index frequently updated tree section 
rest organized follows section highlights related continuous spatio temporal query processing 
section introduce concept shared execution group spatio temporal queries 
section proposes scalable incremental hash algorithm sina 
extensibility sina variety continuous spatio temporal queries handle clients disconnected server short periods times discussed section 
correctness proof sina section 
section provides extensive list experiments study performance sina 
section concludes 

related research spatio temporal query processing focus continuously evaluating spatio temporal query time 
issues scalability incremental evaluation mutability objects queries client overhead examples challenges overlooked wholly partially approaches 
mainly different approaches investigated validity results 
query answer server returns valid time valid region answer 
valid time expired client goes valid region client continuous query reevaluation 
caching results 
main idea cache previous result client side assuming computational storage capabilities client side server side 
previously cached results prune search new results nearest neighbor queries range queries 
precomputing result 
trajectory query movement known apriori computational geometry stationary objects velocity information moving objects identify objects nearest neighbors range query trajectory 
trajectory information changes query needs reevaluated 
lot research optimizing execution multiple queries traditional databases see continuous web queries see continuous streaming queries see :10.1.1.19.8866:10.1.1.136.4253
optimization techniques evaluating set continuous spatio temporal queries addressed centralized distributed environments 
distributed environments assume clients computational storage capabilities share query processing server 
main idea ship part query processing moving objects server mainly acts mediator moving objects 
assumption realistic 
cases clients cheap low battery passive devices computational storage capabilities 
limited stationary range queries applied moving stationary queries 
distinguished approaches assume storage computational capabilities clients 
clients required submit minimal possible information servers mainly identifier location moving objects 
authors knowledge addresses scalability issue client overhead index 
main idea index build tree index structure queries objects 
time interval moving objects probe index find queries belong 
limited aspects performs reevaluation queries tree index time units 
applicable stationary queries 
moving queries spoil index dramatically degrade performance 
general spatio temporal queries evaluated spatio temporal access method 
tpr tree variants tpr tree index objects predictive trajectories 
special mechanisms support continuous spatio temporal queries access methods 
emulate continuity client may need issue query multiple times consecutive time intervals reevaluation 
addition spatio temporal access methods answer queries moving objects stationary objects 
proposed scalable incremental hash algorithm sina distinguishes approaches go idea reevaluating continuous queries 
incremental evaluation compute updates previously reported result 
addition sina assume computational capabilities client side 
sina scalable support large number concurrently outstanding continuous queries deal variations continuous spatio temporal queries 
table gives comparison sina previous approaches 
property sr dq cnn index tpr sina execution incremental model shared execution query moving queries stationary objects types stationary queries moving objects moving queries moving objects assumptions client overhead velocity assumptions select id location inside table comparison different algorithms continuous spatio temporal queries 
select id location inside file scan file scan file scan file scan spatial join moving objects moving objects moving objects moving queries local query plan range queries global shared plan range queries shared execution continuous queries 

shared execution continu ous spatio temporal queries section exploit shared execution paradigm means achieving scalability concurrently executing continuous spatio temporal queries 
main idea group similar queries query table 
evaluation set continuous spatio temporal queries abstracted spatial join moving objects moving queries 
similar ideas shared execution exploited niagaracq web queries psoup streaming queries :10.1.1.19.8866:10.1.1.136.4253
gives execution plans simple continuous spatio temporal queries find objects inside region find objects inside region 
query performs file scan moving object table followed selection filter 
shared execution execution plan 
table moving queries contains regions range queries 
spatial join performed table objects points table queries regions 
output spatial join split sent queries 
stationary objects gas stations spatial join performed tree index object table 
similarly queries stationary index query indexing 
objects queries highly dynamic tree index structures result poor performance 
avoid drawback follow approaches utilize techniques frequently updating tree see cope frequent updates moving objects moving queries 
spatial join algorithm assume existence indexing structure 
proposed scalable incremental hash algorithm sina utilizes second approach 
experimental results section compare sina approach highlights drawbacks advantages approach 
streams moving objects moving queries 
phase hashing memory hashing memory full timeout memory full timeout positive updates disk phase ii invalidation phase iii joining invalidation negative updates incremental result send incremental result queries 
done negative positive updates memory disk join state diagram sina 
done 
incremental evaluation continuous spatio temporal queries main idea scalable incremental hash algorithm sina maintain memory table termed updated answer stores positive negative updates course execution sent clients 
positive updates indicate certain object needs added query results 
similarly negative updates indicate certain object needs removed previously reported answer 
entries updated answer table form qid update list oid qid query identifier update list list oids object identifiers type update 
reduce size updated answer table negative updates may cancel previous positive updates vice versa 
sina sends set updates appropriate queries time units 
sina phases hashing invalidation joining phases 
provides state diagram sina 
hashing phase continuously running receives incoming information moving objects moving queries 
tuples arrive memory hash join algorithm applied moving objects moving queries 
result hashing phase set positive updates added updated answer table 
invalidation phase triggered time units memory full flush memory data disk 
invalidation phase acts filter joining phase invalidation phase reports negative updates ob snapshot time snapshot time example range spatio temporal queries 
jects save processing joining phase 
joining phase triggered invalidation phase perform join memory moving objects queries disk stationary objects queries 
joining phase results reporting positive negative updates 
joining phase completed positive negative updates sent users issued continuous queries 
section example illustrate ideas execution sina 
gives snapshot database time moving objects continuous range queries 
time objects queries change locations 
old query locations plotted dotted borders 
black objects stationary white objects moving 
term moving object queries time ti indicate set objects queries report change information evaluation time ti 
moving objects queries stored memory evaluation time ti 
similarly term stationary objects queries indicate set objects queries report change information evaluation time ti 
stationary objects queries stored disk evaluation time ti 
notice stationary objects queries time ti may moving objects queries time ti vice versa 
phase hashing data structure 
hashing phase maintains inmemory hash tables buckets sources correspond moving objects points moving queries rectangles respectively 
addition moving queries keep memory query table keeps track corresponding buckets upper left lower right corners query region 
symbols pk rk denote kth bucket respectively 
algorithm 
figures provide illustration pseudo code hashing phase respectively 
new moving object tuple hash value hp received step probe hash table rk moving queries join contain step 
queries satisfy join condition containment point objects query region add positive updates updated answer table step 
store hash bucket pk step 
similarly moving query tuple stream moving objects stream moving queries 
hash table hash table query table memory incremental join results phase hashing 
procedure tuple source 

memory accommodate start return 
source moving object hash value hp tuple 
sq set queries joining queries rk sq add updated answer store bucket pk return 
sk set buckets result hash function hr 
bucket sk set objects joining objects pk add updated answer store clipped part bucket rk 
store query table pseudo code hashing phase received probe hash buckets intersect objects satisfy join condition add positive updates updated answer table step 
tuple clipped stored buckets overlaps 
keep track list buckets intersects store memory query table bucket numbers upper left lower right step 
example 
example hashing phase concerned objects queries report change location time interval 
objects joined queries 
positive update reported 
discussion 
hashing phase designed deal memory overhead 
joining memory data disk objects queries performed joining phase 
fact hashing phase performs memory join hashing process enables sending early fast results users 
applications desirable user early fast partial results price slightly increasing total execution time 
similar ideas memory hash join studied context nonblocking join algorithms symmetric hash join xjoin hash merge join :10.1.1.56.701
object index oid pointer qid pointer ii grid index objects oid location timestamp qlist queries qid region timestamp olist query index phase ii invalidation 
procedure 
max grid cell 
moving object mo pk call invalidate object mo gk 
moving query mq rk mq gk update information mq gk insert new entry gk mq olist initialized updated answer call invalidate queries pseudo code invalidation phase phase ii invalidation data structure 
sketches data structures invalidation phase 
invalidation phase relies partitioning dimensional space grid cells objects queries stored grid cells locations 
handle skewed data distribution objects queries employ similar techniques map grid cells smaller size tiles round robin fashion 
tiles directly mapped disk pages 
object entry form oid loc qlist oid object identifier loc location object timestamp reported location loc qlist list queries satisfying 
query clipped grid cells overlaps 
grid cell query entry form qid region olist qid query identifier region rectangular region intersects timestamp reported region olist list objects satisfy region 
addition grid structure keep track auxiliary data structures object index query index 
object query indexes indexed oid qid respectively provide ability searching old locations moving objects queries identifiers 
algorithm 
pseudo code invalidation phase figures 
invalidation phase starts flushing non empty buckets contain moved objects step moved queries step corresponding grid cells disk 
gives pseudo code invalidating moving object mo simplicity sina context grid 
uniform grid substituted sophisticated structures fur tree quad tree structures 
procedure invalidate object object mo gk 

mo gk update location timestamp mo gk sq queries updated answer contains mo query sq mo qlist add mo updated answer mo qlist mo qlist sq return 
insert mo new entry gk timestamp qlist initialized updated answer 
gold old cell mo object index table 
gold null return 
retrieve old entry mo gold 
query qlist add mo updated answer table remove entry mo olist 
delete entry gold pseudo code invalidating moving objects mapped grid cell gk 
old entry mo gk means mo cross cell boundary 
update information mo gk step 
mo new entry gk insert new entry mo gk current timestamp qlist contains moving queries updated answer table satisfied mo step 
utilize auxiliary structure object index mo oid get old entry mo step 
queries qlist report negative updates updated answer table update corresponding step 
delete old entry mo step 
invalidation process moving queries starts flushing query parts corresponding disk cells step 
similar moving objects update old entry insert new 
compare inmemory query table disk query index 
moving query keep track set sk contains cells part old region query new query region step 
send negative updates object part query answer grid cell sk step 
delete old entry moving query 
example 
example invalidation phase concerned moving objects queries change locations time interval 
moving objects report updates cross cell boundaries involved query answer time 
negative update reported object crosses cell boundaries 
guarantee incremental results maintained negative tuple deleted joining phase 
object report negative update 
moving queries report result leave old cells 
query reports negative update procedure invalidate queries 
query mq memory query table 
sk set grid cells covered old value mq covered new value mq 
grid sk retrieve old entry mq cell olist add mq updated answer remove mq qlist 
delete entry pseudo code invalidating moving queries completely leaves old cell contains 
notice report negative update leave cell contains 
discussion 
invalidation phase uses object index query index retrieve old information moving objects moving queries cross cell boundaries respectively 
approach client send old location information new location information 
case need maintaining auxiliary data structures 
approach simplify sina save overhead lacks practicality 
main reason approach assumes client ability store old location information guaranteed clients 
objective sina assume minimal computation storage requirement clients 
auxiliary data structures keep track old locations utilized tree linked list frequently updated tree hash table 
invalidation phase sina limits access auxiliary data structures objects move cells moved objects case 
invalidation phase reports negative updates correspond moving objects cross cell boundaries moving queries leave old cells 
moving objects queries move cell boundaries defer invalidation process joining phase 
approach invalidation phase report negative updates moving objects queries regardless old locations 
approach incur redundant overhead 
joining phase cells contain cell moving objects queries fetched memory perform join objects queries 
computing negative updates cell movement invalidation phase results redundant operations phases 
invalidation phase acts filter avoid unnecessary joins joining phase 
phase iii joining data structure 
joining phase require additional data structure uses grid data structure utilized invalidation phase 
algorithm 
gives pseudo code joining phase 
grid cell joining phase performs spatial join operations joining memory objects disk queries steps join procedure 
max grid cell 
join moving objects memory bucket pk stationary queries disk grid cell gk 
moving object mo pk sq set queries results join query sq mo qlist add mo updated answer update olist stationary mo qlist sq add mo updated answer update olist mo qlist sq mo qlist 
join moving queries memory bucket rk stationary objects disk grid cell gk 
moving query mq rk set objects results join object mq olist add mq updated answer update qlist stationary mq olist add mq updated answer update qlist mq olist mq olist send updated answer table users empty memory data structure pseudo code joining phase ing memory moving queries disk objects steps 
moving object query get set queries objects applying spatial join algorithm respectively steps 
answer set report positive negative updates updating corresponding data structures 
performing spatial join grid cells send updated answer clients clear memory data structures 
example 
example phase moving object reports negative update 
object report updates disk stationary queries join new cell moving query 
moving object joined stationary query produces positive update 
notice positive update cancels corresponding previously reported negative update invalidation phase 
size updated answer table minimized incremental results maintained 
object produce results disk queries join 
moving queries reports negative update joined upper left corner cell 
query reports positive update result spatial join news cells covered 
reports 
query report updates object new region 
discussion 
joining phase joins cells new moving objects queries 
cells contain stationary moving objects queries processed joining phase 
addition cells contain stationary old information moving objects queries filtered processed invalidation phase cells contain snapshot time snapshot time querying time 
iteration joining phase deals grid cell 
cost iteration bounded number disk pages grid cell 
cpu time utilize plane sweep spatial join algorithm similar ones hash spatial join algorithms 

extensibility sina section explore extensibility sina support broad class continuous spatio temporal queries nearest neighbor aggregate spatiotemporal queries support clients may disconnected server short periods time sync clients 
querying queries termed predictive queries interested predicting locations moving objects 
example query alert non friendly airplane going cross certain region minutes 
support queries ddimensional moving objects report current locations xd time velocity vector vd 
predicted location xt moving object instance time computed xt 
extension sina support queries straightforward 
moving objects represented lines points 
hashing phase moving objects clipped hash buckets rectangular queries 
invalidation joining phases moving objects treated moving queries sense may span grid cell 
shared execution paradigm exactly fit queries 
moving queries need special handling ones original description sina section 
gives example querying 
moving objects ability report current location time velocity vector predict locations times 
range query interested objects intersect region time 
time rectangular query region joined lines representation moving objects 
returned answer set 
objects change locations 
new information sina reports positive update negative update indicate considered part answer set longer answer set snapshot time snapshot time nn spatio temporal queries nearest neighbor queries sina utilized continuously report changes set concurrent knn queries 
gives example knn queries issued points 
assuming queries issued time compute time answer traditional algorithms knn queries 
answer answer 
case circular range queries radius equal distance kth neighbor 
time object moved 
sina utilized allow shared execution queries compute updates previously reported answer 
notice change original sina utilize circular range queries rectangular range queries 
object intersect query region 
results invalidating furthest neighbor 
update tuples reported 
object part answer time 
moves joining phase checks inside query region 
outside circular query region compute nearest neighbor 
update tuples reported 
notice query regions changed reflect new nearest neighbors 
aggregate queries continuous spatio temporal aggregate queries addressed dense areas discovered online areas number moving objects certain threshold 
areas discovered limited pre defined grid cells 
dense area aligned grid cell discovered 
modeled special instance sina way grid consider having spatio temporal disjoint aggregate range queries query represents grid cell 
sina extend ability discover pre defined dense areas arbitrary regions 
important areas areas airport downtown discovered aligned grid cells 
pre defined dense areas treated range queries 
shared execution paradigm incremental evaluation sina continuously reports density areas 
positive negative updates report increase decrease density previously reported result 
sina server example sync queries sync clients mobile objects tend disconnected reconnected times server reasons control battery losing communication signals congested network sync behavior may lead erroneous query results incremental approach 
gives example erroneous query result 
answer query stored client server time time client disconnected server 
server recognize disconnected 
server keeps computing answer sends negative update 
client disconnected client receive negative update 
notice inconsistency stored result server side client side 
similarly time client disconnected 
client connected time 
server computes incremental result sends positive update 
time client able update result 
wrong answer correct answer kept server 
sina easily extended resolve sync problem adding catch phase 
catch phase 
naive solution catch phase client wakes empties previous result sends wakeup message server 
server replies query answer stored server side 
example time sina send answer 
approach simple implement process server side 
may result significant delay due network cost sending answer 
consider moving query hundreds objects result gets disconnected short period time 
query missed couple points disconnected time server send complete answer query 
save network bandwidth sina maintains repository committed query answers 
answer considered committed guaranteed client received 
client wakes disconnected mode sends wakeup message server 
sina compares latest answer query committed answer sends difference answer form positive negative updates 
example sina stores committed answer time 
time sina compares current answer committed send updates 
sina receives information moving query sina considers latest answer committed 
stationary queries required send explicit commit message sina enable committing latest result 
commit messages sent convenient times clients 

correctness sina section provide proof correctness scalable incremental hash algorithm sina 
correctness proof divided parts prove sina complete result tuples produced 
second prove sina duplicate free algorithm output tuples produced exactly 
third prove sina progressive new results sent user 
theorem 
sets moving objects moving queries sina produces output results join condition inside satisfied time instance proof 
assume time instance located inside tuple reported sina 
satisfies join condition exists hash bucket hp hr 
assume latest information sent time intervals ti ti tj tj respectively 
exactly possible cases case case reports information time interval ti ti 
guarantee resident memory time 
arrives stored bucket ph joining arrives probe bucket ph join proof applicable arrives tuple missed case case assume indicates arrives invalidation phase flushed disk arrives 
arrives stored memory hash bucket corresponds disk cell object joining phase joins memory hash buckets corresponding disk grid cells guarantee joined proof applicable memory object joined disk query tuple missed case cases conclude assumption reported sina possible 
sina produces output results 
theorem 
evaluation time ti sina produces output result corresponds information change ti ti exactly 
proof 
assume satisfies join condition 
assume sina reports tuple twice 
denote instances 
interested tuples satisfy join condition positive updates skip invalidation phase produces negative updates 
identify cases case produced hashing phase 
assume arrives arrives probes hash bucket outputs result 
hashing phase newly incoming tuples probe hash buckets produced hashing phase 
case produced joining phase 
joining phase produces positive updates outlets memory moving objects disk moving queries moving queries objects 
produced outlet moving object reports information ti ti 
produced second outlet concerned disk objects 
proof applicable produced second outlet 
tuple produced joining phase 
case tuples say produced hashing phase produced joining phase 
reported hashing phase guarantee memory moving time interval ti ti 
moving object moving query 
joining phase produced outlet stationary 
similarly produced second outlet stationary 
tuple produced joining phase 
cases conclude assumption tuple reported twice evaluation time ti valid 
theorem 
sets moving objects moving queries evaluation time ti sina produces changes previously reported result time ti 
proof 
assume satisfy join condition time ti 
time ti inside moved moved inside prove tuples produced time ti 
mainly identify cases case moving query moving objects 
case processed hashing invalidation phases 
theorem hashing phase produces updates 
invalidation phase deleted step moves cell boundary step moves cell adding counterpart tuple 
tuple produced invalidation phase step step 
case moving query stationary objects 
case processed invalidation joining phases 
answer set inside grid cell intersects old new regions processed joining phase particularly step 
old answer action taken 
object assume ci ci sets grid cells covered ti ti respectively 
grid cell 
answer set time ti ci ci 
ci ci tuple produced invalidation phase step 
ci ci tuple produced joining phase step 
object old answer processed invalidation phase 
tuple reported joining phase step 
case stationary query moving objects 
proof similar case road network map oldenburg city reversing roles queries objects 
include case stationary queries stationary objects 
assume moving stationary 
proof valid combination moving stationary cases conclude time ti sina produces change result previously reported answer time ti 
experimental results section compare performance sina having tree index object table 
cope moving objects implement frequently updated tree fur tree short 
fur tree modifies original tree efficiently handling moving objects 
having index query table 
index designed static queries modify original index employ techniques fur tree handle moving queries 
index handle moving queries efficient fur tree handles moving objects 
having fur tree moving objects modified index query table 
employ tree spatial join algorithm rsj short join objects queries 
network generator moving objects generate set moving objects moving queries 
input generator road map oldenburg city germany 
output generator set moving points moves road network city 
moving objects cars pedestrians choose points randomly consider centers square queries 
mentioned generate moving objects moving queries 
moving object query reports new information changed seconds 
space represented unit square query sizes assumed square regions side length 
sina adopted refresh query results seconds 
percentage objects queries report change information seconds moving objects queries respectively 
experiments section conducted intel pentium iv cpu ghz mb ram running linux 
sina implemented gnu 
page size kb 
implement fur tree index rsj original implementation tree 
performance measures overhead cpu time incurred 
consider levels treebased structures memory 
cpu time computed size answer bytes sina complete answer percentage moving objects moving objects size answer bytes sina complete answer query side length query size answer size sina number cells dimension time sec sina number cells dimension cpu time impact grid size time perform spatial join memory page retrieved disk 
sina cpu time includes time hashing phase consumes memory join 
properties sina size result compares size answer returned sina size complete answer returned non incremental algorithm 
percentage moving objects varies 
size complete answer constant orders magnitude size incremental answer returned sina 
complete answer affected moved objects 
sina size answer increasing slightly affected number objects evaluated seconds 
query side length varies 
size complete answer increased dramatically times incremental result returned sina 
saving size answer directly affect communication cost server clients 
number grid cells figures give effect increasing grid size cpu time incurred sina respectively 
small number grid cells cell contains large number disk pages 
spatial join cell results excessive cpu time 
hand large number grid cells cell contains small number moving objects queries 
results sina fur tree index rsj number objects time sec sina fur tree index rsj number objects cpu time scalability number objects lower cpu time spatial join performed tuples 
disk pages utilized 
additional overhead incurred 
experiment set number grid cells dimension 
number objects queries section compare scalability sina fur tree index rsj algorithms 
figures give effect increasing number moving objects cpu time respectively 
sina outperforms algorithms 
rsj double sina due tree update cost 
notice performance trees degraded increase number moving objects moving queries 
performance index dramatically degraded increase number moving objects moving objects indexed 
fur tree worst performance cases index queries 
performance slightly affected increase moving objects 
slight increase due maintenance increasing size moving objects 
number moving objects increased fur tree index similar performance times worse performance sina 
main reason fur tree index utilize index structure 
non indexed objects queries worsen performance fur tree index respectively 
sina lowest cpu time 
relative performance sina tree algorithms increases increase number moving objects 
main reason update cost sina lower updating tree structures 
number moving objects increases quality bounding rectangles tree structure degraded 
searching querying tree incurs higher cpu time 
rsj algorithm gives lower performance cpu time fur tree index rsj needs update trees 
performance rsj ranges times worse performance sina 
gives similar experiment exchanging roles objects queries 
sina rsj treat objects queries similarly performance similar 
index exchange performance deal objects queries differently 
sina fur tree index rsj number queries time sec sina fur tree index rsj number queries cpu time scalability number queries sina fur tree index rsj percentage moving objects time sec sina fur tree index rsj percentage moving objects cpu time percentage moving objects percentage moving objects queries investigates effect increasing percentage number moving objects queries performance sina tree algorithms 
percentage moving objects varies 
percentage moving queries set 
overhead rsj similar performance sina moving objects 
rsj incurs double number sina moving objects 
fur tree index similar performance times magnitude worse sina 
percentage moving objects lower lower percentage moving queries fur tree better performance 
percentage number moving objects moving queries equal fur tree similar performance 
basically performance fur tree index degraded increase percentage moving objects moving queries respectively 
cpu time sina outperforms rtree algorithms 
mainly due high update cost tree 
rsj algorithm highest cpu time updates trees 
addition sina computes incremental results tree algorithms non incremental 
similar performance achieved fixing number moving objects varying number moving queries 
difference replace roles objects queries 
performance fur tree index exchanged moving queries moving queries moving queries percentage moving objects time sec moving queries moving queries moving queries percentage moving objects cpu time scalability sina update rates sina fur tree index rsj objects change cells time sec sina fur tree index rsj objects change cells cpu time effect movement locality sina maintain performance 
limit number moving queries number moving objects 
having dynamic environment degrades performance tree algorithms 
experiment explore scalability sina terms handling highly dynamic environments 
percentage moving objects varies 
plot lines sina correspond percentage moving queries 
include performance results tree algorithms performance dramatically degraded highly dynamic environments 
figures give cpu time incurred sina respectively 
trend sina similar percentages moving queries 
performance sina increases linearly increase moving objects 
sina suitable highly dynamic environments 
locality movement section investigates effect locality movement sina tree algorithms 
locality movement mean objects queries moving certain distance 
extreme example objects moving small distance evaluation time sina objects queries moving cells 
sina achieves best performance 
side sina worst performance objects change cells 
tuning moving distance moving objects keep track number moving objects cross cell boundaries 
figures give effect movement locality cpu time respectively 
worst case sina better tree algorithms similar rsj times better fur tree index 
performance tree algorithms affected objects change cells 
main reason changing cell grid structure necessarily mean changing tree node 
cpu time sina outperforms algorithms orders magnitude 
addition performance sina slight increase number objects change cells 

introduces scalable incremental algorithm sina short new algorithm evaluating set concurrent continuous spatio temporal range queries 
sina employs shared execution incremental evaluation paradigms achieve scalability efficient processing continuous spatio temporal queries 
sina phases hashing phase invalidation phase joining phase 
hashing phase employs memory hash join algorithm results set positive updates 
invalidation phase triggered time units memory full produce set negative updates 
joining phase triggered produce set positive negative updates result joining inmemory data disk data 
discussed extensibility sina support wide variety spatio temporal queries sync clients 
correctness sina proved terms completeness uniqueness 
comprehensive experiments show performance sina orders magnitude better tree algorithms experiments demonstrate sina scalable large number moving objects moving queries stable highly dynamic environments 
sina saves network bandwidth minimizing data sent clients 

norbert beckmann hans peter kriegel ralf schneider bernhard seeger 
tree efficient robust access method points rectangles 
sigmod 
christian jensen 
nearest neighbor reverse nearest neighbor queries moving objects 
ideas 
thomas brinkhoff 
framework generating network moving objects 

thomas brinkhoff hans peter kriegel bernhard seeger 
efficient processing spatial joins trees 
sigmod 
ying cai hua cao 
processing range monitoring queries heterogeneous mobile objects 
mobile data management mdm 
chandrasekaran michael franklin :10.1.1.19.8866
streaming queries streaming data 
vldb 
chen david dewitt feng tian yuan wang :10.1.1.136.4253
niagaracq scalable continuous query system internet databases 
sigmod 
ling liu 
distributed processing continuously moving queries moving objects mobile system 
edbt 
guttman 
trees dynamic index structure spatial searching 
sigmod 
george dimitrios gunopulos vassilis 
line discovery dense areas spatio temporal databases 

susanne chuan ming liu walid aref prabhakar 
query processing broadcasted spatial index trees 

michael franklin walid aref ahmed elmagarmid 
scheduling shared window joins data streams 
vldb 
hanan samet 
distance browsing spatial databases 
tods 
kwon lee lee 
indexing current positions moving objects lazy update tree 
mobile data management mdm 
iosif sharad mehrotra 
dynamic queries mobile objects 
edbt 
li lee hsu christian jensen keng teo 
supporting frequent updates trees bottom approach 
vldb 
mohamed walid aref 
spatio temporal access methods 
ieee data engineering bulletin 
mohamed ming lu walid aref 
hash merge join non blocking join algorithm producing fast early join results 
icde 
patel david dewitt 
partition spatial merge join 
sigmod 
prabhakar xia walid aref susanne 
query indexing velocity constrained indexing scalable techniques continuous queries moving objects 
ieee trans 
computers 
christian jensen scott leutenegger mario lopez 
indexing positions continuously moving objects 
sigmod 
hanan samet 
quadtree related hierarchical data structures 
acm computing surveys 
sellis 
multiple query optimization 
tods 
song nick roussopoulos 
nearest neighbor search moving query point 

sun papadias tao liu 
querying past spatio temporal databases 
icde 
tao dimitris papadias shen 
continuous nearest neighbor search 
vldb 
tao dimitris papadias sun 
tpr tree optimized spatio temporal access method predictive queries 
vldb 
douglas terry david goldberg david nichols brian oki 
continuous queries append databases 
sigmod 
urhan michael franklin 
xjoin reactively scheduled pipelined join operator 
ieee data engineering bulletin 
wilschut peter apers :10.1.1.56.701
dataflow query execution parallel main memory environment 
proceedings international conference parallel distributed information systems pdis 
ouri wolfson yin 
accuracy resource tracking location prediction 

jun zhang zhu dimitris papadias tao dik lun lee 
location spatial queries 
sigmod 
zheng dik lun lee 
semantic caching location dependent query processing 

