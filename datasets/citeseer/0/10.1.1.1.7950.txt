market proportional resource sharing clusters brent chun david culler university california berkeley computer science division cs berkeley edu enabling technologies high speed communication global process scheduling pushed clusters computers mainstream general purpose high performance computing systems 
generality implies sharing raises new questions area cluster resource management 
particular systems aggregate demand computing resources exceed aggregate supply allocate resources competing applications important problem 
traditional solutions problem focused mainly global optimization respect system centric performance metrics metrics ignore higher level user intent 
propose alternative market approach notion computational economy optimizes user value 
starting fundamental requirements describe architecture market cluster resource management idea proportional resource sharing basic computing resources 
architecture implemented node processors prototype system provides market time shared cpu usage sequential parallel programs 
evaluating ideas currently process studying users respond system collecting data real day day usage cluster 
enabling technologies high speed communication global process scheduling pushed clusters computers mainstream general purpose highperformance computing systems 
longer restricted strict space personal supercomputers clusters today capable supporting multiple parallel sequential jobs concurrently delivering high performance 
generality system implies sharing raises new questions area cluster resource management 
particular systems aggregate demand computing resources exceed aggregate supply allocate resources competing applications important problem 
traditional solutions cluster resource management mainly focused global optimization respect system centric performance metrics mean job completion time average system utilization 
systems significant sharing approaches problems 
global optimizations targeted consistent individual resource valuations users 
optimizations performed applications equally important ignoring individual user value resources vary schedulers unix priority scheduler implicit assumptions user value treat applications equally 
example observing fraction job cpu scheduling quantum priority schedulers attempt infer job interactive compute bound modifies job priority accordance thinks result better performance 
immediacy importance resource demands user computing needs 
allocating resources competing applications solutions deliver greatest value users set resources 
second traditional solutions lack proper incentives encourage users back system periods high contention 
systems aggregate demand exceed aggregate supply probability cluster resources non negligible 
users pursuing selfish locally optimal behavior problem periods high contention users incentive perform socially desirable behavior improve global goodness 
address issues propose market approach cluster resource management notion computational economy optimizes user value 
scheme clusters organized economies independent sellers buyers 
cluster nodes act independent sellers computing resources user applications act buyers purchase resources personal value delivered users 
users express value currency traded resources charged resource rate willing pay rate users willing pay competing applications 
starting fundamental requirements develop idea computational economies presenting architecture market cluster resource management idea proportional resource sharing basic computing resources 
describe implementation architecture node processors prototype system provides market time shared cpu usage sequential parallel programs 
evaluating ideas currently process studying users respond system collecting data real day day usage cluster 
rest organized follows 
section fundamental functional requirements market systems 
section architecture market cluster resource management proportional resource sharing 
architecture section describe implementation initial node processors market cluster provides time shared cpu usage sequential parallel programs 
section discusses related section 
fundamental requirements fundamental functional requirements market resource management cluster means users express value ii policies translate value resource allocations iii mechanisms enforce resource allocations 
variations requirements met defines design space market systems 
expressing value market system optimize user value determine personal user value application competing shared resources 
knowledge system meaningful way inferring applications valuable deciding allocate resources 
component needed means concretely express user personal value executing application system 
parts medium expression express value entity entities value assigned 
running application user implicit notion important execution application instant time 
example user running netscape value execution execution important simulation results need included due day 
notion value concrete system needs mapping personal user value common medium expression value 
common solution problem common currency 
long users form reasonably accurate mappings personal value currency solution adequate 
second part expressing value concerns entity entities value assigned 
example user says simulation important thing valued simulation wall clock completion time 
hand user runs server user values average requests second sustain 
ideally entities user assigns value expressed vocabulary application terms user deals 
forming mapping application specific performance metrics low level resources solved cases quite accurately applications 
cases case 
cases mappings users approximate terms basic computing resources 
example user running scientific simulation want speak terms grid points evaluated second percentage cpu obtained time may just effective 
applications hypothesize basic resources critical performance known 
translating value competing users values applications shared resource market system needs policy translating values specific resource allocations appropriate performance guarantees 
policy goes doing involves critical trade human computer interaction hci design goals criteria design economic mechanisms 
hand hci perspective expression value policy translate value directly exposed observable users policy may known effects policy terms resource allocations certainly observed favors policy simple intuitive users form crisp mental model system behaves response choices 
hand game theory perspective common design goal policies incentive compatible meaning deciding assign value application optimum utility maximizing behavior reveal true value users need concerned users behavior 
different policies real systems reflect different trade offs perspectives 
issue associated translation value resource allocations nature resource allocations 
relates point earlier regarding entities value assigned 
value translated resource allocations allocations reflect performance guarantee hard statistical ultimately meaningful user zero layers translation 
example assigning value fraction resource application obtains time defined meaningful 
case zero layers translation 
example suppose video application wanted run frames second maximum achievable frame rate directly proportional cpu utilization providing mechanism control cpu precisely stride scheduler reasonable way provide meaningful resource allocations level translation 
enforcing value value translated resource allocations performance guarantees operating system mechanisms needed enforce allocations users get resources paying 
need appropriate quality service qos mechanisms resources value assigned users charged 
numerous papers published novel quality service mechanisms cpu time networking physical memory spin locks unfortunately despite plethora mechanisms relatively little done area policies effective mechanisms real user environments 
number possible reasons incentives prevent unrestricted socially unacceptable mechanisms discourage user turning service knob maximum setting lack inclusion popular operating systems reason personal computers workstations simply compelling need quality service mechanisms control resource usage competing applications 
networking side absence qos doubt partly due difficulty implementing deploying qos 
single node systems typical applications run execute reasonably presence competition 
hand cluster system intended high performance computing situation quite opposite 
demanding applications common effects frequency nonnegligible contention occurs shared resources significant 
architecture address issues raised section section define architecture market resource management clusters 
take specific positions certain key issues entities value assigned 
positions largely goal defining architecture realize real systems properties measured real settings users running wide range applications 
goal stands contrast previous market systems highly theoretical nature focused fairly narrow slices problem extensive game theoretic analyses policies translate value allocations 
architecture consists layers resources computational resources cpu physical memory disk resource managers operating system entities enforce resource allocations economic front entity translates user value resource allocations access modules means users assign value run applications system users applications entities system ultimately drive design decisions layers 
resources resources computational resources controlled resource managers allocated applications deliver value users 
basic time shared resources cpu time bandwidth networking bandwidth shared spaced resources physical memory disk space typical examples 
unconventional examples include spin locks smps time shared access special purpose devices wall monitors 
context computational economy focus primarily resources exhibit scarcity significant application level performance implications 
words focus queue sharing shares economic batch time access modules resources cpu mem net resource users apps system architecture 
users running wide range applications assign values applications run cluster appropriate access module 
access modules run jobs cluster obtain resources competing jobs economic front 
mode access set competing jobs economic front translates values expressed common currency resource shares 
resource share allocations enforced resource managers resource type 
resources demand resource non negligible probability exceed supply way application performance suffers 
resources allocation controlled priced computational economy 
resource managers resource managers operating system entities provide resource allocations associated performance guarantees 
examples possible design choices resource managers include priority schedulers real time schedulers fair share schedulers proportional share schedulers rate schedulers :10.1.1.129.159:10.1.1.138.3502
resource manager choose resource computational economy depends factors including resource allocation precision flexibility overhead 
ultimately resources allocation control economy resource managers resources capable exposing enforcing resource allocations zero layers translation meaningful user 
architecture chosen proportional share schedulers resource managers basic computational resources cpu memory network 
reasons doing threefold proportional share schedulers provide intuitive model resource allocation ii exist efficient algorithms implementing iii provide flexibility exposing different entities assign value addition assigning value simply currently cpu stride scheduler implemented linux running dell way smps 
plan implement minimum funding revocation algorithm proportional share memory management shares cpu stride scheduler reasonable user estimates cpu time needed admission control potentially build market system deadlines 
proposed articulated detail waldspurger proportional share scheduling provides simple intuitive model resource allocation :10.1.1.138.3502
model resource rights shared resource encapsulated tickets 
resource represented total tickets 
application holding tickets competing resource obtains resource 
example cpu stride scheduling application holding tickets obtain accurate allocation cpu time 
model allocation simple reason affords simple mapping value resource allocations mapping credits credits name currency system traded resources minute ticket allocation time 
economic front economic front entity translates value resource allocations terms shares fractions resource enforced resource managers 
policy front implements largely function access modules access system 
example different policies appropriate users accessing system interactive time shared environment opposed say submitting jobs batch queue runs jobs cluster 
vickrey auctions instance may appropriate batch queue delay time job submitted time executed auction time clear 
hand auction interactive system sense time clear issue user wait typing command auction clear 
policies depend entity entities value assigned associated performance guarantees 
system performs admission control key issue determines resource allocations applications receive represent absolute performance guarantees represent relative performance guarantees 
admission control example absolute guarantees manage futures market computational resources 
futures sold enforced proportional share schedulers admission control policy prevents resources 
combination scheduling admission control effect trying emulate real time schedulers accomplish 
having absolute performance guarantees implies admission control depending access module may may desired 
choice policy reflects trade offs usability concerns game theoretic design points 
architecture point view appropriate trade offs front policy open 
date reported user studies user behavior market clusters 
real implementations certainly scale wish examine problem 
real user behavior data impossible know example criticized assumption human behavior assumed game theory matters practice 
users tend try exploit properties game knowing provide lot freedom trying system usable example 
designing system take position giving usability concerns higher priority making policy absolutely incentive compatible 
usability important design point 
ensuring policy incentive compatible may 
access modules access modules provide means users access cluster resources run applications 
common examples include telnet rlogin rsh ssh interactive remote execution single node custom remote execution environments multiple rsh ssh instances interactive remote execution parallel programs multiple nodes batch queue systems large numbers sequential parallel jobs 
support market resource management access modules need augmented users assign value applications 
assigning value may simple specifying scalar value passed interactively command line may involve complex specifications specifying utility function 
close loop workload demand valuation depends past performance 
keeping goal usability initially chosen simple scalar valuations cpu time 
addition interactive time shared access resources common access module implemented section provides interactive remote execution parallel sequential jobs 
prevent users bypassing access computational economy currently disallow general purpose access modules modified ssh access allowed administrative purposes 
users applications explicitly part system actual implementation users applications important part architecture 
modes usage resource demands users applications ultimately drive design choices system 
users actual usage system determine market resource management effective 
keeping users mind requires thinking clusters batch mode interactive sophisticated assumed understand computer systems resource demands applications resources care factors significant implications design layers system 
implementation investigate users behave market systems systems perform practice implemented computational economy cpu time cluster pcs part ucb millennium project 
system allows users run sequential parallel programs assigning value specifies maximum credits minute user application willing spend purchasing cpu time 
simple intuitive algorithm node independently computes charges cpu allocations competing applications enforces allocations stride scheduling efficient deterministic proportional share scheduling algorithm 
resources ucb millennium cluster system consists way dell multiprocessors running modified version linux operating system 
node mhz intel pentium iii processors mb memory gb local storage network connections myrinet switched gb wormhole routed network switched mb ethernet 
resources system basic computational resources node cpu time physical memory bandwidth network bandwidth broken time space shared shares 
system supports economic resource allocation cpu shares 
memory network bandwidth allocated default operating system policies 
resource managers cpu stride schedulers enforce cpu resource allocations value modified linux cpu scheduler replacing standard priority scheduling algorithm stride scheduling 
stride scheduling system able achieve better precision controlling cpu allocations different jobs compared priority scheduling 
precision necessary allocations driven user specified values result users charged credits finite supply get done 
building basic stride scheduling algorithm added extensions order support stride scheduling smps deal multithreaded multiprocess jobs 
pass cpu cpu pass ticket allocation tickets stride stride scheduling algorithm 
example jobs competing cpu time way smp 
resource rights smp cpus encapsulated pool tickets 
tickets respectively receive allocation machine cpus time 
note way smp having rights th tickets really having exactly job multithreaded 
job stride interval virtual time measured cpu job selected run 
inversely proportional ticket allocation 
job pass virtual time job scheduled 
incremented job stride time job scheduled 
cpu quantum processor stride scheduler chooses job lowest pass scheduled processor runs scheduling quantum increments pass stride 
stride scheduling resource rights shared resource represented pool tickets 
number jobs competing resource 
associated job tickets number tickets assigned job stride interval virtual time measured units scheduling inversely proportional job wait scheduled resource pass virtual time job scheduled 
jobs tickets shorter strides scheduled frequently obtain greater fraction resource 
algorithm simple scheduler picks job lowest pass runs scheduling quantum increments pass stride iterates see 
deterministic resolution scheduling quantum schedules jobs exact proportions ticket allocations 
extended basic stride scheduling algorithm support smps contain control resource usage collection related entities threads process collection processes working 
necessary basic processing nodes multiple processors linux kernel organized centralized run queue 
necessary prevent user running process having process create replicas forking cloning scheduled value original process 
global pass ticket stride values represent aggregate information competing jobs necessary support system jobs join leave system dynamically 
see details :10.1.1.138.3502
making stride scheduling algorithm smp aware simply required small change way global pass computed 
particular processes running concurrently cpus global pass incremented times fast 
support multithreaded multiprocess jobs isolate related entities currencies 
job system scheduled basis number base tickets 
deal multithreaded multiprocess job base ticket allocation simply ensure aggregate base ticket assignment entities forked cloned root process including root maintaining linked list currencies associated linked list processes threads currency 
default policy ticket allocation multithreaded multiprocess job perform fair share entities 
applications desire control system call interface provided allows applications manage tickets applications specific currency 
economic front initial economic policy translate values shares cpu tickets elected start simple intuitive policy opportunity cost charging easy users reason 
scheme jobs competing shared resource case cpus node 
job stated value may may true value suppose user trying value application save credits user realize important particular run 
system allocates shares charges follows 
user demanding resource 
user imposing burden system denying opportunity competition case user charged multiple jobs competing jobs receive shares tickets 
job stated value obtains time 
job charged credits minute 
multiple jobs competing job receives fair share charged 
computing shares charging computed dynamically jobs join leave system 
key issue addressed policy distinction selling sharing 
policy charges users burden place users sharing system 
con opportunity cost charging occurs charging done opportunity resource 
user opts resource charged value opportunity resource denied competing users 
means users system free 
conversely high contention users pay system 
contrast approach profit center charging maximize seller revenue 
selling maximum seller revenue produces different user incentives incentives may result suboptimal sharing resources 
monopoly pricing example common seller maximize revenue underlying resources sold 
shared computer system pricing schemes little sense considering original motivation computational economies 
addressing sharing directly policy number desirable properties including simplicity intuitiveness low computational overhead 
usability perspective easy users reason system response assigning value computation 
property important order reduce amount noise experiments 
users unable understand means assign value particular means doing trying meaningfully interpret results users mechanism difficult impossible 
making policy interface extremely simple scalars increase chances users clear picture means assign value computation system face competition assigning resources 
nice property policy computationally simple implement 
overhead required compute allocations charging straightforward simpler needed implement stride scheduling 
furthermore anticipate users cluster run large numbers short jobs second dynamic updating allocations require system calls incur fairly minimal overhead 
access modules rexec remote execution environment allow users interactively run jobs cluster economy implemented rexec secure decentralized remote execution environment parallel sequential jobs 
compared previous remote execution systems score lsf rexec provides unique set features including decoupling node discovery selection emulation local execution multiple nodes decentralized control dynamic discovery configuration defined failure cleanup models authentication encryption 
section discuss features detail 
section briefly describe rexec implementation 
features decoupling discovery selection means process discovering nodes available system separated process selecting nodes system run user application 
decoupling processes users flexibility choose selection policy want personal preferences opposed having system implement global policy forced 
computational economy property important expect users require multiple selection policies depending needs 
emulation local execution multiple nodes means program run multiple nodes propagation user local environment signals stdin stdout stderr 
provides users familiar execution environment allows apply standard job control mechanisms controlling jobs 
clearly local behavior sense extended multiple remote instances application running top nodes xterm 
rexec provides sufficient emulation common cases 
attempt address types mismatches 
scalability availability reasons rexec decentralized 
position take rexec node capable running user programs available 
false dependencies artifacts remote execution environment nodes perfectly healthy useful 
decentralized control achieved ways having client directly manage remote execution job multiple nodes ii replication node discovery selection service 
increasing availability reducing performance bottlenecks decentralized control works economy decentralized entity acts local information 
rexec depend static configuration files fixed set cluster nodes 
entities rexec dynamically discover known ip multicast channel 
large cluster machines adding removing node cluster fairly common event 
case doing requires restarting system manually editing configuration files 
rexec avoids completely 
cluster nodes discovery selection servers account service managing user credits economy dynamically discovered 
rexec detects failures provides defined failure cleanup models 
remote processes machines networks forth fail time time 
rexec detects failures performs appropriate actions 
significant shortcoming remote execution systems lack precise failure model 
example user types running remote parallel program means terms cleaning remote resources usually defined 
rexec currently provides single failure cleanup model states remote execution fails time entire program aborted remote resources freed 
example freeing resources remote node involves termination arbitrary tree child processes child processes broken tree inherited init process freeing rexec resources node dedicated job 
lastly rexec implements client side authentication encrypts relevant data exchanged clients servers implementation secure sockets layer ssl protocol 
system user presents certificate signed trusted certificate authority establishes user identity uses public key cryptography prove 
public key cryptography scheme provides significant improvements attacks compared traditional password schemes 
addition authentication rexec performs encryption relevant data stdin stdout stderr signals flowing remote programs 
prevents potentially eavesdroppers snooping network observing input output programs users running system 
implementation rexec system consists main programs rexecd daemon runs cluster node rexec client program users run execute jobs rexec vexecd replicated daemon provides node discovery selection services 
logically consists layers rexec physical layer provides low level mechanisms remote execution failure detection cleanup authentication encryption set named nodes virtual layer provides set node names selection criteria rexecd vexecd vexecd rexecd rexecd rexecd ip multicast rexecd state node rexec node node node rexec indexer 
run indexer node credits minute 
minimum 
node rexec remote execution environment 
rexec system consists main programs rexecd daemon runs cluster node rexec client program users run execute jobs rexec vexecd replicated daemon provides node discovery selection services 
users run parallel sequential applications rexec rexec client performs functions selection nodes run user preferences ii remote execution user application nodes direct ssl tcp connections node rexecd daemons 
example nodes system node node node node instances vexecd implements lowest cpu price policy 
user wishes run program called indexer rate credits minute wishes machine lowest cpu price 
contacting vexecd daemon rexec obtains name machine lowest cpu price node 
rexec establishes ssl tcp connection directly node run indexer rate credits minute 
indexer started node compete resources job cheapest cpus 
users run parallel sequential applications rexec rexec client performs functions selection nodes run user preferences user specified vexecd implements user preferred policy ii remote execution user application nodes direct ssl tcp connections node rexecd daemons 
rexec system implemented mainly user level small kernel changes properly freeing resources tree processes 
extend rexec operate framework computational economy changes system 
vexecd daemon written implements minimum price policy nodes knows 
rexecd cluster sends state announcements known ip multicast channel periodically state change occurs similar 
vexecd daemons listen channel maintain list nodes heard specific window time 
selection policy simply ordering list 
second rexec client modified allow specification cpu valuation user application 
new command line switch user specifies maximum credits minute application spend purchasing cpu time 
third rexecd modified economic front collection functions implement cpu market translate user specified rates cpu allocations stride scheduler state system changes job starts exits node 
applications competing resources charged usage account service needed manage credit usage users 
service provides simple credit debit management user credit accounts 
rexecd daemons obtain ip address port account service runtime ip multicast establish secure ssl tcp connections perform transactions database 
users applications ucb millennium project part ucb millennium project system user community spans academic departments uc berkeley campus 
users wide range problems areas multimedia civil engineering computational astrophysics digital libraries large scale internet systems physics computer aided design 
computational workloads generated users typically take form large numbers sequential jobs exploring parameter space large parallel jobs written mpi 
addition millennium users significant opportunity obtain participation user studies number undergraduate graduate courses berkeley computer science department 
taken millennium project computer science users form large diverse user community 
community drive empirical evaluation prototype 
related ferguson microeconomic load balancing algorithm earliest examples applying market ideas cluster resource management 
algorithm multiple sequential jobs compete dedicated slices cpu time collection heterogenous speed machines interconnected point point links 
cpu slice machine holds auction determine set competing jobs granted exclusive cpu user specified slice time 
winner auction job highest bid amount unit time 
winning rate referred current machine price posted machine local bulletin board prices bulletin boards local neighborhood ma cpus cpus node time seconds fraction node cpus versus time job rate job rate job rate job rate balance credits time seconds account balances versus time job account job account job account job account example measured cpu allocation charging single node 
scenario jobs willing pay rates respectively compete cpu resources single node 
node cpus 
job arrival times labeled 
job departure departure times labeled 
instant time interval see relative cpu allocation jobs ratio rates willing pay 
note jobs single threaded jobs compete receives node cpus cpu 
multiple jobs compete job charged rate willing pay allocation proportion rate 
single job demands resources resources charged intervals 
chines 
ferguson model jobs may submitted machine migrate different machines execution complete machine originated 
job gets executed function machine job submitted bulletin board prices neighborhood machine user preferences lowest cost fastest execution 
extending ferguson parallel programs spawn market system scheduling concurrent tree applications collection heterogeneous workstations 
spawn application user specified funding rate specifies aggregate funding rate entire application organized tree worker modules computational tasks concurrent application manager modules entities control worker creation relative funding workers control 
funding applications compete resources bidding dedicated slices cpu time multiple workstations periodically runs sealed bid second price auction 
winning workstation auction application granted exclusive workstation cpu slice expires 
slice application continue requesting extension continuing pay market price price win auction terminated 
system resources resource economic access modules users apps ferguson cpu admission control sealed bid dutch auctions spawn cpu admission control vickrey auction application manager popcorn cpu admission control vickrey double clearinghouse auctions java api mariposa cpu disk contract net pricing load expected resource usage history sc centers cpu memory disk priority scheduler nice priority weighted usage charges batch queue priority ssh numerous table related summary 
table summarizes related framework architecture section 
looking data find far focused mainly economic front layer 
little attention paid problem real users applications market systems practice implications real usage layers system 
supercomputing centers listed bit stretch categorized market 
lack real users applications systems lack highly specialized access modules clearly shows popcorn requires program written economy mind special api 
evidence notice ferguson algorithm spawn popcorn assume dedicated system 
systems today multiple users sharing resources important common mode usage 
case clusters 
supercomputing centers specialized vector machines support popcorn wide area infrastructure market cpu scheduling distributed computations written java 
system users write distributed java applications decomposing application collection coarse grain tasks called 
requires number java operations complete 
buyers users assign desired prices contracts computation value enter known centralized market seek sellers 
sellers users selling cpu time machines perform behalf buyers 
market matching buy sell occur different ways constituting different internal market 
ways include repeated vickrey auction sealed bid second price auction double auction clearinghouse double auction 
unclear duration contract ferguson algorithm possible popcorn uses user specified contract lengths performs economic policies rates 
mariposa distributed database storage system uses market mechanisms resource management execute queries 
system client submits query broker time dependent budget specifies value delivered client function query completion time 
broker receiving query computes parallel pipelined execution plan efficiently execute query collection subqueries 
bids multiple servers contracts execute subqueries checks execute client query specified budget 
successful query plan executed 
servers provide processing storage capabilities perform client query processing execute subqueries 
brokers perform selfish local optimizations particular pricing contacts resources required execute long term revenue collected storage fragment current load 
supercomputing centers pricing algorithms charge resource usage give different levels cpu priority batch queue jobs submitted high machines vector supercomputers 
example machines managed national partnership advanced computing infrastructure npaci job charged resource usage measured service units su queue rate queue job submitted 
su roughly equivalent cpu hour machine job runs 
queue rate priority user assigns job determines quickly user job run 
idea users assign higher priority jobs higher personal value priorities result jobs running greater priority native cpu scheduling mechanism underlying machine supports 
nice property supercomputing center charging charges change slowly different fixed pricing schemes day night users potentially get better handle manage funds prices predictable 
hand prices responsive immediate demand clear prices periods high demand demand exceeds supply periods low demand users 
prices constants pricing computing sus obvious appear change time reflect long term averages observed supply demand 
enabling technologies high speed communication global process scheduling pushed clusters computers mainstream general purpose high systems 
sophisticated resource allocation mechanisms 
generality implies sharing raises new issues area cluster resource management 
address issues proposed decentralized market approach resource management idea proportional resource sharing basic computing resources 
cluster computers organized computational economy optimizes user value 
cluster nodes act independent sellers computing resources user applications act buyers purchase resources personal value delivered users 
described fundamental functional requirements market system expressing value translating value enforcing value 
proposed architecture market cluster resource management proportional resource sharing 
architecture implemented node processors prototype system provides market time shared cpu usage sequential parallel programs 
evaluating ideas currently process studying users respond system collecting data real day day usage cluster 
anderson culler patterson team 
case networks workstations 
ieee micro feb 
arpaci dusseau culler mainwaring scheduling implicit information distributed systems 
proceedings acm sigmetrics conference 
boden cohen seitz su 
myrinet gigabit second local area network 
ieee micro feb 
geweke culler implementation analysis virtual interface architecture 
proceedings supercomputing 
cheriton distributed system 
communications acm march 
chien giannini high performance virtual machines clusters supercomputing apis performance 
proceedings conference parallel processing scientific computing pp 
chun mainwaring culler virtual network transport protocols myrinet 
proceedings th hot interconnects conference aug 
culler arpaci dusseau arpaci dusseau chun mainwaring martin yoshikawa wong parallel computing berkeley 
proceedings th joint symposium parallel processing kobe japan 
demers keshav shenker simulation fair queueing algorithm 
proceedings th ieee computer society international conference compcon march pp 

duke green research heterogeneous networked computing cluster distributed queuing system version www edu html 

ferguson nikolaou microeconomic algorithms load balancing distributed computer systems 
international conference distributed computer systems 
freier kocher ssl protocol version internet draft 

petrou rodrigues vahdat anderson global layer unix network workstations 
software practice experience apr 
gibbons game theory applied economists 
princeton university press 
gmbh technical description www de products tech desc html 

hori ishikawa implementation parallel operating system clustered commodity computers 
proceedings cluster computing conference march 
hull futures options markets 
prentice hall 
ibm 
ibm general information 
september 
kay fair share scheduler 
communications acm january 
scheduling share machine 
software practice experience january 
liu layland scheduling algorithms multiprogramming hard real time environment 
journal acm 
maheshwari charge proportional scheduling 
tech 
rep mit lcs tm massachusetts institute technology april 
mainwaring culler design challenges virtual networks fast general purpose communication 
proceedings th acm sigplan symposium principles practice parallel programming ppopp 
mckusick bostic karels quarterman design implementation bsd operating system 
addison wesley 
npaci 
national partnership advanced computing infrastructure web page www npaci edu 
regev nisan popcorn market online market computational resources 
proceedings st international conference information computation economies 
ridge becker sterling beowulf harnessing power parallelism pile pcs 
proceedings ieee aerospace 
sha klein goodenough rate monotonic analysis real time systems 
andre van gary editors foundations real time computing scheduling resource management 
kluwer academic publishers 
silberschatz operating system concepts 
addison wesley 
stonebraker devine litwin pfeffer sah staelin economic paradigm query processing data migration mariposa 
rd international conference parallel distributed information systems september pp 

tanenbaum modern operating systems 
prentice hall 
vickrey counterspeculation auctions competitive sealed tenders 
journal finance 
waldspurger lottery stride scheduling flexible proportional share resource management 
phd thesis massachusetts institute technology 
waldspurger hogg huberman kephart stornetta spawn distributed computational economy 
ieee transactions software engineering february 
waldspurger weihl lottery scheduling flexible proportional share resource management 
proceedings st usenix symposium operating systems design implementation usenix association pp 

waldspurger weihl stride scheduling deterministic proportional share resource management :10.1.1.138.3502
tech 
rep mit lcs tm massachusetts institute technology 
welsh basu von eicken incorporating memory management user level network interfaces 
proceedings th hot interconnects conference aug 
zhang virtual clock new traffic control algorithm packet switching networks 
acm transactions computer systems may 
zhou wang zheng delisle utopia load sharing facility large heterogenous distributed computer systems 
software practice experience 

