expressiveness structured document query languages attribute grammars frank neven jan van den bussche centrum structured document databases naturally viewed derivation trees context free grammar 
view classical formalism attribute grammars formalism structured document query languages 
perspective study expressive power bags boolean valued attribute grammars propositional logic formulas semantic rules rags attribute grammars rst order logic formulas semantic rules 
bags express unary queries rags express queries arity 
rst show unary queries expressible bags precisely de nable monadic second order logic 
show queries expressible rags precisely de nable rst order inductions linear depth equivalently computable linear time parallel machine polynomially processors 
show rags synthesized attributes strictly weaker rags synthesized inherited attributes 
show rags expressive monadic second order logic queries arity 
preliminary versions parts th acm symposium principles database systems seattle june th international workshop foundations models languages data objects october 
post doctoral researcher fund scienti research flanders 
address luc dept wni universitaire campus belgium 
mail luc ac 
discuss relational attribute grammars context bags rags 
show case bags increase expressive power di erent semantics relational rags capture complexity classes np conp coup 
originally proposed gonnet tompa structured document database naturally viewed derivation tree context free grammar 
essence view taken sgml 
classical formalism attribute grammars introduced knuth prominent framework expressing computations derivation trees 
attribute grammars provide mechanism annotating nodes tree called attributes means called semantic rules bottom called synthesized attribute values top called inherited attribute values 
attribute grammars applied diverse elds computer science compiler construction software engineering survey see 
natural consider attribute grammars basis structured document database languages 
instance approach chosen abiteboul cluet milo 
goal understand expressive power attribute grammars structured document query language 
simple query facility provided information retrieval systems query amounts selection certain nodes tree corresponding positions document structural elements document retrieved 
propose boolean valued attribute grammars bags express unary queries 
bags attribute grammars boolean attribute values propositional logic formulas semantic rules 
bag expresses query natural way result query expressed bag consists nodes tree designated attribute true 
information retrieval systems usually query set structured documents document 
far query language design concerned set documents considered long structured document 
show unary query expressible bag de nable monadic second order logic mso 
pleasantly surprising rst clear rst order queries bag expressible 
direction easy prove 
direction classical theorem eld automata logic thatcher wright stating tree language recognizable nite bottom tree automaton de nable mso sentence 
theorem prove result intricate construction bag simulates parallel runs tree automaton possible boolean labelings tree 
corollary proof obtain bag equivalent bag consists bottom pass followed top pass 
bags express boolean queries restricted setting equivalence bags mso follows directly thatcher wright theorem 
equivalence follows bottom property boolean bag queries boolean query expressible bag expressible bag synthesized attributes 
bottom property hold bags expressing unary queries 
having understood expressive power bags turn queries result relations arbitrary xed arity nodes tree 
queries example wants de ne wrappers map relevant parts document relational database 
introduce relation valued attribute grammars rags rst order logic formulas semantic rules 
query expressed rag naturally de ned value relation designated attribute root 
show queries expressible rags precisely de nable rst order inductions linear depth 
results immerman imply precisely queries computable linear time parallel random access machine polynomially processors 
investigate mentioned bottom property boolean bag queries carries boolean rag queries tools nite model theory prove 
complete picture showing synthesized rags strictly powerful monadic second order logic queries arity 
implies particular restricting attention unary queries rags powerful bags 
turns query point result obtained independently engelfriet 
de ned monadic second order logic formula expressed rag uses synthesized attributes 
consider boolean valued relation valued relational attribute grammars 
relational attribute grammars introduced courcelle 
concept generalization standard attribute grammars semantic rules specify functions computing attributes terms attributes relations attributes 
discuss natural semantics relational bags rags 
show relational bags entirely equivalent standard bags 
rags clear various semantics relational rags capture complexity classes np conp coup relationship linear parallel time complexity class standard rags unknown 
results obtained summarized graphically 
organized follows 
section introduce boolean valued relation valued attribute grammars query language 
section characterize expressive power bags terms monadic second order logic establish bottom property boolean bag queries 
section characterize expressiveness rags terms linear inductions linear depth 
show bottom property boolean rag queries discuss relationship rags mso 
section consider relational bags rags 
concluding remarks section 
technical proofs moved appendix 
attribute grammars query languages data model follows context free grammar set non terminals set terminals set productions start symbol 
harmless technical assumption start symbol appear right hand side production 
derivation tree de ned standard way see 
derivation tree 
nodes exactly children 
production 
label labeled say derived de nition context free grammar models schema database 
database instance derivation tree de nition natural number 
ary query function maps derivation tree ary relation nodes 
nullary query zero say boolean query 
attribute grammar formalism de ne concepts common boolean valued attribute grammars 
de nition attribute grammar vocabulary form syn inh att nite set symbols called attributes syn inh att functions powerset syn inh syn inh 
att syn inh 
syn say synthesized attribute inh say inherited attribute conditions express attribute synthesized inherited attribute symbol terminal symbols synthesized attributes start symbol inherited attributes 
attribute grammar vocabulary 
de nition production attribute ng 
triple called context syn implies inh implies 
false bs result false result false true false example bag 
boolean valued attribute grammars unary boolean queries de nition bag rule context expression form propositional logic formula set proposition symbols fb ng att bag de ned follows de nition boolean valued attribute grammar bag consists attribute grammar vocabulary mapping assigning context bag rule context 
example simple example grammar bag grammar depicted 
syn inh fx syn fis xg att att att inh 
semantics bag explained 
semantics bag de nes boolean attributes nodes derivation trees underlying grammar formalized 
de nition derivation tree valuation function maps pairs node attribute label truth values 
sequel pair intuitive notation 
de nition bag derivation tree 
bag rule context 
node children 
derived formula obtained replacing occurrence propositional symbol form new propositional symbol denoted 

de nition bag derivation tree 
de ne sequence partial valuations follows empty valuation de ned 
de ned extension 
de ned propositional symbols occur 
de ned gets truth value taken 
valuation 
totally de ned valuation implies say non circular 
consider bags non circular 
non circularity known decidable 
valuation de ned 
known evaluation attribute grammar takes linear time counting evaluation semantic rule unit time see 
simply constant number attributes de ned node 
xed propositional formula evaluated constant time valuation bag tree computed time linear size arbitrary total valuation said satisfy equals truth value taken 
attribute node attribute label shall lemma lemma bag derivation tree valuation satis es ram model computation 
proof 
follows immediately de nitions satis es suppose satis es show induction de ned 
clearly holds 
suppose de ned 
de ned claim holds inductive hypothesis 
de ned de nition value equals truth value 
valuation 
assumption equals truth value 
valuation inductive hypothesis de ned 

de nition lemma holds 
bag simple way express unary ary queries 
attributes vocabulary designate attribute result de ne de nition bag expresses unary query de ned fn result derivation tree example recall bag 
derivation tree underlying grammar viewed naturally string alphabet fx yg 
node labeled tree represents position string 
consider semantic rules de ning synthesized attribute 
evaluated bottom node true counting bottom 
semantic rules de ning inherited attribute evaluated top true letter occurs string position semantic rules attribute result simply de ne result 
bag expresses query retrieving numbered positions come string 
illustration 
bag express boolean nullary queries 
attributes start symbol designate attribute result de ne result result result result result derivation tree valuation de ned bag 
de nition bag expresses boolean query de ned true result false derivation tree denotes root relation valued attribute grammars relational queries section generalize bags relation valued attribute grammars rags 
start giving example 
example rst example consider rag shown 
derivation tree underlying grammar models set documents 
document list paragraphs 
synthesized attribute result relation valued tree value result root ternary relation consisting triples intuitively document rst paragraph paragraph precisely actual parts derivation tree just nodes corresponding documents paragraphs 
result relation computed synthesized attributes rst document node rst contains rst paragraph document contains 
attributes computed turn inherited attribute synthesized attribute boolean valued node result result ds result rst result result rst rst true pl rst false false true rst example rag 
technically rule bodies rag strictly rst order formulas certainly expressed rst order logic 
true marks document true marks 
rules constant refers rst child node rule evaluated 
de nition rst production pl refers labeled child 
note rst order expressions propositional ones de ne values attributes 
indicate di erences bags rags formally 
de nition attribute associate arity natural number 
rag rule context expression form ra 
ra free variables occurring 
rst order logic formula vocabulary fb att ng relation symbol arity constant symbol 
valuation derivation tree function maps pair node labeled attribute ary relation nodes rag consists attribute grammar vocabulary mapping assigning context rag rule context 
de nition rag derivation tree 
rag rule context 
node children 
derived formula obtained replacing occurrence relation symbol relation symbol replacing constant symbol node denoted 

de nition rag derivation tree 
de ne sequence partial valuations follows empty valuation de ned 
de ned extension 
de ned relational symbols occur 
de ned relation obtained evaluating fo formula 
tree relation symbol 
interpreted 
valuation de ned total valuation 
arbitrary total valuation said satisfy equals relation de ned fo formula 
relation symbol interpreted 
analogous lemma prove lemma lemma rag derivation tree valuation satis es rag express ary queries simple way 
attributes start symbol designate ary attribute result de ne de nition rag expresses query de ned follows tree derivation equals value result root result order descendants nn descendants descendants descendants order descendants descendants descendants order order descendants order computing linear order nodes rag 
example example rag depicted 
rag expresses binary ary query 
applied tree query returns linear order tree nodes corresponding postorder traversal tree 
example easily generalized arbitrary grammars 
mentioned rags seen model wrappers 
tools map relevant parts document hand instance relational database 
give example illustrate 
example grammar models list publications 
publication consists list authors title 
want wrapper generating binary relation consisting pairs author publication title rag expresses transformation 
node contains set authors author list associated pub node result contains pairs author title publication represented course binary relation created real wrapper opposed abstraction rags contain actual string content actual names authors titles just nodes document corresponding 
pub result result result pub result result pub title result author author rags abstraction wrappers 
expressive power bags section characterize expressive power bags terms monadic second order logic mso 
corollary obtain bottom property boolean bag queries 
recall de nitions tree automata mso 
tree automata mso tree automata theory tree languages trees usually viewed terms ranked alphabet 
ranked alphabet vocabulary function symbols associated arities 
set trees inductively de ned manner function symbol arity 
trees tree base case de nition constant symbols function symbols arity 
tree thought labeled tree nodes subterms including node form labeled de nition bottom deterministic tree automaton triple consisting nite set states set nal states transition function mapping tuples form arity elements function extended canonical manner mapping tree accepted set trees accepted denoted called tree language de ned 
set trees tree language recognizable exists tree automaton 
monadic second order logic maximal arity function symbols ranked alphabet 
tree naturally viewed nite structure sense mathematical logic binary relation symbols fs unary relation symbols fo denote vocabulary associated domain viewed structure equals set nodes relation equals set pairs th child set equals set labeled nodes monadic second order logic mso allows set variables ranging sets nodes tree addition individual variables ranging nodes provided standard rst order logic 
detailed exposition logic ebbinghaus flum book 
example consider mso formula note set variable variables particular free variables individual variables 
tree nodes ancestor ancestor set nodes contains closed child relations contains denote set monadic second order formulas mso 
clear context omit just write mso 
consider tree sequence sets nodes view tuple labeling node labeled ranked alphabet obtained follows function symbol function symbol arity tree tree 
mso formula free set variables 
set viewed set trees 
de nition tree language mso de nable exists mso formula standard theorem theory logic tree languages states theorem natural number 
tree language mso de nable recognizable 
important special case tree language de ned mso sentence 
tree language de ned ft set trees set trees annotation 
derivation trees trees link derivation trees trees 
associate grammar ranked alphabet follows terminal symbol constant symbol production function symbol arity derivation tree naturally viewed tree 
previous section de ned mso trees 
context derivation trees alphabet bit convenient vocabulary fs ox 
de ned ox unary relation speci es nodes tree labeled vocabularies easily de ned terms 
ox fo pg ox vocabulary explicitly speci ed say tree mean derivation tree 
main theorem show unary queries expressed bags exactly de nable mso 
mso usual way de ne unary queries 
de nition mso formula free individual variable 
de nes unary query de ned fn tree lemma query expressible bag de nable mso 
proof 
bag 
know lemma tree exists valuation satis es mso easily de ne valuation 
attribute set variable variable contain nodes attribute true 
associate formula semantic rule way 
consider rule context production de ne formula ox obtained replacing propositional symbol occurring 
intuitively formula states 
derived production formula states holds true 
de ne disjunction rules de ning attribute de ne formula tree set nodes 
de ne valuation follows follows de nition satis es lemma exists valuation satis es follows exists sequence sets 
formula de nes query expressed result state prove rst main result 
theorem unary query expressible bag de nable mso 
proof 
direction lemma 
direction consider unary query de ned free individual variable de ne mso formula having free set variable free individual variables 
formula de nes set nodes selected 
theorem set recognizable tree language 
tree automaton recognizing language 
derivation tree accepts exactly pairs 
note constructed way tree exactly set nodes fn words automaton accept exactly labeling accepted labeling labels precisely nodes result query de ned 
idea 
theorem proved construct bag attribute result tree node result true labeled labeling accepted achieved simulating execution possible labelings 
important realize de ned original grammar de ned annotated vocabulary bag behaves follows 
rst bottom pass tree synthesized attributes de ned node state true assumes state execution labeling accepted labeling unique exactly nal state true root de ne synthesized attributes start symbol true states false 
second top pass tree inherited attributes de ned nodes node true possible execution assumes parent state true 
show assumes state accepted labeling true 
attributes de ned particular node set desired value attribute result construction 
formally bag constructed follows 
set attributes de ned qg qg terminal inh non terminal start symbol syn qg inh qg 
start symbol syn production 
semantic rules usual empty disjunction false terminal add rule true false 
pu qg start symbol add semantic rule false 
assumption start symbol occur right hand side production know occurrence tree root 
second top pass start root 
add rule pu qg add rule result qg terminal add result qg get rid assumption allowing start symbol inherited attributes 
formalism attribute grammars elegant 
harmless technical assumption concerning start symbol 
correctness 
establish correctness fix derivation tree labeling nodes 
denote corresponding labeled tree 
node denote subtree root 
labeling labeling labeling node node lemma proved straightforward induction height lemma node true exists labeling assumes state execution input 
deterministic node true exist di erent labelings assumes state execution 
exactly labeling accepts 
particular assumes state root 
exactly true 
de nition semantic rules attributes true 
lemma true assumes state 
proof 
show induction depth base case just treated 
consider node children 
derived production ng 
suppose true 
exists pu true 
follows exists labeling assumes state 
de ne labeling follows 
follows assumes state 
follows inductive hypothesis assumes state 
tree accepted accepted labeling follows restriction assumes state 
ii suppose assumes state 
state assumes 
pu assumes state inductive hypothesis true lemma true true de nition 
show node result true 
derivation tree exactly proof complete 

leaf node labeled 
suppose result true 
exists state true follows lemma assumes state 
case accept labelings ii suppose state assumes 
result true 

interior node children derived production 
suppose result true 
exist states true 
follows lemma assumes state state case accept labelings ii suppose state assumes state assumes 
result true 
corollary proof theorem obtain normal form bags 
bag described proof special ways 
needs positive formulas involving connectives semantic rules 
second evaluated tree bottom pass followed top pass 
corollary bag equivalent uses positive formulas semantic rules evaluated passes precisely simply pass 
part corollary nd equivalent bag uses positive rules quite easily seen directly 
bag attribute grammar vocabulary syn inh att 
construct equivalent bag attribute grammar vocabulary syn inh att negation semantic rules way 
attribute add attribute true attribute false 
formally fn ag grammar symbol syn syn fn syn inh inh fn inh rule context add rule context rule context formula obtained transforming disjunctive normal form replacing literal 
example bag example uses negation select nodes numbered position 
bag depicted retrieves nodes negation 
clarity replaced attribute neven odd 
false bs odd odd result false odd true result false true false example bag negation 
bottom property boolean bag queries view bag way version nite bottom tree automata alternative classical way generalization tree automata provided 
way generalization provided di erent types attributes bag intuitively synthesized attributes provide bottom direction inherited attributes provide top direction 
proposition relates bags tree automata 
proposition tree automaton exists bag derivation tree accepts accepts bag uses synthesized attributes 
proof 
execution easily simulated bag having synthesized attributes states node attribute value true assumes state execution production fj ng ng 
add semantic rule attribute result de ned rule result 
follows theorem proposition nable boolean query expressible synthesized bag 
leads bottom property boolean bag queries corollary bag bag having synthesized attributes express boolean query 
general case arbitrary attribute grammars semantic rules arbitrary computable functions known inherited attributes simulated synthesized attributes see similar phenomenon holds semantic rules propositional formulas 
corollary hold bags expressing unary queries illustrated example 
example consider grammar example 
query expressed synthesized inherited attributes retrieves nodes rst letter string retrieves nodes 
query expressed synthesized attributes 
synthesized bag decide select letter string having visited rst letter knowing rst letter carries argument holds bags having inherited attributes 
expressive power rags section characterize rags queries de ned rst order inductions linear depth equivalently computable linear time parallel machine polynomially processors 
show contrast bags boolean queries synthesized rags strictly expressive rags synthesized inherited attributes 
bottom property boolean rag queries 
subsection discuss relationship mso rags 
introduce necessary logical de nitions 
fixpoint logic see ebbinghaus flum book background logics de ne 
partial xpoint logic fixpoint logic allows rst order logic formulas iterated 
consider kinds xpoint logics 
rst order logic formula vocabulary free individual variables ary relation variable addition relation symbols provided vocabulary 
tree de nes relations obtained iterating starting empty relation de ne say converges xpoint exists 
denote xpoint 
reach xpoint de ne empty set 
de ne partial xpoint logic pfp follows formulas constructed just rst order logic addition allow atomic formulas form pfp ary rst order logic formula 
semantics follows tree nodes 
pfp formula pfp called positive occurrence variable occurs number negations 
formulas described iteration process reaches xpoint nite number stages 
xpoint xpoint operator de ned tree operator maps ary relations domain ary relations de ned de ne xpoint logic lfp way pfp formula form lfp positive 
note de nitions pfp lfp di er literature allow nesting xpoints allow parameters formula constituting xpoint 
dispensed de nitions equivalent usual ones 
fixpoints linear depth consider pfp formula form pfp exist natural numbers tree reaches partial xpoint 
jtj iterations jtj denotes number nodes say linearly bounded partial xpoint semantics 
de ne logic pfp lin fragment pfp partial xpoints linearly bounded formulas allowed 
lfp lin fragment pfp lin allows formulas xpoint operator positive linearly bounded 
simultaneous xpoint logic system rst order formulas ary relation variable 
tree consider stages de ned say system reaches simultaneous xpoint exists 
denote relation de ned xpoint 
exist simultaneous xpoint de ned empty set 
de ne simultaneous partial xpoint logic pfp follows formulas constructed just rst order logic addition allow formulas form pfp ary rst order formula semantics de ned follows tree nodes 
pfp say system rst order formulas linearly bounded simultaneous partial xpoint semantics exist natural numbers derivation tree system rst order formulas reaches simultaneous partial xpoint 
jtj iterations 
de ne logic pfp lin fragment pfp simultaneous partial xpoints linearly bounded systems rst order formulas allowed 
proposition states pfp lin equivalent pfp lin 
particular means mutual recursion replaced simple recursion preserving linearly boundedness 
proof exactly proof simultaneous induction lemma known theory inductive de nitions nite model theory 
proposition pfp lin formula form pfp kg equivalent pfp lin formula form pfp main theorem relate rags pfp lin 
pfp lin formulas express ary queries way de nition pfp lin formula 
expresses ary query de ned tree theorem query derivation trees expressible rag de nable pfp lin 
proof 

rag 
assume semantic rule contains variable 
de ne pfp simulates induction variables system ary relation variable attribute stands set tuples ra node labeled att ra tuple currently computed value 
attribute formula ra de ning recall arity attribute new value old values built follows 
consider rule ra context production formula ra de ned ox obtained replacing occurrence replacing occurrence constant symbol formula disjunction rules de ning attribute ra ra formula pfp result zj equals arity result 
easy induction show node attribute de ned nodes ra ra ra implies ra ra tree smallest integer obviously jaj 
jtj 
pfp formula reaches xpoint jaj 
jtj iterations 
proposition gives desired formula pfp lin 

crux proof simple observation rag computes relations derivation tree viewed relational structure bottom pass tree 
subsequent top pass relations available nodes 
linearly bounded iteration rst order formula simulated preorder traversal tree di erent stages passed relational attribute values 
formally describe rag expresses query de ned pfp lin formula 
compute relations derivation tree binary attributes maximum width production unary attributes attributes synthesized non terminals inherited terminals 
de ned semantic rules 
consider production de ne de ne 
terminal de ne de ne 
values relations root form relational structure represents derivation tree 
values available nodes attributes ox attributes synthesized start symbol inherited symbols de ned rules 
production form de ne ox production form de ne ox ox pfp lin formula 
rst order combination formulas form ox pfp 
relation ox available root 
suces compute subformula pfp occurring attribute available root 
numbers reaches xpoint 
jtj iterations tree exists rst order formula de nes stages 
variables occur de ne formula obtained replacing atomic formula form formula rag evaluates formula pfp way stages evaluated root tree achieved evaluating formula 
preorder traversal tree evaluating stages evaluating formula node 
formally describe rag uses ary attribute synthesized start symbol inherited grammar symbols ary attribute synthesized nonterminals inherited terminals 
attributes de ned semantic rules 
consider production form 
add rule 
de ne obtained replacing occurrence ox ox respectively replacing occurrence 

terminal de ne 
obtained replacing occurrence ox ox respectively replacing occurrence 

de ne note tree evaluation performs exactly 
jtj iterations 
iteration exactly attribute exactly attribute de ned 
tree number attributes de ned 
correctness construction follows lemma lemma derivation tree node fz de ned 
lemma proved induction pair 
equals relation de ned pfp root logic pfp lin bizarre syntax allows iteration formula formula linearly bounded obvious syntactic property 
know linear boundedness rst order formulas derivation trees xed grammar decidable 
graphs property shown undecidable reduction validity derivation trees equivalently trees ranked alphabet satis ability validity rst order logic monadic second order logic decidable 
problem bizarre syntax avoided de ning alternative manner 
alternative iteration formula allowed syntax trivially decidable 
build semantics iteration performed exactly times cardinality domain 
dicult adapt proof theorem alternative view pfp lin 
complexity rags immerman showed lfp lin captures complexity class cram consisting queries computable time parallel machine polynomially processors 
theorem lfp lin cram class ordered nite structures 
theorem theorem show corollary query expressible rag computable linear parallel time polynomially processors 
proof 
lemma ii show pfp lin lfp lin class trees 
theorem pfp lin cram class ordered trees 
theorem suces show pfp lin cram class trees linear order 
order requirement theorem needed show cram program simulated lfp lin formula 
readily follows pfp lin cram class trees linear order 
remains show converse inclusion 
cram program trees linear order pfp lin formula simulating expository purposes assume form pfp 
lemma exists pfp lin formula pfp computing linear order 
simply plug formula pfp occurrence allow nesting xpoints 
composition trick rst compute ordering start iterating 
just formula pfp formula lin 
ord 

lin 
ord 
rst order logic formula de ning total linear order formula obtained replacing occurrence 
de nition iteration starts linear order 
linearly bounded 
proposition equivalent pfp lin formula 
remains prove lemma 
lemma exists pfp lin formula uniformly de nes total order trees 
ii pfp lin lfp lin class trees 
proof 
example shows ordering binary tree obtained rag 
straightforward generalize construction arbitrary derivation trees 
theorem rag equivalent pfp lin formula 
ii example saw compute ordering tree rag 
compute ordering directly lfp lin 
equivalence lfp lin pfp lin trees reduces equivalence ordered trees compose computation ordering pfp constructs proof previous theorem 
proof equivalence similar proof known fact lfp equals ptime ordered structures thm see 
ptime denotes fragment pfp xpoint reached polynomial number iterations 
bottom property rags section prove synthesized rags rags synthesized attributes strictly expressive rags synthesized inherited attributes 
rest section grammar fu ll fg 
derivation trees grammar consists simply monadic trees concatenated root 
equal subtree query true left subtree number nodes right subtree 
show query expressed synthesized rag 
expressed rag 
proposition query equal subtree expressible rag 
proof 
theorem suces show equal subtree de nable pfp lin pfp formula maintains binary relation rst iteration rst node left subtree rst node right subtree put iterations pair corresponding nodes added provided exists 
iterates jtj times tree belongs pfp lin 
formula true node left subtree node right subtree belong appendix formally prove theorem 
theorem query equal subtree expressible synthesized rag 
rags versus mso characterized bags unary queries de nable mso theorem rags queries arbitrary arity de nable pfp lin theorem 
remains compare formalisms 
show synthesized rags strictly powerful mso 
mso standard way de ne queries arity de nition mso formula 
de nes ary query de ned tree theorem ary query derivation trees de nable mso expressible rag synthesized attributes 
proof 
consider mso formula 
tree nodes 
view tuple labeling elements labeling node 
tree de ned section 
easy write mso sentence derivation tree nodes 
de ne set grammar symbols th component fx de ned ox ox formula obtained replacing atomic formula ox ox 
theorem exists tree automaton de ned accepts derivation tree 
theorem proved construct rag derivation tree simulates parallel possible labelings returning labelings accepted ary relation valued synthesized attributes state semantic rules node assumes state node execution 
attribute result root de ned set nal states formula match de nes labelings tree node labeled match production de ne fi ng ng 
de ne semantic rule match qg formula match false 
correctness construction follows lemma easily proven induction height lemma derivation tree 
node assumes state node execution labeled tree 
concludes proof 
proof previous theorem proof theorem involves simulation parallel tree automaton di erent labelings tree 
simulation straightforward simply parameterize simulation relation valued attributes 
possible case bags theorem boolean valued attributes simulation intricate 
particular theorem states synthesized attributes rag express mso case bags 
explained section bags synthesized attributes weaker mso 
nally show synthesized rags strictly powerful mso 
holds assumption underlying grammar generate nite number derivation trees 
de nition grammar unbounded number derivation trees nite 
clearly grammar unbounded number derivation trees nite rags mso equally powerful query simply reduces case analysis 
theorem unbounded grammar synthesized rags express boolean queries de nable mso 
proof 
consider unbounded grammar exists sequence productions sequence numbers km non terminal left hand side occurs position km right hand side ii symbol position right hand side equals non terminal lefthand side iii left hand sides mutually distinct iv reachable start symbol 
consider derivation tree say node occurrence exists sequence nodes 
nm nm derived th child say nm tail occurrence note nm labeled call sequence nodes chain occurrences occurrence tail occurrence derived length chain occurrences boolean query de ned follows derivation tree true chain occurrences starting rst labeled node preorder traversal tree length power 
note true tree labeled node 
show expressible mso 

theorem exists tree automaton accepting precisely trees satisfying 
consider tree length denote chain occurrences starting rst labeled node preorder traversal tree power bigger jqj 
nodes descendant occurrences chain denotes subtree root th occurrence th occurrence chain 
tree obtained replacing subtree subtree 
chain occurrences starting rst labeled node preorder traversal length power 

de ne appendix formally show expressible synthesized rag 
corollary note corollary rags express unary queries bags 
relational attribute grammars relational attribute grammars generalization standard attribute grammars introduced courcelle 
relational attribute grammars semantic rules longer specify functions computing attributes terms attributes relations attributes 
longer distinction synthesized inherited attributes values attributes longer uniquely determined relational attribute grammars confused relation valued standard attribute grammars rags previous section 
fact section consider relational versions rags 
tree 
consider relational attribute grammars context bags rags discuss express queries 
show bags increase expressive power case rags complexity classes np conp coup captured 
relational bags attribute grammar vocabulary just tuple att nite set attributes att function powerset relational bag assigns production propositional formula set propositional symbols fa ng att valuation derivation tree mapping assigns truth value node attribute label node children derived production formula associated de ne 
formula obtained replacing propositional symbol form new propositional symbol 
arbitrary total valuation said satisfy 
true internal node relational bag express unary queries various ways 
unary query relational bag 
designate attributes attribute result 
expressed existentially derivation tree fn exists valuation satis es result trueg ii expressed universally derivation tree fn valuation satis es result trueg iii expressed implicitly derivation tree exists exactly valuation satis es result true 
bs result result example relational bag 
denote class unary queries existentially respectively universally implicitly expressible relational bags bag respectively bag 
example example relational bag depicted 
expresses existentially universally implicitly query expressed bag example 
theorem says going bags relational bags increase expressive power 
theorem bag bag bag 
proof 
clearly lemma bag bag bag bag bag 
theorem prove query bag bag de nable mso 

query existentially expressed relational bag de ned mso formula xn result set attributes fo formula expresses nodes derived production formula obtained replacing occurrence 
intuitively de ne valuations satisfy 
query universally expressed relational bag de ned mso formula xn result de ned 

query implicitly expressed relational bag mso formula de nes 
relational rags attribute associated arity relational rag associates production fo sentence vocabulary fa att ng constant symbol relation symbol arity valuation derivation tree mapping assigns ary relation nodes node attribute label node children derived production fo sentence associated de ne 
fo sentence obtained replacing occurrence relation symbol relation symbol replacing constant symbol node valuation said satisfy 
evaluates true relation symbol 
interpreted relational rag express ary queries various ways 
query relational rag 
designate attributes ary attribute result 
denote root 
expressed existentially derivation tree exists valuation satis es result ll 

result example relational rag 
ii expressed universally derivation tree valuation satis es result iii expressed implicitly derivation tree exists exactly valuation satis es result 
denote class unary queries existentially respectively universally implicitly expressible relational rags rag respectively rag 
example example relational rag depicted 
rag expresses existentially boolean query true tree number nodes left subtree equals number nodes right subtree 
tree root left child right child root 
valuation satis es contains nodes left subtree contains nodes right subtree 
sentence associated root true contains bijection 
clearly query expressible rag rag rag 

semantic rules rag associated production corresponding relational rag just replace single rule correct translation discussed semantics lemma exists valuation tree satis es theorem characterize classes relational rag queried terms complexity classes np complements np known class problems decidable polynomial time non deterministic turing machine unambiguous accepting computation input 
obtain theorem 
rag equals class queries np 
rag equals class queries conp 
equals class queries coup 
proof 

containment rag np clear 
converse fagin theorem states queries expressible np exactly de nable existential second order logic 
formula form relation variables fo formula vocabulary expanded relation symbols fz consider formula 
proof theorem construct rag computes relations derivation tree viewed relational structure 
add rag rule start symbol result obtained replacing replacing relation vocabulary relational structure corresponding attribute 
follows relational rag expresses existentially query de ned 

prove rag queries computable conp complement fagin theorem conp universal second order logic 
proof analogous 
ary query belongs complexity class decision problem 
clearly coup 
sequence queries 
say sequence implicitly de nable fo fo sentence vocabulary derivation trees augmented fz tree sequence sequence relations 
write imp fo denote collection queries sequence queries implicitly de nable fo 
analogously shown query imp fo expressible rag 
kolaitis proved class ordered structures query de nable imp fo computable coup 
trees consider ordered 
ordered rag saw lemma 
concluding remarks results obtained summarized 
arrow class queries class queries means negated arrow means boolean query bags language expressing simple retrieval queries strike reasonable balance expressive power complexity hand powerful monadic second order logic hand evaluated linear time 
rags language expressing general relational queries structured documents er expressive power bags remaining polynomial time complexity 
mentioned theorem independently proved engelfriet 
investigate bags considered nite valued attribute grammars 
attribute grammars values attributes come xed nite set 
readily seen express unary queries bags 
engelfriet 


hy synthesized bag synthesized rag rag conp rag pfp lin cram rag np coup non boolean queries bag bag bag mso summary results 
study expressiveness attribute grammars model query language 
goal proving equivalence tree transformation languages 
precisely main result shows equivalence mso tree transducers stage attribute grammars rst stage compute relabeling tree means nite valued attribute grammar second stage compute output tree means tree valued attributes 
abiteboul cluet milo 
logical view structured les 
vldb journal 
abiteboul vianu 
computing rst order logic 
journal computer system sciences 
engelfriet 
comparison tree transductions de ned monadic second order logic attribute grammars 
journal computer system sciences 
courcelle 
proofs partial correctness attribute grammars applications recursive procedures logic programming 
information computation 
jourdan 
attribute grammars de nition systems bibliography volume lecture notes computer science 
springer 

tree acceptors applications 
journal computer system sciences 

ebbinghaus flum 
finite model theory 
springer 

ebbinghaus flum thomas 
mathematical logic 
undergraduate texts mathematics 
springer verlag second edition 
enderton 
mathematical logic 
academic press 
fagin 
generalized rst order spectra polynomial time recognizable sets 
karp editor complexity computation volume siam ams proceedings pages 


tree languages 
rozenberg salomaa chapter 

tree automata 
budapest 
goldfarb 
sgml handbook 
clarendon press 
gonnet tompa 
mind grammar new approach modelling text 
proceedings th conference vldb pages 
hopcroft ullman 
automata theory languages computation 
addison wesley 
immerman 
expressibility parallel complexity 
siam journal computing 
knuth 
art computer programming volume 
addisonwesley 
knuth 
semantics context free languages 
mathematical systems theory 
see mathematical systems theory 
kolaitis vardi 
nitary logics laws 
information computation 
ph 
kolaitis 
implicit de nability nite structures unambiguous computations 
proceedings th ieee symposium logic computer science pages 
ieee computer society press 
mecca atzeni merialdo 
araneus web base management system 
proceedings acm sigmod international conference management data volume acm sigmod record pages 
acm press 

way tree automata 
information processing letters 
moschovakis 
elementary induction structures 
northholland 
papadimitriou 
computational complexity 
addison wesley 
papakonstantinou garcia molina widom 
object exchange heterogeneous information sources 
proceedings th international conference data engineering pages 
ieee computer society press 
rozenberg salomaa editors 
handbook formal languages volume 
springer 
thatcher wright 
generalized nite automata theory application decision problem second order logic 
mathematical systems theory 
thomas 
languages automata logic 
rozenberg salomaa chapter 
leslie valiant 
relative complexity checking evaluating 
information processing may 
vardi 
automata theory database theoreticians 
proceedings eighth acm symposium principles database systems pages 
acm press 
wood 
standard generalized markup language mathematical philosophical issues 
van leeuwen editor computer science today 
trends developments volume lecture notes computer science pages 
springer verlag 
appendix appendix prove theorem 
start de nition 
de nition simple rag synthesized rag attribute grammar vocabulary attribute zero ary attribute result focus attention simple rags show synthesized rag transformed equivalent simple 
integers greater denote tree left subtree length right subtree length simple rag 
lemma show values rst child second child root uniformly de ned pfp structure essentially contains ordering part domain 
need de nitions 
de nition vocabulary consisting constant symbols binary relation symbol integers greater 
de ne structure domain interpreted total order 
de ne similarly interpreted total order fn pfp formula vocabulary de ne relation de ned lemma simple rag 
exists pfp formula rc rst child second child root 
proof 
rule context rule context 

rc variables occurring de ne formula root pfp root fo formula de nes root tree rc formula succ rst element succ successor function obtained obtained replacing occurrence occurrence succ obtained replacing occurrence occurrence occurrence variables sure relation empty 
happen de nes empty relation xpoint empty 
lemma immediate observation 
lemma pfp formula greater fn fn fn fn ii fn fn proof 
follows fact pfp distinguish elements 
clearly transposition elements fn automorphism transposition elements automorphism 
de nition pfp formula vocabulary integers greater 
vocabulary consisting constant symbols ary relation symbols de ne structure domain 
show certain assumptions structures fo formula split formulas essentially speak relation relation 
lemma pfp formula free variables 
assume fo formulas fn fo formula vocabulary expanded unary relational symbols exists disjunction fo formulas form contain contain form 
holds proof 
proof goes induction structure 
assume constants appear atomic formulas equalities 

equals empty disjunction 

equals true true 

suppose 
true true 

suppose rst introduce notation 
de ne set symbols natural number 
variables de ne formula de ne 
suppose 
de ne true 
suppose 
symmetric 

suppose 
fy fz fx fu fy fz fv fz fy inductive hypothesis exists equivalent form equivalent form formula obtained replacing disjunct replacing disjunct 
suppose 
inductive hypothesis equivalent form equivalent transform formula equivalent right form 
replace 
form 
put resulting formula disjunctive normal form literals formulas 
disjunct looks form 
disjunct discarded di erent variable 
de ne formula de ne formula variables fx disjunct 
replace disjunct 
suppose 
inductive hypothesis equivalent form equivalent equivalent false equals formula obtained replacing occurence variable subformula right form 
disjunct de ne de ne 
de ne correctness follows lemma ii 
de ne 
de ne correctness follows lemma de ne lemma prove fo formula speak respectively formula general distinguish respectively lemma pfp formula vocabulary suppose contains distinct variables 
fo sentence vocabulary contains distinct variables contain relation symbol ii fo sentence vocabulary contains distinct variables contain relation symbol proof 
prove ii symmetric 
assume variables common 
structure restricted speak suces prove suppose exist formula obtained replacing atomic subformula exists sentence variables distinguishes 
pebble games easy show indistinguishable pfp variables 
leads desired contradiction 
starting actual proof show simulate attributes attribute 
lemma synthesized rag equivalent simple proof 
suppose attributes 
grammar symbol attributes result 
start symbol show equivalent simple rag assume variables 
rc occurs semantic rule formula fy kg ig simulation relations 
relation usual see proof simultaneous induction lemma 
detail refer 
rule context 
de ne context rc ra rule context 
de ne context rc ra obtained replacing occurrence variables common 
result rule context ll result rule context ll 
assume 
variables common 
formula obtained replacing occurrence 
de ne result formula obtained replacing occurrence variables common 
follows tree root result true result true 
putting pieces prove theorem 
contradiction suppose equal subtree expressible synthesized rag 
suppose attributes 
grammar symbol attributes result 
start symbol assume set valued attribute contains node descendants production de ne production de ne 
lemma equivalent simple rag suces show express equal subtree 
lemma exists pfp formula rc rst child second child root 
sentence de nes result result true obtained replacing occurrence occurrence root 
de ne note just de ne value respectively 
formula de ned proof lemma encode attributes 
fn lemma equivalent sentence form sentences contain sentences contain free variables 
assume variables common 
number variables number variables simple counting argument exist applying lemma twice lemma ii follows result true result true express equal subtree 
concludes proof theorem 
appendix appendix show query proof theorem expressible synthesized rag 
rag computing uses synthesized attributes non terminals 
boolean attribute true node labeled descendants note non terminal 
chain boolean attribute chain false labeled node descendants chain occurrences starting rst labeled node preorder traversal subtree root chain true length chain occurrences starting rst labeled node preorder traversal subtree root power 
note node derived length chain occurrences starting node power 

set valued attribute contains descendants 
binary attribute 

occ boolean attribute occ true derived mg exist nodes nm chain occurrences starts nm derived th child 
boolean attribute true derived 
set valued attribute subset 
occ false empty occ true derived nodes encode starting nm nm de ned contains nodes 
occur respectively th 
th position ordering encodes number 
occ true derived nodes encode 
starting rag de ned follows 
consider production de ne fi ng 
write shorthand ng 
de ne true chain true fo sentence truth value equals chain smallest true exists false 

de ne fe ng jg occ false false de ne result chain 
de ne true chain occ attribute chain true occ true contains exactly element encodes number power 
de ne fe reason de nition order correctly represent number sure elements come elements ordering occ occ true occ succ succ succ successor function rst element ordering 

de ne chain de ned 
de ne fe occ occ false occ 
nm de ne true chain de ned 
de ne nm km fe nm km km occ occ false de ne fo sentence expresses contains singleton consisting rst element false equals occ true 

