generative temporal planning complex processes jonathan electrical engineering computer science massachusetts institute technology submitted department electrical engineering computer science partial fulfillment requirements degree master engineering electrical engineering computer science massachusetts institute technology october copyright jonathan 
rights reserved 
author permission reproduce distribute publicly electronic copies thesis right 
author department electrical engineering computer science october certified brian williams thesis supervisor accepted arthur smith chairman department committee graduate theses generative temporal planning complex processes jonathan submitted department electrical engineering computer science october partial fulfillment requirements degree master engineering electrical engineering computer science autonomous vehicles increasingly mission critical applications robust methods needed controlling inherently unreliable complex systems 
thesis advocates model programming allows mission designers program autonomous missions level coach wing commander 
support system thesis presents spock generative planner 
generate plans spock able piece vehicle commands team tactics complex behavior represented concurrent processes 
contrast traditional planners operators represent simple atomic durative actions 
spock represents operators rmpl language describes behaviors parallel sequential compositions state activity episodes 
rmpl useful controlling mobile autonomous missions allows mission designers quickly encode expressive activity models object oriented design methods intuitive set activity combinators 
spock significant uniformly represents operators plan space processes terms temporal plan networks support temporal flexibility robust plan execution 
spock implemented forward progression optimal planner walks monotonically forward plan processes closing open conditions resolving conflicts 
thesis describes spock algorithm detail example problems test results 
thesis supervisor brian williams title associate professor aeronautics astronautics table contents 
motivation 
model programming example 
spock generative planner 
reactive model programming language rich activity operators goal specifications 
flexible time bounds temporal plan networks 
forward progression planning 
thesis layout 
related 
constraint interval planning 
hierarchical task network planning 
graph planning 
forward progression planning 
reactive model programming language 
rmpl overview 
example scenario rmpl program 
rmpl combinators 
rmpl subsumption pddl operators 
rmpl spock generative planner 

temporal plan networks 
tpn overview 
example tpn 
rmpl tpn mapping 
executability temporal plan networks 
tpn consistency 
tpn completeness 
tpn subsumption pddl operators 
summary 
spock generative tpn planning algorithm 
overview 
internal plan candidate representation 
child expansion 
checking candidate consistency 
continuation combining equivalent tell constraints 
ensuring systematicity 
preserving search completeness 
candidate cost update 
summary 
results 
implementation 
performance 

extending rmpl support additional temporal constraints 
implementation efficiency improvements 
summary 

list figures complex process example 
titan model executive architecture 
spock generative planner kirk model executive architecture fire rescue scenario 
rmpl program paradigm comparison 
example rmpl control program 
example temporal plan network 
allen interval relationships 
plan graph 
example graph planner sub optimality 
example rmpl program 
rmpl combinators supported kirk strategy selection algorithm 
rmpl combinators supported spock 
rmpl subsumption pddl operators 
temporal plan network constructs 
example temporal plan network 
temporally inconsistent tpn 
inconsistent tpn corresponding distance graph 
tpn distance graph pseudo code 
tpn threat resolution 
example complete tpn 
mapping pddl operators tpn activities 
spock block diagram 
spock top level pseudo code 
forest fire suppression scenario 
control program rmpl code tpn fire suppression mission 
activity library rmpl code tpn fire suppression mission 
solution tpn fire suppression mission 
plan candidate structure 
activity enablement 
event enablement 
enablement episodes 
child expansion pseudo code 
find enabled activities pseudo code 
example activity instantiation 
find enabled episodes pseudo code 
episode insertion 
causal link 
find conflicting tells pseudo code 
insert episode pseudo code 
event insertion 
find enabled events pseudo code 
insert event pseudo code 
example inconsistent candidate 
fifo label correcting algorithm detecting negative cycles distance graph 
continuation problem solution 
insert episode pseudo code support continuation 
continuation example 
motivation systematicity 
spock child expansion pseudo code blocking 
search tree independent candidate expansions 
cases un enablement 
expansion tree enabled ask episode event 
expansion tree conflicting enabled episodes 
test scenario activity library 
example candidate graph heuristic cost estimation 
relaxed candidate graph heuristic cost estimate 
rmpl tpn limitation 
list tables table rmpl primitives tpn sub networks 
table rmpl combinators tpn sub networks 
table performance spock generative tpn planner 
contained thesis accomplished help support numerous individuals 
foremost advisor professor brian williams invaluable resource 
offer professor williams special giving sage advice providing freedom explore various research topics member mers research group 
group administrative assistant margaret yoon group greg sullivan martin fellow graduate students hsiang shu raj krishnan judy chen oliver martin seung chung paul elliott andreas john undergraduate research assistants paul adam kraft shen qu radu rick sheridan 
technical revisions discussions genuinely appreciate friendship 
importantly family love support 
successes due opportunities provided am forever grateful 
thesis supported darpa mica mixed initiative control teams program contract autonomous robots increasingly important tool military space exploration civilian applications 
example nasa needs autonomous robots send human explorers remote locations solar system safety financial reasons 
furthermore advantageous military able robots help fight wars human beings 
case successfully applying robots achieve mission goals requires flexible robust control system 
lower landing gear reduce engine thrust start adjust wing flaps complex process example key requirement controlling mobile autonomous robots ability express vehicle activity models complex processes 
example automated landing operator unmanned aerial vehicle uav need include primitives lower landing gear adjust wing flaps reduce engine thrust including timing constraints ensure engine thrust lowered wing flaps landing gear set place see 
enable generative planning complex processes thesis presents spock planner 
spock supports generative planning complex processes key contributions 
spock goal plans activity models encoded reactive model programming language rmpl 
rmpl innovative way mission programmers easily specify control programs activity operators supports rich set intuitive process combinators object oriented framework 
second spock represents goal plans plan operators plan candidates uniform representation called temporal plan network tpn 
significant support temporal flexibility simple temporal constraints enable dynamic scheduling improve mission robustness :10.1.1.40.1018
third spock implemented forward progression planner 
combined relaxed heuristic cost estimate approach shown support fast planning requirement real world autonomous control system 
remainder chapter motivate development model executive mobile autonomous systems introduce rmpl give overview spock generative planner 
motivation achieving robust autonomous control challenging problem autonomous robots typically hundreds thousands interacting components controlled monitored 
encode relationships system components languages raps esl tdl allow mission designers program autonomous robots redundant methods goal monitoring simultaneously expressing necessary constraints system components 
robotic execution languages ideal anticipated circumstances problem arises unforeseen contingencies occur 
robotic execution languages require mission designers hierarchically specify operator sequences contingencies 
mission contingency handled expansion hierarchy system fail 
model programming developed remove dependence pre specified monitoring diagnosis operator sequences elevate programming specification state evolutions 
model programming paradigm mission programmer commands autonomous robot terms intended state 
specifics achieving intended state delegated model executive titan see 
separates programmer goals implementation achieving goals removing unnecessary commitments planning process improving flexibility robustness autonomous robot may perform mission 
titan model executive architecture contributions thesis part mission level model executive called kirk see 
kirk designed control mobile autonomous robots rich environments rovers exploring surface mars unmanned aerial vehicles flying search rescue missions 
spock generative planner kirk model executive architecture mission designers program autonomous missions kirk level intended states similar titan activity level required raps 
goal specification set mission strategies kirk find execute safe plan achieving goal robust execution mobile autonomous robot missions 
enable model programming kirk needs able translate intended state evolutions specified control program action plan achieves state evolutions 
function provided spock generative temporal planner see central contribution thesis 
spock unique reasons 
able construct plans piecing operators representing complex processes see 
second spock supports temporal flexibility allows activity operators include durations lower upper bounds 
spock significant able generate optimal plans minimize various cost metrics total mission time number activities plan 
overview spock section motivate modelbased programming paradigm illustrative example 
model programming example demonstrate idea model programming consider example 
suppose family stranded needs forest see 
rescue mission launched threatening forest fires put 
mission commander unmanned aerial vehicles uavs disposal autonomous rescue helicopter unmanned fire fighting aerial vehicles 
forest fire rescue helicopter stranded family forest fire fire rescue scenario forest robotic execution language raps mission commander write program explicitly commands autonomous vehicle see left side 
particular mission commander responsible encoding contingency plans control program 
example crashes program specify relevant contingency 
necessary contingency omitted mission programmer plan fail 
rescue mission ok ok extinguish forest fire extinguish forest fire ok extinguish forest fire extinguish forest fire ok extinguish forest fire extinguish forest fire rescue helicopter rescue family rmpl control program specifies actions rescue mission forest fire extinguished forest fire extinguished family rmpl control program elevated intended states rmpl program paradigm comparison contrast model programming paradigm mission programmer writes control program sequential statements see right side 
forest fires extinguished 
stranded family 
simple control program model executive determines extinguish forest fires autonomous rescue helicopter rescue family 
proceeds automatically generate plan applies knowledge 
mission execution crash modelbased executive re examine goal forest fires autonomously derive alternate plan 
example crashes target forest fire extinguished model executive generate alternate plan instructs remaining extinguish forest fires 
model executive free deduce planning solutions unforeseen contingencies cause plan failure case possible solution exists 
spock generative planner enable model programming mobile autonomous systems thesis provides spock generative planner 
spock supports generative planning complex processes input language rmpl temporally flexible representation control programs operators plans called temporal plan network optimal forward progression planning algorithm 
rmpl innovative way mission programmers specify control programs activity operators supports rich set intuitive process combinators object oriented framework 
approach improves robotic execution languages allowing mission designers program terms intended state evolutions opposed explicit sequences specific activity operators 
significant support temporal flexibility simple temporal constraints enable dynamic scheduling improve mission robustness :10.1.1.40.1018
representation supports fast planning enables efficient graph algorithms determining plan consistency cost 
selection forward progression planning architecture motivated existing planners ff hsp 
planners achieved fast generative planning coupling forward progression planning relaxed plan graph heuristic cost estimate 
furthermore forward progression planners support optimality metrics time possible planning architectures 
input control program right side spock return executable solution plan combining control program environment model activities activity library 
spock implemented forward progressing optimal planner walks monotonically forward plan processes closing open conditions resolving conflicts 
rest chapter review greater detail spock main features rmpl control program activity modeling language tpn operator plan space representation processes spock forward progression planning algorithm 
reactive model programming language rich activity operators goal specifications important feature spock supports rich activity operators goal specifications order allow mission designers flexibility modeling robot behaviors mission scenarios 
achieved building reactive model programming language 
spock mission programmer writes control program reactive modelbased programming language rmpl 
rmpl uses process algebra describe intended state evolutions system similar executable specification languages esterel 
rmpl language allows programmers specify concurrent processes combining primitive commands state assignments parallel sequential compositions non deterministic choice pre emption conditional execution 
group enroute choose group fly path path path path tai pos maintaining path ok group fly path path path path tai pos maintaining path ok group transmit fac arrived tai group wait tai hold tai hold watching engage ok example rmpl control program example rmpl control program shown 
primitive expressions rmpl command executions group fly path state assertions path ok 
expressions combined demonstrated example nondeterministic choice choose parallel composition sequential composition activity time bounds pre emption maintaining watching 
rmpl supports modularity inheritance encapsulation abstraction adherence object oriented paradigm 
context thesis rmpl innovative describe complex processes operators planning problem 
allows spock planner incorporate rich activities represent real world behaviors automated landing operator 
rmpl language describing control programs activity operators 
full rmpl syntax supported kirk control programs 
spock conditional planner spock activity operators subset rmpl language includes activity timing state assertion sequential composition parallel composition maintaining combinator 
subset omits conditional statements non deterministic choice combinator 
resulting execution language sufficiently expressive representing complex processes spock activity operators 
flexible time bounds temporal plan networks important feature spock plans produces temporally flexible 
temporal planners activities fixed durations planner supports temporal flexibility uses time bounds express range durations essential trait context real world applications 
flexible time bounds motivated fact real world usually go schedule 
activity supposed take minutes may finish minutes minutes 
planners rely rigid schedules include slack compensate unexpected occurrences re plan frequently mission execution 
contrast plan representation supports flexible time bounds spock schedule mission activities dynamically eliminating need plan slack excessive replanning 
spock internal plan representation supports temporal flexibility called temporal plan network tpn central contribution thesis 
temporal plan network graphical depiction process representing plans plan space 
mission programmer finishes writing rmpl control program program converted temporal plan network graph represents space possible concurrent threads execution specified rmpl control program 
model executive operates tpn planning process 
superior temporally flexible plan representations timelines graph representation enables fast network algorithms efficiently evaluate plan consistency correctness perform dynamic scheduling 
compact representation data contained rmpl program constraints primitive activities open conditions expressed rmpl program direct mapping encoded tpn 
group fly path group wait ask path ok tell engage ok example temporal plan network example tpn corresponding rmpl control program example shown shown 
example non deterministic choice represented node parallel composition demonstrated nodes 
arcs tpn labeled lower upper time bounds 
temporal plan representation nodes tpn represent events time arcs correspond episodes intervals events 
episodes tpn simple temporal constraints bounding duration allowing activities flexible durations 
additionally tpn episodes contain primitive actions state assignments form ask tell constraints tpn planning represent open conditions activity effects close open conditions respectively 
group enroute group fly path ask path ok add support decision nodes allow network express nondeterministic choice part plan space representation 
kirk strategy selection algorithm searches tpn consistent sub graph return solution plan searching space choices decision nodes 
kirk strategy selection algorithm supports full tpn specification spock support decision nodes perform conditional planning 
spock utilizes rest tpn constructs order create uniform representation control programs activity operators internal plan candidates 
group transmit forward progression planning spock optimal forward progression planner 
goal plan form control program tpn spock walks monotonically forward tpn processes closing open conditions asks resolving conflicts mutually exclusive tells 
approach appropriate model programming mobile autonomous systems plans optimally framework supports fast planning 
remainder section argue importance features motivate selection spock forward progression architecture 
optimality essential controlling real world autonomous systems 
example mars observation satellite limited amount fuel guide orbital insertion 
control system executes sub optimal orbital insertion plan may fuel 
plan uses available fuel cause orbital insertion fail resulting vehicle loss 
best sub optimal plan result shorter mission duration fuel consumed maintain orbit science mission 
optimality important planner control real hardware capable finding globally optimal solutions various cost metrics total mission time resource consumption 
motivates spock forward progression planning architecture graph planners optimize total number plan steps layers 
hierarchical task network planners perform optimal fast planning operators 
planners rely explicit hierarchical expansion rules encoded mission programmer 
model programming paradigm avoids pre compiled expansion rules generative planning architecture forward progression needed 
credible useful real world applications planner able quickly solve reasonably sized problems 
motivates spock forward progression planning architecture forward progression search combined informative heuristic cost estimates shown effective way achieve fast planning 
style ff hsp spock capability including relaxed plan heuristic cost estimate upgrade search algorithm uniform cost search faster informed search 
plan candidate relaxed plan graphs reach goal constructed polynomial time simplified constraint rules 
relaxed graphs serve admissible estimate remaining cost candidate plan allowing planner search algorithm focus plan candidates yield optimal solutions 
section thesis describes possible relaxed plan heuristic cost function accelerate spock search algorithm achieve fast planning 
spock performs generative temporal planning forward progression planning algorithm 
approach motivated need spock fast optimal generative 
capabilities uniquely provided forward progression family planning algorithms justifying choice spock architecture 
thesis layout thesis presents chapter brief background field planning 
chapter introduces spock input language reactive model programming language 
chapter describes temporal plan networks graphs corresponding rmpl code serve spock control program activity plan candidate representation 
chapter explains spock generative planning algorithm detail including examples 
final chapter describes implementation provides test results spock performance concluding remarks discussion 
related planner described thesis builds fields constraint interval planning forward progression planning 
furthermore spock designed various alternative methods achieving fast planning evaluated including hierarchical task network planning graph planning 
chapter describes various approaches planning explains decision heuristic guided forward progression design 
constraint interval planning spock internal plan representation temporal plan network tpn inherits constraint interval plan representations 
similar constraint interval plans tpn contains episodes state assignments interval durations flexible time bounds 
differ regard episodes combined describe complex processes 
section gives overview constraintbased interval planning highlights specific features incorporated spock generative planner essential differences 
planning real world systems requires realistic representation time 
constraint interval planners address need plan actions interval durations 
rich notion time constraint interval planners add constraints action intervals allow expression mutual exclusion relationships preconditions hold particular action interval 
allen interval relationships intervals constraint interval planner ordered allen basic interval relationships meets overlaps starts contains equals ends see 
relationships planner constrain execution related actions ensure open conditions satisfied conflicting intervals occur 
furthermore allen relationships programmer writes activity model describe complex interactions system processes 
constraint interval planners hsts usually plan goal directed search :10.1.1.35.724
planning begins initial plan contains open conditions 
planner closes open conditions adding actions action library 
action added plan threat resolution ensures conflicting state assignments occur 
open conditions plan closed planner returns plan solution 
constraint interval plan duration action specified temporal flexibility upper lower time bound 
check conflicts interval plan temporal constraints start points interval plan represented variables constrained interval durations embedded plan 
constraints represented constraint network simple temporal network distance graph allows consistency checked efficient graph algorithms :10.1.1.40.1018
spock uses similar temporal representation terms simple temporal networks :10.1.1.40.1018
constraint interval planners usually describe concurrent processes fixed set timelines 
build processes process algebra allows processes naturally fork recombine 
constraint interval planners include representation describing continuous resource utilization 
falls outside scope spock 
hierarchical task network planning designing spock planning algorithm architectures considered 
section discuss hierarchical task networks explain design pattern selected spock planning algorithm 
planners attempt achieve fast planning reducing amount search space explored 
hierarchical task network htn planners increase speed searching plan space restricted plan candidates guaranteed complete 
limits flexibility fast eliminating large portion search space 
examples htn planners include shop aspen kirk strategy selection algorithm 
htn planner programmer uses library macro operators decomposed macros primitive operators combination 
additionally may choice alternative decompositions single macro operator introduces non deterministic branch need search component 
htn planning mission programmers initiate planning process specifying initial plan 
initial plan contains macros need decomposed htn planner macro library 
htn planner decomposed macros control program consistent primitive operators planning complete 
htn planners efficient reliance pre specified macro decompositions limits flexibility puts additional programming demands mission designer 
spirit model programming spock able deduce solution plans pre specified rules 
requirement motivates generative planning approach task decomposition 
graph planning opposed htn planning generative planning solves planning problem combining set plan actions achieve planning goals 
section discuss graph planning today leading architectures solving generative planning problems 
graph planners graphplan blackbox utilize structure called plan graph :10.1.1.43.7263
plan graphs compactly represent plan space planning problem allowing graph planners solve planning problems exploring entire space plan candidates see 
act act time act act act fact layer action layer fact layer action layer fact layer plan graph plan graph contains alternating fact action layers increasing time 
facts fact layer represent upper bound set facts theory achieved time fact layer 
fact included particular fact layer attainable corresponding point time 
plan graphs track mutual exclusion relationships conflicts facts fact layer 
fact fact layer achieved path plan graph mutual exclusion relationship indicates facts achieved simultaneously violating plan consistency completeness 
graphbased planner knows search plan graph find solution goals plan graph pair wise consistent 
graphbased planners achieve speed avoid searching subset plan graph goals simultaneously achieved 
graph planners perform facts planning problem mutually exclusive pair wise basis 
plan graphs keep track mutual exclusion relationships pairs facts 
facts consistent pair wise basis mutually exclusive larger groupings 
example robot arms may able move objects time step move group objects single time step 
case planner begins searching plan graph solution exists 
discovers solution exists plan graph planner adds additional fact action layers plan graph continues search 
facts planning problem mutually exclusive triples larger groupings plan graph ability predict existence complete solution plan 
planner efficient searches regions plan space contain solution 
concern graph planners limitation regarding optimality 
graphbased planners return plan discover achieves planning goals 
search increasing order plan length plans fewer actions preferred 
cost metrics involve resources action quantity plan graph planners perform optimal planning 
goal graph planner solution optimal solution example graph planner sub optimality example graph planner sub optimality shown 
scenario vehicle instructed move goal waypoint avoiding obstacles environment 
domain movements obstacle vertices scenario waypoints straight line trajectories 
problem optimal solution involves move commands ordering vehicle trace side large obstacle 
unfortunately graph planner minimizes number layers plan returning sub optimal solution requires move commands 
graph planners provide generative search property spock needs significant limitations regarding optimal planning 
spock intended real world problems involving expensive robot hardware optimal planning metrics time important feature included 
leads conclude graph planning architecture insufficient satisfying spock feature specification 
forward progression planning discussed non generative planning architectures generative architectures limited support optimal planning 
discuss forward progression planning supports optimal planning generative planning 
forward progression planners backward propagation planners perform search entire plan space 
forward progression planners initial state search goal state backward propagation planners goal search initial state 
approaches allow expressive plan actions ability plan optimally arbitrary cost metrics inherently slower htn graph planners 
way optimizing forward chaining planners expansion rules demonstrated tlplan 
expansion rules inform planner avoids searching redundant wasteful candidate solutions reducing search branching factor increasing planning speed 
unfortunately expansion rules inappropriate spock violate spirit model programming 
forward progression planners ff hsp shown dramatic performance improvements relaxed plan graphs calculate admissible heuristic cost estimates 
relaxed plan graph constructed manner similar plan graph mutual exclusions ignored 
property allows relaxed plan graph act admissible heuristic estimate trying determine cost goal particular planning state 
relaxed plan graph heuristic cost estimate forward progression planner uses informed search process opposed uniform cost search process 
improves planner efficiency focusing search solution states reducing number states explored planning problem 
spock design forward progression planner chosen intent eventually utilize relaxed heuristic cost estimates mechanism achieving fast planning 
method achieving fast planning forward progression plan representation local search 
local search repair planners forward progression planning algorithm generally operate plan representations similar forward progression planning 
example local search planner lpg 
lpg plans randomized local search algorithm similar walksat called 
lpg quite fast randomized search means optimal returning plans obviously wasteful sub sequences 
spock planning algorithm implemented forward progression design 
described chapter forward progression planners generative enabling spock automatically deduce command sequences achieve programmer mission goals 
additionally forward progression planners support optimal planning various cost metrics accelerated relaxed graph cost heuristic estimates 
reactive model programming language controlling complex autonomous systems difficult task 
autonomous aerial vehicles robotic spacecraft thousands hardware components needs monitored controlled times 
help manage inherent complexity autonomous systems control mission programmers traditionally relied programming languages raps esl tdl 
languages help model relationships various robot states incorporating features concurrency metric constraints durations functionally redundant choice contingencies synchronization 
benefit languages allow mission programmers create models autonomous systems accurately reflect hardware controlled 
existing languages proven useful ability model activities real world autonomous systems little address massive complexity inherent devices 
modern spacecraft unmanned aerial vehicle hundreds sensors actuators constantly monitored commanded 
large number inter dependent variables managing complexity systems quite similar managing complexity modern software project 
robotic execution language includes features modern programming languages abstraction inheritance encapsulation needed ensure vehicle models programmed quickly minimal human error 
meet demand introduce reactive model programming language 
rmpl rich language describing activity models autonomous reactive systems 
designed help manage complexity rmpl object oriented supports highlevel programming features abstraction encapsulation inheritance 
rmpl process algebra includes combinators supporting concurrency pre emption conditional execution non deterministic choice maintenance conditions state assertion activity timing 
combinators rmpl programming quick easy allowing expression desired constraints 
chapter provides brief overview rmpl syntax 
example shown followed depth discussion rmpl combinators role spock generative planner 
rmpl overview reactive model programming language rmpl high level language describe activity models autonomous reactive systems 
support encapsulation abstraction rmpl object oriented rmpl code contained object methods structure method name arguments method body rmpl methods name important specification sections arguments list method body 
required functional programming language arguments list rmpl method contains variables method body uses customize behavior 
example move method take start position arguments allowing method determine proper trajectory temporal bounds specified move activity 
rmpl method body coded process algebra consisting set combinators supports conditional execution concurrency pre emption maintenance conditions state assertion activity timing non deterministic choice supported spock 
example scenario rmpl program illustrate combinators rmpl scenario 
family hiking woods threatened nearby forest fire 
decision send autonomous rescue helicopter recover family 
simultaneously autonomous helicopter sent fight forest fire 
safety purposes family nearby flames extinguished 
encode scenario rmpl code 
rescue helicopter retrieve group activity activity method body pickup maintaining threat low inf safe fire helicopter extinguish fire location loc activity activity method body drop call assistance watching fire controlled threat low rescue family control program method body thread rescue helicopter fly rescue point rescue helicopter retrieve family rescue helicopter fly hospital thread fire helicopter fly forest fire fire helicopter extinguish fire forest fire fire helicopter fly base example rmpl program example contains rmpl methods macro activity declarations rescue helicopter retrieve fire helicopter extinguish fire top level program rescue family 
macro activity declarations high level methods called top level program methods referenced rmpl code lowercase primitive activities understood system executive 
rescue helicopter retrieve activity method demonstrates maintaining maintenance conditions sequential composition episode timing 
statement method body pickup maintaining threat low inf executes pickup primitive activity seconds threat condition remains low 
statement sequentially combined state assertion safe asserts group indefinitely safe pickup activity complete 
activity method fire helicopter extinguish fire demonstrates watching maintenance conditions sequential composition conditional execution 
root level statement method body watching fire controlled instructs system fight fire fire control 
interior statement drop call tells system fight fire 
specifically says drop fire possible call help available 
complex statement combined sequential composition goal state assertion threat low informs system environment safe fire extinguished 
example includes top level program rescue family primary method directs execution rescue mission 
top level program demonstrates sequential parallel composition macro activity calls episode timing 
body rescue family method contains parallel threads execution constrained take seconds execute 
sequence commands rescue helicopter fly rescue point retrieve family seconds fly hospital drop injured people 
second sequence commands fire helicopter fly forest fire extinguish seconds return base 
rmpl combinators section presents rmpl combinator describes semantics 
list combinators shown 
maintaining watching choose assignment state variable rmpl combinators supported kirk strategy selection algorithm note spock supports subset rmpl allow conditional plan operators 
subset rmpl combinators supported spock listed episode timing maintaining assignment state variable rmpl combinators supported spock rmpl sub activity statement informs executive episode interval activity occurs take time units time units 
construct constrain durations activity episodes episodes activities 
note default episode time bounds inf 
episode constrained set time bounds intersection bounds 
state assertion rmpl language interacting hidden state 
needs mechanism asserting assignments state variables 
mechanism state assertion 
rmpl activity code programmer assert value state variable simply writing state variable xi vij xi declared variable vij element xi domain 
note rmpl language describing evolution state variables time state variable assignment corresponding episode persists 
sequential composition programmers frequently want constrain activities occurs immediately 
situation sequential composition construct 
example code cook eat instruct system perform cook activity immediately execute eat activity 
parallel composition rmpl includes parallel composition construct allow expression concurrent activities 
parallel activities constrained time 
example code close eyes instruct system simultaneously close eyes activities simultaneously activities 
conditional execution rmpl conditional execution construct allows sub activities executed specified state assignment true 
construct control statements particularly important enables rmpl react environmental conditions 
example programmer encode program environment safe fly mission abort note requires state assignment hold embedded activity 
activity begins state assignment free change 
combinator maintains state assignment execution activity maintaining 
note combinator supported kirk strategy selection algorithm spock 
pre emptive execution type control statement 
programmer wants particular sub activity executed time particular state assignment holds 
example suppose programmer wants implement simple routine halts robot motors proximity sensors register object certain threshold 
obstacle avoidance routine coded distance threshold 
note combinator supported kirk strategy selection algorithm spock 
maintenance conditions maintaining watching important activity constraints programming autonomous vehicles maintenance conditions 
frequently mission programmers want encode execution sequences maintenance guard conditions require particular state assignment duration activity 
express guard conditions rmpl programmers maintaining construct 
example express constraint thruster fired fuel rmpl programmer write fire thruster maintaining fuel 
non deterministic choice choose rmpl includes support non deterministic contingency selection 
allows mission programmers specify functionally redundant procedures improve robustness encoding contingency sequences 
encode non deterministic choice uses choose construct followed list possible execution threads 
example encode scenario uav selects series surveillance targets rmpl programmer encode choose fly target fly target fly target 
note choose combinator supported kirk strategy selection algorithm spock 
rmpl subsumption pddl operators planning community established planning domain description language pddl standardized format encoding planning problems 
pddl developed flexible format encoding primitive operators 
pddl supports durative actions start pre conditions effects invariant conditions effects pre conditions effects 
important claim thesis rmpl expressive language describing operators 
argue claim note addition single combinator rmpl arbitrary pddl operators encoded rmpl 
start preconditions start effects invariant conditions invariant effects preconditions effects duration pddl operator maintaining achieve pddl operator corresponding rmpl operator rmpl subsumption pddl operators standard pddl operator takes form shown left side 
addition achieve combinator denotes activity operator sub goal see pddl operator represented rmpl 
pddl operators accepted expressive operator format 
rmpl express arbitrary pddl operators conclude rmpl expressive format encoding plan operators 
rmpl spock generative planner research spock focused generation unconditional plans 
achieve focus allow plan operators include conditional expressions non deterministic choice 
spock operators coded subset rmpl language consisting activity timing state assertion sequential composition parallel composition maintaining combinator 
furthermore control program activities environment model planning problem different roles 
control program represents mission designer planning goals 
activities activity library correspond plan operators effects achieve control program open conditions 
environment model corresponds set state assignments changed 
semantic difference interpretation rmpl state assignments varies inputs 
control program constraints meant indicate intended state assignments planning goals 
state assertion rmpl control program corresponds request particular assignment achieved period time 
example control program state assertion light inf signify request model executive achieve state light time units 
activities environment models state assertion corresponds effect 
inputs rmpl state assertion corresponds explicit assertion particular assignment hold period time 
example activity state assertion light inf signify assertion operator effect light fact state time units 
reactive model programming language effective tool mission programmers allows express constraints efficiently managing complexity 
rooted proven execution modern object oriented languages rmpl process algebra enables programmers easily encode arbitrarily complex activity models mission control programs 
temporal plan networks rmpl allows programmer specify complex processes terms evolution state variables 
enable fast planning convert rmpl programs equivalent graph structures called temporal plan networks 
useful compactly encode space possible state evolutions expressed rmpl program 
program converted tpn processed efficient network algorithms perform search scheduling check temporal consistency 
chapter presents overview temporal plan networks gives example tpn rmpl example chapter describes mapping rmpl combinators tpn constructs 
tpn overview temporal plan networks inspired history process representations qualitative physics concise histories interval representations constraint interval planning 
episodes arcs tpn represent state variable assertions requests hold interval time 
points episodes called events represented tpn graph vertices 
temporally flexible tpn episodes bound simple temporal constraints include lower upper bound corresponding interval time episode 
encode state queries assertions episodes labeled ask tell constraints respectively 
episodes labeled primitive activity operators 
add decision nodes allow non deterministic choice plan representation note decision nodes allowed spock 
episode comprised state assertions tells state queries asks primitive actions nodes represent events time tell location unknown ask battery charged drive path decision node arc needs selected simple temporal constraints time time temporal plan network constructs illustrates constructs temporal plan network 
example nodes represent events time arc node node represents episode drive path primitive action executed 
label arc represents time bounds attached episode 
time bounds constrain episode events take time units 
state assertion state request attached episode arc tell location unknown asserts system location variable undefined duration drive path episode ask battery charged requests system achieve state battery charged order ensure robot run power episode execution 
node decision node 
means model executive select arcs execution 
note event episode decision node start event episode allowed decision node 
lastly reiterate spock planner include decision nodes spock perform conditional planning 
example tpn rescue helicopter retrieve macro rescue helicopter fly rescue point top level ask threat low pickup family tell family safe inf inf rescue helicopter retrieve family inf inf rescue helicopter fly hospital start inf fire helicopter fly forest fire fire helicopter extinguish fire forest fire inf fire helicopter fly base fire helicopter extinguish fire macro ask fire controlled inf ask inf ask drop inf inf example temporal plan network inf call assistance example tpn shown corresponding example rmpl code shown chapter 
just original rmpl code graph distinct parts top level program macro activities expanded control program 
tpn top level program sub section contains parallel threads execution 
total mission time bound seconds 
top level program demonstrates primitive activities fly activities macro activities rescue helicopter retrieve fire helicopter extinguish fire activities 
primitive activities simply included solution plan macro activities need expanded tpn 
tpn sub network macro corresponds expansion rescue helicopter retrieve activity 
sub network episode events shows expansion rmpl maintaining combinator 
example command pickup state maintain threat low 
maintaining rmpl code expanded tpn sub network asks mission threat remain low duration embedded rescue activity 
pickup command constrained take seconds finished state family safe asserted 
macro corresponds expansion fire helicopter extinguish fire activity 
bulk activity nested watching activity similar maintaining 
difference maintaining commands ask particular state hold watching commands execute long particular state hold 
watching statement specified halt execution embedded condition true 
macro executes long fire controlled remains false 
code embedded macro watching statement instructs system ifthen statement fight fire 
statement requires decision corresponding tpn sub graph contains decision node denoted double circle 
choice decision node state variable due ask constraints attached arcs 
thread requires true case drop primitive executed thread requires true case call assistance primitive executed 
rmpl tpn mapping section summarizes mapping rmpl combinators tpn constructs 
translations section rmpl program compiled tpn suitable planning execution tasks 
interval interval assertion interval activity table rmpl primitives tpn sub networks table shows mapping rmpl tpn primitives 
shown primitive statements mission programmers express delays timed assertions timed primitive actions rmpl programs 
primitive statements corresponding primitive tpn construction represents information graph form 
tell sequential composition parallel composition conditional execution reactive execution condition maintenance maintaining ask ask ask ask preemption watching choice choose table rmpl combinators tpn sub networks table shows mapping rmpl combinators tpn sub networks 
shown combinators mission programmers combine rmpl primitives represent complex processes 
graph equivalent rmpl represent process combinators various graph constructions 
executability temporal plan networks executable mission hardware 
open condition ask tpn satisfied combination tpn constraints conflicting 
example tpn control program encodes mission designer planning goals executable open conditions need satisfied 
tpn planner takes tpn control program combines environment model activities activity library order satisfy control program open conditions 
resulting solution tpn said executable complete consistent 
sections explain tpn consistency completeness detail 
tpn consistency finding consistent plans important consistent plans executed realworld systems 
tpn consistency components temporal consistency tell ask consistency 
temporal consistency requires valid temporal assignment event exist temporal constraints violated tell consistency requires state variable single assignment point time 
tpn temporal consistency uav fly waypoint inf uav fly waypoint temporally inconsistent tpn possible temporal plan network represent temporally infeasible mission plan executable 
example aerial vehicles commanded rendezvous waypoint 
vehicles far away take hours reach waypoint vehicle low fuel complete rendezvous hours 
constraints conflict meaning possible time rendezvous occur violating vehicles temporal requirements 
say plan temporally inconsistent 
temporal constraints similar simple temporal networks graph algorithms determining stn consistency applied order determine tpn temporal consistency :10.1.1.40.1018
shown dechter meiri temporal constraints reformulated equivalent graph called distance graph 
distance graph graphical encoding upper lower bound graph simple temporal constraints 
consistency checking graph simple temporal constraints corresponds negative cycle detection associated distance graph 
tpn uav fly waypoint inf distance graph uav fly waypoint inf inconsistent tpn corresponding distance graph graph simple temporal constraints easily converted distance graph 
nodes input graph copied distance graph 
upper bound input graph converted directed arc value direction simple temporal constraint 
lower bound input graph converted directed arc negative value opposite direction simple temporal constraint 
distance graph tpn input returns distance graph 
distance graph 
event input 
add node 
episode input 
add arc episode upperbound weight 
add arc negative episode lowerbound weight 
return tpn distance graph pseudo code mentioned temporal consistency tpn stn corresponds negative cycle detection associated distance graph :10.1.1.40.1018
distance graph tpn constructed easily determine temporal consistency negative cycle detection algorithm floyd warshall pairs shortest path algorithm fifo label correcting algorithm 
tpn tell consistency consistent tpn temporally consistent ensure assignments state variables conflict 
ensure state variable assigned unique value point time 
tells contain inconsistent state assignments say threaten 
process ensuring inconsistent tells occur time referred threat resolution 
tell tell tpn threat resolution ordering arc ensures conflicting episodes occur example tpn threatening tells shown 
tpn threat resolved introducing ordering arc prohibits tells cooccurring 
say tpn consistent temporal constraints consistent tell constraints consistent threatening 
tpn completeness temporal plan network executable complete 
tpn complete embedded open conditions asks satisfied 
specifically tpn completeness corresponds control program tpn successfully combined tpn environment model set activity activity library order achieve mission designer planning goals 
temporal plan network ask constraints represent open conditions system satisfy 
planning goals scenario control program activities take form ask constraints 
recall ask constraints request state assignments tell constraints assert state assignments 
open condition ask constraint closed tpn guarantee ask state assignment entailed tell constraint network 
ask tell constraints assigned temporal episodes tell close ask time bounds subsume contain time bounds ask constraint 
ask constraints tpn closed tell constraints conflicting tell constraints ordered occur say tpn complete 
ask lights inf inf tell lights example complete tpn consider example 
example tpn ask constraint requires lights seconds 
tell constraint asserts lights seconds 
connecting ask tell constraints causal links episodes inf time bounds tpn ensures tell constraint contains ask constraint closing open condition 
tpn subsumption pddl operators described chapter planning community established planning domain description language pddl standardized format encoding planning problems 
pddl supports durative actions start pre conditions effects invariant conditions effects pre conditions effects 
pddl start preconditions start effects invariant conditions invariant effects preconditions effects duration kirk activity ask ask tell ask tell inf mapping pddl operators tpn activities tell inf important claim thesis spock planning operators temporal plan networks allow specification rich activity models 
claim supported fact tpn activities subsume pddl operators 
demonstrates arbitrary pddl operator expressed tpn activity 
summary temporal plan networks compact graph encoding constraints expressed rmpl program 
representing complex processes network form quickly processed graph search algorithms determine temporal consistency perform scheduling 
direct mapping combinators rmpl constructs tpn allowing easy translation human generated code machine understandable graph format 
spock generative tpn planning algorithm spock generative optimal forward progression tpn planner designed support strategic level control autonomous mobile systems part kirk model executive 
chapter describes spock planning algorithm detail 
overview followed discussion spock internal plan representation 
spock child expansion function followed spock consistency checking algorithm 
chapter concludes description spock candidate cost update function 
chapter illustrative examples help convey relevant concepts 
overview spock designed integrate forward progression heuristic search temporal flexibility composition complex processes 
htn planners hsts developed real world systems past forward progression heuristic search demonstrated planners ff hsp lpg novel way achieve faster planning speeds :10.1.1.35.724
spock applies fast search algorithm temporal plan network structure provides temporal flexibility constraint interval planners hsts europa 
spock inputs expressed reactive model programming language allows mission designers specify evolution state variables complex processes process algebra rich set activity combinators 
components demonstrated individually spock novel combines capabilities framework support model programming mobile autonomous systems 
spock algorithm spock requires inputs control program describes system intended state evolutions environment model activity library spock uses assemble solution plan 
solution plan output spock complete consistent temporal plan network achieves behavior specified control program piecing activities activity library maintaining consistency 
spock uses temporal plan networks uniform representation representing control programs activities plans 
described previously collections events episodes events representing processes may subgoals form open conditions represented ask constraints 
spock generates complete plan walking control program start way satisfying open conditions activities activity library 
spock choice proceed branches adding possible expansion queue plan candidates 
spock inserts activity activity library committed inserting entire activity tpn 
spock inserts events episodes activity plan candidate tpn time plan candidate needs keep track events episodes insert 
events episodes called pending events episodes 
spock internal plan candidate representation contains candidate tpn set pending events episodes see 
consistent candidate remaining pending events episodes plan candidate complete returned solution plan 
rmpl control program initial candidate generator initial candidate candidate priority queue cost candidate candidate consistent 
cost update child candidates child expansion candidate complete 
spock block diagram activity data rmpl activity specifications activity library return solution plan spock planning loop shown pictorially pseudo code 
spock solves planning problem begins removing cost plan candidate queue pseudo code line 
candidate tested consistency fails candidate discarded pseudo code line 
spock checks see candidate complete pseudo code line 
candidate remaining pending events episodes complete returned solution plan 
candidate complete planning continues child expansion function 
spock child expansion function generates child candidates parent candidate pseudo code line 
expands candidate spock child expansion function insert pending event episode instantiate additional activity activity library 
child candidate constructed child expansion function cost updated pseudo code line reinserted candidate queue manner uniform cost search search pseudo code line 
spock control program activity library returns complete consistent plan achieves control program 
initial candidate control program 
priority queue 
priority queue non empty 
cost candidate priority queue 
consistent 
complete return 
children child expansion activity library 
children 
update cost 
insert priority queue 
endfor 
endif 
endwhile spock top level pseudo code example generative tpn planning problem residential area forest fire uav forest fire base forest fire suppression scenario consider example scenario 
forest fires burning fire marshal wants send unmanned aerial vehicle suppress flames see 
fires threatening residential area fire marshal writes control program requiring fire near residential area suppressed time units followed second forest fire subsequent time units see top left 
fire suppression fire suppressed fire suppressed control program rmpl code ask fire suppressed note ask fire suppressed control program tpn deadline fire suppression time units mission start deadline fire suppression time units fire suppressed control program rmpl code tpn fire suppression mission control program fire marshal gives spock activity library activity models fire fighting uav 
scenario activity library includes activities move drop water see 
move activity simply moves uav location 
note time bounds move activity dist origin destination parameterized location origin destination waypoints 
allows time bound move activity vary depending distance vehicle travel 
drop water activity straightforward simply drops water location requiring uav remain location duration drop 
note discussed chapter interpretation rmpl state assertion different control program activity model 
control program state assertions ask constraints representing planning goals activity state assertions tell constraints representing operator effects 
move origin destination fly destination location uav unknown dist origin destination inf location uav destination inf fly destination tell location uav unknown tell location uav destination move activity rmpl code move activity tpn drop water waypoint open doors drop water close doors maintaining location uav waypoint waypoint suppressed inf dist origin destination inf open doors inf inf drop water activity rmpl code drop water activity tpn drop water ask location uav waypoint close doors tell waypoint suppressed activity library rmpl code tpn fire suppression mission scenario control program activity library inputs spock generates returns complete consistent solution plan achieves control program minimal cost activities activity library exists see 
fly dest tell location uav unknown tell loc uav dest dist origin dest inf open doors move base fire inf drop water ask location uav waypoint inf drop water fire inf close doors tell inf inf inf inf fly dest tell location uav unknown tell loc uav dest dist origin dest inf inf move fire fire drop water fire open doors drop water close doors ask location uav waypoint tell inf inf control program ask fire suppressed ask fire suppressed solution tpn fire suppression mission inf inf inf scenario solution plan achieves control program commanding uav fly forest fire drop water fire fly forest fire drop water second fire see 
internal plan candidate representation spock plans builds solution plan inserting control program events episodes plan candidate 
encounters ask constraint control program inserts activity activity library order close open condition 
spock walk control program monotonic temporally guided intuition part control program considered represents past part control program considered represents 
spock child expansion function frequent distinction 
sense develop relevant vocabulary aide describing spock planner 
types events episodes plan candidate see 
distinction plan candidate inserted pending events episodes 
inserted events episodes correspond events episodes spock considered past pending events episodes correspond events episodes spock consider 
episode pending associated ask constraints open associated tells may threatened episode inserted contains closed ask constraints tells consistent 
inserted inactive inserted active pending enabled pending non enabled move base fire fly fire tell location uav unknown tell location uav fire open doors dist base fire inf inf inf drop water fire drop water ask location uav fire close doors control program inf tell fire suppressed inf ask fire suppressed ask fire suppressed plan candidate structure set inserted events episodes spock differentiates tell constraints active inactive tells 
active tells represent state solution plan correspond part solution graph affects insertion new events episodes 
inactive tells represent solution plan past effect insertion new events episodes 
specifically active tells defined inserted tells pending events 
active tell deactivated event ends inserted 
spock differentiates set pending events episodes enabled un enabled events episodes 
enabled event episode event episode may inserted solution plan maintaining spock monotonic flow time tpn consistency completeness 
child expansion inserts enabled events episodes child candidate 
follows un enabled events episodes correspond pending events episodes insertion yield incomplete inconsistent child candidate 
enablement activities pending events episodes child expansion spock insert activities events episodes candidate tpn insertion results complete consistent tpn 
described refer activities events episodes insertion valid enabled activities events episodes 
conditions enablement follows 
activity enabled activity enabled ask inactive episodes inserted event inserted episodes tell active tell activity library plan candidate ask activity enablement pending event activity activity library enabled ask constraints start event closed candidate tpn active tells see 
intuition activity inserted candidate tpn satisfy activity preconditions represented initial ask constraints 
inserted events enabled pending event enabled pending event event enablement un enabled pending events event enabled preceding episodes inserted see 
tell battery charged tell light ask light ask battery charged inserted event inactive active ask light tell light enablement episodes start event inserted ask constraints supported candidate active tells tell constraints consistent candidate active tells inserted episode pending event pending episode enablement episodes enabled enabled episode enabled start event inserted asks contains closed candidate tpn active tells tells contains consistent candidate tpn active tells see 
vocabulary describe various events episodes spock plan candidate understand conditions give rise enablement discuss algorithms spock uses generate solution plan 
child expansion candidate removed queue checked consistency see section 
spock determines candidate consistent proceeds check complete 
candidate complete pending episodes events 
candidate complete returned solution plan 
child expansion called 
child expansion grows plan candidate inserting enabled episode event instantiating new activity activity library shown 
expansion applied selected arbitrarily 
possible expansions considered applied order create distinct candidates ensure search completeness 
section describes child expansion process cases 
child expansion candidate activity library returns child candidate 
copy candidate 
choose lines 
find enabled activities 
choose enabled activity 
instantiate 
return 
find enabled episodes 
choose enabled episode 
insert 
return 
find enabled events 
choose enabled event 
insert 
return instantiating activities child expansion pseudo code expand plan candidate child expansion may add activity activity library candidate set pending events episodes 
called activity instantiation activity activity library instantiated parameters bound components added plan candidate set pending events episodes 
activity instantiation key planning component represents part spock true generative planner 
activity instantiation spock child expansion procedure behave kirk strategy selection algorithm ensuring consistency completeness pre defined control program 
activity instantiated enabled meaning asks start event closed candidate active tells 
asks activity start event represent activity preconditions wasteful instantiate activity preconditions satisfied 
spock determines activities enabled evaluating activity activity library checking see asks start event closed candidate active tells see 
alternative method performing task described section 
find enabled activities candidate activity library 
empty set activities 
activity 
ok true 
ask start event 
closed active tells 
ok false 

ok true 
add 


return find enabled activities pseudo code enabled activity selected instantiation newly instantiated activity copied candidate events pending events episodes pending episodes see 
effect instantiated activity part control program constructs integrated candidate tpn order candidate solution plan 
activity enabled activity enabled ask tell ask activity library plan candidate activity instantiation activity enabled activity enabled ask tell example activity instantiation ask activity library plan candidate ask activity instantiation activity instantiated candidate returned queue 
activity events episodes added candidate set pending constructs actual insertion activity constructs handled way rest candidate pending constructs see sections 
note spock maintains search completeness branching iteration creating distinct candidates instantiate enabled activity 
acknowledge better approach goal directed search instantiates activities close existing open condition 
inserting enabled episodes recall section episode enabled start event inserted attached ask constraints closed candidate active tells attached tell constraints consistent candidate active tells 
start events inserted order maintain contiguous tpn graph ask constraints closed order maintain tpn completeness 
tell constraints consistent ensure candidate tpn maintains tell consistency 
spock child expansion function elects insert enabled episodes starts determining episodes candidate enabled insertion 
determine episodes enabled spock searches set active tells see episode asks closed tells consistent see 
search process efficient way detect closing tell constraints number tells need examined small active tells small subset candidate tpn 
improved algorithm discussed section 
find enabled episodes candidate 
empty set episodes 
pending episode 
ok true 
ask 
closed active tells 
ok false 


tell 
inconsistent active tells 
ok false 


ok true 
add 


return find enabled episodes pseudo code enabled episode inserted ask tell constraints processed ensure tpn completeness consistency respectively 
specifically ask constraint bound closing active tell candidate tpn 
addition tell constraints ordered avoid conflicts mutually exclusive tells candidate tpn 
episode insertion tell temperature cold episode insertion conflict avoidance causal link tell temperature cold inf inf inserted event tell light ask light tell temperature hot episode inserted tell light ask support causal links ask light tell temperature hot newly inserted episode inf inserted episode pending event pending episode episode insertion spock episode insertion algorithm processes episode ask constraint binds ask closing tell order ensure plan completeness 
note spock determine tell close ask binding determined enablement checking procedure 
inf causal link causal link point necessary introduce term causal link 
causal link episode inf time bounds attached asks tells primitive activities see 
causal links type episode distinguish merely order plan activities contain state assignments constrained time bounds 
ask tell binding process spock adds causal links ensure closing tell constraint contains ask constraint see 
inserted causal links orders tell start event occur ask start event causal link orders ask event occur tell event 
causal links ensure ask closed require tell effect entire duration ask constraint 
find conflicting tells candidate tell 
empty set tells 
inactive tell 
conflicts add 

return find conflicting tells pseudo code spock episode insertion algorithm processes episode tell constraint adds causal links ensure tell occur pre existing conflicting tells 
spock designed insert events episodes chronological order spock orders new tell constraints occur conflicting pre existing tell constraints 
note violate search completeness possible expansions considered 
candidate activity ordered succeed activity alternate candidate generated activity considered activity ordered succeed activity claim argued section section 
inserting episode tell spock find conflicting inactive tells 
spock finds set conflicting inactive tell constraints simply searching set inactive tells see 
admittedly efficient solution improvement described section 
spock identifies inactive tells conflict new tell tells inserting causal link event conflicting inactive tell constraint start event new tell constraint see 
insert candidate episode 
ask episode 
choose supporting active tell candidate 
add causal link candidate start start 
add causal link candidate 

tell episode 
tell candidate conflicts 
add causal link candidate start 

inserting enabled events cold cold inf inf insert episode pseudo code inf inf tell light ask light tell temperature hot tell light ask light tell temperature hot inserted event inf inf inserted episode pending event pending episode event insertion enabled event insertion event insertion enabled recall event enabled preceding episodes inserted 
child expansion elects insert enabled events begins determining events enabled see 
branches creating distinct candidate inserts enabled event 
enabled event selected insertion inserted simply moving event candidate set pending nodes set inserted nodes see 
find enabled events candidate 
empty set events 
pending event 
ok true 
preceding episode 
inserted 
ok false 


ok true 
add 


return find enabled events pseudo code insert candidate event 
mark event inserted pending insert event pseudo code checking candidate consistency finding consistent solution plans important consistent plans executed real world systems 
spock ensures consistency detecting pruning inconsistent candidates 
plan candidate inconsistent combination episodes tpn conflict 
episode time bounds constrain time tpn events occur conflicting episode time bounds mean event tpn occur violating temporal constraints 
problem single battery activate battery tell radio bus powered power radio duration data inf inf transmission 
transmit data ask radio bus powered corresponding distance graph inf candidate inconsistent inf example inconsistent candidate consistency violated due presence negative cycle episodes removed candidate inconsistent candidate consistent 
spock improves efficiency verifying temporal consistency candidate de queued pruning inconsistent candidates soon detected 
described chapter temporal consistency verified mapping tpn equivalent distance graph checking distance graph existence negative cycles :10.1.1.40.1018
spock checks negative cycles tpn associated distance graph fifo label correcting algorithm 
algorithm selected simplicity relatively small nm time complexity 
pseudo code fifo label correcting algorithm shown 
fifo label correcting 
nodes 
inf 
examined count 

source 
list source 
list non empty 
pop head list 
examined count 
examined count 
return negative cycle 

arc 


list 
push list 




return negative cycles fifo label correcting algorithm detecting negative cycles distance graph changes candidate tpn small iteration sense check temporal consistency incremental algorithm reuses past iterations 
algorithm performing incremental temporal consistency checking itc introduced hsiang shu 
integrated current implementation spock itc perform temporal consistency checking discussed section 
continuation combining equivalent tell constraints domain temporal planning important consider cases multiple temporally short activities needed close single temporally long activity see 
spock occurs single tell constraint upper time bound long close ask constraint 
happens multiple tell constraints may chained close ask constraint 
accomplished adding episode start tell opposite tell requiring tell second continuing tell begun 
problem single battery power radio duration data activate battery tell radio bus powered transmission 
transmit data ask radio bus powered solution multiple batteries power radio 
inf transmit data inf inf activate battery tell radio bus powered inf activate battery inf tell radio bus powered tell radio bus powered ask radio bus powered continuation problem solution inf example continuation shown 
example transmit data activity requires radio bus powered duration transmission time units 
single battery power bus time units 
solution sequence batteries radio bus powered necessary minutes 
continuation arcs spock adds constrain activate battery activities overlap ensuring radio bus powered interruption required minutes 
continuation implemented kirk episode insertion sub routine see 
episode insertion procedure handles episode tells checks see tells match active tells plan candidate tpn 
finds match spock branches 
branch invokes continuation branch omits continuation 
insert candidate episode 
ask episode 
choose supporting active tell candidate 
add causal link candidate start start 
add causal link candidate 

tell episode 
tell candidate conflicts 
add causal link candidate start 

candidate contains matching active tell 
optionally 
add episode candidate start 
add episode candidate start 
add tell candidate start 
add tell candidate start 
option 

insert episode pseudo code support continuation continuation invoked episodes inserted start node tell node opposite tell requiring tells overlap time see 
new episode labeled tell constraint represents combined tell constraints entire duration continuation 
new tell constraints iterations close asks require support chain tell constraints 
continuation enabled episode tell tell active inserted episode ensuring systematicity continuation arcs continuation example continuation newly inserted episode tell tell tell tell active inserted episode spock efficient revisit previously considered planning states 
addressed spock insertion considered disallowing previously considered candidate expansion 
motivates need efficient systematic search process 
suppose represents absence candidate plan expansion represents inclusion candidate plan expansion 
spock system prohibiting previously considered plan expansions analogous search tree shown right side 
duplicate state inefficient systematic search duplicate state duplicate state motivation systematicity efficient systematic search 

duplicate states achieve systematicity spock child expansion function generates child candidates considers expansion 
candidate applies expansion spock selected apply selected expansion 
children selected expansion memoized prohibited consideration call blocking expansion 
child expansion applied considered alternate enabled expansions 
process repeats remaining expansions possible ensuring search completeness 
child expansion function blocking shown 
child expansion candidate activity library returns child candidates 
copy candidate 
choose lines 
find enabled activities 
choose unblocked enabled activity 
instantiate 
block 
block 
return 
find enabled episodes 
choose unblocked enabled episode 
insert 
block 
block 
return 
find enabled events 
choose unblocked enabled event 
insert 
block 
block 
return spock child expansion pseudo code blocking preserving search completeness support systematicity candidate expansions blocked considered 
blocked expansions considered need show possible complete plans visited regardless order expansions considered 
want sure won inadvertently skip valid child candidate applying expansions particular order 
analyze problem cases considered 
case expansions available spock independent inserting enabled event episode un enable enabled events episodes 
case expansions available spock dependent inserting enabled event episode may cause enabled events episodes un enabled 
process event insert event insert event block event block event insert event block event original candidate insert event insert event process event block event block event insert event search tree independent candidate expansions block event independent case search completeness easy demonstrate 
know enabled event episode remain enabled regardless insert block event episode spock simply explores combinations candidate structures inserting blocking expansion considered see 
insertion blocking expansion affect enablement events episodes order expansion considered irrelevant 
enabled episode ask tell enabled episode tell tell enabled episode enabled event cases un enablement inserting enabled event cause ask un enabled tell closes ask deactivated inserting enabled episodes cause episode un enabled tell constraint conflicts tell search completeness harder demonstrate case dependent candidate expansions 
recall dependent expansions expansions inserting enabled expansion may cause enabled expansion un enabled 
ways may occur see 
case expansion may un enable expansion expansion deactivates active tell needed close ask constraint second expansion 
second case expansion inserts active tell conflicts tell constraint part second expansion 
argue spock systematic search blocking remove completeness analyzing cases 
case show possible child candidates generated regardless order expansions considered 
ask longer enabled enabled episode event enabled due addition causal link represents alternate insertion ask tell ask tell initial candidate ask tell insert event block event ask tell insert episode consider enabled event consider enabled episode ask tell block episode expansion tree enabled ask episode event enabled event inserted enabled episode un enabled enabled event case enabled ask episode enabled event trace expansion tree shown 
recall interested case inserting enabled event episode result enabled event episode 
case shown occurs enabled event considered 
show spock child expansion blocking complete need show expansion tree enabled event considered contain possible child candidates 
distinct child candidates spock needs find 
candidate including tell episode ask episode 
candidate including tell episode ask episode 
see spock discovers required child candidate simply inserting enabled event 
de activates active tell un enables ask episode 
required child candidate reachable direct path 
spock blocks insertion enabled event 
continues considering enabled episode inserting candidate 
recall ask inserted candidate causal links added ensure ask contained closing tell 
causal links added topology tpn respect blocked event changes 
event blocked single predecessor episode addition new causal link episode means blocked insertion longer applies 
re enables event inserted iteration completing construction desired plan candidate 
enabled episode tell re enabled conflicting tell constraint deactivated enabled episode tell tell tell initial candidate tell tell consider enabled tell episode tell insert tell episode block tell episode tell tell insert tell episode tell consider enabled tell tell episode insert tell episode expansion tree conflicting enabled episodes tell enabled additional causal link required second case insertion may un enable enabled event episode case conflicting tells see 
case inserting enabled episode un enable episode mutually exclusive 
due symmetry example need consider consideration orderings 
note case need show spock demonstrates distinct child candidates 
candidate contains tell episode second candidate contains tell episode third candidate contains episodes tell ordered occur candidate contains episodes tell ordered occur 
spock generate desired candidates follows 
tell episode inserted 
un enables tell episode tell active conflicts tell 
eventually tell episode deactivated 
point tell episode inserted achieving case episodes tell episode ordered occur tell episode blocked achieving case tell episode 
spock generate needed candidates process 
tell episode blocked 
tell episode inserted 
tell episode completely inserted deactivated tell episode re enabled 
recall conflict avoidance causal links added tpn tell inserted inconsistent inactive tell 
means inactive tell episode cause new conflict avoidance causal link added tell episode inserted 
graph topology respective tell episode changed tell episode re enabled spite previous blocking 
point spock insert tell episode achieving case episodes tell episode occurs block tell episode achieving case tell episode 
spock successfully generate possible child candidates systematic framework regardless order expansions considered conclude spock planning algorithm complete 
candidate cost update child candidate inserted priority queue cost updated 
important contribution thesis fact spock optimal tpn planner 
means spock optimize minimum possible mission time number inserted activities episodes 
manner search spock designed eventually support evaluation plan candidate utility function component represents cost candidate solution far component admissible heuristic estimate remaining cost goal 
causes spock search plan space best order focuses search solutions sacrificing optimality improving efficiency 
spock heuristic cost estimate implemented possible design included section 
spock currently perform optimal uniform cost search cost candidate embedded tpn graph 
remainder section discusses procedure spock calculates candidate value cost far 
currently implemented spock optimizes total plan execution time 
plan candidate cost minimum time entire plan executed 
calculate value event earliest execution time determined equation 
maximum earliest execution time events tpn returned candidate cost 
min time lowerbound arc min time max predecessors equation candidate cost update equation solution equation equivalent solving single source shortest path algorithm tpn episode lower time bound cost 
spock calculate plan candidate cost standard single source shortest path algorithm dijkstra algorithm fifo label correcting algorithm 
single source shortest path algorithm performing candidate cost updates spock improves speed performs task utilizing incremental nature plan candidate expansion 
events episodes inserted candidate tpn chronological order spock perform cost updates incrementally simply applying equation event inserted candidate 
reduces cost spock cost update procedure mn constant time 
summary spock generative tpn planning algorithm finds optimal solution plans input control program activity library 
key contributions spock supports rich activity operators goal specifications flexible time bounds optimal planning arbitrary cost functions 
spock enforces systematicity blocking repeated consideration candidate expansions allows combined tell constraints close ask constraints long durations 
furthermore currently implemented spock cost update procedure designed support heuristic cost estimate focus search improve planning speed 
results thesis spock planning algorithm enables generative planning complex processes 
spock provides key contributions 
spock represents operators rmpl language describes behaviors parallel sequential composition state activity episodes 
second spock uses uniform operator plan space representation processes terms temporal plan networks 
third spock uses forward progression algorithm walks monotonically forward plan processes closing open conditions resolving conflicts 
chapter concludes discussing spock implementation performance presents possible directions research 
implementation spock generative tpn planner described thesis implemented tested pentium iii mhz processor mb ram running redhat linux 
described chapter spock part kirk model executive mobile autonomous systems 
primary components system include rmpl compiler tpn sequencer spock generative tpn planner plan runner 
rmpl compiler takes input rmpl files converts temporal plan networks suitable mission planning 
tpn sequencer identifies consistent goal strategy plan establishes guidelines particular mission 
spock takes goal plan control program forms solution plan combining goal plan set activities activity library 
solution plan passed plan runner schedules activities executes primitive commands vehicle hardware 
spock planning algorithm complete needs integrated rest kirk model executive 
currently spock inputs hand coded tpn structures solution plan dumped text file 
integration rest kirk model executive completed near 
spock implementation described thesis contains primary classes spock candidate activity event episode 
event episode classes 
activity class represents activity activity library contains collection events episodes 
candidate class corresponds plan candidate contains candidate solution tpn set pending events episodes 
candidate class contains methods perform enablement checking consistency verification completeness checking cost updating 
spock class contains top level search algorithm passes plan candidate objects calls appropriate methods necessary 
performance spock run series test problems chart effectiveness 
smaller problems validate spock correctness larger problems demonstrated spock applicability actual autonomous vehicle control scenarios 
problem events solution episodes solution number candidates generated time solve table performance spock generative tpn planner larger test problems instances forest fire rescue scenario see 
scenarios unmanned fire fighting aerial vehicle base waypoint 
forest fire located waypoint forest fly forest fire put depending scenario return base 
return base execute extinguish fire activity forest fire forest base fly forest fire ask start tell inf ask move activity ask forest fire tell fire extinguished inf extinguish fire activity test scenario activity library demonstration problems uses activity operators complete mission move extinguish fire see :10.1.1.43.7263
move moves waypoint extinguish fire commands put fire requiring vehicle forest fire waypoint 
current implementation spock validates spock planning representation ability plan complex processes 
fast planning demonstrated spock include relaxed graph heuristic cost estimate 
correspondingly spock able successfully find solution plans tested small example problems 
lack relaxed graph heuristic cost function spock currently slowed inefficient helper functions 
example spock child expansion function copies candidates entirety time branches 
process inefficient consumes unnecessary time memory 
additionally spock detects enabled events episodes simple search process efficient iterative context 
searches consume large amount time iteration circumventing yield significant performance improvement 
solutions performance bottlenecks discussed section 
spock implementation complete areas performance functionality improved 
section describes significant improvements incremental temporal consistency checking incorporation relaxed plan graph heuristic cost estimate extending rmpl handle types timing constraints 
selection implementation efficiency improvements described 
incremental temporal consistency check tpn temporal consistency checking computationally expensive 
example fifo label correcting algorithm runs nm time number nodes distance graph number arcs 
planner spock extending frequency temporal consistency checker called warrants trying improve runtime 
way improve spock runtime incremental algorithm check temporal consistency 
incremental algorithm updates answer reasoning problem changes changes consequences 
problem changes resulting changed consequences small relative problem significant performance gain achieved 
examples incremental algorithms include truth maintenance systems incremental :10.1.1.38.9249
candidate modified slightly child expansion 
sense check temporal consistency incremental temporal consistency checking algorithm 
hsiang shu developed incremental consistency checking algorithm itc 
itc verifies temporal consistency minimal time efficient verification algorithm reuses existing previous iterations 
uses idea set support truth maintenance systems identify edges require updating 
uses update rule modified fifo label correcting algorithm perform update incrementally 
itc shown decrease validation time order magnitude nonincremental methods applied incremental problems 
spock candidate consistency checking sub routine type consistency checking algorithm help maximize planning speed 
relaxed plan graph heuristic cost estimate uniform cost search currently implemented spock inefficiently explore regions plan space yield desirable solution 
reason uniform cost search include estimate close candidate achieving goal 
focus search spock extended admissible heuristic estimate remaining cost plan candidate goal value 
admissible heuristic estimate transforms uniform cost search informed search process increasing efficiency 
cost estimate admissible equal true cost achieving goals 
search algorithm uses inadmissible heuristic may overestimate cost particular plan candidate 
search algorithms examine candidates overestimating optimal solution may cause search algorithm discover sub optimal solution 
heuristic estimates underestimate admissible heuristics essential ensuring optimal search process 
space admissible heuristics want estimate close true cost possible 
farther estimate true cost goal information contains focused search 
spock needs admissible close estimate remaining cost plan candidate goal 
advances planner efficiency demonstrated ff hsp planners admissible heuristic cost estimate called relaxed plan graph 
relaxed plan graphs similar structure standard plan graphs prohibit mutually exclusive facts facts persist indefinitely created 
allows relaxed plan graph insert enabled actions action layer eliminating need branching 
apply ideas relaxed plan graph spock plan candidates order generate admissible heuristic estimate cost remaining particular plan candidate 
constructing relaxed plan graph spock performed follows 
note input heuristic estimate function current state plan space candidate output admissible close estimate cost goal 
spock plan candidate complete events episodes inserted 
relaxed plan graph goal state state initially pending events episodes inserted 
events episodes added pending sets heuristic estimate calculation need inserted relaxed plan graph goal state 
protect admissibility relaxed plan graphs attempt include superfluous plan actions want necessary plan actions contribute relaxed graph cost estimate 
key feature relaxed graphs constructed quickly determine cost estimate 
constructing relaxed graph require polynomial time implies algorithm avoids decision making expensive search procedures 
elimination decision making causes relaxed graph inconsistent problem relaxed graph meant heuristic imperfect cost estimate 
constructing relaxed graph constructing normal candidate tpn rule modifications designed eliminate decision making 
active tells deactivated 
allows relaxed graphs monotonically add tell constraints 
note deactivating tell require decision point tell deactivation may un enable enabled ask episode 
second conflicts tell constraints ignored 
de conflicting active tells requires decision making 
iteration possible expansions applied 
recall relaxed graph active tells deactivate conflicting tells ignored 
follows expansions behave independently 
required apply possible expansions iteration want decisions including decision expansion apply 
set active tells relaxed graph monotonically increases active tells deactivate 
plan operators need inserted relaxed plan graph 
useful finite number plan operators guarantee point reached goal discovered solution determined infeasible 
consistency checked iterations relaxed graph construction 
resolving temporal tell inconsistencies require decision making process attempt exclusion violating episode 
originally pending events episodes inserted relaxed graph construction complete 
point heuristic cost estimated returning maximum minimum execution times assigned event 
plan candidate activity library activity activity value tell tell ask ask tell example candidate graph heuristic cost estimation relaxed candidate graph conflicting tells ignored original candidate tell tell ask ask tell value ax bx nodes need inserted instantiated part relaxed candidate graph relaxed candidate graph heuristic cost estimate shown plan candidate associated activity library 
example complete relaxed graph plan candidate shown 
note activity nodes relaxed graph inserted relaxed graph complete 
ensures admissibility making relaxed graph underestimate cost goal 
note inserted tell constraints conflict 
relaxed graphs require tell consistency 
note cost values candidate events propagated manner normal plan candidate graphs 
modifying spock candidate expansion algorithm avoid decision making spock support admissible relaxed graph heuristic cost function 
cost function focuses spock search optimal solution plans improving efficiency 
extending rmpl support additional temporal constraints rmpl builds processes standard constructs parallel sequential composition 
combinators allow natural expression complex operators terms intended state evolutions 
cases richer vocabulary required describing temporal relationships episodes see 
vocabulary provided qualitative metric temporal algebras 
tpn structure generated rmpl arc currently represented rmpl tpn structure motivates additional rmpl constructs rmpl tpn limitation extending rmpl handle arbitrary temporal constraints accomplished adding new rmpl construct language naming device allowing programmers refer sections rmpl code locations initially defined 
constructs take form similar allen temporal relations intuitive method ordering sub activities rmpl method 
expanding rmpl vocabulary presents technical challenges 
care taken ensure simplicity rmpl process descriptions corrupted rmpl key feature 
accomplished simply adding additional combinators preserving rest rmpl syntax 
long method rmpl activities control programs developed changed rmpl significant features preserved 
second planning algorithms process rmpl programs need adapted handle new construct 
spock designed improvement mind supports advanced tpn constructions 
kirk strategy selection algorithm need revised assumes tpn encapsulated shown top portion 
implementation efficiency improvements spock complicated planning algorithm relies smaller algorithms order solve planning problems 
sub algorithms currently implemented ways motivate implementation improvements 
currently spock enablement checking algorithm searches plan candidate entire pending event episode sets order determine components enabled expansion 
process takes polynomial time expensive spock iterative planning process 
better approach track active tells enabled events enabled episodes support links style truth maintenance systems order efficiently determine pending events episodes enabled un enabled expansion process :10.1.1.38.9249
approach theoretically result linear time enablement checking algorithm result significant performance improvement 
inefficiency spock copies entire plan candidates branches 
uses lot space time takes copy plan candidate negatively impacts runtime 
better solution plan candidates share common components requiring new child candidates contain events episodes differentiate parent candidate 
approach require modifications spock planning algorithm way interacts candidate possibly sub routine responsible deleting parent candidates children pruned 
result improvement significant reduction space time consumption 
note spock partition event episode sets time 
spock enablement checking function needs consider interactions pairs events occur 
temporal indexing storage mechanism useful 
temporal indexing storage device store spock events episodes organize possible execution times 
allow spock compare episodes occur reducing search space enablement checking 
summary thesis provides generative planning algorithm supports temporally flexible planning complex processes 
achieve key contributions 
describe operators goal behaviors concurrent evolution actions states comprised behavioral episodes combined sequential parallel composition 
second goal behaviors operators plan space represented uniformly planning process temporal plan networks 
planning spock forward progression process walks goal tpn moving forward time closing open conditions inserting activity needed 
allen 
maintaining knowledge temporal intervals 
communications acm 
ahuja magnanti orlin 
network flows theory algorithms applications 
prentice hall 
bacchus kabanza 
temporal logic control search forward chaining planner 
new directions planning ghallab eds pages 
berry 
esterel synchronous semantically sound high level language real time applications proc 
ieee real time systems symposium ieee catalog ch pp 

avrim blum furst 
fast planning planning graph analysis 
artificial intelligence 
bonet geffner 
heuristic search planner 
ai magazine fall 
cormen leiserson rivest 
algorithms 
mit press 
dechter meiri pearl :10.1.1.40.1018
temporal constraint networks 
artificial intelligence may 
doyle 
truth maintenance system 
artificial intelligence 
fikes nilsson 
strips new approach application theorem proving problem solving 
artificial intelligence 
james firby 
investigation reactive planning complex domains 
proceedings th national conference ai seattle wa july 
maria fox derek long 
pddl extension pddl expressing temporal planning domains 
journal artificial intelligence research special issue rd international planning competition 
gat 
esl language supporting robust plan execution embedded autonomous agents 
aaai fall symposium issues plan execution cambridge ma 
alfonso gerevini ivan 
lpg planner local search planning graphs 
proceedings sixth international conference ai planning scheduling aips 
hayes 
na physics manifesto 
expert systems micro electronic age michie ed edinburgh university press may 
jorg hoffman bernhard nebel 
ff planning system fast plan generation heuristic search 
journal artificial intelligence research 
ari jonsson paul morris nicola muscettola rajan ben smith 
planning interplanetary space theory practice 
proceedings th aips breckenridge 
henry kautz bart selman 
unifying sat graph planning 
proceedings ijcai 
philip kim brian williams mark abramson 
executing reactive model programs graph temporal planning 
proceedings ijcai 
koenig 
incremental 
advances neural information processing systems 
derek long maria fox 
exploiting graphplan framework temporal planning 
proceedings th international conference automated planning scheduling 
mcallester :10.1.1.38.9249
truth maintenance 
proceedings aaai pp 

muscettola morris pell smith 
issues temporal reasoning autonomous control systems 
proc 
nd international conference autonomous agents minneapolis mn 
dana nau total order planning partially ordered subtasks 
proceedings ijcai 
knight chien fukunaga iterative repair planning spacecraft operations aspen system international symposium artificial intelligence robotics automation space netherlands june 
stuart russel peter norvig 
artificial intelligence modern approach 
prentice hall 
bart selman henry kautz cohen 
local search strategies satisfiability testing 
dimacs series discrete mathematics theoretical computer science 
hsiang shu 
enabling fast flexible planning incremental temporal reasoning 
master thesis massachusetts institute technology 
simmons 
task description language robot control 
proceedings conference intelligent robots systems iros victoria canada 
david smith jeremy frank ari nsson 
bridging gap planning scheduling 
knowledge engineering review 
williams 
doing time putting qualitative reasoning ground 
proc 
th national conference artificial intelligence pp 

williams gupta 
unifying model reactive programming model executive 
proceedings th international workshop principles diagnosis scotland june 
brian williams michel ingham seung chung paul elliott 
model programming intelligent embedded systems 
proceedings ieee special issue modeling design embedded software 

