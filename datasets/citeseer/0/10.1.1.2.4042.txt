pointer escape analysis multithreaded programs alexandru laboratory computer science massachusetts institute technology cambridge ma lcs mit edu presents new combined pointer escape analysis multithreaded programs 
algorithm uses new abstraction called parallel interaction graphs analyze interactions threads extract precise points escape action ordering information objects accessed multiple threads 
analysis compositional analyzing method thread extract parameterized analysis result specialized context 
capable analyzing programs unstructured form multithreading languages java standard threads packages posix threads 
implemented analysis mit flex compiler java extracted information verify programs correctly region allocation constructs eliminate dynamic checks associated regions eliminate unnecessary synchronization 
experimental results show analyzing interactions threads significantly increases effectiveness region analysis region check elimination little effect synchronization elimination 

multithreading key structuring technique modern software 
programmers multiple threads control reasons build responsive servers communicate multiple parallel clients exploit parallelism shared memory multiprocessors produce sophisticated user interfaces enable variety program structuring approaches 
research program analysis traditionally focused sequential programs extensions multithreaded programs usually assumed block structured form multithreading parent thread starts parallel threads immediately blocks waiting finish 
standard form multithreading supported languages java research supported part darpa afrl contract nsf ccr nsf ccr 
permission digital hard copies part personal classroom granted fee provided copies distributed pro commercial advantage copies bear notice full citation rst page 
copy republish post servers redistribute lists requires prior speci permission fee 
ppopp june snowbird utah usa 
copyright acm 
martin rinard laboratory computer science massachusetts institute technology cambridge ma rinard lcs mit edu threads packages posix threads unstructured child threads execute independently parent threads 
software structuring techniques described designed form multithreading recommended design patterns 
lifetimes child threads potentially exceed lifetime starting procedure unstructured multithreading significantly complicates interprocedural analysis multithreaded programs 
analysis algorithm presents new combined pointer escape analysis multithreaded programs including programs unstructured forms multithreading 
algorithm new abstraction parallel interaction graphs maintain precise points escape action ordering information objects accessed multiple threads 
previous escape analysis abstractions parallel interaction graphs enable algorithm analyze interactions parallel threads 
analysis capture objects accessed multiple threads escape multithreaded computation 
fully characterize points relationships objects accessed multiple parallel threads 
parallel interaction graphs characterize potential interactions analyzed method thread callers parallel threads resulting analysis compositional method thread levels analyzes method thread produce single general analysis result specialized context 
combination points escape information abstraction enables algorithm analyze part program analysis result precise program analyzed 
application region allocation implemented analysis mit flex compiler java 
information produces potential applications compiler optimizations software engineering foundation program analysis 
presents experience analysis optimize check safety conditions programs region allocation constructs relying garbage collection 
region allocation allows program run potentially multithreaded computation recursive methods recursively generated threads may require iterative algorithm may analyze methods threads strongly connected component multiple times reach fixed point 
context specific allocation region 
objects created computation allocated region deallocated computation finishes 
avoid dangling implementation ensure objects region outlive associated computation 
standard way achieve goal dynamically check program attempts create object object allocated region shorter lifetime 
program attempt create implementation refuses create throws exception 
unfortunately approach imposes dynamic checking overhead introduces new failure mode programs region allocation 
analysis statically verify multithreaded benchmark programs region allocation correctly 
provides safety guarantee programmer enables compiler eliminate dynamic region checks 
analysis powerful algorithm analyze interactions parallel threads verify correct region allocation 
analysis traditional purpose synchronization elimination 
algorithm quite effective enabling optimization multithreaded benchmarks interthread analysis provides little additional benefit standard analysis 
contributions contributions abstraction presents new abstraction parallel interaction graphs combined pointer escape analysis programs unstructured multithreading 
analysis presents new algorithm analyzing multithreaded programs 
algorithm compositional analyzes interactions parallel threads 
region allocation presents experience analysis statically verify programs correctly region allocation constructs 
benefits include providing safety guarantee program eliminating overhead dynamic region checks 
remainder structured follows 
section presents example illustrates algorithm works 
section presents abstractions analysis uses section presents analysis algorithm section discusses analysis uses 
discuss experimental results section related section conclude section 
example simple example illustrates analysis works 
structure parallel computation presents multithreaded java program computes fibonacci number input 
task class implements parallel divide conquer algorithm computation 
task stores integer object source field input produces new integer object target field output 
program illustrates common patterns multithreaded programs 
uses threads implement parallel computations 
second thread starts execution points objects hold input data computation 
computation finishes writes result objects thread object parent computation read 
class main public static void main string args int integer args fib new fib region new region enter class fib implements runnable int source fib int source public void run task new task new integer source start try join catch exception system println system println target tostring class task extends thread public integer source public integer target task integer source public void run int source intvalue target source task new task new integer task new task new integer start start try join join catch exception system println int target intvalue int target intvalue target new integer multithreaded fibonacci example regions memory management computation runs continually allocates new task objects parallel subcomputations new integer objects hold inputs outputs 
lifetimes program uses standard java thread creation mechanism 
statement start creates new parallel thread control 
new thread control invokes run method task class object 
start run linkage standard way execute new threads java 
objects contained lifetime fibonacci computation die computation finishes 
standard memory management system exploit property 
task integer objects allocated garbage collected heap increasing memory consumption rate garbage collection frequency garbage collection overhead 
region allocation provides attractive alternative 
allocating objects single heap region approaches allow program create multiple memory regions allocate object specific region 
program longer needs objects region deallocates objects region garbage collection 
researchers proposed different region allocation systems 
example implemented system uses approach standardized real time java specification 
main program invokes fibonacci computation creates new memory region statement enter executes run method object methods threads executes context new region threads computation creates new object object allocated region entire multithreaded computation terminates objects region deallocated garbage collection 
task integer objects managed independently garbage collected heap increase garbage collection frequency overhead 
region allocation attractive alternative garbage collection exploits correspondence lifetimes objects lifetimes computations deliver efficient memory management mechanism 
regions dangling checks potential problem region allocation possibility dangling 
object lifetime exceeds region lifetime refers object allocated inside region region deallocated access potentially recycled garbage violating memory safety program 
real time java specification eliminates possibility follows 
allows computation create hierarchy nested regions ensures parent region deallocated child regions 
region associated potentially multithreaded computation objects region deallocated computation terminates objects child regions deallocated 
implementation dynamically checks assignments object fields ensure program attempts create goes hierarchy object ancestor region object child region 
program attempt create check fails 
implementation prevents assignment place throws exception 
checks ensure memory safety execution impose additional execution time overhead introduce new failure mode software 
goal analyze program statically verify checks fail 
analysis enable compiler eliminate dynamic region checks 
provide programmer guarantee program throw exception check failed 
analysis example generalized escape analysis determine object allocated region escapes computation associated region 
objects escape program attempt create dangling compiler eliminate checks 
algorithm performs interprocedural analysis derive parallel interaction graph method 
figures analysis results run methods fib task classes respectively 
points graphs component parallel interaction graph points graph 
nodes graph represent objects edges represent objects 
kinds edges inside edges represent created analyzed part program sequential computation fib run method outside edges represent read objects potentially accessed outside analyzed part program 
figures solid lines denote inside edges dashed lines denote outside edges 
kinds nodes 
inside nodes represent objects created analyzed part program 
inside node object creation site program node represents objects created site 
parameter nodes represent objects passed parameters currently analyzed method load nodes represent objects accessed reading object potentially accessed outside analyzed part program 
parameter load nodes set outside nodes 
figures solid circles denote inside nodes dashed circles denote outside nodes 
nodes outside nodes 
node represents parameter method node represents object loaded expression target line example fib run method 
nodes inside nodes denote task integer objects created statement task new task new integer source line example 
started thread information parallel interaction graph contains information threads started analyzed part program 
node represents started task thread implements entire fibonacci computation 
nodes represent threads implement parallel subtasks computation 
interthread analysis uses started thread information computes interactions current thread threads execute parallel current thread 
escape information parallel interaction graph contains information objects escape analyzed part program accessed unanalyzed part 
node escapes parameter node represents unanalyzed thread started analyzed part program 
escapes reachable escaped node 
node escapes passed parameter nodes escape reachable unanalyzed thread node 
points information escape information source target inside edge outside edge parameter node unanalyzed started thread node reachable reachable inside node outside node analysis result fib run points information escape information source source target source target target parameter node reachable reachable unanalyzed started thread node reachable reachable unanalyzed started thread node reachable reachable analysis result task run points information fib run source target points information task run mappings source target mappings interthread analysis fib run task run points information escape information source source target source target target parameter node unanalyzed started thread node reachable reachable unanalyzed started thread node reachable reachable analysis result interthread analysis points information escape information source source target source target target parameter node final analysis result fib run interthread analysis previously proposed escape analyses treat threads conservatively object reachable thread object analyses assume permanently escaped :10.1.1.12.2189
algorithm analyzes interactions threads recapture objects accessed multiple threads 
foundation interthread analysis construction mappings nodes parallel interaction graphs parent child threads 
outside node mapped node nodes represent object analysis 
mappings combine parallel interaction graph child thread parallel interaction graph parent thread 
result new parallel interaction graph summarizes parallel execution threads 
presents mappings interthread analysis fib run task run method thread fib run starts 
algorithm computes mappings follows initialization inside fib run method node represents started task thread 
inside task run method node represents started thread 
algorithm initializes map node node 
matching target edges analysis task run method creates inside edges node nodes 
edges label target represent corresponding task integer objects execution task run method 
fib run method reads obtain result task run method 
outside edge node node represents analysis fib run method 
analysis matches outside edge fib run method node node inside edges task run method compute node represents objects nodes 
result maps node nodes 
matching source edges analysis fib run method creates inside edge node node 
edge label source represents corresponding task integer objects execution fib run method 
task run method reads obtain input 
outside edge node node represents analysis task run method 
interthread analysis matches outside edge task run method node node inside edge fib run method node node compute node represents objects node 
result maps node node 
transitive mapping maps node node maps node node analysis computes node represents object node 
result maps node node 
note matching process models interactions thread reads created thread 
threads execute parallel matching symmetric 
analysis uses combine parallel interaction graphs obtain new graph represents combined effect threads 
presents graph analysis computes follows edge projections analysis projects edges mappings augment nodes parallel interaction graph edges graph 
example analysis projects inside edge node node generate new inside edges node nodes 
generates edges involving outside nodes removes edges simplification step 
graph combination analysis combines graphs omitting outside node represents parameter started thread node example 
simplification analysis removes outside edges captured nodes outside nodes reachable parameter node unanalyzed started thread node inside nodes reachable live variable parameter node unanalyzed started thread node 
example analysis analyzed thread node 
nodes captured reachable thread node 
analysis removes nodes new graph reachable parameter node unanalyzed thread node 
note interactions thread nodes analyzed nodes nodes reachable escape 
example program uses recursively generated parallelism analysis perform fixed point computation interthread analysis 
presents final parallel interaction graph fib run method result fixed point analysis 
analysis inside nodes including task nodes 
objects represented nodes escapes computation fib run method execution new region violate region referencing constraints 

analysis abstraction formally abstraction parallel interaction graphs analysis uses 
addition pointsto escape information discussed section parallel interaction graphs represent ordering information actions synchronization actions parent child threads 
ordering information enables analysis determine thread start events temporally separate actions parent child threads 
information may example enable analysis determine parent thread performs synchronizations object child thread starts execution synchronizes object 
simplify presentation assume program static class variables methods analyzable methods returns result 
implemented analysis correctly handles aspects 
object representation analysis represents objects program manipulates set nodes disjoint union set ni inside nodes set outside nodes 
set thread nodes nt ni represents thread objects 
set outside nodes disjoint union set nl load nodes set np parameter nodes 
set fields objects set local parameter variables set local variables 
points escape graphs points escape graph triple nl set outside edges 
notation 
set inside edges 
notation 
escape function records escape information node 
node escapes reachable parameter node node represents unanalyzed parallel thread 
escape function satisfy invariant points escapes ways escapes 
analysis adds edge pointsto escape graph updates escape function satisfies invariant 
define concepts escaped captured nodes follows escaped ife captured ife parallel interaction graphs parallel interaction graph tuple thread set represents set unanalyzed thread objects started analyzed computation 
action set records set actions executed analyzed computation 
synchronization action sync represents object action performed node represents thread performed action 
action performed current thread dummy current thread node nt implementation record actions reading object writing object invoking method object 
straightforward generalize concept actions include actions performed multiple objects 
action order records ordering information actions current thread threads execute parallel current thread 
set subsets set nodes escapes 
sync synchronization action sync may happened threads represented started executing 
case actions thread represented may conflict action 
represented outside edge may read threads represented started executing 
case outside edge may represent written thread represented notation denote set actions outside edges may occur parallel thread represented 
analysis algorithm program point algorithm computes parallel interaction graph current analysis scope point 
intraprocedural analysis analysis scope currently analyzed method point 
interprocedural analysis extends scope include transitively called methods interthread analysis extends scope include started threads 
analysis identifying program representation different phases key algorithms interprocedural interthread phases 
program representation algorithm represents computation method control flow graph 
assume program preprocessed statements relevant analysis copy statement load statement store statement synchronization statement acquire release object creation statement new cl method invocation statement op 
lk thread start statement start 
control flow graph method op starts enter statement ends exit statement 
intraprocedural analysis intraprocedural analysis forward dataflow analysis propagates parallel interaction graphs statements method control flow graph 
method analyzed assumption parameters maximally point different objects 
method formal parameters 
vn initial parallel interaction graph entry point method vi nv nv nv parameter node parameter vi 
method invoked context parameters may point object interprocedural analysis described section merges parameter nodes con model effect aliasing 
transfer function st models effect statement st current parallel interaction graph 
graphically presents rules determine new points graphs different basic statements 
row contains items statement graphical representation existing edges graphical representation existing edges plus new edges statement generates set side generated edges basic statements reachable transfer function start sync sync transfer function acquire release conditions 
interpretation row points escape graph contains existing edges side conditions satisfied transfer function statement generates new edges 
assignments variable kill existing edges variable assignments fields objects leave existing edges place 
addition updating outside inside edge sets transfer function updates escape function ensure points escapes ways escapes 
load statements transfer functions leave unchanged 
load statement transfer function updates action order record new outside edges may created parallel threads modeled nodes nl load node nl escaped presents transfer function start statement adds started thread nodes updates escape function 
presents transfer function synchronization statements add corresponding synchronization actions record actions executing parallel nodes 
control flow merges confluence operation takes union inside outside edges thread sets actions action orders 
mappings mappings implement substitutions take place combining parallel interaction graphs 
interprocedural analysis example parameter node callee mapped nodes call site may represent corresponding actual parameter 
analysis component denotes component replacing node nl nl sync sync sync sync interprocedural analysis interprocedural analysis computes transfer function method invocation statement 
assume method invocation site form op 
lk potentially invoked method op formal parameters 
vk corresponding parameter nodes nv nv 
nv parallel interaction graph program point method invocation site graph exit statement op 
interprocedural analysis steps 
computes mapping outside nodes callee 
uses combine parallel interaction graphs obtain parallel interaction graph program point immediately method invocation 
analysis computes fixed point constraints exception definition substitute load node nl constitutes point outside edge nl li nv constraint initializes constraints extend 
constraint maps parameter node callee nodes caller represent actual parameters call site 
constraint matches outside edges read callee corresponding inside edges caller 
constraint matches outside edges callee inside edges callee model aliasing callee nodes 
algorithm extends ensure nodes callee parameter nodes appear new parallel interaction graph np algorithm computes new parallel interaction graph program point method invocation follows computes new escape function union escape function method invocation expansion escape function callee formally constraints define new escape function np propagated edges interprocedural analysis reachability parameter nodes callee longer relevant escape function set difference second initialization constraint 
proof interprocedural analysis produces parallel interaction graph conservative obtained inlining callee performing intraprocedural analysis section 
simplify resulting parallel interaction graph removing superfluous nodes edges 
remove load nodes nl nl graph load nodes represent concrete object 
remove outside edges start captured node outside edges represent concrete 
remove nodes reachable live variable parameter node unanalyzed started thread node dynamic dispatch single method invocation site may invoke different methods 
transfer function merges parallel interaction graphs potentially invoked methods derive parallel interaction graph point method invocation site 
current implementation obtains call graph information variant cartesian product type analysis conservative approximation dynamic call graph 
analysis uses worklist algorithm solve combined intraprocedural interprocedural dataflow equations 
bottom analysis program yields full result analysis strongly connected component call graph 
strongly connected components algorithm iterates fixed point 
thread interaction interactions threads take place starter thread thread starts parallel thread thread thread started 
interaction algorithm parallel interaction graph program point starter thread node nt represents thread run method runs thread object represented nt starts 
parallel interaction graph associated exit statement run method result thread interaction algorithm parallel interaction graph models interactions execution starter thread corresponding program point entire thread 
result conservatively models possible interleavings threads 
algorithm steps 
computes mappings maps outside nodes starter maps outside nodes 
uses combine parallel interaction single parallel interaction graph reflects interactions threads 
algorithm computes fixed point constraints nt nv nt oi ij oi ii ii oj nv parameter node associated single parameter run method pointer dummy current thread node 
nt 
note algorithm computes interactions outside edges starter thread represent read thread starts 
caller callee interaction execution caller suspended execution callee starter interaction threads execute parallel producing complicated set statement interleavings 
interthread analysis model richer set potential interactions thread read edges created thread 
interthread analysis uses mappings thread just mapping 
augments constraints reflect potential interactions 
style interprocedural analysis algorithm initializes mappings extend respectively 
node initial parallel interaction graphs nv appear new parallel interaction graph nv algorithm uses compute resulting parallel interaction graph follows nt addition combining action orderings starter algorithm updates new action order reflect ordering relationships actions outside edges occur parallel starter threads actions outside edges starter thread occur parallel thread occur parallel threads starts 
new escape function union escape function starter escape function expanded respectively 
formally escape function initialized constraints np propagated edges interthread analysis interthread analysis uses fixed point algorithm obtain single parallel interaction graph reflects interactions parallel threads 
algorithm repeatedly chooses node nt retrieves analysis result exit node corresponding run method uses thread interaction algorithm section compute interactions analyzed threads thread represented nt combine parallel interaction graphs new graph 
algorithm reaches fixed point removes nodes nt escape function final graph models possible interactions may affect nodes escape unanalyzed thread nodes 
analysis may recapture thread nodes escaped interthread analysis 
example thread node algorithm uses type information determine class contains run method 
inside nodes approach exact 
outside nodes algorithm uses class hierarchy analysis find set classes may contain run method 
algorithm computes interactions possible run methods merges results 
practice contains inside nodes common coding practice create start threads method 
escape parameter node captured interthread analysis 
algorithm enhances efficiency precision analysis removing superfluous nodes edges simplification method interprocedural analysis 
algorithm assumes node represents multiple instances corresponding thread 
implementation improves precision analysis tracking node represents single thread multiple threads 
nodes represent single thread algorithm computes interactions just adjusting new action order record outside edges actions thread occur parallel node represents thread 
nodes represent multiple threads algorithm repeatedly computes interactions reaches fixed point 
resolving outside nodes possible augment algorithm records outside node inside nodes represents analysis entire program 
information allows algorithm go back analysis results generated various program points resolve outside node set inside nodes represents analysis 
absence nodes escape unanalyzed threads methods enables algorithm obtain complete precise points information analysis results contain outside nodes 

analysis uses discuss analysis results perform optimizations region check elimination synchronization elimination 
region check elimination analysis eliminates region checks verifying object allocated region escapes computation executes context region 
system computations invoked execution statement form enter 
statement causes run method thread execute context memory region analysis locates run methods 
analyzes run method performing interthread analysis checks inside nodes analysis result escape 
inside nodes escape objects allocated inside region inaccessible computation terminates 
region checks succeed removed 
synchronization elimination synchronization elimination algorithm uses results interthread analysis find captured objects synchronization operations removed 
previous synchronization elimination algorithms algorithm uses analysis results remove synchronizations objects escape thread created 
previous synchronization elimination algorithms algorithm analyzes interactions parallel threads 
uses action set action ordering relation eliminate synchronizations objects synchronizations multiple threads 
analysis proceeds follows 
node captured interthread analysis examines find threads execute parallel synchronization examines action set determine synchronizes parallel threads synchronize compiler remove synchronizations objects represents 
multiple threads synchronize objects analysis determined synchronizations temporally separated thread start events redundant 

experimental results implemented combined pointer escape analysis algorithm mit flex compiler system static compiler java 
analysis information synchronization elimination elimination dynamic region checks 
experimental results set multithreaded benchmark programs 
general programs fall categories web servers scientific computations 
web servers include server quote stock quote server 
applications written posted internet 
scientific programs include barnes water complete scientific applications appeared benchmark sets including splash parallel computing benchmark set 
results synthetic benchmarks tree array object field assignment heavily 
benchmarks designed obtain maximum possible benefit region check elimination 
methodology modified benchmark programs regionbased allocation 
web servers create new thread service new connection 
modified versions separate region connection 
scientific programs execute sequence interleaved serial parallel phases 
modified versions separate region parallel phase 
result modified benchmarks allocate long lived shared objects garbage collected heap short lived objects regions 
modifications relatively straightforward perform difficult evaluate correctness modifications static analysis 
web servers particularly problematic heavily java libraries 
static analysis clear libraries correctly region allocation 
quote tree array interprocedural analysis able verify correct region allocation enable elimination dynamic region checks 
barnes water required interthread analysis eliminate checks interprocedural analysis unable verify correct region allocation 
mit flex compiler generate implementation benchmark gcc compile program executable 
ran quote servers mhz pentium ii running linux clients running mhz pentium iii running linux 
machines connected private mbit sec ethernet 
ran water barnes tree array mhz pentium iii running linux 
analysis time bytecode removing backend program instructions checks syncs time tree array water barnes quote program sizes analysis times original optimized version program version interprocedural interthread tree array water barnes quote number synchronization operations program standard checks checks tree array water barnes quote execution times benchmarks number number program objects heap objects regions tree array water barnes quote allocation statistics benchmarks results presents program sizes analysis times 
synchronization elimination algorithm analyzes entire program region check algorithm analyzes run methods methods transitively invoke 
synchronization elimination analysis takes significantly time region analysis 
backend time time required produce executable analysis finished 
times seconds 
presents number synchronizations original version analysis interprocedural version interprocedural analysis interthread version interprocedural interthread analysis 
optimization interthread analysis produces additional benefit interprocedural analysis 
presents execution times benchmarks 
standard version allocates objects heap region allocation 
checks version uses region allocation dynamic checks 
checks version uses region allocation analysis eliminating dynamic checks 
versions uses synchronization elimination optimization 
check elimination produces substantial performance improvements tree array modest performance improvements water barnes 
running times quote dominated thread creation operating system overheads check elimination provides basically performance increase 
presents number objects allocated garbage collected heap number allocated regions 
vast majority objects allocated regions 
discussion applications regions ways 
servers allocate new region connection 
region holds new objects required service connection 
examples objects include string objects hold responses sent clients iterator objects find requested data 
scientific programs regions auxiliary objects structure parallel computation 
objects include thread objects required generate parallel computation objects hold values produced intermediate calculations 
general eliminating region checks provides modest performance improvements 
view primary value analysis context helping programmer regions correctly 
expect analysis especially useful situations web servers programmer may complete confidence detailed knowledge program object usage patterns 

related discuss areas related analysis multithreaded programs escape analysis multithreaded programs region allocation 
analysis multithreaded programs analysis multithreaded programs relatively unexplored field 
awareness multithreading significantly complicates program analysis full range standard techniques emerge 
grunwald srinivasan dataflow analysis framework reaching definitions explicitly parallel programs knoop steffen efficient dataflow analysis framework bit vector problems liveness reachability available expressions 
frameworks designed programs structured concurrency intraprocedural 
view main contributions largely orthogonal previous research 
particular main contributions center abstractions algorithms interprocedural compositional analysis programs unstructured multithreading 
focus problems pointer escape analysis fit framework 
aware pointer analysis algorithms multithreaded programs algorithm rinard multithreaded programs structured concurrency intraprocedural algorithm corbett 
algorithms compositional discover interactions threads repeatedly thread new analysis context reach fixed point maintain escape information support analysis incomplete programs 
escape analysis multithreaded programs published escape analysis algorithms java programs analyze interactions threads 
object escapes thread object 
algorithms best viewed sequential program analyses extended execute correctly conservatively presence multithreading 
analysis takes step analyzing interactions threads recapture objects accessed multiple threads 
ruf analysis occupies point traditional escape analyses multithreaded analysis 
analysis tracks synchronizations thread performs object enabling compiler remove synchronizations objects accessed multiple threads thread synchronizes object 
analysis goes step remove synchronizations multiple threads synchronize object 
requirement thread start events temporally separate synchronizations different threads 
region allocation region allocation systems years 
comparison focuses safe versions ensure dangling deleted regions 
researchers developed type systems support safe region allocation 
systems flow insensitive context sensitive analysis correlate lifetimes objects lifetimes computations 
analyses designed sequential programs straightforward generalize handle multithreaded programs 
gay aiken system provides interesting contrast approach 
provide safe flat region system allows arbitrary regions 
implementation instruments store instruction count go regions 
region deleted objects objects regions 
dynamic counted approach works equally sequential multithreaded programs 
system supports explicit assignment objects regions allows programmer type annotations specify stay region 
violations constraint generate run time error static analysis reduces designed eliminate possibility error occurring 
real time java specification implementation provides flexible system hierarchically organized regions implicit assignment objects regions 
region lifetimes hierarchically nested implementation dynamically counts region number child regions number external pointers region 
performing counter manipulations store unoptimized version system checks assignment ensure program generates goes hierarchy ancestor region descendant region 
static analysis eliminates checks interthread analysis required successfully optimize multithreaded programs 

multithreading key program structuring technique language system designers threads central part widely languages systems multithreaded software pervasive 
presents abstraction parallel interaction graphs algorithm uses abstraction extract precise pointsto escape action ordering information programs standard unstructured form multithreading provided modern languages systems 
implemented analysis mit flex compiler java extracted information verify programs correctly region allocation constructs eliminate dynamic checks associated regions eliminate unnecessary synchronization 
experimental results show analyzing interactions threads significantly increases effectiveness optimizations region programs little effect synchronization elimination 

started research collaboration john whaley contributions collaboration 
wes invaluable assistance region allocation package darko marinov viktor interesting discussions regarding pointer escape analysis 

agesen palsberg schwartzbach 
type inference self analysis objects dynamic multiple inheritance 
software practice experience sept 
blanchet 
escape analysis object oriented languages 
application java 
proceedings th annual conference object oriented programming systems languages applications denver nov 

removing unnecessary synchronization java 
proceedings th annual conference object oriented programming systems languages applications denver nov 
hardin gosling turnbull 
real time specification java 
addison wesley reading mass 
chandra gupta hennessy 
data locality load balancing cool 
proceedings th acm sigplan symposium principles practice parallel programming san diego ca may 
choi gupta serrano sreedhar midkiff 
escape analysis java 
proceedings th annual conference object oriented programming systems languages applications denver nov 
corbett 
shape analysis reduce finite state models concurrent java programs 
proceedings international symposium software testing analysis mar 
crary walker morrisett 
typed memory management calculus capabilities 
proceedings th annual acm symposium principles programming languages san antonio tx jan 
gay aiken 
language support regions 
proceedings sigplan conference program language design implementation snowbird ut june 
grunwald srinivasan 
data flow equations explicitly parallel programs 
proceedings th acm sigplan symposium principles practice parallel programming san diego ca may 
hauser jacobi theimer welch weiser 
threads interactive systems case study 
proceedings fourteenth symposium operating systems principles asheville nc dec 
knoop steffen 
parallelism free efficient optimal bitvector analyses parallel programs 
acm transactions programming languages systems may 
lea 
concurrent programming java design principles patterns 
addison wesley reading mass 
nielson nielson hankin 
principles program analysis 
springer verlag 
pai druschel 
flash efficient portable web server 
proceedings usenix annual technical conference june 
reppy 
higher order concurrency 
phd thesis dept computer science cornell univ ithaca june 
rinard 
analysis multithreaded programs 
proceedings th static analysis symposium paris france july 
ruf 
effective synchronization removal java 
proceedings sigplan conference program language design implementation vancouver canada june 
rinard 
pointer analysis multithreaded programs 
proceedings sigplan conference program language design implementation atlanta ga may 

pointer analysis applications java programs 
master thesis dept electrical engineering computer science massachusetts institute technology preparation 
tofte birkedal 
region inference algorithm 
acm transactions programming languages systems july 
whaley rinard 
compositional pointer escape analysis java programs 
proceedings th annual conference object oriented programming systems languages applications denver nov 
woo singh gupta 
splash programs characterization methodological considerations 
proceedings nd international symposium computer architecture 
acm new york june 
