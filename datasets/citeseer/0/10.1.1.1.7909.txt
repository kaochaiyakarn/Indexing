type reconstruction presence polymorphic recursion recursive types said boston university cs bu edu kfoury boston university kfoury cs bu edu december technical report bu cs establish equivalence type reconstruction polymorphic recursion recursive types equivalent regular cation proves undecidability corresponding type reconstruction problem 
establish equivalence type reconstruction polymorphic recursion positive recursive types special case regular semi uni cation call positive regular semi uni cation 
decidability positive regular cation open problem 
semi uni cation developed powerful tool study polymorphic type systems 
various forms semi uni cation problem depending kind terms allowed inequalities instance partly supported nsf ccr 
address department science boston university st boston ma usa 
partly supported nsf ccr 
address department science boston university st boston ma usa 
shown reconstruction problem various polymorphically typed calculi functional programming languages 
equivalence generalizes known relationship standard rst order uni cation typability simply typed calculus 
sample results area reader referred :10.1.1.42.3091
report extend theory semi uni cation deal polymorphic recursion recursive types simultaneously 
polymorphic recursion introduced xpoint constructor object level recursive types introduced bya xpoint constructor level 
recursive types come varieties restriction binds atype variable occurrences positive 
obtain distinct polymorphic type systems ml ml pos rst extending second second extending ml type system 
importance polymorphic recursion programming languages rst observed mycroft 
polymorphic recursion allows de nition functionf contain recursive calls tof di erent types instances generic type 
mycroft extended ml type system feature proved principal type property resulting system left open corresponding type reconstruction problem 
subsequently ml studied extensively henglein kfoury tiuryn urzyczyn nally proved type reconstruction problem undecidable :10.1.1.42.3091
importance recursive types positive recursive types programming language theory recognized years sample results restricted aspects type checking 
report organized follows 
rst give precise de nition recursive positive recursive types section introduce systems ml pos section 
call system short 
systems fact pared versions su cient purposes particular omitted pairing constructors features interesting programs written omitted constructor 
constructor source polymorphism diminish importance semi uni cation parts theoretical computer science 
see example aswell survey application areas 
greatest successes semi uni cation theory undoubtedly area polymorphic type systems 
standard ml addition simply typed calculus turns ptime complete dexptime complete 
shown polymorphic recursion added constructor reconstruction undecidable problem omit 
de ne forms semi uni cation problem section denoted regular sup positive regular sup 
prove equivalent reconstruction ml ml pos respectively sections 
having established equivalences conclude type reconstruction problem ml undecidable leave problem open ml pos section 
types de nition nite set type variables type constants respectively 
set recursive types de ned follows 

follow standard convention 
stands 
universal recursive types expressions form lett bethe set universal recursive types 
universal quanti er operator bind type variables 
identify convertible types types identical renaming bound variables 
substitution functions notation stands result substituting free occurrences appropriate renaming bound variables necessary 
write simultaneous substitution 
avariable positive free occurrence left hand side number 
set positive recursive types de ned follows de nition 



positive 
set universal positive recursive types atype nite contain occurrence operator 
set nite types 
notice lett set nite nite labeled binary trees labels 
type consists node descendants possibly nite type regular set subtypes nite 
set regular types 
type form unfolding step results type 
recursive type represents underlying regular type obtained unfolding nitely times 
formally 
refer reader exact de nition 
true type notation unique refer reader proof fact contains detailed discussion nite regular types 
means appropriate properties prove results vice versa 
particular view regular cation semi uni cation recursive terms 
fact prove undecidability oftype reconstruction system standard notions equivalence referred strong equivalence 
represent regular type 
de nition de nition smallest equivalence relation satisfying 


observe implies converse false example case 
observe relations decidable 
systems thesis consider simple language consisting terms augmented polymorphic constructor set constants 
noted refer object constants bya object variables augmented terms considered de ned grammar jaj mn xm usual constructors assumed bind variables 
adopt standard notion conversion generally distinguish convertible terms 
describe type inference systems systems di er types equivalence relation uses 
uses recursive types equivalence relation uses positive recursive types type inference systems shown figures respectively 
follow standard notation terminology 
environment nite set type assumptions fx xn ng associating type 
denote set type variables occurring free ina 
partial function object variables types may writea mean assumption ina 
assertion expression forma environment atype 
assertion mentioned ina called environment types assigned derived type 
derivability ins denoted symbols respectively 
vara type constant inst gen app abs fix mn xm fv 
system environment types derived types vara type constant inst gen app abs fix mn xm fv 
system environment types derived types 
syntax oriented rules system syntax oriented sense derivation tree certain assertion 
subsection give syntax oriented version 
simpli es proofs report 
sort simpli cation standard step papers dealing polymorphic recursion see 

write mean instantiation similarly instantiation corresponds sequence applications rule inst rule rule leads lemma 
lemma 
ifa thena 
ifa thena modi cation respectively shown figures consists removing rules inst gen modifying var fix rules 
resulting systems partially syntax oriented sense derivation assertion unique applications rule ins ins 
derivability ins denoted symbols 
keep notation simple clear context system considering simply symbol denote derivability particular system 
vara type constant app abs fix mn xm fv 
system environment types derived types vara type constant app abs fix mn xm fv 
system types 
derived types 
main result subsection lemma 
similar lemma lemma :10.1.1.42.3091
proof lemma adopted proof lemma :10.1.1.42.3091
lemma letm term aan environment resp zero type variables fv ia resp ia 
proof direction structural induction derivations cases single derivation rules const var 
var rule assume thata applying var rule system var rule observing wehave const rule observe const rule obtain const rule similar argument case var const rules 
fix rule assume thata derivable fix rule applying fix rule induction hypothesis get assumption fv 
apply fix rule get similar argument fix rule 
inductive proof rules straightforward 
direction notice su cient 
ifa thena 
ifa thena prove producing rule corresponding derivation respectively 
non trivial cases rules var fix 
var rule respectively assume thata applying var rule get var rule respectively part lemma part case derive respectively fix rule assume rule apply derivation fix rule get derivation applying gen rule needed get apply fix rule obtain part lemma get similar argument applies 
positive regular semi uni cation result equivalence sets look regular substitution substitution section rede ne regular semi uni cation de ne positive regular semi uni cation 
regular resp 
positive regular substitutions functions resp regular resp 
positive regular substitution extended natural way functions resp 
instance semi uni cation nite set inequalities ng ui 
regular regular solution instance sn sn regular semi uni cation problem problem deciding instance regular solution 
instance positive regular solution positive regular substitutions positive regular sn sn positive regular semi uni cation problem problem deciding instance positive regular solution 
construct instance semi uni cation mis typable ins regular solution 
mis typable ins positive regular solution 
construction similar construction section 
proofs di er slightly style syntax oriented version gen rule 
constants added 
view construction extension construction de nitions related 
constructing set equalities pg pg 
follow convention variable occurring inm member andy 
furthermore variable occurs free bound member 
variable bound member constant occurring 
letm mn enumeration subterms ofm fork object variable mi xv mi andi 
set fm mng mentions occurrences subterm may mj fori observe mn 
de nition fork simultaneously de ne type variables inv induction 
th occurrence inm set 
number occurrences free bound inm starting left ofm 
bound inm binding occurrence xxi counted 

yi set 
ai set ci 

set fresh auxiliary variable 

yi mj set tj 
tj bound occurrences introduced corresponding bound occurrences 

xxi mj set write 
di erence add constants allow polymorphic abstraction 
de ne variables occurring follows free bound occurrences occurs occurs mg jxi occurs nite sequence possibly empty type variables de ne body denotes map ands denotes map 
occurring restricts ands ands 
ands associate ands respectively satisfying condition body ands body 
symbol denotes partial order object variables relative tom 
fx fy bound inm binding scope binding ofy 
de ne means regular solution positive regular solution respectively notice solution solution instance semi uni cation 
de nition regular solution fork conditions hold 
equality ks 

occurring 

occurring bound variables ofs precisely set fv ffv jxi de nition positive regular solution fork ni conditions hold 
equality 

occurring 

occurring bound variables ofs precisely set fv ffv jxi lemma extension lemma 
lemma letm term 

type thata regular body tm xi 

type thata positive regular solutions body tm ands xi 

ifs regular solution thena environment body tm anda xi 
ifs positive regular solution thena body tm xi 
proof observe facts derivations systems ifa assertion derivation anx ory variable thena de ned free inm bound inm andn scope binding ofv 
ifa xi assertion immediately preceding application fix discharges type assumption xi assume bound type variables precisely fv ffv yj ja yj de ned letm mn enumeration subterms ofm 
induction proofs parts similar show inductive proof part 
part need show ifa mk solutions body tk xi ands yi 
basis step need consider cases th occurrence yi 
ai cases straightforward see regular solutions xi yi 
induction step case example cases similar 
assume xxi mj implies thata xi fix rule system induction hypothesis solutions tj ands xi 
easily adjusts tj force tj 
step construction easily check thats solution satisfying conditions part 
proofs parts induction 
proof part omit proof part similar 
part need show regular solution type mk body tk xi anda yi 
basis step need consider cases mentioned 
straightforward see basis step correct 
induction step consider case example 
assume xxi mj 
observe ifs solution solution assume thats tj ands tk step construction conclude thats tj induction hypothesis thata mj xi letb 
fix rule system wecan conclude mk de ne instance semi uni cation solution sense semi uni cation solution 
de nition letm term pg set equalities obtained described 
largest index occurs 
contains inequality fresh auxiliary variables 

contains inequality tij uij tij 
uij 
jxi 

contains inequality 
lemma ifm term 
sis regular solution sense semi uni cation regular solution sense de nition 

positive regular solution sense semi uni cation positive regular solution sense de nition 
proof reproduces proof lemma necessary terminological changes 
consider inequality introduced part de nition regular resp 
positive regular solution sense de nition resp 
de nition regular resp 
positive regular solution sense semi uni cation 
consider inequality tij uij introduced part de nition resp 
de nition readily checked thats resp bound variables ofs fv ffv jxi regular resp 
positive regular solution tij uij sense semi uni cation 
section construction section reproduce text section necessary modi cations 
technical force object variable assigned particular nite type substitution instance 
letz object variable nite type 
type variables named corresponding weintroduce object type constants corresponding object de ne term denoted hz induction nite types 
ci fori ng hz ai 
fori 
hz vi 
hz hz ihz zz uz clear induction fv hz fzg fv lemma extension lemma explains crucial property term hz lemma arbitrary nite type fv 
arbitrary recursive types 
term hz typable fz hz 

arbitrary positive recursive types 
term hz typable fz hz 
proof give proof part lemma leave part reader proofs similar 
proof induction basis step ci easily checked hz typable induction step assume hz hz typable environment fz forj 
readily checked term hz typable environment fz 
hz typable inb induction hypothesis 
lemma consider instance semi uni cation form mentions type variables 
de ne xx zn nz hz nie en yn xw yn hyi ii fori mis typable regular solution 
mis typable positive regular solution 
proof just show proof part lemma 
proof just reproduction proof lemma necessary modi cations 
left right implication suppose typable 
means typable types tox zn 
type ofx assume types assigned tov respectively 
ii typable ina fori environment contain type lemma 
type form assigned tov zn 

depends type ofz 
term xw yn hyi ii typable appropriately extended environment 
follows type assigned th occurrence form 


regular types lemma 
instance precisely particular si fori substitution regular solution instance 
converse suppose solution regular types sn si fori shall show typable leta vi ji de ne environment ai wj jj yi yj jj ig fori arbitrary regular types 
lemma case hyi ii open type follows ai 
xw yn hyi ii new type variables 


typable ina fx ig 
letb zi ji ng 
lemma term ii typable inb 
de ne fx 

stands quantify variables applying obtain type si si si si take forj appropriate fz ii typable fori repeated abstractions fz zn 

nally application gen rule repeatedly followed fix rule fz proves typable decidability results regular semi uni cation arbitrary trees undecidable 
proof result 
result restricted semi uni cation binary trees leads theorem type reconstruction system undecidable 
proof proof directly obtained undecidability regular cation equivalence regular semi uni cation regular cation binary trees 
open reconstruction system decidability 
roberto amadio luca cardelli 
subtyping 
acm transactions programming languages systems 
courcelle properties nite trees 
theoretical computer science 
coppo 
type inference syntax semantics 
information computation 
rounds 
subsumption cation feature algebras 
proceedings ieee th annual symposium logic computer science pages 
giannini ronchi della rocca 
characterization typings polymorphic type discipline 
proceedings ieee rd annual symposium logic computer science pages 
henglein :10.1.1.42.3091
type inference polymorphic recursion 
acm transactions programming languages systems 
kfoury 
general theory semi uni cation 
technical report boston university department computer science december 
kanellakis mitchell 
polymorphic uni cation ml typing 
proceedings th acm symposium principles programming languages pages 
kapur musser narendran stillman 
semi uni cation 
kumar editors proceedings th conference software technology theoretical computer science lncs pages 
springer verlag 
kfoury tiuryn urzyczyn 
hierarchy nitely typed functional programs 
proceedings ieee nd annual symposium logic computer science pages 
kfoury tiuryn urzyczyn 
computational power universally polymorphic recursion 
symposium logic computer science pages 
kfoury tiuryn urzyczyn 
analysis ml typability arnold editor th colloquium trees algebra programming caap lncs pages 
springer verlag 
kfoury tiuryn urzyczyn 
undecidability ofthe semi uni cation problem 
proceedings nd annual acm symposium theory computing baltimore pages 
kfoury tiuryn urzyczyn 
type reconstruction presence polymorphic recursion 
acm transactions programming languages systems 

semi uni cation type inference polymorphic recursion 
research report inf ase siemens munchen 
mairson 
deciding ml typability complete deterministic exponential time 
proceedings th acm symposium principles programming languages pages 
mendler 
inductive types type constraints second order lambda calculus 
annals pure applied logic 
mitchell 
polymorphic type inference containment 
information computation 
mycroft 
polymorphic type schemes recursive de nitions lncs 
paul robinet editors international symposium programming pages 
springer verlag 

uni cation problem related kreisel conjecture 
mathematicae prague czechoslovakia 

