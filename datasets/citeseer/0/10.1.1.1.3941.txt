contracts quality attributes software components ralf software engineering group department computing science university oldenburg germany informatik uni oldenburg de heinz schmidt school computer science software engineering monash university australia monash edu au argue quality attributes component constant property 
quality component heavily depends specific usage context 
specification method specified components specify quality attributes constants functions evaluated deployment 
contribution threefold clarify term contractual components term inconsistently current literature 
translate design contract principle components 
generalise component contracts parameterised contracts mentioned context dependencies components account 
demonstrate parameterised contracts compute reliability software components 
results empirical evaluation confirm strong context dependency component reliability show parameterised contracts reliability prediction easy specify automated control flow analysis 

quality attributes components gaining increasing attraction cbse community 
term quality attribute extra functional properties externally visible user reliability performance opposed extra functional properties intrinsic software maintainability reusability 
reasons attraction quality attributes component software engineering cbse identified component users wish knowledge quality component purchase decision 
components similar functional properties knowledge quality attributes significant information specified 
past promising areas software engineering software architecture software components moved closer 
major motivations software architectures aim reason explicitly extra functional properties software design may benefit lot focusing component software architectures 
consequently problem predicting quality attributes architecture known component qualities gains attraction 
component specifies certain quality service provides interfaces component request specific quality service context components calls services environment 
concept component offers quality service component met context naturally leads contract principle meyer pre postconditions 
specify quality service components review term contractual software components section translate meyer design contract principle components 
position extends parameterised contracts predict properties component software architectures position cbse workshop ieee conference lund sweden april summarises results 
classical contracts section generalisation contracts called parameterised contracts dealing prediction functional component properties component quality attributes component context account 
importance component context component properties clear looking quality attributes timing behaviour reliability 
timing behaviour reliability component clearly depends timing behaviour reliability resp 
environmental services component 
addition reliability depends usage profile component 
usage profile clearly fixed part component variable context 

example shows example composite component offers service displaying mails various formats mobile personal 
internally consists handling selection mails connection address book formatting strings delivering mails provides viewers appropriate format actual email possible attachment 
memory limited mobile devices device store viewers formats 
programmer foresee mail attachment formats advance 
servers remote component 
personal manager program mobile device mgr server checks performed classical contracts computations performed parameterised contracts 
configuration mobile viewer considers single component located locally 
rectangles denote components triangle denote interfaces 
components kinds interfaces provides requires interfaces 
describe services offered component services required component services components 
components connected component interfaces form environment component 
example component requires server offers services 
need requires interfaces obvious interoperability substitutability check known literature current component models sun ejb microsoft net contain provides interfaces 
notable exception corba 
microsoft able model requires interfaces pattern 

contractual components software architectures confusion term contractual component comes double meaning term component 
component refers 
usage component run time 
calling services component component 

usage component composition time 
placing component new reuse context happens architecting systems reconfiguring existing systems updating component 
depending case contracts play different role 
defining contracts components briefly review design contract principle point view 
contract client supplier consists obligations client satisfy precondition supplier 
supplier fulfil postcondition precondition met client 
obligations seen benefit party 
client count postcondition precondition fulfilled supplier count precondition 
putting sentence client fulfils precondition supplier supplier fulfil postcondition 
clear component plays role supplier 
formulate contracts components identify pre postconditions user component 
depends case usage run time composition time 
consider component run time 
component run time calling services 
user component components connected provides interface 
precondition kind precondition service likewise postcondition postcondition service 
kind component different method 
authors consider case component service component 
likewise contract fulfilled client supplier method contract described meyer 
component specific kind contracts 
case component usage usage composition time important case talking contractual components 
case architecting systems components deploying components existing systems reconfigurations 
case component acting supplier environment client 
component offers services environment components connected provides interface 
discussion contracts offered services postcondition component postconditions describe client expect working component 
meyers description contracts precondition describes component expects environment components connected requires interface 
precondition met offers services stated postcondition 
precondition component stated requires interfaces 
analogously single sentence formulation contract state user component fulfils components required interface offers right environment component offer services described provided interface 
note checking satisfaction requires interface includes checking contracts required services service contracts specified requires interface sub contracts service contracts stated provides interfaces required components 
notion subcontract described contravariant typing methods contract subcontract contract precondition weaker equal precondition postcondition stronger equal postcondition 
checking correct contractual component example check services specified requires interface included provides interface contracts requires services provided services likewise check binding provides interface 
general state interfaces involved contract checking belong separate components connected bindings 
checking contractual components interoperability checks boolean result 
architecting systems introducing new components check bindings environmental provides interfaces 
replacing component newer check contract bindings requires interfaces components mentioned contracts environmental components bindings provides interfaces ensure replacement existing local contracts broken 
example means replace component check contractual check precondition interoperability check precondition fulfilled checking contractual 
range formalisms specifying pre postconditions defining range interface models components see extensive discussions various models 
leads naturally different kinds contracts components 
degree freedom principle design contract time deployment 
component contracts discussed describe deployment components composition time 
stresses importance contracts statically checkable 
system architected reconfigured aware possibility introducing errors 
direct feedback success introducing replacing component system helpful practice assure absence composition errors 
opposed run time checks show presence composition errors detecting contract violation 
helpful debugging particularly bad reconfiguring existing systems 
case person system triggering error commonly person reconfiguring architecting system 
worse case subsequent reconfigurations finds hard trace back reconfiguration step introduced error 

parameterised contracts daily life component reuse component rarely fits directly new reuse context 
component developer hard foresee possible reuse contexts component advance design time 
severe consequences component oriented programming component developer finds hard provide component configuration possibilities required making component fit reuse contexts 
coming back discussion component contracts means praxis single pre postcondition component sufficient 
precondition component satisfied specific environment component able provide meaningful subset functionality example may fail completely absent different architecture standard text emails display specific attachments 

weaker postcondition component sufficient specific reuse context full functionality component 
due component require functionality requires interface satisfied weaker precondition 
need static pre postconditions parameterised contracts 
case parameterised contract computes postcondition computed dependency strongest precondition guaranteed specific reuse context postcondition parameterised precondition 
case parameterised contract computes precondition dependency postcondition acts parameter precondition 
components means provides requires interfaces fixed provides interface computed dependency actual functionality component receives requires interface requires interface computed dependency functionality requested component specific reuse context 
opposed classical contracts say parameterised contracts link provides requires interface component see fig 

range possible results new interfaces 
interoperability special case component interoperable provides interface change 
interoperability check fails new provides interface computed 

applications parameterised contracts classical contracts parameterised contracts depend actual interface model 
case software developer foresee possible reuse contexts provide bidirectional mapping provides 
corba idl signature list interfaces means provided service list required external services provided component developer 
computing provides interface service included provides interface required services provided component linked 
interfaces describe component protocols specify offered service call sequences required correct execution 
specification task simplified tools algorithms prototypical implementation described 
extra functional properties application parameterised contracts crucial 
example specify timing behaviour software component fixed number 
timing properties component offered provides interface function environment timing behaviour received requires interfaces 
argument holds reliability shown 

context dependent reliability prediction software components parameterised contracts software reliability defined probability software operates user expectations 
reliability anti proportional mtbf mean time failure mean time failure mttf plus mean time repair mttr 
usually assumes constant mttr records statistical testing system monitoring mttf measure software reliability ibm cleanroom approach 
clear reliability opposed relative formal system specification usage profile 
different usage profiles software usually result different reliability values 
determining reliability software component take facts account 

usage profile component part component component context 
component differently different contexts 

component performs calls external services requires interface 
consequently reliability component user depends component code reliability called external services 
reliability software component constant 
reliability component modelled function having parameters usage profile reliability external services 
approach parameterised contract function computing reliability value service parameterised reliability values external contextual services 
concretely parameterised contract includes service provided component markov model parameterised vector external services reliability values 
markov chain analysis yields reliability value service provided component 
second step user compute component reliability markov chain analysis reliability values provided services usage profile component 
result reliability usage profile component step step 
viewer viewer viewer viewer viewer viewer reliability values external services 
markov model service 
step reliability computation component step process shown computing reliability component example system 
step read vector external services cf 
compute service reliability markov chain analysis details 
require service provided markov model specifying probabilities call sequences external services service 
explicit specification model avoided discussed section 
result step reliability value provided service 
sufficient information users 
user wants associate single reliability component second step user compute reliability component markov chain analysis intended usage profile component 

specification parameterised contracts benefit automated analyses success software engineering technique heavily depends minimising costs application 
main cost arise additional specification overhead crucial minimise specification overhead automated generation required specifications 
application technique needs inputs 
reliability values external services 
information gained monitoring predicting model estimating 

parameterised contract 
means provided method markov model describing usage external methods 

step usage profile component 
specifying information accurately may result considerable costs discuss necessity providing information accurately 
test bed validating model running various experiments 
experiments show accuracy markov models predicting reliability 
having accurate inputs prediction worst case measured reliability values cases error 
experiment changed reliability context observed changes measured component reliability cf 

meas 
rel 
scale factor external reliability 
comparing reliability services depending external services reliabilities experiments clearly confirm reliability component heavily depend reliability environment slight changes reliability services provided component context shown axis result large changes reliability offered services especially external services called loops service 
second point list required inputs concerns prediction model markov models provided service uses external methods 
show experiment testbed accuracy markov model predictions varied shown axis 
interested error predictions real reliability measured axis 
show results different contexts 
context homogenous respect reliability reliability different services context quite similar just order magnitude difference details 
opposed context includes reliable services unreliable services encounters calling services intra net services extra net 
expected quite realistic scene webservices different servers 
rel 
difference pred 
meas 
rel 
context difference pred 
meas 
rel 
context scale precision usage profile 
differences predicted measured reliability varied accuracy markov model different contexts external reliability interestingly context accuracy really matters 
knowing real markov model error larger shown axis prediction error axis 
context prediction basically completely independent accuracy input 
explained homogenous context external service similar reliability matter know exactly service called 
accuracy secondary concern yield markov models simply guessing transition probabilities 
example heuristic state outgoing transitions assume knowing better outgoing transition probability 
seen application maximum entropy principle 
input need finite state machine provided component service denoting transitions calls internal external methods 
inline internal method calls 
kind state machine basically control flow graph component service yielded code analysis 
tools generating automata analysing java source code exist approach limited java source code 
point list required input usage profile component needed compute reliability provided services single reliability component 
mentioned service reliability values interest single component reliability value having component usage profile 
partially derived message sequence charts state machine describing valid call sequences provided services 
context interest newer methods bmw web architecture applies finite state machines modelling user inputs 
bottom line information context say reliability component 
software component delivered blackbox information required perform context sensitive prediction component reliability deployment time parameterised contracts derived automatically control flow analysis components code sources binary code 

result discussing contractual usage software components argued requires interfaces preconditions components provides interfaces postconditions 
parameterised contracts linking provides component motivated necessity computing component properties functional extra functional dependence concrete reuse context 
emphasise contracts specifying quality attributes software components fixed forever component vendor 
case component reliability case study clearly demonstrates 
fact component contract parameterised contextual properties deployment time run time context changes run time 
parameterised contract specified component vendor bundled component 
case study shows dealing quality attribute reliability parameterised contract automatically generated control flow analysis code sufficiently accurate 
area includes formal model predicting accuracy model presence inaccurate inputs 
application parameterised contracts performance prediction worthwhile approach expected performance attributes component heavily depend performance attributes concrete component deployment context 

quel plouzeau watkins 
making components contract aware 
computer july 
schmidt stafford 
th icse workshop component software engineering component certification system prediction 
proceedings rd international conference software icse pages los alamitos california may 
ieee computer society 
dyer 
cleanroom approach quality software development 
series software engineering practice 
wiley sons new york ny usa 

von aus java code 
diplomarbeit fakult informatik universit karlsruhe th germany apr 
john musa 
software reliability measurement prediction application 
mcgraw hill new york 
kr mer 
synchronization constraints object interfaces 
kr mer papazoglou editors information systems interoperability pages 
research studies press england 
lind 
bmw web anwendungen 
java spektrum nov dec 
magee dulay eisenbach kramer 
specifying distributed software architectures 
proceedings esec th european software engineering conference volume lecture notes computer science pages spain sept 
springer verlag berlin germany 
meyer 
applying design contract 
ieee computer oct 
meyer 
object oriented software construction 
prentice hall englewood cliffs nj usa edition 

ge zur bei software 
logos verlag berlin 
schmidt 
reliability prediction component software architectures 
journal systems software special issue software architecture engineering quality attributes 
stafford 
predicting feature interactions component systems 
proceedings workshop feature interaction composed systems june 
hern ndez 
object interoperability 
moreira demeyer editors object oriented technology ecoop workshop reader number lncs pages 
springer verlag berlin germany 
wirth 
programming modula 
springer verlag rd edition 

