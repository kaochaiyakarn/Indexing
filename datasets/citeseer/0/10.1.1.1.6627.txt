supporting deliberation behaviour systems andrei mark thesis submitted faculty department computer science partial fulfillment requirements degree master science faculty graduate studies york university april supporting deliberation behaviour systems andrei thesis submitted faculty graduate studies york university partial fulfillment requirements degree master science permission granted library york university lend sell copies thesis national library canada thesis lend sell copies film university microfilms publish thesis 
author reserves publication rights thesis extensive extracts may printed reproduced author written permission 
certificate page iii typed architecture tsotsos proposed solution problem integrating deliberative functionality behaviour framework 
thesis examines simplifying assumptions considers theoretical practical issues related control 
overcomes fundamental flaws concepts behaviour robotics kirsh tsotsos particularly concept explicit representation avoided 
modifies notion world include explicit representations modifies notion behaviour smpa process reads writes world representations 
consequently resort hybrid methodology support deliberation uniform conceptually convenient manner 
formalism thesis demonstrates turing equivalent showing reduction counter turing machine finite set universal behaviours representations 
object oriented software framework developed implementing controllers simplifying assumptions controllers demonstrated 
iv sit lab third floor new computer science building hours minutes remaining submit thesis fgs imposed deadline remember people help get done come painful page document fantastic dedicated examination committee managed come thinking okay 
owe great deal 
document debts 
start john tsotsos thought worthwhile contribute planet took introductory computer vision course term graduate studies take student put lame long personality trait reader surely gleaned passage general coming contents pages 
contributing great wisdom depth knowledge support owe great deal 
committee members michael jenkin franck van spent hours helping sift ideas gave rise thesis owe lot 
faculty helpful especially bil examined nasty uml diagrams chapter provide errata 
owe quite bit 
prominent mention richard paige saw potential help get graduate school despite rough edges undergraduate record 
faculty member believe jin lee saw potential spent hours encouraging pursue graduate studies 
owe great deal 
getting expensive 
described thesis part team effort albert fantastic team player effort great friend mentor 
working day pleasure albert breadth depth knowledge scientific domains domain life vastly enriched experience 
owe albert great deal 
lab mates great pleasure hope mentioning names am confident manage divide debt fair manner 
moral support generously provided fun loving happy folks elder wilcox labs notably kevin mackenzie joseph lily graduate students department computer science numerous mention 
owe substantial bounded amount running assets 
section complete careful mention people life love 
mother father reminded am extraordinary felt overwhelming evidence indicate owe tremendous deal 
sister admiration greatly owe tremendous deal 
vi importantly girlfriend soon wife owe 
love support encouragement past years finishing possible 
waking mornings ensuring eat exercise properly forcing aware deadlines stood side 
sandra dedicate thesis 
conclude owe lots people great deal 
language sufficiently vague legal claims assets resolved document note quite certain life insurance plan cover debt 
ll just patient guess 
vii table contents iv chapter background robot control architectures deliberative reactive decompositions problems functional architectures supporting deliberation vertical reactive architectures behaviour systems deliberation confounding reactivity vice versa deliberation losing behaviours hybrids non hybrid architectures observations conceptual architecture chapter theoretical aspects narrowing conceptual framework example formalism example proof sketch turing equivalence counter turing machine reduction discussion chapter software framework motivation developing software framework framework overview case view structure function functional components initialization operation building behaviour networks constructing behaviours networks code reuse representation granularity viii chapter demonstrations controller demonstrations bug controller comparative evaluation behaviour approaches hybrid approaches non hybrid approaches deliberation versus reactivity problems disadvantages software framework behaviour augmentation behaviour conflict problem common currency problem chapter appendix ix list tables table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
table 
xi list figures brooks functional decomposition brooks 
shakey architecture nilsson 

brooks vertical structures 
components generic behaviour controller tsotsos 
subsumption architecture example brooks 
example spreading activation network 
tradeoff deliberation reactivity arkin aura architecture atlantis architecture planner reactor architecture 
procedural reasoning system 
georgeff lansky 
behaviour primitive behaviour 
behaviour network 
samba example samba architecture smpa cycle behaviour augmentation mechanism example mission specification 
xii behaviour network depicting example controller behaviour network diagram machine 
case diagram generic controller example class diagram representations representation hierarchy example updating representations example representation hierarchy class diagram software architecture sequence diagram describing message passing mechanism sequence diagram describing controller initialisation initializing behaviour envelopes sequence diagram describing behaviour initialisation 
uml sequence diagram depicting happens initiate trigger 
statecharts depicting state changes occurring event trigger behaviour network example 
causality chain connectives visual display virtual reality simulator 
behaviour network diagram bug controller robot navigating red target tracking 
robot reached red target 
robot tracking green target 
robot locates navigates red target 
xiii robot locked position green target robot reaching green target having reached green target robot searches blue target robot tracks blue target robot reached blue target 
behaviour network diagram execution begins robot navigates corner mapping corridor time robot reached goal 
new goal selected 
boundary discovered path 
planner finds path direction 
robot navigates corner robot discovers terrain old path path soon discovered robot navigates new path generic behaviour controller controller reproducing subsumption example cast spreading activation network example 
cast schema example 
realisation selection strategy realisation advising strategy 
xiv realization adaptation strategy example postponement strategy 
behaviour network cast 
samba cast controller 
reactive xv chapter chapter background project part effort implement validate proposal tsotsos 
behaviour architecture intelligent control mobile robots proposed overcome various problems identified approaches 
thesis presents adaptation proposal focus basic building blocks architecture support deliberation discusses role design principles 
chapter introduces 
critical examination past current research supporting deliberation reactivity robot control 
continue detailed description robot control architecture theoretical foundation salient points major contributions claims 
rest thesis presents theoretical practical considerations 
chapter formalisation proof sketch turing equivalence discuss implications proof sketch 
chapter presents software framework controllers implements controller 
structure function framework discussed design justifications application robot control problems considered 
chapter discusses applications software framework robot control problems virtual environment compares various robot control approaches 
problems limitations identified discussed 
thesis concludes overview original contributions summary limitations identified software framework conceptual framework 
directions research discussed 
robot control architectures thesis discusses architectural design control systems robots 
argues processes control robot behaviour organized proposal tsotsos fully realize behavioural capabilities robots 
clear robot useful needs achieve goals respond unknown uncertain environments 
robot able reason environment responsive robot control architectures support requirement 
order discuss issue consider approaches robot control architecture focus inclusion deliberative mechanisms assurance reactivity 
story agent controller design ai community story adoption architectural design principles purpose realizing capabilities 
discussion development computational processes robots discussion architectural design philosophy 
ask question architecture kaelbling considers agent architecture specific collection software hardware modules typically designated boxes arrows indicating data control flow modules 
view architecture general methodology designing particular modular decompositions particular tasks maes view agent architecture restrictive particular methodology building agents 
specifies agent decomposed construction set component modules modules interact 
total set modules interactions provide answer question sensor data current internal state agent determine actions internal state agent 
architecture encompasses techniques algorithms support methodology reflected general definitions specific goal robot control architectures find way endow agents capabilities achieving goals autonomously efficient reliable manner 
done field provide mechanisms doing guiding principles providing 
mechanisms guiding principles constitute methods strategies decomposing robot control problems 
deliberative reactive decompositions problems years general approaches decomposing robot control problems emerged 
decompositions deliberative mechanisms decompositions reactive mechanisms 
deliberative mechanisms computations symbolic abstractions maintained system compared cognitive processes referred cognitive 
characterized rational thinking 
reactive mechanisms computations produce rapid response agent environment stimulus environment thought involve thinking 
research efforts types mechanisms spawned paradigms robot control architecture functional decomposition seen primarily deliberative vertical decomposition seen primarily reactive 
researchers see approaches dichotomous opposite contradictory brooks mataric arkin 
functional decompositions thought impede reactivity vertical decompositions disallow deliberation 
obviously necessary autonomy recognition fact considerable effort research community bridge paradigms 
believe dichotomy false ideas fact orthogonal 
view deliberation reactivity refer different aspects control system 
deliberation characterizes kinds algorithms robot controller understood conceptual point view 
algorithms manipulate logical symbols signals consequently involve decisions inferences reasoning 
reactivity simply characterizes controller performance understood perspective implementation deployment environment 
referred horizontal centralized 
referred behaviour distributed 
necessarily detract practical limitations impede deliberative process reactive 
idea symbol emergence false dichotomy due confusion word symbol means 
common usage symbol denote stands represents denotes exact resemblance vague suggestion accidental conventional relation especially material object representing taken represent immaterial idea quality condition oxford english dictionary ai researchers operate definition symbols physical patterns occur components expression newell simon 
constrain common meaning symbol way constrain symbol may structured 
built physical symbol system concept physical symbol system consists expressions creation modification reproduction destruction processes operate produce new expressions 
forms basis physical symbol system hypothesis holds physical symbol system necessary sufficient means intelligent action newell simon 
hypothesis guiding principle symbolic artificial intelligence study mechanisms rational thinking study deliberative mechanisms 
context symbolic ai known symbol structures 
relations symbols symbol structure correspond physical relationship objects world symbols represent 
church turing thesis implies turing equivalent machine accepts input produces output considered physical symbol system poole 
shall seen chapter appears proponents vertical architectures misunderstand role symbols play reactive systems 
generally hold deliberative mechanisms slow reactive act maintaining symbols inhibits reactivity 
correctly argue classic approaches planning decision making symbolic ai slow problematic robots dynamic unstructured environments incorrectly attribute symbols 
furthermore claim avoid symbols vertical architectures despite fact implemented turing equivalent machines necessarily symbol 
argue chapter falsity deliberation versus reactivity dichotomy emergence paradigms confounded architectural design issue requirement reactivity necessity deliberation 
chapter presents paradigms attempts reconcile problematic view deliberation reactivity view 
section continues examining functional vertical architectures critique known claims comparisons light falsity 
section evaluates critically attempts bridge paradigms 
functional architectures supporting deliberation functional decomposition considered classical top architecture 
approach control process decomposed separate modules processed turn output input 
depicts 
components classical functional decomposition described brooks perception 
gathers information environment 
model 
builds environmental model robot perception environment 
plan 
constructs plan robot 
execute 
selects motion commands generated plan 
motion control 
provides low level control 
sensing action perception model plan execute motor control brooks functional decomposition robot operational software brooks 
brooks referred architecture sense model plan act smpa cycle widely referred 
brooks calls horizontal systems 
stanford cart moravec excellent example system controlled approach 
stanford cart uses smpa controller executing board computer 
cart wheel mobile platform ackermann steering 
sensor monocular camera moved laterally track shaft encoders switches dead reckoning 
sensor actuator signals communicated wirelessly board computer cart 
supplied goal location attain cart moves go fashion meter long navigating cluttered environment vision 
self calibration system proceeds follows 
senses environment visually pictures equidistant points track computing interest points features image finding correlations detected points 
cart applies sensory data model best correlations determine locations dimensions points scene 
affine transform applied locations fit world model occupancy grid 
cart modifies world model perform planning 
point occupancy grid expanded circle having radius minimum steering radius 
modified model re cast graph possible trajectories edges path planning done finding shortest path 
cart translates plan steering motor commands command executed combination dead reckoning model wheel slippage feedback 
tested cart able navigate boxes chairs walls debris fairly indoors moderately outdoors tackling courses meters path planning scheme somewhat successful 
moravec points serious limitations system slowness program mainly due image processing model fitting causing travel top speed meters hour 
error due tire slippage fully compensated vision system performed poorly high contrast conditions 
functional decomposition deliberation strength approach deliberative mechanisms easily integrated 
perceptual module interfaces easily deliberative mechanism providing situational data environment mechanism interfaces easily action modules providing plan action generated 
probably famous example deliberative mechanism manner stanford research institute problem solver strips planner fikes nilsson fikes nilsson 
strips consists stack goals global symbolic representation provides controller situational description environment applies set operators modify representation fulfil goals condition capable doing 
separate perceptual system provides information state world strips strips produces sequence motor commands plan execute module perform 
strips operators represent motor commands defined terms conjuncts predicates situational state world 
operators comprise lists precondition list 
predicates satisfied operator applied 
add list 
predicates asserted global representation result operator application 
delete list 
predicates retracted global representation result operator application 
goals conjuncts predicates satisfied 
current goal stack evaluated situation stored global representation 
satisfied simply popped stack 
satisfied add lists operators satisfy goal operators preconditions pushed goal stack decomposition goal subgoals 
operator top stack transferred list motor commands operator add delete lists update global representation 
strips continues goals stack exhausted point plan sent executor 
disadvantage strips incomplete fail find plan exists sussman anomaly example due fact operators treated linearly order 
sussman anomaly experimentation hacker system sussman allen brown 
strips notable application robot called shakey nilsson mobile platform carrying monocular camera laser rangefinder whisker sensors bumper navigated rooms connected corridor performed box pushing tasks 
depicts shakey architecture 
architecture functionally decomposed lines smpa decomposition 
edge information images conjunction range information construct world model 
strips planner accepts goals determines sequence high level tasks achieve goal 
plan generalizer accepts tasks generates intermediate level actions results path planning routine 
intermediate level actions decomposed servo motor commands overridden event bumpers whiskers detect collision 
landmark development symbolic ai literature strips served basis subsequent distributing deliberation multiple processes 
system sacerdoti uses hierarchical search strategy highly critical goals treated goals lesser criticality tried refining coarse grained plan finely grained plan 
strips system assumes linearity solve sussman anomaly 
noah system sacerdoti overcomes plane space search algorithm detect goal interactions larger search space 
see russell norvig review planners 
shakey architecture nilsson 
state action representation operators strips limited realization situation calculus mccarthy formal calculus describes changes state world exogenous endogenous actions 
situation calculus fully realized systems golog family languages levesque tam 
key attributes strips deemed useful deliberative mechanisms decomposition goals subgoals reliance symbolic representations 
functional decompositions endow robot capability achieving goals 
general impose operational problems 
limitations functional approach number significant disadvantages 
significant disadvantages inability react events sudden changes environment smpa cycle complete change perceived 
considering shakey example suppose change occurs shakey environment strips completes execution generated plan useless 
problem compounded fact architecture imposes module complex handle complex task robot intended perform leading long latency times 
imposing temporal constraints bekey partial solution comes price significantly increased software complexity 
brooks argues second disadvantage modules easily modified isolation rest system 
modifications single component run risk changing interfaces neighbouring components changes may propagate neighbouring components requiring neighbouring components changed 
high coupling functional approaches systems exhibit coupling extent 
interested solving problem general intelligence machines limitations severe 
brooks argued general intelligence requires responsiveness 
argued functional approach accommodate processes sufficiently reactive appear instinctive obviously exist animals evolved highly mobile unstructured dynamic environments 
argued machine fast solve issue moravec remarked reactivity cart limited speed board computer 
shall see issue raises respect coupling refers extent modules interconnected interdependent 
efficient organization computational processes 
section see incorporate notions reactive vertical architectural paradigm 
vertical reactive architectures vertical control paradigm decomposing action behaviour deliberative process similar views animal models intelligence addresses concern instinctive responsiveness 
researchers attempted implement results biology closely possible see mataric example motivated bat navigation choose underlying details 
sensing build maps explore wander avoid obstacle environment action 
brooks decomposition robot operational software vertical structures 
functional systems vertical systems consist set asynchronous concurrent modules directly couple sensors actuators module responsible realizing usually hard coded goal computing candidate actuator commands sensory input 
depicts simple example controller mobile robot platform due brooks modules realize goals range low level high level 
capabilities claimed brooks vertical architecture considered researchers generally hold vertical architectures arkin 
summarized brooks comments multiple goals robots satisfy goals simultaneously safety guarantees processing input communicating executing actions 
goals realized real time 
importance goals depends context environment 
vertical systems goal task oriented modules execute parallel 
modules working high level goals inspect railroad track executed concurrently working low level goals get track train coming 
modules process goals level low level goal just described take precedence high level goal detecting collision train imminent 
view necessarily peculiar vertical systems 
functional architecture support multiple goals compute separate module 
conceivable planner compute multiple goals interleaving computations similar vertical system implemented single processor machine scheduler interleaves goal achieving process 
multiple sensors data retrieval multiple robot sensors rapid done real time 
sensor readings contain error components direct analytic mapping sensor values desired physical values desirable environmental information may hidden readings different sensors 
despite robots able decide suitable actions 
claim vertical systems modules sensor information independently uses different sensors functional system independent modules error propagate module 
algorithms symbolic ai highly sensitive input errors designers choose implement noise error resilient signal processing algorithms 
algorithms execute asynchronously slow cycle time involved processing sensor interfere faster cycle times involved processing sensors case functional decompositions 
view true practice 
module great deal sensor data available compute goal errors sensor potentially affect modules 
consider planner consists multiple strips representations goal 
step planner consists applying operator goal 
robustness event sensors fail robot cope relying remaining available sensors 
similarly robot able behave sensibly event environment changes radically 
vertical system modules independently compute spectrum high low level goals 
case sensor module failure modules may exist compute sensible response robot limiting degradation safety liveness 
modules may take longer compute actions modules system able behave sensibly faster acting modules producing sensible results 
view robustness limited 
modules computing low level goals focus safety modules computing high level goals focus liveness 
robot lost lowest level module unsafe robot lost highest level module useless 
extensibility possible add sensors capabilities robot controller requiring changes rest controller 
easier add new modules vertical system functional system modules loosely coupled 
view significant limitations owing coupling 
small changes module solve particular performance problem introduce new performance problems necessitate changes modules order compensate 
turn examination behaviour systems approach central vertical systems exhibit characteristics 
behaviour systems behaviour systems address problems associated functional systems introducing radical design principles 
ideas radical researchers believe scales human level intelligence 
behaviour behaviour transform arbitrating stimulus behaviour domain ordinating action mechanism behaviour behaviour world components generic behaviour controller tsotsos 
traditional behaviour controller described generically follows 
behaviours mappings sensors actuators execute parallel quickly compute independent responses ordinate compete produce actuator response 
behaviours considered minimal representations tasks constructed minimal knowledge necessary accomplishing specific task 
generic behaviour system depicted easily described expression due arkin vector sensor signals vector behaviours computes independent responses vector weights ordination competition function controller response operation component wise multiplication 
modern behaviour controllers act suite signals generated loosely termed perception systems essentially process sensor signals useful form behaviours 
perception systems external controller task information adapt signal processing way 
consider earliest best known behaviour systems subsumption architecture consider considered exemplar 
subsumption architecture behaviour systems put forth forcefully brooks brooks subsumption architecture 
modern behaviour approaches robot control remains important behaviour approach 
subsumption braitenberg vehicles braitenberg walter walter inspired brooks place 
tolman schematic tolman believed truly behaviour system proposed endo arkin 
subsumption behaviours condition action rules implemented augmented finite state machines hardware state transitions predicated current state state behaviours communicated low bandwidth unidirectional connections 
behaviours organized layers higher layers subsume functioning lower layers 
outputs subsumption behaviours subsumed suppressed replaced signals coming higher layers inputs subsumption behaviours inhibited higher layers 
subsumption proved tremendous departure smpa systems 
brooks architecture innovative principles underlie subsumption radical 
principles follows 
situatedness 
subsumption robot situated surrounded real world operates reality opposed representations reality 
brooks direct influence agent behaviour 
put world best model brooks 

embodiment 
subsumption robot physically world interactions real world faithfully reproduced simulation 
unreasonable try 

intelligence 
subsumption robot observed intelligent brooks appear behave intelligently due fact agent interacts environment 
hold intelligence property agent environment result interplay arkin components brooks :10.1.1.12.1680:10.1.1.18.4669
claim intelligence property agent implies physical symbol system hypothesis ignored 
deliberative mechanisms necessary 

emergence 
intelligent behaviour arises emerges interactions robotic agent environment 
brooks points hard point event place system say external action manifested brooks 
implication idea agent necessarily need maintain concepts intelligent behaviour 
highly provocative ideas behaviour robotics 
subsumption founded idea symbolic computation avoided costs brooks claims avoid symbols altogether 
false states subsumption behaviours constitute symbols state transitions constitute operations symbols particularly partial function states behaviours 
consequently subsumption controllers maintain small amount representation form behaviour state 
back tight situations layer clock explore layer wander go run away avoid objects layer collide forward lost reverse subsumption architecture example brooks 
motors brakes example simple subsumption controller behavioural layers 
controller published brooks implemented toy car 
lowest behaviour layer performs obstacle avoidance signals robot infrared proximity sensors turn away obstacles 
second layer performs exploration absence obstacles signalling robot move forward execute random turns 
top layer enables robot avoid tight situations reversing directions case collision motor signals covered ground period time robot lost 
designers specify controllers behavior language 
language translated target synthesizing routing programmable logic arrays brooks compiled firmware microcontrollers 
schema arkin schema approach behaviours arkin arkin arkin appeared time subsumption appeared 
intellectual descendants ideas behavioural psychology due arbib khatib 
architecture behaviour accepts output perceptual algorithms relevant task computes action vector subsequently combined vector summation produce candidate output 
behaviour outputs perceptual algorithms combined perceptual algorithms required behaviour 
depicts 
depicts sample vector field encoding direction travel position world output behaviours vector fields termed schema 
outputs weighted combined gradient descent method applied resulting vector field perform navigation 
processes execute independently asynchronously short cycle time 
schema approach successfully applied wide variety problems including behaviour docking foraging control mobile manipulators 
advantages include fact computation distributed completely behaviours behaviours completely reorganized controller run time highly modular maintained library reused 
arkin reports significant limitation 
generic nature behaviours allows reusable difficult design components optimal particular domain schema tuned easily 
rs relationships perception action schema 
sample schema 
unrelated arkin schema robot schema rs architecture developed lyons arbib lyons arbib method expressing distributed sensor driver flexible plans manipulation robot 
schema simple processes 
communicate communication ports composed 
claim plan tunes robot behaviour suit environment 
rs includes formally defined process composition algebra describes composition simple reactive parameterised processes execute parallel sequentially recursively condition completion processes 
process composition algebra described 
symbols processes free variables port port mapping 
indicate port port mapping processes write indicate process stores result write indicate process parameter variable symbol occurring expression describes uses value stored parameter write composition rules follows pj 
concurrent composition 
behaves parallel connected port port mapping operator idempotent 
processes identical robot automated manufacturing assembly lines factories 
concurrent identically parameterized connected instances schema 

sequential composition 
behaves process followed process 
conditional composition 
qj behaves process terminates 
aborts aborts 
completes computation produced stored parameter behaves value parameter 
disabling composition 
behaves concurrent composition terminates point aborted 

synchronous recurrent composition 
qj behaves process executes stores result conditionally followed value parameter conditionally followed 
asynchronous recurrent composition 
qj 
behaves process executes stores result conditionally followed value parameter concurrently set atomic processes individual perception action mappings constructed 
process computes result sensory input process computes response parameter qj mapping 
strong advantage system reactive layer defined formally plans verified analytically 
execution plan flexible sense robot take different branches plan depending situation hand plan change due situation limiting flexibility certain extent 
rs functions domain workspaces high degree structure hard code assumptions environment controller 
unsuitable mobile robots expected behave sensibly highly unstructured environments 
disadvantage implementations allow generalization reuse schemas multiple tasks 
spreading activation networks maes developed agent architecture supports goal directed behaviour distributed manner maintaining explicit goal representation operator explicitly specify agent goals 
controller consists set competence modules maes essentially behaviours 
controller designer specifies module defining preconditions postconditions resemble strips operators add list delete list condition list activation level indicates model relevance situation 
probability module influence behaviour agent depends activation level 
module executes preconditions true 
competence modules organized spreading activation network modules linked manner modules having preconditions add list modules connected successor links modules connected predecessor links opposite direction modules having preconditions delete list modules get link 
agent executing various modules may active situations may executed activation exceeds module activation level 
happens executing modules follow successor links add terms add list condition module modules follow links inhibit modules removing terms condition list module 
result execution may command effector unit increase activation level successor module term activation spreading 
operators specify goals adding term satisfy module preconditions 
network experiences goal directed behaviour modules suitable achieving goal active spread activation modules require goal achieved order proceed undoing action achieved 
depicts general spreading activation network 
depicts add delete lists preconditions behaviours 
maes applied approach block stacking problem described earlier strips 
implementation performed excessive replanning controller dynamics described natural fluid contrast controllers classical approaches planning 
amount traded reactivity varying activation thresholds 
system maintain history past actions loops occasionally emerge action selection maes arguing need history questionable rely world changing overcome impasse network 
maes points unclear select values global parameters produce behaviour desirable solving specific control problem 
architectural point view maes approach combines aesthetics pure behaviours goal orientedness deliberative systems provide somewhat satisfactory mechanism control 
condition condition condition condition module module module module sense act sense act sense act sense act example spreading activation network 
brooks credited idea really tolman proposed high level factors motivation cognition purpose woven view autonomous activity 
endo arkin point tolman purposive spoke concerns addressed modern behaviour systems parallel sensorimotor pathways ordinated give situated agent sensible behaviour introduce goal oriented behaviour 
walter walter demonstrated behaviour principles application principles cybernetics developed norbert weiner robot consisting motors displacing rotating sensors detecting light front collisions controller capable exhibiting sophisticated behaviours 
explored environment weak light source 
follow weak light back away light bright 
override light response turn away obstacles 
interestingly recharge recharging station single light approach battery weak light source appeared weak 
battery fully charged light appear bright repel 
braitenberg proposed class machines braitenberg modelled walter approach realized behavioural attributed characterized aggression love hunger fear 

behaviour architectures abound excellent review see arkin behaviours implicit representations behaviour approaches subsumption maintain explicit symbolic representations environment abound implicit symbolic representation 
implicit representation subsumption demonstrated mataric mataric map building robot toto 
concept distribute representation behaviours central concept subsumption behaviours maintain state representation considered exist aggregate behaviour states 
aggregate states maintains pair wise connections representations 
toto able construct spatial map boundaries world denoted unique landmarks reach user defined goal specified selecting goal landmark 
addition sonars compass landmark detector sensors 
constructed map form graph map behaviour represents landmark message wire represents topological relationship states map behaviours represent landmark 
toto explore environment finding obstacle execute boundary behaviour 
landmarks detected map behaviours construct graph actual landmarks methods similar spreading activation 
mechanism perform path planning navigating goal landmark computing minimum spanning trees 
disadvantage number behaviours system maintain representations increased logarithmically possible number representation states needed grows 
number pair wise connections increases bound maintaining state representation prohibitively difficult 
approaches maintain implicit representations arkin schema controllers 
vector fields produced behaviours represents actions taken configuration robot pose 
maes spreading activation networks rs implicitly encode representations plans 
activation networks representations analogous strips 
rs composition processes represents plan 
limitations key limitations behaviour systems limit utility lack support deliberative mechanisms lack explicit representation 
deliberation behaviour systems capable small degree deliberation support deliberative mechanisms require extensive world knowledge hierarchical planners 
limits capabilities behaviour robots 
deliberative systems permit representational knowledge planning purposes advance execution 
example reactive controllers learn environment explore world efficiently 
importantly behaviours adapted suit missions environments augmenting robot capabilities analogous deliberate conscious control behaviour animals 
process efficient priori world knowledge 
representation 
benefits deliberation realized inclusion explicit representation seen distributed implicit representations behaviour systems sufficient purposes 
design goal build systems capabilities approaching humans lack explicit representation forces scale behaviour solution grow bounds 
absence conceptual representation limits range capabilities control approach 
scaling problem champions behaviour paradigm claim capable achieving holy grail ai general purpose human level intelligence equivalence brooks 
claim behaviour systems scale problems solvable human beings solved system model human intelligence 
goal robotics research achieve human intelligence situated agent behaviour paradigm fundamentally flawed 
tsotsos showed tsotsos claim wrong follows 
view claim behaviour system scales human level intelligence meaning behaviour system accept samples stimuli human beings computing resources suffice solving problems size system compute solution quickly accurately human 
intelligent robots vision undoubtedly useful sensors 
central task visual perception visual search simplest form problem determining target image 
explicit knowledge target guide search process way problem np complete tsotsos tsotsos conversely target knowledge search time linear size image 
fact visual search problem humans target knowledge brain small deal visual stimulus render task impossible 
humans clearly perform task case attention mechanism required task knowledge 
behaviour approach supposed maintain explicit representations knowledge possibly perform visual search way human produce results 
furthermore tsotsos showed allow explicit representations stimuli trigger behaviours considered size input data number possible responses explosion number behaviours required give responses possible stimuli possible variations stimulus due lighting colour viewpoint context responses stimulus different different contexts 
concludes arguing explicit representations targets goals behaviour controller paradigm fast useful structure behaviour architecture processing hierarchical little doubt brain hierarchical processing level providing input data driven knowledge driven directions despite dogma explicit intermediate representations processes useful notes brain intermediate representations ginsberg arguments similar tsotsos 
claims size vertical system grows exponentially complexity domain 
advanced position concluding strict position value provoking ai community reconsider deliberative approach building intelligent robots taken list requirements reactive architectures dickinson developed system take advantage results 
includes robot vision system achieves complex object recognition 
system uses layers behaviours performing planning object recognition respectively 
organized hierarchical behaviour architecture internal representations behaviours read write triggered internal representations 
respects system considered early implementation 
lacks formal setting ideas applied single domain 
clearer chapter 
need conceptual representation kirsh argued brooks idea intelligent behaviour concept free 
concepts necessary certain types perception learning control processes computationally simpler kirsh concepts represent binding commonalities objects classes 
required perception action control learning 
determined activity successful environment contains sufficient number perceptible cues 
action determined planning problem solving hypothesis testing require concepts 
concepts necessary communicating understanding learning agents world 
case perception especially visual perception conceptual information required perform recognition contains invariant information useful recognizing objects perspective different illumination conditions 
concepts best done maintain indexed database shapes perspective searched exhaustively 
concepts enable attention 
knowledge world acquired perceptual processes reasoning classes 
case control concepts necessary reasoning discarding goals weigh competing costs benefits acting goal 
controllers execute goal hand intelligence remain insect 
multiplied kirsh put creature concepts capacities vastly deliberation confounding reactivity vice versa emerged done paradigms notion control techniques comprise spectrum deliberation reactivity purely deliberative systems purely reactive systems systems reactivity having deliberative mechanisms middle 
modify system increasingly depend symbols explicit representations system position spectrum shifts leftward 
purely symbolic reflexive representation dependent slow response cognitive intelligence variable latency predictive capability speed response model dependence representation free real time response low level intelligence primitive computations tradeoff deliberation reactivity arkin depiction spectrum arkin 
authors observed tradeoffs just described occur deliberation introduced reactive system vice versa 
move right spectrum predictive capabilities system reduced dependence accurate world knowledge gains responsiveness environment 
truly rigorous explanation trade researchers nature boundary deliberation reactive execution understood time arkin 
intuitively understand absence deliberative mechanisms operating explicit representations fewer sequential computations systems reactive 
sequential computation sped point parallelizing 
explanations weak 
consider nature deliberation precludes deliberative computation fast 
gat argues trade due searching bigger search space longer takes compute result 
necessarily exclude sub optimal searches tend substantially smaller search spaces 
argument search unsatisfactory 
view source trade due processes interact system 
depends tightness connections sensors actuators manner difficult lengthy computations handled system 
computers symbol systems essentially perform deliberation level consider lengthy computations deliberative shorter computations 
chapter explains fully presenting terms manner behaviours interact 
section consider role knowledge representation reactive robot control systems support deliberation 
deliberation losing behaviours reconcile limitations described section advantage benefits behaviour systems necessary integrate deliberative processing system performs reactive control 
approaches put forward 
class approaches views problem terms integrating functional systems vertical systems 
termed hybrid architectures hybrid approaches 
approaches notion deliberation reactivity necessarily constitute separate computational components general layers needed minimum represent deliberation reactivity 
common approach involves introducing explicit third layer concerned coordinating components arkin argue false notion imposes unnecessary limitations architectures 
approaches put forward involve behaviours way explicit representation task information maintain implicit representations 
non hybrids 
approaches classes class hybrids class hybrids hybrid approach dominates autonomous robots today 
hybrid architectures seek reconcile requirement planning requirement reactivity attempting merge best worlds world functional paradigm world vertical paradigm 
product integrating deliberative reactive systems validated 
clearly design approach highly pragmatic accounts popularity 
examine hybrid approach carefully 
advocated arkin arkin approach essentially mate deliberative control system reactive control system manner 
fundamental insight behaviour systems need planning order achieve truly purposive functionality 
fundamental technique deliberative component ordinates configures behaviour component purposive functional behaviour 
fundamental attribute deliberative systems provide explicit knowledge representation 
wide variety approaches appeared control literature idea approach bridging gap deliberation reactivity 
section explore number best hybrid systems referred layer architectures top layer deliberative bottom layer reactive middle layer mediates responsible task execution monitoring gat 
known hybrid approaches viewing critical eye focused earlier discussion deliberation versus reactivity problems arise 
generally believed hybrid systems capable deliberative reasoning behaviour execution needed realize full potential behaviour systems systems function way safely realize goals unknown environment 
arkin advocate hybrid approach control 
framework autonomous robot architecture aura draws legacy hierarchical systems schema control 
deliberative hierarchical planner consisting mission planning module spatial reasoning module plan sequencing module instantiate appropriate schemas satisfy human high level commands 
modules individually replaceable intention render simple task engineering component integrating treating closed system clearly indispensable practice engineering robotic systems desire scalable flexible 
deliberative deliberative component component reactive reactive component component mission planner spatial reasoner plan sequencer schema controller motor perceptual actuators sensors aura architecture describes architecture 
consists deliberative component reactive component 
reactive component consists schema controller perception module interfaces sensors motor module interfaces actuators 
deliberative component consists mission planner human interface spatial reasoner plan sequencer interact internal representations shown module receives information reactive component perceptual module 
sitting highest level deliberative component mission planner receives command human interface specifies position map represents system current goal 
level deliberation sits spatial reasoner performs navigation achieve goal path planning algorithm cartographic map specify discrete path followed 
beneath path sequencer translates discrete step path set motor schema rule system subsequently re implemented finite state sequencer 
schema manager incorporates motor schema final system response including linear combination schemas including ones enabling collision avoidance described section 
deliberative system suspended failure detected 
occurs motors stalled timeout occurs 
occurs level hierarchical control activated bottom failure overcome 
aura applied wide variety domains including manufacturing environments aerial navigation indoor outdoor navigation unmanned ground vehicles ugv war game scenarios nuclear waste inspection multiagent systems 
aura placed aaai mobile robot competitions 
accounts aura performance results spectacular 
agents able develop execute plans fulfill goals reacting dynamic unstructured environment 
unexpected behaviour caused problems perception case trash collecting task regions tables mistaken black 
key disadvantage aura modules tightly coupled making extendible 
example swap planning algorithm significantly impacting interface deliberative module reactive module 
perception ancillary concern perceptual modules appear considered external aura 
consequence aura take advantage task information render perceptual processing efficient 
arkin identifies principal strategies described literature interfacing deliberative components reactive components 
core property planner recast strategy generator 
strategies 
selection strategy 
deliberative component selects behaviours behaviour parameters suitable realizing plan 
planning cast system configuration selection 
deliberative component may replan event failure 
aura example 

advising strategy 
similar selection strategy deliberative component selects behaviour parameters reactive component may elect 
arkin words plans offer courses actions reactive agent determines advisable planning cast advice giving 

adaptation strategy 
deliberative component modifies reactive component response changing environment conditions task 
planning cast strategy adaptation 

postponement strategy 
deliberative component defers deciding actions absolutely necessary light sort situation reactive controller 
way generated plan reflects available sensor data suited recovering situation caused plan generated 
planner lazy planning cast commitment process 
arkin uses terms planning deliberation interchangeably views strategies strictly terms interfacing deliberation reactivity 
planning kind deliberation 
fact symbolic computation deliberation domain perception possibly parts action 
arkin concept deliberation planners symbolic ai 
bear mind interface strategies really versions approach deliberative layer reconfigures ordinates reactive layer 
case arkin schema approach hybrid approaches involve adding deliberative module existing reactive system 
consequence authors see deliberation necessarily planning automated reconfiguration reactive systems necessarily result planning process 
seen example selection strategy 
follows examples strategies 
atlantis advising strategy jet propulsion laboratory jpl gat gat developed layer hybrid system called atlantis part nasa ongoing research effort develop control technology mars exploration rover program 
deliberation interacts reactive layer atlantis advising strategy 
sensors deliberative sequencing control atlantis architecture actuators atlantis incorporates modules organized hierarchically layer 
depicts 
layer control module manages collection primitive activities accepts sensor signals controls actuators 
second layer sequencer activates terminates reactive module actions complete task responds failures reactive module 
third layer performs planning maintains world model provides tasks sequencer complete 
module functions asynchronously 
module implemented differently rest architecture said heterogenous 
aura described layers atlantis function independently exert control lower layers 
deliberative processing expresses intent reactive system 
layer communicates adjacent layers 
reactive module receives requests sequencer activate particular activity responds sequencer status information 
entire layer implemented lisp programming language called alfa gat program reactive components configured networks connected communication channels 
sequencer decomposes specified task subtasks determines selection ordering activities required complete subtasks generates activation termination requests reactive module carry 
performs failure detection monitoring execution status reactive module order determine particular activity result completion subtask 
failure occurs sequencer try new task decomposition 
task decomposition done help system consisting ai planning algorithms implemented lisp 
accepts requests sequencing layer replan task 
sequencer may necessarily adopt planner output 
sequencer modeled firby reactive action packages rap approach deciding set suitable actions contend situation firby 
rap variant situated activity approach control robot actions predicated situations finds 
sequencer possible situation indexed unique index possible task specify plan 
index mapped set possible actions action sequence subtasks 
task sequencer selects subtask sequence causes reactive module execute 
subtask sequence fails sequencer selects subtask sequence 
rap sequencer vertical system task 
rap relies heavily strong explicit internal world model possible situations actions 
atlantis applied aaai mobile robot competition jpl rocky planetary rover testbed 
results atlantis spectacular 
gat won aaai competition robot alfred 
event required robot explore mock office escape robot succeeded twelve twelve tries capable escaping playing arena 
rocky rover able perform local navigation martian terrain mock vision main sensor 
applied sojourner mission success known 
despite tremendous success atlantis may limitations 
clear extendible due high degree cohesion modules comprise 
vision system module exists outside system task knowledge perceptual processes efficient 
appears sequencer purely reactive component 
thought perform deliberation returns solution situation return different solution detects required 
sequencer incorporates deliberative processing 
new view sequencer appears acceptable think reactive components having deliberation interface deliberation reactivity blurred 
important contribution fault detection capability atlantis 
gat gat introduced notion cognizant failure 
robot capable recognizing failure occurred say complete task atlantis detects cognizant failures dedicated monitor routines simple processes raise interrupt detects things going 
example monitor routine simple watchdog timer raise interrupt task fails complete time 
monitor routines task specific checking alignment conditions performing wall task 
interesting contribution atlantis designed bottom designer constructs low level activities 
designer constructs sequences activities suitable various tasks 
designer develops deliberative methods assist sequencer decision making 
deliberative component grounded reactive layer similar subsumption layers evolved lower layers 
planner reactor architecture pr adaptation strategy planner reactor architecture pr proposed lyons hendriks lyons hendriks integrates deliberative component planner reactive component reactor maintains controller model called robot schema rs lyons arbib 
underlying philosophy planner guarantee reactor behaviour constantly improves adaptation strategy done anytime planner 
anytime planner line algorithm provide best possible solution time request provides solutions strictly increase optimality time 
depicts architecture 
sensors planner reactor rs planner reactor architecture 
actuators approach planner uses anytime planner continually reconfigures reactive component necessary 
situation agent goals change example human operator may direct controller switch suddenly new mission mission planner generate rs configuration suitable realizing new goal 
situation fact pr architecture maintains list assumptions robot operating environment planner determines assumptions invalid reconfigure reactor ensure safety robot 
example assumption moving obstacles environment 
assumption need hypothetical avoid obstacle schema active 
assumption planner maintains process monitors environment ensure truth assumption 
detects violated planner removes assumption list suspends assumption monitoring process signals reactor activate avoid obstacle schema 
process referred adaptation 
planner apply recursively re adapt reactor adapted 
approach seen successful application task laboratory environment 
approach generate complete plans complete snapshots world time adapts existing plan pr successful reacting uncertainty environment due variable arrival rates poses defects incoming parts delays downstream automation problems availability substitutability resources 
authors stated see planner producing appropriate behaviour way reactor interacts world 
limitations due limitations rs particular rs intended largely structured environment 
consequence unclear pr react unstructured environments planetary exploration 
limitations rs apply 
arkin observes planner uses adaptation strategy interface reactor planner uses adaptation process ensure reactor undergoes dependent online performance improvement reactor purely reactive 
mentioned earlier section see rs model purely reactive contains deliberative elements monitor completion processes 
planner strictly deliberative 
clearly includes processes react changes environment 
fact change detected planner triggered action reactive manner 
deliberative layer reactive properties reactive layer includes deliberative processing 
restrictive assume deliberation domain top layer reactivity bottom layer layers suffice 
procedural reasoning system prs commitment georgeff lansky approach problem combining deliberation reactivity differently hybrid approaches procedural reasoning system prs georgeff lansky 
reactivity different role prs systems controlled deliberative component controls particular tightly couple perception action tightly couples perception planning 
coupling perception planning founded view planning type commitment strategy interfacing deliberation reactivity arkin 
idea approach robot considered rational agent endowed psychological attitudes belief desire intention 
agent consists system database goals knowledge areas system interpreter 
system database maintains beliefs set state descriptions describing believe true agent environment point time 
goals represent desired behaviours system states agent achieve 
knowledge area ka describes sequence subgoals achieve fulfill goal includes invocation condition precondition 
system interpreter runs entire system applies ka existing goals achieve subgoals translates primitive goals actions performed 
invoked new perceptual information changes beliefs plans updated needed reactive manner 
fact robot alters plans fly light changes perceived state environment follows system deliberative reactive reactivity depends speed deliberative mechanisms 
procedural reasoning system 
georgeff lansky 
commitment strategy operates assumption information necessary correct decision available time comes 
benefit approach deliberative system attentive changes various representations maintains compute result reasonably quickly 
prs action closely follows plan continually reformulated reaction agent current situation see 
plans specifications desired robot behaviour formulated explicit representations beliefs desires existing plans intentions 
explicit representations get changed plan automatically gets regenerated 
approach applied sri robot navigation unmanned ground vehicles ugv 
able perform tasks simulated space station environment plan path target room navigate obstacles hallways react emergencies real time 
ugv able perform reconnaissance tasks war game scenarios 
disadvantage approach ka tend incorporate assumptions environment 
architecture intended specific applications architecture flexible 
controller capabilities augmented adding knowledge areas enhancing perceptual modules system support radical changes 
providing additional functionality necessarily increase signal path decreasing system reactivity 
hybrid systems view problem supporting deliberation reactivity integrating disparate systems conceptual error nature deliberation reactivity impose unnecessary limitations controllers 
hybrid system designers necessarily view deliberation strictly happens planner realize deliberation may occur reactive layer 
deliberation reactivity necessarily constitute separate systems thinking restrictive architectural point view 
layering progressively deliberative modules ground useful strategy integrating task oriented modules hardware platform oriented modules 
adopt designing controllers 
perceptual systems outside hybrid system 
useful want task information deliberative system influence perceptual system necessary performing tasks 
hybrid approaches appear support deliberation reactivity ad hoc fashion constitute grand unified theories control manner functional behaviour architectures 
approaches attempt support deliberation reactivity uniform manner shall see 
non hybrid architectures subsection approaches integrating deliberation reactivity resort hybrid approach 
hierarchical behaviour architecture mataric developed unified approach supporting deliberation reactivity realized hierarchical behaviour architecture mataric 
motivating principle behaviour systems maintain representations maintain state mataric showed mataric see section 
approach depicted behaviours called primitive behaviours accept parameters execute atomic tasks pickup pick orange box gripper track human cause robot position cm away human located rightwards current heading simple tasks localize goto location 
seemingly high level behaviours fairly standard behaviour systems may may depend external components perform perception 
atomic tasks may may carried external components 
behaviour computes response achieve goal long active 
possible behaviours produce effects conflicting situation called destructive competition 
situation instruct inhibited 
perception perception action effects behaviours preconditions inhibit activation test task specific preconditions test world preconditions continue active perception action mapping effects behaviour behaviours pure behaviour behaviour primitive behaviour 
primitive behaviour paired concurrent process called behaviour ab activate inhibit depending activation inhibition state behaviours system 
behaviour signal corresponding primitive behaviour activate primitive behaviour signal corresponding behaviour completed task needs continue 
done port arbitrated behaviour paradigm behaviours input ports listen messages corresponding primitive behaviour output ports continually send messages primitive behaviour 
behaviours connected ports represent conditions behaviour execution requests activation inhibition behaviours notification task completion 
graphs connected behaviours referred behaviour networks 
represent hierarchical decomposition tasks network behaviours place primitive behaviours 
way correspond entire behaviour networks behaviours 
networks deliberation realized see 
door goto place door door door behaviour network 
activation state primitive behaviour behaviour network corresponds activation state behaviour depends satisfaction precondition preconditions state world system task 
detected input ports predicated signals behaviours send signals output ports external components 
behaviours perceptual information state world determine effect actions world representation effects send signal behaviours 
descriptions input ports corresponding effects activation state behaviour follow behaviour 
binary number indicating current behaviour enabled current network controller 
activation occur 
activation level 
natural number indicating activation level behaviour simply sum binary valued activation messages received behaviours 
greater zero activation occur 
inhibit 
binary number indicating exists behaviour sent inhibition signal 
zero activation occur 
sensory input 
set signals sensors perceptual processes behaviour uses perceive state environment compute effects signals 
play role satisfying preconditions activation described 
situations 
set boolean inputs carrying effects signals behaviours may active past may currently active 
examples signals unknown true indicate robot know room true indicate robot detected door world open home false mean robot home location 
effects signals effectively describe situation world system 
values play role satisfying preconditions activation 
mataric call preconditions kinds condition 
formulas sensory input express preconditions activation 
kinds preconditions world preconditions 
preconditions situation world activation occur 
example behaviour called precondition agent positioned front closed door 
represented formula door dooropen 
sequential preconditions 
task dependent conditions met activation occur express temporal conditions sequences execution 
preconditions formulas constructed effects signals meant express system states behaviour ought active 
example suppose behaviour picks box world grippers operate properly box currently 
execute value false 
sequential precondition formula 
activation preconditions give rise deliberation causing sequences behaviour activations occur 
world situation subset available behaviours active producing sort useful emergent functionality 
continue actions active behaviours cause world change significantly new situation emerges causing subset necessarily disjoint previous subset behaviours active 
sequences situational causality seen execution kinds preconditions give rise kinds execution sequential execution specified sequential preconditions opportunistic execution specified world preconditions 
sequential execution new subset available behaviours activates effects produced subset currently active satisfy sequential preconditions 
time old subset inactive 
opportunistic execution new subset available behaviours activates strictly world situation satisfies world preconditions 
opportunistic execution give rise situation sequential execution occur sequential execution give rise situation opportunistic execution occur 
functionality gives credence mataric claim hierarchical behaviour network architecture gives rise strips deliberation behaviours behave operators 
architecture successful realization unified approach supporting deliberation behaviour system 
resort implementing deliberation reactivity separate components need integrated 
distributes deliberative processing behaviours aggregation states corresponds representation 
furthermore formidable intellectual descendent recognized results field 
start builds legacy deliberation fikes nilsson strips architecture fikes nilsson mataric supporting representation distributing behaviour states mataric maes activation spreading technique maes maes enable multiple roles support goal directed behaviours 
known techniques 
addition lesser known results 
technique hierarchically organizing behaviour networks follows similar technique schemas lyons arbib robot schema architecture lyons arbib 
technique ports communication behaviours developed distributed control systems extension programming language called 
approach applied problems 
move box room door separated rooms 
controller included behaviours shown example robot successful opening door pushing box room 
recognized get room door closed 
recognized door closed needed opened 
opening door recognized door open box pushed fulfil goal 
pushing box room recognized goal complete 
learning behaviours developed construct behaviour networks observing effects actions agents environment 
action produces effect matches behaviours adds matching behaviour network behaviours networked process able execute sequence 
learning process stops learning behaviour detects goal reached 
behaviour network executed 
applied problem learning obstacles goal position target position problem learning simple tasks observing humans demonstrate task 
situation robot communicates humans needs taught task 
limitation approach deliberation restricted capabilities equivalent strips 
expressiveness plans limited order logic 
limitation approach suffers scaling problem 
mataric approach unique respect usage perception 
functioning perceptual processes depend architecture representation task driven 
behaviours execute specific tasks dependent put world position enable 
behaviour senses directly environment order produce response share perceptual information producing response 
share situational representation world performing deliberation possible feature world represented behaviour needed 
fact architecture task executed twice execution sequence instances behaviour 
persuasive argument representation realizable aggregating states behaviours take account number behaviours bounded impractical implement large scale 
deliberation completely supported architecture 
decision making happens situations arise decision making done actions architecture perform planning way 
preconditions realize execution sequence tasks view planning act determining preconditions plan set preconditions assigned behaviours 
preconditions established priori execution 
planning happens outside architecture 
mataric includes study automatic generation activation conditions 
currently developing system automatically generate preconditions general purpose planner 
view planner architecture system currently hybrid architecture 
planning viewed hierarchical centralized high level planning generates courses action different world situations distributed low level planning executes plan current world situation 
samba response tsotsos identification scaling problem proposed solution maintains internal representations enable visual perception 
approach hybrid approaches system components completely heterogeneous 
primitive reactions continuously reproduced objects environment attended 
reactions represented action maps 
tasks executed modifying combining action maps 
higher layer reason determined sensor data 
behaviours compute responses sensor data continuously updated robot actions function environment state 
key abstraction samba marker markers serve decompose control system ways vertically producers consumers sensor data horizontally high level task oriented processes low level platform hardware oriented processes 
markers indices features processing elements associate perceivable environment features task related data 
markers serve purposes take care processing uses task information allow behaviours implemented simply having handle task information serve decrease number bandwidth interconnections modules control system interestingly focus attention behaviours inputs relevant task hand constraining situations behaviours operate 
mobile space markers special type marker changed fly index new feature foci attention shifted 
samba 
task layer structured similarly subsystem output sets state goal markers denoted goal module example samba reactive layer depicted 
component modules sensors actuators markers behaviours arbiters 
object markers task information separate task layer module sensor signals compute signals representations percept objects 
behaviours defined primitive reactions objects go object avoid object 
responses form action maps ordinate action map represents particular action representing action translate distance direction ordinate contains value represents fitting particular action achieving desired task map applied ordinate weight 
arbiter selects action maps relevant task hand 
generates new map weight stored location maximum absolute value 
simply maximum absolute values weights location action maps arbiter selected 
task layer module fact sort system 
behaviours perform task oriented deliberative processing compute results directly markers 
example approach applied controlling mobile robot stereo active vision 
modules shown buffers simply networks markers 
task layer comprised task behaviors task arbiters task markers contained mobile space buffer produces tasks robot gaze behaviors 
robot behaviors control mobile base gaze behaviors stereo gaze platform 
study adding task specific extensions behaviour systems necessarily impede reactivity 
reported approach satisfactorily deal error sensory input outside focus attention input mobile space marker index 
relaxing accuracy requirements particular designing controllers behaviours depend sensor information foci attention information tends sufficiently accurate task limitation insignificant 
focus samba developing robots play soccer representations took form dimensional surfaces plane represented soccer playing field images axis represented degree position goal contained salient feature relevant task 
samba control multi agent system played soccer robocup robocup competitions held aaai 
group placed eighth seventh 
architecture tested simulated environment real robots 
agents exhibited soccer playing skills dribbling passing blocking intercepting moving net attempting score binocular vision primary sensor 
observed able incorporate task information perform attentive processing reducing reactivity system compared samba behaviours similar computations input markers employ task information 
lengthening signal path sensors actuators increasing amount computation storing data decrease reactivity system 
computations samba involved dimensional maps significant differences task dependent processing task independent processing 
system able produce sensible action actions combined say vector summation method guarantee sensible action arbitrated 
behaviour arbitration dynamic opposed static subsumption selected action suitable situation 
example samba architecture task layer implemented samba behaviours writes markers 
limitation system may representations homogenous samba allow logical representation 
components samba communicate common currency markers computed data format output accepted format input behaviours input output 
investigation integrating heterogeneous representation formats say graphs quad trees 
difficult accept claim general samba incorporate task directed processing significantly reducing reactivity heterogeneous formats may significant increase amount computations required order perform transformations formats decreasing reactivity 
investigation supporting logical representation symbol oriented computation consequence samba support forms deliberative processing 
observations noted non hybrid approaches recognize deliberation reactivity necessarily constitute separate modules 
deliberation type processing say system module deliberative say includes symbol oriented computing sort 
reactivity property system module say reactive say performs action environment rapid response stimulus 
note notion reactivity implies correctness appropriateness system response 
merely implies response fast 
notion deliberation encompass correctness appropriateness deliberative mechanisms aware task hand purely reactive systems 
control architecture embrace deliberative processing limit tradeoff reactivity possible 
architecture conceptually simple constructed uniform components 
hybrid architectures incorporate benefits functional vertical systems rigidity inherent deliberation reactivity decomposition hybrid systems 
enable forms representation concepts task oriented perception 
section presents architecture 
conceptual architecture architecture proposed described tsotsos seeks reconcile successful vertical approaches scaling problem reap benefits functional systems 
conceptual approach building controllers attention goal directed processing enabled view supporting efficient active attentive machine vision primary perceptual mechanism 
addition control architecture language mission plan specification defined permitting integration deliberative reactive specifications proof procedure sketched determine particular behaviour set violates timing feasibility constraints specific mission 
unique method determining particular behaviour collection satisfy mission described 
research seeks realize aspects conceptual framework describes architecture philosophical perspective software framework includes structures mechanisms realizing 
central conceptual framework view world controller consists external environment consists internal data explicit intermediate representation fact world consists representations data structures related semantics represent external sensors robot spatial world knowledge object knowledge perceptual task knowledge behavioural knowledge ego knowledge intentional knowledge 
concept behaviour redefined perform planning explicit representations order behaviour functional system smpa process triggered change seen event window world 
behaviour response change state subset world action window 
behaviour gets triggered operation daemon monitors representations sees event window 
way unified framework perform deliberative processing retain benefits traditional behaviour control particular reactivity 
addition possible processing component behaviour sense model plan act components execute parallel behaviour performs related function responses processes ordinated produce final result 
mechanism called behaviour augmentation 
behaviours connected sets representations way action behaviour trigger behaviour respond 
architecture viewed directed graph trigger called behaviour network 
smpa concept part definition noted means decompose individual behaviours component parts 
partition robot functions centralized strategy 
note daemon check input valid contains errors input event window representations relevant concern behaviour coupled 
usual approach achieving real time performance robotics avoid minimize role vision sensors visual analysis order realize real time operation 
claimed tsotsos attentive goal driven vision capacity realize real time performance 
visual analysis previous researchers low resolution sensors implemented primitive form attentional selection vision selectively analyze parts visual world analyze degree required order achieve goal done ad hoc fashion resulting real time performance 
attempts include attentional selection goal driven processing principled manner broader scope 
behaviour may manipulate internal representations input internal representation making changes creating internal representation subsequent processes 
intermediate representations hierarchical organizations attentive selection explicit goals facilitated 
behaviour internal external represented smpa cycle see 
concept smpa control criticized past criticism due single integrated control paradigm 
means decompose stages computation individual behaviours 
world act elements cycle defined sense plan smpa cycle 
model world 
contains representations event window action window 
event window accessible relevant portion representation system 
similarly action window opens set representations 
world node contains set daemons monitor contents event window 
daemons detect changes event representations relevant types act triggers activation behaviour 
way representations limited external world sophisticated forms intelligent reasoning permitted 
intermediate representations manipulated permit internal behaviours handled manner representations external behaviours 
sense 
process attempts extract event window stimuli interest perform level processing 
model 
representation domain sensed representation model associated subsets sensed representation 
plan 
process associates actions models determines appropriateness association 
act 
process invokes manipulation representation realizes behaviour acting action window world node 
sense model plan act nodes called process nodes 
share common attributes contains types windows internal event window internal action window external action window 
process nodes perform computation map events process input representations internal event window store result representations external action window 
internal action window node internal event window successor node manner pass information 
external action window enables augmentation 
sense plan act map events actions resolve conflicts behaviour behaviour augmentation mechanism 
depicts role windows behaviour augmentation 
model node augmented entire behaviour 
sense node updates representations model node augmenting behaviour triggered 
produces result eventually stored representation 
representation internal action window sense node read process resolve conflicts executes map events terminated 
resolve conflicts process ordinates result model node augmenting behaviour 
result stored external action window 
explicitly stated tsotsos important details worth clarifying manner daemons operate manner representations maintained system original proposal 
representation controller system maintains full history states representation point initialised 
state representation associated time stamp represents point time representation particular state 
say representation updated changes state new state assigned timestamp representing new timestamp old state saved assigned timestamp 
sensor writes representation new timestamp current system time 
behaviour writes representation new timestamp determined differently mentioned 
state history representation indexed timestamps 
daemons required observe state changes representation state changes deemed relevant trigger new instance copy behaviour 
behaviour instance performs computation thread different state input 
action window representations written new states representations get assigned timestamp state event window representation caused behaviour trigger place 
example suppose representation called maintains readings front left rear right mobile platform say history states looks time time time time time belonging behaviour called say computes direction travel avoid obstacles imagine angle bird eye view robot platform directed forward write states representation called heading say time time time time time manner representations states reflect available information particular instance time 
explored thesis tsotsos proposal includes exception handling mechanism mission language procedure analytically verifying configuration behaviours representations 
discussed turn 
exception handling 
exception handling mechanism functions follows 
suppose cognizant failure occur behaviour processing example triggered behaviour discovers deal particular input contains invalid insufficient data 
behaviour throws exception placing information caused failure special representation called exception record 
behaviours dedicated task catching exceptions read exception record new entries respond correcting situation caused exception generated place 
state histories representations reconstruct situation caused exception thrown place exception record contain information behaviours 
mission language 
mission language best thought augmentation list actions action behaviour augmentation consists language features support execution monitoring task scheduling constraint satisfaction 
essentially mission specification serves specialize behaviour network strengthening trigger conditions specifying behaviour parameters achieved writing values event representations 
example mission specification language 
mission divided phases phase list tasks sequential tasks separated semi colons task behaviour includes parameters event representations fixed states 
significant construct form tasks ensure constraint condition tasks executed long constraint condition remains satisfied special monitoring behaviours implement construct controller 
tasks execute concurrently note constructs example task start complete time task executing 
similar constructs include starts ends starts time ends implement validate language simulated environment 
start phase panorama raise mast take snapshot turn camera take snapshot turn camera take snapshot turn camera take snapshot turn camera lower mast phase am raise mast find landmark find landmark localize lower mast phase approach target goto landmark track landmark phase analyze target localize panorama mission am panorama ensure speed approach target analyze target ensure speed ensure example mission specification 
proof procedure 
take advantage constraints ensure clause just described procedure verifying behaviour network suitable satisfying mission 
example timing constraints provided running times behaviours computations representation reads writes determined analytically 
suppose behaviours bn total running times cn en functions size event windows ei execute network supposed complete time described mission specification specifies timing constraints groups behaviours ensure clauses 
find longest path network may trivial case cycles suffices determine exist valid assignments ei sum running times ci ei behaviours longest path exceed subject constraint worst case running times behaviours network exceed constraints specified mission specification 
consider respect attributes robot control architectures mentioned earlier chapter 
behaviours reactive respond changes representations event windows deliberative perform complete smpa cycle 
embraces deliberative processing limits trade reactivity possible sequential deliberative processing confined behaviour 
triggering mechanism daemons allows deliberative computation happen distributed manner behaviours 
conceptually simple architecture lends construction controllers uniform components avoids rigidity inherent deliberation reactivity decomposition hybrid systems 
shall see subsequent chapters explicit representation enables concepts task oriented perception 
chapter chapter theoretical aspects flesh details conceptual framework formalization example 
sketch proof architecture predefined behaviours turing equivalent 
implications proof sketch discussed representation free behaviour systems 
thesis consider totality 
consider narrowed version need examine issues concern supporting deliberation reactivity robot control architectures 
chapter begins discussing aspects considered thesis aspects neglected 
narrowing thesis evaluate aspects 
evaluate develop exception handling mechanism mission language proof procedure performing active attentive vision situated agents real robots 
focus strictly behaviours representations interact robot controller designers ought build controllers software framework 
particular focus software framework build behaviours representations weaving behaviour networks 
thesis consider exception handling 
mission language falls outside scope thesis treated 
examination proof procedure warrants thorough investigation automated theorem proving optimisation 
proper investigation active attentive vision requires mobile robot platform hardware best done follow thesis 
thesis discusses efforts develop evaluate software framework conceptual framework 
order done necessary ignore details proposal introduce practical problems scope thesis 
details daemons trigger multiple instances behaviours representations maintain complete state history 
hypothetical problems create discussed turn 
multiple instances behaviours respect daemons triggering multiple instances behaviours keeping mind behaviour thread execution conceivable number behaviours spawned grow unmanageable quantity 
simple example daemon monitors sensor representation frequently updated sensor readings continually change 
type behaviour triggered rate completion slower update rate number threads may grow bound 
solution example may limit representation update rate general possible limit update rate representation 
trade limit number spawns behaviour 
avoid difficulties managing multiple spawns behaviours thesis limits number spawns 
investigation multiple spawns left 
representation state histories respect maintenance representation full state history conceivable system memory eventually exhausted 
simple solution limit size history new states added history old states removed 
guarantee old states needed system say case exception caught behaviour needs recreate context caused exception generated 
possible solution behaviour mark representation states read behaviour daemon observes garbage collector remove states marked read system behaviours read representation 
garbage collection may problems constitutes entire area research 
dealing practical problems scope thesis limit state histories single state 
say representation updated old state timestamp lost representation contains state timestamp indicating update occurred 
investigation state histories left 
rest thesis consider conceptual framework include modifications mentioned 
consider difference conceptual framework proposed tsotsos narrowed version significant rest thesis refer narrowed version simply conceptual framework 
note confused software framework software implementation conceptual framework 
conceptual framework section components conceptual framework defined explained account modifications mentioned section 
entities comprise follows representation 
representation abridged representation kind representation discussed unambiguous simply data structure maintaining sort explicit representation deliberative systems discussed background 
may intermediate internal representations may represent state sensors actuators 
representations may modified behaviour control system endogenous change may modified process outside control system exogenous change case sensor reading changes 
representations read input behaviour event representations similarly representations written output behaviour action representations 
window 
entity belonging behaviour window maintains set representations interest thought inside window window opens set 
detect change occurred representations 
behaviour event window opens event representations similarly behaviour action window opens action representations 
daemon 
daemon monitors changes event representations behaviour detected evaluates relevant behaviour purpose 
triggers behaviour activate 
monitoring suspended behaviour completes 
behaviour 
triggered activate respective daemon behaviour abridged behaviour kind behaviour discussed unambiguous reads data event representations executes smpa process data input stores result process action representations 
smpa process fails complete behaviour throws exception 
generic controller 
class encapsulates entities related interactions comprise conceptual framework 
example consider conceptual example entities interact example chapter 
consider cylindrical differential drive mobile robot platform located rectangular room square blocks placed aligned right angles walls depicted 
room aligned cardinal directions north south east west 
control problem simply move platform straight line stopping rotate deg obstacle detected 
robot travels forward absence obstacles path turns leftwards avoid obstacle front rightwards obstacle impedes doing 
platform contains hypothetical servo control system carries sensors forward directed laser rangefinder reports value true detects obstacle distance platform diameter false ii 
leftward directed laser rangefinder identical iii 
rightward directed laser rangefinder identical ii iv 
compass reports heading mobile robot angle degrees 
done simple controller representations behaviours 
controller maintains representations 
consists boolean fields front left right representing boolean values forward leftward rightward directed laser 
values determined exogenously laser 
ii 
compass 
consists field direction represents compass reading angle degrees range 
value determined exogenously compass 
iii 
bearing 
identical compass determined exogenously 
represents goal heading travel set behaviour 
iv 
wheels 
consists fields left right representing angular velocities left right wheels 
value determined endogenously affects speed wheels 
positive value implies platform moving forward 
controller executes behaviours avoid 
uses information presence obstacles determine robot bearing 
compass direction right angle writes bearing direction depending state compass front false bearing direction compass direction front true left false right true bearing direction compass direction ii 
bearing direction compass direction compass direction right angle behaviour complete 
guarantees bearing changed platform executing rotation 
ii 
move 
manipulates motor speeds turn robot place direct desired bearing move forward 
bearing compass representations input modifies wheel velocities wheels robot turns place bearing direction compass direction 
done follows positive constant value indicate angular speed bearing direction compass direction wheel left wheel right turn right place 
bearing direction compass direction wheel left wheel right turn left place 
wheel left wheel right move forwards 
consideration position direction robot iv examine interactions occur behaviours representations robot travel path initialisation 
behaviours initialize 
behaviour constructs event action windows acquiring relevant representations system 
daemons monitoring event window changes 
controller ready execute 
note initialisation hypothetical servo control system recognize wheel speeds wheels representation undefined 
ii 
travelling point representations assumed undefined state 
compass representations reflect state sensors changed exogenously 
change detected daemon belonging avoid triggering 
reflects collision occurred direction avoid sets bearing direction equal compass direction case 
endogenous change bearing representation detected move behaviour adjusts left right wheel speeds angular speed correct disparity compass reading bearing 
servo control moves platform forward 
platform moves forward reached point detection wall north side causes exogenous change 
iii 
traveling point front true 
change detected avoid computes bearing 
endogenous change bearing causes move triggered 
wheels right set wheels left set causing platform turn clockwise 
platform direction changing compass representation undergoes constant exogenous change 
causes avoid behaviour triggered moment 
compass direction right angle avoid compute response guaranteeing bearing direction change 
compass direction bearing direction move sets wheels representation platform moves forward 
situation remains platform reaches close point detection walls left right platform results exogenous change 
front remains false platform continues moving detects wall front causes front true 
iv 
traveling past point avoid computes bearing causes platform turn clockwise 
point front left remain true right false 
avoid causes platform continue turn clockwise facing opposite direction initially came 
point left right true front stays false 
iii ii iv example result interaction behaviours representations 
graphs behaviours representations called behaviour networks 
behaviour network diagram technique depicting behaviour networks shown red hexagons behaviours blue rectangles representations arrows representation behaviour indicate behaviour event window arrows direction indicate representation behaviour action window 
bumpers compass avoid bearing move possible vectors characters set possible binary trees 
wheels behaviour network depicting example controller 
noted example simple highly reactive behaviours include significantly deliberative processing 
chapter interested demonstrating interactions behaviours representations formal setting 
chapter demonstrate behaviour perform sensing modelling planning action 
consider formalism 
formalism section formal notation 
specification controller consists components definition representations system initial state representations behaviour definitions 
described detail 
representation definitions representations data structures values simple matter specify representation function discrete time mapping state data structure 
define representation type set values represent possible states data structure 
example set integers characters floating point numbers set possible arrays integers set defined representation type discrete time representation type introduce notational convenience 
suppose define cartesian product primitive data types qn 
qn shorthand expressing representation type write shorthand referring th projection case ki write may elect field name place syntactic sugar fieldname shorthand representations defined alternative manner expressing types individual fields field field field qn may convenient define operations predicates 
representation initializations definition start execution system time zero 
express initial state representation value 
define initial state state kn simply write behaviour definitions kn kn behaviour definitions describe state representations current state 
example suppose behaviour event representations rn rn action representations sm sm computes states sm time tb values rn time function duration tb 
define simply write rn convenient expression function computes behaviour specification postcondition precondition predicates defined representation states rn respectively 
usually precondition includes expression state representations trigger occur 
possible race conditions exist definition controller 
example follows 
consider behaviours defined programs write respectively shared single write regular registers halt 
execution exists final state registers contradict definitions practice necessarily problematic controllers problems stemming race conditions redefined handle race conditions robust manner remove race conditions altogether 
example applying example previous section specification 
representation definitions representations defined left front right compass direction bearing direction wheels left wheels right define predicates compass bearing compass direction boolean 
note velocity range wheels 
representation initializations initial values representations follows behaviour definitions define behaviours follows 
avoid left false front false right false compass direction bearing direction wheels left wheels right compass direction front false bearing direction compass direction front true left false right true bearing direction compass direction bearing direction compass direction compass direction bearing direction bearing direction 
move bearing direction compass direction wheel left wheel right bearing direction compass direction wheel left wheel right bearing direction compass direction wheel left wheel right note part specification computed daemon evaluation compass direction 
event false changed happen behaviour triggered 
apply formalization describing controller demonstrates turing equivalence 
proof sketch turing equivalence section prove architecture turing equivalent problem solved approach solved computing system 
say controller built accept recursive language 
motivation carrying proof discussed 
best knowledge researchers offered proofs turing equivalence robot control architectures characterize computational power single robot controller proof exists demonstrate collective robots controlled finite automata turing equivalent dudek jenkin milios wilkes 
consequence fact knowledge researchers constructed formalisms robot control architectures 
argued focus control architecture research find principles efficiently organizing computation concerns discussed chapter proof turing equivalence give important information arkin 
ask bother 
ask question architecture turing equivalent discover just flexible architecture getting perform desired computation provided known possible course 
example necessary simply reconfigure existing controller perform computation considered flexible opposed architecture requires designer modify modules implement new ones 
strengthen point observe different types mathematical machines known exist turing equivalent 
turing machines multiple tapes multiple heads tapes multiple dimensions deterministic nondeterministic stacks counters 
utility lies partly facility lend carrying different kinds proofs partly describing minimum properties required machine able carry possible computation 
shall see considered quite flexible comparison behaviour approach 
case conceptual framework quite specific kinds computations allowed ways memory allowed accessed 
obvious proof turing equivalence simply find turing machine accepts language create single behaviour compute function 
input stored representation 
behaviour uses internal representation tape turing machine simulates turing machine 
implies controller designer implement behaviour possible computation desired 
inflexible better 
goal show fixed predefined repertoire behaviours representations configure controller accept recursive language 
advantage approach need define special behaviours particular problems wish demonstrate recursive language exists set behaviours representations construct behaviour network accepts 
counter turing machine specifying controller simulates counter turing machine minsky proved turing equivalent minsky 
machine consisting integer counters place tape execute simple operations add subtract change state halt course 
decisions operate counters depend counters zero non zero 
initial values counters represent input 
counter turing machine defined quadruple qf finite set states qf initial final state transition function defined dec dec transition current state zero zero 
additionally input machine takes form initial states counters 
result transition increments counters decrements counters increment decrement 
configuration state value counter value second counter 
construct controller simulates counter turing machine 
reduction proof sketch turing equivalence reduction counter turing machine 
consider name controller just 
theorem 
turing equivalent 
proof sketch 
show reducible specified follows 
representation definitions representations defined state counter counter accepted state representation simulates state machine counter simulates counters representations maintain functions map states values mapped transition function machine idea stores subset transition function increments counters stores subset transition function increments counter decrements second 
accepted boolean true input accepted initialize representations initial states representations follows state counter counter dec dec dec dec accepted false intial states counters input 
behaviour definitions set set elements domain maps increment counters 
similarly set dec set dec set dec dec 
behaviours defined 

state counter counter counter counter state state 
state counter counter counter counter state state 
state counter counter counter counter state state 
state counter counter counter counter state state 
accept state qf accepted true depicts controller 
representation state maintains state representation counter maintains counters states representations correspond configurations behaviours correspond operations increment counters increment decrement second increment second decrement decrement counters 
behaviour associated representation transition rules required simulate daemon triggers behaviour machine state values counters correspond mapping transition function behaviour operation 
behaviours read write state counters 
input selected accepted true 
note exogenous changes representations 
accept state count accepted behaviour network diagram machine 
start operation input string encoded natural number assigned counter second counter zero 
daemons behaviours observe state counter recognize change occurred system initialized 
deterministic machine transition function injection exactly daemons triggers behaviour 
behaviour performs operation counter uses lookup information associated representation determine state gets written state 
behaviours take exactly time complete daemons guaranteed simultaneously detect representation update time step simulated computation takes place 
fifth behaviour accept monitors state see enters final state sets accepted true 
process continues ad infinitum thought accepted input accepted true 
accepts string accepted important note behaviours general considered minimal representations tasks behaviours may computationally weaker turing machine proof relies true behaviours 
turing equivalence due fact components turing equivalent 
fairly obvious behaviours turing equivalent computations involved evaluating boolean condition reading values registers applying values function stored representation write result function registers 
function simply table 
executions possible behaviour writes counter representation writes state representation 
situation behaviour get triggered counter new values state old value computation follow turing machine 
solve problem assuming behaviours lock counter state time 
turing equivalent string accepted accepted turing equivalent 
section discuss implications result 
discussion section proved turing equivalent 
fact important implications structure controller 
implication respect program controller 
program controller solve particular problem polynomial time turing machine necessarily define special behaviours 
sufficient define trigger conditions information contained representations 
language accepted depends states transition function 
things define contents representations trigger conditions language accepted controller section depends definitions 
corollary exists universal set behaviours representations computation 
second implication mission language behaviours proposed tsotsos developed turing equivalent configure trigger conditions daemons contents representations 
third implication architecturally superior purely behaviour approaches purpose computation 
wish controller designer configure ordination mechanism order select computation infinite number behaviours required machine accept language 
clearly undesirable preferable controller designer implement behaviours perform set desired computations 
flexible regard purely behaviour approach 
consider modification definition generic behaviour system shown chapter output controller accept reject input string defines set behaviours system behaviour ordination mechanism 
simulate deterministic turing machine necessarily define behaviour simulates construct controller uses 
suppose wanted find universal set pure behaviours section 
language accepted turing machine need add behaviour controller simulates machine 
accept machine language ordination mechanism externally configured allow output machine simulator 
set recursive languages countably infinite number behaviours system necessarily infinite 
highly possible situation different communication allowed behaviours behaviour systems subsumption permit 
clear number behaviours required bounded universal set necessarily exists known case general 
rest thesis focuses software framework 
chapter chapter software framework position discourse robot control architecture theory established background conceptual framework formalized chapter 
examine claims concepts implementation 
chapter begins examination presenting software prototype research thesis 
order examine conceptual framework defined tsotsos goal research implement system realized principal structural functional concepts 
object oriented software framework developed structure functional components 
extended implement specific controllers conform exactly principles done purpose experimentation chapter 
practical benefit capability enable reuse behaviours representations different controllers second goal research 
chapter describes software framework explains design decisions 
proceeds follows 
section presents motivation developing software framework section presents framework overview informal usage requirements 
structure function framework described section usage requirements description components comprise behaviours representations section explanation components initialized terminated operate 
illustrative example 
section claims evaluated 
section motivation approach implementing 
possible unified modelling language uml describe structural dynamic functional aspects framework 
particular uml view represents aspect system 
structural aspects functional aspects 
structural aspect system terms inheritance client supplier relationships classes including relationships types processes behaviours daemons data representations windows 
model class diagrams represent static view system 
second structural aspect concerns specification support transactions system environment 
seen collection cases represented case diagram 
functional aspect terms various states occupied system components behaviours representations example 
represent components state machines state chart diagrams 
functional aspect concerns activities occurring framework interaction behaviours representations 
aspect seen different uml views activity view suited highlighting control flow processes interaction view show causal sequences events occur 
activity diagrams realize activity view 
different diagrams emphasize different aspects causal sequences sequence diagram emphasizing ordering messages method invocations collaboration diagram emphasizing classes collaborate response occurrence events 
discuss motivation developing software framework 
motivation developing software framework order properly apply principles designing controller software framework developed controller developer extend control system conforms principles 
software framework reusable object oriented design structured set classes collaborations instances define part software system 
large scale reuse object oriented libraries requires frameworks framework provides context components library reused 
important confuse software framework conceptual framework set assumptions concepts values practices constitutes approach control 
substrate controllers embody approach 
controller framework provides generic design entire controller 
classes represent structural components conceptual framework behaviours representations event action windows daemons 
collaboration instances realize relationships structural components defined conceptual framework representations behaviours daemons arise processes detecting changes representations daemons daemons triggering behaviours 
inheritance polymorphism developer easily build controller defining specific behaviour representation classes 
interactions handled entirely framework 
developers reuse behaviours representations controller guaranteed reused classes interact seamlessly rest controller components 
example consider hypothetical robots serving patrons hall 
robots built differential drive platform model includes sonar array stereo camera 
robot server carries tray sensors detect presence 
second vacuum cleaner sports different attachments hard floors 
robots share behaviours driving platform sensing sonars simple collision detection 
behaviours steering behaviour called collision avoidance behaviour called implemented robot inheriting behaviour class second robot 
example uses bearing stored event representation goal controller robot event representation reused controller second robot 
task specific behaviours may differ detecting presence potential patrons vacuuming floor assumption 
controllers may require representation store map hall need navigation behaviour 
summary software framework basis controllers guaranteed controllers conform conceptual framework 
added benefit code reuse simpler discussed 
rest chapter describes implementation software framework 
framework overview software framework comprised classes execution engine 
classes represent conceptual entities defined chapter 
execution engine ensures instances classes collaborate properly 
say ensures kinds activities occur event action windows behaviour define representations behaviour access behaviour daemon detect change occurred representations event window occurs behaviour gets triggered daemon sensing modelling planning acting processes complete affect representations action window behaviours initialize terminate correctly 
ordination behaviour initialisation termination kinds activities distributed behaviours behaviours thread execution 
kind activity implemented sequence class method calls executed thread belonging behaviour 
entity called supervisor defined conceptual framework controls initialisation termination threads execute behaviours performing host housekeeping activities 
way processing related robot control performed behaviours entity 
software framework implemented function monolithic operating system windows linux 
case view design software architecture motivated generic software controller framework required interact environment 
subsection presents requirements informal specification usage requirements 
case view specifies manner actors environment framework highlighting transactions occurring 
actors refer entities interface software framework exist independently framework 
different actors system different cases referred cases 
actors sensors 
devices physically interact environment produce signals represents state 
consists external sensors devices sensing state world including sonar arrays cameras bumpers solar panels microphones internal sensors devices sensing state robot hardware including battery measuring angular displacement wheels temperature measurement attached actuated hardware sensing position 
controller accept signals sensors 
actuators 
devices physically act world signal represents action 
examples motors robotic arms effectors robotic lights displays 
act robot hardware motors deploy retract antennae landing gear 
accept signals controller 
operator 
human deliberative entity robot performs tasks useful operator 
operator specifies goals robot achieve 
designer 
human deliberative entity configures software framework set desired capabilities 
designer ensures robot sufficiently capable achieving goals operator set 
cases interactions actors described 
depicts interactions 
cases follows sense environment 
architecture able receive information environment sensors 
representations sensors reflect signals sent sensors 
perform action environment 
architecture allow actuators act environment 
signals actuators reflect representations actuators 
assign goals 
architecture able receive operating goals operator 
configure controller 
architecture allow operator configure system 
operator able select behaviours representations relevant desired mission 
mission language allows operator specify conditions requisite behaviours active point mission execution 
case diagram generic controller depicting required interactions system actors interact 
define capabilities 
architecture allow robot capabilities specified designer straightforward manner 
designer including excluding different behaviours representations system plug ins 
turn examination framework structure 
structure section presents static view architecture 
types classes classes relating representation classes related behaviours classes relate system operation 
classes semantics described class diagram 
component classes subsection describe classes comprise software framework 
purpose class justified terms relevance conceptual framework classes behaviour described 
classes related system operation classes described comprise operating system controls monitors execution behaviours maintains handles representations behaviours 
supervisor class controller class classes associated threads messaging basic types 
types discussion basic types 
classes defined framework represents simple types system 
time class key class rule class 
time 
represents time 
allows arithmetic relational operations performed time objects 
key 
entities controller behaviours representations uniquely identified key object 
entities maintain dictionaries entities system indexed key object 
entities share key key representation key behaviour 
keys totally ordered 
rule 
rule object represents predicate 
rule class allows predicate defined evaluated runtime 

class mutex lock writers readers single writer multiple reader access semantics 
processes lock simultaneously reading calling method single process lock writing calling method 
mutex locked writing locked reading vice versa 
software framework representation classes subclasses inherit writers readers semantics 
data 
data class represents generic data structure 
representations type messaging mechanism framework uses messages carry objects type 
threads messaging controller multithreaded application behaviours processes execute concurrently thread management facilities required 
thread class encapsulates thread methods starting suspending terminating 
messaging class encapsulates message queue methods enqueuing processing dispatching messages 
inherits class ensuring message queue written read 
noted message passing exist conceptual framework required order implement software framework correctly 
particular allows processing start terminate suspended gracefully 
naturally conceptual framework address implementation details capability needed controller implementation 
consider case termination example 
suppose messages control execution threads supervisor able destroy threads allowing behaviour smpa cycle terminate gracefully 
conceivable behaviour responsible homeostatic control say may complete jeopardize safety system 
true case suspending threads 
thread class method called run executes thread implemented subclasses 
third class called inherits thread messaging implements run method read messages message queue dispatch 
class defines method called invoked run method messages dispatched 
class provides behaviours thread execution 
message queue method called 
threads execution system managed process called supervisor described 
supervisor supervisor independent process manages behaviours representations software framework 
monitors controls behaviours performs management access brokerage representations 
supervisor class encapsulates programmatic behaviour 
noted supervisor defined part conceptual framework implementation construct 
supervisor class inherits class maintains message queue processing operator messages initializing configuring resetting starting suspending stopping controller 
operator configures controller specifying behaviours instantiated representations bound 
dynamics surrounding activities section configuration 
configuration done mission language discussed thesis 
supervisor keeps track controller entities 
supervisor maintains dictionary representations indexed key 
processes system request representation key 
supervisor maintains key indexed dictionary different types behaviours available system 
operators specify type behaviour launched key identifies type 
supervisor maintains dictionary active behaviours unique keys index 
key system unique 
dictionaries writer reader access semantics 
entities maintain supervisor may retrieve necessary 
supervisor behaves interface operator entities controller 
binding robot hardware related representations exogenous behaviours supervisor 
controller controller class encapsulates entire controller 
class subclass instantiated calls supervisor methods initialize configure start controller 
note class defined conceptual framework strictly implementation detail 
purpose thesis role framework specific 
encapsulates thread responsible performing tasks reading simulated sensors updating corresponding sensor representations sending signals simulated actuators updates corresponding actuator representations 
simulations described thesis thread exogenously changes controller sensor representations 
classes related representations controller interacts environment representations behaviours controller interact representations 
classes defined representations windows 
representations representations realized representation class 
representations controller instances classes inherit class representation 
representations arbitrary data structures encapsulated associated operations realize symbolic representations 
example symbolic representation representation boolean fields true object direction deemed close 
example associated operations compass representation operations ensure direction field maintains value range 
representation controller associated key uniquely identifies supervisor daemons behaviours 
representation maintains association supervisor 
class diagram example representations compass bearing wheels derived representation various attributes associated operations 
example class diagram representations showing inheritance relationship representation class 
behaviours daemons sensors actuators read write representations 
avoid conflicting accesses representation interface writers readers access semantics inherits class 
implemented methods 
methods belonging particular representation execute process calling method 
example different behaviours executing process read data map representation accessor method method execute behaviour 
process effects change representation change registered call update method executes process 
timestamp set time system method called 
daemons monitor representations relevant changes 
detect change daemon compares time inspection representation timestamp available time methods 
rule instance representation subclass number methods defined compute predicates state instance 
ensure change relevant daemon number predicates 
responsibility controller designer define types representations system 
simply defining subclasses representation class termed representation types 
controller designer selects representations instances representation types get particular controller 
operator determines representations controller depend behaviours operator specifies 
particular operator representation window replaced representations long conform type original representation 
ensure state representations tied sensors controller designer interface representations sensors 
controller keeps track representations exist system maintaining dictionary indexed unique key called representation key 
done process maintained supervisor class described 
special type representation framework keeps track system time called class 
class keeps track number milliseconds elapsed system began running subclass time class representation class 
singleton class allows instance exist system associated supervisor 
entities query supervisor get current system time 
updated representations update timestamp hold current system time association supervisor 
representation hierarchies representation defined mereological aggregate smaller defined mereological aggregate smaller possible behaviour event action windows open portions representation 
process independently access atomic representation 
aggregate constitute representation wholly accessed 
aggregate termed representation hierarchy 
noted defined conceptual framework introduced implementation construct 
category spatial concepts expresses notions part 
representation hierarchy example 
aggregation involves organizing atomic representations mereological hierarchies say atomic representations connected trees tree node part relationship children 
aggregate referred simply atomic representation root tree 
example suppose want maintain representation sensors particular system 
supposing sensors consist array sonars array bumpers compass tilt sensor pan tilt stereo camera 
organized sensors representation aggregates compass representations representation aggregates sonar representations representation aggregates bumper representations representation aggregates representation 
updating representations 
atomic representations updated updated 
atomic representations updated bumper updated 
lightning symbol denotes update 
updates representation imply updates representations share mereological relationship 
example suppose representation updated 
sensors representation considered updated parts updated 
representations considered updated representation part updated 
depicted 
suppose second bumper representation updated 
consider sensor representations updated bumper part sensors representations 
representations considered updated bumper part part 
depicted 
lightning symbols denote updates 
bumpers left bumpers front bumpers right bumpers rear bumpers collisions example representation hierarchy behaviour detects collisions 
depiction robot platform small black circles bumpers 
behaviour network diagram 
dashed line indicates alternative event representation behaviour 
grey line indicates parent child relationships representations 
note lightning symbol defined uml just purpose illustration 
glance may appear representations organized frame hierarchies operates frame system 
appearance reinforced fact state representations thought describing situation 
representations describe situations representations mereological hierarchies frame aggregate inheritance hierarchy 
representation hierarchies possible event windows change scope attention 
suppose hypothetical robot behaviour called task updating representation called collisions event collision bumper just occurred 
suppose behaviour expects type event representation 
consider robot twelve bumpers front left right rear depicted 
bound bumper representations representation hierarchy various representations depicted 
root representation represented system representation key bumpers 
bumpers children left bumpers front bumpers right bumpers rear bumpers 
representations representation type representations event representation behaviour rear bumpers example 
attend left front right rear bumpers attend 
windows responsibility controller designer define representation hierarchies 
behaviours access representations world event action windows open 
window class defines semantics windows 
window instance maintains dictionary representations indexed key known corresponding object 
processes add entries dictionary insert method change representation referenced key dictionary replace method long type replaced representation conforms type original representation get representation indexed key inspect method 
windows maintain associations supervisor 
windows enable behaviours windows attention world shifted providing interface behaviours daemons representations world 
interface decouples representations representations 
way process replace representation behaviour event window representation type register change behaviour 
behaviour triggered requests supervisor current event representations event windows key 
replaced behaviour new operating shifted window attention 
special subclasses window class defined software framework correspond event action windows conceptual framework maintain key indexed dictionaries event action representations respectively 
define methods allow process query event representations updated process queried 
daemons mechanism detect changes event representations 
substantial differences class class 
classes subclassed classes 
instances assigned process nodes behaviour able update representation dictionaries behaviour event action windows changed clearer process nodes described 
controller designer specify types representations event action windows system observe 
responsibility operator assign individual representations event action windows particular behaviours 
appear behaviours depend supervisor process get representation behaviours may block waiting response 
fact behaviours invoke routine defined supervisor module retrieve representation 
routine executes thread behaviour lock required operation involved read 
classes related behaviours behaviours describe classes relating behaviours processing 
behaviour class encapsulates programmatic behaviour behaviours 
entities computable functions take input state event representations output state change action representations triggered processing daemons relevant changes detected event windows 
instance behaviour class maintains event action windows associated instance daemon class described section shares event action windows 
behaviours decomposable sense model plan act computations behaviour object aggregates instance classes perform computations classes described 
possible behaviour object perform null computation place computations aggregating instance class class described 
behaviours maintain association supervisor 
method trigger daemon object call 
daemon invokes method corresponding representation behaviour executes sense model plan act computations defined classes 
method executes completion 
behaviours exist various states 
behaviours operating normally controller active initialised finalized triggered 
may may executing smpa cycle smpa cycle may may terminated successfully 
capture information maintain types states execution states describes behaviour state readiness execute smpa cycle hasn triggered ready triggered failure occurred activation states describes operational readiness triggered observing event window executing completed 
execution states follows standby 
behaviour smpa cycle waiting triggered triggered 
executing 
behaviour executing smpa cycle normally 
succeeded 
behaviour finished executing smpa cycle operation successful 
may triggered 
state defined framework implementation construct 
failed 
exception generating failure occurred behaviour triggered 
state defined framework implementation construct 
activation states follows dead 
initial state behaviour 
exception handling treated thesis 
ready 
behaviour event action representations set properly behaviour ready observe event representations 
inhibited 
behaviour ready process inhibited triggered 
feature implemented available 
observing 
behaviour ready daemon observing event representations 
triggered 
behaviour triggered executing smpa cycle 
finalized 
behaviour event action representations freed behaviour removed controller 
noted succeeded failed execution states activation states exist conceptual framework 
included software framework designed support mission language extensions scope thesis 
behaviours concurrent processes 
behaviour processing executes thread owned termed behaviour envelope including daemon process nodes 
behaviour envelope concept described 
associated behaviour representation uniquely describes state 
termed behaviour state representation instance class subclass representation 
behaviour state changes corresponding behaviour state representation updated reflect 
responsibility controller designer determine types behaviours defined system 
type behaviour referred behaviour type defined simply process nodes bound representation types selected event action windows behaviour type pointer static method instantiates behaviour 
mechanisms process node binding representation type selection described 
operator plays role 
behaviour key system uniquely identifies 
behaviour type key system uniquely identifies 
noticed keys system uniquely identify system entities behaviour type key behaviour key representation key 
process nodes sense model plan act computations performed behaviour seen nodes smpa cycles conceptual framework 
software framework termed process nodes 
processnode class encapsulates programmatic behaviour process nodes 
subclasses processnode encapsulate sense model plan act computations classes 
controller designer develop new behaviour simply implementing new subclasses classes bound behaviour described 
subclass processnode class defined framework performs computation computation equivalent precondition true postcondition true 
designer prefers kinds computations inert class bound behaviour place relevant processnode subclass 
processnode class associate kinds windows declare methods controller designer implement processnode subclasses belonging particular behaviour 
windows instance called internal event window instances called internal action window called external action window 
windows enable communication process nodes enable behaviour augmentation manners described chapter 
case communication process nodes internal action window process node say shares representations internal event window node follows computational sequence case 
internal event window sense node event window behaviour internal action window act node action window behaviour 
case behaviour augmentation process node internal event window external action window share event action representations augmenting behaviour 
process node perform computation essentially mapping action representation states event representation states resolve conflicts introduced behaviour augments node 
processnode class declares methods intended perform processing suggested names implemented controller designer 
responsibility controller designer define behaviours done simply defining methods process nodes choosing representations viewed nodes event action windows effectively chooses type representations viewed windows representation replace conforming type 
behaviour constitute part behaviour type 
daemons coupled behaviour daemon 
daemon class encapsulates functionality 
daemon class instance maintains event action windows corresponding behaviour ensures behaviour process nodes refer representations windows behaviour windows 
daemons maintain association supervisor available corresponding behaviour 
controlled associated behaviour envelope executing thread observe method periodically called event window queried determine event representation updated 
predicate evaluated determines state representations satisfies behaviour precondition execution 
predicate precondition daemon corresponding behaviour constructed calls predicates defined representations connected logical operators 
daemon default predicate true controller developer specify different predicate subclassing daemon class overriding virtual method called returns boolean 
example precondition avoid behaviour described earlier triggered compass direction right angle 
responsibility controller developer specify types representations daemon maintains event action windows consequently behaviour windows 
example implementing move developer specifies bearing compass event representations wheels action representation 
operator capability binding modifying representations daemon event windows provided types conform types existing representations 
untested framework thesis examine manner operator configure behaviours run time 
operator mission language examines mechanism 
responsibility controller developer implement daemon predicate 
responsibility operator process able strengthen predicate adding terms runtime facility demonstrated current framework discussion falls outside thesis scope 
facility mission language demonstrates 
behaviour envelopes processing attributable behaviour daemon process nodes windows occur thread execution framework able start suspend query state 
thread execution owned called behaviour envelope software framework 
noted defined conceptual framework 
purpose ensure supervisor completely control threads independent operating system 
controller maintains constant number behaviour envelopes 
active behaviour assigned behaviour envelope keeps track execution status states binds representations windows triggering monitors failure suspends destroys finalization 
class encapsulates management facilities activities 
behaviour envelope periodically calls observe method daemon class described earlier 
behaviour envelopes maintain association supervisor available corresponding behaviour 
class inherits class described earlier implements message processing mechanism implements method 
behaviour envelope accepts process control messages supervisor initialize start suspend finalize behaviour 
message queue idle messages behaviour envelope invokes observe method daemon class done method implemented 
thread execution behaviour processing takes place 
processes messages behaviour smpa cycle completed behaviour triggered messages processed 
reasonable behaviour guarantee execution messages suspend finalize behaviour processed soon possible violating guarantee 
class maintains behaviour state representation monitored supervisor 
manner supervisor control behaviours active system 
supervisor wishes replace behaviour supervisor issues message behaviour envelope corresponding behaviour finalize 
supervisor waits execution state finalized assigning envelope new behaviour 
dynamics surrounding activities detail section 
behaviour envelopes exist various states 
types states execution states describe behaviour ready active suspended usability states describe behaviour function normally 
execution states follows ready 
behaviour operating normally activated 
ready 
reason behaviour ready longer ready operating normally 
failed 
behaviour longer unrecoverable failure occurred 
execution states follows dead 
initial state behaviour 
initialized 
behaviour event action representations set properly behaviour ready start 
started 
behaviour active processing representations 
suspended 
behaviour ready may active presently active 
stopped 
behaviour active deactivated 
finalized 
behaviour event action representations freed behaviour removed controller 
behaviour envelopes enable operator control task execution mission language 
operator deems behaviours irrelevant operator corresponding behaviour envelopes freed new behaviours instantiated stand 
manner old behaviours irrelevant task hand new ones available take 
active behaviours available behaviour envelopes 
ensures number concurrent processes running system remains constant performance behaviour depend designed controller includes exception handling behaviours enter state 
exception handling unrecoverable failures may occur 
number active behaviours system 
behaviour envelopes assigned behaviours deemed unassigned deemed free 
specification software architecture specification software architecture uml class diagram describes relationships classes described section 
controller class encapsulates entire application aggregating instance supervisor class aggregates key searchable dictionary behaviour types representation instances list behaviour envelopes 
controller supervisor behaviour envelopes concurrent objects 
controller class specializes thread class 
supervisor behaviour envelopes message passing specialize class specialization thread class 
window specializes 
windows associated multiple representations 
representation class aggregates class associates instances representation 
specializes representation manner composite design pattern gamma helm johnson vlissides realized enables mereological hierarchy 
instance behaviour aggregates classes specializations processnode 
processnode contains instances instance 
sense model plan classes implement methods declared processnode 
behaviour associates daemon associates event window action window 
supervisor maintains list behaviour envelopes process messages posted 
behaviour envelopes associate behaviour class 
class diagram software architecture 
function section structure software framework 
components described manner integrated 
section continues presentation framework describing functional behaviour focussing interactions 
software framework phases operation initialization operation termination subsections 
functional components possible functioning phase software framework described 
functional components subsection discusses functional components possible framework initialisation operation termination 
messaging entity repositories representation change detection 
mechanisms sketched previous section described detail 
messaging messaging enables communication different processes 
controller multiple behaviours executing concurrently behaviour ordination mechanisms needed framework 
supervisor performs ordination ways assigning behaviours behaviour envelopes binding representations windows second sending control messages behaviour envelope initialize start suspend finalize corresponding behaviour 
supervisor process executes concurrently behaviours accepts messages operator initialize reset start suspend finalize controller 
behaviour envelopes supervisor maintain message processing mechanism 
defined class thread message processing mechanism works follows 
thread maintains priority queue messages messages may assigned ascending priorities low low normal high high 
message token represents type optionally additional data 
processes send messages thread locking priority queue writing message 
thread examines head priority queue messages processes dispatches 
message execute idle subroutine available 
calling process bundles data message thread perform necessary memory management 
messages way message replied 
messaging way problems introduced 
find policy dealing processes wait reply may come 
second find policy resolving deadlocks processes waiting reply 
watchdog timers possibly helpful require mechanism handling messaging related exceptions 
exception handling mechanism defined conceptual framework suitable 
sequence diagram describing message passing mechanism 
depicts messaging mechanism uml sequence diagram 
process sends message process stored queue sendmessage 
process receives message sends message handling method 
messages waiting queue called 
entity repositories behaviours share common representations windows able representations replaced framework requires facility maintaining entities 
roles supervisor repository entities controller behaviours behaviour types representations 
supervisor maintains key indexed dictionary types entities controls access 
key entity retrieved supervisor process requests 
example behaviour windows contain list keys representations refer representation system includes internal representations internal windows process nodes 
controller designer specifies keys internal external event action representations compile time 
operator runtime swap keys event action representations 
behaviour created acquires representations supervisor calling supervisor method 
example suppose operator signals supervisor behaviour type activated 
supervisor retrieves specified behaviour type behaviour type dictionary call uses instantiate desired behaviour 
representation change detection behaviours triggered event representations changed behaviour inspected 
representations timestamps updated current system time representations updated 
processing takes place event window performs inspections representations maintains earliest current timestamp event representations 
framework call daemon observe method method invokes method daemon event window 
method returns true representation updated earliest timestamp false 
case timestamp gets updated case timestamp need changed 
initialization section processes surrounding controller initialization described 
controller developer implements subclass controller class declares behaviour envelopes execute behaviour types corresponding behaviour type keys system representations corresponding representation keys 
software framework run controller initialization method invoked framework 
initialization method calls methods method declares behaviour types comprising appropriate daemon processnode derived classes passing supervisor keys stores behaviour types dictionary declares number behaviour envelopes method declares representations passing supervisor keys stores representations dictionary 
process depicted 
processing done controller occurs thread 
sequence diagram describing controller initialisation 
done controller issues supervisor initialize message described 
execution gets passed run method controller 
point controller operator issue message implemented support mechanism discussed section 
initializing supervisor initializing behaviour envelopes 
receipt initialize message supervisor method invoked 
method instantiates specified number behaviour envelopes 
process depicted 
configuring controller proposal controller configurable fly configuration communicated mission language 
software framework provides basic support interpreting mission specification 
framework controller class send message supervisor bundled mission specification intention done operator 
supervisor receives message method gets invoked 
implementation binds instance registered behaviour type behaviour envelope initialize message sent 
initializing behaviours sequence diagram describing behaviour initialisation 
supervisor signals behaviours initialize sending initialize messages behaviour envelopes 
manner behaviour envelopes process described 
receipt initialize message behaviour envelope method invoked 
method performs procedure depicted 
daemon initialize method invoked 
invokes method set event action windows specified representations system 
sets list representation types behaviour respond 
invokes initialize method corresponding behaviour retrieves event action representations daemon 
behaviour initialize method invokes initialize methods process nodes 
sense node retrieves internal event representations behaviour event window act node retrieves internal action representations behaviour action window 
behaviours initialized controller ready start functioning 
operation subsection presents processing occurs framework regular operation 
main kinds processing resetting starting stopping behaviours representation accesses updates behaviour activity triggered chains triggering behaviours 
resetting starting suspending stopping behaviours 
behaviours started stopped reset corresponding behaviour envelopes signalled supervisor 
receiving initialize finalize start suspend reset message behaviour envelope changes behaviour state depending previous state 
start state dead 
behaviour started suspended daemon poll event window 
state changes occur manner described table 
state messages initialize start suspend reset finalize dead initialized initialized started initialized finalized started suspended stopped suspended started stopped stopped started initialized finalized finalized initialized representation accesses table operational state transitions behaviours issues surrounding representations periodically get updated 
update signal propagated hierarchy 
second representations unlocked shortly locked avoid deadlock 
updates representation hierarchies representation hierarchies completely locked writing representations gets updated 
ancestor descendant representations considered updated 
update signal propagate hierarchy 
consider representation field parent points parent representation field children array child representations timestamp field 
noting representation occupies root position hierarchy parent field pointing algorithm describes process 
algorithm update 


algorithm calls recursive algorithms 
algorithm 
timestamp algorithm 
parent 
parent 
parent 
parent 
parent algorithm 
children 



representation updated ancestors descendants updated 
algorithm defines ancestors updated parent representation exists locked writing updated unlocked applies algorithm parent 
recursion ends root representation 
similarly algorithm defines descendants updated child representation locked writing updated unlocked process applied children 
recursion ends representations lowest level hierarchy children 
defined algorithm representation records update updating timestamp current system time 
clear algorithm terminates guarantees locked representation unlocked soon locked 
ensures cause processes stall deadlock 
guaranteeing stalling deadlock access semantics representations introduce problem guaranteeing stalling deadlock 
suppose behaviour locks representation reading unlocks 
behaviour wait lock writing stall 
alternatively suppose behaviour locks representation writing time behaviour locks representation writing 
second behaviour tries lock representation reading behaviour tries lock second representation reading 
deadlock occurs 
situations occur guarantee process unlock resource locked 
controller developer required implement behaviours way guarantee 
difficult 
simplest solution read data representations write data representations approaches 
read done 


field field field field 
copy 

read field write done 
write field 


field field field field 
copy 
obvious drawback approach great quantity data contained representation small subset required behaviour 
case additional computation required runtime determine subset representation locked 
example representation contain pixel map ordinates viewport behaviour ordinates retrieve subset image viewport 
computation may guaranteed successful say computation ensures sensible behaviour results case ordinates invalid 
complex computation difficult provide guarantee 
may necessary resort formal methods prove correctness complex computation 
controller developer advised keep computations simple time representations locked ensure computations provably correct 
happens execute trigger 
daemon detects relevant change event window fairly complex activity results described 
uml sequence diagram depicting happens initiate trigger 
statecharts depicting state changes occurring event trigger 
top activation state bottom execution state 
daemon observes event window behaviour activation state ready execution state standby 
behaviour envelope invokes daemon observe method activation state observing 
event representation updated activation state returns ready 
behaviour trigger method invoked activation state triggered execution state executing 
initiates smpa cycle calling sense method followed model plan act methods 
invokes methods sense model plan act process nodes 
exception generated behaviour complete execution state failed 
execution state succeeded 
cases activation state returns ready 
depicts process depicts state transitions activity state state transitions execution state 
causality chains behaviour updates action representations behaviours having event windows subsequently triggered 
behaviours update action representations causes triggers behaviours 
update trigger termed event confused event window event representation 
chain events emerges consisting behaviours representations associated chain events termed causality chain event causes discussed thesis framework provide support 
event effect said downstream 
event caused event cause said upstream 
consider hypothetical network behaviours representations depicted 
suppose representation triggered 
possible trigger causality chain shown 
circular emerge 
suppose representation triggered 
trigger causality chains exogenous update representation representation update fails directly cause trigger 
different situation trigger indirect cause representation update say case updated representation controls motor causing motion results exogenous update sensor representation 
simply open loop feedback 
behaviour network example 
causality chain decomposed types connectives depict 

start exogenous update representation 

finish endogenous update representation event window 

link behaviours representations causally connected series 

convergence links converge behaviour representation 
happen number behaviours update representation exceeds number behaviours triggered representation number representations trigger behaviour exceeds number representations updated behaviour 

divergence links diverge behaviour representation 
happen number behaviours update representation number behaviours triggered representation number representations trigger behaviour number representations updated behaviour 

cycle link causally connects upstream behaviour representation cycle events recur 
consists convergence divergence connected links 
closed loop feedback 
building behaviour networks causality chain connectives 
network behaviours representations causal relationships trigger conditions called behaviour network 
section considers issues surrounding manual constructions behaviour networks controller designer defines constructions operator role 
examined issues surrounding connecting behaviours representations reuse engineering artefacts behaviours representations note representation granularity 
constructing behaviours networks behaviour networks constructed manually controller designer defining representations declaring representations belong controller defining behaviours declaring instances behaviour types belong controller specifying representations event action representations behaviour 
done writing code 
representation type defined subclassing representation class 
behaviour type defined subclassing processnode classes daemon class 
behaviours representations declared subclassing controller class implementing methods 
controller designer declares representations listing calls method called representation instance unique key passed call 
similarly controller designer declares behaviour types calling method called passing constructor template class parameterized process node subclasses daemon subclass 
behaviours reactive representations tied sensors actuators describe task information goals world models knowledge 
behaviour network naturally hierarchical low level behaviours close sensors actuators reactive high level behaviours closer task information world models 
lowest level behaviours tied closely hardware highly reactive little task information knowledge model information 
conversely highest level behaviours tied closely tasks necessarily need reactive 
discussed background necessary reconcile levels behaviours translate task oriented control reaction oriented control reactive highest levels reactive lowest levels 
high level behaviours process symbolic information low level behaviours process signals higher level behaviours deliberative lower level ones 
conceptually higher level behaviours lower level behaviours tend concrete 
controller designer select names behaviours behaviour network reflect 
code reuse software framework allows reuse behaviours representations 
low level behaviours associated representations hardware specific reused controllers different tasks executed platform 
similarly high level behaviours associated representations task specific tasks different hardware 
key issue behaviours reused event action representations different ones having identical interfaces controller developer substantially modify behaviours suit new ones 
clearly representations common currency interacting behaviours 
controller developers ensure low level behaviours interact reused high level behaviours high level behaviours integrated reused low level behaviours ensuring common representations clearly limits behaviours reusability providing middle go layer behaviours 
preferred helps buffer higher layers reactivity lower behaviours buffer lower layers reactivity potentially sluggish deliberation higher layers 
reusability behaviours limited common currency problem software framework affords greater reusability approaches 
behaviour reuse possible tasks subsumption layers behaviours evolved lower layers definitions depend lower layers lowest dependent hardware 
approach mataric aims support behaviour reuse propose behaviour libraries 
intent reuse behaviours tasks platform 
behaviour approaches limited way behaviours tied directly sensors actuators fact seen skills combined executing different kinds tasks 
hierarchical approaches afford reuse components integration deliberative reactive layers rigid allow reuse components different systems 
designed different components integrated hierarchical architecture 
representation granularity glance appears representations defined software framework encapsulate data representations described proposal levels granularity appears differ approaches 
representation hierarchies functions possible event windows behaviours open different subsets representation allow behaviours lock subsets representation needed 
expect atomic representations typically encapsulate fairly small amount data 
appears contrast manner representations described proposal tsotsos representations contain great amount data 
example proposal describes single representation called environment maintains representations robot environment suggests may include priori map models landmarks models known objects framework environment representation constitute hierarchy representations having maps landmark models models known objects children environment 
noted software framework capable treating root representation hierarchy single representation 
manner representations necessarily low level granularity tsotsos concept preserved 
chapter chapter demonstrations chapter evaluates number conceptual components 
section aspects software framework evaluated simulation particularly representations task directed perception maintaining concepts forms basis rest chapter 
section compares behaviour control architectures discusses ideas implemented 
section discusses widely observed tradeoff phenomenon deliberation reactivity occurs 
section discusses problems disadvantages current software framework suggests solutions disadvantages 
controller demonstrations section aspects software framework demonstrated simulation 
thesis focuses discussion dichotomy deliberation reactivity representation 
focus demonstrations representations combination deliberation reactivity 
representations task directed perception concepts 
demonstrate shot feedback triggering causality chains behaviour augmentation goal detection spatial planning 
demonstrations evaluate representation hierarchies dynamic event windows 
representation hierarchies evaluated discussion falls outside scope thesis 
implemented sake completeness evaluation left 
discuss simulated environment demonstrate 
demonstrations uses task directed perception visually identify targets navigate uses conceptual representation perform map building exercise 
virtual reality simulator replace experimentation physical robot graphical simulations useful rapid prototyping behaviours missions developing testing new architectures 
part research effort graphical simulator mobile planetary rover flat terrain developed interface software controllers 
testing 
complete account structure function provided 
provide summary 
simulator comprised simulation visualization components provides generic interface 
simulation maintains kinematics rover locomotion manipulator mobile sensor systems provides sensory inputs controller 
visualization module generates simulated stereo camera views various mechanical optical characteristics representing terrain features simulating varying lighting conditions 
controller need aware running physical platform simulation interface provides controller simulated sensor signals accepts actuator signals 
components system easily extended modified order accommodate various requirements 
current implementation restricted representation obstacles essentially flat world 
simulated robot platform collection sensors 
sensor array contains sixteen collision proximity sensors limited range spatial units ordinate system simulator stereo camera mounted actuated mast 
contains locomotion systems differential drive mobility system mast stereo camera system degrees freedom height roll pitch yaw 
simulate kinematics real locomotion system implementing limits acceleration speed angles rotation 
accept commands level high level commands move forward distance turn left angle low level commands set left motor speed value visual display virtual reality simulator 
shows visual display provided controller 
stereo camera images top 
bottom left visual representations bumpers proximity sensors bottom right bird eye view world 
bird eye view rover denoted brown circle centre 
white dots represent focal points cameras white lines denote boundaries visual fields 
oriented direction travel upwards image stereo cameras looking leftwards 
bumper representation large circle denotes robot small white circles surrounding denote bumpers coloured white activated turn red 
proximity sensor representation red circle denotes robot detected free space range sensor marked white corona 
demonstrations 
bug controller demonstration controller called bug uses task directed perception visually identify targets navigate priori map 
robot performs random walk terrain searching target list targets 
approaches close moves target 
behaviour network explained 
description execution observations 
detailed descriptions behaviours representations appendix 
behaviour network depicts behaviour network implied behaviour descriptions appendix 
dynamics reactive subnetwork straightforward 
walk node reactive behaviour controls actuator current pose desired motion 
triggers updating changing event representations ensuring behaviour correcting platform motion 
navigate behaviour frequently triggered execution time planning times execution time walk sufficiently responsive avoid collisions 
navigate walk behaviours considered low level note navigate behaviour platform oriented task oriented behaviours 
deliberative due planning considered part reactive subnetwork 
detect acquisition stereo camera images proximity detectors bumpers task attend acquire target colour percept navigation type target location camera mast track navigate heading walk motors map pose task queue behaviour network diagram bug controller 
dynamics perception task oriented subnetworks straightforward 
receiving instruction move task inspecting task representation acquire behaviour selects task task queue representation description target acquire writes task related information target colour representation colour target 
attend behaviour isolate largest blobs colour robot field view report percept 
track behaviour uses control mast navigation mode robot search environment target 
seen camera mast manipulated maintain fix target fix achieved target position estimated 
navigate behaviour position plot shortest path manoeuvre platform 
platform spatial units target staring directly detect acquisition recognizes situation signals task performed 
execution controller executed simulator 
run task sequence visit red green red green blue targets order 
screenshot depicted robot startup 
shows robot front green target starting position searching visually red target 
step shown robot red target tracking estimating position 
note position estimation errors cause planner find path minimum brings robot vicinity target 
robot reached target 
shortly point detects task complete continues finding task task list acquire green target 
robot tracking green target estimated position planning path 
reaches green target selects target task queue acquire red target plots path shown 
red target reached robot navigates green target shown 
robot returns green target 
shown reached proceeds search blue target 
shows robot tracking blue target starting navigate 
see robot reached blue target 
robot navigating red target tracking 
robot reached red target 
robot tracking green target 
having acquired green target robot locates navigates red target 
robot reached red target locked position green navigating 
robot reaching green target 
having reached green target robot searches blue target 
robot tracks blue target observations robot reached blue target 
ask reader bear mind claim controller optimal design 
controller considered na attempt decomposing control problem 
words goal build see happens may learn behaviours representations interact 
immediately observable tradeoff deliberation reactivity controller 
navigate reactivity limited speed planner 
planning absent walk execute quickly reactivity greater 
natural solution decouple planner navigate augmented behaviour 
way nt star mode navigate compute responses collisions write response sooner heading 
apply technique controller described subsection 
occasionally problem occurs acquisition detection mechanism 
detects target proximity sends task flag true 
acquire behaviour selects task saves colour target colour drops task flag false 
attend triggered process new target colour information update percept track may re written target position direction target direction old centroid positions percept 
triggers sees target close sets task flag true 
causes acquire move task previous task lost completed 
solution representations maintain state histories manner described chapter 
say track writes new target locations target location save old target location 
way detect acquisition examine target location history see target changed 
need raise flag task 
achieved strengthening behaviour precondition include test 
advantage solution solves problem modification point system widely accepted principle software engineering known single choice principle meyer 
solution behaviour inhibition network designer include mechanism having acquire inhibit track triggering written target colour representation 
way attend triggered track track trigger occur attend updated percept 
track may triggered daemon scheduled execute time gets reading state percept earlier trigger attend 
effective solution aware acquire moving new task case triggered moment 
solution acquire clear percept target direction 
problem approaches conceptual unreasonable acquire concerned side effects caused track detect acquisition vice versa separate modules 
furthermore doing limit usability track networks acquire behaviour way 
verify second solution mentioned implemented managed remove problem subsequent runs 
realized strengthening precondition track daemon ensure target colour updated time 
way modification happened behaviour network level abstraction behaviour level abstraction fool proof considering asynchronous system 
reason prefer solution involves state histories representations 
general appears strengthening behaviour preconditions may behaviours representations integrated network ensure meaningful behaviour needing change behaviour implementations 
second demonstration controller called uses conceptual representation perform map building exercise 
robot explores world selecting goal locations mapped uses existing map proximity sensors perform path planning collision avoidance 
behaviour network explained 
description execution observations 
individual behaviours representations described appendix 
behaviour network depicts behaviour network 
bug controller walk behaviour accepts input heading pose representations selects appropriate locomotor adjustment writing output locomotor representation 
updates heading representation continually re trigger 
navigate behaviour accepts input sensors pose target map representations event window 
depending situation performs collision avoidance follows planned path current target 
augmented plan behaviour finds shortest path map reports step path navigate goal position representation 
uses pose proximity sensor representations compute locations obstacles update map 
explore behaviour checks map see robot currently path 
path small behaviour selects new target location navigate writes target 
resolution map higher case bug represents boundaries thicker avoid planning paths lead robot boundaries 
explore build map map proximity detectors bumpers target plan navigate pose goal position heading walk behaviour network diagram motors execution proceeds follows 
initially map contains unknowns planned path exists 
explore behaviour immediately triggered selects target location unknown 
point navigation behaviour triggered plan behaviour 
goal position computed robot travel 
plan behaviour eventually completes having written path map having selected location travel stored goal position 
eventually navigate behaviour act node examines goal position external action window selects direction displacement type target 
robot moves behaviour updates map detects obstacles 
particular location unreachable outside boundary world say plan behaviour succeed finding path store path result map 
explore behaviour detect select new target location 
way target position reachable 
entire space mapped continue explore environment explore occasionally selects position thought traversable 
changes environment registered changes introduced simulation 
note map conceptual representation controller applies region classification learn environment 
explore navigate plan behaviours depend determine controller actions turn influence state 
execution execution occurs follows 
controller starts selecting goal position planning path building map 
see robot path goal position navigating corner 
soon robot reaches goal robot selects new goal path depicted 
obstacles sensor range mapped operation 
obstacles discovered planner may select new path case 
robot follows new path doing discovers entire area boundary extends edge map new path discovered 
depicts robot navigating corner order follow path 
see path discovered 
new path leads robot discover area new path selected 
eventually robot discovers impossible map complete 
regardless robot selects goal map gets reinforced complete map shown 
execution begins area surrounding robot immediately mapped 
target selected 
robot navigates corner mapping corridor time 
robot reached goal 
obstacles get mapped enter sensor range 
goal reached new goal selected 
boundary discovered path 
region outside map area planner finds path direction 
robot navigates corner 
robot discovers terrain old path selects path 
path soon discovered new selected 
robot navigates new path finishing map construction 
path discovered new selected 
observations controller successfully demonstrates mechanisms behaviour augmentation conceptual representation 
behaviour augmentation navigate behaviour reactive bug controller 
planning placed separate process result available 
consequence move quickly bug 
note result plan computation input navigate behaviour manner similar hybrid architectures main goal broken subgoals reactive layer subgoal parameter 
map conceptual representation ties activities behaviours performing sensing action control learning 
map informs explore areas environment ought send robot exploration forms basis motion planning 
continually updates influencing explore plan behaviour 
comparative evaluation section architecture compared known behaviour hybrid non hybrid approaches robot control 
utility concepts discussed 
assessing list criteria developed arkin 
purpose criteria measure architecture utility particular problem 
accepted method evaluating architectures evaluation complete 
list follows assessment item 

support parallelism 
behaviour systems inherently parallel nature architecture provide capability 
exception behaviours able execute parallel behaviour computations may parallelized behaviour augmentation mechanism 

hardware 
respect aspects hardware real robotic systems sensors actuators immersed environment chip level hardware implementation preferred software due superior performance 
respect unproven controller evaluated simulation 
second respect limited 
software framework exists desirable behaviours execute dedicated processors 
possible proved 
realized strictly programmable logic arrays brooks done subsumption brooks 

niche 
respect architecture fit robot operating environment manner robot relates environment ensure successful niche occupation 
domain implementation exists real hardware 
mentioned chapter fitting robot environment simple defining low level behaviours representations 

support modularity 
refers methods architecture provides encapsulating behavioural abstractions 
discussed chapter software framework completely modular object oriented supports design time reuse behaviours representations supports run time reconfiguration behaviours representations supports run time elimination behaviours 

robustness 
refers ability system perform face failing components mechanisms fault tolerance 
exception handling mechanism proposed tsotsos intended precisely sake fault tolerance 
mechanism implemented 
controller low level behaviours highly reactive sort robustness behaviour systems afforded 

timeliness development 
refers sorts tools development environments available implement controllers conform architecture 
potential rapid development controller applications aid tools 
behaviours representations created inheriting classes manual configurations done straightforward manner developer need worry behaviours representations controller configuration 
controllers section implemented visual microsoft developer studio contains simple wizards creating classes managing repositories classes version control 
easily extended support full suite controller development tools straightforward manner 
tools exist suitable 

run time flexibility 
refers ability control system reconfigured adjusted runtime ease adaptation learning methods introduced 
controller easily modified runtime described 
presently adaptation learning behaviours possible behaviours precluded executing machine learning algorithms 
study learning suitable 

performance effectiveness 
refers metrics constructed robot perform tasks encompasses timeliness capabilities achieving real time deadlines operational constraints 
measurements real implementation exists 
furthermore current software framework support real time deadlines operational constraints feature mission language outside scope thesis 
treats 
subsections architecture compared control methodologies utility concepts assessed 
behaviour approaches subsection compares behaviour control architectures 
claim generalization purely behaviour approaches demonstrate showing behaviour controllers cast controllers 
compared general behaviour controller 
continue special treatment brooks subsumption mataric additions maes activation spreading arkin schema 
discussion comparisons approaches 
generic behaviour controllers behaviour architecture conforms description background easily cast controller 
controller depicted cast generic controller depicted 
behaviours replace generic behaviours mapping sensors actuators simple sense act nodes perform mapping 
share event representations representations sensors signals exogenous perception systems 
behaviour stores response action representation action representations feed behaviour performs ordination competition processing 
behaviour computes actuator response 
sensor sensor sensor sensor sensor behaviour behaviour behaviour behaviour behaviour response response response response response ordinate generic behaviour controller 
approach may completely implemented hardware approach actuators disadvantage approach introduces delays associated causality chains 
generic approach assumed perform computation negligible execution time controller wait triggers occur 
generic necessarily implemented software behaviour executes dedicated embedded processor 
subsumption compared 
comparing subsumption controller built cast subsumption controller described background 
depiction controller 
behaviours implement condition action rules subsumption behaviour replace 
representations communicate signals behaviours 
subsumption implemented ways behaviours augment behaviours priority network implemented conflict resolution stage additional behaviours arbitrate representations selecting higher layer lower layer 
go behaviour special representation reset allows collide behaviour trigger reset 
subsumption approach notable attributes handshake free low bandwidth communication behaviours lower layers fully accessible higher layer priority networks simple behaviour competition scheme successful behaviours reset behaviours architecture evolvable signals grounded environment subsumption hardware notably architecture evolvable ground 
compete simplicity interaction behaviours fact hardware 
software implementation subsumption efficient cast manner described due having wait daemons recognize trigger events 
sensors wander run away collide direction reset going forward lost reverse go reversing controller reproducing subsumption example 
superior important respects 
reconfigured different tasks having controller recompiled 
subsumption behaviours organized layers layers evolved top primitive layers 
high level behaviours task specific dependent hardware specific behaviours behaviour reuse feasible task platforms 
high level behaviours developed independently low level behaviours reused task platforms 
restriction mid level behaviours exist reconcile 
view behaviours skills notion skill competence specific task apply behaviours architectures evolved bottom competence decoupled hardware 
motors brakes second subsumption suffers scaling problem outlined background easily solved 
third explicit representation renders task directed perception conceptual representation substantially easier subsumption mataric method comparison 
comparing spreading activation networks behaviour network constructed cast spreading activation module 
depicts controller cast spreading activation network 
competence modules represented behaviours add delete lists hard coded behaviour 
behaviour representation event window maintains condition list activation level 
predecessor successor links re cast having representation predecessor behaviour action representation successor behaviour 
manner successor behaviour activated adds relevant terms predecessor spreading activation appear add list 
links cast having representation conflicting behaviour action representation conflicted behaviour 
manner conflicted behaviour activated removes relevant terms conflicting behaviour 
behaviours trigger activation level determined condition list exceeds activation threshold 
behaviours event action representations sensors actuators respectively activity controller resemble maes controllers 
condition condition condition condition module module module module sensors actuators sensors actuators cast spreading activation network example 
disadvantages maes architecture activation selection architecture known chaotic may enter infinite loops guarantee progress modules parameterised limited capabilities goals explicitly specified variables go goals specified representations 
controllers limitation behaviours parameterised event representations goals expressed explicitly 
comparing arkin schema behaviours controller configured operate manner schema controllers 
depicts replica schema controller 
behaviour relevant sensor representations event window perceptual algorithms implemented sense node 
act node performs mapping perception action 
behaviours action representation type schema event representations combine behaviour 
combine behaviour scales schema weight vector maintained gain event representation writes output gradient descent computation actuator representation 
es es es ps ps pss pss ps result ps result pss result pss result ps ps result ms ms result ms result ms cast schema example 
advantages schema approach highly robust approach completely parallelized schema software objects added removed reconfigured run time modifying weights behaviours maintained behaviour repository reused 
true behaviours execute concurrently added removed representations reassigned run time behaviour types maintained repository 
approach number disadvantages shares 
significant disadvantage schema approach suffers scaling problem behaviour perform perceptual processing task driven intermediate representations shared sum weights behaviours 
limitation discussed 
motors disadvantage schema approach gradient descent mechanism may get stuck local minima 
solutions vector field perturbed noise affects accuracy control scheme snapshot short term past maintained indicate path robot taken avoid 
analogous situation occur threatened invalidate operational constraint responsibility sort monitoring behaviour detect situation simple timer perform sort corrective action 
purpose thesis hypothetical evaluated support constraint monitoring mission language 
hybrid approaches subsection compare hybrid approaches control discussed background 
claim unified approach supporting deliberation reactivity generalization hybrid approaches 
support claim demonstrating hybrid approaches cast controllers comparing interface strategies identified arkin background selection strategy advising strategy adaptation strategy postponement strategy 
selection strategy selection strategy deliberative layer configures behavioural composition parameters execution may reconfigure event system failure 
configuration able execute complete task 
recall aura controller arkin described chapter 
chapter depicts controller 
cast controller depicted 
deliberative layer modelled hierarchical organization behaviours representations mode action representations 
describes behaviours currently allowed triggered second contains operating parameters behaviours 
event representations behaviours reactive layer 
set control behaviours share percept representations input compute output 
outputs subsequently combined coordinator behaviour determines signals accept mode representation 
percept representations event window level planner consisting plan sequencer behaviour spatial reasoner behaviour mission planner behaviour 
mission planner behaviour communicates high level plan spatial reasoner representation 
decomposes low level plan communicated plan sequencer representation 
plan sequencer selects suitable mode roster control behaviours current point plan 
functionally identical analogies aura 
es es es ps ps pss pss mission planner spatial reasoner plan sequencer parameters ps result ps result pss result pss result ps ps result ms ms result ms result ms realisation selection strategy 
weights sum representation approach deliberative layer configures reactive layer selecting values representations essentially specify manner low level behaviours function 
illustrates behaviours individually deliberative reactive behaviours structurally uniform 
note interface deliberative layer reactive layer provided representations interact 
chief advantage claimed aura interface affords modularity 
true cast controller reactive layer depends interface mode representations function deliberative layer 
top layer changed substantially limiting lower level way 
motors advising strategy advising strategy deliberative layer establishes intent agent reactive control system may ignore unsafe 
configuration able execute complete task 
atlantis architecture gat described chapter uses strategy depicts architecture 
cast controller depicted 
sequencer behaviour essentially controls execution system 
essentially decomposes plan subtasks commissions reactive behaviour execute failure occurs 
subtasks complete detected perceptual information selects subsequent subtask 
augmenting behaviour shares perceptual information generates plan may may followed sequencer 
behaviours responsible monitoring state system augment sequencer 
detect failure controller inform sequencer may perform suitable action signal re plan 
select appropriate step plan sequencer stores action command activation representation 
controller simply translates action appropriate roster reactive behaviours execute 
separate perception behaviours compute perceptual information sequencer reactive behaviours 
reactive behaviours compute responses subsequently combined coordinator behaviour computes actuator signals 
sequencer status activation external perceptual system percepts controller configuration beh beh beh beh ps result ps result pss result pss result realisation advising strategy 
ordinate motors noted benefits atlantis architecture advising strategy results deliberation flexible cognizant failures detected trigger replanning 
behaviour augmentation different purposes generate plans monitor execution errors 
potential realizing benefits 
advantage atlantis reactive layer implemented combinational circuits substantially reactive controller 
behaviour network constituting reactive layer reconfigured runtime reactive layer atlantis 
interesting property controller high degree deliberation highest layer lesser middle layer lowest layer 
conversely reactivity highest lowest layer lesser middle layer highest layer 
possible precluded fact components structurally uniform 
adaptation strategy adaptation strategy deliberative layer continuously reconfigures reactive layer adaptive manner world situation task information changes 
configuration able execute complete task 
planner reactor architecture pr lyons hendriks chapter uses adaptation strategy 
depicts architecture 
partly cast controller due limitation behaviours configure behaviour networks 
example include exception handling mechanism proposed tsotsos described chapter 
controller depicted 
simple deliberative layer consisting planner behaviour generates subsequently modifies high level plan system perceptual information event exception raised 
manner deliberation adaptive 
reactive system lyons hendriks rs model chapter reactive architecture really representation flexible plans executed decisions 
reactive layer controller possible cast model 
consists executor behaviour number reactive behaviours augment 
reactive behaviours perceptual information percepts cluster representations compute independent results executor 
executor uses information configuration representation provide operating parameters reactive behaviours ordinate results 
outputs commands actuator writing actuators cluster representations 
case cognizant failure executor may throw exceptions caught deliberative layer 
goals external perceptual system reactive suite percepts configuration step take 
catches exceptions thrown executor event planner adapter executor beh beh beh beh actuators actuators actuators realization adaptation strategy 
bridging deliberative reactive layers executor able follow high level plan generate required configuration reactive layer 
uses information status determine particular configuration completed move step plan 
uses perceptual information percepts decide reactive controller encountered problem 
resolve problem selecting different configuration satisfy plan exception planner modifies plan 
advantage pr model deliberative layer completely reconfigure rs layer injecting removing perceptual components action components conditions 
deliberative behaviours modify reactive behaviour parameters writing representations read 
pr model fact share representations perceptual processing occurs behaviour 
scaling problem issue rs 
components act behaviours necessarily platform dependent 
replanning triggered reactive layer halt activity reconfigured dangerous 
controller continue react sensibly environment configuration regenerated 
demonstrates utility including exception handling mechanism 
adapting plans simple done response exceptions planner executor required perceive error independently 
disadvantage current software framework exception handling mechanism implemented 
controller far simpler behaviours modify behaviour networks 
suppose behaviour system representation described configuration contained list event representations 
behaviour modify behaviours event window writing configuration representations reconfigure behaviour network 
fact tsotsos proposes single representation ew event windows system 
performing observation event windows daemons required access 
implementation allows daemon spawn multiple instances type behaviour described chapter necessary store window information representation probably difficult track instance behaviour 
implementation investigated thesis described chapter easier couple behaviour representation number instances remains fixed 
postponement strategy postponement strategy deliberative layer reconfigures reactive layer opportunistic manner world changed necessitate reconfiguration 
doing controller takes advantage available perceptual information generate plans effective relevant generated earlier 
procedural reasoning system prs georgeff lansky described chapter uses strategy 
depicts prs architecture cast controller 
depicts controller 
prs reactivity controller respect tight mapping perception action responsiveness planner state changes world 
sensor actuator representations event action windows perception action behaviours behaviours directly interact 
perception behaviour maintains beliefs held controller world state beliefs representation 
action representation realizes intent controller stored intentions representation generating actuator commands provide suitable behaviour 
interpreter behaviour augmented planner behaviour performs planning robot beliefs desires stored desire representation current intentions 
interpreter carries current plan new beliefs desires arise point augmenting planner behaviour may generate new symbolic plan interpreter may elect adopt 
sensors sensors sensors desires goals beliefs planner interpreter perception action intent example postponement strategy 
plan actuators actuators actuators prs approach successfully control unmanned military vehicles 
disadvantage approach interpreter cycle time necessarily fast reactive 
safety guaranteed 
great deal critical processing occurs interpreter requirement probably limits capabilities connection perception action fairly loose 
controller entities comprising reactive path sensor representations perception behaviour beliefs interpreter behaviour intention representation action behaviour actuator representations 
causality chain longer reactive chains seen earlier perception directly coupled action 
approach reactivity seen occurring perception behaviour interpreter reactively trigger planning 
deliberation reactive 
consistent notion deliberation reactivity system necessarily realized separate components 
demonstrates utility implementing behaviour smpa process entity traditionally seen purely reactive performs deliberative function 
non hybrid approaches section compared non hybrid approaches exist literature hierarchical behaviour architecture samba architecture 
note attribute common approaches hybrid different systems 
approach completely uniform second approach completely heterogeneous 
described chapter cast controllers 
hierarchical behaviour architecture hierarchical behaviour architecture mataric chapter distributes deliberation behaviours signal activation primitive behaviours 
behaviours communicate satisfaction preconditions inhibition requests manner closely related activation spreading executing plans reactive manner 
depicts behaviour pure behaviour depicts behaviour network chapter 
percepts percepts percepts inhibit cond inhibit cond inhibit cond ab pb ab pb perceptual processing 
primitive behaviours compute action ab status status status pb behaviour network cast 
pb percepts actuators behaviour network cast controller depicted 
primitive behaviour pb shares primitive behaviour status pbs representation behaviour ab describes behaviour active continue 
read write 
behaviours read sensory information environment perform ordinated ordinator behaviour behaviours determine task completed manner mirror 
behaviour reads behaviour status abs representation maintains inhibition flag list flags denoting precondition 
writes effect behaviour status representations emergent chain mirrors behaviour network 
minor differences proposed controller 
relies underlying hardware allow behaviours block tries access busy actuator 
ensures conflicts actuator decisions 
approach hand relies behaviour ordinate signals primitive behaviours continue operate 
advantages 
behaviours communicate tcp ports execute platform 
interprocess communication high bandwidth simply relies mutexes locking shared memory 
tremendous overhead associated tcp ip communication exist 
second behaviours perform perceptual processing share representations perform task directed perceptual processing 
third sort deliberation selects behaviours manner strips operators select actions allow sort distributed deliberation perform spatial path planning 
samba architecture samba architecture chapter non hybrid approach 
strength solves scaling problem internal representations called markers purposes integrating perception action activating reactive behaviours performing task directed perception 
depiction 
goals plans features features features task attend attend attend attend salient features salient features salient features salient features task beh task beh task beh task beh reactive beh reactive beh reactive beh reactive beh response response response response response response response response samba cast controller 
arbitrator actuators arbitrator samba controller cast controller depicted 
samba focuses markers variety functions 
notably maintains task knowledge selects features salient task output reactive behaviours 
feature representations feed reactive behaviours purposive behaviours behaviour subnetwork manages markers 
reactive behaviours compute motor responses 
salient features event representation stores weighted response response representation 
arbiter behaviour accepts response representations sends actuators response manner performed samba arbiters 
purposive behaviours enable task directed behaviour 
select necessary reactive behaviours required perform task generating proposed selections behaviours tasks 
response combined arbiter behaviour writes winner task selection representations 
representations attend behaviours enable provide input reactive behaviours reactive behaviour coupled attend behaviour 
attend behaviour task selection select features salient task feed corresponding reactive behaviour selected activation 
purposive behaviours receive information current task feature information current selection monitor activity system ensure tasks executed 
re plan 
disadvantage samba constituent parts heterogeneous 
behaviours representations far simpler 
hand markers enabled learning multiagent systems samba agents communicate markers learn adapting behaviours produce responses stimuli previously observed successful 
successfully multiple operating agents matches 
demonstrated multiagent systems learning behaviours considered 
samba illustrates interesting practices combining deliberative processing reactive processing representations task information attentive processing 
controller sketch suggests practices incorporated controller designs 
section compared behaviour approaches including traditional behaviour architectures approaches integrate reactivity including hybrid approaches non hybrid approaches 
comparison involved describing suggested controllers structurally functionally similar approaches take advantage best practices 
involved comparing relative strengths weaknesses approach 
proposed controllers conclude successfully realize capabilities best practices approaches 
identified limitations 
case traditional behaviour controllers successful natural consequence fact behaviours generalizations traditional behaviours 
disadvantage traditional behaviours realized hardware capability demonstrated 
case hybrid controllers success due fact deliberative behaviours interact reactive behaviours simply controlling parameters event representations 
similarly reactive behaviours communicate state reactive layer deliberative layer representations 
high level task oriented behaviours low level platform oriented behaviours usually bridged middle layer layer usually translates symbolic representations operating parameters usually monitors reactive layer execution problems communicated higher layers symbolically 
hierarchical planners decomposed behaviours responsible planning reactive behaviours ordinated dedicated behaviour 
best practices hybrid controllers incorporated controllers 
better behaviours allowed perform modelling planning symbolic computation restricted high level behaviours signal processing restricted low level behaviours 
case non hybrid approaches best practices underlying philosophy includes underlying philosophies 
treats deliberation reactivity uniformly 
representations deliberation distributed behaviours manner 
better deliberation occur behaviours restricted sort uses 
better case samba behaviours able communicate task information perform task directed perception sharing representations 
note cast samba architecture resembles versions hierarchical controllers high level deliberative behaviours interacting low level reactive behaviours middle layer uses representations maintaining task information state reactive controller 
perceptual information communicated deliberative layer reactive layer 
close inspection apparent general trend emerged respect distribution sensory information 
just mentioned task oriented behaviours platform oriented behaviours require task oriented behaviours greater amount perceptual information reactive layer 
reactive layer tied sensory information short pathway guided control information task oriented behaviours 
trend pathway observed arkin best practice design hybrid systems termed reactive 
directly ties perception action permitting coexistence plans actions arkin approach kelly levine notion consistent neisser notions action oriented perception neisser 
perceptual sensors perception action actuators information perception memory memory memory perception action reactive high level high level high level action reactive 
intent deliberation versus reactivity recall reactivity property time stimulus system response stimulus fast deliberation property computations symbolic representations system 
discussed chapter researchers observed natural tradeoff deliberation reactivity control systems 
tradeoff appears occur despite unified treatment deliberative capability property reactivity 
tradeoff occur behaviours defined behaviours interact 
behaviours faster execution times obviously reactive slower execution times 
explained chapter low level behaviours necessarily reactive tied closely sensors actuators robot 
high level behaviours necessarily reactive deliberative task related information knowledge close hardware 
high level behaviours may perform symbolic computations computations may fast behaviours reactive 
surprising levesque lesperance describe purely symbolic rules reactive levesque ng 
source tradeoff entire system 
source tradeoff entire system occurs behaviours integrated networks 
related length causality chains longer causality chains system reactive takes longer time information acquired sensors result response actuators 
causality chains lengthened ways lengthened links number intermediate representations behaviours lengthen number cycles organized serially parallel concentric due hierarchical organization higher level behaviours representations lower levels deliberative higher levels compute response affects lower levels 
cycles feedback loops usually involve sort deliberative decision 
intermediate representations link daemons making decisions trigger form deliberation 
length causality chains thought reflect degree deliberation controller tradeoff 
problems disadvantages software framework previous sections evaluated various aspects software framework mechanisms shown 
section disadvantages framework discussed problems encountered evaluation discussed 
behaviour augmentation distinct advantages control architectures concept behaviour augmentation 
allows parallelization computations enables hierarchical organization processes manner similar albus rcs permits take advantage brooks layering concept 
questions remain disadvantages behaviour augmentation 
problem conflict resolution process node augmenting behaviour solved general 
controller developer implement ad hoc conflict resolution computations specific behaviours 
augmenting behaviour modified conflict resolution computation limits reuse augmented behaviours 
disadvantage augmentation structure static changed suit interpretation mission language interpretation required 
mission language investigation consider behaviour augmentation question remains unanswered 
behaviour conflict problem known behaviour conflict problem arkin peculiar behaviour systems 
occurs behaviours poorly designed system compute responses negate way realized system deployed 
behaviour conflict problem uncovered systems undergo redesign validation 
example behaviour designed move robot forwards conflict behaviour designed move robot backwards event close obstacle 
behaviour moves robot desired target immediately second behaviour detects obstacle sends signal move backwards alternatively priority network prefer second behaviour signal 
sufficiently far away behaviour active robot proceeds target 
phenomenon happen behaviours compute responses cancel behaviour ordination phase 
results stalling controller readily apparent traditional behaviour systems 
problem occur poorly designed controllers 
unfortunately apparent conflicts involve internal representations stalling may readily observable 
example consider behaviours boolean valued representations behaviours read write suppose triggered set true changes false triggered set false changes true 
suppose third behaviour simply reads value writes fourth behaviour compute actuator action function representations 
situation conflict exists result may easily observed 
solution controller designer aware possibility design controller way avoid 
simplest solution ensure cycles exist behaviour network correct 
may limit reusability behaviours representations may modified overcome behaviour conflict problems particular controller 
possible solution modify allow behaviours inhibit behaviours 
controller designer recognizes possibility behaviours conflict specify behaviour inhibit declaring inhibition link way maes activation spreading functions maes 
disadvantage behaviour designer aware possibility inhibition link 
approach extensively successful strict behaviour systems 
developed system generating links preconditions behaviours common disjuncts inhibition link required behaviour activated having opportunity impede 
easily applied preconditions order propositions disjuncts easily compared preconditions 
conceivable solve problem maintaining representation state histories exception handling mechanism originally proposed tsotsos 
case designer perceives behaviours may interfere examine event representations recurring states time interval read write exception record implement token passing mechanism 
suppose behaviours stalling exception token behaviour writes exception record indicate believes may involved behaviour conflict 
triggered behaviour senses event representations appear recurring states sense node finds stalling exception exception record puts stalling exception exception record terminates smpa cycle 
finds stalling exception terminates 
proceeds 
behaviour complete effect eroded competing behaviour token passing behaviour allowed execute 
disadvantage approach may smpa cycles block safety liveness sacrificed 
problems usually discovered system deployed removing behaviour conflicts system time resource intensive process 
valuable find general solution eliminates need redesign systems 
possible solution find algorithm detecting occurrence behaviour conflict proof procedure guaranteeing happens 
number methods available detecting resolving deadlocks distributed systems field lend insight 
common currency problem behaviour system behaviours interact communicate formalism 
behaviours share formalism communicating termed common currency problem 
common issue behaviour systems discussed 
communication behaviours happens common representations 
representations interfaces constitute common currency 
advantage respect common currency problem approaches behaviours communicate share representation type 
need share predetermined connection connection determined changed run time 
course suitable interpreting mission languages explored 
architectures include brooks subsumption approach majority hybrid approaches reactive components consist modular rules simple ad hoc bits code 
chapter chapter thesis implementation validation aspects conceptual framework robot control introduced tsotsos tsotsos 
thesis began chapter presentation paradigms robot control emerged past years predominantly deliberative horizontal approaches dominated ai thinking predominantly reactive vertical approaches served challenge thinking 
discussion limitations vertical approach discussed especially need representation due scaling problem benefits maintaining concepts 
need deliberative processing reactive systems introduced tradeoffs deliberation reactivity noted 
informed subsequent presentation attempts support control systems 
hybrid approaches seek integrate modules deliberation modules reactivity interface strategies 
hybrid approach revealed false notions nature attributes deliberative reactive mechanisms necessarily constitute separate modules integrated 
non hybrid approaches sought combine different approaches limitations examined 
discussion uncovered mechanisms attributes necessary inclusion conceptual framework robot control goal maximize capability reliably achieving goals 
introduced conceptual approach supports mechanisms embraces attributes 
reactive system supports deliberation perform complete smpa cycle 
conceptually simple architecture lends construction controllers uniform components avoids rigidity inherent deliberation reactivity decomposition hybrid systems 
chapter introduced specialization order simplify evaluation examined theoretical aspects 
conceptual framework introduced entities described 
method formally specifying introduced applied simulating counter turing machine sketch proof turing equivalence 
implication proof sketch exists universal set behaviours representations computable problem solved set 
implied mission specification language define trigger conditions assign states representations turing equivalent 
chapter software framework software substrate supporting development robot controllers conform principles outlined tsotsos 
implementation details aspects implementation treated tsotsos design decisions supported justifications respect conceptual framework 
software framework described perspectives structural functional structures processes specified uml 
particular interest message passing ordinating behaviours hierarchies representations supporting variety properties conceptual framework behaviour triggering mechanism mechanisms supporting mission language 
chapter concludes discussion building behaviour networks focusing software framework implement controllers 
hierarchical organization behaviours discussed suggested task oriented behaviours higher level platform oriented behaviours 
discuss software framework enables reuse engineering artefacts behaviours representations 
chapter presents evaluation components conceptual framework applying software framework build controllers evaluate simulation 
controller uses task directed perception visually identify targets navigate priori map 
robot performs random walk terrain searching target list targets 
approaches close moves target 
second controller uses conceptual representation perform map building exercise 
explores unmapped parts environment constructs map subsequently uses perform path planning aid exploration 
focus demonstrations representations combination deliberation reactivity 
representations task directed perception maintaining concepts 
demonstrated shot feedback triggering causality chains behaviour augmentation goal detection spatial planning 
utility concepts comparing approaches chapter 
controllers shown simulate reproduce capabilities existing approaches demonstrating sufficiently flexible allow incorporation best practices seen far 
reactive distribute deliberative processing behaviours 
particular interest fact incorporate interface strategies hybrid controllers demonstrates generalizes hybrids 
better hybrid approaches deliberation occur architecture reactive easily implemented task directed perception supported 
case controller tradeoffs deliberation reactivity observed 
length causality chains determined presence deliberation placement representations behaviour network thought reflect degree deliberation controller tradeoff 
partly validated number interesting limitations identified 
solutions proposed require examination 
pressing limitation validation robotic hardware exists 
necessary full validation principles 
done focus active attentive perception perform vision localization navigation multi role 
highly successful behaviour approaches evaluated strictly hardware subsumption probably reason influential 
finding way implement behaviours firmware programmable logic gate arrays constitute ideal validation 
important limitations respect conceptual approach 
behaviour augmentation introduces problem finding mechanisms conflict resolution operator augment behaviours run time just compile time controller designer 
behaviour conflicts identified problem behaviour networks 
controller developer manually engineer system operator ths implications proof procedure 
solution examine methods distributed systems study inhibition 
software framework specific limitations warrants rectification 
structured exception handling mechanism clearly necessary 
currently implemented careful examination order 
software framework depends message passing ordination processes 
execution state behaviours maintained representations processes modify alternative passing message 
solution spirit 
valuable contribution development computer aided software engineering case tools automating development process 
example due uniformity imposed structure behaviours representations framework possible behaviours representations generated automatically code generation tools 
possible manipulate repository version control software allowing developers literally plug archived behaviours representations controllers 
possible extend integrated development environment ide microsoft developer studio perform code generation repository management tasks controller development 
purpose examining development issues case tools comprise excellent area study 
demonstrated multiagent systems learning behaviours considered comprising excellent area study 
obviously thesis apply tsotsos original conceptual framework natural obvious manner 
aspects validated areas explore 
thesis represents step validation alternative conceptual approach control architecture 
believe new way understanding robot control conceptual approach renders flexible approaches 
simple core simply shared memory collection parallel processes 
architectures simpler flexible 
appendix appendix tables describe behaviours representations demonstration controllers chapter 
bug controller bug controller consists behaviours eighteen representations 
representation described table table 
table gives representation name informal summary kind information maintains representation type specialization inheritance list features include functions routines informal descriptions function representation part representation hierarchy 
representations described tables 
representation bumper summary contains signals sixteen bumpers 
specializes features description value sets bumper boolean value value 
true bumped false bumped 
called exogenously 
returns state bumper true bumped false bumped 
parent sensor table representation sensor summary root representation sensor representations specializes features description parent table representation summary represents ranges detected sixteen proximity sensors 
specializes features description gets distance reported sensor distance sets distance sensor called exogenously 
parent sensor table representation actuator summary root representation actuators 
specializes features description parent table representation heading summary describes robot desired direction walk 
specializes features description direction angle describing robot desired heading degrees simulator ordinate system 
displacement signal step forward backwards displace 
parent representation mast table summary represents camera mast pose command signals 
specializes features description camera direction simulator ordinate system degrees 
reports height camera surface 
command signal sent mast turn degrees simulator ordinate system 
parent actuator table representation pose summary robot pose 
specializes features description compass reading signal degrees robot compass simulator ordinate system cartesian position simulator ordinate system 
parent table representation summary root representation stereo camera 
specializes features description parent sensor table representation target direction summary represents estimated position target estimated direction 
specializes features description distance relative distance robot position current target spatial units simulator ordinate system 
location target position simulator ordinate system 
direction direction target relative robot heading degrees 
parent table representation summary representation stereo camera image bitmap 
specializes features description boolean predicate evaluates true stereo image representation false 
image refreshes left right images 
called exogenously 
image left right images 
parent table representation target color summary colour current target 
specializes features description colour colour current target 
parent table representation task queue summary task list targets acquire 
specializes features description target adds target information tail queue 
predicate evaluates true iff target task list 
dequeues returns task head task queue 
parent table representation navigation type summary specializes features description type navigation type mode 
nt stopped nt random walk nt direct path nt back nt star 
parent table representation task summary represents fact controller go ahead execute task queue 
specializes features description indicate task queue executed 
indicate controller go task queue 
predicate returning true iff true controller go task queue 
parent table representation locomotor summary represents command signal wheel differential drive locomotion system 
specializes features description indicates displacement travel spatial units simulator 
indicates angle turn degrees 
parent actuator table representation map summary represents priori map environment keeps track planned path current position goal position 
map locations marked range resistance traversal resistance traversal infinite unknown 
specializes features description returns map location nth step stored planned path 
predicate true iff path exists 
length planned path 
returns information map location 
parent table representation internal target direction summary internal representation navigate behaviour specializes target direction features description parent table representation percept summary contains stereo image locations centroids coloured blobs colour target searched 
specializes features description image locations centroids colour blobs 
predicates indicating blobs detected left right images 
image attributes 
distance stereo cameras height stereo camera ground 
parent table behaviours represented tables table indicate name behaviour informal summary operation behaviour type specializes inheritance event window representations action window representations possibly list internal representations event action representations trigger precondition daemon informal descriptions sense model plan act nodes 
behaviours described tables 
behaviour acquire summary executes target acquisition task 
completion previous task task read task queue task related information colour search reported 
specializes event window task queue task 
action window target colour 
precondition task task sense dequeues task perform task queue 
model determines colour desired target task 
plan null act writes target colour target colour representation lowers flag task 
table behaviour attend summary performs task directed image processing colour features target locates centroids blobs colour reports locations image percept 
specializes event window stereo image target colour mast action window percept precondition stereo image sense read stereo images stereo image target colour desired target target colour 
model stereo image compute centroid largest colour blob target colour blobs exist 
simply record centroids undefined 
plan null act write positions centroids image ordinates percept representation write undefined exist 
table behaviour detect acquisition summary checks see robot platform front target staring 
signals completion task flags controller continue task 
specializes event window target direction 
pose 
action window target target direction 
precondition task sense read estimated location target target direction robot position compass heading pose 
model null plan information determine distance target robot units robot direction faces target 
decide proceed task 
decide proceed task 
act decision move task raise flag target 
take action 
behaviour navigate table summary performs collision avoidance target directed navigation strategies depending type navigation selected system nt stopped stand 
nt random walk perform random walk 
nt direct path travel current heading avoiding obstacles necessary 
nt back travel backwards opposite current heading 
nt star travel shortest path target priori map stored map 
specializes event window bumper navigation type target direction pose heading 
action window heading 
internal map precondition true 
sense read sensor information proximity sensors bumpers robot pose information pose position desired target target direction navigational behaviour desired system navigation type 
navigation type thought operating parameter indicating strategy advise behaviour navigating 
model place robot target positions map 
proximity sensors determine imminent collision direction travel avoid collision 
compute direction robot turn face target 
plan bumper readings collision occurred decide platform travel short distance backwards 
proximity sensors collision imminent decide platform travel direction avoids collision preference direction target 
perform navigation strategy depending navigation type advised system nt stopped decide stand 
nt random walk decide travel forwards random moment select new random travel gaussian probability distribution current heading 
nt direct path decide travel forwards 
nt back decide travel backwards turning 
nt star plot shortest path planner current position target location decide follow step plan 
act translate decision desired heading face direction travel roll forwards backwards step write heading 
table behaviour track summary controls pose camera navigation strategy platform visually search environment centroids colour blobs detected point camera directly colour blob scene 
specializes event window pose mast task 
action window navigation type mast target direction 
precondition task sense read centroids exist percept robot camera pose information pose mast respectively 
model centroids exist find horizontal positions image 
assuming represent point visual scene estimate position environment robot camera pose information 
plan centroids exist decide pan camera leftwards platform perform random walk 
centroid exists left image decide pan camera leftwards similarly centroid exists right image decide pan camera rightwards case decide platform stay location 
centroids exist left centre images decide pan camera leftwards right centre images decide pan camera rightwards centroids centered centroid left centre right centre decide select computed target position new target position 
case decide platform travel target position path planning 
act translate decisions navigation strategy nt stopped nt random walk nt camera mast velocity write navigation type mast respectively 
decision select new target position write computed target position estimate target direction 
table behaviour walk summary controls locomotor 
turns robot desired heading displace robot forward backward depending heading representation 
displacement rotation happen time 
specializes event window heading pose action window locomotor heading precondition true 
sense read desired heading travel direction command signal heading 
read current robot platform pose pose 
model null plan compute desired turning angle platform pose desired heading 
controller act write desired turning angle travel direction locomotor update heading changing cause behaviour triggered 
table controller consists behaviours eleven representations 
representations bumper sensor actuator heading pose locomotor map reused bug controller exception map priori information empty initialisation 
representations described tables 
representation goal position summary represents ordinates subgoal position planned path navigate coordinate system map 
specializes pose features description parent table representation navigation mode summary maintains representation current navigation strategy 
mode undefined 
mode stand stand 
mode backup travel backwards direction opposite current heading 
mode follow path travel planned path produced augmenting behaviour reach goal 
mode avoid perform collision avoidance 
mode error error state 
specializes features description get returns current navigation mode 
set sets current navigation mode parent table representation target summary represents ordinates final destination position goal ordinate system map 
specializes features description target position 
parent table controller uses walk behaviour described table 
behaviours described tables 
behaviour summary current position agent uses egocentric obstacle range data proximity sensors determine absolute positions obstacles map 
regions obstacles marked 
specializes event window proximity sensor pose map action window map precondition true sense read proximity sensor data proximity sensor get robot position orientation pose 
keep proximity sensor readings report distances range sensor discard rest 
model assuming remaining distances indicate presence obstacles transform distances egocentric sensor data map positions obstacles robot position compass heading 
plan decide obstacles appear map added 
act write newly detected obstacles map 
table behaviour explore summary remaining path generated planner short nonexistent fewer subgoals path generated select random location marked unknown map report map ordinates target 
occasionally picks location known free target destination 
specializes event window map action window target precondition map map sense read map information 
model randomly pick location map occupied obstacle 
plan random decision new target selected 
act decision select new target location write random location map target 
behaviour navigate table summary performs navigation navigation modes mode undefined 
mode stand stand 
mode backup travel backwards direction opposite current heading 
mode follow path travel planned path produced augmenting behaviour reach goal 
mode avoid perform collision avoidance 
mode error error state 
behaviour augmented plan node 
note bug controller navigation mode set internally 
specializes event window bumper map pose action window heading internal navigation mode goal position precondition true sense read bumper data bumper proximity sensor data 
model proximity sensors determine imminent collision direction travel avoid collision 
compute direction turn face goal position stored internal representation goal position computed augmenting behaviour plan step planned path 
plan proximity sensors detect collision imminent set navigation mode mode avoid 
bumpers detect collision occurred set navigation mode mode backup 
set navigation mode mode follow path 
navigation mode mode backup decide move backwards 
navigation mode mode follow path decide turn direction goal position move forward 
navigation mode mode avoid decide travel forward direction avoids collision 
act write desired travel direction heading heading 
table behaviour plan summary performs path planning goal position 
specializes event window map pose target action window goal position map precondition true sense read current robot pose pose target position target 
model place robot current position target position map map 
plan execute path planning algorithm find best path current position target position 
act write location step path goal position 
table agre chapman 
plans robotics autonomous systems vol 
pp 

albus 
outline theory intelligence ieee transactions systems man cybernetics vol 
may june pp 

albus 
engineering mind proceedings fourth international conference simulation adaptive behavior animals animats cape cod ma september 
anderson donath 
animal behavior paradigm developing robot autonomy designing autonomous agents ed 
maes mit press cambridge ma 
pp 
arbib perceptual structures distributed motor control handbook physiology nervous system ii motor control ed brooks american physiological society bethesda md pp 

arkin 
path planning vision autonomous robot proceedings spie conference mobile robots cambridge ma 
pp 
arkin 
motor schema navigation mobile robot approach programming behavior proceedings ieee conference robotics automation raleigh nc pp 

arkin 
robots intelligent navigation extended man environments ph dissertation coins technical report university massachussets department computer information science 
arkin 
behaviour robot navigation extended domains adaptive behaviour vol pp 

arkin 
just robot architecture anyway 
turing equivalence versus organizing principles 
web publication 
www cc gatech edu ai robot lab online publications stanford ps gz arkin 
behavior robotics mit press 
balch arkin 
avoiding past simple effective strategy reactive navigation proceedings ieee international conference robotics automation atlanta ga may vol 

pp 
bekey 
robot control reflex actions ieee international conference robotics automation san francisco ca april pp 

braitenberg 
vehicles experiments synthetic psychology mit press cambridge ma 
brooks 
layered intelligent control system mobile robot ieee journal robotics automation ra 
brooks 
hardware retargetable distributed layered architecture mobile robot control proceedings international conference robotics automation raleigh nc march pp 

brooks 
elephants don play chess robotics autonomous systems pp 

brooks 
intelligence artificial intelligence 

brooks 
intelligence reason ai memo mit ai laboratory 
brooks 
new approaches robotics science vol 
september 
pp 
connell 

creature building subsumption architecture proceedings international joint conference artificial intelligence ijcai milan italy 
pp 

cristian 
exception handling software fault tolerance th international symposium fault tolerant computing october pp 

de giacomo levesque incremental interpreter high level programs sensing 
logical foundations cognitive agents pp 
springer verlag berlin germany de giacomo lesperance levesque congolog concurrent programming language situation calculus artificial intelligence pp 
dickinson stevenson tsotsos olsson 
integrating task directed planning reactive object recognition spie vol 
intelligent robots computer vision xii pp 
dudek jenkin 
computational principles mobile robotics cambridge university press 
dudek jenkin milios wilkes taxonomy multi agent robotics autonomous robots 
endo arkin ron 
implementing tolman schematic behavior robotics international conference robotics automation 
engelmore robert morgan anthony 
eds 

blackboard systems addison wesley 
erman lee hayes roth lesser victor reddy raj 
hearsay ii speech understanding system integrating knowledge resolve uncertainty computing surveys june pp 

fikes nilsson 

strips new approach application theorem proving problem solving artificial intelligence 
pp 
files nilsson 
new approach application theorem proving problem solving artificial intelligence 
pp 
firby 
adaptive execution complex dynamic worlds pd dissertation technical report yaleu csd rr yale university new haven ct firby slack 

task execution interfacing reactive skill networks working notes aaai spring symposium lessons learned implemented software architectures physical agents palo alto ca march 
pp 
gamma helm johnson vlissides 
gamma helm johnson vlissides design patterns elements reusable object oriented software gat 
reliable goal directed reactive control autonomous mobile robots ph dissertation virginia polytechnic institute state university blacksburg 
gat 
alfa language programming reactive robotic control systems proceedings ieee international conference robotics automation sacramento ca pp 

gat 
robot navigation conditional sequencing proceedings ieee international conference robotics pp 

gat 
layer architectures kortenkamp eds 
ai mobile robots 
aaai press 
georgeff lansky 
reactive reasoning planning proceedings aaai pp 

terzopoulos 
remote operation supervised autonomy rosa proceeding th international symposium artificial intelligence robotics automation space canadian space agency st hubert quebec canada june 
ginsberg 
universal planning universally bad idea ai magazine pp 

grupen 

behaviours mapping perception action traditional non traditional robotic sensors ed 
henderson nato asi series vol 
springer verlag berlin pp 

harnad 
symbol grounding problem physica 
hu bradley 
parallel processing architecture sensor control intelligent mobile robots robotics autonomous systems 
kaelbling rosenschein 
action planning embedded agents designing autonomous agents ed 
maes mit press cambridge ma pp 

kahn 

specification control behavioral robot programs proc 
spie sensor fusion iv boston ma november 
kauffman 
home universe search laws self organization complexity oxford university press 
kelly levine 
object perception autonomous robots proceedings ieee international conference robotics automation 
pp 

khatib 
real time obstacle avoidance manipulators mobile robots proceedings ieee international conference robotics automation st louis mo pp 

kirsh 
today tomorrow man artificial intelligence 
pp 
levesque reiter lesperance lin scherl golog logic programming language dynamic domains logic programming 
special issue reasoning action change levesque reiter lesperance lin scherl 
golog logic programming language dynamic domains logic programming 
special issue reasoning action change 
lim 

agent approach programming mobile robots proc ieee international conference robotics automation san diego ca 
pp 
lyons hendriks 
planning reactive robot behaviour proceedings ieee international conference robotics automation nice france pp 

lyons hendriks 
planning incremental adaptation reactive system robotics autonomous systems vol 
pp 

lyons arbib 
formal model computation sensory robotics ieee transactions robotics automation vol 
june pp 

maes 
dynamics action selection proceedings eleventh international joint conference artificial intelligence ijcai detroit mi pp 

maes 
situated agents goals journal robotics autonomous systems 
maes 
maes ed 
designing autonomous agents theory practice biology engineering back 
mit press 
maes 
situated agents goals maes ed 
designing autonomous agents theory practice biology engineering back 
mit press 
mataric 
integration representation goal driven behavior robots ieee international robotics automation vol 
june pp 

mataric 
integration representation goal driven behavior robots ieee transactions robotics automation 
mataric 
behavior control examples navigation learning group behavior journal experimental theoretical artificial intelligence 
mccarthy john hayes 

philosophical problems standpoint artificial intelligence michie ed machine intelligence american elsevier new york ny 
meyer 
object oriented software construction second edition prentice hall 
miller 

experiences looking niches working notes spring symposium lessons learned implemented software architectures physical agents palo alto ca march 
pp 
minsky recursive unsolvability post problem tag topics theory turing machines annals mathematics second series vol 
issue nov 
pp 
moravec 
obstacle avoidance navigation real world seeing robot rover 
ph thesis stanford university 
published robot rover visual navigation ann arbor mi research press 
moravec 
stanford card cmu rover proceedings ieee vol 

pp 

moravec 
stanford cart cmu rover autonomous robot vehicles 
cox wilfong eds 
springer verlag pp 
newell simon 
computer science empirical enquiry symbols search communications acm vol pp 
ng ho kong 
topics high level robot control integrating planning reactivity multiple robot coordination 
sc 
thesis york university 

extending behavior systems capabilities behavior representation working notes aaai fall symposium parallel cognition pages north ma november 
mataric maja 
learning interacting human robot domains special issue ieee transactions systems man cybernetics part systems humans vol 
pages chelsea white kerstin dautenhahn eds september 
mataric maja 
hierarchical architecture behavior robots proceedings international joint conference autonomous agents multi agent systems bologna italy july 

direct perception recognition distinct perceptual systems text address cognitive science society august 
nilsson 
shakey robot 
technical report ai center sri international menlo park ca 
oxford university press 
oxford english dictionary oxford university press 
poole mackworth goebel 
computational intelligence logical approach 
new york oxford university press 
ning 
playing soccer modifying combining primitive reactions kitano ed 
robocup robot soccer world cup lncs lecture notes artificial intelligence springer verlag nagoya pp 
ki ning 
executing primitive tasks parallel proceedings nd robocup workshop robocup july paris france pp 

reactive task execution mobile robot phd thesis faculty technology university oulu oulu finland 
robinson jenkin 
reactive control mobile robot archibald kwok eds research computer robot vision pp 
world scientific press singapore 
rosenblatt payton 
fine grained alternative subsumption architecture mobile robot control proc 
international joint conference neural networks june pp 
rosenschein kaelbling 

synthesis digital machines provable epistemic properties sri international technical note menlo park ca april 
albert 
mission plan specification language behaviour robots 
sc 
thesis department computer science university toronto 
russell norvig artificial intelligence modern approach 
prentice hall englewood cliffs nj 
sacerdoti 
planning hierarchy abstraction spaces artificial intelligence 
sacerdoti 
nonlinear nature plans proc 
fourth joint conf 
artificial intelligence morgan kaufmann pp 

model reaction planning dynamic environments thesis computer science department university maryland college park may sussman 
computer model skill acquisition elsevier north holland 
tam lloyd lesperance levesque lin marcu reiter jenkin 
controlling autonomous robots golog australian joint conference artificial intelligence pp 
tam lloyd lesperance levesque lin marcu reiter jenkin 
controlling autonomous robots golog proceedings tenth australian joint conference artificial intelligence pp perth australia nov tolman 
prediction vicarious trial error means schematic 
psychological review 
ed vol 

pp 
bekey 
robot control reflex actions proc 
ieee international conference robotics automation vol 
pp san francisco ca april 
tsotsos 
complexity perceptual search tasks proc 
intl 
joint conf 
artificial intelligence detroit pp 

tsotsos 
relative complexity active vs passive visual search international journal computer vision pp 

tsotsos 
intelligence scaling problem artificial intelligence pp 

tsotsos 
proposal ark internal working notes dept computer science university toronto june unpublished 
tsotsos 
intelligent control perceptually attentive agents proposal technical report tr university toronto june 
tsotsos 
intelligent control perceptually attentive agents proposal journal robotics autonomous systems vol 
elsevier science pp 

red ko 
kaufman nk boolean networks principia cybernetica 
vub ac 
walter 
living brain norton 
distributed port arbitrated behaviour control 
prod 
th intl 
symp 
distributed autonomous robotic systems knoxville tn 
springer pages zeltzer 
task level graphical simulation abstraction representation control making move mechanics control animation figures eds 
badler barsky zeltzer 
morgan kaufmann san mateo ca pp 

zhang mackworth 
constraint nets semantic model hybrid dynamic systems theo 
computer sci 

