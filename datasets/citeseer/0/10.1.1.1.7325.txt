discrete time uml semantics concurrency communication safety critical applications werner damm bernhard amir pnueli angelika oldenburg germany weizmann institute science rehovot israel define subset krtuml uml rich express modelling entities uml real time applications active objects dynamic object creation destruction dynamically changing communication topologies combinations synchronous asynchronous communication shared memory usage object attributes 
define formal interleaving semantics kernel language associating model krtuml symbolic transition system sts 
shortly outline compile models industrial systems making generalisation hierarchies weak strong aggregation hierarchical state machines krtuml 
main aim provide executable semantics krtuml suitable formal verification temporal model properties existing model checking tools 
establishment real time profile uml proposal uml action language installation special interest group shared omg develop profile uml addressing specification real time systems system level reflect pressure research partially supported information society dg european commission project ist omega 
email addresses damm de werner damm de bernhard amir wisdom weizmann ac il amir pnueli de angelika 
put standardisation bodies give rigorous foundation increasing level usage uml develop hard real time systems 
increased safety critical applications mandates need complement modelling oriented activities agreement formal semantics employed modelling constructs prerequisite rigorous formal analysis methods formal verification compliance requirements 
need perceived research community leading substantial body formalisation various subsets uml 
precise uml group series papers proposing meta modelling approach lacks capability address dynamics aspects level detail required formal verification 
approaches translation existing formalisms calculus asms casl object fall short covering rich range behavioural modelling constructs covered 
approaches uml semantics discussed detail section 
closest addressing intricacies understanding active objects 
approach takes account functional aspects real time systems considering discrete time model allowing define different levels step granularity 
focus investigation semantic foundation critical features real time applications concurrency types inter object communication synchronous asynchronous including specification time points interferences 
proposed semantics executable cover different choices final implementation deployment different execution times scheduling strategy intended formal verification earlier stages development process preliminary detailed design 
early verification allow find errors possible implementations model level 
described approach benefits numerous discussions industrial users employing uml tools development real time systems partners ist projects omega ait ist project omega developed agreed specification modelling concepts uml required support industrial users application development subsuming concepts inheritance polymorphism weak strong aggregation hierarchical state machines rich action language active passive reactive objects account detailed issues navigability visibility changeability ordering association points allowing unbounded multiplicity 
project provides real time extension proposed semantics 
ist www omega imag fr index php ist intranet gr propose stage approach give formal semantics precompilation step translates models sufficiently compact sublanguage krtuml eliminating need kernel level address various facets associations generalisation hierarchical state machines 
give formal semantics krtuml formalism symbolic transition systems 
semantic framework state space transition system valuations set typed system variables initial states transition relation defined order predicate logic 
show capture complete snapshot dynamic execution state uml model unbounded arrays object configurations maintain current status objects pending request table modelling status submitted served operation calls 
object configurations include information valuation object attributes state configuration state machine pending events collected event queue 
definition formal semantics krtuml sketches ideas precompilation phase translation steps standard compiler techniques 
refer reader full description steps full specification 
organised follows 
section outlines aims semantics proposed gives formal definition constituents krtuml model 
section heart develops sts semantics motivating introducing consecutive sections system variables spanning state space transition systems transition relation 
section highlights aspects pre compilation step addressing class relations hierarchical state machine 
section discusses related 
krtuml language kernel language caters difference active passive objects 
generalise concept section proposing group active object collection passive server objects call components 
class dichotomy orthogonal active passive hierarchy considered difference reactive simple classes 
objects assumed state machines behaviour dependent current state system 
state machines specify event receptions automatically implies reactive behaviour corresponding class objects react external stimuli 
require restrictions combinations active passive reactive simple class notions 
pre compilation flattened hierarchical state machines flat state machines considered kernel language 
split compound transition annotations kernel language atomic actions triggering guards signal operation names possibly conditions allowed labels transitions 
basic notions explain uml related notions considered imposed problems resolving ambiguity semantic variation points deliberately left uml specifications 
notions active object thread control concurrency multiplicity state machine association composition generalisation multiple inheritance dynamic classification stimulus signal event sender receiver method parameter defined uml proposal 
developing krtuml maintain purified form ingredients uml relating interaction active objects 
active classes intended model threads sequential executions threads run concurrently 
active classes provide means independent executions 
intuitively active object instance active class event driven task processes incoming requests fashion 
comes equipped dispatcher picks top level event event queue dispatches processing state machine passive objects associated active object inducing called run completion step 
passive classes scheduling mechanisms 
instances passive objects mechanisms assigned active objects 
words passive objects perform services behalf corresponding active ones 
components 
notion component restriction general concept standard uml 
call component set objects executing services sequentially 
means component contains active object possibly passive ones associated active 
component passive objects delegate event handling active object pre compilation capture delegation relation allowing refer ac active object responsible event handling passive objects 
require static assignment passive objects active ones object belong component life cycle 
run completion rtc step sequence fired transitions object state machine corresponding processing single event operation call 
rtc step interrupted 
rtc steps different components run concurrently semantics meaning possible interleavings 
semantic challenge 
problem semantic definition concurrent executions solved side take account different execution speeds different components executing concurrently asynchronously side find abstraction actual execution durations different different platforms providing semantics allowing tell state run temporal properties complex systems 
signals specifications asynchronous reception handled state machines 
signal instances called signal events system point time 
signals generalised means state machine handle reception generalised signal event handle specialised event vice versa 
operations 
support called triggered operations operation calls return value depends current state system distinguished call primitive operations body defined program supported action language 
primitive operations involve services object component pre compilation eliminate calls primitive operations inlining methods transitions assuming call depth primitive operations bounded 
contrast triggered operations willingness object accept particular operation call state expressed state machine labeling transitions emerging state operation name triggering guard style willingness object react signal event specified signal triggering guard 
reflecting wish return value triggered operations dependent object state body spread state machine acceptance call induce run completion step transition labels passed run completion step determine response particular invocation triggered operation 
general characteristic reactive classes uml contain specifying reactions stimuli changing states 
reaction depend current state state machine 
article propose semantics executions defined respect transitions state machines object creation destruction explained terms implicit state machine transitions 
krtuml classes state machines 
define slightly different notion reactive class capture proper reactive behavior follows 
reactive class krtuml class state machine specifies event receptions operation acceptance initialisation phase state machine execution triggered creation operation completed 
called simple class 
consider types intra inter object communication asynchronous signal event 
caller need reply proceeds signal event 
events needed store additional repositories accepted callees 
synchronous operation calls 
krtuml consider triggered operations trigger state machine transitions 
caller sends request wants synchronise callee possibly get result operation suspended 
callee may accept call enters corresponding state 
semantic challenge 
problem semantic definition models combination different kinds communication solved side distinguish semantically synchronous asynchronous communications treating differently side give uniform state machine semantics account communication structure class diagrams providing suitable granularity interference object executions capture properties synchronous asynchronous communication schemes complex systems 
semantical model rich support communication shared attributes operation calls signals restrict communication model inter component communications purely asynchronous signal events 
sub sections give formal definitions mentioned notions respect krtuml 
notion components considered section higher level modelling formalism called 
krtuml structure elaborate formal definition krtuml models 
note different ingredients mutually dependent collect formal definition 
essentially kernel model contains set classes signals signals ordered generalisation relation contains state machine typed attributes operations implemented class state machine 
classes distinguished active 
consider flat state machines extended object initialisation object destruction phases 
designated root class serves system initialisation 
definition krtuml model krtuml model consists elements sig void ib set basic types comprising booleans natural numbers 
set typed predefined primitive functions 
sig finite set signals 
instance signal called signal event event brevity 
sig sig generalisation relation signals transitive closure irreflexive ev ev denotes ev generalisation ev 
denote reflexive transitive closure 
finite non empty set classes 
class consists isactive attr ops sm isactive predicate 
class called active iff isactive true 
attr finite set typed attributes may type void 
ops finite set typed triggered operations 
sm state machine explained terms actions expressions 
class contains specific implicit attributes introduced preprocessing self attr keeping object ac attr specifying event handling object associated class class root object serving specify system initialisation defined definition 
subset active classes called actors denote external objects part environment 
krtuml allows set base types set functions operating including particular booleans natural numbers logical arithmetical operators 
signals operations may parameters defined types 
note support explicitly generalisation hierarchies signals generalisation hierarchies objects eliminated pre compilation 
elaborate elements krtuml model defined far start defining supported types 
clear distinguish base types types visible uml level third category types catering implicit attributes representing association points typically hold number depending multiplicity 
choosing type uniformly functions naturals classes cater unbounded multiplicity 
operationally view implicit attributes unbounded arrays index pointing associated object class containing nil pointer 
definition continued typing krtuml model defines set types tc tas df tc tas df tc set types df tc set association types represent kinds associations described composition aggregation neighbour 
type assume existence designated element nil default value 
type denote type attributes functions follows class attribute attr type denotes type attr type self tc tc type ac tc 
class triggered operation op ops type par op tn denotes parameter type ti type th parameter type op denotes type reply value type op void op yield return value 
type op defined type op type par op type op 
type par tn denotes parameter type ti type th parameter type denotes value type type type type par type 
ev sig type par ev tn denotes parameter type ev ti type th parameter 
introduce expression language supporting navigation expressions accessing objects association points closing application base type functions including equality boolean operations 
expressions terms defined scope class transition guards primitive actions class 
definition continued ii expressions class expression expr defined inductively follows navigation expression expr attr type tc tc attr 
set type expr df type 
note consider flat navigation expressions krtuml refer object self 
association access expr expr expr expr expr expressions type expr tc tas type expr 
set type expr df tc 
function application expr expr 
expr expr 
expr expressions type expr matches type th parameter define type expr type 
definition guards actions state machines expr expr expr denote expressions 
guards just boolean expressions express willingness accept signal event operation call possibly conjoined boolean condition 
definition continued iii guards class triggering guard state machine class guard short signal trigger ev expr ev sig type expr ib 
call trigger op expr op ops type expr ib 
condition expr type expr ib 
support rich action language allowing object creation destruction operation calls event emission assignments attributes association points 
expression passed object creation intended pass identity active object responsible event handling 
reply actions serve define return values triggered operations 
definition continued iv actions primitive action state machine class action short object creation expr attr type tc tc attr type tc tc type expr type ac 
object creation association place expr expr attr type tc tc attr type tc tas type expr type expr type ac 
attribute assignment expr attr type tc tc attr type type expr 
association place assignment expr expr attr type tc tc attr type expr type tc tas type expr tc 
event emission send ev expr 
expr attr type tc ev sig type expr type par ev 
operation call ignoring reply value call op expr 
attr type tc op type ops type expri op 
operation call assigning value call op expr 
attr type tc tc attr attr type tc op type ops type expri op type op 
operation call assigning value association place expr call op expr 
expr attr type tc tc attr attr type tc op type ops type expr type par op type tas type expr type op setting reply value reply expr tc type expr 
object destruction destroy expr type expr tc 
triggering guards actions appear labels transitions class state machines 
assume designated destruction state 
pre compilation extend user defined state machine pre fixing initial state sequence transitions modelling constructor actions destruction state having incoming transitions unique entry point section added pre compilation modelling destructor code 
pre compilation transfers hierarchical state machines flat state machines 
create isactive false ac self sm created dead qx isactive true ac self 
sm created dead create isactive true ac self sm created qc op destroy self qd dead isactive false ac self op sm create reply created attr ops dead op fig 

class examples classes active passive perform services sequences executions respectively 
classes reactive react stimuli initialisation phase 
classes accept stimuli creation 
definition continued state machines state machine class tuple sm qx tr finite set states 
initial state 
qx destruction state mark destructor actions 
tr guard action transition relation 
require initial transition tr action create class called reactive transition tr form ev expr op expr ev sig op ops 
krtuml denote set krtuml models 
example krtuml classes model shown 
note krtuml level intentionally inheritance relation classes class inheritance explained implicit attributes parent type table superclass preprocessing step described section 
association attributes parent keep structure inheritance hierarchy type table reflects actual type object available level dynamic classification useful calls operations deferred implementation 
note association access restricted accessing single index krtuml level operations iteration associations adding 
assume operations explained terms primitive actions preprocessing 
identification actors considered necessary semantical point view actors treated active classes 
information object actor instance exploited formal verification objects need necessarily encoded ordinary objects interpreted assumption environment behaviour expected sequences input stimuli 
assume preprocessing step outlined subsection establishes set requirements regarding sets attributes state machines krtuml model rely section explaining semantics 
attribute triggered operation names classes pairwise different example qualified class name states state machines pairwise different 
ii class attr contains attribute ac store responsible active object ac type tc isactive true 
iii values implicit attributes self ac type table parent assigned initialisation corresponding object change life time object 
iv triggered operation op ops attributes attr hold local copies parameters typed 
op 
op pn type par op ev sig willing receive transition ev expr tr attributes attr hold local copies signal parameters typed 
ev 
krtuml semantics give semantics krtuml terms symbolic transition systems proposed name synchronous transition systems 
separate subsections derive types krtuml models type structure related symbolic transition systems introduce system variables required represent snapshot dynamic execution krtuml model 
elaborate way snapshots evolve defining possible cases transition predicate 
define predicate characterising initial snapshots collect pieces transition relation full predicative definition transition relation leading definition symbolic transition system associated krtuml model 
symbolic transition systems introduce semantic model symbolic transition systems allows purely syntactical description transition system order logic predicates set typed system variables 
definition sts symbolic transition system sts consists finite set typed system variables order predicate variables characterising initial states transition predicate order predicate referring primed unprimed versions system variables current states 
sts induces transition system set interpretations variables follows 
definition runs sts st set types variables semantic domain 
snapshot type consistent interpretation assigning variable value domain 
denotes set snapshots 
ii snapshot inductively defines value expr order predicates expr value expr order predicates expr provides interpretation unprimed interpretation primed variables expr 
iii snapshot called initial iff true 
iv snapshots snapshot called successor iff true 
computation run infinite sequence snapshots 
satisfying requirements initiation initial 
snapshot sj successor sj 
vi set computations denoted runs 
denote th snapshot run runs df 
denote infinite suffix starting 
cruiser car 
status self speed cruiser 
exe sc eq ds ds system configuration object configuration ac dest par dest ev par dest ev par fig 

system configuration variable type contains object configuration object identifier oc 
example object configuration object car shown enlarged 
system variables krtuml semantics motivate choice types system variables snapshots related automated rail car system described model autonomous rail bound cars transport passengers terminals adhere simple arrive departure protocol allocate de allocate platforms inside terminal 
refer reader details 
depicts way object configuration captured 
shows enlarged entry object class car currently executing 
current state machine configuration illustrated state machine fact current state stored 
object configuration gives current valuation attributes current state configuration maintains current object status elaborated event queue active objects dispatcher status active objects enforce single thread control objects grouped component 
semantic entity representing single class potentially unbounded array object configurations entry corresponding single instance class 
object status reflects phase object life cycle see 
prior creation objects perceived dormant 
creation new object instance pick dormant index corresponding class awake object realities life 
life objects suspended waiting completion operation call idle special case discussed stable run completion step terminates 
happens reaching state outgoing transitions guarded signal triggers form ev expr call triggers form op expr conditions form expr evaluated false 
particular case accepting destruction object status switch dying remaining status run completion step induced objects destructor completed 
dormant create queue empty pending calls locally enabled transition object status remain dead 
idle executing suspended take event accept trig 
op 
initiate trig 
op 
call alive stable pick result destroy fig 

object life cycle 
dying destruction completed note destruction aggregate object composition association defined induces destruction parts dying may long painful process 
semantics allows observe sending events dying objects detecting dangling 
rest section sig krtuml model 
define semantic types employed definition associated symbolic transition system semantic domain semantic types 
type system semantic types subsumes types krtuml model 
definition object types domains basic type assume existence corresponding semantic type domain 
type tc tc denote oc ttc corresponding semantic df type choose doc domain 
call oc domain df doc doc object type resp 
domain 
object type oc assume existence designated element doc serve default value 
association type tc tas domain dead df doc define semantic type system configurations associated domain defining semantic type object configurations 
definition object system configuration object configuration status ac sc eq ds consists elements object status status type associated semantic domain df dormant idle executing suspended dying dead 
cruiser car 
dest op cruiser engage status pending result nil params nil pending request table pending request table entry fig 

pending request table pending request table system variable type 
contains entry object identifier oc 
object attribute configuration ac type tac tt 
df attr object state machine configuration sc type tsc associated semantic domain df event queue eq type dest ev par type df sequence entries df oc sig ev 
ev sig event queue entry dest denotes destination ev event type signal name par event parameters 
denote empty event queue 
df dispatch ds type tds oc object class denote object currently processing event 
type object configuration df tac tsc tds ii type system configuration df oc 
iii call component set cm ac objects assigned event dispatcher 
iv call object oc class active object iff isactive true active class 
call passive object 
write isactive true specify active object isactive false passive ones 
call object oc class reactive object iff reactive class 
call simple object 
symbolic transition system uses variable sconf maintain object configuration objects note general assignment event dispatcher reactive object user defined 
default assignment derived composition association 
collect status pending operation calls pending request table 
example shows enlarged entry calls object caller calls callee accepts callee unused trig 
op 
pending call busy stable completed caller picks result fig 

life cycle triggered operation call 
class car 
currently call triggered operation engage cruiser pending 
exploit fact objects suspended calling operation 
maintain status operation calls table indexed sender objects resp 
actors 
entry pending request table maintains identity receiver name requested operation list parameters result field status information 
life cycle entry pending request table depicted 
object owning entry emits new operation call status entry switches pending 
remain status receiving object willing serve call causes status switch busy 
run completion step induced accepting call terminated result call entered result field entry status changes completed 
allow calling object pick result resume computation causing status entry unused 
definition pending request table pending request table entry dest op status result params maintains receiver triggered operation call dest type asso ciated semantic domain df oc 
triggered operation identifier op type top associated se mantic domain dtop df ops 
triggered operation status status type semantic domain df unused pending busy completed 
result reply result type tres associated semantic main df type op 
op ops parameters params type associated semantic domain df op ops type par op 
type pending request table entry df top tres 
ii type pending request table df oc 
symbolic transition system uses variable prt maintain operation requests objects considered type assume existence designated element nil serve default undefined value 
assume expressions expr evaluated situations example trying read attribute value nil trying execute arithmetic exception situations 
words expr true iff expr nil type expr 
furthermore need boolean flag sysfail indicate undefined state system tries read attribute object nil type reply action match type currently processed triggered operation 
performing arithmetic computations raise flag failure situations division 
initially sysfail set false remains set changed true 
brevity abbreviations oc rest section status df sconf status analogously sc ds eq 
df sconf value attribute df sconf sconf attributes type 
denote simultaneous assignment th components corresponding attributes event operation parameter tuple ev primed abbreviation indicates primed system variable example sconf event queue 
en introduce elements head df denotes entry queue 
tail df 
en denotes entry removed tail 
enqueue df denotes result appending entry logical xor operator abbreviation df 
transition predicate intuitively transition snapshots exists exactly object oc configuration changes reasons object idle event dispatched active object event destination discarded enabled state machine 
coarse granularity flow control kept elements ds active objects configurations 
object idle accepts triggered operation call 
fine granularity flow control kept elements dest pending request table 
object executing dying unstable takes transition state machine executing action simple fine step changes flow control delayed waiting results objects 
object suspended picks result triggered operation call completed callee 
fine granularity flow control kept dest prt 
system may remain snapshot object executing event queues empty 
formalise conditions separately order logic predicates construct transition predicate semantics st 
note incremental definition transition predicate symbol processed explicated definition yield final transition predicate 
informally symbol indicates difference current states system variables specified explicitly sequence expressions constituents 
define object oc predicate stable current system configuration follows stable df tr sc ev expr sysfail sysfail expr op expr sysfail sysfail expr expr expr sysfail sysfail expr ev expr op expr expr means label current transition form ev expr op expr expr resp signal trigger call trigger condition resp cf 
definition iii 
sconf status idle ac ep ep sc ac eq ds eqi nil get event status exec eqi ev ev ev 
tail eq ev expr ac ep ep sc 
fig 

transition relation get event 
ac eq eqi ds ev expr sconf eqi tail eq define individual steps object perform defining transitions locally objects 
definition global transition predicate combined steps additional conditions specifying kind scheduling 
partial predicate defined kind steps contains specifications state step performed conditions current unprimed values system variables changes values object attributes pending request table induced transition rising failure flag case referred values undefined 
getting event 
intuitively event ev destination dispatched head event queue active object object component currently processing event reception specified ac ds nil transition guarded superclass ev ev enabled current state cf 
get event df ev expr ac ds nil expr true sysfail sysfail expr ac eq head ac eq dest ac eq tail ac eq ev sig head ac eq ev ev ev ev stable ac ds status executing ev head ac eq par element ac ds equal nil locks component processing signal event 
released component start process event new run completion step computations component completed 
note exploit fact syntactic category boolean expression definition krtuml models subsumed expression language order logic define transition predicates 
particular defined abbreviations apply expressions transition predicates providing intended relation sconf 
accepting triggered operation 
object accept triggered operation call op transition guarded op enabled current state object called op entry point pending request table operation accept op df op expr expr true sysfail sysfail expr oc prt dest prt op op prt status pending stable prt status busy status executing stable prt status completed prt result nil op prt opp note object call trigger operation object component restrictions inter component communication 
ac ds ac ds execution operations rtc step change control objects level communication captured prt dest prt status 
skipping guards 
object take transition guarded boolean expression expression evaluates true skip guard df expr expr true sysfail sysfail expr discarding events 
event object queue active object willing accept transition matching signal generalisation enabled event simply removed top queue discard event df ac ds nil ac eq head ac eq dest ac eq tail ac eq ev expr tr expr false ev head ac eq ev sysfail sysfail expr stable ac ds status executing note discarded signal event trigger transition object stable state value guarding condition transition signal call trigger true 
note triggered operation calls discarded remain callee accepts call 
executing simple actions 
object execute action current transition enabled annotated action 
distinguish types actions simple non operation actions operation calls synchronisation delays treating different ways 
subformulas combined different contexts conditions performance final transition predicate 
kinds non operation actions non op action df assign send event reply destroy assignment action simply assigns value destination attribute assign df expr expr expr sysfail sysfail nil expr event sending action causes new event appended queue destination active object send event df send ev expr 
sysfail sysfail nil expri ac eq enqueue ac eq ev expr 
reply action causes parameter value written reply field pending request table processes call object system failure indicated reply df reply expr oc prt dest prt status busy prt result expr sysfail sysfail type expr sysfail true destroy action causes destination state machine configuration changed qx current state status dying 
subsequent steps execute actions destructor 
killing dying dead object causes system failure destroy df destroy expr expr oc expr nil ac ac status dormant dying dead sc qx stable status dying stable status dead sysfail true synchronisations operation calls 
operation call actions differ just defined simple actions treated atomically 
operation call suspends object configures entry pending request table denotes callee called triggered operation parameters 
initially status called operation pending 
additional check performed guarantee operation calls component run time failure observed 
init df call op expr 
call op expr 
ac ac sysfail sysfail nil expri ac ac status suspended prt dest prt op op prt status pending prt result nil prt op expr 
expr creating new object 
creation action handled triggered operation caller blocked object desired class readily created inherited parts aggregated parts possibly attribute initialisation 
modelled operations attended precompilation step initial transitions state machines 
creation action looks dormant object wakes appropriate component create new component created object active calls operation new object call create df expr ac expr sysfail sysfail expr ac expr expr oc status dormant dying dead oc status dormant status idle isactive ac expr isactive ac status suspended prt dest prt op prt status pending prt result nil prt params nil example essential changes system configuration corresponding creation action shown 
creation passive object shown 
note newly created passive objects assigned current component defined corresponding attribute ac creation action called 
synchronisation took place callee completed required operation additional bookkeeping needed operation execution rise flag result ready formalised subsection 
stable 
object stable bookkeeping takes place 
processing event dispatch active object reset 
executing triggered operation pending request table status set completed caller know operation completed 
cases idle 
executing run completion step starting qx status dormant isactive false sconf sconf status idle ac create call create status suspended ac expr create expr prt dest op status pending 
fig 

call object creation 
changing status caller callee inserting called operation pending request table values selected elements sconf prt dead stable df stable ac ds ac ds nil status idle picking result 
oc prt dest prt status busy prt status completed status idle status dying status dead object pick result previous operation call callee set status pending request table entry completed 
picking result means change corresponding attribute changes caller status removing corresponding entry pending request table pick result df prt status completed prt nil stable status executing call op expr 
expr nil prt result sysfail sysfail nil status sc status sc sconf suspended dep idle disengaged sconf suspended dep executing disengaged sconf suspended dep idle engaged sconf call engage dep crs executing crs idle engaged car cruiser prt prt prt prt dest nil op engage engage engage nil disengaged engage reply status pending busy completed nil engaged fig 

triggered operation call 
changing status caller callee called operation engage pending request table unprimed variables depicted time operation call values selected elements sconf prt 
complete execution example triggered operation engage illustrated 
row tables show relevant part system configuration time just entered call pending request table 
note taken transition remains previous state 
second row shows time just cruiser accepted call 
time just completed run completion step written result changed operation status completed idle 
indicator pick result time read reply value table clear table entry take transition 
executing continues run completion step assuming stable 
sts semantics krtuml model 
putting specifications different kinds transitions define semantics krtuml symbolic transition system system variables subsection initial condition combined transition relation specified definition 
definition krtuml semantics sig krtuml model 
semantics sts sts system variables df sconf prt sysfail ib 
initial condition initially single object class exists status executing 
objects dormant attributes default values ret nil nil nil par nil nil nil nil system failure entries pending request table df status executing ds sc eq ac oc status dormant sc ds nil eq oc self prt nil attr sysfail false unique single object class alive run called root object transition relation intermediate predicate composes introduced subpredicates additional conditions application objects life cycle follows df oc status executing eq sysfail oc tr sc sc status idle get event accept op status executing status dying skip guard non op action status suspended pick result stable sc sc status idle discard event status executing init call create final transition relation obtained adding frame axiom requires places allowed change transition get new values assignment changing assignments 
semantics krtuml model set runs sts computations starting 
easy see effectively restricts activity object resulting interleaving actions different objects 
definition transitions sts uses refined notion step 
definition formalises coarser levels steps complex system 
definition run completion step 
vi snapshots sts 
run completion rtc step object subsequence rtc vi 
vi run 
vi 
vi 
runs sts conditions hold sconf sconf changes required object configuration step sconf sc qx sconf status idle object stable sconf status idle dead object stable step sconf status executing suspended dying object unstable step execution 
ii rtc step component cm subsequence rt cm vi 
vi run conditions hold sconf ds nil sconf ds object scheduled event reception step sconf sconf cm changes required component step sconf status idle active object component stable sconf status idle dead active object component stable step sconf status executing dying sconf ds nil active object component performing computation scheduled reception event passive servant 
iii object component rtc step vi 
vi vi called rtc step vi called rtc step 
relation notion object rtc step component rtc step proposed semantics formalised proposition 
proposition 
seq 
vn rtc step component cm sconf status dying cm 
exactly holds seq rtc step object seq rtc step object cm sconf ds consequence definitions formalises main properties described krtuml semantics 
consequence 
krtuml model runs sts 
vn 
vi sconf prt sysfail 
oc 
invariants hold level computation concurrency status status executing cm cm objects different components executing time 
ii asynchronous interference points vi vi get event vi rtc step vi 
vi component cm ac 
iii synchronous interference points vi vi accept op vi rtc step vi 
vi object object accept operation calls borders rtc steps 
semantics sts encodes system executions interleavings component rtc steps allowing event receptions objects borders component rtc steps objects component currently executing suspended uncompleted operation calls 
side component rtc step chain invocations objects rtc steps started suspending previous operation call 
semantics local point view objects mechanism component implemented shared variables ac ds ac eq prt 
consequence summarises means proposed semantics 
consequence 
component computations component cm isactive true shared variables ds eq prt play main roles scheduling available component objects 
objects cm eq isactive false 
runs sts eq event queue component store asynchronous stimuli sequentially 
ds vi vi get event ac ds nil object receive event object executing event reception 
prt prt status busy status suspended synchronisation operation executed calling suspended vi vi pick result dest status idle synchronisation object proceed result operation call callee stable easy see transition vi vi system run 
vn 
state machine transition taken transitions enabled different component chosen non deterministically 
considering possible runs provide semantics covering different execution speeds scheduling components 
assessing expressiveness krtuml section indicate reduce richer uml models supported ist project omega krtuml subset defined section 
explain choice design decision formal semantics 
subset uml chosen translate krtuml called contains additional features krtuml primitive operations classes definition implemented methods actions defined definition iv extended richer navigation expressions constructs branching loops 
kinds operation concurrency sequential guarded concurrent 
specific kinds primitive operations class constructor destructor 
kinds associations classes semantically distinguished composition aggregation neighbour kinds visibility attributes operations association ends public private protected 
generalisation relation inheritance classes multiple inheritance assumption naming conflicts attributes operations elements dynamic classification called casting 
implies polymorphism particular operations corresponding virtual eiffel 
hierarchical state machines containing hierarchical states addition simple states states concurrent regions states 
pseudo states initial deep history shallow history 
join fork vertices consider transitions multiple sources targets 
entry exit actions states 
transitions complex containing guards non primitive actions 
translating krtuml translation krtuml comes steps 
technical scope 
subsection outline steps 
extended explanations 
uml defines associations association points capture relations classes 
semantically association points maintain pointers objects accessible association point subject restrictions visibility navigability 
precompilation introduces call implicit attributes attribute self type class translates code invoked creating compound objects establishing links employing set implicit operations add association initialise association delete association note special type tas provided attributes krtuml model 
particular pre compilation create implicit attributes maintaining knowledge possibly dynamically created component objects strong aggregation called composition include calls creation component objects bounded multiplicity constructor code aggregate object contain calls destroying existing component object destructor code aggregate object 
class direct successors aggregate composite relation classes cn require preprocessing defines operations pj destroy type pj cj ac type cj 
preclude user defined constructor destructor bodies invoked ref destroy ref resp 
sequential composition action catering recursive creation deletion component parts 
trivial pre processing step eliminate complex navigation expressions introducing auxiliary attributes reducing level de referencing definition 
scope thread inline recursively primitive operation bodies directly transitions containing calls 
regarding class generalisation create private instances segment descriptor class predecessor generalisation hierarchy creation compound objects induces creation components 
implicit offset attributes parent serve navigate current segment object definition inherited attributes operations overridden current class 
hierarchical structure object allocation allows keep access operations implementation state machines overridden specialised objects easy casting assignment specialised object attribute generalised note difference component object specified composition association part aggregate object level notion component group active passive objects krtuml level class forgetting specialised attributes operations 
attributes parent defined object immediate ancestor generalisation class hierarchy sanity check qualified operation calls operation ci opj called object type ck ci generalisation ck opj defined ck may overridden 
attributes parent static polymorphism current type object operation invocation defined type attribute referring statically detectable class definitions 
actual type attributes descriptor pointer type object creation time kept implicit association attribute call type table 
semantics proposed defined objects local point view statically inlined methods necessary formal verification 
current type object specification point view calling object aimed hiding non necessary details unacceptable behaviour actual type find correct implementation operations having deferred implementation 
preclude constructor destructor bodies action sequences catering recursive creation deletion segments hierarchical descriptors 
require restrictions state machine inheritance subclass state machine overwritten independently corresponding super class 
private copies maintain object configurations accepting triggered operation change state configuration state machine corresponding object offering operation generalisation hierarchy 
precompilation step transfers hierarchical uml state machines flat state machines krtuml changing behavior 
states flattened state machine correspond state configurations original state machine sets states active time extended function called history configuration keeping information history connectors 
transition flattened state machine relates state configurations iff configuration reached triggering transition corresponding guard original state machine 
effect transition flattened state machine constructed sequential composition exit actions effect corresponding transition original hierarchical state machine entry actions may comprise non deterministic concurrent exit entry actions different concurrent substates 
state machine class add kinds auxiliary states creation states 
qn outgoing transition guarded triggered operation followed inlined constructor initialize inherited parts 
flattened state machine 
inlined destructor kill inherited parts fig 

inlining object initialisation destruction 
wait slow mode enter precompilation call slow self self self self fig 

splitting complex transition 
mode enum car return return pass self mode self mode pass constructor code initial state original hierarchical state machine 
state machine root class contain triggered operation creation transitions 
destruction state qx outgoing transitions containing destructor code 
state flattened state machine containing termination original state machine outgoing transition auxiliary state triggering guard action destroy self result inlining initialisation destruction codes flattened state machine shown schematically internal states necessary split complex transitions transitions containing sequence actions construction actions 
example splitting transition sequential composition actions branching construct shown 
preserve original execution granularity avoid transition enabled inside execution splitted containing action block introduce kind semaphore blocks transitions executed 
transition obtain additional guard inside trans 
splitting complex action simple parts set boolean variable true 
variable reset false 
avoid transition started middle 
eq crs cruiser ac car car ac hnd term terminal ac ac eq mgr comp comp fig 

component structure snapshot model part shows active objects car term event queues passive objects crs hnd mgr 
reactive objects car crs hnd denoted associated schematic state machines 
active objects car term designate components comp comp respectively 
choice communication scheme certain transformations pre compilation steps modelling assumptions 
elaborate concept components introduced definition iii 
targeting distributed system implementations real time systems synchronous operation calls clearly component communication 
estimation worst case execution time cater waiting delay receiving component able accept call may blocked awaiting serving operation call third component 
assume modelling style inter component communication restricted communication 
exploit allow grouping objects components component restrictions placed inter object communication 
pragmatics active objects uml mandate component group contains exactly active object allow include dynamically run time arbitrary number passive objects group 
reactive passive objects required delegate event handling active object group 
figures illustrate concepts components intercomponent communication automated rail cars system example 
graphical representation snapshot model shows objects krtuml level 
reactive object link active object ac assumed constant object lifetime 
objects referring active object form component 
shows components single link component boundary 
delegated component active object keeps events event queue 
event reached top queue eq crs cruiser ac car car ac hnd dispatch term terminal ac ac eq mgr comp comp fig 

event communication components sending event car hnd fact enters event event queue term active object associated hnd 
active object may decide take event queue dispatch destination 
indicated light gray arrows 
semantics section explained perspective destination 
semantics enforces single thread control active component 
feel deviating modelling paradigm particular allowing multiple threads execute object easily cause modelling errors acceptable hard real time applications 
related works attempts define uml semantics classified different orthogonal dimensions 
direction semantics classification level uml coverage 
people trying build semantics individual diagrams uml state machines collaboration diagrams class diagrams cases activity diagrams just give formal foundations action language 
approach symbolic transition system represents static dynamic aspects 
combination statics dynamics considers problem defining active classes associated state machines 
difference approach authors give precise semantics event queue handling consider limited inheritance treat flat uml state machines action semantics 
coverage level relates problem adequate formalisation concurrency communication aspects objects uncovered addressed original uml docu ments 
open problems typical called loose semantics introduced aspects concurrency object communication fixed design decision cover different variation points 
loose semantics suitable formal verification 
tries overcome problem providing executable semantics example feasibility uml precise formalisation particular verification purposes 
side number uml modelling verification tools implementing precise semantics translating uml models programming languages model checker internal formats 
tools different limitations supported uml features provide formal description implemented semantics 
translations stages system design modelling levels 
hu mann proposes third dimension classification attempts uml formal semantics dividing approaches groups naive set theoretic approach 
richters gogolla suggested simple set theoretic interpretation uml class diagrams 
approach semantics class diagram described set hypergraphs corresponding configuration objects 
kind semantics formal definition ocl constraints uml models 
consider ocl approach 
metamodelling semantics 
group approaches application bootstrapping principle semantics uml described small subset uml core static semantics 
approach group uml semantics 
essentially algebraic specification describe legal local snapshots system treating actions 
biggest issue covered approaches deal complex aspects dynamic behavior concerned concurrency inter object communication 
study kleppe warmer oo meta modelling approach 
addition takes account static dynamic viewpoints system separated 
formal semantics state machines really defined set primitive actions restrictive object creation attribute manipulation transporting mechanism signal inter object communication specified 
approach give formal semantics actual state machines unfolding actions larger set primitive actions 
resolved open issues concurrency 
translation semantics 
approach tries keep right abstraction level defines translation uml class diagrams traditional specification languages object casl 
example reggio proposed general schema uml semantics extension algebraic language casl describing individual diagrams class diagrams state machines semantics composed get semantics model 
uml diagram types translated formal notations state machines 
rger defined dynamic semantics uml terms asm extended new construct cover uml state machine features 
model covers event handling run completion step formalises object interaction combining control data flow features 
authors give complete solution solve transition conflicts clear transitions selected 
differently approaches study provides formalism sts static dynamic semantics contains restricted action language 
different approaches mentioned combined shown 
research static semantics defined meta modelling mechanism uml execution semantics expressed asm programs 
study covers features contained class diagrams body operations 
aspects inter object communications really covered semantics uml state machines addressed accompanied complementary papers 
articles consider state machines separated rest uml approach provides semantics model structure class diagrams behaviour state machines 
allow flexibility combination different orthogonal aspects concurrency reactivity synchronous asynchronous inter object communication 
respect investigation results sketched main novelty approach resolves ambiguity formal uml specification concurrency object communication giving formal semantics chosen concrete decision 
damm shown semantics formal verification approach allow active passive objects reactive considering event communication objects 
capture combination different kinds inter object communication synchronous operation calls asynchronous signal events 
proposed semantics choice evaluated prototype discrete time verification environment uml modelling tool xmi representation uml models 
provided semantical foundation sublanguage uml expressive deal industrial uml models real time applications 
partners verimag proposed extensions semantical model focussed real time particular account need support annotations real time scheduling 
ongoing omega builds semantical foundation layed develop verification environment real time uml 
gratefully acknowledge contribution omega partners semantics 
ab 
tau 
www com products tau index cfm 
alvarez clark evans sammut 
action semantics mml 
proc 
uml 
www cs york ac uk pdf 
rger 
asm semantics uml activity diagrams 
rus editor proc 
amast volume lncs pages 
springer verlag 
rger 
modeling dynamics uml state machines 
gurevich ph kutter odersky thiele editors state machines theory applications international workshop asm proceedings volume lncs pages 
springer verlag 
dblp dblp uni trier de 
clark evans kent 
metamodelling language calculus foundation semantics uml 
proc 
fase pages 
www dcs kcl ac uk staff tony docs ps 
clark evans kent brodsky cook 
feasibility study uml family languages precise oo meta modelling approach version september 
available www org 
clark evans kent sammut 
approach engineering object oriented design languages 
proc 
workshop language descriptions tools applications 
available www org 
compton shen 
semantic model state machine uml 
reggio knapp rumpe selic wieringa editors dynamic behaviour uml models semantic questions workshop proceedings uml workshop bericht pages 
ludwig maximilians universitt institut fr informatik october 
www edu papers uml ps 
rational software 
rational rose family 
www rational com products rose index jsp 
damm pnueli 
formal semantics uml kernel language 
omega technical report part deliverable project ist omega january 
available www omega imag fr doc kl pdf 
damm 
live die lsc verification uml models 
boer editor proceedings international symposium formal methods components objects volume lncs 
springer verlag october 
engels heckel sauer 
dynamic meta modeling graphical approach operational semantics behavioral diagrams uml 
proceed 
international conference uml october 
evans france lano rumpe 
uml formal modeling notation 
modeling language international workshop june 
springer verlag 
evans clark 
foundations unified modeling language 
nd northern formal methods workshop electronic workshops computing 
springer verlag 
www cs york ac uk papers ps 
graf 
semantics time extensions 
omega technical report deliverable project ist omega december 
available www omega imag fr doc pdf 
harel 
executable object modeling statecharts 
ieee computer 
hu mann 
loose semantics uml ocl 
proceedings th world conference integrated design process technology 
society design process science june 
logix 
www com products index cfm 

kim carrington 
formalizing uml class diagrams object 
france rumpe editors proc 
uml volume lncs pages 
springer verlag 
kleppe warmer 
unification static dynamic semantics uml 
www klasse nl english uml unification report pdf 
kwon 
rewrite rules operational semantics model checking uml 
proceed 
international conference uml university york october 
lilius 
vuml tool verifying uml models 
turku centre computer science abo university finland 
technical report 
manna pnueli 
temporal logic reactive concurrent systems specification 
springer verlag new york 
meyer 
eiffel language 
prentice hall 

design languages object oriented extensions executable semantics phd thesis 
institut national polytechnique de toulouse france april 
object management group 
uml action semantics final adopted specification ptc january 
available www kc com site home html 
object management group 
uml profile schedulability performance time specification ptc omg adopted specification march 
available cgi omg org docs ptc pdf 
object management group 
unified modeling language superstructure final adopted specification ptc august 
available www omg org cgi bin doc ptc 

formal specification object oriented meta modelling 
maibaum editor proceedings fundamental approaches software engineering fase number lncs 
springer verlag 

boom framework formal specification uml 
proceedings defining precise semantics uml 

formal approach cases relationships 
uml 
reggio astesiano choppy hu mann 
analyzing uml active classes associated state machines lightweight formal approach 
feas 
ftp ftp disi unige pub person reggio ps 
reggio cerioli astesiano 
rigorous semantics uml supporting multiview approach 
fase 
ftp ftp disi unige pub person fase pdf 
richters gogolla 
formalizing uml object constraint language ocl 

ling ram lee editors proc 
th international conference conceptual modelling er volume lncs pages 
springer verlag 

