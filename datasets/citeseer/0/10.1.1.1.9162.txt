comparison software refactoring tools simmonds ecole des mines de nantes simmonds fr tom mens vrije universiteit brussel tom mens vub ac november principal aim apply taxonomy software evolution developed mens position various software tools support activity software refactoring part evolutionary process 
taxonomy mechanisms change factors impact mechanisms 
goal taxonomy position concrete tools techniques domain software evolution easier compare combine 
apply taxonomy tools provide explicit support refactoring 
tools considered detailed study smalltalk visualworks eclipse guru self controlcenter 
detailed discussion comparison tools analyse strengths weaknesses limitations evolution taxonomy 
years software evolution gained importance 
mainly high maintenance costs produced non software designs 
objectoriented languages introduced expected maintenance costs decrease important amounts 
procedural languages object oriented languages permit code reuse encapsulation 
maintenance effort smaller systems designed 
unfortunately maintenance costs stayed high 
new features inserted existing systems system designs changed able accept changes disturbing system 
changes inserted simply possible 
combat problem various tools developed 
tools idea applying refactorings existing system code better existing design implicit source code 
refactorings defined opdyke source source transformations applied source code transformed changing behavior system 
nowadays various refactoring tools techniques mechanisms exist specific application domains characteristics 
try classify refactoring tools evolution taxonomy characterizing mechanisms tools 
taxonomy mechanisms change factors impact mechanisms 
goal taxonomy position concrete tools techniques domain software evolution easier compare combine 
tools chosen study 
tools picked apparent differences exist 
interesting see tools really different 
application taxonomy section taxonomy software evolution developed applied software development tools provide explicit support software refactoring visualworks eclipse controlcenter guru 
tools selected differences show 
visualworks integrated development environment ide smalltalk includes known refactoring browser 
smalltalk dynamic class object oriented language 
eclipse specifically jdt java ide permits refactoring 
java smalltalk static class object oriented language 
guru restructures self code fully automated fashion 
self prototypical object oriented language 
controlcenter manages great part production process java ide permits refactoring 
notice applying taxonomy tools ides permit refactoring guru stand refactoring tool 
visible detailed comparison tools 
taxonomy explained briefly applying 
categorisation proposed axes temporal facets facets change system facets change process object change drivers change 
axis subdivided facets 
temporal changes time change 
times change defined time interval change requested time interval change prepared time interval change available execution time interval change executed time change history 
tools support versioning provide means distinguishing new versions old ones 
unversioned systems new old versions simultaneously context 
versioned system may allow different versions exist 
change frequency 
changes system may performed continuously periodically arbitrary intervals 
drivers change role user 
distinct personnel roles identified lifetime software change 
concretely identifies users interact tool 
distribution users 
facet identifies physical location users involved changes 
making local distributed changes 
degree automation 
taxonomy distinguishes degrees automation automated partially automated manual software changes 
automated changes require user intervention manual changes user 
partially automated halfway 
facets change type change 
changes structural semantic 
semantic changes impact software behavior structural changes aim preserve semantics 
effect change 
distinction element addition element subtraction element modification element renaming 

facet establishes evolutions extensions destructive 
destructive call invasive non invasive 
safety 
types safety distinguished static dynamic safety 
mechanism provide static safety ensure compile time system crash behave erroneously runtime 
mechanism consistency checks runtime provide dynamic safety 
effort 
changes require high low effort included system 
object change artifact 
facet specifies software artifacts subject changes evolutionary tool 
granularity 
granularity refers scale artifacts changed 
range coarse medium fine degree granularity 
application taxonomy coarse refers system package level changes medium refers class level changes fine refers method variable level changes 
locality 
changes local global changes 
local changes fact global changes local change propagated system 
scope 
refers impact change artifact artifacts change source code require change documentation 
system facets availability 
changes integrated system system restarted changes take effect 
tool presents static software evolution presents dynamic software evolution 
activeness 
system reactive changes driven externally proactive system autonomously drives changes 
openness 
software systems open specifically built allow extensions 
closed systems provide framework possible extensions 
change process plan 
change process planned changes managed coherent manner 
unplanned change process 
tool support 
control 
change controlled constraints change process explicit enforced 
change uncontrolled 
measure 
type technique measure change 
impact measured impact system effort needed produce change 
visualworks visualworks popular smalltalk ide produced 
famous refactoring browser standard smalltalk browser visualworks 
achieve worked closely integrate complete refactoring browser toolset visualworks 
secures visualworks place premier extreme programming toolset market 
addition program transformations automate refactoring refactoring browser buffers drag drop undo viewing resources correct editor graphical view class hierarchy protection editing old versions method mistake style checker bug detector 
important enhancements reason tool included report tool ability perform behavior preserving refactoring transformations 
application taxonomy tool focus refactoring capabilities 
temporal changes time change 
visualworks concerned coding process software development effort 
reason place restrictions 
user usually developer maintainer system receives request change browser helps prepare execute change 
visualworks developed interactive tool dynamic pre post condition checking modification source code faster 
refactoring accepted browser compilation finished marking resulting executable program 
tool range action 
change history 
browser provide facilities managing different versions 
visualworks depends host ide versioning capabilities 
browser place restriction type ide versioned unversioned environment 
version code provide undo capabilities 
important decision apply refactorings clear 
maximum length undo history modified user 
change frequency 
visualworks support continuous modifications 
maintainers developers incorporate changes time 
base refactorings usually applied refactoring chains accomplish certain objectives code cleanup design modification 
drivers change role user 
browser code oriented main concern development maintenance source code 
reason main user visualworks system developer maintainer 
user requested functions lead code cleanup system redesign able include modifications making system corrupt brittle 
changes require system redesign system architect user tool deciding refactorings apply 
distribution users 
time smalltalk ides local stand environments 
browser inherits behavior standard browser limited browser 
means visualworks may distributed tool family hosts distributed 
theory refactoring browser permits merging multiuser programming environments underlying smalltalk environment extended multiple user distributed application 
degree automation 
visualworks partially automated tool 
user pick refactorings apply source code parameters apply 
preconditions postconditions effects calculated applied automatic fashion 
user input dynamic analysis conditions quicker supplying things hard calculate 
helps maintain source code readable class method variable names automatically generated 
tool automate decision refactorings apply user decision 
facets change type change 
majority refactorings included visualworks structural changes 
refactorings phd william opdyke 
idea refactorings behavior preserving 
preconditions determine refactoring legal 
don roberts extended opdyke definition refactoring including postconditions 
effect change 
refactorings included visualworks refer directly addition removal modification program elements classes methods variables see table 
refactorings applied refactoring chains preserve behavior 
means implicit dependency relationships exist different refactorings result application transformation rules altered source code 
behavior program offers alteration possibly new behaviors added 
type refactoring refactoring classname superclass subclasses addition addmethod class selector body class varname class class selector class varname class newname classes selector newname class selector modification class varname newname class varname class varname class varname getter class varname table partial list refactorings included visualworks 
visualworks modifies existing source code directly 
means modifications browser invasive underlying ide provides versioning capabilities see section change history 
tool provide ability undo refactorings 
code suffers great alterations form content possible rollback initial state 
safety 
safety ensured tool trustworthy making software testing cycle larger 
particular case visualworks safety provided opdyke preconditions robert postconditions 
addition postconditions permits condition checking done dynamic fashion 
condition analysis done observing state system runtime examining conditions true prior execution program 
conditions ones resulted true accepting previous refactorings 
dynamic checking user input relatively high degree safety guaranteed information accept refactorings complete offered static conservative algorithm preconditions 
way achieve making unit tests essential ingredients extreme programming 
supported visualworks means 
combination refactoring unit testing visualworks ide ideally suited extreme programming 
effort 
main objective tool modify code automating tedious error prone task 
user determine refactoring apply 
doing search replace code programmer input certain information needed tool 
requires relatively low effort user ides offer versioning capabilities browser offers undo capabilities user apply arbitrary refactoring 
satisfied result go back initial state apply refactoring 
means low effort tool 
ide offer versioning done manually user tool cvs object change artifact 
artifact visualworks modifies system source code 
code oriented automating search replace programmers done historically hand cleaning system source code applying design changes 
artifacts involved software development effort kept compatible done manual fashion development team 
granularity 
mentioned effects change see section basic refactorings affect classes methods variables 
basic refactorings combined refactoring chains generating complex refactorings 
classification mentioned taxonomy visualworks medium class refactorings fine method variable refactorings granularity 
locality 
visualworks tool global changes software 
refactorings preserve behavior refactorings offered affect class level downwards user think making local changes 
alterations refactoring may global level example main object system modified 
beauty visualworks changes local user code transformations done automatically user really sees local changes 
scope 
browser integrated software development process coordinate activities products produced phases development process 
source code project modified browser 
changes artifacts produced software development done manually 
applying behavior preserving refactorings system design documentation change requirement specification need change 
system facets availability 
visualworks smalltalk environment environments dynamic compilation 
means systems modified fly refactorings behavior preserving evolutions reduce functionalities offered system maintain compatibility previous versions 
tool highly recommended projects need evolve dynamically 
activeness 
tool completely reactive expects user initiate refactorings indicate applied parameters 
user interaction browser menus dialog boxes 
browser attempt better design inspecting static code system runtime 
information visualworks collects just determine refactoring legal 
openness 
visualworks implemented smalltalk 
means modified reflective capabilities smalltalk 
authors tool developed framework permits definition new refactorings existing ones 
framework available authors recognize difficult impossible framework extensive knowledge theory refactorings 
propose development part browser example providing gui permits refactoring definition 
change process plan 
browser integrated software development process planned unplanned change processes 
type development benefit tool evolutionary systems unplanned change process example extreme programming 
dynamic capabilities tool offer dynamic checking dynamic compilation 
control 
tool knows exactly conditions system complies refactoring applied dynamic analysis program runtime calculation pre post conditions knowledge stored database known facts 
means systems modified tool go controlled evolutionary process 
measure 
visualworks include metrics kind 
obtain information quality modularity code produced refactoring system necessary tool capability 
extremely useful clear refactorings applied 
metrics quality resulting program help user form better idea results refactorings applied 
eclipse eclipse project designed building integrated development environments ides create applications diverse web sites java programs programs open extensible architecture plug ins 
eclipse sdk great amount built functionalities generic 
additional tools needed extend platform new types 
eclipse sdk distributed important tools plug development environment pde java development tool jdt pde create new plug ins extend eclipse sdk 
jdt state art java ide provides abilities java code refactoring 
taxonomy applied jdt tool permits creation evolution java projects 
temporal changes time change 
jdt concerned coding process software development effort java ide 
reason place restrictions 
user usually developer maintainer system receives request change advanced code editor available jdt helps prepare execute change 
jdt uses incremental project build capabilities offered eclipse platform incremental java compiler 
project fully compiled time compiled rest times partial recompilations done 
shorter observed traditional java compilers 
compilation finished marking result executable program 
jdt java compiler produces executable code problems code 
tool range action 
refactorings offered jdt applied system changes requested incorporated system 
restructuring refactoring process applied arbitrary moment time change process 
means tool control time change requested time change prepared time change available execution 
finalized tool applied system includes modifications needed include requested changes 
refactorings offered tool applied expectation changes requested 
refactoring process concluded changes executed time 
change history 
user workspace top level projects 
project project nature gives particular personality 
java project 
projects contain regular files 
projects files folders workspace called workspace resources 
eclipse adds version configuration management capabilities projects workspace 
repositories store version managed resources shared servers 
workspace access different types repositories simultaneously 
stream maintains shared configuration related projects development team 
project stream streams evolve parallel form 
means software evolution eclipse may carried parallel fashion 
eclipse local application user works workspace eclipse parallel asynchronous changes 
synchronized changes eclipse convergent 
change frequency 
developers jdt tried develop ide java possible build large systems expensive system recompilations 
ability maintain relatively dynamical information needed able accomplish purpose 
led development java model model represent java program elements tree structure 
java compiler developed uses tree structure generated java model incremental project builds 
means cheap frequently build system parts project suffered modification get recompiled 
means tool supports continuous changes 
drivers change role user 
eclipse code oriented main concern development maintenance source code 
reason main user jdt system developer maintainer 
user requested functions lead code cleanup system redesign able include modifications making system corrupt brittle 
eclipse includes testing suites example jdt junit testing 
means testers users tool 
type user plug writers pde extend functionalities offered eclipse 
distribution users 
tool local application 
means person development team workspace accessing local copy resources 
workspace directly accessible rest team members 
solved repositories see section change history 
team member see changes submitted team members synchronizes workspace stored project stream repository 
repository type supports optimistic concurrency model conflicting incoming outgoing changes detected automatically 
developer resolve conflict 
means tool supports restricted form distribution 
new plug ins created better aspect 
degree automation 
jdt partially automated tool 
user refactoring wizard pick refactorings apply source code parameters 
preconditions effects calculated applied automatic fashion 
user input dynamic analysis conditions quicker supplying things hard calculate 
helps maintain source code readable class method variable names automatically generated 
tool automate decision refactorings apply user decision 
adds features code completion code editor 
jdt determines legal code completions java compiler 
facets change type change 
jdt refactorings classified actions preserve program semantics 
means changes refactoring wizard applies source code structural changes 
refactorings alter program just affect form program 
user freedom insert semantic changes moment tool just refactoring tool complete ide 
effect change 
majority refactorings included jdt refer directly renaming movement program elements classes methods fields 
refactorings available refer table see current list refactorings available eclipse 
refactorings behavior preserving 
effect change associated ide involves directly element manipulations element addition removal modification 
activities correspond basic actions programmer write applications 
dependency graphs calculated information saved java model eclipse growing plug ins list subject modification 
rename field method class package move static field static method class extract local variable method organize imports inline local variables reorder method parameters table current list refactorings available eclipse 
eclipse jdt java ide allows user modify existing source code directly 
changes code destructive version configuration management jdt offers 
means modifications user invasive tool non invasive changes preserving old unmodified versions repositories 
tool provide ability undo refactorings 
safety 
programs evolve repository capabilities offered tool sort version compatibility checking users synchronize changes shared team repository 
version configuration management system jdt assumes optimistic concurrency model conflicting incoming outgoing changes detected automatically 
developer resolve conflict 
users disposal junit testing java debugger testing plug ins 
debugger supports dynamic class reloading underlying java virtual machine 
effort 
main objective tool create evolve java code 
user disposal java editor advanced editor java nature assigned project 
color keywords syntax marginal annotations format code propose code completion edit code method level usual source file level 
refactorings applied refactoring wizard allows pick refactoring applied parameters 
refactoring proposed code modifications showed user accept changes modifications modify accept simply accept 
refactorings way user need extensive knowledge refactoring theory able apply code 
contributes tool low effort tool 
object change artifact 
artifact jdt modifies system source code 
ide includes code editor compiler debugger refactoring wizard 
projects allowed contain files associated nature example design documents kept project directory 
artifacts involved software development effort kept compatible done manual fashion development team 
due fact synchronization options provided version configuration management system apply java related files 
granularity 
mentioned effects change see section basic refactorings affect packages classes methods variables 
jdt ide changes granularity accepted 
classification mentioned taxonomy jdt coarse package manipulation medium class manipulation fine method variable manipulations granularity 
locality 
jdt ide code editor tool local changes software 
code edited source file method level 
ide offers refactoring wizard allows user global changes package class method field level applying refactorings 
global changes semi automated jdt modifies source code user 
scope 
jdt integrated software development process coordinate activities products produced phases development process 
source code project modified editor refactoring wizard 
changes artifacts produced software development done manually plug ins support modification artifacts created 
moment support plug ins exist really coordinate different artifacts exist projects 
system facets availability 
java static object oriented programming language traditional debug execute life cycle 
changed jdt 
mentioned earlier see section change frequency eclipse tool provides incremental project build support jdt java compiler incrementally build java projects 
compiler generates executables compiler problems compiling 
debugger permits dynamic class reloading java virtual machine hot swap capabilities 
systems restarted changes effective 
means system evolution offered jdt static 
activeness 
tool completely reactive ide 
expects user initiate refactorings indicate applied parameters 
user interaction ide java editor 
jdt attempt better design inspecting static code system runtime 
just uses information gathered java compiler java model suggest completions corrections example suggest keyword completion correct spelling keywords 
openness 
eclipse platform designed open extensible architecture 
architecture plug technology 
eclipse sdk great amount built functionalities generic 
additional tools plug ins needed extend platform new types 
eclipse sdk distributed tools plug development environment pde java development tool jdt 
pde create new plug ins extend eclipse sdk 
jdt state art java ide 
jdt build plug base eclipse platform extensible plug ins 
plug ins jdt exist example testing database plug ins 
comprehensive list plug ins available eclipse platform available eclipse project website 
change process plan 
ide integrated software development process planned unplanned change processes 
creators tool indicate tool encourages exploratory programming 
incremental capabilities tool offer incremental compilation 
plug ins permit better coordination distributed team development allow communication existence new releases necessity team synchronization 
allows development team follow planned change process default change process unplanned 
control 
tool knowledge state system user manually modifies project source code 
ide uses advanced information able offer complex editing options user incrementally compiling code generating dependency graphs information 
tool real understanding information 
possible know code combinations user input 
jdt controlled evolution application refactoring context refactorings defined behavior preserving actions 
tool presents types evolution uncontrolled ide context controlled refactoring context 
measure 
jdt include metrics kind 
considered serious draw back eclipse plug capabilities jdt extended include functionalities 
obvious choice metric code quality metrics jdt integrated software development process 
eclipse platform level possible add plug ins general metrics include different types projects example uml projects interact code projects java projects 
guru self guru refactoring tool developed ivan moore self programming language 
language prototypical object oriented language differentiation class instance objects 
objects related inheritance relationships 
tool restructuring inheritance hierarchies refactoring methods self programs fully automatic manner 
restructuring process supposed behavior preserving 
done maximizing sharing features refactoring shared expressions new methods 
inheritance structures exist system new abstractions 
temporal changes time change 
guru applied system changes requested incorporated system 
restructuring refactoring process applied arbitrary moment time change process 
means tool control time change requested time change prepared time change available execution 
finalized tool applied system includes modifications needed include requested changes 
tool applied system immediately available execution 
tool applied time delay system executed 
delay quite considerable depending amount objects included restructuring process 
examples cited moore indicate time intervals hours attributed fact restructuring refactoring processes occur simultaneously current implementation tool 
restructuring process concluded changes executed time 
change history 
tool applied directly source code wants better design wise 
guru gathers information necessary restructuring existing source code 
determined new object inheritance hierarchy new methods added source code modified 
done automatically obtaining information guru saved parse trees existing code replaced generated code 
guru tool unversioned 
user saved source code having independent cvs simply making copy file original code lost 
undo operation mentioned guru literature 
change frequency 
guru automatic tool user interaction needed 
allows frequent application tool minimal effort programming hours restructuring process 
user indicate objects considered process 
author recommends tool design change 
important restrictions limit frequency application tool 
duration process depends largely quality current inheritance hierarchy amount objects considered restructuring process 
second limitation tool automatic automatically generated code inserted source code automatically generated object method names 
code rational studying development uml plug eclipse 
point restructuring refactoring process referred just restructuring process refactoring implied formal demonstrations indicate moore algorithms behavior preserving exper results favorable tool applied expectation changes requested 
understandable specially automatic applied rapid succession 
tool permit renaming automatically generated names replacing method calls automatically 
drivers change role user 
tool developed support tool self programmer 
main user guru tool system developer maintainer 
automatically generated code inserted original source code person uses tool know system structure quite understand changes introduced inheritance hierarchy new methods generated 
newly introduced elements automatically generated names recommended names replaced descriptive names contribute maintenance system 
distribution users 
guru applied system developer maintainer directly local copy system source code 
means tool local changes 
tool examine entire self environment applying changes certain automatically generated names unique environment 
bad candidate distributed implementation mean necessary checks introducing time delays tool execution 
degree automation 
tool automated 
requires user intervention determine applied indicate objects considered 
guru started restructuring process fully automated 
generates new inheritance hierarchy methods information gathered source code 
means generates code automatically new object method names 
proceeds replace original code generated code necessary 
facets change type change 
algorithms implementation guru supposed behavior preserving 
formal proof fact 
practical demonstrations included code restructuring code refactoring shown system behavior altered 
specially true examples moore 
guru restructure inheritance hierarchies fundamental classes self environment 
environment apparent change behavior 
formal proof behavior conservation result 
changes introduced guru structural changes 
effect change 
certain set classes restructure guru add subtract modify elements elements objects methods 
instance variables treated set methods corresponding mutator methods self language guru tool includes variable manipulation method manipulation 
methods refactored moving common expressions separate methods invoking 
guru restructures system reach optimal state preserves program behavior 
optimal taken mean duplicate methods removed method sharing maximized redefinition methods avoided 

guru replaces original system code automatically generated code 
tool highly invasive 
original method code ignored corresponding format documentation totally replaced expressions extracted tool parse tree 
problems automatically generated code presents excess brackets 
tool provide versioning mechanisms see section change history 
user provide versioning capabilities 
safety 
practical demonstrations shown guru behavior preserving 
demonstrations involved crucial parts self environment applying restructuring read instance variables method fundamental classes see section type change 
means system backward compatible 
literature tool indicate checks static dynamic applied 
effort 
changes guru high impact changes potentially system structure change 
usually case 
cases classes added 
hand quite lot common expressions factored methods included new methods 
guru automated tool changes done automatically tool 
user liberated responsibility 
tool provides method renaming function 
lets user easily rename automatically named methods classes specifying desired name 
guru name replacements message 
guru low effort tool 
object change artifact 
artifact guru modifies system source code 
automatic source code optimizer 
relies information stored source code determine optimal design 
compatibility software artifacts introduce manually software development team 
granularity 
mentioned effect change see section restructuring refactoring process affects objects methods variables included methods self property 
classification mentioned taxonomy guru medium object restructuring fine method variable refactorings granularity 
tool performs refactoring entire inheritance hierarchies classified coarse grained 
locality 
changes global set objects optimized objects necessarily related inheritance relationships 
changes set objects mean objects outside set modified new inheritance hierarchy generated flattening existing inheritance hierarchy 
methods change name messages refer certain method reflect change 
means changes embark self environment system studied objects belong 
scope 
guru integrated software development process coordinate activities products produced phases development process 
source code project modified include automatically generated code 
changes artifacts produced software development introduced manually development team 
system facets availability 
tool requested changes incorporated system 
tool applied restructure system optimization process take hours complete amount objects considered restructuring process 
modified system obtained suffer changes example user rename automatically generated methods 
reasons said guru supports static software evolution processes 
activeness 
guru requires user intervention determine applied indicate objects considered 
guru started restructuring process fully automated 
system modifications determined main algorithms automatic inheritance hierarchy restructuring automatic method refactoring 
tool just executes algorithms decisions refactorings applied 
moore proposes development refactoring algorithms tool decide algorithm applied conditions context 
means currently tool reactive 
initial user interaction 
see section effect change openness 
guru tool implemented self author opinion object oriented design principals development tool 
demonstrated applying guru tool structure 
guru produced similar inheritance structures developed 
means tool relatively easy extend person introducing tool extensions knowledge existing system structure theory algorithms employed moore self language 
difficult meet conditions tool classified partially open 
change process plan 
tool integrated software development process planned unplanned change processes 
tool restructuring inheritance hierarchies refactoring methods self programs fully automatic manner 
done maximizing sharing features refactoring shared expressions new methods 
means form output changes code duplication 
considered planned change 
control 
tool limited application predetermined restructuring rules 
knowledge runtime state system works information source code 
generated restructuring refactoring reflect exists implicitly old system structure 
exist system 
algorithms guarantee resulting system duplicated methods 
means systems modified tool go controlled evolutionary process 
measure 
guru design quality metrics incorporated moore suggests possible metrics 
message sends overriding methods 
refers total number potential message sends methods classes belong restructured inheritance hierarchy 
metric represents source code length self informative know potential messages going sent lines code 
conditions restructuring methods expressions duplicated resulting structure lines code original code resulting design worse 
potential messages means better design methods distributed inheritance hierarchy 
second metric overriding methods refers number methods override methods inside outside classes restructured 
method overriding design poor quality 
currently metrics incorporated guru 
controlcenter controlcenter application development tool created specific purpose streamlining software development process 
application modeling ensure system meets business needs 
controlcenter provides closer synchronization application design transformation code 
single development environment covers various phases software development life cycle design coding testing final deployment 
usually complex infrastructure developed multiple platforms tools multiple participants 
simplified control center collaborative application development approach 
unified environment application design development deployment 
additionally supports software evolution providing developer source code refactorings 
need tool support clear product previous version offered refactorings offers additional refactorings total twelve refactorings 
practice formal demonstration exists 
metrics applicable oo systems developed self oo properties 
temporal changes time change 
controlcenter concerned various phases software development cycle corresponding artifact synchronization 
changes requested usually requirement analysts communicated system designer 
normal recommended form proceeding system designer include changes system design diagrams 
means corresponding code synchronized altered design change partially incorporated source code 
responsibility system developer maintainer finish adding change system 
steps represent 
possible developer incorporate changes directly passing designer 
problem system design automatically synchronized source code modifications 
changes prepared system compiled tested 
environment provides numerous set audits purpose 
system executed time 
refactorings offered controlcenter applied system changes requested incorporated system 
restructuring refactoring process applied arbitrary moment time change process 
means refactorings control time change requested time change prepared time change available execution 
finalized applied system includes modifications needed include requested changes 
refactorings offered tool applied expectation changes requested 
refactoring process concluded changes executed 
change history 
tool fully integrated version control support 
supports wide range versioning tools 
controlcenter file architecture include non ascii files documentation diagrams historic repositories 
support versioning non ascii files file versioning system supported 
tool sold cvs vs bundled environment 
added bonus controlcenter graphical cvs interface 
means tool versioned 
characteristics software evolution depend directly versioning software versioning systems permit parallel divergent changes 
change frequency 
controlcenter acts project artifact manage automatic synchronization artifacts 
main system development environment support frequent changes 
true maintenance tool 
changes applied system continuous manner required automatic synchronization artifacts provide artifact consistency 
ideal tool performing refactorings requirements change 
rollback previous versions done stored versions cvs repository 
drivers change role user 
tool simplifies integrates analysis design implementation deployment debugging phases complex applications 
means users team members involved phases predefined roles analysts designers developers testers 
analysts designers modeling capabilities provided controlcenter 
includes full uml support system analysis design 
developers maintainers testers development capabilities offered tool advanced code editor debugger audits unit testing 
refactoring capabilities developers 
function provided tool effect workspace configuration specifying user role development process 
affects views visible default 
distribution users 
tool local application 
means person development team workspace accessing local copy resources 
workspace directly accessible rest team members 
solved repositories see section change history 
team member see changes submitted team members synchronizes workspace stored project stream repository 
degree automation 
controlcenter partially automated refactoring tool 
user refactoring menu pick refactorings apply source code parameters 
preconditions effects calculated applied automatic fashion 
tool checks changes introduced refactorings correctly propagated 
user input dynamic analysis conditions quicker supplying things hard calculate 
helps maintain source code readable class method variable names automatically generated 
tool automate decision refactorings apply user decision 
adds features code completion code editor 
facets change type change 
controlcenter refactorings classified actions preserve program semantics 
means changes applied refactorings source code structural changes 
refactorings alter program just affect form program 
user freedom insert semantic changes moment tool just refactoring tool development environment includes complete ide 
semantic changes introduced source code automatically system design modified 
type changes completed system developer 
effect change 
majority refactorings included controlcenter refer directly renaming movement program elements classes methods variables 
affect source code directly uml design introduce changes code 
refactorings available refer table see list refactorings available controlcenter 
refactorings behavior preserving 
additionally developer ask system show list derived classes interfaces base classes implementing classes overrides clarify refactoring 
effect change associated ide part tool involves directly element manipulations element addition removal modification 
activities correspond basic actions programmer write applications 

java ide allows user modify existing source code directly 
changes code destructive version configuration management controlcenter offers 
means modifications user invasive tool non invasive changes preserving old unmodified versions repositories 
tool provide ability undo refactorings 
safety 
version compatibility checking implemented cvs development team offered environment 
refactorings applied tool checks changes introduced refactorings correctly propagated 
ensures safety evolution refactoring 
additionally artifacts produced tool kept synchronized worry design source code mismatch 
documentation generated information project 
means documentation corresponds real state project 
users disposal junit testing java debugger auditing tools 
effort 
main objective tool develop complex information systems 
done supporting different phases development process 
user type disposal various tools permit fast easy way coordinated rest participants process 
analysts designers uml modeling capabilities offered tool 
developers advanced code editor 
testers support included java main language refactoring effect move class moves selected class different package pull attribute operation moves selected attribute operation superclass push attribute operation moves selected attribute operation subclass encapsulate attribute selected attribute private provides accessors changes usages project self encapsulate attribute creates getting setting operations uses operations access attribute extract interface creates new interface selected classes extract superclass creates ancestor class selected operations moves operations new ancestor class renaming method bodies renaming operation parameters local variables properties optionally rename usages project extract method extracts method class table list refactorings available controlcenter effect produced refactoring testing framework provided tool 
refactorings applied refactoring wizard allows pick refactoring applied parameters 
refactorings way user need extensive knowledge refactoring theory able apply code 
low effort tool 
documentation generated automatically document styles created wizard 
object change artifact 
controlcenter modifies system design source code tests documentation 
complete system development environment includes uml modeling tool code editor compiler debugger refactoring wizard testing framework documentation generator deployment wizard 
main artifacts kept coordinated automatic synchronization 
granularity 
mentioned effects change see section basic refactorings affect packages classes methods variables 
controlcenter includes ide changes granularity accepted 
artifacts changed system design documentation 
classification mentioned taxonomy controlcenter coarse design documentation package manipulation medium class manipulation fine method variable manipulations granularity 
locality 
ide part tool offers refactoring wizard allows user global changes source code directly package class method variable level applying refactorings 
scope 
controlcenter tool market currently offers highest level integration software artifacts produced different phases software development process 
done integrating different phases tool 
phase represented main activities artifacts 
way phases speak common language 
artifacts kept consistent changes automatic synchronization 
system facets availability 
java static ool traditional write compile debug execute life cycle 
controlcenter deployment automation expert allows application deployed server configuration easily 
server configurations determined development team visual deployment diagrams 
easier system available change fact tool offers static system evolution 
activeness 
tool completely reactive 
users enter input corresponds software design source code 
expects user initiate refactorings indicate applied parameters 
tool attempt better design inspecting static code system runtime 
just uses information gathered java compiler suggest completions corrections example suggest keyword completion correct spelling keywords 
openness 
controlcenter designed open extensible architecture 
third party tools integrated controlcenter integration api integration wizards provided tool 
easier incorporate third party tools wizards api 
provides list compatible third party tools 
change process plan 
tool highly integrated software development process 
offers set metrics measure system quality 
controlcenter include project management tools 
main activity missing tool analysis design implementation testing installation activities form 
artifacts produced software automatically synchronized tool recommended developments need follow unplanned change process extensive functionalities offered tool automatic synchronization 
control 
tool knowledge state system user manually modifies project source code 
information artifacts artifacts kept synchronized 
form partial control 
controlcenter controlled evolution application refactoring context refactorings defined behavior preserving actions 
tool presents types evolution uncontrolled ide context controlled refactoring context 
measure 
controlcenter includes quality assurance module 
module audits metrics 
metrics exist java cohesion coupling complexity volume size 
classified software change impact analysis metrics 
user define custom metrics framework provided tool 
controlcenter quality assurance expert tool 
permits generation web pages results metrics standard tabular form graphical form 
distribution graphs metric results requested advice panel displays tips high low metric values 
metric results saved reloaded 
tool permits comparison metric results 
tool comparison software evolution tools evaluated picked apparent differences existed see section application taxonomy 
idea tools share characteristics subjective opinion previous knowledge fact tools oriented different languages purposes 
visualworks smalltalk code 
smalltalk dynamic class object oriented language 
eclipse jdt java ide permits refactoring 
java smalltalk static class object oriented language 
guru restructures self code 
self prototypical object oriented language 
controlcenter manages great part production process java ide permits refactoring 
able see apparent differences exist tools real 
words impression correct 
thing notice comparing tools ides permit refactoring guru stand refactoring tool 
relationship visible comparison 
looking table tools share characteristics 
possible see tools compared depend external versioning systems 
explained variety versioning tools exist market cvs microsoft visual rational clearcase evaluated tools target developer main user 
evaluated tools local applications 
tools show amount automation act support tools development process reactive tools 
advances user interfaces tools user friendly easier 
applications longer built lemma mind user wants learn 
tools approached user way round 
tools manage medium fine elements 
global changes 
similarities show differences initially seen fundamental 
initial differences tool problem domain tool characteristics 
taxonomy error differentiation clear 
tool differ somewhat control center 
tool evaluated includes phases development process implementation 
automatic artifact synchronization speed development process 
important project development longer just question source code development necessity fast development phase resulting software reasonably stable mass produced 
guru differs fully automated really integrated ide 
visualworks evaluated tool fully interactive 
requests information user need know basis 
tools information user applying refactoring 
gives freedom aspect jdt permits user modification output produced refactoring accepting 
controlcenter tool open commercial tool 
extended third party tools 
evolution tool difficult say development third party tools 
hand tools open form source code visualworks reflection guru available eclipse extended plug ins 
taxonomy developed mens successfully applied software tools support refactoring evolutionary software development process 
differences identified tools motivated tool selection minor differences applying taxonomy 
reason initial differences tool problem domains 
tool problem domains different tools shared characteristics change history automation user distribution observing comparison table see table see ide tools share characteristics ide tool refactoring tool 
said characteristics refactoring tools 
result expected 
happened probably meant taxonomy badly defined 
tool manages differentiate tools evaluated controlcenter 
evaluated tool includes various phases development process evolutionary process implementation phase 
automatic artifact synchronization removes mismatch system design source code modifications 
important project development longer just question source code development necessity fast development phase resulting software reasonably stable mass produced 
possible reasons differentiation functionality controlcenter commercial tool 
tools open tools 
hope eclipse community tool eclipse rich functionality example controlcenter 
difference system extended third party tools externally developed tools second extended plug ins developed specially 
means evolution eclipse tool easier controlcenter real control third party tools developed 
interesting see years tool biggest share market 
smalltalk community happy visualworks ports different flavors language worked 
smalltalk community java community need development ides type structure environment smalltalk browser smalltalk ide 
additionally smalltalk extended modifying browsers directly 
guru tool interesting fully automated 
tool powerful fact new inheritance structure created independently existing inheritance structure 
uses algorithms effectively find better inheritance hierarchy designs 
puts category 
taxonomy easy apply times 
tools provided excessive documentation aspects ignored completely 
application taxonomy difficult cases 
study hardest tool evaluate controlcenter implementation details available commercial tool 
easiest tool evaluate visualworks 
immediate want apply taxonomy refactoring tools 
interesting generate library application taxonomy different evolutionary mechanisms tools 
evolutionary tool needed know features useful project ones hamper 
way easier development teams pick adequate evolutionary tool product 
clear tool comparison software evolution support tools incorporate design phase support apart implementation support 
specifically tools consider inclusion source code design refactorings 
controlcenter artifact synchronization important step direction 
tools evaluated help user decide refactorings apply 
refactoring applied selected application process low effort tools apply changes automatically 
refactoring selection process medium high effort activity 
effort lowered existence tools support selection process 
tools determine quality existing design decide changes quality higher 
research funded fwo project formal foundation software refactoring carried context scientific networks formal foundations software evolution research links explore advance software evolution financed fund scientific research flanders european science foundation respectively 
mens buckley rashid zenger taxonomy software evolution 
technical report vub prog tr vrije universiteit brussel submitted workshop unanticipated software evolution poland 
smalltalk visualworks eclipse org eclipse moore automatic inheritance hierarchy restructuring method refactoring 
proc 
int conf 
oopsla 
acm sigplan notices acm press controlcenter opdyke refactoring program restructuring aid designing object oriented application frameworks 
phd thesis roberts brant johnson refactoring tool smalltalk 
theory practice object systems roberts practical analysis refactoring 
phd thesis university illinois urbana champaign beck extreme programming explained embrace change 
addison wesley instantiations xref tech facet visualworks eclipse guru controlcenter time change change history irrelevant parallel async 
unversioned versioned frequency continuously continuously occasionally continuously role developer developer developer developer designer tester distribution local local local local automation semi automatic semi automatic fully automated semi automatic type structural structural structural structural semantic semantic effect alteration alteration non invasive non invasive highly invasive non invasive safety behavior high behavior high preserving safety preserving safety effort low low virtually low effort effort effort effort artifact smalltalk java self design uml source source source java code code code code tests documentation granularity medium coarse coarse coarse fine medium medium medium fine fine fine locality global global global global scope source code source code source code design source code availability dynamic static static static activeness reactive reactive reactive reactive openness source available plug source available integration api reflection architecture wizards plan indifferent unplanned planned unplanned control controlled refactoring controlled refactoring controlled controlled refactoring measure built support built support proposed quality oo metrics assurance table comparison software evolution tools evaluated 
