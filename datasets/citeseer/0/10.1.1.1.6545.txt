adaptive precision floating point arithmetic fast robust geometric predicates jonathan richard shewchuk may cmu cs school computer science carnegie mellon university pittsburgh pa exact computer arithmetic variety uses including limited robust implementation geometric algorithms 
report purposes 
offer fast software level algorithms exact addition multiplication arbitrary precision floating point values 
second propose technique adaptive precision arithmetic speed algorithms wishes perform calculations require exact arithmetic satisfy error bound 
third provide practical demonstration techniques form implementations common geometric calculations required degree accuracy depends inputs 
robust geometric predicates adaptive running time depends degree uncertainty result usually small 
algorithms computers floating point arithmetic uses radix exact rounding including machines complying ieee standard 
inputs predicates may arbitrary single double precision floating point numbers 
code publicly available orientation incircle tests robust delaunay triangulation tests 
timings implementations demonstrate effectiveness 
supported part natural sciences engineering research council canada science engineering scholarship national science foundation cms 
views contained document author interpreted representing official policies express implied nserc nsf government 
keywords arbitrary precision floating point arithmetic computational geometry geometric robustness orientation test incircle test delaunay triangulation contents arbitrary precision floating point arithmetic background properties binary arithmetic simple addition expansion addition simple multiplication expansion scaling compression approximation operations adaptive precision arithmetic adaptivity 
making arithmetic adaptive implementation geometric predicates related robust computational geometry orientation incircle tests orient orient incircle performance triangulation programs caveats tiebreaking rule important linear time expansion addition round tiebreaking report electronic copy report software described obtained web page www cs cmu edu quake robust html 
copyright jonathan richard shewchuk 
report may freely duplicated distributed long copyright notice remains intact 
please mail cs cmu edu comments corrections 
steven fortune douglas priest christopher van wyk provided comments draft papers provided foundations research 
steven fortune provided ln generated predicates timing comparisons unwittingly sparked research years ago brief email responses 
david hallaron james daniel comments 
ii software libraries arbitrary precision floating point arithmetic accurately perform error prone ill conditioned computations infeasible hardware supported approximate arithmetic 
computations accuracy requirements vary input 
instance consider problem finding center circle points lie circle 
normally hardware precision arithmetic suffice input points nearly collinear problem ill conditioned approximate calculation may yield wildly inaccurate result division zero 
alternatively exact arithmetic library yield correct result exact arithmetic slow really needs 
report presents techniques writing fast implementations extended precision calculations demonstrates implementations commonly geometric predicates 
technique suite algorithms new performing arbitrary precision arithmetic 
method greatest advantage computations process values extended small precision bits ideal computational geometry numerical methods benefit realized modest increase precision 
second technique way modify algorithms compute result adaptively quick circumstances slow results prone high relative error 
third subject report demonstration techniques implementations performance measurements commonly geometric predicates 
elaboration topics follows 
methods simulating exact arithmetic software classified characteristics 
exact arithmetic libraries operate integers fixed point numbers operate floating point numbers 
represent number libraries store significand arbitrary length store exponent 
libraries hardware integer arithmetic units floating point units 
oddly decision integers floating point numbers internally orthogonal type number represented 
norm integer arithmetic build extended precision floating point libraries especially floating point hardware uncommon differed computer models 
times changed modern architectures highly optimized floating point performance processors floating point arithmetic faster integer arithmetic 
trend reversing software libraries proposals floating point arithmetic perform extended precision integer calculations 
fortune van wyk clarkson boissonnat devillers preparata described algorithms kind designed attack computational geometry robustness problems considered report 
algorithms surveyed section 
differentiating feature libraries multiple exponents 
arbitrary precision libraries store numbers multiple digit format consisting sequence digits usually large radix coupled single exponent 
freely available example approach bailey package sophisticated portable library uses digits machine dependent radix usually stored single precision floating point values 
alternative multiple term format number expressed sum ordinary floating point words significand exponent 
approach advantage result addition gamma may arise calculations geometric predicates discussed section stored words memory multiple digit approach bits store sum incur corresponding speed penalty performing arithmetic 
hand multiple digit approach compactly represent numbers exponent stored 
sacrifices compactness take advantage floating point hardware jonathan richard shewchuk exponent digit unused 
pertinent difference speed discussed briefly section 
algorithms described floating point hardware perform extended precision floatingpoint arithmetic multiple term approach 
algorithms described section assumption hardware arithmetic performed radix exact rounding 
assumption holds processors compliant ieee floating point standard 
proofs correctness algorithms 
methods closely related occasionally taken directly methods developed priest faster 
improvement speed arises partly priest algorithms run wide variety floating point architectures different rounding behavior mine limited optimized radix exact rounding 
specialization justified wide acceptance ieee standard 
algorithms benefit relaxation priest normalization requirement strict normalization required multiple digit algorithms time consuming enforce 
demonstrate methods publicly available code performs dimensional threedimensional orientation incircle tests calculations commonly arise computational geometry 
orientation test determines point lies left right line plane important predicate geometric algorithms 
incircle test determines point lies inside outside circle sphere delaunay triangulation 
inexact versions tests vulnerable roundoff error wrong answers produce cause geometric algorithms hang crash produce incorrect output 
exact arithmetic difficulties common hear reports implementations slowed factors consequence 
reasons computational geometry important arena evaluating extended precision arithmetic schemes 
orientation incircle tests evaluate sign matrix determinant 
significant sign magnitude determinant needed 
fortune van wyk take advantage fact floating point filter determinant evaluated approximately forward error analysis indicates sign approximate result trusted exact test 
carry suggestion logical extreme computing sequence successively accurate approximations determinant stopping accuracy sign assured 
reduce computation time approximations reuse previous accurate computation economical 
procedures designed adaptive refine results certain correctness answer 
technique limited computational geometry limited finding signs expressions employed calculation required degree accuracy varies 
adaptive approach described section application orientation incircle tests described section 
readers wish predicates applications encouraged download try 
certain read section covers important issues considered ensure correctness implementation processor floating point behavior compiler optimization behavior 
furthermore aware exact arithmetic panacea robustness uses limitations discussed section 
exact arithmetic robust algorithms take geometric input return purely combinatorial output instance fully robust convex hull implementation produced recourse exact orientation test 
algorithms construct new geometric objects exact arithmetic constrained cost inability represent arbitrary irrational numbers 
arbitrary precision floating point arithmetic arbitrary precision floating point arithmetic background modern processors support floating point numbers form theta exponent significand bit binary number form bbb denotes single bit additional bit represents sign 
report address issues overflow underflow allow exponent integer range gamma 
fortunately applications inputs exponents fall circumscribed range 
predicates implemented report overflow underflow inputs exponents range gamma ieee double precision arithmetic 
floating point values generally normalized means value zero significant bit set exponent adjusted accordingly 
example bit arithmetic binary decimal represented theta see survey goldberg detailed explanation floating point storage formats particularly ieee standard :10.1.1.102.244
exact arithmetic produces values require bits store 
algorithms arbitrary precision value expressed expansion delta delta delta called component represented floating point value bit significand 
impose structure expansions required nonoverlapping ordered magnitude largest smallest 
floating point values nonoverlapping significant nonzero bit significant significant nonzero bit vice versa instance binary values gamma nonoverlapping overlap 
number zero overlap number 
expansion nonoverlapping components mutually nonoverlapping 
note number may represented possible nonoverlapping expansions consider gamma 
nonoverlapping expansion desirable easy determine sign take sign largest component produce crude approximation value take component largest magnitude 
floating point values adjacent overlap overlaps overlaps instance adjacent 
expansion nonadjacent components adjacent 
surprisingly floating point value corresponding nonadjacent expansion instance may appear representable nonoverlapping expansion bit components consider expansion gamma 
trick sign bit component separate larger neighbor 
see algorithms nonadjacent expansions arise naturally 
multiple term algorithms expansions defined faster multiple digit algorithms require expensive normalization results fixed digit positions multiple term algorithms allow boundaries terms wander freely 
boundaries enforced fall bit position 
addition usually takes time convert ordinary floatingpoint number internal format multiple digit library ordinary floating point number expansion length 
conversion overhead account significant part cost small extended precision computations 
central conceptual difference standard multiple digit algorithms multiple term algorithms described perform exact arithmetic keeping bit complexity operands small avoid roundoff error allow roundoff occur account note definition expansion slightly different priest priest requires exponents components expansion differ requirement 
formally nonoverlapping exist integers jyj jxj jonathan richard shewchuk fact 
measure roundoff quickly correctly certain standard accuracy required processor floating point units 
algorithms rely assumption addition subtraction multiplication performed exact rounding 
means exact result stored bit significand exact result produced rounded nearest bit floating point value 
instance bit arithmetic product theta rounded theta value falls precisely halfway consecutive bit values tiebreaking rule determines result 
possibilities round rule specifies value rounded nearest bit value significand round zero rule 
bit arithmetic rounded theta round rule theta zero rule 
ieee standard specifies round tiebreaking default 
report symbols phi psi omega represent bit floating point addition subtraction multiplication exact rounding 
due roundoff operators lack desirable arithmetic properties 
associativity example bit arithmetic phi phi phi phi 
list reliable identities floating point arithmetic knuth 
roundoff analyzed terms units place 
ulp effective magnitude low order pth bit bit significand 
ulp defined relative specific floating point value shall ulp denote quantity 
instance bit arithmetic ulp gamma ulp 
useful notation err denotes roundoff error incurred bit floatingpoint operation approximate real operation addition subtraction multiplication division operands note ulp unsigned quantity err signed 
basic operation err exact rounding guarantees ulp 
pages follow various properties floating point arithmetic proven algorithms manipulating expansions developed properties 
binary decimal numbers intermixed base apparent context 
number said expressible bits expressed bit significand counting sign bit exponent 
occasionally refer magnitude bit defined relative specific number instance magnitude second nonzero bit binary gamma 
remainder section quite technical reader may wish skip proofs reading 
key new results theorems provide algorithms summing scaling expansions 
properties binary arithmetic exact rounding guarantees ulp find smaller bound roundoff error evidenced lemmata 
lemma useful operand smaller second useful sum close power 
lemmata bit floating point numbers 
lemma phi err phi 
roundoff error phi larger jaj jbj 
analogous result holds subtraction 
proof assume loss generality jaj jbj 
sum phi bit floating point number closest bit floating point number phi jbj jaj 
see 
xi corollary roundoff error err phi expressed bit significand 
arbitrary precision floating point arithmetic phi demonstration lemmata 
vertical lines represent bit floating point values 
roundoff error distance phi lemma states error larger jbj 
lemma states ja bj gamma means falls darkened region error greater lemma useful computed value falls close power 
proof assume loss generality jaj jbj 
clearly significant nonzero bit err phi smaller magnitude ulp 
lemma phi jbj significand err phi longer follows err phi expressible bits 
lemma basic floating point operation err 
integer ja bj 
integer ja bj 
proof numbers gamma gamma expressible bits 
value ja bj distance numbers 
numbers gamma gamma expressible bits 
value ja bj distance numbers 
see 
xi lemmata identify special cases computer arithmetic exact 
shows addition subtraction exact result smaller magnitude operands 
lemma suppose ja bj jaj ja bj jbj 
phi 
analogous result holds subtraction 
proof loss generality assume jaj jbj 
clearly significant nonzero bit smaller magnitude ulp 
ja bj jbj 
follows expressed bits 
xi algorithms rely lemma shows subtraction exact operands factor jonathan richard shewchuk theta gamma gamma demonstrations lemma 
lemma suppose 
psi gamma proof loss generality assume jaj jbj 
case symmetric gammab psi gammaa 

difference satisfies ja gamma bj jbj jaj result follows lemma 
xi examples demonstrating lemma appear 
exponent floating point subtraction analogous finding difference bit integers sign result expressible bits 
exponents differ 
case difference smaller exponents expressed bits 
simple addition important basic operation algorithms performing arithmetic expansions addition bit values form nonoverlapping expansion length 
algorithms due dekker knuth respectively 
theorem dekker bit floating point numbers jaj jbj 
algorithm produce nonoverlapping expansion approximation represents roundoff error calculation fast sum phi virtual psi psi virtual return proof line computes may subject rounding err phi 
assumption jaj jbj sign 
line computes quantity virtual value really added line 
subtraction computed exactly fact proven considering cases 
sign jbj jaj apply lemma see 
hand opposite sign jbj jaj gamma gammaa apply lemma line showing computed exactly virtual see 
case subtraction exact virtual gamma err phi 
line computed exactly 
corollary gamma virtual phi expressible bits 
follows phi err phi exact rounding guarantees jyj ulp nonoverlapping 
xi arbitrary precision floating point arithmetic theta phi theta theta virtual psi psi virtual gamma demonstration fast sum sign 
sum expansion gamma 
theta gamma phi theta virtual psi gamma psi virtual demonstration fast sum opposite sign jbj jaj note outputs necessarily sign demonstrates 
subtraction fast diff implemented sequence psi virtual psi virtual psi proof correctness sequence analogous theorem 
difficulty fast sum requirement jaj jbj 
relative sizes unknown comparison required order invoking fast sum 
compilers fastest portable way implement test statement 
test takes time execute slowdown may surprisingly large modern pipelined superscalar architectures statement coupled imperfect microprocessor branch prediction may cause processor instruction pipeline drain 
explanation speculative machine dependent sum algorithm avoids comparison cost additional floating point operations usually empirically faster course fast sum remains faster relative sizes operands known priori comparison avoided 
theorem knuth bit floating point numbers 
algorithm produce nonoverlapping expansion exceptions identify optimize fabs math library call 
dec alpha workstation bundled compiler optimization level sum uses roughly time fast sum conditioned test 
sparcstation ipx gnu compiler optimization level sum uses roughly time 
hand sparcstation bundled compiler optimization produces slower code gcc conditional fast sum uses time sum 
lesson optimal speed time method machine compiler 
jonathan richard shewchuk phi theta virtual psi virtual psi virtual roundoff psi virtual roundoff psi virtual gamma roundoff phi roundoff demonstration sum jaj jbj jaj jxj 
sum expansion 
approximation roundoff error calculation sum phi virtual psi virtual psi virtual roundoff psi virtual roundoff psi virtual roundoff phi roundoff return proof jaj jbj lines correspond precisely fast sum algorithm 
recall proof theorem line calculated exactly follows line sum calculated exactly virtual expressed exactly 
roundoff zero roundoff computed exactly procedure correct 
suppose jaj jbj consider cases 
jxj jaj jbj computed exactly lemma 
immediately follows virtual virtual roundoff roundoff zero 
conversely jxj jaj lines may subject rounding err phi virtual err phi err psi 
see 
lines analogous lines fast diff line negated lines computed exactly 
virtual gamma virtual gamma err psi roundoff err psi 
jbj jaj jxj ja phi bj jbj roundoff errors err phi err psi ulp virtual lemma applied show line exact 
roundoff phi gamma err psi 
line exact corollary roundoff roundoff phi expressible bits 
follows phi err phi xi term subtraction diff implemented sequence psi virtual psi virtual phi virtual roundoff virtual psi roundoff psi virtual roundoff phi roundoff arbitrary precision floating point arithmetic corollary values returned fast sum sum 
jyj integer jx yj 
jyj integer jx yj 
proof roundoff error phi theorems results follow directly lemma 
xi corollary values returned fast sum sum 
machine arithmetic uses round tiebreaking nonadjacent 
proof exact rounding guarantees ulp 
inequality strict nonadjacent 
ulp round rule ensures significant bit significand zero nonadjacent 
xi expansion addition having established add bit values turn topic add arbitrary precision values expressed expansions 
methods available 
expansion sum adds component expansion component expansion mn time 
linear expansion sum fast expansion sum time 
despite asymptotic disadvantage expansion sum faster linear time algorithms cases size expansion small fixed program loops completely unrolled indirection overhead eliminated avoiding arrays 
linear time algorithms conditionals optimizations untenable 
expansion sum fast expansion sum implementations geometric predicates described section 
expansion sum linear expansion sum property outputs nonoverlapping inputs nonoverlapping nonadjacent inputs nonadjacent 
fast faster linear expansion sum performing floating point operations component disadvantages 
fast expansion sum preserve nonoverlapping nonadjacent property preserves intermediate property described 
second linear expansion sum assumption tiebreaking rule sum designed machines round tiebreaking fail machines tiebreaking rules 
third correctness proof fast expansion sum tedious 
fast expansion sum geometric predicates relegate slower linear expansion sum appendix users machines exact rounding round tiebreaking replace calls fast expansion sum calls linear expansion sum 
complicating characteristic algorithms manipulating expansions may spurious zero components scattered output expansions zeros input expansions 
instance expansions passed inputs expansion addition algorithms output expansion bit arithmetic 
may want add expansions produced expansions fortunately algorithms report cope spurious zero components input expansions 
unfortunately accounting zero components complicate correctness proofs significantly 
avoid confusion jonathan richard shewchuk sum sum sum sum oe oe oe oe operation grow expansion 
expansions illustrated significant components left 
sum boxes report observe convention larger output emerges left side box smaller output bottom right 
term approximate running total 
proofs addition scaling algorithms written input components nonzero 
spurious zeros integrated proofs fact noting effect zero input component produce zero output component changing value accumulator denoted variable 
effect likened pipeline delay clear proofs 
algorithm accompanying dataflow diagram 
readers find proofs easier understand follow diagrams reading proofs keep facts mind 
lemma indicates arrow sum box represents number larger input box 
zero input component yields zero output component 
second theorems indicate arrow sum box represents number small overlap number represented left arrow box 
algorithm adding single bit value expansion 
theorem nonoverlapping expansion bit components bit value 
suppose components sorted order increasing magnitude may zero 
algorithm produce nonoverlapping expansion components hm order increasing magnitude may zero 
furthermore nonadjacent round tiebreaking nonadjacent 
grow expansion sum gamma hm qm return approximate sum components see 
implementation array collapsed single scalar 
arbitrary precision floating point arithmetic proof iteration loop invariant holds 
certainly invariant holds line executed 
line theorem gamma deduce inductively invariant holds relevant values line executed output sum line property overlap 
lemma jh je nonoverlapping expansion nonzero components arranged increasing order overlap 
follows overlap components constructed summing components 
nonoverlapping increasing excepting zero components 
round tiebreaking nonadjacent corollary nonadjacent nonadjacent 
zero corresponding output component zero accumulator value unchanged gamma 
instance consider suppose zero 
accumulator value shifts pipeline zero output effect occurs algorithms report 
xi corollary components larger corresponding component 
jh je jh je jh je 
furthermore jh jbj 
proof follows immediately application lemma line 
facts apparent 
recall arrow sum box represents number larger input box 
xi long expansion optimizations advantageous 
binary search find smallest component greater equal ulp start 
variant idea search theorem 
second optimization early output sum operation inputs expansion nonoverlapping 
na way add expansion repeatedly grow expansion add component expansion 
improve idea small modification 
theorem nonoverlapping expansions bit components respectively 
suppose components sorted order increasing magnitude may zero 
algorithm produce nonoverlapping expansion components order increasing magnitude may zero 
furthermore nonadjacent round tiebreaking nonadjacent 
expansion sum hh grow expansion hh gamma return proof completion proven induction line 
setting expansion sum traverses expansion smallest largest component individually adding components grow expansion see 
theorem follow directly theorem component added expansion save jonathan richard shewchuk sum sum sum sum oe oe oe oe sum sum sum sum oe oe oe oe sum sum sum sum oe oe oe oe operation expansion sum 
time hh gamma considered 
optimization saves sum operations appear lower right corner 
considered components gamma summed corollary jh jf iteration line 
increasing nonoverlapping expansion overlap furthermore jh jf 
sums skip gamma components sacrificing nonoverlapping increasing properties similarly nonadjacent skip gamma components sacrificing nonadjacent property difficulty ensues spurious zero component zero overlap number 
grow expansion deposit zero continue normally 
xi expansion sum fast expansion sum preserve nonoverlapping nonadjacent properties guaranteed produce strongly nonoverlapping output inputs strongly nonoverlapping 
expansion strongly nonoverlapping components overlapping component adjacent components pair adjacent components property components expressed bit significand powers 
instance strongly nonoverlapping 
characteristic property zero bit occur expansion bits 
instance bit arithmetic strongly nonoverlapping expansion largest component greater 
nonadjacent expansion strongly nonoverlapping strongly nonoverlapping expansion nonoverlapping converse implications apply 
assumption expansions strongly nonoverlapping possible prove arbitrary precision floating point arithmetic sum sum sum fast sum oe oe oe oe operation fast expansion sum 
terms maintain approximate running total 
key result report fast expansion sum algorithm defined behaves correctly tiebreaking 
algorithm round zero arithmetic proof different 
emphasized round arithmetic due ieee standard 
variant algorithm priest differently 
priest uses algorithm sum nonoverlapping expansions proves general conditions components resulting expansion overlap digit bit binary arithmetic 
expensive renormalization step required afterward remove overlap 
contrast algorithm sum strongly nonoverlapping expansions result strongly nonoverlapping expansion 
surprisingly proof demands stringent conditions priest requires binary arithmetic exact rounding round tiebreaking consonant ieee standard 
renormalization needed 
theorem strongly nonoverlapping expansions bit components respectively 
suppose components sorted order increasing magnitude may zero 
machine arithmetic uses round rule algorithm produce strongly nonoverlapping expansion components order increasing magnitude may zero 
fast expansion sum merge single sequence order nondecreasing magnitude possibly interspersed zeros fast sum gamma sum gamma hm qm return approximate sum components see 
lemmata aid proof theorem 
proof sum correct 
lemma invariant iteration loop invariant gamma holds 
assures line executed algorithm produces correct sum 
jonathan richard shewchuk proof invariant clearly holds line executed 
larger values line ensures gamma gamma invariant follows induction 
xi lemma series formed merging strongly nonoverlapping expansions subseries thereof 
suppose largest term nonzero bit magnitude smaller integer gamma gamma 
proof expansions subsequences thereof formed assume term comes expansion largest term nonzero bit magnitude smaller strongly nonoverlapping jb ej bounded gamma 
instance jb ej 
bound applies expansion jb gj jb gamma 
omit sum cases consider 
jb gamma bounded bounded 
instance jb gamma 
conversely jb gamma bounded bounded gamma 
instance jb gamma 
case jb gamma jb gamma 
xi lemma expansion produced fast expansion sum nonoverlapping expansion components order increasing magnitude excepting zeros 
proof suppose sake contradiction successive nonzero components overlap occur order decreasing magnitude 
denote pair produced gamma components gamma nonoverlapping increasing excepting zeros 
assume loss generality exponent gamma zero gamma form sigma asterisk represents sequence arbitrary bits 
gamma produced sum fast sum operation nonadjacent corollary round rule 
form sigma having bits magnitude smaller 
jh gamma corollary guarantees jq gamma offending components gamma nonzero overlapping decreasing magnitude nonzero bit significand magnitude greater 
may ask offending bit come 
computed line offending bit come form sigma come jg nonzero bit magnitude smaller 
applying lemma finds bound gamma derived recalling gamma form sigma gamma nonoverlapping increasing 
gamma 
rewrite invariant form gamma gamma gamma bounds derived obtain jq gamma arbitrary precision floating point arithmetic ae gamma jq gamma demonstration invariant proof nonoverlapping 
top values summed form nonzero bit magnitude greater formed merging strongly nonoverlapping expansions sum gamma larger illustrated worst case example 
result jq gamma large roundoff error jh gamma smaller overlap 
note part sum appears box drawn placeholder bounds value expansion 
see concrete example 
inequalities hold simultaneously 
result follows contradiction 
xi proof theorem lemma ensures lemma eliminates possibility components overlap fail occur order increasing magnitude remains prove strongly nonoverlapping 
suppose successive nonzero components gamma adjacent 
assume loss generality exponent gamma zero gamma form sigma 
proof lemma form sigma 
gamma adjacent significant nonzero bit magnitude form sigma 
ask bit come 
bit come come jg nonzero bit magnitude 
applying lemma find gamma bounds gamma gamma derived recalling gamma form sigma largest component nonoverlapping expansion 
gamma gamma 
rewriting invariant form gamma gamma obtain jq invariant gives identity gamma gamma gamma jq gamma recall value jh 
consider possibility jh greater corollary occur jq contradicting inequality 
jh exactly expressible bit 
gives example occurs 
similarly value jh gamma 
consider possibility jh gamma greater corollary occur jq gamma contradicting inequality 
jh gamma exactly expressible bit 
implicitly assumed offending pair separated intervening zeros 
proof written consider case intervening zeros appear convoluted 
trust jonathan richard shewchuk sum sum sum fast sum oe theta oe oe oe theta theta gamma gamma bit example fast expansion sum generates adjacent components permits stab explaining admittedly thin intuition theorem suppose form sigma 
roundoff term associated form round arithmetic 
bit magnitude come implies je larger imposes bounds large jq jq lemma bounds turn imply jh larger jh larger 
furthermore adjacent bit magnitude 
corollary jq gamma jh gamma 
inequality inequality gamma invariant deduce formed nonoverlapping increasing expansions inequality implies jg gamma binary recalling form sigma having bits magnitude smaller 
form sigma produced sum fast sum operation nonadjacent corollary assuming round rule 
form sigma adjacent follows contain consecutive adjacent components 
arguments prove components adjacent expressible bit components adjacent 
strongly nonoverlapping 
xi proof theorem complex 
unfortunate proof requires strongly nonoverlapping expansions parsimonious fast expansion sum produced nonoverlapping output nonoverlapping input nonadjacent output nonadjacent input 
unfortunately 
counterexample possibility consider adding nonoverlapping expansion bit arithmetic 
example produces overlapping expansion uses round rule uses round zero rule 
counterexample possibility see 
personal note took quite bit effort find property nonoverlapping nonadjacent preserved fast expansion sum 
conjectures laboriously examined discarded converged strongly nonoverlapping property 
persisted algorithm consistently works practice 
unfortunate proof requires explicit consideration tiebreaking rule 
sum works just machine uses round zero rule 
conditions works simpler output expansion guaranteed nonoverlapping input expansions 
hope prove fast expansion sum works regardless rounding arbitrary precision floating point arithmetic mode possible 
appendix demonstrates difficulty example mixing round zero round arithmetic lead creation overlapping expansions 
algorithms expansion sum fast expansion sum mixed limited degree 
expansion sum preserves nonoverlapping nonadjacent properties strongly nonoverlapping property fast expansion sum preserves strongly nonoverlapping property 
nonadjacent expansions strongly nonoverlapping strongly nonoverlapping expansions nonoverlapping expansions produced exclusively algorithms fed input may dangerous repeatedly switch back forth algorithms 
practice preferred producing small expansions nonadjacent suitable input fast expansion sum 
useful consider operation counts algorithms 
expansion sum uses mn sum operations total mn flops floating point operations 
fast expansion sum uses gamma sum operations fast sum operation total gamma flops 
merge step fast expansion sum requires gamma comparison operations form je jf 
empirically comparison take roughly long flops rough measure estimate fast expansion sum takes long execute gamma flops 
estimates correlate measured performance algorithms 
implemented procedure function call parameters variable length expansions stored arrays measured dec alpha workstation bundled compiler optimization level 
plotting performance variety expansion sizes fitting curves expansion sum runs gamma microseconds fast expansion sum runs mn microseconds 
sum faster expansions component case grow expansion 
mentioned balance shifts expansion lengths small fixed 
storing small fixed length expansions scalar variables arrays unroll loops remove array indexing overhead allow components allocated registers compiler 
expansion sum attractive special case advantage implementation geometric predicates section 
note fast expansion sum difficult unroll conditionals initial merging step 
hand arrays store expansions non unrolled loops manage confers advantage spurious zero components easily eliminated output expansions 
procedures grow expansion expansion sum fast expansion sum procedures scale expansion compress sections come zero elimination achieved maintaining separate index output array advancing index procedure produces nonzero component practice versions algorithms eliminate zeros preferable versions don loop unrolling confers greater advantage 
zero elimination adds small amount overhead testing indexing lost time virtually regained operations performed resulting shortened expansions 
experience suggests economical unrolled versions expansion sum form expansions components tolerating interspersed zeros fast expansion sum zero elimination forming potentially larger expansions 
jonathan richard shewchuk simple multiplication basic multiplication algorithm computes nonoverlapping expansion equal product bit values 
multiplication performed splitting value halves half precision performing exact multiplications fragments 
trick find way split floating point value 
theorem proven dekker theorem bit floating point number 
choose splitting point gamma 
algorithm produce gamma bit value hi nonoverlapping gamma bit value lo ja hi ja lo hi lo split omega big psi hi psi big lo psi hi return hi lo claim may absurd 
hi lo gamma bits significand carry information bit significand 
secret hidden sign bit lo instance bit number split bit terms gamma 
property fortunate odd ieee double precision arithmetic split bit values 
proof line equivalent computing phi 
clearly expressed exactly multiplying value power changes exponent change significand 
line subject rounding err phi 
line subject rounding big err phi err psi 
apparent shortly proof relies showing exponent big greater exponent phi psi bounded ulp exponent big larger bit significand nonzero possibly bit arithmetic significand 
manually checking behavior split cases verify exponent big larger reason fact useful line implies psi ulp error term err psi expressible gamma bits 
lemma lines calculated exactly 
follows hi gamma err psi lo err psi expressible gamma bits 
show hi expressible gamma bits consider significant bit smaller ulp big ulp 
hi exponent hi expressible gamma bits alternatively hi exponent greater gamma err psi larger exponent hi expressible bit demonstrated 
exactness line implies hi lo required 
xi multiplication performed setting bit operands split bit pieces hi lo hi lo products hi hi lo hi hi lo lo lo computed exactly floating point unit producing values 
summed fast expansion sum procedure section 
dekker provides faster ways accomplish computation 
dekker attributes method veltkamp 
arbitrary precision floating point arithmetic theta omega theta big psi theta hi psi big theta lo psi hi gamma demonstration split splitting bit number bit numbers 
omega theta hi omega hi theta err psi hi omega hi theta lo omega hi theta err err psi lo omega hi theta hi omega lo theta err err psi hi omega lo gamma lo omega lo gammay err psi lo omega lo gamma demonstration product bit arithmetic hi hi lo lo 
note intermediate result expressible bits 
resulting expansion theta 
theorem bit floating point numbers 
algorithm produce nonoverlapping expansion ab approximation ab represents roundoff error calculation furthermore round tiebreaking nonadjacent 
see 
product omega hi lo split hi lo split err psi hi omega hi err err psi lo omega hi err err psi hi omega lo lo omega lo psi err return jonathan richard shewchuk proof line subject rounding ab err omega 
multiplications lines exact factor bits proven subtractions exact omega 
loss generality assume exponents gamma jaj jbj integers range gamma gamma 
proof theorem emerged ja hi jb hi integers range gamma ja lo jb lo integers range dp gamma 
ranges assumption derive inequalities ja lo ja hi jb lo jb hi err omega gamma ja hi hi intuitively hi hi ought factor omega line computed exactly lemma 
confirm note ab err omega hi hi lo hi hi lo lo lo err omega hi hi sigma ja hi hi inequalities stated justifies lemma 
line computed roundoff err lo hi hi lo lo lo err omega 
assured line executed roundoff error value err gamma lo hi hi lo lo lo err omega expressible bits 
prove property holds showing left hand expression multiple dp right hand expression strictly smaller upper bound absolute value right hand expression follows immediately upper bounds hi lo lo err omega 
show left hand expression multiple dp consider err multiple gamma omega hi hi exponents gamma 
err gamma lo hi multiple dp lo integer hi multiple dp line computed exactly err hi lo lo lo err omega 
show line computed roundoff error note lo lo integer greater gamma lo lo integers greater dp gamma err omega integer greater gamma err lo lo err omega integer greater expressible bits 
line exact simply omega expressed bits 
ab round tiebreaking nonadjacent analogy corollary 
xi expansion scaling algorithm multiplies expansion floating point value second key new result report 
theorem nonoverlapping expansion bit components bit value 
suppose components sorted order increasing magnitude may zero 
algorithm produce nonoverlapping expansion components order increasing magnitude may zero 
furthermore nonadjacent round tiebreaking nonadjacent 
scale expansion product product gamma gamma sum gamma gamma fast sum gamma return arbitrary precision floating point arithmetic prod prod prod prod oe oe oe oe sum sum sum fast sum fast sum fast sum oe oe oe oe oe oe operation scale expansion 
illustrated scale expansion multiplies component sums results 
apparent final expansion desired product obvious components guaranteed nonoverlapping increasing order 
lemmata aid proof 
lemma nonoverlapping nonzero components je je correctly rounded approximation component expansion exactly equal 
expansion produced line defined 
small magnitude overlap double width product furthermore nonadjacent adjacent proof scaling appropriate powers shifting exponents changing may assume loss generality integers magnitude je radix point falls 
follows integer je bj fact exact rounding imply jt overlap 
nonadjacent scale integer je jt adjacent 
xi lemma smallest integer je overlap 
jq jbj jh gamma gamma ulp 
proof inequality jq jbj holds line executed rounded larger magnitude je bj jbj jbj expressible bits 
larger values bound proven induction 
assume smallest integer je gamma inductive hypothesis jq gamma jbj 
gamma nonoverlapping multiple suppose smallest integer je je gamma jonathan richard shewchuk lines compute approximation gamma subject roundoff error lines 
suppose gamma sign jq gamma largest possible value jbj je largest possible value gamma assignments roundoff occur lines jq jq gamma bj jbj 
roundoff may occur monotonicity floating point multiplication addition ensures jq larger jbj 
inequality jh gamma gamma ulp guaranteed exact rounding gamma roundoff term associated computation line 
xi proof theorem prove inductively iteration loop invariant gamma holds 
certainly invariant holds line executed 
induction lines deduce invariant holds relevant values 
fast sum line justified shortly 
line executed shall prove components nonoverlapping showing time component written component smaller overlap accumulator remaining products component overlap portion sum 
claim component overlap accumulator true roundoff error incurred computing show component smaller overlap remaining products shall consider remaining odd components components separately 
component computed line overlap remaining products virtue lemma 
components computed line overlap remaining products application lemma line component jh gamma larger jt bounded turn lemma 
odd components computed line overlap remaining products virtue lemma guarantees jh gamma gamma ulp 
remaining products multiples ulp remaining components multiples 
round tiebreaking output sum fast sum product statement nonadjacent 
nonadjacent arguments easily modified show nonadjacent 
fast sum line justified jt jq gamma case fast sum works correctly 
see recall multiple defined lemma consider cases je computed exactly jt jbj jq gamma jq gamma je larger twice large jq gamma roundoff occurs zero jt jq gamma jt jq gamma note input component zero zero output components produced accumulator value unchanged gamma 
xi corollary demonstrates scale expansion compatible fast expansion sum 
corollary strongly nonoverlapping round tiebreaking strongly nonoverlapping 
proof nonoverlapping nonoverlapping theorem 
seen nonadjacent nonadjacent strongly nonoverlapping guaranteed strongly nonoverlapping may deviate 
arbitrary precision floating point arithmetic prod prod oe oe sum sum fast sum fast sum oe oe oe oe oe gamma gamma gamma gamma adjacent pair bit components strongly nonoverlapping input expansion may cause scale expansion produce adjacent pair bit components output expansion 
suppose successive components adjacent 
definition strongly nonoverlapping powers adjacent gamma integer satisfying components multiplication line exact 
applying lemma line gamma 
components gamma may cause difficulty see 
know nonoverlapping components adjacent neighbors 
arguments theorem prove nonadjacent nonadjacent round tiebreaking applied show gamma adjacent components produced may adjacent 
assume gamma adjacent overlapping 
computed line addend equal 
adjacent gamma produced line fast sum operation 
significant nonzero bit bit causes adjacent gamma come equal follows multiple ulp 
je lemma implies ulp 
ulp 
similarly je lemma implies gamma ulp 
components gamma adjacent case gamma ulp 
case components expressible bit 
adjacent pair bit components input give rise isolated adjacent pair bit components output adjacent components may appear 
strongly nonoverlapping xi compression approximation algorithms manipulating expansions usually express results compact form 
addition interspersed zero components mentioned easily eliminated common find components represent bits expansion value 
fragmentation jonathan richard shewchuk rarely severe cause largest component expansion poor approximation value expansion largest component may carry little bit significance 
component may result instance cancellation subtraction nearly equal expansions 
compress algorithm finds compact form expansion 
importantly compress guarantees largest component approximation expansion 
round tiebreaking compress converts nonoverlapping expansions nonadjacent expansions 
priest presents complicated renormalization procedure compresses optimally 
greater running time rarely justified marginal reduction expansion length need put expansions canonical form 
theorem nonoverlapping expansion bit components 
suppose components sorted order increasing magnitude may zero 
algorithm produce nonoverlapping expansion nonadjacent round tiebreaking components order increasing magnitude 
zero 
furthermore largest component approximates error smaller ulp 
compress bottom gamma downto fast sum bottom bottom bottom gamma bottom top bottom fast sum top top top top set length top return illustrates operation compress 
clarity separate arrays compress pseudocode combined single working array conflict replacing occurrence 
proof sketch compress works traversing expansion largest smallest component back smallest largest replacing adjacent pair component sum 
traversal largest smallest compression 
expansion gamma delta delta delta bottom produced lines property gamma ulp successive components overlap bit 
fact follows output fast sum line property arbitrary precision floating point arithmetic fast sum fast sum fast sum fast sum fast sum fast sum fast sum fast sum oe oe oe oe operation compress zero elimination occurs 
ulp value produced increased slightly subsequent addition smaller nonoverlapping components 
second traversal smallest largest clips overlapping bits 
fast sum line justified property gamma ulp guarantees sum components smaller smaller expansion top top gamma delta delta delta nonoverlapping nonadjacent round fast sum produces nonoverlapping nonadjacent output 
second traversal approximate total maintained accumulator component gamma produced fast sum operation produces roundoff term roundoff term greater ulp 
sum jh gamma gamma delta delta delta components nonoverlapping ulp jh gamma ulp 
xi ensure approximation second traversal necessary traversal effective reducing number components 
fastest way approximate simply sum components smallest largest reasoning result errs ulp 
observation basis approximate procedure predicates section 
theorem strongest statement compress 
compress effective components input expansion certain limited amount overlap 
furthermore bound jh gamma tight 
conjecture largest possible relative error exhibited number contains nonzero bit pth bit note ulp ulp delta delta delta compressed 
improvements complicate proof explored 
operations distillation process summing unordered bit values 
distillation performed divide conquer algorithm priest uses expansion addition algorithm sum values jonathan richard shewchuk component expansion sum expansion sum distillation sixteen bit floating point values 
tree fashion illustrated 
bit addend leaf tree interior node represents call expansion addition algorithm 
expansion sum zero elimination matter tree balanced distillation take precisely gamma sum operations regardless order expansions combined 
fast expansion sum speed distillation depends strongly balance tree 
balanced tree yield log distillation algorithm asymptotic improvement distilling expansion sum 
mentioned usually fastest unrolled expansion sum create expansions length fast expansion sum zero elimination sum expansions 
find product expansions scale expansion zero elimination form expansions ef ef sum distillation tree 
division course performed exactly performed arbitrary precision iterative algorithm employs addition multiplication 
consult priest algorithm 
easiest way compare expansions subtract test sign result 
expansion sign easily tested nonoverlapping property simply check sign expansion significant nonzero component 
zero elimination employed check component largest index 
nonoverlapping expansion equal zero components equal zero 
adaptive precision arithmetic adaptive precision arithmetic adaptivity 
exact arithmetic expensive avoided 
applications need exact results require absolute error result fall threshold 
threshold known computation performed economical employ adaptivity prediction 
writes procedures approximates result different degree precision correspondingly different speed 
error bounds derived procedures bounds typically cheaper compute approximations precise approximation 
particular input application computes error bounds uses choose procedure attain necessary accuracy cheaply 
determine computation accurate done 
example wishes bound relative error absolute error result 
special case determining sign expression result relative error 
result may prove larger error bound low precision arithmetic suffice may close zero necessary evaluate exactly satisfy bound relative error 
generally know advance precision needed 
context determinant evaluation computational geometry fortune van wyk suggest floating point filter 
expression evaluated approximately hardware precision arithmetic 
forward error analysis determines approximate result trusted exact result computed 
exact computation needed occasionally application slowed little 
hope improve idea computing sequence increasingly accurate results testing turn accuracy 
alas exact result required suffers cost exact computation additional burden computing approximate results advance 
fortunately possible intermediate results stepping stones accurate results done discarded refined 
making arithmetic adaptive fast sum sum product feature broken parts line computes approximate result remaining lines calculate roundoff error 
expensive calculation delayed needed needed 
sense routines adaptive produce result needed 
describe achieve effect general expressions 
expression composed addition subtraction multiplication operations calculated adaptively manner defines natural sequence intermediate results accuracy appropriate test 
sequence easily described considering tree associated expression 
leaves tree represent floating point operands internal nodes represent operations 
replace node children leaves sum represents approximate value subexpression represents roundoff error incurred calculating expand expression form polynomial 
terms containing occurrences variables dominated terms containing fewer occurrences 
example consider expression gamma gamma jonathan richard shewchuk expansion sum product sum expansion component terms terms term terms formula square distance points 
lowest subexpressions tree expressed sum approximate value roundoff error 
simple incremental adaptive method evaluating expression 
approximations generated tested turn 
final expansion exact 
includes terms size ffl gamma larger error greater ffl 
incremental adaptivity taken extreme 
subexpression trees calculated adaptively 
contains terms needed reduce error ffl 
calculates square distance points plane 
set gamma gamma resulting expression expanded full significant small relative corresponding standard terminology forward error analysis quantity ulp called machine epsilon denoted ffl 
recall exact rounding guarantees jy quantity ffl bounds relative error err basic floating point operation 
note ffl gammap ieee double precision arithmetic ffl gamma single precision ffl gamma expression divided parts having magnitudes ffl ffl respectively 
denote parts generally expression expanded manner sum products containing variables magnitude ffl 
adaptive precision arithmetic ct ct ct adaptive method intermediate complexity frequently efficient 
achieves ffl error bound adding inexpensive term labeled ct gamma obtain approximation error larger ffl computing exactly sum terms gamma sequence increasingly accurate approximations formed incrementally exact sum gamma gamma members sequence generated tested illustrated sufficiently accurate 
intricate method modify technique subexpressions computed adaptively 
produce approximation having error magnitude ffl need approximate term error ffl approximations summed exactly form result term magnitude ffl need approximated better relative error ffl gammak 
approach may economical adaptive choices prediction 
incrementally illustrated cost usually unnecessarily large unbalanced additions overhead keeping track small pieces sum 
better method incremental adaptivity derive geometric predicates section falls described 
method compute sequence define 
obtain approximation error larger ffl take gamma add exactly inexpensive term approximates gamma ordinary floating point arithmetic form new approximation illustrated 
term reduces jonathan richard shewchuk error ffl gamma ffl nearly accurate takes compute 
scheme reuses done performing exact calculations reuse terms 
value computed method approximation sufficiently accurate unnecessary compute terms exact arithmetic techniques 
recall terms expensive compute terms 
test identical fortune van wyk floating point filter 
method stage computation method typically terminates stage earlier 
slower exact result computed generally faster applications rarely need exact result 
cases may desirable test members sequences accuracy predicates defined section 
reader may wonder writing expression sum products form isn inefficient 
ordinary floating point arithmetic little difference exact arithmetic algorithms section 
multiplication operation described section multiplies expansions expanding product sum products form 
ideas exclusively applicable multiple term approach arbitrary precision arithmetic 
multiple digit formats details differ 
implementation geometric predicates related robust computational geometry geometric algorithms originally designed robustness real ram model quantities allowed arbitrary real numbers arithmetic exact 
ways geometric algorithm correct real ram model go wrong encounter roundoff error 
output incorrect correct perturbation input 
result usable valid imaginable input 
program may simply crash fail produce result 
reflect possibilities geometric algorithms divided classes varying amounts robustness exact algorithms correct robust algorithms correct perturbation input stable algorithms perturbation small quasi robust algorithms results geometrically inconsistent satisfy weakened consistency criterion fragile algorithms guaranteed produce usable output 
pages devoted discussion representative research class circumstances exact arithmetic techniques applicable 
extensive surveys geometric robustness see fortune hoffmann 
exact algorithms 
geometric algorithm exact guaranteed produce correct result exact input 
course input geometric algorithm may approximation real world configuration difficulty ignored 
exact algorithms exact arithmetic form form library disguised form 
exact arithmetic schemes designed specifically computational geometry methods exactly evaluating sign determinant perform orientation incircle tests 
clarkson proposes algorithm floating point arithmetic evaluate sign determinant small matrix integers 
variant modified gram schmidt procedure improve conditioning matrix determinant subsequently evaluated safely gaussian elimination 
bits significand available ieee double precision numbers sufficient implementation geometric predicates operate theta matrices bit integers 
clarkson algorithm naturally adaptive running time small matrices determinants near zero boissonnat devillers preparata proposed algorithm evaluate signs determinants theta theta matrices bit integers bit arithmetic respectively 
surprisingly sufficient implement test normally written theta theta determinant handicap bit complexity bit double precision arithmetic sufficient correctly perform test points having bit integer coordinates 
fortune van wyk propose general approach specific determinants predicates represents integers standard multiple digit technique digits radix stored double precision floating point values 
bit double precision possible add products bit integers necessary normalize 
general purpose arbitrary precision library developed ln expression compiler writes code evaluate specific expression exactly 
size operands arbitrary fixed ln run expression generate functions arguments different bit lengths 
expression bit lengths operands fixed advance ln tune exact arithmetic aggressively eliminating loops function calls memory management 
running time function produced ln depends bit complexity inputs 
fortune van wyk report order magnitude speed improvement libraries equal bit complexity 
furthermore ln gains speed improvement installing floating point filters appropriate calculating error bounds automatically 
lieber report experiences optimizing method determinant evaluation rational inputs 
approach reduces bit complexity inputs performing arithmetic intervals low precision bounds exact values 
determinant evaluated interval contains zero precision increased determinant reevaluated 
procedure repeated interval contain zero contains zero result certain 
approach adaptive appear results iteration speed 
clarkson algorithms effectively restricted low precision integer coordinates compare performance algorithms theirs may faster 
floating point inputs difficult integer inputs partly potential bit complexity intermediate values grow quickly 
algorithm suffers difficulty probably competitive techniques discussed may best existing alternative algorithms require rational numbers computing exact line intersections 
necessary algorithm floating point coordinates aforementioned methods currently option possible adapt techniques section 
am aware prior literature exact determinant evaluation considers floating point operands limited example ottmann advocate accurate scalar product operation ideally implemented hardware software distillation algorithm may way evaluate predicates orientation test 
exact determinant algorithms satisfy needs applications 
program computes line intersections requires rational arithmetic exact numerator exact denominator stored 
method clarkson correctly determinant exactly zero clarkson personal communication notes easily fixed 
keeping track scaling done algorithm upper bound maintained magnitude determinant matrix 
upper bound drops determinant zero matrix entries integers algorithm 
jonathan richard shewchuk intersections may endpoints lines generate intersections intersections greater greater bit complexity may generated 
exact rational arithmetic sufficient solid modeler instance need determine vertices intersection independent solids rotated arbitrary angles 
exact floating point arithmetic cope rotating square ffi plane irrational vertex coordinates result 
problem solvable storing coordinates symbolic form resolving combinatorial queries great numerical care treatment certainly expensive 
remainder discussion consideration restricted algorithms input geometric coordinates specified output purely combinatorial construction convex hull arrangement hyperplanes 
robust algorithms 
algorithms correct straightforward implementations exact arithmetic suffer unacceptable loss speed 
alternative relax requirement correct solution accept solution close sense depends application 
exact arithmetic algorithm find way produce sensible output despite fact geometric tests occasionally tell lies 
general techniques emerged army appeared specific algorithms usually ensuring robustness quasi robustness painstaking design error analysis 
lack generality techniques limitation relaxed approach robustness fundamental difficulty deserves careful discussion 
disaster strikes real ram correct algorithm implemented floating point arithmetic fails produce meaningful result algorithm performed tests results mutually contradictory 
shows error arose dimensional delaunay triangulation program wrote 
program employs divide conquer algorithm guibas stolfi failed subroutine merges triangulations 
geometrically nonsensical triangulation illustration produced 
close inspection debugger failure caused single incorrect result incircle test 
bottom appear nearly collinear points deviation collinearity greatly exaggerated clarity 
points sorted coordinates correctly established orientation tests lie line ac line ad 
principle program deduce facts fall inside circle 
unfortunately incircle test incorrectly declared lay inside leading invalid result 
significant incircle test just wrong particular points inconsistent known combinatorial facts 
correct algorithm computes purely combinatorial result produce meaningful result test results wrong consistent exists input test results correct 
fortune algorithm robust produces correct output real ram model approximate arithmetic produces output consistent hypothetical input perturbation true input stable perturbation small 
typically bounds perturbation proven backward error analysis 
approximate arithmetic fortune gives algorithm computes planar convex hull correct points perturbed relative error ffl ffl defined section algorithm maintains triangulation planar perturbing vertex relative error ffl number vertices 
surprising stable algorithm keep triangulation planar consider problem inserting new vertex close existing edge difficult discern side edge vertex falls 
exact arithmetic prevent possibility creating inverted triangle 
implementation geometric predicates top left delaunay triangulation 
top right invalid triangulation created due roundoff error 
bottom exaggerated view inconsistencies led problem 
algorithm knew point lay lines ac ad incorrect incircle test claimed lay inside circle 
jonathan richard shewchuk wonder triangulation program robust avoiding test result inferred previous tests 
fortune explains algorithm parsimonious performs test outcome determined formal consequence previous tests 
parsimonious algorithm clearly robust path algorithm correspond geometric input making algorithm parsimonious obvious way making robust 
principle possible algorithm parsimonious primitive tests polynomial sign evaluations question current test logical consequence previous tests phrased statement existential theory reals 
theory np hard decidable polynomial space 
unfortunately full power theory necessary problems 
example line arrangement problem set lines specified real coordinates ax compute combinatorial structure resulting arrangement plane 
follows problem deciding combinatorial arrangement realizable lines hard existential theory reals 
parsimonious algorithm line arrangement problem require solution np hard problems 
exact arithmetic require solution np hard problems intermediate course possible employ parsimony efficient resort exact arithmetic 
consistency guaranteed exact tests bootstrap parsimony engine 
am aware algorithms literature take approach geometric algorithms designed authors avoid obviously redundant tests 
quasi robust algorithms 
difficulty determining line arrangement realizable suggests exact arithmetic robustness defined unattainable goal 
settle algorithm output realizable 
place algorithms bag labeled fuzzy term quasi robust apply algorithm output provably distinguishable nonsense 
milenkovic circumvents aforementioned np hardness result approximate arithmetic constructing pseudo line arrangements pseudo line curve constrained lie close actual line 
fortune presents delaunay triangulation algorithm constructs approximate arithmetic triangulation nearly delaunay defined sense pseudo line notion 
unfortunately algorithm running time compares poorly log time optimal algorithms 
milenkovic fortune algorithms quasi stable having small error bounds 
milenkovic algorithm thought quasi robust algorithm line arrangements robust algorithm pseudo line arrangements 
degree robustness required application typically determined output 
instance point location algorithms fail non planar triangulation 
reason crashed producing flawed triangulation 
reader take lessons section 
problems due roundoff severe difficult solve 
second inputs imprecise user isn accuracy output internal consistency may necessary output produced exact arithmetic may required exact results aren 
third exact arithmetic clever handling tests tell universal 
exact arithmetic attractive applicable employed na program developers time consuming need careful analysis particular algorithm behavior faced imprecision 
occasionally hear implementations half developers time spent solving problems roundoff error degeneracy 
efforts improve speed exact arithmetic computational geometry justified 
implementation geometric predicates orientation incircle tests points plane 
define procedure orient returns positive value points arranged counterclockwise order negative value points clockwise order zero points collinear 
common symmetric interpretation orient returns positive value lies left directed line ab purpose orientation test geometric algorithms 
define procedure incircle returns positive value lies inside oriented circle abc 
oriented circle mean unique possibly degenerate circle points occurring counterclockwise order circle 
points occur clockwise order incircle reverse sign output circle exterior interior 
incircle returns zero points lie common circle 
orient incircle symmetry property interchanging parameters reverses sign result 
definitions extend trivially arbitrary dimensions 
instance orient returns positive value lies oriented plane passing oriented plane mean appear counterclockwise order viewed plane 
apply left hand rule orient left hand fingers follow circular sequence abc 
thumb points orient returns positive value 
generalize orientation test dimensionality unit vectors orient defined orient 
dimension orientation incircle tests may implemented matrix determinants 
dimensions orient fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi gamma gamma gamma gamma gamma gamma gamma gamma gamma fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi fi gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma fi fi fi fi fi fi fi fi fi formulae generalize dimensions obvious way 
expressions shown equivalent simple algebraic transformations expressions little effort 
equivalences unsurprising expects results orientation incircle test change points undergo identical translation plane 
expression instance follows expression translating point gammad 
computing determinants techniques section choice expressions straightforward 
principle expression preferable jonathan richard shewchuk shaded triangles translated origin incurring roundoff error lemma 
triangulations triangles common case 
produce component expansion expression produce expansion having components 
numbers somewhat misleading zero elimination expansions rarely grow longer components real applications 
expression takes roughly time compute exact arithmetic expression takes time expression 
disparity increases higher dimensions 
mechanics error estimation turn tide direction 
important fast exact test equally important avoid exact tests possible 
expressions tend smaller errors correspondingly smaller error estimates errors function relative coordinates points errors expressions function absolute coordinates points 
geometric applications points serve parameters geometric tests tend close 
commonly absolute coordinates larger distances 
translating points lie near origin working precision freed subsequent calculations 
errors error bounds expressions generally smaller expressions 
furthermore translation done roundoff error 
demonstrates toy problem suppose orient find orientation triangle triangulation 
lemma shaded triangle translated vertices lies origin roundoff error white triangles may may suffer roundoff translation 
complete triangulation larger portion illustrated small proportion triangles near coordinate axis suffer roundoff 
exact translation common case adaptive geometric predicates test exploit case 
implementation geometric predicates determinant chosen evaluation methods evaluate 
number methods surveyed fortune van wyk repeated 
cheapest method evaluating determinant theta smaller matrix dynamic programming applied cofactor expansion 
evaluate gamma delta determinants theta minors columns gamma delta determinants theta minors columns 
predicates method 
orient implementation orient computes sequence results labeled illustrated 
exact result may long sixteen components zero elimination length components common practice 
logical places test accuracy result continuing 
applications majority calls orient floating point approximation computed resort exact arithmetic techniques 
component expansion error ffl appropriate value test exact result subtractions bottom expression tree performed roundoff error corresponding shaded triangles 
common case orient explicitly tests execution continues roundoff occurred translation coordinates smaller error bound 
corrected estimate error bound ffl 
sufficiently accurate exact determinant computed 
unusual features test arise sign determinant needed 
term added form added exactly approximate procedure section find approximation term added possibility roundoff error 
consequent errors may magnitude normally preclude obtaining error bound ffl 
sign determinant questionable magnitude ffl ffl error bound established 
second interesting feature sufficiently accurate approximations computed computing exact determinant 
understand consider collinear points determinant defined points zero 
coordinate points perturbed single ulp determinant typically increases ffl 
guess determinant larger ffl probably zero 
intuition hold practice predicates considered random practical point sets 
determinants don approximation nearly zero 
derivation error bounds values tricky example 
easiest way apply forward error analysis expression value calculated floating point arithmetic express exact value subexpression terms computed value plus unknown error term magnitude bounded 
instance error incurred computation phi larger 
furthermore error smaller bj 
bounds useful different circumstances 
represents true value abbreviated way expressing notions write sigma sigma 
henceforth notation shorthand relation satisfies jj jj 
consider error bound subexpression expression tree orientation test denote true exact value approximate value follows 
jonathan richard shewchuk component expansion diff product expansion sum expansion diff estimate adaptive calculations orientation test 
dashed boxes represent nodes original expression tree 
gamma psi gamma psi gamma psi gamma psi omega omega gamma psi definitions clear sigma similar bounds hold observe implementation geometric predicates approximation error bound ffl ffl omega jx phi jx ffl ffl omega jx phi jx ffl ffl omega jb phi ffl ffl omega jx phi jx table error bounds expansions calculated orient 
bit approximation expansion computed approximate procedure 
note coefficient expressible bits 
omega sigma follows sigma ffl ffl jx sigma sigma ffl ffl jx sigma sigma ffl ffl ffl jx similarly sigma ffl ffl ffl jx may odd keeping track terms smaller ffl effort find smallest coefficient error bound justified prevents determinant computation expensive necessary 
error bound derived 
gamma gamma sigma ffl ffl ffl jx jx sigma sigma ffl ffl ffl jx jx minimize effect term advantage fact interested sign conclude certainty correct sign gamma ffl jaj 
ffl ffl ffl jx jx true jaj ffl ffl ffl jx jx bound directly applicable computation incur roundoff error 
account multiply coefficient ffl factor ffl addition jx jx factor multiplication 
secure sign correct jaj ffl ffl ffl omega jx phi jx bound directly applicable coefficient expressible bits 
rounding bit number coefficient ffl ffl exactly computed program initialization reused call orient 
error bounds table 
bound takes advantage theorem shows approximates relative error ffl 
recall section largest component bit precision 
bounds pleasing property zero common case input points lie horizontal vertical line 
orient usually resorts exact arithmetic collinear input points performs approximate test cases occur commonly practice 
jonathan richard shewchuk double precision orient timings microseconds points uniform geometric nearly method random random collinear approximate exact exact exact adaptive approximate adaptive adaptive adaptive exact ln adaptive approximate ln adaptive exact table timings orient dec mhz alpha processor 
determinants version expression stable expression indicated 
columns indicate input points generated uniform random distribution geometric random distribution 
third column considers points chosen random distributions third point chosen approximately collinear 
timings adaptive tests categorized result generated 
timing average randomly generated inputs 
input time measured unix system call iterations predicate 
individual timings vary approximately 
timings bailey package fortune van wyk ln package included comparison 
compiler effects affect implementation orient 
separating calculation remaining calculations procedures calling necessary reduced time compute presumably improvements compiler ability perform register allocation 
table lists timings orient random inputs 
observe adaptive test stops approximate result takes nearly twice long approximate test need compute error bound 
table includes comparison bailey chosen fastest portable freely available arbitrary precision package know 
orient coded nonadaptive algorithms roughly thirteen times faster orient coded 
included comparison orientation predicate bit integer inputs created fortune van wyk ln 
ln generated orientation predicate quite fast takes advantage fact restricted bounded integer inputs 
exact tests cost twice ln reasonable price pay ability handle arbitrary exponents input 
timings story ln static error estimate typically larger runtime error estimate adaptive stage ln uses stages adaptivity ln generated predicates slower applications section demonstrate 
significant bit integer inputs multiple stage predicates rarely pass stage initial translation usually done roundoff error ln generated orient usually takes twice long produce exact result 
emphasized inherent differences ln multiple digit integer approach multiple term floating point approach ln principle employ runtime error estimate similar multiple stage adaptivity scheme 
implementation geometric predicates component expansion diff product scale expansion expansion sum expansion diff estimate adaptive calculations orientation test 
bold numbers indicate length expansion 
part expression tree shown cofactors omitted results appear dashed components expansions 
orient incircle illustrates implementation orient similar orient implementation 
standard floating point result 
exact subtractions bottom tree incur roundoff 
represents drop error bound ffl ffl 
exact determinant 
jonathan richard shewchuk approximation error bound ffl ffl omega ff phi ff phi ff ffl ffl omega ff phi ff phi ff ffl ffl omega jb phi ffl ffl omega ff phi ff phi ff ff jx omega jx phi jx ja psi omega psi omega psi phi psi omega psi ff jb psi omega psi omega psi phi psi omega psi ff jc psi omega psi omega psi phi psi omega psi table error bounds expansions calculated orient 
double precision orient timings microseconds points uniform geometric nearly method random random coplanar approximate exact exact exact adaptive approximate adaptive adaptive adaptive exact ln adaptive approximate ln adaptive exact table timings orient dec 
determinants expression stable expression indicated 
timing average randomly generated inputs 
input time measured unix system call iterations predicate 
error bounds largest component expansions table partly terms variables 
bounds zero input points share coordinate approximate test needed common instances coplanarity 
table lists timings orient random inputs 
error bound expensive compute increases amount time required perform approximate test adaptive case factor half 
gap exact algorithm smaller case factor nearly 
oddly table reveals calculated quickly exact result calculated nonadaptive version orient 
explanation probably computed determinant zero close zero lengths intermediate expansions smaller usual computation time 
furthermore point coordinates translated roundoff error adaptive predicate ignores branches expression tree evaluate zero 
incircle implemented similarly orient determinants similar 
corresponding implementation geometric predicates approximation error bound ffl ffl omega ff phi ff phi ff ffl ffl omega ff phi ff phi ff ffl ffl omega jb phi ffl ffl omega ff phi ff phi ff ff psi phi psi omega psi omega psi phi psi omega psi ff psi phi psi omega psi omega psi phi psi omega psi ff psi phi psi omega psi omega psi phi psi omega psi table error bounds expansions calculated incircle 
squares approximate 
double precision incircle timings microseconds points uniform geometric nearly method random random approximate exact exact exact adaptive approximate adaptive adaptive adaptive exact ln adaptive approximate ln adaptive exact table timings incircle dec 
determinants version expression stable expression indicated 
timing average randomly generated inputs adaptive stage 
difficult generate cases reach stage 
input time measured unix system call iterations predicate 
error bounds appear table timings appear table 
timings appear table 
implementation differs tests due programmer laziness computed incrementally accurate computed scratch 
fortunately usually accurate 
ln exact tests advantage factor roughly incircle cost handling floating point operands greater larger expressions 
orientation tests cost mediated better error bounds stage adaptivity 
timings exact versions predicates show sensitivity distribution operands take longer execute geometrically distributed operands exponents vary widely uniformly distributed operands 
difference occurs intermediate final expansions larger operands broadly distributed exponents 
exact orientation predicates cheapest inputs collinear coplanar smaller expansions result effect occur exact incircle predicates 
jonathan richard shewchuk double precision timings microseconds points uniform geometric nearly method random random approximate exact exact exact adaptive approximate adaptive adaptive adaptive exact ln adaptive approximate ln adaptive exact table timings dec 
determinants expression stable expression indicated 
timing average randomly generated inputs adaptive stage input time measured unix system call iterations predicate 
performance triangulation programs evaluate effectiveness adaptive tests applications tested delaunay triangulation codes 
triangle delaunay mesh generator publicly available netlib uses divide conquer algorithm 
pyramid delaunay uses incremental algorithm 
types inputs tested uniform random points points lying approximately boundary circle sphere square cubic grid lattice points tilted aligned coordinate axes 
chosen 
lattices tilted approximate arithmetic perfectly cubical exponents coordinates vary ln 
tried perfect lattices bit integer coordinates orient pass stage perturbed lattices preferred occasionally force predicates stage 
results appear table indicate stage predicates add total running time randomly distributed input points mainly error bound tests 
difficult point sets penalty may great 
course penalty applies precisely point sets cause difficulties exact arithmetic available 
results outlined table pleasing 
stage predicates add total running time randomly distributed input points points distributed approximately surface sphere penalty factor eleven 
penalty tilted grid uncertain tetrahedralization program approximate arithmetic failed terminate 
debugger revealed point location routine stuck infinite loop geometric inconsistency introduced mesh due roundoff error 
robust arithmetic slower 
programs program stage predicates exception faster ln equivalents 
surprise considering stage predicates accept bit floating point inputs ln generated predicates restricted bit integer caveats divide conquer delaunay triangulation uniform perimeter tilted random circle grid input sites orient calls adaptive approximate adaptive adaptive adaptive exact average time ln approximate ln exact ln average time incircle calls adaptive approximate adaptive adaptive adaptive exact average time ln approximate ln exact ln average time program running time seconds approximate version robust version ln robust version table statistics divide conquer delaunay triangulation point sets 
inputs 
integer predicates probably outperform floating point predicates adopt runtime error estimate similar stage adaptivity scheme 
caveats unfortunately arbitrary precision arithmetic routines described universally portable hardware compilers prevent functioning correctly 
compilers interfere making invalid optimizations misconceptions floating point arithmetic 
instance clever incorrect compiler cause expansion arithmetic algorithms fail deriving fact virtual computed line fast sum equal optimizing subtraction away 
optimization valid computers stored arbitrary real numbers incorrect floating point numbers 
unfortunately compiler developers aware importance maintaining correct floating point language semantics improving 
goldberg presents related examples carefully designed numerical algorithms utterly incorrect optimizations 
jonathan richard shewchuk incremental delaunay tetrahedralization uniform surface tilted random sphere grid input sites orient counts adaptive approximate adaptive adaptive adaptive exact average time ln approximate ln exact ln average time counts adaptive approximate adaptive adaptive adaptive exact average time ln approximate ln exact ln average time program running time seconds approximate version robust version ln robust version table statistics incremental delaunay tetrahedralization point sets 
approximate code failed terminate tilted grid input 
floating point units binary arithmetic exact rounding including conform ieee standard subtle properties undermine assumptions algorithms 
common difficulty presence extended precision internal floating point registers intel pentium processors 
registers usually improve stability floating point calculations cause methods described determining roundoff operation fail 
possible workarounds problem 
possible designate variables volatile implying stored memory 
ensures variable rounded bit significand operation 
forcing intermediate values stored memory reloaded slow algorithms significantly worse consequence 
volatile variable doubly rounded rounded internal extended precision format rounded single double precision stored memory 
result double rounding correctly rounded final precision priest page describes case roundoff error produced double rounding may expressible bits 
alleviated complex slower version fast sum 
better solution configure processor round internally double precision 
processors internal extended precision registers configured compilers provide support manipulating processor control state support varies compilers portable 
speed advantage multiple term methods worth trouble learn right correctly configure processor 
algorithms correctly special treatment current unix workstations 
users careful trying routines moving new platform ensure underlying assumptions method violated 
algorithms simple fast looking difficult imagine expansions summed fewer operations special hardware assistance 
features techniques account improvement speed relative techniques especially numbers precision components length 
relaxation usual condition numbers normalized fixed digit positions 
enforces weaker condition expansions nonoverlapping strongly nonoverlapping 
expansions summed resulting components nonoverlapping cost floating point operations comparison component 
normalization fixed digit positions done quickly portable way current processors 
second feature attribute improved speed fact packages require expensive conversions ordinary floating point numbers packages internal formats 
techniques priest describe conversions necessary 
reader may misled attribute difference algorithms fact store double precision components stores single precision digits imagine difference go away reimplemented double precision 
belief misunderstanding works 
uses double precision arithmetic internally obtains exact results digits narrow multiplied exactly 
digits integral part approach calculate exactly avoiding roundoff error 
surprise multiple term methods reasonable speed attained allowing roundoff happen accounting fact 
fast multiple term algorithms reasonably portable making assumptions machine binary arithmetic exact rounding round tiebreaking sum linear expansion sum 
representation dependent tricks bit masking extract exponent fields 
machines execute algorithms correctly numbers ieee standard entrenched 
greatest limitation multiple term approach easily extends precision floating point numbers simple way extend exponent range losing speed 
obvious approach associating separate exponent field component sure slow 
promising approach express number consisting digits large radix digit expansion coupled exponent 
scheme true exponent component sum component exponent exponent expansion contains 
fast algorithms described report add multiply individual digits digits normalized standard methods 
ieee double precision values exponent range gamma multiply digits radix simple expansion multiplication algorithm digits radix slightly complicated splits digit half multiplying 
jonathan richard shewchuk code publicly available form extensive library arithmetic routines similar great deal remains done 
addition problem expanding exponent range problem particular multiple term approach possible fft multiplication algorithms renormalizing expansion multiple digit form 
normalization difficult costs time puts multiple term method disadvantage relative methods keep numbers digit form matter course 
priest points multiple term algorithms implement extended finite precision arithmetic exact arithmetic simply compress truncate result fixed number components 
greatest potential algorithms lies arbitrary precision libraries providing fast simple way extend slightly precision critical variables numerical algorithms 
difficult provide routine quickly computes intersection point segments double precision endpoints correctly rounded double precision result 
algorithm significantly stable double quadruple precision key values may save researcher spending great deal time devising analyzing algorithm priest offers examples 
speed considerations may untenable accomplish calling standard extended precision library 
techniques priest developed simple coded directly numerical algorithms avoiding function call overhead conversion costs 
useful tool coding algorithms expression compiler similar fortune van wyk ln converts expression exact arithmetic code complete error bound derivation floating point filters 
tool able automate process breaking expression adaptive stages described section 
see adaptivity just determining sign expression suppose wishes find relative error greater center circle passes points may expressions 
gamma fi fi fi fi fi gamma gamma gamma gamma gamma gamma fi fi fi fi fi fi fi fi fi fi gamma gamma gamma gamma fi fi fi fi fi fi fi fi fi fi gamma gamma gamma gamma gamma gamma fi fi fi fi fi fi fi fi fi fi gamma gamma gamma gamma fi fi fi fi fi denominator fractions precisely expression computed orient 
computation unstable nearly collinear roundoff error denominator dramatically change result cause division zero 
disaster avoided desired error bound enforced computing denominator variant orient accepts approximation error bound roughly times smaller 
similar adaptive routine accurately compute numerators 
fruitful explore methods described clarkson extended fast methods handle arbitrary double precision floating point inputs 
certainly relax constraints bit complexity inputs instance method perform test bit inputs expansions length 
unfortunately obvious adapt integer techniques inputs wildly differing exponents 
clear hybrid algorithms faster straightforward adaptivity 
clarkson approach looks promising larger determinants 
methods small determinants sizes larger theta 
uses gaussian elimination cofactor expansion important adjustment matrices larger theta adaptivity technique scale determinants large number terms tiebreaking rule important expanded polynomial 
clarkson technique may economical approach matrices larger theta 
issues resolved near researchers today tests orientation incircle dimensions correct fast cases applicable single double precision floating point inputs 
invite working computational try code implementations hope save worrying robustness may concentrate geometry 
tiebreaking rule important theorem complicated need consider tiebreaking rule 
appendix gives example proves complication necessary ensure fast expansion sum produce nonoverlapping output 
processor round tiebreaking algorithm independent tiebreaking rule slower linear expansion sum appendix section gave examples demonstrate fast expansion sum preserve nonoverlapping nonadjacent properties 
example demonstrates absence assumption tiebreaking rule fast expansion sum preserve property implies nonoverlapping property 
seen round rule ensures fast expansion sum preserves strongly nonoverlapping property 
simplicity assume bit arithmetic 
suppose round zero rule initially effect 
incompressible expansions formed summing components expansion addition algorithm 
summing expansions fast expansion sum zero elimination yields expansion theta 
similarly form expansion theta summing turn yields theta theta nonoverlapping strongly nonoverlapping 
switching round rule suppose fast expansion sum sum copies expansion 
resulting expansion theta gamma gamma gamma contains pair overlapping components 
safe mix round zero round rules possible prove fast expansion sum produces nonoverlapping expansions tiebreaking rule 
expansion nonoverlapping particularly bad sense approximate produce accurate approximation expansion value 
proven regardless tiebreaking rule fast expansion sum preserves call weakly nonoverlapping property allows small amount overlap components easily fixed compression 
details omitted 
conjecture geometric predicates section correctly regardless tiebreaking rule 
linear time expansion addition round tiebreaking theorem nonoverlapping expansions bit components respectively 
suppose components sorted order increasing magnitude may zero 
algorithm produce jonathan richard shewchuk sum sum sum fast sum fast sum fast sum fast sum oe oe oe oe oe oe oe operation linear expansion sum 
maintains approximate running total 
fast sum operations bottom row exist clip high order bit term necessary outputting 
nonoverlapping expansion components order increasing magnitude may zero 
linear expansion sum merge single sequence order nondecreasing magnitude possibly interspersed zeroes fast sum gamma fast sum gamma sum gamma hm gamma hm qm return approximate sum terms see 
proof iteration loop invariant gamma holds 
certainly invariant holds line executed 
lines gamma gamma gamma invariant follows induction 
fast sum line justified shortly 
assures lines executed algorithm produces correct sum 
proof nonoverlapping increasing relies fact terms summed order smallest largest running total grows larger component summed 
specifically prove induction exponent greater exponent components gamma nonoverlapping order increasing magnitude excepting zeros 
statement holds jq jg phi jg jg prove statement general case assume inductive hypothesis exponent gamma greater exponent components gamma nonoverlapping increasing 
gamma roundoff error sum operation produces gamma jq gamma ulp gamma 
inequality inductive hypothesis imply jq gamma ulp justifies fast operation line 
operation produces sum jr gamma jg gamma 
ulp 
corollary implies jh gamma ulp 
gamma nonoverlapping bound gamma ulp ulp 
assume loss generality exponent gamma ulp jg jg jg bounded formed merging nonoverlapping increasing expansions gamma consider instance bit arithmetic greater sum 
substituting bounds invariant proof jq gamma gamma confirms exponent greater exponent show gamma larger previous components zero overlap observe gamma formed summing gamma shown equal zero large overlap gamma gamma seen jh gamma ulp bounded turn ulp 
clear jh gamma small overlap produced fast sum operation 
jh gamma small overlap gamma jh gamma jq gamma applying lemma line jq gamma ulp gamma 
foregoing discussion assumes input components zero 
zero corresponding output component gamma zero accumulator values unchanged gamma gamma 
xi francis jean daniel boissonnat olivier devillers franco preparata 
evaluating signs determinants single precision arithmetic 
manuscript available www inria fr personnel devillers determinant 
david bailey 
portable high performance package 
technical report rnr nasa ames research center moffett field california may 
john canny 
algebraic geometric computations pspace 
th annual symposium theory computing chicago illinois pages 
association computing machinery may 
kenneth clarkson 
safe effective determinant evaluation 
rd annual symposium foundations computer science pittsburgh pennsylvania pages 
ieee computer society press october 
dekker 
floating point technique extending available precision 
numerische mathematik 
steven fortune 
stable maintenance point set triangulations dimensions 
th annual symposium foundations computer science pages 
ieee computer society press 
jonathan richard shewchuk progress computational geometry 
directions geometric computing martin editor chapter pages 
information 
numerical stability algorithms delaunay triangulations 
international journal computational geometry applications march june 
steven fortune christopher van wyk 
efficient exact arithmetic computational geometry 
proceedings ninth annual symposium computational geometry pages 
association computing machinery may 
static analysis yields efficient exact integer arithmetic computational geometry 
appear transactions mathematical software 
david goldberg :10.1.1.102.244
computer scientist know floating point arithmetic 
acm computing surveys march 
leonidas guibas jorge stolfi 
primitives manipulation general subdivisions computation diagrams 
acm transactions graphics april 
christoph hoffmann 
problems accuracy robustness geometric computation 
computer march 
michael derek lieber lee 
efficient delaunay triangulation rational arithmetic 
acm transactions graphics january 
donald knuth 
art computer programming algorithms second edition volume 
addison wesley reading massachusetts 
der tsai lee bruce 
algorithms constructing delaunay triangulation 
international journal computer information sciences 

analysis known methods improving accuracy floating point sums 
bit 
victor milenkovic 
double precision geometry general technique calculating line segment intersections rounded arithmetic 
th annual symposium foundations computer science pages 
ieee computer society press 

universality theorems classification problem configuration varieties convex polytopes varieties 
topology geometry seminar ya 
editor lecture notes mathematics volume pages 
springer verlag 
thomas ottmann gerald christian 
numerical stability geometric algorithms 
proceedings third annual symposium computational geometry pages 
association computing machinery june 
douglas priest 
algorithms arbitrary precision floating point arithmetic 
tenth symposium computer arithmetic los alamitos california pages 
ieee computer society press 
properties floating point arithmetics numerical stability cost accurate computations 
ph thesis department mathematics university california berkeley berkeley california november 
available anonymous ftp ftp icsi berkeley edu pub theory priest thesis ps jonathan richard shewchuk 
triangle engineering quality mesh generator delaunay 
workshop applied computational geometry 
association computing machinery may 
pat 
floating point 
prentice hall englewood cliffs new jersey 
david watson 
computing dimensional delaunay tessellation application polytopes 
computer journal 
james hardy wilkinson 
rounding errors algebraic processes 
prentice hall englewood cliffs new jersey 
