graph algorithms boolean function manipulation randal bryant new data structure representing boolean functions associated set manipulation algorithms 
functions represented directed acyclic graphs manner similar representations introduced lee akers restrictions ordering decision variables graph 
function requires worst case graph size exponential number arguments functions encountered typical applications reasonable representation 
algorithms time complexity proportional sizes graphs operated quite efficient long graphs grow large 
experimental results applying algorithms problems logic design verification demonstrate practicality approach 
index terms boolean functions symbolic manipulation binary decision diagrams logic design verification 
boolean algebra forms cornerstone computer science digital system design 
problems digital logic design testing artificial intelligence combinatorics expressed sequence operations boolean functions 
applications benefit efficient algorithms representing manipulating boolean functions symbolically 
unfortunately tasks perform boolean functions testing exists assignment input variables boolean expression evaluates satisfiability boolean expressions denote function equivalence require solutions np complete conp complete problems 
consequently known approaches performing operations require worst case amount computer time grows exponentially size problem 
difficult compare relative efficiencies different approaches representing manipulating boolean functions 
worst case known approaches perform poorly naive approach representing functions truth tables defining desired operations terms effect truth table entries 
practice utilizing clever representations manipulation algorithms avoid exponential computations 
variety methods developed representing manipulating boolean functions 
classical representations truth tables maps canonical sum products form quite research funded california institute technology defense advanced research projects agency arpa order number carnegie mellon university defense advanced research projects agency arpa order number 
preliminary version title symbolic manipulation boolean functions graphical representation nd design automation conference las vegas nv june 
update originally published ieee transactions computers pp 
august 
create version started original electronic form submission 
figures redrawn format 
included footnotes starting update discussing minor errors original version giving updates open problems 
current address department computer science carnegie mellon university pittsburgh pa impractical function arguments representation size 
practical approaches utilize representations functions exponential size 
example representations include reduced sum products equivalently sets prime cubes factored unate functions 
representations suffer drawbacks 
certain common functions require representations exponential size 
example odd parity functions serve worst case examples representations 
second certain function may reasonable representation performing simple operation complementation yield function exponential representation 
representations canonical forms function may different representations 
consequently testing equivalence satisfiability quite difficult 
due characteristics programs process sequence operations boolean functions erratic behavior 
proceed reasonable pace suddenly blow running storage failing complete operation reasonable amount time 
new class algorithms manipulating boolean functions represented directed acyclic graphs 
representation resembles binary decision diagram notation introduced lee popularized akers 
place restrictions ordering decision variables vertices 
restrictions enable development algorithms manipulating representations efficient manner 
representation advantages previous approaches boolean function manipulation 
commonly encountered functions reasonable representation 
example symmetric functions including odd parity represented graphs number vertices grows square number arguments 
second performance program algorithms processing sequence operations degrades slowly 
time complexity single operation bounded product graph sizes functions operated 
example complementing function requires time proportional size function graph combining functions binary operation intersection subtraction testing implication special cases requires time proportional product graph sizes 
representation terms reduced graphs canonical form function unique representation 
testing equivalence simply involves testing graphs match exactly testing satisfiability simply involves comparing graph constant function 
unfortunately approach set undesirable characteristics 
start processing choose ordering system inputs arguments functions represented 
functions size graph representing function highly sensitive ordering 
problem computing ordering minimizes size graph conp complete problem 
experience human understanding problem domain generally choose appropriate ordering great difficulty 
quite small set heuristics program select adequate ordering time 
seriously functions represented boolean expressions logic circuits reasonable size input orderings representation function graph large practical 
example prove appendix functions describing outputs integer multiplier graphs grow exponentially word size regardless input ordering 
exception integer multiplication experience functions seldom arise digital logic design applications 
classes problems particularly combinatorics methods practical restricted conditions 
variety graphical representations discrete functions studied extensively 
survey literature subject moret cites describe sufficient set algorithms implement boolean function manipulation program 
fortune hopcroft schmidt studied properties graphs obeying similar restrictions showing graphs tested functional equivalence polynomial time functions require larger graphs restrictions milder restrictions 
payne describes techniques similar reducing size graph representing function 
algorithms combining functions binary operation composing functions new capabilities central symbolic manipulation program 
section contains formal presentation function graphs 
define graphs functions represent class reduced graphs 
prove key property reduced function graphs form canonical representation boolean functions 
section depart formal presentation give examples discuss issues regarding efficiency representation 
develop set algorithms manipulating boolean functions representation 
algorithms utilize classical techniques graph algorithms assume reader familiarity techniques 
experimental investigations practicality methods 
conclude suggesting refinements methods 

notation assume functions represented arguments written 
expressing system combinational logic network boolean expression boolean function choose ordering inputs atomic variables ordering functions represented 
function resulting argument function replaced constant called restriction termed cofactor denoted xi arguments 
xi 


notation shannon expansion function variable xi xi similarly function resulting argument xi function replaced function called composition denoted xi arguments 
xn xi 



functions may depend arguments 
dependency set function denoted contains arguments function depends xi function values arguments yields respectively denoted respectively 
boolean functions dependency sets equal empty set 
boolean function viewed denoting subset boolean space argument values function evaluates 
satisfying set function denoted defined 



representation section define graphical representation boolean function prove canonical form 
definition function graph rooted directed graph vertex set containing types vertices 
nonterminal vertex attributes argument index index 
children low high terminal vertex attribute value value 
furthermore nonterminal vertex low nonterminal index index low 
similarly high nonterminal index index high 
due ordering restriction definition function graphs form proper subset conventional binary decision diagrams 
note restriction implies function graph acyclic nonterminal vertices path strictly increasing index values 
define correspondence function graphs boolean functions follows 
definition function graph having root vertex denotes function defined recursively 
terminal vertex value value 
nonterminal vertex index function 
low 
high 

words view set argument values 
describing path graph starting root vertex path index path continues low child high child 
value function arguments equals value terminal vertex path 
note path defined set argument values unique 
furthermore vertex graph contained path part graph unreachable 
function graphs considered isomorphic match structure attributes 
precisely definition function graphs isomorphic exists function vertices vertices vertex terminal vertices value value nonterminal vertices index index low low high high 
note function graph contains root children nonterminal vertex distinguished isomorphic mapping graphs quite constrained root map root root low child map root low child way terminal vertices 
testing function graphs isomorphism quite simple 
definition vertex function graph subgraph rooted defined graph consisting descendants 
lemma isomorphic mapping vertex subgraph rooted isomorphic subgraph rooted 
proof lemma straightforward restriction descendants forms isomorphic mapping 
function graph reduced size changing denoted function eliminating redundant vertices duplicate subgraphs 
resulting graph primary data structure representing boolean function 
definition function graph reduced contains vertex low high contain distinct vertices subgraphs rooted isomorphic 
lemma follows directly definition reduced function graphs 
lemma vertex reduced function graph subgraph rooted reduced function graph 
theorem proves key property reduced function graphs form canonical representation boolean functions function represented unique reduced function graph 
contrast canonical representations boolean functions canonical sum products form interesting boolean functions represented function graphs size polynomial number arguments 
theorem boolean function unique isomorphism reduced function graph denoting function graph denoting contains vertices 
proof proof theorem conceptually straightforward 
take care presuppose possible representations function 
proof proceeds induction size constant functions 
reduced function graph denoting function 
graph contain terminal vertices having value set argument values function evaluates vertices function graph reachable path corresponding set argument values 
suppose contains nonterminal vertex 
graph acyclic nonterminal vertex low high terminal vertices follows value low value high 
vertices distinct case constitute isomorphic subgraphs identical case low high 
case reduced function graph 
reduced function graph denoting function consists single terminal vertex value 
similarly reduced function graph denoting consists single terminal vertex value 
suppose statement theorem holds function having ig 
minimum value argument function depends 
define functions xi respectively 
dependency sets size represented unique reduced function graphs 
reduced function graphs show graphs isomorphic consisting root vertex index low high subgraphs denoting functions nonterminal vertices graphs index index subgraphs rooted denote independent arguments 
xi subgraphs rooted vertices low low denote function induction isomorphic mapping similarly subgraphs rooted vertices high high denote function isomorphic mapping claim subgraphs rooted isomorphic mapping defined subgraph rooted low subgraph rooted high prove show function defined isomorphic mapping 
observe vertex contained subgraph rooted low subgraph rooted high subgraphs rooted isomorphic rooted 
contains isomorphic subgraphs hold conflict definition 
similar reasoning see distinct vertices having subgraphs rooted vertices isomorphic subgraph rooted implying reduced 
properties isomorphic mapping follows directly definition fact obey properties 
similar reasoning see graph contains exactly vertex index vertex existed subgraphs rooted isomorphic 
claim fact root 
suppose vertex index vertex having index function depend subgraphs rooted low high denote implies low high reduced 
similarly vertex root graphs isomorphic 
prove graphs denoting particular function reduced graph minimum number vertices 
suppose reduced graph 
form smaller graph denoting function follows 
contains vertex low high eliminate vertex vertex having child low child 
contains distinct vertices subgraphs rooted isomorphic eliminate vertex vertex having child child 

properties example function graphs section explore efficiency representation means examples 
shows examples reduced function graphs 
nonterminal vertex represented circle containing index children indicated branches labeled low high 
terminal vertex represented square containing value 

example functions function yields value th argument denoted graph single nonterminal vertex having index having low child terminal vertex value high child terminal vertex value 
graph mainly point input variable viewed boolean function operated manipulation algorithms described 
odd parity function variables denoted graph containing vertices 
compares favorably representation reduced sum products form requiring terms 
graph resembles familiar parity ladder contact network described shannon 
fact adapt construction contact network implement arbitrary symmetric function show symmetric function arguments denoted reduced function graph having vertices 
third example graph denoting function contains vertices shown 
example illustrates key properties reduced function graphs 
observe vertex having index function independent generally reduced function graph function contains vertices having indices inefficiencies caused considering functions arguments 
case represented functions truth tables 
second observe simple function subgraphs shared different branches 
sharing yields efficiency size function representation performance algorithms operation performed subgraph result utilized places sharing subgraph 

ordering dependency left low 
right high example argument ordering dependency shows extreme case ordering arguments affect size graph denoting function 
functions differ permutation arguments denoted function graph vertices requires vertices 
generalizing functions arguments function denoted graph vertices function requires vertices 
consequently poor initial choice input ordering undesirable effects 
closer examination graphs gain better intuition problem arises 
imagine bit serial processor computes boolean function examining arguments order producing output bit read 
processor requires internal storage store information arguments seen correctly deduce value function values remaining arguments 
functions require little intermediate information 
example compute parity function bit serial processor need store parity arguments seen 
similarly compute function processor need store preceding pairs arguments value previous argument 
hand compute function need store arguments correctly deduce value function remaining arguments 
function graph thought processor set vertices having index describing processing argument storing intermediate information bits memory information encoded set possible branch destinations 
bit serial processor requires bits encode information arguments graph function vertices terminal nonterminal index greater having incoming branches vertices index equal example function requires branches vertices index equal vertices terminal index greater 
fact levels graph form complete binary tree obtain degree branching 
generalization function levels graph form complete binary tree number vertices grows exponentially number arguments 
view different perspective consider family functions 

possible combinations values 
functions distinct represented distinct subgraphs graph function algorithms small problems functions variables user intuition certain functions large function graphs choice input ordering may affect size 
section examples structure problem solved exploited obtain suitable input ordering 

inherently complex functions functions represented efficiently representation regardless input ordering 
unfortunately functions representing output bits integer multiplier fall class 
appendix contains proof ordering inputs 

functions representing integer product requires graph containing vertices 
lower bound large word sizes encountered practice equals indicates exponential complexity functions 
furthermore suspect true bound far worse 
empirically word sizes equal output functions multiplier require vertices variety different input orderings 
outputs require graphs vertices impractical 
wide variety techniques implementing multipliers canonical form boolean functions set manipulation algorithms efficiently represent multiplication great interest circuit verification 
unfortunately functions especially intractable 

operations view symbolic manipulation program executing sequence commands build representations functions determine various properties 
example suppose wish construct representation function computed combinational logic gate network 
starting graphs representing input variables proceed network constructing function computed output logic gate applying gate operator functions gate inputs 
process take advantage repeated structure constructing functions representing individual terms set auxiliary variables composing functions obtain complete network functions 
similar procedure followed construct representation function denoted boolean expression 
point test various properties function equals satisfiability tautology equals function denoted expression equivalence 
ask information function satisfying set list member list members test element membership procedure result time complexity reduce reduced canonical form log apply op restrict xi log compose xi satisfy element sf satisfy sf sf satisfy count sf table summary basic operations section algorithms perform basic operations boolean functions represented function graphs summarized table 
basic operations combined perform wide variety operations boolean functions 
table function represented reduced function graph containing vertices similarly functions algorithms utilize techniques commonly graph algorithms ordered traversal table look vertex encoding 
table shows algorithms time complexity proportional size graphs manipulated 
long functions interest represented reasonably small graphs algorithms quite efficient 

data structures express algorithms pseudo pascal notation 
vertex function graph represented record declared follows update time complexity entries table strictly correct 
extra factor log log included time complexity apply compose account complexity reducing resulting graph 
research wegener showed perform bdd reduction linear time information processing letters pp 

consequently log factors dropped table 
practice bdd implementations hash tables sorting method described 
assuming retrieving element hash table takes constant time reasonable assumption hash function implementations perform bdd reduction linear time 
type vertex record low high vertex index val id integer mark boolean nonterminal terminal vertices represented type record field values vertex depend vertex type table 
field terminal nonterminal low null low high null high index index val value id mark fields contain auxiliary information algorithms 
id field contains integer identifier unique vertex graph 
matter identifiers ordered vertices range number vertices different 
mark field mark vertices visited traversal graph 
procedure traverse shown illustrates general method algorithms traversing graph performing operation vertices 
procedure called top level root vertex argument mark fields vertices true false 
systematically visits vertex graph recursively visiting subgraphs rooted children 
visits vertex complements value mark field determine child visited comparing marks 
vertex visited perform operation increment counter set id field value counter assigning unique identifier vertex 
vertex visited exactly assuming operation vertex requires constant time complexity algorithm proportional number vertices graph 
termination vertices mark value 
procedure traverse vertex mark mark index nonterminal mark low mark traverse low mark high mark traverse high implementation ordered traversal 
reduction reduction algorithm transforms arbitrary function graph reduced graph denoting function 
closely follows algorithm example aho hopcroft ullman testing trees isomorphic 
proceeding terminal vertices root unique integer identifier assigned unique subgraph root 
vertex assigns label id vertices id id terminology definition 
labeling algorithm constructs graph vertex unique label 
working terminal vertices root procedure label vertices inductive method 
terminal vertices label value attributes 
assume terminal vertices nonterminal vertices index greater labeled 
proceed labeling vertices index vertex id equal vertex labeled conditions satisfied 
id low id high vertex redundant set id id low 
second labeled vertex index having id low id low id high id high reduced subgraphs rooted vertices isomorphic set id id 
sketch code shown 
vertices collected lists indices 
done procedure similar traverse vertex visited added appropriate list 
process lists working containing terminal vertices containing root 
vertex list create key form value terminal vertex form nonterminal vertex id low id high 
vertex immediately set id 
remaining vertices sorted keys 
aho hopcroft ullman describe linear time lexicographic sorting method bucket sorting 
sorted list assigning label vertices having key 
select vertex record unique label store pointer vertex array indexed label 
selected vertices form final reduced graph 
obtain reduced version subgraph root accessing array element index id method modify vertex record children vertices reduced graph return root final reduced graph procedure exited 
note labels assigned vertices routine serve unique identifiers routines 
assuming linear time sorting routine processing level requires time proportional number vertices level 
level processed complexity algorithm linear number vertices 
function reduce vertex vertex var subgraph array vertex var vlist array list put vertex list vlist index nextid downto empty set vlist index add key key value terminal vertex low id high id id low id redundant vertex add key key low id high id sort elements keys key key removed order key id nextid matches existing vertex unique vertex nextid nextid id nextid subgraph nextid low subgraph low id high subgraph high id key return subgraph id implementation reduce key label reduction algorithm example shows example reduction algorithm works 
vertex show key label generated labeling process 
observe vertices index key right hand vertex index redundant 

apply procedure apply provides basic method creating representation function operators boolean expression logic gate network 
takes graphs representing functions binary operator op boolean function arguments produces reduced graph representing function op defined op 

op 

procedure complement function compute test implication compare variety operations 
representation implement operators single algorithm 
contrast boolean function manipulation programs require different algorithms complementing intersecting op op functions implement operators combining operations 
algorithm proceeds roots argument graphs downward creating vertices result graph branching points arguments graphs 
explain basic idea algorithm 
describe refinements improve efficiency 
control structure algorithm recursion derived shannon expansion equation op op op apply operator functions represented graphs roots consider cases 
suppose terminal vertices 
result graph consists terminal vertex having value value op value 
suppose nonterminal vertex 
index index create vertex having index apply algorithm recursively low low generate subgraph root low high high generate subgraph root high 
suppose hand index terminal vertex index function represented graph root independent xi alternatively function complemented simply complementing values terminal vertices 
create vertex having index recursively apply algorithm low generate subgraph root low high generate subgraph root high 
similar situation holds roles vertices previous case reversed 
general graph produced process reduced apply reduction algorithm returning 
implement technique described previous paragraph directly obtain algorithm exponential time complexity call arguments nonterminal vertex generates recursive calls 
complexity reduced refinements 
algorithm need evaluate pair subgraphs 
maintain table containing entries form indicating result applying algorithm subgraphs roots subgraph root applying algorithm pair vertices check table contains entry vertices 
immediately return result 
proceed described previous paragraph add new entry table 
refinement drops time complexity show 
refinement shows exploit sharing subgraphs data structures gain efficiency algorithms 
argument graphs contain shared subgraphs obtain high hit rate table 
practice hit rates range 
note hit rate obtain speed improvement far better factor expect 
finding entry table counts hit avoids potentially numerous recursive calls required construct subgraph rooted second suppose algorithm applied vertices say terminal vertex particular operator value controlling value value op value op example controlling value argument controlling value argument 
case need evaluate 
simply create terminal vertex having appropriate value 
refinement improve worst case complexity algorithm certainly helps cases 
practice case occurs time 
sketch code shown 
simplicity optimize worst case performance table implemented dimensional array indexed unique identifiers vertices 
practice table sparse efficient hash table 
detect vertices contains controlling value operator evaluate expression value op value algebra value nonterminal vertex represents don care 
op op op op evaluation technique logic simulators 
final graph returned apply procedure reduce transform reduced graph assign unique identifiers vertices 
analyze time complexity algorithm called graphs vertices respectively observe procedure apply step generates recursive calls time invoked pair vertices total number recursive calls procedure exceed 
single call operations including looking entry table require constant time 
furthermore initialization table requires time proportional size 
total complexity algorithm 
worst case algorithm may require time reduced graph function op contain vertices 
example choose positive integers define functions update see footnote table discussing inaccuracy complexity measure 


functions represented graphs containing vertices respectively saw section 
compute resulting function 
represented graph vertices 
worst case efficiency algorithm limited size result graph expect algorithm achieve better performance conditions 
empirically observed worst case occurring result graph large 
conjecture algorithm refined worst case complexity resulting reduced graph 
function apply vertex op operator vertex var array vertex recursive routine implement apply function apply step vertex vertex id id null return evaluated new vertex record mark false id id add vertex table value value op value value create terminal vertex index low null high null create nonterminal evaluate index min index index index index vlow low vhigh high vlow vhigh index index vlow low vhigh high vlow vhigh low apply step vlow vlow high apply step vhigh vhigh return main routine initialize elements null apply step return reduce implementation apply shows example algorithm proceed applying operation graphs representing functions shows graph created algorithm reduction 
vertex resulting graph indicate vertices procedure update improved worst case complexity algorithm described 
disproving conjecture difficult 
evaluation graph reduction example apply apply step invoked creating vertex 
refinements applied procedure invoked vertices controlling value operator second invocation vertices 
larger graphs expect refinements applied 
reduction algorithm applied see resulting graph represents function 

restriction restriction algorithm transforms graph representing function representing function xi specified values algorithm proceeds traversing graph manner shown procedure traverse looking pointer root graph vertex child vertex index pointer encountered changed point low high 
procedure reduce called reduce graph assign unique identifiers vertices 
amount computation required vertex constant complexity algorithm 
note algorithm simultaneously restrict function arguments changing complexity 

composition composition algorithm constructs graph function obtained composing functions 
algorithm allows quickly derive functions logic network expression containing repeated structures common occurrence structured designs 
composition expressed terms restriction boolean operations expansion derived directly shannon expansion equation xi xi algorithms restriction application sufficient implement composition 
functions represented graphs respectively obtain worst case complexity 
improve complexity observing equation expressed terms ternary boolean operation ite short ite operation applied functions xi extension apply procedure ternary operations 
procedure compose shown utilizes technique compose functions 
code recursive routine compose step applies operation ite computes restrictions traverses graphs 
unclear efficiency algorithm truly quadratic dependence size argument indicates weakness performance analysis 
cases composition requires time greater 
instances functions composed simpler efficient way syntactic technique 
suppose functions represented graphs respectively 
compose functions replacing vertex graph having index copy replacing branch terminal vertex branch low high depending value terminal vertex 
resulting graph violate index ordering restriction 
indices assuming reduced graph resulting replacements reduced avoid applying reduction algorithm 
technique applies restricted conditions worthwhile optimization 

satisfy questions ask satisfying set function including number elements listing elements just single element 
seen table operations performed algorithms widely varying complexity 
single element time proportional number function arguments assuming graph reduced 
considering value element specified bit sequence length algorithm optimal 
list elements time proportional times number elements optimal 
generally wise thing functions represented small graphs large satisfying sets 
example function represented graph vertex possible combinations argument values satisfying set 
update jain 
jain analysis composition complexity obtain smaller canonical graphs th design automation conference pp 

shown example resulting graph size 
worst case algorithm quadratic dependence size argument 
update elena private correspondence feb pointed approach yield non reduced graph 
function compose vertex integer vertex var array vertex recursive routine implement compose function compose step vlow vhigh vertex vertex perform restrictions vlow index vlow vlow low vhigh index vhigh vhigh high apply operation ite vlow id vhigh id id null return evaluated new vertex record mark false vlow id vhigh id id add vertex table value value vlow value value vhigh value value create terminal vertex index low null high null create nonterminal evaluate index min vlow index vhigh index index vlow index index vlow low vlow high vlow vlow vhigh index index vhigh low vhigh high vhigh vhigh index index vlow low vhigh high vlow vhigh low compose step vlow high compose step vhigh return main routine initialize elements null compose step return reduce implementation compose care exercised invoking algorithm 
wish find element satisfying set obeying property inefficient enumerate elements satisfying set pick element desired characteristics 
specify property terms boolean function compute boolean product function original function procedure satisfy select element 
compute size satisfying set algorithm time proportional size graph assuming integer operations sufficient precision performed constant time 
general faster apply algorithm enumerate elements satisfying set count 
procedure satisfy shown called root graph array initialized arbitrary pattern returns value false function unsatisfiable value true case entries array set set values denoting element satisfying set 
procedure utilizes classic depth search backtracking scheme find terminal vertex graph having value 
procedure function graph 
called unreduced function graph require time exponential consider complete binary tree final terminal vertex search value 
reduced graph assume property lemma nonterminal vertex reduced function graph terminal vertex value descendant 
procedure backtrack vertex child tries terminal vertex value case guaranteed succeed second child 
complexity algorithm 
function satisfy vertex var array integer boolean value return false failure value return true success satisfy low return true return satisfy high implementation satisfy enumerate elements satisfying set perform exhaustive search graph printing element corresponding current path time reach terminal vertex value 
procedure satisfy shown implements method 
procedure arguments index current function argument enumeration root vertex subgraph searched array describing state search 
called top level index root vertex graph array arbitrary initialization 
effect procedure invoked index vertex array having elements equal 
enumerate elements set 




previous algorithm procedure function graph require time exponential unreduced graph regardless size satisfying set consider complete binary tree terminal vertices having value 
reduced graph guaranteed search fail procedure called terminal vertex value case recursive call child succeed 
half recursive calls satisfy generate new argument value element satisfying set complexity 
compute size satisfying set assign value vertex graph recursive formula 
terminal vertex value 
nonterminal vertex low index low index high index high index 
terminal vertex index 
computation performed procedure traverses graph manner procedure traverse 
formula applied vertex graph total time complexity update adnan darwiche ucla private correspondence observed formula incorrect 
correct low index low index high index high index procedure satisfy integer vertex array integer value return failure value success print element return index function independent satisfy satisfy function depends satisfy low satisfy high implementation satisfy computed values graph root compute size satisfying set index 
experimental results known algorithms solving np hard problems algorithms worst case performance unacceptable smallest problems 
hope approach practical reasonable class applications demonstrated experimentally 
shown size graph representing function depend heavily ordering input variables algorithms quite efficient long functions represented graphs reasonable size 
major questions answered experimental investigation appropriate input ordering chosen ordering large graphs encountered typical applications 
implemented algorithms described applied problems logic design verification test pattern generation combinatorics 
experience quite favorable 
analyzing problem domain generally develop strategies choosing ordering inputs 
furthermore necessary find optimal ordering 
orderings produce acceptable results 
functions rarely require graphs size exponential number inputs long reasonable ordering inputs chosen 
addition algorithms quite fast remaining practical graphs vertices 
consider problem verifying implementation logic function terms combinational logic gate network satisfies specification terms boolean expressions 
examples family arithmetic logic unit alu designs constructed ttl integrated circuits 
implements bit alu slice implements lookahead carry generator 
chips combined create alu word size multiple bits 
alu bit word size inputs control inputs labeled select alu function carry input labeled cin data words bits labeled 

produces outputs function outputs labeled 
carry output labeled cout comparison output labeled logical function outputs 
word size gates patterns cpu minutes graph table alu verification examples experiments derived functions chips gate level descriptions composed functions form different alu chip level interconnections circuit manual 
compared circuit functions functions derived boolean expressions obtained encoding behavioral specification circuit manual 
succeeded verifying alu word sizes bits 
performance program task summarized table 
data measured best ordering able find happened tried control inputs carry input interleaving data words significant 
table number gates defined number logic gates schematic diagrams chips times number chip 
number patterns equals number different input combinations 
cpu time expressed minutes measured digital equipment vax mip machine 
times complete verification construct functions circuit behavioral descriptions establish equivalence 
final column shows size reduced graph output 
cases largest graph generated 
seen time required verify circuits quite reasonable part basic procedures fast 
amortizing time memory management user interface reducing graphs call evaluation routines apply step compose step requires milliseconds 
example verifying bit alu procedures called times 
total verification time grows square word size 
expected number gates sizes graphs operated grow linearly word size total execution time grows product factors 
quadratic growth far superior exponential growth required exhaustive analysis 
example suppose time universe formed years ago started analyzing bit alu exhaustively rate pattern microsecond 
half way 
bit alu advantage exhaustive analysis greater 
alu circuits provide interesting test case evaluating different input orderings successive bits function output word functions increasingly variables 
shows sizes graphs depend ordering circuit inputs 
best case obtained ordering cin 
ordering choose bit serial implementation alu read bits describing function computed read successive bits data words starting significant bits 
bit serial computer analogy section guides best solution 
best case tested occurred ordering cin 
data ordered significant bit 
ordering represents alternative successful strategy order bits decreasing order importance 
th bit output word depends strongly th bits input words lower order bits 
seen strategy works quite 
case shown ordering control inputs cin 
ordering expected produce poor result outputs depend strongly control inputs 
complexity graphs grows linearly due fact number control inputs constant 
explain linear growth terms vertices input orderings cin 
bn cin 
bn bit position cin bn 
cin 

bn alu output graph sizes different input orderings bit serial processor analogy implement alu control inputs read computing possible alu functions selecting appropriate result desired function known 
final case shows happens poor ordering chosen case ordering cin 

ordering requires program represent functions similar function considered section exponential growth characteristics 
experimental results indicate representation works quite functions representing addition logical operations words data long choose ordering successive bits input words interleaved 
representation especially efficient compared representations boolean functions 
example truth table representation totally impractical alu word sizes greater bits 
reduced sum products representation significant bit sum bit numbers requires product terms reduced sum products representation circuit equally impractical 

shown known graphical representation boolean functions imposing restriction vertex labels minimum size graph representing function canonical form 
furthermore graph representing function reduce canonical form graph linear time 
reduction algorithm minimizes amount storage required represent function time required perform symbolic operations function tasks testing equivalence satisfiability tautology simple 
property valuable applications 
set algorithms performing variety operations boolean functions represented data structure 
algorithms obeys important closure property argument graphs satisfy ordering restrictions result graph 
combining concepts boolean algebra techniques graph algorithms achieve high degree efficiency 
performance limited sizes data structures algorithms operate 
akers devised variety coding techniques reduce size binary decision diagrams representing output functions system 
example represent functions outputs alu slice total vertices representation requires 
techniques applied representation violating properties required algorithms 
discuss refinements briefly 
digital systems contain multiple outputs 
current implementation represent output function separate graph function may closely related graphs containing isomorphic subgraphs 
alternatively represent set functions single graph multiple roots function 
reduction algorithm applied graphs eliminate duplicate subgraphs guarantee subgraph consisting root descendants canonical representation corresponding function 
example represent functions addition bit numbers single graph containing vertices assuming inputs ordered significant bits representing separate graphs requires total vertices 
idea extreme manage entire set graphs single shared data structure extension reduction algorithm merge newly created graph structure 
structure enhance performance apply procedure maintaining table containing entries form op indicating result applying operation op graphs roots graph root way exploit information generated previous invocations apply current 
savings storage requirements algorithm efficiencies offset somewhat difficult memory management problem 
akers saves storage representing functions decomposed form 
represent function xi terms may represented decomposed form 
unfortunately function decomposed different ways technique lead canonical form 
noted page certain instances functions composed straightforward way simply replacing vertex representing composition variable xi graph decompositions functions stored decomposed form expanded canonical form dynamically operations performed 
instances storage savings considerable 
example graph function 
requires total vertices 
function decomposed series functions xi equals desired function 
functions represented graphs vertices 
unclear decompositions occur easy find affect efficiency algorithms 
update idea subsequently termed shared bdd shared binary decision diagram attributed edges th design automation conference pp 

common implementation method 
appendix complexity integer multiplication appendix prove functions representing outputs integer multiplier provide difficult case representation graph sizes grow exponentially word size regardless ordering input variables 

possible orderings input variables hope derive result experimentally provide detailed proof 
proof principles similar proving area time lower bounds multiplier circuits 
show just large amount information transferred set inputs set outputs performing multiplication certain individual outputs require high information transfer 
consider multiplier inputs 

corresponding binary encoding integers significant bits 
circuit outputs corresponding binary encoding product described functions mul 


permutation 
graph inputs 
denotes function mul 
theorem exists contains vertices 
proof informally proof proceeds follows 
input control multiplier power circuit acts shifter transferring bits input data output offset 
example graph contain vertices encode values occurs half input sequence occurs second 
furthermore show ordering input variables choose input control data output undesirable splitting occurs values formally permutation number bits argument occurring half input sequence 
define sets represents indices argument occurring half input sequence represents indices added occurring second half 
define represents indices added occurring half represents indices occurring second 
case sets contain elements 
consider elements data inputs control 
multiplication commutative free choose argument considered control input considered data proof 
define set 
output represents indices data input occurring half input sequence corresponding bits control input occur second half 
consider set sequences 
set contains possible values inputs 
claim contain unique vertex element si case choose sequences 
xn 
leading vertex value fi xj consider sequences xn 

defined xk note xk equal exactly value sequences 

lead terminal vertex mul 
mul 
contradiction forces conclude graph contain vertices 
get final result need show value 
involves counting argument expressed lemma 
lemma suppose 
contain elements 

proof observe sets contain elements ordered pairs qj value qi large average value qj qi theorem shows ordering multiplier output graph exponential size 
leaves open possibility output ordering giving polynomial size graph output 
conjecture case certain outputs output graph function exponential size regardless ordering 
proof conjecture require stronger simple shifter argument 
proof lead interesting area time lower bound circuits computing single bits product binary numbers 
update conjecture subsequently proved author bryant complexity vlsi implementations graph representations boolean functions application integer multiplication ieee transactions computers pp 
feb 

lee representation switching circuits binary decision programs bell system technical journal vol 
july pp 


akers binary decision diagrams ieee transactions computers vol 
june pp 


garey johnson computers guide theory np completeness freeman new york 

hill peterson switching theory logical design wiley new york 

roth computer logic testing verification computer science press md 

brayton fast recursive boolean function manipulation international symposium circuits systems ieee rome italy may pp 


moret decision trees diagrams acm computing surveys vol 
december pp 


fortune hopcroft schmidt complexity equivalence containment free single variable program schemes automata languages programming goos ausiello boehm eds springer verlag lecture notes computer science vol 
pp 


payne methods reducing size printed diagnostic keys journal general microbiology vol 
pp 


brayton logic minimization algorithms vlsi synthesis kluwer academic publishers 

shannon symbolic analysis relay switching circuits transactions vol 
pp 


wallace suggestion fast multiplier ieee transactions electronic computing vol 
ec january pp 


aho hopcroft ullman design analysis computer algorithms addison wesley reading ma 

level design verification system ibm systems journal vol 
pp 


texas instruments ttl data book 

rowan robinson cosmology oxford univ press 

akers functional testing binary decision diagrams eighth annual conference fault tolerant computing ieee pp 


brent kung area time complexity binary multiplication journal acm vol 
july pp 


abelson information transfer area time trade offs vlsi multiplication communications acm vol 
january pp 

table contents 

notation 
representation 
properties 
example functions 
ordering dependency 
inherently complex functions 
operations 
data structures 
reduction 
apply 
restriction 
composition 
satisfy 
experimental results 
appendix complexity integer multiplication ii list figures 
example function graphs 
example argument ordering dependency 
implementation ordered traversal 
implementation reduce 
reduction algorithm example 
implementation apply 
example apply 
implementation compose 
implementation satisfy 
implementation satisfy 
alu output graph sizes different input orderings iii list tables table 
summary basic operations table 
alu verification examples 
