model checking project philips research philips research eindhoven netherlands philips com 
new veri cation project started philips research 
concerns veri cation concurrent programs specify functionality hardware software systems 
problem veri cation practical sense mechanized applicable thousands lines code 
goals project combination existing solutions want try 
follows concerned functional veri cation systems opposed manufacture testing example 
distinguish formal veri cation understood academia veri cation general practised industry 
words term veri cation broader sense including testing nal products simulation models 
veri cation hardware software systems serious ort consuming nonnegligible part time devoted design implementation 
due increasing complexity systems time needed verify increase nally reaching unacceptable levels 
addition high tech products part safety critical systems extremely reliable making veri cation ort time consuming 
potential problems caused industries involved design manufacturing high tech products turn attention systematic methods veri cation say formal veri cation model checking promised proponents shorten veri cation time increase reliability nal products 
philips far facing veri cation crises scale spectacular hardware software failures publicized years 
due fact philips involved production devices 
anticipation potential problem increased time spent veri cation ect time market philips research experimenting years incorporating formal veri cation methods design ows 
example damage caused remote tv set controller deadlock unusual combination buttons pressed accidentally 
especially switch tv set order resolve problem 
historically formal veri cation started philips hardware circuits devices produced philips software intensive past 
currently formal equivalence checks various levels hardware descriptions performed routinely production projects 
far formal veri cation functional properties say symbolic model checking concerned available tools scale apply bigger designs latches 
reason viable option apply model checking relatively simple sub components 
restricted setting formal veri cation properties considered useful supposed play role bigger ort making reusability components easier 
formal veri cation software model checking currently considered serious option due limited usability available tools 
main obstacle relatively small size models programs analyzed automatically 
decomposition help reasons 
takes substantial ort isolate software components nal hardware software system properties expected rest system easily formalized 
second software components isolated usually orders magnitude bigger current tools cope 
hand software model checking niche philips area proven successful early beginnings protocol veri cation 
control intensive protocols veri ed spin 
tricky protocols common daily practice kind application considered important justify substantial ort incorporating model checking design ows 
follows new project aims change negative perception model checking formal methods general 
relevance project design ows currently philips rst precise descriptions functionality hardware software system programs languages close rtl register transfer level 
reason veri cation time currently spent rtl speci cations 
design ows cosy start higher level 
cosy starts describing functionality design yapi language 
short yapi just concurrent version kahn networks processes communicate bounded fifos read write primitives non deterministically choose possible communications select primitive 
fairly standard model distributed concurrent systems relatively simple formal semantics opens possibilities formal analysis yapi programs 
exception philips medical systems 
various scanning devices rely heavily complex software image processing 
design speci ed yapi program form process network 
network accompanied description nal hardware architecture consisting programmable circuits microprocessors custom designed circuits asics 
yapi network mapped hardware architecture 
processes mapped microprocessors called software components implemented asics called hardware components 
main goal cosy design ow start performance analysis early possible 
various models prepared simulated order gather performance metrics 
initial design satisfy assumed performance requirements modi ed repartitioning required functionality new process network changing hardware architecture 
new re mapping performance modi ed design re evaluated 
cycle may repeated times 
yapi speci cations simulated functional veri cation start system design phase order expose errors early possible making easier cheaper correct 
far functional errors exposed usually system integration phase 
currently functional veri cation done simulation support automation veri cation ort simulation scenarios prepared manually 
cosy design ow improved aspects veri cation yapi programs mechanized 
setting new veri cation challenges arise address project 
distinguish kinds veri cation tasks property checking design veri ed satisfy kind behavioral constraint equivalence checking models design checked equivalent instance yapi versus rtl rtl versus gate gate versus gate 
veri cation tasks identi ed cosy ow property checking yapi networks 
distinguish generic properties absence deadlocks speci properties invariants assertion violations 
equivalence checking yapi networks 
yapi process split network processes order facilitate better software hardware repartitioning 
done manually 
question original yapi process equivalent resulting decomposed network 
equivalence checking yapi process rtl implementation case hardware components 
equivalence checking yapi process software implementation case software components 
code works ne simulated suce dsp code instance 
tweaked manually 
important check equivalence abstraction level original specialized code 
order simplify job decided concentrate initially veri cation tasks 
goal investigate methods veri cation ort easier 
methods practical sense mechanized applicable thousands lines yapi code 
propose investigate model checking directed testing 
proposed solutions formal veri cation nd errors establish correctness 
important di erence methods nding errors usually scale better establishing correctness far size yapi programs concerned 
reason quite obvious reliability tools 
tool establishing correctness expected reliable sound complete 
answer mean correct soundness 
second correct property answer completeness 
tool nding errors need exact 
fact needs sound complete 
error answer need necessarily mean real error unsoundness user judgement relatively easily simulating erroneous trace 
second expected nd errors incompleteness 
investigate approaches model checker spin nd errors yapi programs 
testing tool torx directed testing yapi programs 
link project cdr ote de project philips research involved 
want torx tool automate property checking equivalence checking directed testing 
cdr approach testing objects compared torx 
rst object called implementation checked conform object called speci cation 
implementation speci cation perceived torx input output state transition systems labelled state transition systems labels kinds input output actions 
torx explores speci cation chooses input actions ered speci cation stimulate implementation 
implementation performs chosen input action computation produces output action return waits input action 
output action produced implementation checked conform speci cation conforms input action chosen stimulation 
testing process supported formal theory sense ioco input output conformance relation implementation speci cation formally de ned 
torx exible architecture framework concrete tool 
consists modules relatively easily changed adapt torx various testing scenarios 
speci cation implementation language providing wrappers allow torx perceive objects input output state transition systems 
second speci exploration strategy relatively easily programmed modules 
example order test yapi process networks deadlocks exploration strategy consistently prefer yapi read operations yapi write operations vice versa trying fifos empty full typical situations cause deadlocks yapi networks 
way generation test cases driven property tested name directed testing 
worthwhile try spin torx verify yapi programs lead di erent tradeo far exactness nding errors versus scalability concerned 
spin allows exhaustive testing expense limitations imposed size veri cation model torx principle scale better expense non exhaustive 
reason investigating torx section 
successful application tools relies solving fundamental problems obtain veri cation model yapi program assumption yapi programs complex informal analyzed directly model small cope inherent limitations fully automated veri cation tools 
essentially techniques cope size problem decomposition abstraction 
compositional veri cation hard prefer tackle size problem aggressive abstractions 
going try abstraction omission abstraction projection realized existing tools 
details 
extracting promela program yapi program going solve model size problems simultaneously creating tool similar ax tool 
ax extracts promela program program 
extracted program fed spin torx happens promela input languages torx 
term extracts translates translation promela combined abstracting promela program necessarily equivalent program 
note pose theoretical problems nding errors establishing correctness 
abstracting process driven table speci es basic statements declarations assignments guards procedure calls appear program 
table prepared user hopefully place human intervention needed extracting model 
table driven extraction exible 
hand allows fully automated abstractions built general abstraction rules 
hand allows ne tune abstractions needed speci rules provided user 
exibility crucial successful usage spin torx real life complex yapi programs allows ne tune veri cation ort relatively easily trade exactness results time spent veri cation 
yapi extracting promela model yapi unfeasible manipulations objects including memory management object allocation deallocation simulated promela lead explosion state space 
fortunately classes yapi describe structure yapi process network 
behaviour processes speci ed avoid potential problems mapping hardware components 
far speci cation properties concerned generic properties deadlock don need speci ed 
speci cation behavioral properties poses problems want general 
principle behavioral properties grouped safety liveness properties 
safety properties pose problems easily speci ed observers assertion violations yapi promela extracted directly promela 
liveness properties revert ltl linear temporal logic case perceived dicult user design general simpler language top ltl 
extracting veri cation model directly yapi program order avoid potentially tedious task preparing abstraction table ax tool try approach verisoft tool 
approach state space program large due ne granularity statements projected smaller space consisting called observable states 
observable states de ned break points debugging transitions computations break points 
rst solution model size problems solved simultaneously time relatively small veri cation model obtained directly just executing concurrent program 
observable states extracted executing program parallel verisoft model checker program reaches break point model checker gets control analyzes current observable state 
fact verisoft model checker provided library parallel composition program model checker realized simply linking program library 
observable states visited model checking big stored stateless model checking technique overcome problem 
gluing yapi verisoft easy 
break points naturally de ned yapi communication primitives read write select 
second yapi implemented extension sense special version compiler needed 
implemented libraries implement yapi communication primitives particular platform library combination processor operating system yapi supports 
verisoft library provides implementation bounded queues order glue yapi verisoft write yapi library simply delegates yapi communication primitives verisoft communication primitives 
veri cation experiment consists linking unmodi ed yapi program libraries yapi verisoft executing 
gluing yapi torx pose fundamental problems due modular architecture torx toolset 
version yapi library automatic projection observable states 
reason investigate torx verifying complex system say speci ed thousands lines yapi code hope successfully model checking technology abstractions advocated section verify relatively simple properties 
relatively simple property mean property depends small part system words concerns particular aspect system 
way able system model small analyzed 
observe equivalence checking relatively simple property sense involves system fact 
spin hopeless equivalence checking complex yapi programs 
goals project support equivalence checking decided torx purpose 
torx establishes kind containment relation implementation speci cation formally de ned 
check equivalence pair yapi programs torx run twice 
rst run rst program plays role speci cation treated implementation 
second run roles reversed 
reversal roles possible implementation speci cation perceived torx objects kind input output state transition systems 
related signi cant amount research past years adapt model checking program checking 
ax verisoft tools java pathfinder bandera caught attention 
opinion approach taken early versions java pathfinder direct translation java promela enable tractable model checking non trivial programs 
newer version java pathfinder employs dedicated model checker works directly java bytecode remains seen new approach scales 
hand bandera quite promising tool purpose verifying programs due support slicing abstraction 
considered project envision bigger problem adapting bandera yapi ax verisoft tools 
promising approach bridge gap model checking program checking may emerge relatively research runtime veri cation 
runtime veri cation program executed various kinds information gathered particular run 
information predict di erent runs may violate properties interest 
particular interest deadlock detection algorithm proposed hope adapt yapi 
order veri cation yapi programs practical propose model checking directed testing combined abstraction omission projection 
combination obtained relatively easy combining existing tools spin torx ax verisoft 
allow asses relatively quickly proposed methods perform 


brunel cosy methodology system design reusable hardware software ip bordeaux france sept 

ote de fmt cs utwente nl projects cdr html 
corbett bandera extracting finite state models java source code nd int 
conference software engineering ireland june acm press 

iosif deadlock detection tool concurrent java programs software practice experience july 

godefroid model checking programming languages verisoft popl th acm symposium principles programming languages paris jan 

havelund runtime analysis guide model checking java programs spin th spin workshop stanford university usa lncs springer verlag sept 

havelund model checking java programs java pathfinder int 
journal software tools technology transfer april 

holzmann model checker spin ieee trans 
software engineering may 

holzmann logic veri cation ansi code spin spin th spin workshop stanford university usa lncs springer verlag sept 

de kock yapi application modelling signal processing systems dac th design automation conference los angeles 

visser java pathfinder second generation java model checker post cav workshop advances veri cation chicago july 

de vries ote de progress progress workshop embedded systems utrecht netherlands oct 
fmt cs utwente nl publications cdr pap html 
