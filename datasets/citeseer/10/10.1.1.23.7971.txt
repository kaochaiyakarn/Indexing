copyright dissertation committee certifies approved version dissertation architectural techniques accelerate multimedia applications general purpose processors committee john supervisor james brian evans ching yu hung stephen earl jr architectural techniques accelerate multimedia applications general purpose processors dissertation faculty graduate school university texas austin partial fulfillment requirements degree doctor philosophy university texas austin august thesis dedicated family friends 
acknowledgments advisor prof john support advice guidance wishes 
profound influence graduate advisor austin life 
availability times cluding weekends dedication family professional integrity pursuit perfection helped better individual 
am grateful freedom flexibility gave years spent austin 
gratitude goes committee members alphabetical order dr james prof brian evans dr ching yu hung prof steve prof earl helpful comments productive suggestions time reading draft thesis 
mid term evaluation helped immensely finish 
students past current laboratory computer architecture lca ramesh ravi juan tao vikram jason lance yue anand 
juan rubio instrumental jump starting research providing performance monitoring tools 
ravi bhargava passed valuable comments drafts submissions stages research 
lance spent considerable amount time reading correcting multiple drafts dissertation 
dr raj providing nity digital camera team texas instruments dallas 
gained valuable experience working digital camera team 
linda shirley melanie administrative worked computer engineering past years 
parents sister friends tremendous influence life 
vi architectural techniques accelerate multimedia applications general purpose processors publication 
ph university texas austin supervisor john general purpose processors gpps augmented dia extensions improve performance multimedia rich workloads 
extensions operate single instruction multiple data simd fashion ex tract data level parallelism multimedia digital signal processing dsp applications 
dissertation consists comprehensive evaluation execution characteristics multimedia applications simd enhanced gpps detection bottlenecks execution multimedia applications simd enhanced gpps design implementation architectural techniques vii eliminate alleviate impact various bottlenecks accelerate multimedia applications 
dissertation identifies bottlenecks processing simd enhanced multimedia dsp applications gpps 
approxi mately instructions dynamic instruction stream media loads performing useful computations merely supporting useful computations performing address generation address transformation data reorganization loads stores loop branches 
leads utilization simd computation units peak simd throughput achieved 
dissertation proposes hardware support efficiently exe cute overhead supporting instructions overlapping useful computation instructions 
way gpp simd extensions augmented proposed mediabreeze hardware significantly outperforms way simd gpp mediabreeze hardware multimedia kernels 
multimedia ap plications way simd gpp augmented mediabreeze hardware superior way simd gpp mediabreeze hardware 
formance improvements achieved area cost current gpps power consumption total processor power critical path processor 
viii table contents list tables xii list figures xiv chapter 
approaches multimedia processing 
general purpose processors simd extensions 
vliw architectures multimedia processing 
asics 
problem 
objectives 
thesis statement 
contributions 
organization 
acronyms 
chapter 
related multimedia application characteristics 
benefits simd extensions 
media architectural enhancements 
related gpp architectures 
chapter 
performance evaluation methodology tools 
performance monitoring counters 

simplescalar simulator 
tms simulator 
benchmarks 
ix evaluation environment 
compilers 
assembly libraries 
compiler intrinsics 
performance measures 
chapter 
execution characteristics multimedia applications gpps detailed characterization multimedia applications 
cycles instruction 
resource instruction stream stalls 
branch statistics 
data memory 
cache behavior 
floating point operations 
multimedia extensions 
speculative execution factor instruction 
comparison simd vliw approaches media processing 
tms xx dsp processor 
results 
summary 
chapter 
bottlenecks multimedia processing simd style extensions scalability test 
identification bottlenecks 
nested loops multimedia applications 
overhead supporting instructions 
simd throughput efficiency 
memory access branch bottlenecks 
summary 
chapter 
hardware support efficient simd processing mediabreeze architecture 
decoupling computation overhead 
multicast technique aid data transformation 
example encoding breeze instruction 
performance evaluation 
summary 
chapter 
hardware cost mediabreeze architecture implementation methodology 
hardware implementation mediabreeze units 
address generation 
looping 
breeze instruction decoder 
breeze instruction memory 
existing hardware units 
area power timing results 
summary 
chapter 
appendix performance monitoring events microarchitecture appendix hardware cost mediabreeze architecture different asic technologies bibliography vita xi list tables gpp multimedia extensions 
list available media processors 
description commercial media applications benchmarks workload characterization 
summaries benchmark kernels applications 
data cache rates multimedia applications 
execution clock cycles simd vliw processors 
processor memory configuration scalability test 
summary key media algorithms required nested loops primitive addressing sequences 
execution statistics efficiency media programs 
performance ipc unit cycle memory accesses perfect branch prediction 
speedup mediabreeze architecture simd efficiency 
way simd gpp baseline 
speedup mediabreeze architecture prefetching 
percentage reduction dynamic instruction count mediabreeze architecture comparison conventional risc isa simd extensions 
hardware functionality various mediabreeze hardware units 
xii area power timing estimates mediabreeze units asic technology 
area commercial simd gpp implementations 
microarchitecture counters performance measures 
list cell libraries synthesis mediabreeze hardware units 
timing area power estimates different technologies 
xiii list figures simd add instruction 
simd multiply add instruction 
simd pack instruction 
simd unpack instruction 
simd permute instruction pattern 
simd permute instruction mixing 
simplified block diagram vliw core 
cycles instruction 
stalls instruction 
branch statistics 
memory statistics 
cache statistics 
log plot cpi versus cache misses 
percentage floating point instructions 
percentage mmx instructions 
packing unpacking percentage mmx instructions 
average number instruction speculation execution factor 
xiv cpu core tms xx processor 
ratios execution times simd vliw processors 
results scalability test 
data structure sub blocks data processed 
code dct implementation 
typical access patterns multimedia dsp kernels 
pentium iii optimized assembly code dct routine 
simplescalar optimized assembly code dct routine 
breakdown dynamic instructions various classes 
mediabreeze architecture 
structure breeze instruction 
multicast technique versus traditional simd matrix multiply 
pseudo code implementation mediabreeze unit looping 
pseudo code implementation mediabreeze unit address generation 
pseudo code implementation mediabreeze unit loads stores 
pseudo code implementation mediabreeze unit simd computation data reorganization 
breeze instruction mapping dct 
performance mediabreeze mb versus simd 
xv block diagram address generation hardware 
block diagram hardware loops 
percentage interconnect area area 
breakdown dynamic power cell internal power net switching power 
xvi chapter contemporary computer applications multimedia rich involving significant amounts audio video compression image processing graphics speech character recognition communications signal processing 
proliferation world wide web internet workloads believed multimedia dominant 
applications run va systems ranging low power personal mobile computing envi ronment high performance desktop workstation server environment 
chapter describes major approaches processing multimedia applica tions objectives contributions dissertation 
approaches multimedia processing section describes common approaches handling multimedia loads general purpose processors gpp single instruction multi ple data simd extensions long instruction word vliw media proces sors application specific integrated circuits asics 
general purpose processors simd extensions virtually pc sold today multimedia capable 
ated software revolution brought wide range audio video applications desktop 
common desktop computers run video editing image processing applications adobe photoshop games addition basic productivity applications word processing spreadsheet database applications 
addition network multi media applications leverage existing network infrastructure deliver video audio users video conferencing video server applica tions 
application types video audio streams transferred network peers clients servers 
evolving stan changing consumer needs general purpose processors require multimedia processing capabilities 
order provide multimedia capability gpp manufacturers announced extensions instruction set architectures isa enhance performance multimedia applications 
isa exten sions operate simd fashion exploit data level parallelism dlp mul applications 
simd paradigms computer design proposed flynn 
multimedia digital signal processing dsp appli cations typically small data types primarily bits spend sig portion execution time loops high degree proc regularity 
packing small data elements wider gpp data path typically bits wide enables simultaneous processing separate data elements 
initial implementation simd extensions intel mmx sun vis compaq mips hp max supported integer data types mid floating point support media extensions introduced dnow 
amd followed sse sse intel 
motorola altivec introduced integer float ing point capability simultaneously 
table shows list gpp vendors announced shipped simd extensions gpp core 
initial simd implementations bit simd execution units providing way parallelism bit data re spectively 
altivec sse implemented bit simd execu tion units 
simd instructions available arithmetic logical op erations addition special media operations sum absolute differ ences 
instructions data reorganization packing unpacking permute included media extensions 
figures show examples subword execution common multi media operations 
purely data parallel add operation subwords register accomplished 
multiplication subword pairs addition sets partial results occurring leading result words 
illustrates packing registers register 
table 
gpp multimedia extensions vendor processor isa extension description hewlett packard pa risc max max media acceleration extensions sun microsystems ultrasparc vis visual instruction set intel amd mmx sse sse mmx dnow 
sse multimedia extensions streaming simd extensions streaming simd extensions multimedia extensions dnow 
extensions streaming simd extensions mmx multimedia extensions mips mips mips digital media extensions compaq alpha motion video instructions motorola powerpc altivec altivec extensions illustrates complementary operation unpacking 
multimedia extensions provide permute depicted figures 
number simd instructions functionality seen vary widely depending manufacturer 
example number compaq instructions motorola altivec intel pentium simd instructions mmx sse sse 
initial imple simd extensions shared registers gpps floating point register file example mmx vis 
extensions sse altivec dedicated register files store temporary data 
simd add instruction 

simd add instruction simd multiply add instruction 

simd multiply add instruction simd pack instruction pack truncated truncated truncated truncated 

simd pack instruction simd unpack instruction unpack 

simd unpack instruction simd permute instruction permute pattern 

simd permute instruction pattern simd permute instruction permute mixing 

simd permute instruction mixing cost incorporating media extension hardware minimal typically processor die size 
compiler support multimedia extensions infancy 
current support program mers involves compiler intrinsics assembly libraries provided vendors 
intrinsics libraries vary different ven dor implementations applications coded separately proc platform 
compilers intel compiler generate code utilizes mmx 
multimedia extensions gpps quite successful providing additional performance media applications gpps 
vliw architectures multimedia processing due processing regularity multimedia dsp applications statically scheduled processors vliw processors viable option cally scheduled processors state art superscalar gpps 
vliw processors rely software identify parallelism assemble wide instruction packets issue multiple instructions cycle shows block dia gram generic vliw processor core 
past years ic vendors touted processors gener ally vliw architectures handle media processing chores applications ranging pc multimedia high definition digital tv 
vliw processors primarily appearing area dedicated multi media processors 
multimedia processors defined programmable proces ld load store unit sh add st fadd brcc integer alu way vliw packet integer alu load store unit floating point unit 

simplified block diagram vliw core branch unit sors dedicated simultaneously accelerating operations multimedia data types 
processors dedicated processing multimedia data contrast standard gpp host processors architectures specialized processing data types cost effective manner 
high bandwidth fast integer performance allow media processors accelerate different multimedia data types 
single programmable de vice replace numerous fixed discrete function devices 
media processors possess features differentiate dsps 
standard dsps typically include support video computer graphics 
table lists major vendors media processors processors 
chromatic research chip de signed act processor simd enhanced general purpose processor addition stand operation dvd players 
media processors typically marketed low cost stand processors high performance gpp system embedded multimedia systems processor pc system 
addition vliw core media processors equipped processors uniquely targeted specific functions 
example equator technology map processors include bit microprocessor optimized low latency bit serial processing programmable video scalar kb chip memory shared processors 
table 
list available media processors manufacturer media processor target applications chromatic research lg semiconductor toshiba equator technologies fujitsu microelectronics matsushita semiconductor mitsubishi electronics combine instruction vliw architecture simd capabilities newer executes includes hardware graphics accelerator 
map vliw processor way simd vector units 
supports gb aggregate bandwidth 
equipped video coprocessors specific functions 
multi media assist combines instruction vliw architecture simd capabilities reach 
media core processor mcp combines vliw architecture dsp execution unit reach 
combines vliw architecture simd capabilities reach pc multimedia coprocessor capable graphics audio mpeg decoding modem tasks mainly dvd decoder hdtv sets games dvd players set top boxes printers dvd players set top boxes car navigation systems dvd players set top boxes videoconferencing systems precursor targets cell phones philips semiconductors sharp digital sony table 
list available media processors continued texas instruments analog devices vm labs systems tm combine vliw architecture simd capabilities reach approximately includes dedicated mpeg decoder video scalar includes dvd encryption block 
data driven media processor multiprocessor architecture integrated arm risc controller 
emotion engine cpu core vector processing engines 
tms dsp xx xx xx instruction vliw dsp xx having simd capability 
xx xx supports gb xx supports gb aggregate bandwidth 
dsp way vliw dsp simd capability 
processor delivers mips 
dsp way vliw dsp 
dvd players set top boxes digital tv including hdtv video conferencing systems offers robust digital tv design development platform color fax machines printers dvd players boxes digital tv graphics wireless communication base stations remote access servers dial adsl lines wireless communication base stations remote access servers dial adsl lines consumer electronics devices capable dvd games servers cellular infrastructure third generation wireless systems asics alternative processing multimedia streams application spe cific integrated circuit asic chips 
asics offer fixed hardware solution processing multimedia streams 
multimedia applications spend significant amount time small numbers processing routines kernels 
design ers asics optimize hardware critical sections applica tion achieve high degrees performance 
asic designed specific function typically delivers performance order magnitude greater gpp raw processing capacity run func tion 
increasing transistor densities different functions implemented single chip addition system logic leading system chip 
large volume applications asics offer significant perform ance advantages addition tremendous savings power consumption low cost 
example media processing asic announced ana log devices adv jp 
adv jp high performance image processor implements computationally intensive operations jpeg image compression standard hardware 
chip contains full custom wavelet processor entropy codec associated interface control functions 
example asics multimedia processing cube family products applications set top boxes broad cast consumer video dvd 
major drawback asics provide limited flexibility optimized implement specific function 
ex ample adv jp perform wavelet transform 
mul technologies fast moving targets due changing standards ing interfaces shifting consumer tastes 
programmable approaches simd general purpose processors vliw media processors provide advantage asics 
problem primarily problems media processing general purpose processors 
behavior multimedia applications general purpose processors understood 
media processing general purpose processors simd style ex tensions contain bottlenecks 
objectives specific objectives dissertation fold 
objective understand characteristics multimedia ap plications 
dissertation investigates issues execution characteristics multimedia applications dif ferent desktop applications 
execution tics memory branch behavior resource instruction stream stalls data memory floating point operations examined 
characteristics multimedia applications map simd enhanced general purpose processors 
simd enhanced general purpose processors capable exploit ing available data level parallelism multimedia applica tions 
percentage peak computation rate achieved simd execution units general purpose processors 
computation rate low reasons prevent simd execution units achieving computation rate 
bottlenecks media processing simd style ex tensions general purpose processors 

second objective design implement cost effective hardware support alleviating eliminating performance bottlenecks simd enhanced general purpose processors 
thesis statement dominant fraction instructions multimedia instruction stream performing useful computations merely supporting computa tions 
hardware accelerate supporting instructions significantly im prove performance media applications simd enhanced general purpose processors 
contributions dissertation contributions characterization dia workloads detection bottlenecks explicit hardware support accel erating media applications simd gpps 
described detail 
summary contributions listed 

perform quantitative study execution characteristics com multimedia applications state art superscalar proces sor 
memory access behavior cache branch behavior resource usage studied 
contrary popular belief caches ineffective multimedia applications multimedia applications ex better data cache performance desktop applications 
branch misprediction ratio multimedia applications higher spec benchmarks 
perform evaluation simd vliw techniques multimedia dsp applications 

characterization media workloads simd gpps perspective support required efficient simd processing focusing computation part algorithms 
study shows instructions media instruction stream forming useful actual true computations merely supporting computations 
observed simd computation units computing peak computation rate 

introduce mediabreeze architecture significantly improves formance media applications decoupling media program execution useful computations overhead supporting instructions 
explicit hardware support provided executing supporting instructions 
set multimedia kernels way simd gpp aug mented mediabreeze architecture superior way simd gpp 
set multimedia applications way simd gpp augmented mediabreeze architecture outperforms way simd gpp respectively 

implement hardware units mediabreeze architecture ana area power timing tradeoffs 
added hard ware consumes gpp chip area power consumption ghz 
achieved ing critical path gpp pipeline 
organization chapter describes existing pertinent dissertation 
past research efforts characterizing multimedia workloads discussed 
studies evaluating effectiveness simd extensions architectural enhance ments improve performance multimedia applications discussed 
gen eral purpose computer architecture schemes related proposed enhance ments dissertation described 
chapter presents performance evaluation methodology dissertation 
detailed description tools benchmarks evaluation envi ronment performance measures 
chapter presents quantitative study execution characteristics commercial multimedia applications state art simd enhanced general purpose processor 
similarities differences multimedia desktop workloads highlighted 
addition evaluation comparison simd vliw paradigms media signal processing 
pentium ii tms xx processors simd vliw representatives respectively 
chapter identifies bottlenecks execution multimedia applica tions simd gpps 
supporting instructions necessary feed simd execution units analyzed 
utilization rate simd execution units measured 
chapter proposes mediabreeze architecture influenced characterization studies chapters 
focus architecture instructions support core computations compu tations 
performance mediabreeze architecture evalu ated compared wide issue simd gpps 
chapter investigates cost incorporating mediabreeze archi tecture high speed simd gpp 
tradeoffs area power timing evaluated cell asic design methodology 
chapter concludes dissertation summarizing contributions suggesting opportunities 
acronyms adpcm adaptive differential pulse code modulation alu arithmetic logic unit asc applied scientific computer asic application specific integrated circuit billions operations second btb branch target buffer cad computer aided design cfa color filter interpolation cisc complex instruction set computer cmos complementary metal oxide semiconductor cpi cycles instruction cpu central processing unit dae decoupled access execute dct discrete cosine transform dlp data level parallelism dram dynamic random access memory dsp digital signal processing digital signal processor dtlb data translation look aside buffer dwt discrete wavelet transform fft fast fourier transform fir finite impulse response flops floating point operations second fp floating point gflops giga floating point operation second gpp general purpose processor idea international data encryption algorithm iir infinite impulse response ilp instruction level parallelism ipc instructions cycle isa instruction set architecture stream instruction stream itlb instruction translation look aside buffer jpeg joint photographic expert group cache level cache cache level cache lru mac multiply accumulate max media acceleration extensions mips digital media extensions mflops millions floating point operations second mips instructions second mmx multimedia extensions mpeg moving picture expert group mux multiplexer motion video instructions nop operation nsp native signal processing risc reduced instruction set computer sdram synchronous dynamic random access memory simd single instruction multiple data sma structured memory access architecture spec standard performance evaluation specint spec integer benchmarks specfp spec floating point benchmarks sse streaming simd extensions tlb translation look aside buffer micro operations vis visual instruction set vliw long instruction word chapter related multimedia workloads processors researched extensively past years 
related divided different categories characterizing multimedia workloads efforts quantifying benefits simd extensions architectural enhancements proposed researchers improve performance multimedia applications general purpose architecture research related enhancements proposed dissertation 
multimedia application characteristics section describes past research discusses characteristics media loads 
mention distinguishing characteristics multimedia applications general purpose applications position pa 
real time response multimedia applications video conferencing electronic commerce require certain quality service real time response 
continuous media data types input data multimedia applications comprises set data elements derived sampling analog signal time domain video audio sensory perception 
media data types differ data types width typical data bits versus bits 
significant fine grained data parallelism data parallelism inherent signal processing graphics applications 
input data streams frequently large collections small data elements pixels vertices frequency amplitude values 
lends machines simd hardware units executing parallel 
significant coarse grained parallelism media applications ios consist time critical execution thread 
example typical video conferencing application consists video encoding de coding audio encoding decoding background task threads independent 
high instruction locality small loops dsp media process ing applications consist small loops kernels dominate processing time 
high memory bandwidth working data sets media applications huge implying processors provide high memory bandwidth tolerate long memory latency 
high network bandwidth processor able accommodate high network speeds 
extensive data reorganization packing unpacking data necessary advantage simd execution units 
lee introduce mediabench benchmark suite compare media applications specint workloads 
single issue proces sor perform experiments 
observe mediabench bench marks better instruction cache hit rates specint benchmarks 
find data caches effective reads mediabench specint effective writes 
specint required times bus bandwidth mediabench 
mediabench applications higher ipc specint workloads 
extends characterization mediabench workloads 
finds nearly instructions operate data sizes bits 
average basic block size small leads conclude parallelism multimedia applications basic blocks 
evaluation ilp revealed multimedia applications similar general purpose applica tions 
evaluation parallelism operation frequencies memory formance video signal processors closely related media processors performed trace driven simulations 
study formed assumptions perfect branch prediction perfect memory dis infinite sized scheduling window 
trace driven simu lation results best define upper bound potential performance 
ilp ranging ideal machine model 
conducted study memory system performance multimedia applications mediabench suite 
observe data caches multimedia applications lower cache rates spe cint programs 
addition conclude larger input data sizes necessarily result higher cache rate 
smith ana cache behavior berkeley multimedia workload find multi media applications exhibit lower instruction ratios comparable data ratios contrasted widely studied workloads 
addi tion find longer data cache line sizes currently benefit multimedia processing 
explore cache strategies multimedia applica tions 
find standard caching policies gpps exhibit poor performance exploiting spatial locality typical programs handling processing images 
introduce hardware prefetching employing prefetch pol icy observe better cache performance block lookahead policy 
hughes measure variability execution dia applications gpps 
find execution time varies frame frame multimedia applications variability caused application algorithm media input 
conclude aggressive architectural features induce little additional variability unpredictability execution time 
dissertation evaluate execution characteristics cial multimedia applications state art superscalar processor simd extensions compare existing characterizations desktop workloads 
benefits simd extensions research efforts evaluated benefits simd extensions commercial 
bench marking applications ultrasparc processor vis showed performance speedup dsp applications non vis ver sions 
applications fir filters showed improvement iir filters ffts exhibited little performance increase 
evaluation mmx pentium processor kernels applications bhargava 
performance image video processing vis extensions analyzed ranganathan benefits vis reported 
shown conventional ilp techniques provided formance improvements media extensions provided additional performance improvement 
motorola altivec technology seen result significant performance increase dsp multimedia kernels 
performance analysis mmx technology video encoder reported performance improvement mmx optimized scalar assembly code mmx 
number commercial general purpose dsp processors benchmarked suite kernels 
single performance metric denoting execution time released public domain benchmarks 
execution time measured kernels written chip memory 
sriram hung implementation mpeg video decoder xx dsp processor compared performance vari ous components mmx hp max vis 
xx faster simd implementations 
different dlp alternatives embedded media domain evaluated demonstrate superiority matrix simd extensions simd traditional simd extensions 
dissertation compare simd vliw approaches multi media dsp applications state art commodity processors 
media architectural enhancements research starting mid late proposed architectural en improve performance multimedia workloads gpps 
developed imagine architecture bandwidth efficient media processing 
architecture clusters alus processing large data streams built processor high multimedia system 
levels memory hierarchy provided local register file cluster global stream register file external sdram 
compared conventional scalar processor imagine reduces global register mem ory bandwidth factors respectively able achieve peak performance gflops sustained performance gflops media processing kernels 
goldstein design piperench processor streaming multimedia acceleration 
piperench processor reconfigurable fabric architecture achieving performance improvement media kernels risc processor 
related effort chimaera architecture ye 
chimaera prototype system integrates small fast recon functional unit pipeline aggressive dynamically sched superscalar processor 
authors demonstrate way order superscalar processor chimaera results average performance crease 
proposed adding vector unit superscalar processor improve performance numeric multimedia codes 
related proposes exploit dlp dimensions dimension processing mmx 
performance improvement shown relevant multimedia applications traditional simd extensions 
lee proposed evaluated simple long vector microprocessors multimedia applications 
show order superscalar processor order short vector conventional simd extensions simple order long vector allows poten tial saving chip area achieves better multimedia performance 
important general purpose processor achieve sustained perform ance different domains workloads 
vassiliadis proposed complex streamed struction set csi enhance existing order gpp 
stream computa tion instruction capture levels loop nesting 
describe dct reed solomon code similar media oriented op erations enhanced hardware accelerator works conjunction gpp 
accelerator designed algorithm 
re targeting accelerator algorithm incurs significant effort 
ranganathan propose reconfigurable caches appli media processing 
find ipc improvements ranging applying instruction reuse multimedia benchmarks 
dissertation accelerate multimedia applications adding ex plicit hardware support simd gpp 
related gpp architectures section describe gpp architectures relevant proposed enhance ments dissertation 
proposed solution combines advantages simd vector dae dsp processors 
dae concept ibm system cdc cdc cray map sdp pipe sma wm ds demonstrated potential decoupling memory accesses computations 
research specialized access processors ad dress generation coprocessors 
concept embedding loops hardware implemented commercially ti asc loop case 
sma architecture provided similar flexibility accessing ces 
concept seen successful machines dsp processors 
burroughs scientific processor pure simd array processor special purpose hardware called alignment net works packing unpacking data 
addition processor powerful simd instructions current simd ex tensions 
chapter performance evaluation methodology chapter methodology characterizing media workloads evaluating performance media enhancements proposed tation 
detailed description various tools benchmarks dissertation 
discuss evaluation environment perform ance measures 
tools performance monitoring counters built processor performance counters intel microarchitecture pentium ii iii processors media workload characterization studies 
measurements various statistics processors performed ing counters 
hardware performance counters offer advantage measuring processor statistics non obtrusive way generating results real time 
addition benchmark source code necessary measuring execution statistics 
microarchitecture implements performance counters counter associated event select register controls counted 
counters accessed instructions 
measure events performance counters measure events run runs benchmark necessary 
performance monitoring utility microarchitecture provides option reading ring events ring ring events 
ring events correspond user level processes active particular time 
ring events correspond operating system processes 
dissertation ring events masked gather execution characteristics multimedia application intervention operating system related events 
evaluating benchmark user process kept active minimize effects pollution 
detailed listing various performance monitoring events microarchitecture provided appendix intel performance analysis tool get complete struction mix assembly instructions code 
tool designed ana hot spots code optimizing 
addition provides time event system sampling call graph profiling 
profile instruction mix processors microarchitecture 
simplescalar simulator order simulator simplescalar tool suite study performance media workloads superscalar processors 
addi tion simplescalar simulator modified evaluate improvements achieved proposed methods 
simd extensions provided simulator adding bit simd execution units processor core 
simplescalar tool suite widely computer architecture re search involving superscalar processors 
simulator sim models superscalar order pipeline detail execution driven simulation 
models different isas 
pisa isa mips archi tecture 
simplescalar tool set provides ability add new instructions altering compiler instruction annotations 
instruction annotations model simd instructions 
tms simulator xx simulator analyze performance dsp multimedia applications vliw processors chapter 
texas instruments provides cy cle accurate simulator xx vliw dsp processor 
execution cy cle counts dsp media benchmarks obtained stand simulator 
clock function provided simulator returns execu tion times benchmarks 
benchmarks multimedia benchmarks understand characteristics media applications 
table shows commercial media applications benchmarks dissertation 
applications categorized graphics unreal streaming video quick time streaming audio realaudio winamp 
commercial applications excellent benchmarks study properties multimedia applications 
applications available binaries source code available 
table lists media signal processing kernels appli cations dissertation addition benchmarks described table evaluating proposed hardware support 
kernels table form significant components media applications 
benchmark applications table popular multimedia benchmark suites mediabench 
table 
description commercial media applications benchmarks workload characterization application description unreal quicktime winamp realaudio popular games excellent graphics sounds smart combat enemies 
processor vendors graphics accelerator manufacturers benchmark standard gaming benchmark 
game demo run resolution inch monitor 
executed instructions 
feature rich game touted heavily mmx instruction set 
graphics engine unreal advanced audio engine unreal outperforms audio 
game demo run resolution inch monitor 
executed instructions 
delivers high quality digital video lower bit rates non streaming solutions compressed quicktime avi mpeg 
technology allows intranets deliver video training corporate communications presentations desktop 
video clip inch inch played 
executed instructions 
quicktime multimedia architecture developed apple synchronize graphics text video sound 
quicktime ideal synchronizing picture sound 
quicktime economical solution terms bandwidth music video 
avi video clip inch inch played 
executed instructions 
winamp fast flexible high fidelity music player windows nt 
winamp supports mp mp cd mod wav audio formats custom interfaces called audio visualization audio effect plug ins 
mpeg audio stream played 
executed instructions 
realaudio system designed deliver streaming audio speech music 
player cache downloaded files 
synchronization video flash sequence html files provides excellent vehicle multimedia presentation 
realaudio audio stream played 
executed instructions 
table 
summaries benchmark kernels applications 
source code benchmark available dot product autocorrelation auto finite impulse response filter fir color filter array cfa discrete cosine transform dct motion estimation image scaling scale audio effects aud speech coding adpcm speech compression adpcm jpeg image compression jpeg kernels dot product randomly initialized element array repeated times bit data autocorrelation element vector lag repeated times bit data low pass filter length operating buffer elements repeated times bit data color filter array interpolation pixel image filter bit data discrete cosine transform pixel image bit data motion estimation routine frame pixels bit data linear scaling image pixels bit data applications adding successive echo signals signal mixing filtering data samples bit data law law conversion vice versa specified itu standard data samples bit data bit bit compression speech signal obtained intel element buffer repeated times bit data jpeg image compression pixel image jpeg image decompression ijpeg idea decryption decrypt evaluation environment jpeg image de compression resulting pixel image idea decryption bytes data pentium ii pentium iii processor systems running windows nt experiments microarchitecture chapters 
ex periments analyzing performance vliw processors media dsp applications chapter performed xx simulator 
experi ments simd gpps proposed enhancements bottleneck detection performed simplescalar tool suite chapters 
significant effort put generating code experiments dissertation 
case commodity processors pentium ii pentium iii tms xx dsp assembly libraries compiler intrinsics create simd vliw versions code 
case sim processor simulator simd code generated hand coded instruction annotations 
rest section describes com code development assembly libraries compiler intrinsics 
compilers compilers generating media application code 
code gen eration processors microarchitecture performed intel compiler 
code generation xx vliw dsp performed texas instruments xx compiler 
modified version gcc simplescalar gcc generating code simplescalar processor 
hand coded assembly creating simd code processor simulator 
code generation microarchitecture xx dsp processor assembly libraries compiler intrinsics ex 
maximum optimizations provided compilers study 
assembly libraries intel assembly libraries provide versions common signal process ing vector arithmetic image processing kernels called functions 
signal processing library calls require library specific data structures created initialized calling kernels fir 
ing assembly libraries restricted intel libraries auto benchmarks benchmarks calling sequence library functions library versions extra data structures 
code developer replace complete function call call library function assembly libraries util ized completely 
creating simd versions pentium ii iii processors benchmarks assembly libraries replaced function written call signal processing library incorporates simd mmx sse instructions 
loss accuracy simd versions benchmarks operate bit data bit data 
issue intel libraries generally robust intuitive employ lot error checking code guarantee functional correctness potentially increase execution time 
overhead simd instructions mis alignment related instructions packing unpacking data related instruc tions potential benefit simd instructions 
ti provides optimized assembly code xx 
libraries code callable calling sequence code counterpart 
restrictions apply xx opti mized vliw assembly codes 
example fir code requires number filter coefficients multiple length auto vector multiple 
compiler intrinsics intel ti libraries useful entire function written replaced equivalent callable assembly function call 
applications easily replaceable functions difficult find cially applications kernels speech coding adpcm benchmarks 
intel compiler xx com piler provide intrinsics inline simd mmx sse vliw xx assembly instructions respectively 
compilers allow variables hardware registers schedule instructions maximize formance 
creating simd versions pentium ii iii processors benchmarks profiled benchmarks identify key procedures incorporate simd instructions 
major computation replaced equivalent set simd instructions original functionality maintained 
unrolled loops manually isolate multiple iterations loop body replaced equivalent intrinsics 
xx compiler similarly provides intrinsics inlining assembly instructions code 
compiler intrinsics provided mul numbers shift saturate approximate reciprocal square root subtract lower upper halves registers 
compiler detailed descriptions obtained 
performance measures performance measures dissertation ing multimedia applications 
performance measures execution time speedup performance improvement obtained tech nique technique benchmark calculated execution time divided execution time 
techniques vary depending experiment 
ipc instructions retired cycle indicates processors ability overlap multiple instructions 
cpi cycles retired instructions 
cache hit rates cache hit rates computed ratio number cache hits total number cache accesses 
chapter execution characteristics multimedia applications chapter characterizes performance commercial multimedia applica tions categorized graphics streaming video streaming audio processor system 
architectural data pertaining utilization various hardware resources chip collected chip performance counters 
execution characteristics multimedia workloads compared spec desktop applications 
rest chapter organized follows 
section presents various execution characteristics commercial multimedia applications table pentium ii processor mmx technology 
compare existing spec nt characteristics 
section presents evaluation simd vliw techniques media signal processing pentium ii xx representative processors 
section summarizes chapter 
detailed characterization multimedia applications pentium ii processor mmx technology operating mhz run ning windows nt characterization 
intel pentium ii processor way superscalar architecture capable retiring micro instructions cycle 
implements dynamic execution order speculative execution engine register renaming integer floating point flag variables carefully controlled memory access reordering multi processing bus support 
integer units floating point units memory interface unit allow micro ops scheduled clock cy cle 
addition provides mmx execution unit simd processing 
bit mmx alus bit mmx multiplier 
pentium ii evaluation kb instruction data caches kb cache 
rest section presents execution characteristics multimedia applications 
cycles instruction shows cycles instruction cpi individ ual multimedia applications table 
geometric mean mul specint specfp nt benchmarks shown 
geometric mean cpi multimedia workloads cpi cpi unreal quicktime winamp realaudio lies specint specfp benchmarks 
factors affecting cpi discussed detail subsequent sections 
resource instruction stream stalls shows stream stalls resource stalls measured terms cycles stall conditions occur 
cache misses itlb misses cause stream stalls 
resource stalls show number cycles re sources register renaming reorder buffer entries memory entries cpi cpi specint multimedia specfp nt 

cycles instruction individual multimedia benchmarks comparison media applications workloads stalls instr 
stalls instr 
resource stalls stream stalls cpi unreal winamp realaudio resource stalls stream stalls cpi specint multimedia specfp nt 

stalls instruction individual multimedia benchmarks comparison media applications workloads execution units full stalls may overlapped execution latency previously executing instructions 
increase cpi directly proportional sum stream resource stalls observed 
realaudio highest number resource stream stalls exhibits largest cpi dia benchmarks 
geometric mean resource stalls multimedia workload stream stalls 
number resource stalls cpi cpi case multimedia applications twice number stalls specint benchmarks 
resource stalls case nt comparable multimedia benchmarks 
specfp benchmarks incur sig resource stalls due long dependency chains 
interestingly number stream stalls instruction multimedia benchmarks simi lar specint third nt bench marks 
number stream stalls graphics applications smaller audio video applications 
combined resource stall stream stall ratios multimedia applications specint specfp ratios correlating cpi multimedia applications lies specint specfp benchmark suites observed cpi ratios 
branch statistics shows number branches instruction branch mispredict ratio multimedia benchmarks 
multimedia pro grams branch instruction ratio 
ratio specint ratio specfp 
branch statistics available nt lee report desktop applications exhibit behavior specint benchmarks respect average basic block size 
instructions branch specint branch instr 
branch instr 
branch inst branch mispredict ratio unreal quicktime winamp realaudio branch inst branch mispredict ratio specint multimedia specfp benchmark suite instructions branch dia applications instructions branch case floating point benchmarks 
average available ilp multimedia applications potentially larger average ilp specint programs 
case multimedia applications explained mmx operate data elements time single instruction 
mis predict ratio mis predict ratio 

branch statistics individual multimedia benchmarks comparison media applications workloads spite processing average basic block size multimedia applica tions twice programs spec suite 
reports average basic block size multimedia appli cations mediabench suite similar general purpose integer applica tions 
observes average basic block size varies significantly media benchmark 
approximately branches mispredicted specint specfp multimedia applications branches mis predicted 
number mispredicted branches ranges instructions integer benchmarks floating point benchmarks multimedia benchmarks 
mul benchmarks btb ratio 
specint btb ratio specfp btb ratio 
spite having better average basic block size cpi dia applications integer benchmarks 
negative effect having higher resource stalls seemingly positive effect fewer branches instruction 
case floating point benchmarks longer latencies floating point operations added higher resource stalls increase cpi considerably number branches far types benchmarks 
data ref instr 
data ref instr 
data memory data instruction memory transactions instructions unreal winamp realaudio data instruction memory transactions instructions specint multimedia specfp 

memory statistics individual multimedia benchmarks comparison media applications workloads shows number data instruction number memory transactions instructions 
average multimedia specint specfp benchmarks generate data instruction 
data memory statistics available nt lee report desktop applications exhibit ratios similar specint benchmarks 
ia architecture results data memory trans 
memory trans 
risc architectures fewer registers versus 
memory transactions arise fetching missed data instructions write back dirty blocks replacement 
number memory transac tions instructions higher general rate cache higher discussed section 
multimedia applications higher number memory transactions instructions spe cint lower specfp benchmarks 
cache behavior pentium ii processor consists separate kb way set associative data instruction caches cache line length bytes 
caches em write back replacement policy pseudo lru replacement algorithm 
data cache consists banks interleaved byte boundaries 
data cache accessed simultaneously load instruction store struction long different cache banks 
latency load cache hit cycles simultaneously outstanding misses handled 
pentium ii processor unified kb way set cache 
table shows data cache rates multimedia ap plications 
table 
data cache rates multimedia applications kb way separate kb way unified cache benchmark rate local rate global rate unreal quicktime winamp realaudio average multimedia applications achieve kb data cache hit rate specint desktop workloads similar hit rates processor data accesses cache global rate 
local rate table corresponds number misses cache divided number cache accesses 
shows data instruction cache misses instructions multimedia benchmarks 
kb way data instruction cache misses instructions spec spec integer floating point suites compared multimedia applications 
streaming video audio benchmarks incur instruction cache misses graphics applications 
data instruction misses insts 
misses insts 
data misses instr misses misses unreal quicktime winamp realaudio specint kb specint kb multimedia kb specfp kb specfp kb data misses instr misses 

cache statistics individual multimedia benchmarks comparison media applications workloads cache misses instructions multimedia applications slightly higher specint benchmarks lower specint benchmarks 
specfp programs dominated loops results predictable control flow excellent instruction cache perform ance reflected minimal cache misses instructions 
data cache misses instructions specfp programs significantly worse multimedia applications 
results indicate data caches reasonably multimedia applications opposed popular notion caches ineffective media applications due streaming nature 
shows correlation cpi data instruction cache misses latency cycles cycles multimedia applications 
floating point operations misses misses cpi unreal quicktime winamp realaudio 

log plot cpi versus cache misses shows amount floating point computation performed multimedia benchmarks 
winamp realaudio rest benchmarks contain floating point related instructions 
floating point unreal quicktime winamp realaudio 

percentage floating point instructions fact graphics applications unreal integer com opposed floating point operations floating point computation graphics applications performed graphics accelerator cards desktop workstations 
reports multimedia applica tions mediabench suite floating point operations 
multimedia extensions mmx multimedia applications exploit available data parallelism simd extensions mmx technology 
unfortunately media applications mmx instructions developed mmx technology introduced compilers take advantage mmx extensions 
compiler technology catch simd processing 
percentage mmx instructions benchmarks shown 
mmx especially suited audio applications expected realaudio winamp take advantage mmx instructions 
sur uses mmx instructions 
realaudio component components 
uses mmx instructions realaudio fails 
developed mmx announced mmx instructions 
unreal hand game uses mmx technology heavily 
nearly half dynamic instructions unreal mmx related 
total number mmx instructions sub divided ries packed multiply packed shift pack operations unpack operations packed logical operations packed arithmetic operations 
overhead involved mmx computations packing unpacking instructions 
shows overhead percentage benchmarks 
overhead mmx insts 
unreal quicktime winamp realaudio 

percentage mmx related instructions overhead mmx insts 
pack unpack unreal quicktime 

packing unpacking instructions percentage mmx instructions associated mmx instructions mmx instructions re quicktime unreal 
interesting note unpacking overhead times packing overhead 
benefit mmx usually exceeds overhead associated packing unpacking instructions mmx 
unreal option dis mmx instructions 
observed number frames second mmx times greater mmx 
speculative execution factor instruction microarchitecture instruction fetch unit fetches bytes clock cycle cache delivers instruction decoder 
parallel decoders decode stream bytes convert triadic 
instructions converted directly single de coded complex instructions require microcode 
issued clock cycle various execution units retired cycle 
branch incorrectly predicted speculated instructions mispredicted path flushed 
speculative execution factor defined number instructions decoded divided total number instructions retired 
shows num ber micro operations instruction speculative execution factor multimedia benchmarks workloads 
speculation unreal quicktime winamp realaudio speculation specint multimedia specfp nt 

average number instruction speculation execution factor individual multimedia benchmarks comparison media applications workloads multimedia applications instruction results average micro ops similar behavior specint specfp programs 
nt applications high instruction ratio 
speculation execution factor multimedia ap plications lowest different workloads illustrating signifi cant mis speculation ratio 
comparison simd vliw approaches media processing section evaluate performance simd paradigm intel pentium ii processor mmx vliw paradigm texas ment tms xx processor subset dsp media benchmarks table 
briefly describe xx processor followed analysis results 
tms xx dsp processor texas instruments tms xx general purpose vliw dsp proces sor bit fixed point chip 
capable executing bit cycle 
xx processor functional units grouped identical sets units register files 

cpu core tms xx processor courtesy ti shown 
functional units unit memory load store add subtract operations unit multiplication unit addi tion subtraction logical comparison operations unit shifts addition add subtract logical operations 
set functional units register file cross path provided accessing register files set functional units 
interested reader referred architectural details xx processor 
results profile subset benchmarks evaluation kernels auto fir applications aud adpcm 
versions benchmark simd pentium ii mmx vliw xx non simd pentium ii mmx 
baseline processor pentium ii proc mmx non simd 
illustrates performance simd vliw code non simd version 
execution time pre sented table 
interpreting results remembered baseline non simd performance derived way superscalar proc performs dynamic scheduling exploit ilp 
speedup non simd simd vliw auto fir aud adpcm 

ratios execution times simd vliw processors table 
execution clock cycles simd vliw processors benchmark non simd cycles simd cycles vliw cycles auto fir aud adpcm vliw processor capable executing instructions cycle simd unit capable executing operations cy cle bit data respectively 
significant speedup achieved simd vliw versions non simd code kernels 
kernel shows improvement approximately times simd version non simd version despite bit data 
super linear speedup possible due presence pipelined multiply accumulate instruction mmx throughput cycle latency cycles 
non simd case integer multiply operation takes cycles 
dynamic instructions case simd version mmx related instructions 
performance vliw version better simd version speedup close times 
vliw code capable executing data elements clock cycle case way scalar processor take clock cycles data ele ment loads multiply add store 
xx code takes advantage software pipelining prefetch data itera tions 
auto kernel shows similar performance increase simd vliw versions 
case auto uses multiply accumulates 
simd case dynamic instructions mmx related instructions 
case vliw processor fetch packets execute packet indicating instructions able execute parallel 
majority remaining fetch pack ets execute packets indicating average instructions parallel 
fir benchmark shows modest performance increase speedup simd version non simd code compared kernels 
amount mmx related instructions dynamic stream far kernels 
simd version needs copies filter coefficients avoid data misalignment 
intel library version fir filter exhibited speedup 
due addi tional data structures defined error checking code po decrease performance results improved robustness 
vliw version exhibits stronger performance boost simd version 
case auto fetch packets execute packet instructions executing parallel 
vliw kernel codes hand optimized assembly libraries 
vliw code constraints number filter cients multiple size auto vector mul tiple 
results vliw versions applications disappointing compared performance improvements obtained kernels 
adpcm involve significant control dependent data dependencies execution table lookup conditional branch statements immediately preceding computations 
aud application appreciable parallelism exploited vliw environ ment 
vliw version aud application exhibits speedup close non simd version 
echo effects signal mixing components vliw version unrolled manually times 
speedup achieved vliw version aud application half kernels 
xx version primarily developed code filtering component utilized optimized assembly code 
compiler generates echo effects signal mixing components 
utility xx compiler provides user ability original source code compiler generated assembly code 
compiler generated assembly code echo effects signal mixing components indicates compiler unable fill pipeline slots execute packets fetch packet 
compiler unable software pipeline echo effects component 
effectively introduced nops load degraded performance 
loop unrolling computations result nops load 
order execution vliw processor loop unrolling instance contributes perform ance increase terms speed increases code size 
vliw code adpcm shows speedup non simd simd cases 
application xx compiler perform loop unrolling software pipelining 
parallelism ex unrolling drastically increase code size little formance increase 
software pipelining difficult loads ap plication depended execution conditional branch statements 
compiler generated assembly code non optimal branches followed nops loads followed nops 
fetch packets execute packets serial opposed desired parallel exe cution 
vliw version shows slowdown non simd code 
analysis showed base non simd model way dynamically scheduled superscalar processor achieves ipc ap 
xx code packets slot utilized 
branches followed nops cycles assembly code 
loads due look table nops cy cles inserted code 
static scheduling combined branch prediction control nature application parallelism exploited 
operates bit data rest bits xx data width bits internally wasted 
speedup achieved application benchmarks simd technology appreciable 
aud application shows moderate speedup simd code non simd code 
dy namic instructions mmx related 
loop unrolling echo effects filtering signal mixing portions application 
adpcm benchmark mmx instructions algorithm inherently sequential computation data sample depends result immediately preceding sample 
simd version speedup non simd code 
number mmx related instructions performance increase partly due manual loop unrolling 
simd vliw processors able ex tract dlp ilp respectively multimedia dsp programs 
vliw proc advantage exploiting ilp dlp exist adpcm benchmark 
hand vliw processors dynamic scheduling branch prediction seen heavily dependent capabilities compiler adpcm dynamically scheduled superscalar processors exploit ilp irrespective quality compiled code 
summary chapter execution characteristics commercial multimedia applications evaluated different domains graphics streaming video streaming audio 
built hardware performance counters sta cpi branch frequency mis prediction rate instruction stream resource stalls cache behavior compared corresponding char spec desktop benchmarks 
major observations summarized number resource stalls instruction multimedia applications twice specint workloads similar desktop workloads third specfp workloads 
number instruction stream stalls instruction multimedia applications similar specint loads third desktop workloads 
specfp workloads instruction stalls instruction 
combined resource stream stall ratios media benchmarks lie specint specfp desktop workloads 
similar trend observed cpi reflect ing influence resource stream stalls cpi 
branch frequency multimedia workloads half specint workloads twice specfp workloads 
branch mispredict ratio multimedia applications higher specint specfp applications 
number data memory instruction architec ture observed approximately irrespective workload spec desktop multimedia 
contrary popular belief data caches ineffective multimedia applications due streaming nature multimedia bench marks achieve cache hit rate kb way global hit rate kb way 
multimedia applications achieve better data cache performance kb way specint specfp specfp slightly worse specint workloads 
struction cache rate similar specint half spe cint benchmarks specfp specfp exhibit near cache hit rates 
multimedia applications significant floating point op erations streaming audio applications winamp floating point instructions realaudio floating point instructions 
benchmarks evaluated mmx instructions mmx instructions packing unpack ing operations 
media applications instruction results average similar specint specfp benchmarks desktop workloads exhibit average 
speculative execution factor multimedia applications lower specint specfp desktop workloads specint highest speculative execution factor 
vliw processors exploit ilp programs dlp 
heavily dependent compiler performance appli cations relatively poor compared performance kernels 
chapter bottlenecks multimedia processing simd style extensions simd extensions accelerate multimedia applications exploiting dlp 
improvement performance encouraging exciting notice performance scale increasing simd execution resources 
primary contribution chapter characterization media workloads perspective support required efficient simd processing 
typi cally studies focused simd computation part algorithms 
chapter focus supporting instructions show significant ad ditional performance opportunities exist simd gpps 
embark study understand behavior multimedia applica tions simd gpps evaluate dlp multimedia applications 
chap ter attempt answer simd gpps typically exploit sub word parallelism independent loop iterations inner loops multimedia programs 
dlp media applications reside 
dlp reside inner loops significant dlp outer loops 
nested loops required processing multimedia data streams necessitates multiple indices generating addresses 
gpps contain limited support compute addresses elements multiple indi ces 
levels nesting required common media algorithms 
addressing sequences primarily sequential 
simd extensions capable performing multiple computations cycle essential provide data simd computation unit timely fashion order efficient sub word parallel ism 
providing data timely fashion requires supporting instructions address generation address transformation data reorganization packing unpacking permute processing multiple nested loop branches loads stores 
supporting instructions dominant part struction stream 
percentage peak computation rate achieved simd exe cution units gpps 
computation rate low reasons prevent simd execution units achieving computation rate 
rest chapter organized follows 
section includes sen experiments scalability conventional ilp dlp techniques 
section describes studies detect bottlenecks execution simd programs 
section describes loop nesting access patterns mul applications mapping simd gpps 
section classi fies dynamic instructions fundamental categories useful computa tion instructions overhead supporting instructions analyze mix media benchmarks 
section measure percent peak computa tion rate achieved simd execution units gpps conducting experi ments different superscalar processors 
section identifies additional bottlenecks conventional ilp processors limit computation rate simd execution units 
chapter summarized section 
scalability test logical approach improve performance scale processor resources extract parallelism 
understand ability wide order super scalar processors increase performance multimedia programs performed experiments scaling various resources processor table 
fig ure shows instructions cycle ipc different processor configurations multimedia benchmarks 
table 
processor memory configuration scalability test parameters fetch width way way way way decode width issue width commit width ruu size load store queue integer alus latency recovery integer multipliers latency recovery load store ports latency recovery cache size kb hit time associativity block size bytes cache size kb hit time associativity block size bytes unified cache size kb hit time associativity block size main memory width bits bits bits bits main memory latency chunk chunk branch predictor bimodal size btb size simd alus simd multipliers ipc ipc ay ay ay ay cfa dct mot scale aud jpeg ijpeg decrypt cfa dct mot scale aud jpeg ijpeg decrypt cfa dct mot scale aud jpeg ijpeg decrypt way way way incidentally note performance achieved simd units scaled non simd components scaled way processor keeping simd component constant way processor simd alus simd multiplier 
ipc case depicted 
percentage increase ipc scaling 

results scalability test 
ipc simd non simd resources scaled ipc non simd resources scaled simd resources constant way processor configuration performance improvement simd non simd resources case scaling non simd resources shown 
experiment shows bottlenecks multimedia processing simd style extensions 
identification bottlenecks evident bottlenecks simd style media processing possible achieve significant additional performance im making processor wider bigger extract parallelism 
investigate characteristics media programs point bottlenecks current simd architectures 
nested loops multimedia applications section nature multimedia loops investigated understand levels nesting stride patterns location parallelism 
desk top workstation multimedia applications streaming video ing decoding mpeg motion jpeg audio encoding decoding adpcm xx mp video conferencing games image processing jpeg filtering typically operate sub blocks large dimensional block data 
audio applications operate chunks dimensional data samples time 
example mp codec operates frames smaller components complete audio signal lasts fraction second 
image video applications operate sub blocks dimensional data time 
example dct algorithm operates pieces data large image pixels 
division data sub blocks results data accessed different strides various instances algorithm 
depicts dimensional block data accessed different strides vertical direction horizontal direction 
source code aforementioned algorithms involves usage multiple nested loops commonly loops language process data streams 
available parallelism multimedia applications dlp stride vert stride vert stride stride sub block 

data structure sub blocks data processed 
sub block requires strides rows columns sub block stride stride 
additional strides stride stride required accessing different sub blocks horizontal vertical direction 
resides various levels nesting 
dimensions sub block multimedia algorithms small filtering typically uses sub blocks dct operates sub blocks motion estimation oper ates sub blocks resulting limited parallelism innermost loop 
number sub blocks large size data stream order mb 
consequently significant part dlp multimedia applications resides outside innermost loop ap plications coded differently 
existing gpps simd extensions exploit dlp independent loop iterations innermost loops leading significant available dlp multimedia applications 
shows simd code implemen tation dct dct major component jpeg image mpeg video coding operates sub blocks image height width 
second matrix transposed doing computation cause accessing second matrix column major order results significant amount overhead 
particularly true simd instructions cause simd register needs packed element different rows contiguous 
simd register holds elements rows matrix need loaded cache elements column packed register 
possible elimi nate transpose operations row column dct void dct image image width image height image height image width perform row column dct output dct coeff block dct coeff row dct dct coeff block col dct block dct coeff void xxx dct dct coeff block transpose block temp simd width temp simd mul dct coeff block output simd reduc temp 

code dct implementation transposed version dct coefficients available 
total nested loops dct routine 
current simd instructions exploit dlp innermost loop variable 
number iterations scaled width available simd datapath currently bits wide size element bit bit bit 
access patterns media applications studied 
analysis media dsp applications invocation address patterns multiple simultaneous sequences 
shows typical access pat terns media dsp kernels 
table lists key multimedia dsp kernels typical number nested loops required corre sponding primitive addressing sequences 
sequence length am address range multimedia dsp kernels considered composed primitive addressing sequences sequential addressing ii sequential offset stride addressing iii shuffled addressing base ap ap iv bit reversed addressing reflected addressing am 

typical access patterns multimedia dsp kernels table 
summary key media algorithms required nested loops primitive addressing sequences multimedia dsp algorithm discrete cosine transform jpeg mpeg coding motion est comp 
mpeg wavelet transform jpeg color space conversion jpeg mpeg graphics scaling matrix operations image video nested loops addressing sequences sequential sequential multiple offsets strides sequential sequential multiple offsets strides sequential sequential multiple offsets strides sequential sequential offsets shuffled sequential sequential multiple offsets strides fast fourier transform shuffled bit reversed color filter array median filtering correlation convolution fir iir filtering edge detection alpha saturation image video sampling transformation graphics quantization jpeg mpeg adpcm speech sequential sequential multiple offsets strides sequential sequential offsets reflected sequential sequential multiple offsets strides sequential sequential multiple offsets strides sequential sequential multiple offsets strides sequential sequential multiple offsets strides hardware generate multiple address sequences overly cated supporting general purpose instruction sets ef ficient available addressing modes limited 
furthermore support keeping track multiple indices strides efficiently gpps 
similarly keeping track multiple loop nests bounds involves combination addressing modes instructions 
gpps enhanced simd extensions extract dlp multimedia programs mismatch requirements media applications address generation nested loops ability gpps simd extensions 
simple asics perform tasks efficiently loss programmability flexibility weakness approach 
overhead supporting instructions discussion previous section points need instructions compute addresses support core simd computations 
section analyze media instruction stream focusing dis sets operations useful computations required algorithm supporting instructions address generation address transfor mation data movement data reorganization packing unpack ing loads stores loop branches 
consider dct code 
useful computation instructions dct routine multiply dct coefficients data accumulate operations addition multiplied val ues 
shown bold 
instructions denoted overhead sole purpose aid execution useful computa tion instructions 
arise due programming conventions general purpose processors abstractions control flow structures pro gramming mismatch data computations versus sequence data stored memory 
similar kind classification instructions access execute instructions performed dae proces sors 
classification overhead component includes loop branches reduction operations specific multimedia applica tions packing unpacking permute addition memory access instructions 
instructions contributing overhead address generation considerable processing time dedicated perform ing address calculations required access components data structures arrays called address arithmetic overhead 
address transformation transforming physical pattern data logical access sequence transposing matrix pack ing unpacking data elements simd computations reorganizing ways 
loads stores data available registers fetched memory stored memory called access overhead 
branches performing control transfer nested loops 
figures show assembly code classified useful com putation overhead instructions pentium iii simplescalar processors dct routine excluding transpose function inner level nested loop structure 
transposing second matrix multiplication necessitate additional overhead instructions address transformation 
figures seen significant number overhead supporting instructions necessary feed simd computation units 
order quantify amount overhead supporting instructions multimedia programs performance benchmarks cfa dct mot scale aud evaluated 
jpeg ijpeg decrypt ex periment source code benchmarks includes tion routines file benchmarks mapped way simd execution units perform useful com putation 
shows breakdown dynamic instructions various classes memory branch integer simd overhead simd computation 
pentium iii simd code lea ebx dword ptr ebp load address overhead mov dword ptr esp ebx load address overhead xor eax eax address overhead mov edx ecx address overhead lea edi dword ptr ecx load address overhead mov dword ptr esp ecx load address overhead mm ptr ebp load overhead mm mm initialization overhead mm ptr eax esi computation mm ptr ebp load overhead mm ptr eax esi computation add eax address overhead mm mm computation mm mm computation mm mm load related overhead mm simd reduction overhead movd ecx mm simd load overhead movd ebx mm simd load overhead add ecx ebx simd conv 
overhead mov word ptr edx cx store overhead add edx address overhead cmp edi edx branch related overhead jg loop branch overhead mov ecx dword ptr esp load address overhead add ebp address overhead add ecx address overhead mov eax dword ptr esp load address overhead cmp eax ebp branch related overhead jg loop branch overhead 

pentium iii optimized assembly code dct routine shown excluding matrix transpose simplescalar simd gcc code move address overhead lc load overhead move address overhead move address overhead mtc initialization overhead mtc initialization overhead move address overhead move address overhead move address overhead simd simd load overhead simd simd load overhead mul simd computation addu address overhead add simd computation slt branch related overhead addu address overhead addu address overhead bne loop branch overhead simd simd reduction overhead addu address overhead addu address overhead slt branch related overhead simd simd store overhead bne loop branch overhead addu address overhead addu address overhead addu address overhead slt branch related overhead bne loop branch overhead 

simplescalar optimized assembly code dct routine shown excluding matrix transpose cfa piii cfa ss 

breakdown dynamic instructions various classes overhead supporting instructions required assist simd computation useful computations instructions dominate dynamic instruction stream 
significant number instructions required processing loop branches computing strides accessing data organized sub blocks 
memory branch integer simd overhead simd computation dct piii dct ss scale piii scale ss simd throughput efficiency section throughput simd units evaluated understand impact overwhelming number instructions needed support simd computations 
define simd efficiency ratio execution cycles ide ally necessary useful computation instructions execution cycles consumed 
words simd efficiency indicates frac mot est piii mot est ss aud piii aud ss piii ss tion peak throughput simd units achieved 
actual execution cycles obtained measurement processor performance counters simulation ideal cycles computed assuming overhead instructions perfectly overlapped useful computation instructions 
ideal case overhead instructions address generation memory access data reorganization loop branches consume addi tional processor cycles 
number ideal execution cycles depends amount simd resources machine 
example consider matrix multi plication algorithm nxn matrices computational complexity 
assumes processor contains multiplier pipe lined addition accumulation take place parallel 
matrix multiply take cycles machine multiplier pure dataflow model take cycles machine multipliers adders accumulation 
algorithm take cycles real machine multiplier effi ciency computation 
efficiency achieved low suggests opportunities enhancement 
simd efficiency measured platforms pentium iii ma chine way simplescalar simulator benchmarks 
table shows execution statistics simd efficiency bench marks 
ideal number execution cycles computed identifying number required useful computation operations available simd exe cution units alus multiplier processors 
table 
execution statistics efficiency media programs pentium iii mmx sse benchmark inst 
count actual cycle count efficiency cfa dct scale aud benchmark inst 
count simplescalar simd actual cycle count efficiency cfa dct scale aud simd efficiency ranges pentium iii simplescalar simd processor respectively 
simd efficiency low supporting instructions dominate dynamic instruction stream 
execution time increased conventional architectural limitations cache misses misalignment issues resource stalls btb misses tlb misses branch mis speculations 
effi ciency pentium iii processor slightly higher simplescalar processor benchmarks able issue micro ops equivalent cisc instructions benchmarks simplescalar processor issues instructions cycle 
bench marks scale achieve better efficiency simplescalar ration memory intensive benchmarks cache latency pentium iii processor cycles sim configuration cycle 
measured similar statistics pentium iii simplescalar processor simd extensions 
execution time slower simd enhanced processors efficiency higher non simd processors 
bit simd execution unit counts peak rate computations cycle bit bit data scalar execution unit counts single computation cycle 
true simd enhancements added improve efficiency proc speedup multimedia programs characterization highlights gap peak computation rate achieved computation rate simd programs points ample opportunities performance improvement 
memory access branch bottlenecks supporting wide issue processors requires ability fetch multiple branches 
memory latency prevents processors fetching data timely fashion achieve peak throughput 
section investigate memory latency branch prediction impact performance media kernels applications 
table shows ipc unit cycle memory ac cess perfect cache perfect branch prediction way processors simd extensions 
seen different programs vary sensitivity memory la tency branch prediction 
scale benchmarks memory bound programs improve significantly due unit cycle memory access show negligible increase ipc due perfect branch prediction 
cfa dct mot benchmarks operate sub blocks structure requiring levels loop nesting benefit perfect branch prediction ability fetch multiple branches single cycle 
unit cycle memory access negligible performance impact benchmarks 
remaining benchmarks aud jpeg ijpeg decrypt benefit equally fect branch prediction unit cycle memory access 
evident experiment extremely important pro vide low latency memory access excellent branch prediction extending multiple branches order achieve performance 
table 
performance ipc unit cycle memory accesses perfect branch prediction cfa dct mot scale aud jpeg ijpeg decrypt realistic ipc way way way way ipc unit cycle memory access way way way way ipc perfect branch prediction way way way way summary perceived characteristics media applications stood 
detailed analysis shows features media workloads touted characteristics dlp structured computations 
chapter analyzes multimedia workloads focusing instruc tions support core computations computations 
investigation loop structures access patterns multimedia algorithms significant amount parallelism lies outside innermost loops difficult simd units exploit parallelism 
characteristics preventing simd computation units computing peak rate analyzed 
major findings bottleneck analysis approximately percent instructions dynamic instruction stream media workloads performing useful computations 
performing address generation data rearrangement packing unpacking loop branches loads stores 
efficiency simd computation units low overhead supporting instructions 
measurements pentium iii processor variety media kernels applications illustrate simd efficiency ranging 
increasing number simd execution units impact perform ance positively leading conclude resources head supporting instructions need scaled 
observe significant increase scalar resources required increase simd efficiency conventional ilp techniques 
way way integer processor nec essary process overhead instructions simd width current processors 
chapter hardware support efficient simd processing overhead supporting instructions dominate instruction stream multi media applications due programming conventions gpps 
overhead re lated instructions need eliminated alleviated overlapped useful computations better performance higher overlap head related instructions higher simd efficiency 
chapter ex observed characteristics media programs propose augment simd gpps specialized hardware efficiently overlap head supporting instructions 
simd instructions reduce dynamic count instructions operate multiple data single instruction 
due repetitive operations required media applications technique reduces number instruc tion fetches decodes 
simd instructions capture useful computation operation 
chapter showed overhead supporting instruc tions necessary feeding simd execution units constitute dynamic instructions 
similar computation operations parallelism exists head supporting instructions 
gpps limited support ing addresses keeping track multiple loop nests bounds 
chapter architecture incorporates explicit hardware support efficiently executing overhead supporting instructions simd gpp 
addition capturing useful computation operations associated overhead opera tions captured single multidimensional vector instruction 
leads drastic reduction dynamic instructions reduces repeated sary fetch decode instructions 
rest chapter organized follows 
section describes proposed architecture 
section presents performance evaluation 
chapter summarized section 
mediabreeze architecture decoupling computation overhead exploit characteristics media applications observed chapter proposing mediabreeze architecture 
specialized hardware rated simd gpp efficiently overlap overhead supporting instructions 
shows block diagram mediabreeze architecture 
cache cache main memory load store units hardware looping address generation units data reorganization address transformation instruction stream instruction decoder starting breeze instruction simd pipeline overhead breeze instruction memory breeze instruction interpreter order perform simd operations mediabreeze architecture introduces new hardware units reuses existing hardware units 
new hardware units shaded blocks address genera tion units hardware looping breeze instruction memory interpreter 
hardware units reused lightly shaded blocks load store units normal superscalar execution data station os non simd pipeline 

mediabreeze architecture new hardware existing hardware differently useful computations simd computation unit input stream os output stream simd computation unit data reorganization address transformation data station 
simd computation unit handles useful computation part remaining units handle overhead supporting instructions 
hardware units process overhead related instructions address calculation address arithmetic functions moved execu tion unit subsystem current processors dedicated hardware unit address arithmetic hardware generates input output address streams concurrently simd computations 
address calculations formed explicitly cpu current ilp processors 
involves combination extra instructions parts instructions registers memory accesses computation time 
dedicated address arithmetic hardware allow simd computation unit stream peak rate 
address transformation algorithms logical access sequence data vastly different physical storage pattern 
various permute operations including pack unpack instructions 
example element columns matrix packed single row simd register 
similarly single element bits wide un packed sub words simd register bits wide 
efficiently handles task reordering data explicit hard ware support 
loads stores load store units conventional ilp processors purpose 
branch processing eliminate branch instruction overhead mediabreeze employs zero overhead branch processing dedicated hardware loop control supports levels loop nesting 
branches related loop increments indices referencing data handled technique 
done conventional dsp processors motorola tms texas instruments data station register file simd computation im plemented queue 
dedicated register files conventional machines simd separate register file altivec aliased floating point register file mmx 
breeze instruction memory interpreter order program control hardware units mediabreeze architecture special instruction called breeze instruction formulated 
breeze instruction memory stores instructions enter processor 
illustrates structure breeze instruction 
dsp processors tms xx eliminated hardware looping allows smaller simpler instruction sets 
multiple loops encoded single bit instruction 
loop count loop count loop count loop count loop count starting address loop index counts bounds indicated breeze instruction support level nested loops hardware 
benchmarks required nested loops 
mediabreeze architecture allows input data structures streams produces output structure 
chosen media algorithms benefit capability current simd execution units operate input registers produce output value 
example adaptive filtering algorithms input streams generate output stream 
similarly certain signals complex valued re third input stream 
application third input stream third input prefetching second input stream 
starting address starting address starting address os opr shift ll stride stride stride stride stride stride stride stride stride stride stride stride stride stride stride stride os stride os stride os stride os stride os masks masks multicast data types stream os remaining bits unused bits 

structure breeze instruction legend input stream os output stream opr operation code reduction operation ll loop level write results data structure stream dedicated address generation unit compute address clock cycle base address specified breeze instruction 
due sub block access pattern media programs data accessed different strides various points algorithm 
breeze instruction facilitates multiple strides level loop nesting total strides input streams output stream 
strides indicate address increment decrement values loop nest level 
depending mask values stream indicated breeze instruction loop nest level possible strides update address pointer 
application need levels nesting non constant strides generated extra levels looping 
data types stream structure indicated breeze struction 
depending size element data structures differ ent amount simd parallelism achieved 
data stream bit data way parallelism bit wide execution unit bit data way parallelism simd processing achieves way parallelism 
maximum achievable simd parallelism minimum data struc tures commercial simd extensions limitation 
current simd ex tensions provide data reorganization instructions packing unpacking permute solving problem having different element sizes data structures introduce additional instruction overhead 
providing information breeze instruction special hardware mediabreeze perform function 
reduction operations performed indicated breeze instruction 
example multiple independent results single simd register combined dot product require additional instructions current dlp techniques 
sup port signed unsigned arithmetic saturation shifting scaling final results indicated breeze instruction 
eliminates additional instructions needed conventional risc processors 
support multiple levels looping multiple strides breeze instruction complex instruction decoding instruction complex process current risc processors 
mediabreeze handles task interpreting decoding breeze instruction 
mediabreeze instruction memory hold breeze instruction 
additional bit instruc tions added isa general purpose processor starting interrupting mediabreeze 
bit instructions fetched decoded traditional instruction issue logic contain length breeze struction 
breeze instruction encountered dynamic instruc tion stream dynamic instructions prior breeze instruction allowed finish mediabreeze instruction interpreter decodes breeze instruction 
current implementation superscalar pipeline halted execution breeze instruction completed mediabreeze re uses existing hardware units 
arbitration resources necessary allow overlap breeze instruction superscalar instructions 
cycle penalty conservative estimate simulation associated detection start breeze instruction simulations 
encoding overhead supporting operations simd useful computation instructions advantage breeze instruction potentially replace millions dynamic risc instructions fetched decoded issued cycle normal superscalar processor 
results giving mediabreeze architecture advantages similar asic acceleration 
possible exception interrupt occurs breeze instruc tion progress 
state loops current counts loop bounds saved restored instruction returns 
similar handling exceptions move instructions rep repeat prefix 
mediabreeze registers hold loop parameters loops 
code development mediabreeze architecture currently done hand 
similar developing code simd extensions compiler intrinsics may employed utilize mediabreeze architecture 
underestimate chal compiling mediabreeze architecture effort comparable compiling current simd extensions 
multicast technique aid data transformation mediabreeze uses technique called multicast eliminate need transposing data structures allow reordering computations crease reuse data items soon fetch 
multicasting means copying data items registers buffers item 
ex ample data value may copied registers sections big simd register resulting pattern items may copied registers pattern pattern 
usefulness multicasting illustrated understood matrix multiply routine 
matrix multiply routine usually matrix traversed row order second matrix column order 
spatial locality exploited matrix due mul tiple data elements cache block second matrix incurs com column time assuming consecutive rows fit cache block 
machine simd execution units iteration second matrix new cache line loaded data belongs column different cache line 
case simd processing multiple cache lines need loaded data belonging required column needs reorganized vertical horizontal di packing 
involves substantial overhead usually second matrix transposed prior computation eliminate column access pattern 
transposing overhead eliminated multicast tech nique 
column access pattern row order access pattern matrix matrix single element multicast sub element locations simd register 
doing multi plications generate element result matrix multi plications partial product result terms row performed 
sequence multiplications normal simd matrix multiply multicast matrix multiply illustrated 
multiplications result terms row re sult matrix simultaneously generated 
algorithm multicast technique operating multiple independent output values tra ditional techniques compute result term time 
eliminates need transposing second matrix 
increases reuse items loaded improving cache behavior code 
mediabreeze archi tecture provides hardware support multicasting 
allows cache friendly algorithms perform media algorithms 
example broad cast multicast employed element transmitted registers 
applications horizontal vertical downsampling upsampling filtering elements multicast bits wide bits wide simd matrix multiply multicast matrix multiply add partial results get add partial results get bits wide bits wide sub element locations mapping opposed mapping name multicast 
dimension matrices multiplied large multi cast method needs temporary registers accumulator store lated results 
multimedia applications operate sub blocks huge matrices opposed processing entire matrix 
simd paral quite adequate capture media sub block matrices 
bits wide acc acc acc acc acc acc acc acc bits wide bits wide acc acc acc acc acc acc acc acc bits wide 

multicast technique versus traditional simd matrix multiply common operation multicast extremely useful filtering convolution 
example mmx implementing finite impulse response fir filter multiple copies filter coefficients needed equal simd parallelism reduce considerable overhead due misalignment coefficient data 
multicasting eliminates need data due misalignment issues 
fact mediabreeze architecture hardware handling misalignment issues multicasting 
example encoding breeze instruction breeze instruction densely encoded instruction media algorithms processed just breeze instructions 
common kernels dct color space conversion motion estimation filtering mapped breeze instructions 
figures show pseudo code implementation breeze instruction 
illus breeze instruction mapping dct routine assuming way simd bit data 
dct routine possi ble loop nests needed loop boundaries indicated breeze struction 
starting address stream represented starting ad dress arrays 
third input stream algorithm 
value strides computed loop indices value address pointer previous cycle 
address pointer updated clock cycle choosing stride depending nesting level loops 
scenario loop nests data streams processed mediabreeze executes hardware equivalent number dy namic software instructions conventional ilp processors cycle branches loads store address value generation stream address genera tion representing multiple risc instructions simd operation way way parallelism depending data element size accumulation simd result simd reduction operation simd data reorganization pack unpack permute operations shifting saturation simd results looping loop count loop count loop count loop count loop count 

pseudo code implementation mediabreeze unit hardware looping start address start address start address os start address os increment address level mask level stride level mask level stride level mask level stride level mask os level os stride os level 

pseudo code implementation mediabreeze unit address generation load load load store os loop count increment address elseif loop count increment address elseif loop count increment address elseif loop count increment address increment address 

pseudo code implementation mediabreeze unit loads stores simd data reorganization simd compute operation simd data reorganization 

pseudo code implementation mediabreeze unit simd computation data reorganization dct image dct coef output temp simd vector way simd parallelism innermost loop folds iteration required starting address image temp simd vector multicast dct coef image output temp simd vector bits starting address dct coeff starting address output opr mac shift bits ll bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes os multicast dct coefficients data types stream set bit data 

breeze instruction mapping dct performance evaluation measure impact mediabreeze architecture pisa version simplescalar sim modified simulate breeze instructions instruction annotations 
simd execution unit configurations pentium iii processor bit simd alus bit simd multi 
memory system mediabreeze architecture modi fied allow cache stalls memory conflicts simd pipeline stalls event cache mediabreeze operates order fashion 
mediabreeze hardware incorporated way way simd gpp 
shows speedup obtained benchmarks mediabreeze architecture way processor baseline 
speedup way mediabreeze architecture way simd enhanced processor ranges 
bench marks cfa dct mot scale kernels benchmark code trans breeze instructions superscalar instructions necessary 
remaining benchmarks aud jpeg ijpeg decrypt applications require scalar superscalar instructions breeze instructions 
decrypt applications amount simd instructions superscalar pipeline accounts bulk execu tion time mediabreeze pipeline 
applications way speedup ay simd ay mb ay simd ay mb cfa dct scale aud jpeg ijpeg decrypt 

performance mediabreeze mb versus simd mediabreeze architecture slightly faster way simd processor 
hand remaining benchmarks aud jpeg ijpeg way mediabreeze architecture significantly faster way simd proc 
table shows speedup simd efficiency achieved way way mediabreeze enhanced processors way superscalar order simd processors 
simd efficiency jpeg ijpeg decrypt computed initialization file routine source code benchmarks 
table 
speedup mediabreeze architecture simd efficiency 
way simd gpp baseline 
way simd way mb way simd way mb way simd way simd cfa dct mot scale aud jpeg ijpeg decrypt mediabreeze pipeline susceptible memory latencies operates order 
mediabreeze unable achieve maximum simd effi ciency kernels cfa dct scale spite mapped completely breeze instructions 
reduce impact memory latencies mediabreeze architecture prefetch engine intro duced load data cache 
access pattern data stream known advance strides prefetch engine load data going 
regularity media access patterns prevents risk superfluous fetch commonly encountered prefetching environments 
prefetch engine slips ahead loads computation computation gather data cache 
ta ble shows speedup mediabreeze architecture prefetching way way configurations 
observed prefetching architecture achieves unit cycle memory access performance breeze instruction portion program 
speedup noticeable cfa dct scale aud 
table shows percentage reduction dynamic instructions mediabreeze architecture 
leads significant reduction fetch decode issue logic power consumption gpp 
instruction fetch issue logic expected consume greater total execution power including clock power speculative processors 
implementa tion cost adding mediabreeze hardware simd gpp evalu ated chapter 
geometric mean speedup way mediabreeze processor way simd processor applications including kernels cfa dct mot scale way simd processor way simd processor 
applications way architecture achieves performance slightly better way su simd processor 
similar trend observed case way mediabreeze processor slightly superior way superscalar simd processor 
way way mb prefetching way way mb prefetching table 
speedup mediabreeze architecture prefetching cfa dct mot scale aud jpeg ijpeg decrypt table 
percentage reduction dynamic instruction count mediabreeze architecture comparison conventional risc isa simd extensions cfa dct mot scale aud jpeg ijpeg decrypt mb summary enhancements increasing number simd execution units target exploiting additional parallelism useful computation architecture proposed chapter focuses overhead instruc tions ability hardware eliminate alleviate overlap overhead 
mediabreeze exploits regularity predictability overhead instructions devise simple hardware combining advantages simd vector dae dsp processors 
major findings eliminating reducing overhead specialized hardware works conjunction state art superscalar processor simd extensions dramatically improve performance media workloads deteriorating performance general purpose workloads 
kernels way processor simd extensions augmented hardware significantly outperforms way processor simd extensions 
applications way processor simd extensions support ing mediabreeze hardware outperforms way superscalar processor simd extensions 
similarly way processor simd extensions added mediabreeze hardware superior way superscalar simd extensions 
chapter hardware cost mediabreeze architecture adding hardware support execute overhead supporting instructions creases computation throughput simd execution units 
chapter simd execution units gpp utilized bottlenecks concealed overhead supporting instructions 
special ized hardware overlap overhead related instructions useful com putation instructions allows simd execution units achieve higher throughput 
mediabreeze architecture chapter incorporates explicit hardware support efficient looping address generation process overhead supporting instructions 
way simd gpp enhanced mediabreeze architecture outperforms way simd gpp multimedia ap plications 
similarly way simd gpp augmented mediabreeze hardware superior way simd gpp 
chapter investigates associated cost adding mediabreeze units high speed simd gpp 
cell methodology targeting micron asic library esti mate area power timing requirements added hardware 
table summarizes hardware units divided parts neces sary implementing mediabreeze components order gpp 
entries address generation looping breeze instruction decoder breeze instruction memory relate hardware units augmented simd gpp 
remaining entries simd computation unit data zation unit load store units data station relate hardware units existent current commodity simd gpps 
chapter evaluate cost adding hardware units current simd gpps 
table 
hardware functionality various mediabreeze hardware units new hardware units functionality address generation looping breeze instruction decoder breeze instruction memory address generation moved execution unit subsystem address generation units added gpp core data stream 
levels nesting allows capturing parallelism outer loops 
dedicated hardware looping allows zero overhead loop branch processing 
breeze instruction introduced capture overhead supporting instructions core simd computation instructions 
mediabreeze handles task decoding breeze instruction controlling various hardware units 
breeze instruction memory stores breeze instruction enters processor 
table 
hardware functionality various mediabreeze hardware units continued existing hardware units functionality simd computation unit data reorganization load store units data station arithmetic logical simd computations multiplication special media operations absolute differences executed unit 
current gpps typically simd alus simd multiplier simd datapath 
simd processing mandates data reorganization mechanisms packing unpacking permute reduction operations scaling shifting results required simd processing 
current commodity simd gpps data reorganization hardware simd datapath 
load store units gpp mediabreeze architecture 
data station acts register file simd computation 
current simd gpps dedicated simd register files altivec share floating point register file mmx 
rest chapter organized follows 
section describes implementation methodology tools estimate hardware cost 
section detailed implementation new mediabreeze hard ware units 
section evaluates cost associated imple mechanism mediabreeze architecture applicability mainstream commodity gpp pipelines 
section summarizes chapter 
implementation methodology estimate area power timing requirements mediabreeze archi tecture developed vhdl models various components 
synopsys synthesis tools cell methodology target vhdl mod els micron asic cell library lsi logic 
technology library operates supports layers metal 
synopsys synthesis tools estimate area power timing circuits asic technology library 
asic technology library provides kinds information 
structural information 
describes cell connectivity outside world including cell bus pin descriptions 
functional information 
describes logical function output pin cell synthesis tool map logic design actual asic technology 
timing information 
describes parameters pin pin timing rela tionships delay calculation cell library 
environmental information 
describes manufacturing process oper ating temperature supply voltage variations design layout 
design layout includes wire load models estimate effect wire length design performance 
wire load modeling estimates effect wire length fanout resistance capacitance area nets 
default wire load models provided lsi logic tech nology 
synopsys synthesis tools compute timing information cells design corresponding parameters defined asic tech nology library 
area information provided synthesis tools prior layout computed wire load models associated cells design 
average power consumption measured switching ac tivity nets design 
experiments switching activity factor originates rtl models tool gathers information simu lation 
area power timing estimates obtained performing maximum optimizations performance synthesis tools 
results ob tained chapter reflect order approximation accuracy synthesis tools cell libraries 
interested reader referred information regarding capabilities limitations syn thesis tools 
hardware implementation mediabreeze units address generation mediabreeze architecture supports input output data struc tures streams 
data streams dedicated address generation hardware unit 
address arithmetic stream performed strides mask values indicated breeze instruction 
clock cy cle depending mask bits loop index counts possible strides selected 
new address value computed se lected stride previous address value 
depicts block dia gram address generation circuitry single data stream structure 
val comparators determine inner level loop counters reached upper bound 
outermost loop comparison necessary breeze instruction finishes execution instant outermost loop counter reaches upper bound 
cond combine blocks generate flag signals output val com mask values breeze instruction 
flag signals true stride update prev address appro priate stride selected depending flag 
address generate block uses bit adder add selected stride previous address 
exception stall prev address value needs stored combine loop counters stored hardware looping circuitry 
data structures streams val comparators portion logic shared remaining hardware needs replicated 
looping loop count val comparators mask mask mask mask cond cond cond cond stride prev address combine combine combine flag flag flag flag address generate mediabreeze architecture incorporates levels loop nesting hard ware eliminate branch instruction overhead loop increments 
similar updated address 

block diagram address generation hardware data stream mechanism commercially implemented ti asc levels loop nesting addition self increment loop 
conventional dsp proces sors motorola tms ti technique levels loop nesting 
shows block diagram looping hardware 
loop index values produced clock cycle loop bound level nesting bounds loops specified breeze instruction 
value loop index varies lower bound corresponding loop bound upper bound resets lower bound upper bound reached previous cycle 
execution breeze instruction ends outermost loop loop 
reaches upper bound 
encountering exception stall loop indices stored increment logic halted counting process loop count loop count loop count loop count loop count index index index index index comparator comparator comparator comparator comparator flag flag flag flag flag loops increment index increment index priority encoder incl incl incl incl increment index increment index increment index index index index index index 

block diagram hardware loops started exception stall serviced 
comparators bit wide operates parallel generate flag bit wide signals priority encoded determine loop counters increment 
loop counter incremented circuit incrementing bit value loop counters belonging inner level reset example loop incremented loop loop reset lower bound 
breeze instruction decoder stand instruction decoder breeze instructions eliminates need modify conventional instruction decoder current gpps 
breeze struction needs decoded various control parameters stored hardware registers decoding process 
implementation breeze instruction decoder merged address generation loop ing circuitry 
breeze instruction memory breeze instruction memory stores breeze instruction enters processor 
estimate cost storage asic li targeted memory cells 
area power timing estimates breeze instruction memory similar sram structure 
size breeze instruction typically bytes 
existing hardware units remaining hardware units required operation architecture simd computation unit data reorganization load store units data station 
hardware units commodity simd gpps 
breeze instruction decoder controls operation units opposed conventional control path 
man dates extra multiplexer differentiate control conventional control path breeze instruction decoder 
model exist ing hardware units 
area power timing results table shows composite estimates area power timing ad dress generation looping circuitry implemented asic cell methodology described section 
results breeze instruc tion decoder merged address generation looping hardware 
power area estimates table correspond clock frequency ghz 
table 
area power timing estimates mediabreeze units asic technology address generation stream looping levels area mm power mw timing ns mw ns area mm area mm power mw power mw timing ns mw ns area chip area required implementing address generation streams looping breeze instruction decoder approximately mm table shows hardware area cost commercial simd gpp implementations comparison 
micron process increase chip area implementing vis hardware sparc processor family mm mmx pentium family mm altivec powerpc family mm 
micron process altivec hard ware expected occupy mm 
micron technology die size pentium iii processor mm mmx sse execution units requiring approximately mm 
increase area due mediabreeze units simd related hardware increase chip area 
table 
area commercial simd gpp implementations vis mm micron process mmx mm micron process altivec mm micron process pentium iii processor mm micron process mmx sse pentium iii processor mm micron process power power consumed address generation looping breeze instruction decoder approximately mw ghz 
gpps speeds ghz range typically consume power ranging 
increase power consumption due added hardware processor power 
energy consumption mediabreeze architecture simd gpp breeze instruction reduces total dynamic instruction count media applications including kernels 
breeze instruction densely encoded breeze instructions needed media processing algorithm 
number dynamic instructions need fetched decoded reduces tremendously leads minimal instruction fetch decode issue logic superscalar processor 
instruc tion fetch issue logic expected consume greater total execution power including clock power speculative processors 
breeze instruction decoded fetch decode issue logic superscalar processor shutdown save power 
timing pipelining hardware looping logic stages allow incorporating current high speed superscalar order processors ghz clock frequency 
similarly address generation stage needs divided pipe stages achieve frequencies greater ghz 
timing results show incorporating mediabreeze hardware high speed processor critical path processor pipe lining 
breeze instruction decoder multiplexers control hardware units introduce extra gate delay pipeline 
cell methodology gives conservative estimate custom design typically commercial general purpose processors allow greater clock fre added mediabreeze hardware 
spite adding pipeline stages pipeline depth processor affected loop ing address generation stages bypass conventional fetch decode sue pipeline stages 
estimates area power timing different technologies optimizations described appendix summary chapter estimated cost incorporating explicit hardware support simd gpp execute supporting instructions 
asic cell methodology targeting micron technology obtained area power timing information mediabreeze architecture components 
ma jor findings chapter area cost simd execution unit area mmx sse 
compared processor chip area crease 
power consumption added units total processor power 
mediabreeze hardware units increase effective pipeline depth high speed gpp 
appropriate pipelining simd regions simd gpp mediabreeze hardware operated ghz micron technology 
expect energy consumption potentially lower ing mediabreeze augmented processor breeze instruction ily encoded encompasses multiple operations 
power consumption de due reduced traditional instruction fetch decode issue logic duration breeze instruction execution 
chapter certain workloads dominant gpp architectures added hardware support execute efficiently 
simd extensions integrated processor gpp vendors accelerate multimedia applications 
dissertation show simd support extract parallelism multimedia applications 
providing explicit hardware support assist simd computations way bridge existing performance gap realistic versus ideal utilization simd execution units 
major findings dissertation summarized 
comprehensive study execution characteristics commercial mul applications revealed contrary popular belief data caches effective multimedia programs 
multimedia bench marks achieve data cache hit rate kb way global hit rate kb way 
compared spec benchmarks data cache performance superior multimedia ap plications 
major finding study multimedia appli cations higher branch misprediction ratio spec benchmarks 
analysis bottlenecks execution multimedia programs simd gpps revealed mismatch requirements multimedia applications capabilities simd gpps 
simd gpps exploit dlp inner loops significant dlp exists outer level nested loops media applications 
experiments simd gpps revealed majority dynamic instruction stream multimedia applications performing useful computations merely supporting computa tions 
dynamic instructions sup porting useful computations performing address generation ad dress transformation loop branches loads stores 
measuring utilization simd execution units revealed vastly underutilized 
experiments simd gpps variety dia kernels applications illustrate simd efficiency ranging 
scalability tests simd gpps revealed increasing number simd execution units improve performance 
observed significant increase scalar resources required increase tion simd execution units conventional ilp techniques 
providing explicit hardware support works conjunction state art simd gpp eliminating reducing overhead dramatically accelerates media workloads deteriorating formance general purpose workloads 
breeze instruction capture useful supporting instructions ously 
breeze instruction similar multidimensional vector 
way simd gpp augmented hardware support significantly outperforms conventional way simd gpp multimedia kernels 
media applications way simd gpp enhanced mediabreeze hardware support su way conventional simd gpp 
cost adding mediabreeze hardware simd gpp compared performance improvements 
mediabreeze hardware units occupy proc chip area consumes total processor power increase effective pipeline depth high speed gpp 
summary simd extensions accelerate media applications sev eral bottlenecks exist simd gpps prevent higher performance im 
dissertation propose cost effective solution address supporting instructions focusing simd computations 
media processor designer decides exploit parallelism just scaling current architectures scale non simd part aggressively simd part 
opportunities im proving media application performance gpps involves improving compiler abilities extract dlp ilp media applications 
appendix performance monitoring events microarchitecture table lists microarchitecture counter performance measures 
complete list performance events measured count ers interested reader referred 
table microarchitecture counters performance measures performance measure numerator event denominator event data instruction data mem refs inst retired dcache misses instruction dcu lines inst retired icache misses instruction inst retired itlb misses instruction itlb inst retired cycles instruction ifu mem stall inst retired cache misses instruction inst retired cache misses instruction lines inst retired ratio lines memory transactions instruction bus tran mem inst retired flops instruction flops inst retired instruction retired inst retired speculative execution factor inst decoded inst retired branch frequency br inst retired inst retired branch mispredict ratio br pred retired br inst retired branch taken ratio br taken retired br inst retired btb ratio btb misses br inst decoded branch speculation factor br inst decoded br inst retired resource stalls instruction resource stalls inst retired cycles instruction cpu clk inst retired appendix hardware cost mediabreeze architecture different asic technologies table lists different cell libraries evaluating area power timing tradeoffs mediabreeze hardware 
technology discussed chapter included appendix 
table 
list cell libraries synthesis mediabreeze hardware units library name description micron drawn micron effective cmos process 
highest performance solution high drive cells optimized long interconnects associated large designs 
micron drawn micron effective cmos process 
optimized performance density power applications micron drawn micron effective cmos process 
ultra low power high density solution low dynamic standby leakage current micron drawn micron effective cmos process 
highest performance solution micron drawn micron effective cmos process 
ultra low power cost sensitive solution micron drawn micron effective cmos process 
optimized high performance table shows composite estimates timing area power tion hardware looping address generation circuitry imple mented cell methodology 
power area estimates ta ble correspond clock frequency ghz 
power consumption mhz corresponding slowest technology circuit shown pa 
table timing area power estimates different technologies time ns hardware looping loops area ns ns ns power mw mw mw mw mw mw mw mw ns mw mw ns mw ns mw mw time ns address generation stream area ns ns ns power mw mw mw mw mw mw mw mw ns mw ns ns mw mw mw mw shows percentage interconnect area mediabreeze hard ware 
shows power consumption split cell internal power net switching power 
area interconnect dynamic power loop add 
gen 

percentage interconnect area area cell internal power net switching power hardware looping address generation 

breakdown dynamic power cell internal power net switching power bibliography allen custom circuit design driver microprocessor performance ibm journal research development vol 
nov 
available www research ibm com journal rd allen html amd dnow 
website 
available www amd com products cpg dnow index html 
analog devices jpeg processor 
available www analog com pdf preview adv jp pra gif vector microprocessors ph thesis computer science division university california berkeley may 
austin sohi tetra evaluation serial program performance fine grain parallel processors technical report university wisconsin dynamic dependency analysis ordinary programs proc 
th int 
sym 
computer architecture pp 
may 
barnes feedback directed data cache optimizations proc 
nd acm workshop feedback directed optimization fdo conjunction nd int 
sym 
microarchitecture nov 
lee donnell map vliw ieee micro 
vol 
pp 
mar apr 
specification coprocessor efficient access data structures proc 
hawaii int 
conf 
system sciences pp 
jan 
ding performance characterization pentium pro processor proc 
high performance computer architecture pp 
feb 
bhargava john evans radhakrishnan evaluating mmx technology dsp multimedia applications proc 
ieee acm sym 
microarchitecture pp 
dec 
bier independent dsp benchmarking methodologies latest results proc 
int 
conf 
signal processing applications technology sep 
gutman julier keith complete guide mmx technology mcgraw hill 
measure dsp execution speed 
white berkeley design technology available www com articles htm 
microprocessors outperform dsps microprocessor report vol 
pp 
dec 
burger austin simplescalar tool set version 
technical report univ wisconsin madison comp 
sci 
dept 
cube products 
available www cube com products cfm chang dally carter lee effects explicitly parallel mechanisms multi alu processor cluster pipeline proc 
ieee conf 
computer design pp 
oct 
chen baer performance study software hardware data prefetching schemes proc 
ieee acm sym 
computer architecture pp 
apr 
chen reekie lee native signal processing ultrasparc ptolemy environment proc 
ieee asilomar conf 
signals systems computers pp 
nov 
conte jennings lee peleg schlansker song wolfe challenges combining general purpose multimedia processors ieee computer magazine vol 
pp 
dec 
exploiting new level dlp multimedia applications proc 
ieee acm sym 
microarchitecture pp 
nov 
efficiency reductions micro simd media extensions proc 
int 
conf 
parallel architectures compilation techniques sep appear 
watson ti advanced scientific computer ieee computer magazine pp 
jan 
crowley baer trace sampling desktop applications windows nt workshop workload characterization held conjunction micro nov 
appears workload characterization methodology case studies edited john maynard ieee computer society press 
exploiting cache multimedia proc 
ieee int 
conf 
multimedia computing systems pp 
vol 
jun 
multimedia workloads change processor design ieee computer magazine vol 
pp 
sep 
scales altivec extension powerpc accelerates media processing ieee micro vol 
pp 
mar apr 
edn embedded microprocessor benchmark consortium available www org 
algorithms real time dsp nj prentice hall 
fisher latest word digital media processing ieee signal processing magazine vol 
pp 
mar 
flynn high speed computing systems proc 
ieee vol 
pp 
fridman dsp architecture ieee micro vol 
pp 
jan feb 
wolf dynamic parallel media processing speculative broadcast loop proc 
workshop parallel distributed computing image processing video processing multimedia held conjunction ipdps apr 
architecture compiler design issues programmable media processors ph thesis dept electrical engineering princeton university 
goldstein schmit moe taylor laufer piperench coprocessor streaming multimedia acceleration proc 
ieee acm sym 
computer architecture pp 
may 
goodman hsieh liou schechter young pipe vlsi decoupled architecture proc 
ieee sym 
computer architecture pp 
jun 
gonzalez horowitz energy dissipation general purpose microprocessors ieee journal solid state circuits vol 
pp 
sep 
intel mmx speeds multimedia microprocessor report vol 

altivec powerpc microprocessor report vol 
may 
gyllenhaal hwu rau impact technical report impact university illinois urbana il mar 
hansson reducing power risc dsp core electronic engineering times aug 
available www com story oeg 
hughes adve jain park srinivasan variability execution multimedia applications implications architecture proc 
ieee acm sym 
computer architecture pp 
jul 
john design vlsi implementation address generation coprocessor iee proc 
computers digital techniques vol 
pp 
mar 
intel performance library suite 
available developer intel com software products index htm 
intel literature architecture developer manuals 
available developer intel com design processor 
intel architecture optimization manual 
available developer intel com design manuals htm 
intel xscale microarchitecture 
available developer intel com design htm 
jouppi wall available instruction level parallelism superscalar machines proc 
int 
sym 
architectural support programming languages operating systems pp 
apr 
jouppi improving direct mapped cache performance addition small fully associative cache prefetch buffers proc 
ieee sym 
computer architecture pp 
may 
vassiliadis implementation evaluation complex streamed instruction set proc 
int 
conf 
parallel architectures compilation techniques sep appear 
parameter value characterization windows nt applications workshop workload characterization held conjunction micro nov 
appears workload characterization methodology case studies edited john maynard ieee computer society press 
dally mattson owens efficient conditional operations data parallel architectures proc 
ieee acm sym 
microarchitecture pp 
dec 
kohn maturana tremblay prabhu visual instruction set vis ultrasparc compcon digest papers pp 
mar 
patterson new direction computer architecture research ieee computer magazine vol 
pp 
nov 
kuck stokes burroughs scientific processor bsp ieee trans 
computers vol 
pp 

ide sato endo murakami oka okada vector unit architecture emotion synthesis ieee micro vol 
pp 
mar apr 
lapsley bier shoham lee 
dsp processor fundamentals architectures features chapter ieee press series signal processing isbn 
performance analysis intel mmx technology video encoder proc 
acm int 
conf 
multimedia pp 
sep 
lee potkonjak smith mediabench tool evaluating synthesizing multimedia communications systems proc 
ieee acm sym 
microarchitecture pp 
dec 
lee simple vector microprocessors multimedia applications proc 
ieee acm sym 
microarchitecture pp 
dec 
lee crowley baer anderson bershad execution characteristics desktop applications windows nt proc 
ieee int 
sym 
computer architecture pp 
jun 
lee multimedia extensions general purpose processors proc 
ieee workshop signal processing systems pp 
nov 
liao wolfe available parallelism video applications proc 
ieee acm int 
sym 
microarchitecture pp 
dec 
lsi logic asic technologies 
available online www com products asic technologies index html lsi logic documentation system 
mckee maximizing memory bandwidth streamed computations ph thesis school engineering applied science university virginia may 
media processors software driven multimedia white research available www com html media processors target digital video roles 
edn magazine sep 
available www com reg df htm microprocessor architecture java computing sun microsystems 
available www sun com microelectronics documentation docs pdf motorola altivec technology available www mot com sps powerpc altivec index html 
nguyen john exploiting simd parallelism dsp multimedia algorithms altivec technology proc 
acm int 
conf 
supercomputing pp 
jun 
palacharla kessler evaluating stream buffers secondary cache replacement proc 
ieee int 
sym 
computer architecture pp 
apr 
peleg weiser mmx technology extension intel architecture ieee micro vol 
pp 
aug 
pentium iii implementation ia 
available www sandpile org impl htm 
davidson structured memory access architecture proc 
ieee int 
conf 
parallel processing pp 
aug 
adding vector unit superscalar processor proc 
acm int 
conf 
supercomputing pp 
jun 
radhakrishnan characterizing behavior windows nt web server workloads processor performance counters workshop workload characterization held conjunction micro nov 
appears workload characterization methodology case studies edited john maynard ieee computer society press 
ranganathan adve jouppi performance image video processing general purpose processors media isa extensions proc 
ieee acm sym 
computer architecture pp 
may 
ranganathan adve jouppi reconfigurable caches application media processing proc 
th ieee acm sym 
computer architecture pp 
jun 
vissers la hei cpu application domain benchmark suite proc 
int 
conf 
computer design pp 
oct 
dally lopez mattson owens bandwidth efficient architecture media processing proc 
ieee acm sym 
microarchitecture pp 
dec 
dally mattson owens memory access scheduling proc 
ieee acm sym 
computer architecture pp 
jun 
memory behavior spec benchmark suite ibm research report oct 
evaluation different dlp alternatives embedded domain proc 
workshop media processors dsps conjunction micro nov 
architecture programmable digital signal processor ieee trans 
computers vol 
pp 
jan 
version available www uk 
smith cache performance multimedia applications proc 
acm intl 
conf 
supercomputing pp 
jun 
smith decoupled access execute computer architectures acm trans 
computer systems vol 
pp 
nov 
smith weiss pang simulation study decoupled architecture computers ieee trans 
computers vol 
pp 
aug 
xu min hu study memory system performance multimedia applications proc 
acm sigmetrics pp 
jun 
source code benchmarks 
available www com benchmarks speech coding resource 
available www mobile ecs soton ac uk speech codecs 
sriram hung mpeg video decoding tms dsp architecture proc 
ieee asilomar conf 
signals systems comp pp 
pacific grove ca 
synopsys online sold documentation system version 
john evans evaluating signal processing multimedia applications simd vliw superscalar architectures proc 
ieee int 
conf 
computer design pp 
sep 
john execution characteristics multimedia applications pentium ii processor proc 
ieee int 
performance computing communications conference pp 
feb 
john performance evaluation benchmarking native signal processing proc 
european conf 
parallel processing lecture notes computer science pp 
sep 
john quantifying effectiveness mmx native signal processing proc 
ieee mid west symposium circuits systems pp 
aug 
john cost effective hardware acceleration multimedia applications proc 
ieee int 
conf 
computer design sep appear 
texas instruments tms cpu instruction set guide lit 
num 

texas instruments tms benchmarks available www ti com sc docs products dsp bench htm 
texas instruments tms optimizing compiler user guide lit 
num 

texas instruments tms dsp technical brief 
available www ti com sc docs products dsp pdf 
thornton parallel operation control data fall joint computer conference vol 
pp 

van vissers pol tromp van der wolf tel cpu architecture proc 
int 
conf 
computer design pp 
oct 
vassiliadis complex streamed instructions initial evaluation proc 
ieee euromicro conf vol 
pp 
sep 
de man flexible hardware acceleration multimedia oriented microprocessors proc 
ieee acm sym 
microarchitecture pp 
dec 
wilcox manne alpha processors history power issues look cool chips tutorial conjunction ieee acm sym 
microarchitecture nov 
wm 
wolf evaluation wm architecture proc 
ieee acm sym 
computer architecture pp 
may 
ye hauck banerjee chimaera high performance architecture tightly coupled reconfigurable functional unit proc 
ieee acm sym 
computer architecture pp 
jun 
practical low power digital vlsi design kluwer academic publishers 
zhang adams performance modeling code partitioning ds architecture proc 
ieee acm sym 
computer architecture pp 
jun 
martinez meyr dsp oriented benchmarking methodology proc 
int 
conf 
signal proc 
applications technology oct 
zucker architecture arithmetic multimedia enhanced processors ph thesis dept electrical engineering stanford university jun 
vita born india april son dr venkata dr reddy 
completing high school education school india en tered college engineering university india august 
received degree bachelor engineering electronics communication engineering university june 
joined graduate program electrical computer engineering villa nova university pa august obtained degree mas ter science electrical engineering august 
august en tered ph program computer engineering university texas austin 
summers texas instruments dallas working architecture digital cameras 
student member ieee ieee computer society acm acm sigarch 
permanent address nursing home mvp colony india dissertation typed author 

