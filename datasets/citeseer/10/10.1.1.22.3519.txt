axiomatizing reflective logics languages manuel clavel jos meseguer computer science laboratory sri international menlo park ca success breadth reflective techniques underscores need general theory reflection 
wide ranging variety reflective systems explained idiosyncratic terms 
metalogical foundations allow capture essential aspects reflective systems way 
proposes metalogical axioms reflective logics declarative languages theory general logics 
way strands reflection including functional equational horn logic rewriting logic reflective languages variety reflective theorem proving systems placed common theoretical framework 
general axioms computational strategies internalization strategies reflective logic 
reflection fundamental idea 
logic vigorously pursued researchers fundamental godel tarski see surveys 
computer science form universal turing machines 
researchers recognized great importance usefulness programming languages theorem proving concurrent distributed computation areas compilation programming environments operating systems fault tolerance databases see snapshot research reflection 
success extension reflective ideas underscores need conceptual foundations 
need real specific instances reflection explained terms particular concepts available lambda expressions horn clauses objects metaobjects 
general theory reflection capable unifying instances providing general criteria concepts judge extent particular system example interpreter exhibits reflective properties falls short reflective certain respects 
believe metalogical foundations particular logic choice easily changeable parameter useful regard 
reason hope capture precise formalism independent way essential supported office naval research contract national science foundation ccr information technology promotion agency japan part industrial science technology frontier program new models software architecture sponsored new energy industrial technology development organization 
features reflection intuitively appear shared quite disparate languages systems 
step planned longer term effort provide metalogical foundations reflection exactly sense 
strongly conjecture axioms useful reflection general apply cases computational reflection inspection amenable logical specification aim modest 
focus case reflective logics reflective declarative languages 
particular axioms unify quite different strands research reflection including reflective functional equational horn logic rewriting logic programming languages reflective theorem provers different logics 
key concept axiomatic treatment reflective logics notion universal theory theory simulate deductions theories class theories interest 
particular theories class simulate metalevel object level process iterated ad infinitum giving rise reflective tower 
course reflective phenomena admit degrees languages may choose represent certain metalevel aspects interest may weaker stronger ways 
treatment takes form increasingly stronger axiomatizations 
weaker axiomatization universal theory may belong class theories represents full power having reflective tower lost 
degree representational freedom metalevel aspects represented 
weaker axiomatization entailment relation holding axioms theory theorems proves may represented stronger axioms actual proofs theorems object theories may represented 
gradation strength axioms provides formalism independent criteria understand compare degrees reflection exhibited different logics declarative languages corresponding formalisms differ greatly 
declarative foundations propose naturally express structural behavioral aspects computational reflection 
point declarative perspective computation deduction 
deductive mechanisms specified metatheory logical language play role operational semantics machine logical language implemented 
logic reflective sense static structural aspects metatheory example theories dynamic behavioral aspects deductive mechanisms reified 
way logical language deductive engine implementing causally connected 
reflective logic sense naturally gives rise reflective tower possible modify runtime object theories reified metatheory 
metalogical foundations propose concepts theory general logics section 
section presents general axioms reflective logics languages explains satisfied variety declarative languages 
discuss declarative reflection functional equational horn rewriting logic languages explain relationship reflection turing machines 
rewriting logic case appendix explains detail illustrates example reflection achieved 
reflective language particularly powerful strategies computing represented inside language section give general axiomatization strategies discuss specific examples 
ends concluding remarks section 
axioms general logics declarative languages general axiomatic theory logics adequately cover key ingredients logic 
include syntax notion entailment sentence set axioms notion model notion satisfaction sentence model 
flexible axiomatic notion proof calculus proofs entailments just entailments class citizens included 
theory general logics study different ingredients logic interrelations uses general notions obtain general notion declarative language logic 
purposes notions syntax entailment system proof calculus proposed play crucial role 
summarized form axioms characterizing notions declarative language 
axioms language category theory require acquaintance categories basic notions category functor natural transformation 
syntax syntax typically signature sigma providing grammar build sentences 
order logic typical signature consists list function symbols list predicate symbols prescribed number arguments build usual sentences 
allow maximum freedom generality example graphical language representations counts syntax particular style signatures logic may sentences defined relative signature 
assume logic category sign possible signatures functor sen assigning signature sigma set sen sigma sentences 
call pair sign sen syntax entailment systems signature sigma sign entailment called provability sentence sen sigma set axioms gamma sen sigma relation gamma holds prove axioms gamma rules logic 
relation relative signature 
follows jcj denotes collection objects category definition entailment system triple sign sen ffl sign sen syntax ffl function associating sigma jsignj binary relation sigma sen sigma theta sen sigma called sigma entailment properties satisfied 
reflexivity sen sigma sigma 
monotonicity gamma sigma gamma gamma gamma sigma 
transitivity gamma sigma gamma ig sigma gamma sigma 
translation gamma sigma sigma sigma sign sen gamma sigma sen 
definition entailment system category th theories objects pairs sigma gamma sigma signature gamma sen sigma 
theory morphism sigma gamma 
sigma gamma signature morphism sigma sigma gamma gamma sigma sen 
theory morphism sigma gamma gamma 
sigma gamma called axiom preserving satisfies condition sen gamma gamma defines subcategory th objects th morphisms restricted axiom preserving theory morphisms 
note extend functor sen functor theories sen sigma gamma sen sigma 
proof calculi entailment system may admit different proof calculi 
example order logic hilbert style natural deduction sequent calculi way proofs represented generated rules deduction different calculi 
useful proofs relative theory axioms allowed order prove theorems 
proof calculus associates theory structure proofs axioms hypotheses 
structure typically algebraic structure kind obtain new proofs previously proofs operations mirror rules deduction calculus question 
need choice particular types algebraic structures allowed different proof calculi choices simply saying proof calculus category str structures functor th gamma 
str assigning theory structure proofs 
course possible extract underlying set proofs proofs theorems theory extraction functorial 
proof contain information theorem proof formalized postulating projection function parameterized natural way maps proof proofs sentence proves 
course theorem proof sentences theorems proof 
summarize proof calculus consists entailment system ffl functorial assignment structure theory ffl additional functorial assignment set proofs structure 
ffl natural function assigning sentence proof proofs gamma axioms sentence image gamma 
proofs proof theorem express writing decorated entailment 
practice quite common encounter proof calculi specialized nature certain signatures admissible syntax finite signatures certain sentences allowed axioms certain sentences possibly different axioms allowed 
obvious reason introducing specialized calculi proofs efficient restrictions 
computer science choice efficient inefficient calculus may dramatic practical consequences 
logic declarative languages calculi coincide called operational semantics 
mark difference intrinsically inefficient theorem prover efficiently implementable programming language 
considerations lead notion proof just proof calculus appropriate restrictions imposed follows ffl subclass admissible signatures specified ffl admissible signature sigma family sets gamma sen sigma called sets admissible axioms specified ffl admissible signature sigma subset conc sigma sen sigma sentences called admissible specified ffl functorial assignments proofs natural function just proof calculus restricted theories having admissible signature axioms way maps proof admissible admissible proof 
practice course primarily interested proof calculi proof subcalculi computationally effective principle implemented computer 
axiomatized notion effective proof give details 
declarative languages general logic mean declarative language 
propose view program language theory logic 
entering program machine user ask questions program 
questions called queries belong specified class sentences language user submits query case provable consequence axioms machine return set answers justifying truth 
view answers different proofs truth 
query provable things happen machine stops finite amount time answer failure machine loops forever 
things equivalent computation machine deduction logic 
course add pragmatic sense implementation machine reasonably efficient broad class applications language fact practice system better described theorem prover 
definition gives axiomatization terms general logics concepts notion declarative language just stronger notion requiring initial model semantics 
definition allows careful selection signatures finite sets sentences statements program sentences admissible queries 
language required computationally effective operational semantics effective proof 
definition declarative programming language tuple sign stat 
sign sen entailment system 

sign subcategory sign 

stat sign gamma 
set functor obtained composing sen finite powerset functor natural inclusion stat sigma fin sen sigma sigma sign 
gamma stat sigma called set sigma statements program theory sigma gamma sigma sign gamma stat sigma 

sign gamma 
set sen functor 
sentences sigma called sigma queries addition effective proof having underlying entailment system sign category admissible signatures stat axioms 
effective proof assumed unique 
called operational semantics declarative programming language definition encompasses wide range logics languages 
example equational functional horn logic rewriting logic declarative languages multiparadigm combinations satisfy definition requirements 
axiomatizing reflective logics languages reflective logic logic important aspects metatheory represented object level consistent way object level representation correctly simulates relevant metatheoretic aspects 
obvious metatheoretic notions reflected theories entailment relation 
leads notion universal theory 
universality may absolute relative class representable theories 
typically theory representable object level finitary description way say recursively enumerable represented piece language 
definition entailment system set theories theory universal function called representation function ftg theta sen gamma 
sen sen addition entailment system called reflective 
note reflective entailment system representable representation iterated immediately reflective tower key metatheoretic aspect represented object level proof theory 
leads notion reflective proof calculus 
definition proof calculus set theories theory universal function called representation function ftg theta proofs theta sen gamma 
sen proofs sen addition proof calculus called reflective 
notions relative proof set theories contained equal class admissible theories get way notions universal theory relative reflective proof 
entirely similar case expressions restricted range sigma gamma admissible signature sentences belong sentence belong set conc sigma admissible 
addition get corresponding effective notions requiring calculus effective representation map computable 
main advantage reflective proof calculus reflective entailment system proofs represented proof checking expressible ordinary deduction universal theory 
reflective proof calculus reflective tower sentences decorated proofs level proofs sentence representing previous level 
concepts give general definition reflective declarative language 
definition reflective declarative programming language declarative programming language sign stat set programs contains program universal theory computable representation function sending pairs program query query form program sigma gamma query sigma addition operational semantics reflective effective proof representation function universal theory possibly distinct program sigma gamma proof proofs query sigma say reflective operational semantics reflective declarative languages goal definition capture key aspects reflection declarative language logic independent way 
discuss classes languages reflective sense strong evidence suggesting understood 
wide range languages consider details omitted describe sufficient detail universal theory rewriting logic appendix functional languages program finite collection recursive function definitions adequate program transformations combinator see example expressed simple theory signature lambda calculus axioms equations form free variables understood additional constants standing different functions program closed lambda terms standing corresponding definitions 
queries existential formulas form nf lambda term free variables queries entailed substituting corresponding definitions normal form reached normal form reached closed lambda term 
regard witness proof query write nf universal theory program function definition eval program function definitions nf eval nf closed lambda term eval representation function exactly properties defined proved correct mogensen 
case typed functional languages subtle may possible typecheck appropriate eval function type discipline universal theory may exist outside class theories language may necessary consider eval functions bound number rewrites remain language see example careful treatment problem calculus constructions study reflection polymorphic lambda calculus treatment reflection nuprl constructive type theory la martin lof 
promising development general area lambda calculi monads la moggi give semantics reflective languages 
equational languages strong evidence supercompiler related partial evaluation equational programs suggesting equational languages reflective precise axiomatic sense 
careful representation levels terms programs represented terms excellent mathematical properties allows arbitrarily high reflective towers 
supercompiler program transformer written compile away extra levels interpretation support powerful meta programming compilation tasks 
interpreter virtually universal theory computational interpretation favored logical certain language conventions example order equations applied prevent semantic account exclusively equational logic terms appears needed define prove correct universal theories sense equational logic programming 
different approach taken machine evaluating conditional equational programs extended reflective capabilities 
treatment provide universal theory limited reflective power 
horn logic languages long tradition interpreters meta programming prolog see papers collected strongly suggesting declarative variant prolog reflective axiomatic sense 
vanilla interpreters literature example fall short universal theory lack adequate semantics 
systematic effort carefully represent metalevel concepts give declarative semantics horn logic interpreters typed version logic undertaken hill lloyd theoretical basis godel language 
interpreter properties similar universal theory 
mathematical correctness proofs apply formalizations program represented data structure appearing goal universal theory represented extension interpreter additional atomic clauses form clause clause done basis defining proving correct universal theory horn logic extra needed prove correctness universal theory sense programs represented terms goal extra atomic clauses 
furthermore needed better understand related approaches area define universal theories 
rewriting logic languages rewriting logic logic concurrent action supports declarative specification programming concurrent distributed systems including object oriented ones 
equational logic horn logic naturally included rewriting logic conservative way rewriting logic programming generalizes equational programming horn logic programming 
sketch reflective aspects rewriting logic appeared 
class finitely presentable rewrite theories universal theories exactly axiomatic sense 
detailed description universal theory rewriting logic example illustrating simulation rewriting object rewrite theory appendix interest conceptual clarification reflection motivated current design implementation maude rewriting logic language 
languages rewriting logic designed researchers 
broader interest case due fact rewriting logic logical semantic framework wide range logics models computation including horn equational logic linear logic sequent calculi lambda calculus concurrent object oriented programming naturally represented 
reflective properties rewriting logic semantic framework specify prototype reflective logics computational systems example turing machines discussed case point 
evidence provided watanabe malenfant dony cointe papers rewriting formalize computational reflection :10.1.1.31.9998
turing machines turing machines naturally viewed phrase structure grammars string rewriting systems rewrite theories modulo associativity equation binary string concatenation operator 
form restricted class finitely presentable theories rewriting logic 
known class universal theories belonging 
view turing reflection special case reflection semantic framework rewriting logic 
strategies interpreter may fixed strategy strategy may remain metalevel 
interpreter flexible complicate formal reasoning correctness 
ideally strategies defined reflective logic represented reasoned object level 
section give axioms strategies general strategies internal logic discuss advantages reflective logic internal strategies case rewriting logic 
logical theory strategy computational way looking certain proofs theorems may done having strategy language associated example theorem provers lcf tradition metalanguage ml tactics tacticals defined exactly purpose 
generally think abstractly strategy language computational system strategy expressions evaluated cases forever highly nondeterministic ways evaluate expression proofs exhibited stages 
naturally represent evaluations strategy expression labelled transitions ff gamma 
denote ae set proofs exhibited requirement computation ff gamma 
ae ae 
course transitions ff gamma 
fi gamma 
composable yield ff fi gamma 
possible add idle transitions gamma 
axiomatize computations strategy language category 
definition proof calculus external strategy language functor th gamma 
cat natural transformation ae fin ffi proofs fin set gamma 
cat functor sending set poset fin finite subsets viewed category arrows subset inclusions 
addition strategy language required complete sense proofs ae 
internal strategy language consists ffl endofunctor th gamma 
th thought associating theory local metatheory axiomatizing strategy expressions ffl functor str gamma 
cat forgets part algebraic structure algebra proofs leaves underlying categorical structure particular category computations strategy expressions ffl natural transformation ae ffi ffi fin ffi proofs associates strategy expression set proofs exhibits 
th th str set cat proofs fin ae addition require language complete sense 
notice ffi ffi internal strategy language regarded external 
reflective proof calculus internal strategy language iff defined endofunctor gamma 
full subcategory th determined ae restricted definitions external internal strategy language relativized proof obvious manner 
say reflective declarative language reflective operational semantics internal strategies internal strategy language required effectively endofunctor mapping program program strategies ae required computable function extracting proofs exhibited strategy expression 
say strategy expression church rosser iff transitions ff gamma 
fi gamma 
transitions ff gamma 
fi gamma 
say strategy expression sequential iff finite countable sequence transitions ff gamma 
transition ff gamma 
exists unique ff ff ff sequential strategy expression obviously church rosser contrary true general 
strategy expressions need church rosser 
example strategy language nondeterministic choice operator phi expression phi transitions ff phi gamma 
fi phi gamma 
nondeterministic choice operator opaque proofs exhibited disappeared ae phi 
reflective proof calculus reflective declarative language internal strategy language strategies universal theory particularly important represent object level strategies computing universal theory 
interpreter language regarded implementation particular strategy reasoning properties interpreter carried inside logic 
class finitely presentable rewrite theories universal theories making rewriting logic reflective 
addition variety internal strategy languages defined effective theory transformations defined inside language rewriting logic finitely rewrite theory choice category underlying free system countable set variables intuitively associates rewrite theory rewrite theory specifying compute strategy expressions category strategy expression rewritings 
currently studying choice maude 
similar ideas specifying strategies rewrite rules adopted strategies elan rewriting logic language strategy language initially defined external language 
context typed lambda calculi important advantages having internal strategy language stressed authors 
reflective capabilities tactics decision specified reasoned executed inside nuprl constructive type theory 
similarly rue discusses detail elegant definition transformation kind strategy expressions coincide multisets proof expressions see details strategy languages appear 
approach endowing calculus constructions internal strategies part treatment reflection calculus 
concluding remarks step broader effort develop general theory reflection 
purpose concepts support reasoning proving properties reflective logics languages general way 
aim similar model theory important properties logic established general assumptions 
remains ahead develop exploit ideas particular number important topics suggested addressed studied including ffl computational reflection languages 
area greater need theoretical foundations reflective logics reflective declarative languages 
conjecture reflective rewriting logic provide clear simple semantics reflective computational systems briefly illustrated example turing machines evidenced rewriting systems semantic definitions reflection authors 
particularly simple rewriting logic semantics object oriented systems including concurrent ones exists developing rewriting logic semantics reflective object oriented systems natural promising research direction 
ffl mappings reflective systems 
theory general logics logics related mappings preserving relevant logical structure 
mappings useful reusing tools logical components 
similar notions mapping investigated detail reflective case 
ffl modularity 
fact theories represented object level offers excellent opportunities developing powerful internalized logic independent theory modules module operations specifications programs 
lead fundamental advances programming methodology 
ffl supercompilation partial evaluation 
dramatic improvements efficiency reflective systems gained techniques 
part developed functional programming context 
general metalogical understanding techniques consistent ideas substantially widen range applicability 
ffl reflective logical semantic frameworks different reflective logics languages systems naturally represented useful executable specification rapid prototyping formal reasoning 
substantial amount evidence advocating suitability rewriting logic purposes exists 
rewriting logic reflective internal strategy languages systematic exploitation reflection logical semantic framework promising natural 
similar studies useful suitable reflective logics 
fact evidence exists properties nuprl constructive type theory reflective metalogical framework 
steven eker david israel narciso mart oliet harald rue johann schumann shankar mark stickel carolyn talcott valentin turchin helpful comments earlier version 
abramson rogers editors 
metaprogramming logic programming 
mit press 
william aitken robert constable judith underwood 
metalogical frameworks ii reflected decision procedures 
technical report computer sci 
dept cornell university lecture max planck institut fur informatik saarbrucken germany july 
krzysztof apt franco turini editors 
meta logics logic programming 
logic programming series 
mit press november 
barwise feferman eds 
model theoretic logics 
springer verlag 
basin constable 
metalogical frameworks 
huet plotkin editors logical environments pages 
cambridge university press 
anders bondorf 
self applicable partial evaluator term rewriting systems 
orejas editors tapsoft pages 
springer lncs 
boyer strother moore 
proving correct efficiently new proof procedures 
robert boyer moore editors correctness problem computer science pages 
academic press 
bruynooghe editor 
proceedings second workshop meta programming logic 
leuven department comp sc april 
cerioli jos meseguer 
may borrow logic 
transporting logical structure maps 
appear theoretical computer science 
robert constable 
reflection explain enhance type theory 
proof computation pages 
andrzej filinski 
representing monads 
conference record popl acm symposium principles programming languages pages january 
laurent fribourg franco turini editors 
logic program synthesis transformation meta programming logic 
lncs 
springer verlag september 
futatsugi sawada 
cafe extensible specification environment 
appear proc 
international case symposium china november 
fausto giunchiglia paolo traverso alessandro cimatti paolo 
system multi level reasoning 
imsa pages 
information technology promotion agency japan 
joseph goguen rod burstall 
institutions model theory specification programming 
journal acm 
john harrison 
metatheory reflection theorem proving survey critique 
university cambridge computer laboratory 
christopher higgins 
type safe reflection encapsulation logic programming 
volume 
patricia hill john lloyd 
analysis meta programs 
abramson rogers editors meta programming logic programming pages 
mit press 
patricia hill john lloyd 
godel programming language 
mit press 
douglas howe 
reflecting semantics reflected proof 
peter aczel harold simmons stanley wainer editors proof theory pages 
cambridge university press 
dony malenfant cointe :10.1.1.31.9998
semantics introspection reflective language 
appear lisp symbolic computation 
marianne jiang 
meta logics logic programming chapter ambivalent logic pages 
mit press november 
gregor kiczales jim des rivieres daniel bobrow 
art metaobject protocol 
mit press 
kirchner kirchner 
personal communication 
july 
kirchner kirchner vittek 
designing constraint logic programming languages computational systems 
saraswat van editors principles practice constraint programming newport papers pages 
mit press 
narciso mart oliet jos meseguer 
rewriting logic logical semantic framework 
technical report sri csl sri international computer science laboratory august 
narciso mart oliet jos meseguer 
general logics logical frameworks 
gabbay editor logical system pages 
oxford university press 
satoshi matsuoka watanabe akinori yonezawa 
object oriented concurrent reflective architectures 
tokoro nierstrasz wegner editors object concurrent computing pages 
springer lncs 
se matthews 
reflection logical systems 
imsa pages 
promotion agency japan 
francois nicola demers jacques malenfant 
reflection logic functional objectoriented programming short comparative study 
ijcai workshop reflection metalevel architectures applications ai pages august 
harald rue 
computational reflection calculus constructions application theorem proving 
manuscript universitat ulm abt 
kunstliche intelligenz december 
harald rue 
reflection formal tactics deductive reflection framework 
manuscript universitat ulm abt 
kunstliche intelligenz january 
anurag mendhekar daniel friedman 
exploration relationship reflective theories 
volume 
jos meseguer 
general logics 

ebbinghaus editor logic colloquium pages 
north holland 
jos meseguer 
conditional rewriting logic unified model concurrency 
theoretical computer science 
jos meseguer 
multiparadigm logic programming 
kirchner levi editors proc 
rd intl 
conf 
algebraic logic programming pages 
springer lncs 
jos meseguer 
logical theory concurrent objects realization maude language 
gul agha peter wegner akinori yonezawa editors research directions concurrent object oriented programming pages 
mit press 
torben ae 
mogensen 
efficient self interpretation lambda calculus 
journal functional programming 
eugenio moggi 
computational lambda calculus monads 
proceedings fourth annual symposium logic computer science pages june 
kurihara azuma 
reflective language conditional term rewriting 
technical report division systems information engineering university sapporo japan 
okamura ishikawa mario tokoro 
distributed programming system multi model reflection framework 
imsa pages 
promotion agency japan 
lawrence paulson 
tactics tacticals cambridge lcf 
technical report university cambridge 
editor 
proceedings third workshop meta programming logic 
lncs 
springer verlag april 
simon peyton jones 
implementation functional programming languages 
prentice hall 
pfenning lee 
polymorphic calculus 
theoretical computer science pages 
luis rodriguez jr study viability production quality metaobject statically parallelizing compiler 
imsa pages 
information technology promotion agency japan 
harald rue 
formal meta programming calculus constructions 
phd thesis universitat ulm 
shankar 
metamathematics machines godel proof 
cambridge university press 
david sherman robert ir ene durand 
optimization equational programs partial evaluation 
pepm pages 
sigplan notices 
brian smith akinori yonezawa editors 
proc 
imsa international workshop reflection meta level architecture tokyo november 
research institute software engineering 
brian smith 
reflection semantics lisp 
proc 
popl pages 
acm 

incompleteness theorems 
barwise editor handbook mathematical logic pages 
north holland 

diagonalization self 
oxford university press 
steele jr sussman 
art interpreter modularity complex 
technical report aim mit ai lab may 
leon sterling ehud shapiro 
art prolog 
mit press 
valentin turchin 
concept supercompiler 
acm transactions programming languages systems 
valentin turchin 
programming guide manual 
new england publishing 
valentin turchin 
program transformation transitions 
journal functional programming 
valentin turchin andrei 
metavariables implementation program transformation 
technical report csc tr city college cuny 
wand friedman 
mystery tower revealed 
lisp symbolic computation 
watanabe 
foundation computational reflection rewriting preliminary result 
imsa pages 
information technology promotion agency japan 
richard weyhrauch 
prolegomena theory mechanized formal reasoning 
artificial intelligence 
reflection rewriting logic appendix gives rules deduction rewriting logic defines universal theory class finitely presentable rewrite theories illustrates simulating object theory means example 
simple version rewriting logic signature rewriting logic pair sigma formed ranked alphabet sigma function symbols set sigma equations 
signature sigma sentences logic sequents form gamma 
sigma terms 
theory logic called rewrite theory triple sigma sigma signature set sequents called rewrite rules sigma sigma denotes algebra sigma terms variables notation equations write iff provable equations rules unsorted equational logic 
rewrite theory say entails sequent gamma 
write gamma 
iff gamma 
obtained finite application rules deduction 
indicate fx set variables occurring write gamma 
denotes simultaneous substitution 
reflexivity 
sigma gamma 
standard treatment rewriting logic rules rewrite theory labels set written gamma 
omit labels version simplify exposition 
say straightforward extension labelled case 

congruence 
sigma gamma 
gamma 
gamma 

replacement 
rewrite rule gamma 
gamma 
gamma 
gamma 

transitivity 
gamma 
gamma 
gamma 

equality 
gamma 
gamma 
easy show rules deduction define entailment system rewriting logic 
choose signature maps sigma gamma 
sigma sign functions sigma gamma 
sigma 
universal theory rewriting logic section introduce theory representation function making universal theory class unconditional unsorted finitely presentable rewrite theories theories ranked alphabet set equations set rules finite 
essential loss generality assume syntax theories operators variables strings ascii characters 
assume theories standard parenthesized notation 
ease readability particular case theory adopt extra notational conventions 
introduce ranked alphabet sigma operation symbols briefly explain representation function defined 
give set eu equations set ru rules operation symbols sigma follows sigma ascii ascii denotes set ascii characters 
sigma sigma fg sigma 
sigma 
sigma 
ease readability adopt notational conventions 
appearance characters ary operator sigma allows display corresponding expressions mix fix syntax adding parentheses necessary 
operator write 


string forming operators assumed parsed precedence 
shorthand similarly shorthand 
define representation function encoding pairs consisting finitely presentable rewrite theory sentence sentences ftg theta sen gamma 
sen definition top fashion 
clear intended meaning operation symbols sigma note ease readability recursively define representation theories rules term overloaded function symbol 
ffl finitely presentable rewrite theory gamma 
sentence gamma 
gamma 

ffl rewrite theory sigma var finite set variables appearing equations rules var 
ffl var set variables fx var var empty set var 
ffl set equations fe empty set 
ffl set rewrite rules fr empty set 
ffl equation 
ffl rewrite rule gamma 


ffl term sigma term sigma term var varfxg 
note assumed operators variables strings ascii characters 
ffl string ascii characters introduce set eu equations operation symbols declared associative identity element operation symbol declared commutative 
introduce groups set ru rules explain intended meaning 
ease readability variables rules appear italics shorthand notation convention variables character strings quote having length ambiguity may arise ascii characters constants sigma introduce notation 
indicate bidirectional rule pair rules gamma 
gamma 
shall see belongs class finitely presentable rewrite theories 
entailment system rewriting logic reflective 
means reifies entailment relation operation symbols equations rules seen specification rewriting logic rules deduction including congruence replacement equality rules 
reflexivity transitivity rules deduction theory directly mirrored reflexivity transitivity rules deduction note rewriting logic proof calculus 
extending definition lines explicit reify proofs built deduction process similarly exhibit finitely presentable universal theory making proof calculus rewriting logic reflective 
reify rule congruence contexts potential redexes 
fact idea contexts redexes combine rules congruence replacement 
result step reified replacement taken subterm reified subject term 
particular operation symbols sigma rules operation symbols decompose term rewritten context potential redex 
context term arguments 
potential redex term 
intended meaning rules indicate subterm step rewriting attempted 


declared operation symbol associative identity element rule applied argument fact overriding goal definition avoid possible building particular evaluation strategy allow greatest possible flexibility subsequent definition strategies 
conceived particular interpreter say left inner rewriting logic 
notion strategy introduced section easy see different interpreters obtained defining different strategies details appear 
reify rule replacement reify condition application 
rule gamma 
replacement term iff 
rule set aside matching problem left hand side rule potential redex 
introduced sigma operation symbol 
argument pair formed rewrite theory term decomposed context potential redex matching problem related second third arguments left hand side rule potential redex respectively 
fourth argument consists pair built operation symbol 
element pair represents set assignments second set variables 
see argument needed handle case nonlinear left hand sides variable occurrences 
note sets empty initial set assignments sets initial set variables set variables theory 
fifth argument righthand side selected rule 
shall see allows continue reified replacement process having keep track rule selected 
rule reifies equality rule treating way entirely similar replacement 


note operation symbol associative identity rule chosen 
commitment strategy rule selection replacement step derivation 
matching problem terms handled rules gamma 
expected try come set assignments substituted equal reified matching process seen process trying identify keeping track differences handle case non linear lefthand sides pair idea keep set variables set variables assigned disjoint 
note initial set set variables theory 
reified matching process reach base case matching variable term consider cases rule rule set variables encountered occurrence matching 
rule operation symbols similar way rules 
intended meaning indicate subterms respectively matching pursued 

varfxg varfxg gamma 
varfxg varfxg varfxg varfxg varfxg gamma 
varfxg varfxg varfxg note commitment strategy reified matching process 
matching process terminated rules 
note rule applied time reified matching process abort applied process succesful number applications rules gamma potential redex equal lefthand side rule set assignments substituted equal gamma 
gamma 

application rule changes matching task replacement task 
introduced sigma operation symbol 
argument pair formed rewrite theory term decomposed context redex second argument righthand side rule lefthand side succesfully matched redex third argument set assignments resulting matching process 
fourth argument substitution task 
see argument needed guarantee correctness reification replacement rule 
replacement task carried phase process phase consists applying substitution second consists actual replacement result substitution 
application substitution term performed rules gamma 
reified matching process substitution initiated carried 
indicate subterm fully substituted introduced sigma operation symbol fg 
indicate part substitution task remains done introduced sigma operation symbol 
idea reify substitution task sequence terms representing current task 
note rule chooses current task 
rule operation symbols way similar rules 
intended meaning indicate subterm substitution pursued 
note subterm selected subtask current task 
application indicate subterm substitution pursued delete subtask current task place new current task 
rule handles case current task subtasks 
particular deletes current task changes current subterm fully substituted subterm 
similar fashion rules handle base cases reified substitution process 
expected deletes current task changes current subterm fully substituted subterm 
similar behavior exhibited performing actual substitution 
rule subterm previously decomposed context subterm fully substituted 

gamma 


gamma 
uf gamma 
uf gg varfxg varfxg varfxg 
gamma 
uf tg varfxg 
tg gamma 
actual replacement handled expected way rule 
note applied righthand side rule succesfully matched fully substituted substitution tasks pending 

gamma 
example rewriting foo rewrite theory sigma fa bg sigma fhg sigma ffg var fxg ff gamma 
clear holds rewriting logic foo gamma 
prove foo gamma 
holds expanded foo gamma 
foo proof illustrate rewriting universal theory simulates rewriting object theory 
ease readability foo change rewriting step shorthand fully expanded definition foo varfxg varfxg opfhg varfxg 
show rewriting derivation foo foo 
step select redex rules 
case want select 
label indicates derivation replacement step rule foo opfhg opfbg foo opfhg opfbg note rule replacement step 
need take equality steps equations label equ indicates steps 
foo opfhg opfbg equ foo opfhg opfbg equ foo opfhg opfbg rule select 
foo opfhg opfbg foo opfhg opfbg simplify exposition subsequent derivations show explicitly equality steps taken replacement step 
label equ indicate equality steps taken replacement step rule select rule foo 
obviously want select gamma 

rule 
note rule sets aside matching problem 
varfxg varfxg opfhg varfxg 
opfhg opfbg varfxg varfxg opfhg varfxg 
opfhg opfbg varfxg opfbg varfxg opfhg varfxg 
context remain unchanged phases matching substitution 
ease readability context shorthand context opfhg opfbg top operator rule continue matching process subterms 
way select 
foo context varfxg opfbg varfxg opfhg varfxg 
foo context varfxg opfbg varfxg opfhg varfxg 
apply rule identify keeping result difference assigning foo context varfxg opfbg varfxg opfhg varfxg 
foo context varfxg varfxg varfxg opfbg opfhg varfxg 
apply rule equivalent saying matching succesful resulting substitution reified replacement step 
note carry similar process matching subterms 
foo context varfxg varfxg varfxg opfbg opfhg varfxg 
foo context opfhg varfxg varfxg opfbg opfhg varfxg 
carry actual reified replacement step 
apply substitution obtained matching process reified righthand side 
note fact current task 
rule selects continue substitution process 
deletes subtask replaces current task 
foo context opfhg varfxg varfxg opfbg opfhg varfxg 
foo context opfhg varfxg varfxg opfbg opfhg varfxg 
rule performs actual substitution variable rule declares fully substituted subterm deletes current task 
foo context opfhg varfxg varfxg opfbg opfhg varfxg 
foo context opfhg opfbg varfxg opfbg opfhg 
rule continuing current substitution task 
foo context opfhg opfbg varfxg opfbg opfhg 
foo context opfhg opfbg varfxg opfbg opfhg 
case current substitution task subtasks 
apply rule declare fully substituted subterm delete empty current task 
foo context opfhg opfbg varfxg opfbg opfhg 
foo context opfhg opfbg varfxg opfbg note substitution tasks pending 
rule perform actual reified replacement step 
rule change context shorthand 
foo opfhg opfbg opfhg opfbg varfxg opfbg foo opfhg opfhg opfbg finish rewriting derivation foo foo just opposite directions rules 
label gamman indicates derivation replacement step right left bidirectional rule foo opfhg opfhg opfbg gamma foo opfhg opfhg opfbg gamma foo opfhg opfhg opfbg 
