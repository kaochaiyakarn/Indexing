title region memory management authors mads tofte jean pierre talpin affiliation mads tofte department computer science university copenhagen jean pierre talpin irisa campus de beaulieu france earlier version st acm sigplan sigact symposium principles programming languages portland oregon january describes memory management discipline programs perform dynamic memory allocation de allocation 
runtime values put regions 
store consists stack regions 
points region allocation deallocation inferred automatically type effect program analysis 
scheme assume presence garbage collector 
scheme tofte talpin subsequently tested ml kit regions region garbage collection free implementation standard ml core language includes recursive datatypes higher order functions updatable birkedal elsman 
defines region dynamic semantics skeletal programming language extracted standard ml 
inference system specifies regions allocated de allocated detailed proof system sound respect standard semantics 
conclude giving advice write programs run stack regions practical experience ml kit 
computers finite memory 
total memory allocated program run far exceeds size memory 
practical discipline programming provide form memory recycling 
key achievements early programming languages invention notion block structure associated implementation technology stack memory management recycling memory 
languages point allocation matched point deallocation points easily identified source program naur dijkstra 
properly stack discipline result efficient memory maximum memory usage bounded depth call stack number memory allocations 
stack discipline limitations witnessed restrictions type systems block structured languages 
example procedures typically prevented returning lists procedures results 
main reasons restrictions 
stack discipline size value known latest space value allocated 
allows example arrays local procedure size determined arguments procedure contrast general possible determine big list going generation list begins 
second stack discipline life time values comply allocation deallocation scheme associated block structure 
procedures values danger procedure value refers values deallocated 
example consider program fn 
expression application function denoted delta delta number 
function formal parameter body stands projection 
fn pronounced sml 
operator expression supposed evaluate fn 
bound pair expression evaluates pair 
regard delta delta construct block construct just lexical scope see stack implementation de allocate space component needed function returned entire expression 
way ease limitations stack discipline allow programmer controlled allocation de allocation memory done 
store stack regions region uniquely identified region name depicted box picture 
operations malloc free allocation de allocation respectively 
unfortunately general hard programmer know block memory contain live values may freed consequently solution easily leads called space leaks programs memory expected 
functional languages haskell standard ml object oriented languages java separate routine runtime system garbage collector take care de allocation memory knuth baker lieberman 
allocation done program high rate 
example expressions fn 
allocate memory time evaluated 
part memory holding values called heap role garbage collector recycle parts heap hold dead values values consequence rest computation 
garbage collection fast provided computer memory 
quoted argument amortized cost copying garbage collection tends zero memory tends infinity appel page 
case languages standard ml frees programmer completely having worry memory management 
write efficient sml programs understand potential dangers example accidental copying survival large data structures 
program written concern space usage may memory problem located space profiler example turning space wasting program space efficient may require major changes code 
purpose reported advocate compromise extremes completely manual vs completely automatic memory management 
propose memory model user may programming memory thought stack regions see 
region stack unbounded size grows upwards picture region entirety popped region stack 
example typical region hold list 
program analysis automatically identifies program points entire regions allocated de allocated decides value producing expression region value put 
specifically translate typed source language expression target language expression identical certain region annotations 
evaluation corresponds step step evaluation forms annotations ae letregion ae form expression directly produces value 
constant expressions abstractions tuple expressions fall category 
ae region variable indicates value put region bound ae 
second form introduces region variable ae local scope runtime unused region identified region name allocated bound ae 
evaluated probably region named 
region de allocated 
letregion expression way introducing eliminating regions 
regions allocated de allocated stack manner 
target program corresponds source program letregion ae ae letregion ae ae ae ae ae ae ae shall step evaluation expression detail section 
briefly evaluation starts region stack regions ae ae ae evaluation allocates de allocates regions ae ae ae ae ae ae contain final result 
scheme forms basis ml kit regions compiler standard ml core language including higher order functions recursive datatypes 
region inference rules describe address life times 
solution problem handling values unknown size addressed birkedal 
important optimisation turns distinguish regions size determined statically 
allocated usual stack 
terminology region analysis infers insert calls malloc free beware analysis developed context standard ml relies fact sml strongly typed strongly typed imperative language java region inference useful freeing memory java free 
readers interested code generation appendix shows address program ml kit produces program region inference additional optimisations described birkedal :10.1.1.24.9456
primarily semantics regions implementation 
experience kit properly region scheme strong execute demanding benchmarks considerable space savings compared garbage collected system birkedal 
allocation handled automatic region analysis occasionally conservative garbage collector probably useful especially programmer know region inference rules chosen usually small transformations source programs region friendly 
shall describe transformations 
important property implementation scheme programs executed written additional costs unbounded size see appendix detailed example 
memory management directives inserted constant time operations 
opens possibility languages power standard ml applications guarantees time space usage crucial example real time programming embedded systems 
key problem addressed prove region inference system safe particular de allocation really safe analysis claims safe 
follows 
define standard operational semantics skeletal source language giving static dynamic semantics section 
define region operational semantics target language target language identical source language programs annotated region information section 
dynamic semantics source language notion store target language semantics store organised stack regions 
specify translation source language target language form inference system section 
define representation relation values standard semantics skeletal language values regionbased semantics section show subexpression original program far rest computation evaluation concerned image target program evaluate related values evaluated related environments section 
restricting attention rest computation observe turns crucial connections values source language semantics regionbased semantics lost memory re region semantics 
key point part target machine observed rest computation value source language faithfully represented value target language 
representation relation defined maximal fixed point certain monotonic operator 
properties relation proved method proof call rule induction section 
algorithms region inference scope shall give hints region inference rules implemented section 
related main differences region stack traditional stack discipline block structured languages follows 
value created scheme necessarily put topmost region 
case function closures example closure put far stack necessary order sure closure exists accessed 
second regions size determined time region allocated 
scheme works higher order functions recursive datatypes allocation basis type system language grammar 
murtagh propose stack regions conjunction traditional heap 
region associated activation record necessarily case scheme 
combination interprocedural intraprocedural data flow analysis find suitable regions put values 
type inference analysis crucial handling polymorphism higher order functions 
inoue 
interesting technique compile time analysis runtime garbage cells lists 
method inserts pairs hold instructions target language 
hold holds pointer say root cell argument collects cells reachable fit path description hold reclaim pairs nested hold pointers held stack entirely stack regions 
scheme unit collection entire region traversal values connection region collection 
path descriptions inoue possible distinguish individual members list 
possible scheme treat elements list equal 
inoue report reclamation rate garbage list cells produced quicksort inoue page 
obtain reclamation rate word garbage produced quicksort garbage collection tofte talpin 
hudak describes counting scheme order call byvalue functional language 
turner wadler mossin type system inspired linear logic distinguish variables variables may 
analyses provide somewhat different information distinguish 
georgeff describes implementation scheme typed lambda expressions called simple form transformation expressions simple form 
transformation result increase number evaluation steps arbitrarily large factor georgeff page 
georgeff presents implementation scheme involve translation relies call value reduction actual parameters functions 
device grouping values regions unification region variables essentially idea baker expressions ae annotation type checking directly indirectly unifies type baker prove safety deal polymorphism 
obtain separation lifetimes explicit region polymorphism mean regions arguments functions runtime 
example declaration successor function fun succ compiled fun succ ae ae letregion ae ae ae note succ decorated extra formal region parameters enclosed square brackets distinguish value variables 
new succ function type scheme ae ae int ae fget ae put ae gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma int ae meaning ae ae function accepts integer ae produces integer ae performing get operation region ae put operation region ae process 
succ put result different regions depending context delta delta delta succ ae ae ae delta delta delta succ ae ae additional provision recursive function call region arguments different formal region parameters may local body recursive function 
local regions resemble activation records classical stack discipline 
ideas effect inference lucassen lucassen gifford jouvelot gifford find wrap letregion ae expression 
effect inference uses word effect meaning side effect concurrent languages communication effect nielson nielson 
effects side effects relative underlying region store model irrespective effects stem imperative features 
idea effect inference possible delimit regions memory delimit lifetimes goes back early effect systems lucassen 
lucassen gifford call effect masking prove side effect masking sound respect store semantics regions reused 
talpin talpin jouvelot polymorphic effect system side effect masking prove sound respect store semantics regions reused 
version proof recorded technical report tofte talpin turn basis proof outline tofte talpin 
order simplify proofs modifications early proofs done 
main differences adopted value polymorphism simplifies proofs various ways particular difficult lemma lemma tofte talpin eliminated dynamic semantics target language extended region environments definition consistency strengthened prevent closures free region variables complicate proof proofs rewritten idea rule induction 
aiken 
developed program analysis post pass analysis described 
analysis possible delay allocation regions promote de allocation leading asymptotic improvements space usage leading worse results region inference analysis added 
source language sexp skeletal language treated essentially milner polymorphically typed lambda calculus milner 
assume denumerably infinite set var program variables 
range variables 
ranges integer constants 
grammar source language letrec sexp denote set source language expressions 
addition pairs tuples theory straightforward 
exceptions recursive datatypes added implementation correctness translation constructs proved 
call cc concurrency primitives substantial extensions standard ml studied 
clear region inference bear lazy functional languages 
fact ml typed essential fact polymorphism essential follows 
notation rest shall terminology 
finite map map finite domain 
sets set finite maps denoted fin domain range finite map denoted dom rng respectively 
finite maps finite map domain dom dom value dom 
map set write mean restriction write tuple region variables example form ae delta delta parentheses commas 
need select components tuples example region name address 
cases rely variable names indicate component selected 
example means region name component 
shall see address pair form region name offset 
static semantics source damas milner ml types ml type schemes defined ml int ff ml ml ml type oe ml ff delta delta deltaff ml ml type scheme ff ranges denumerably infinite set tyvar type variables 
ml type ml instance ml type scheme oe ml ff delta delta deltaff ml written oe ml ml exist ml ml ml ml ff ml ff ml ml type environment finite map program variables ml type schemes 
te ml range type environments 
ml type type scheme type environment ftv denotes set type variables occur free milner original type discipline polymorphism associated 
turned advantages restricting polymorphism gets type scheme syntactic value 
language syntactic value integer constant lambda abstraction 
making easier prove soundness connection language extensions imposing restriction proofs correctness region inference simpler done 
fact shall take restriction step allow polymorphism connection letrec 
program satisfies value restriction turned equivalent program letrec polymorphism simply turning letrec fresh variables 
theory follows polymorphism connection letrec convention just syntactic sugar show rules easier follow examples 
te ml oe ml oe ml ml te ml ml te ml fx 
ml ml te ml ml ml te ml ml ml te ml ml te ml ml te ml ml te ml fx 
ml ml te ml ml te ml ff 
ml ml fff ff ftv te ml te ml ff 
ff delta delta deltaff ml ml te ml letrec ml dynamic semantics source non recursive closure triple hx ei environment finite map variables values 
range environments set environments denoted env 
recursive closure takes form hx fi name recursive function question 
value integer constant closure 
range values set values denoted val 
evaluation rules appear 
allow infer statements form read environment expression evaluates value closure representing recursive function unrolled just applied rule 
expressions hx ei hx fx 
hx fi ff 
hx fig fx 
fx 
ff 
hx fig letrec target language texp assume denumerably infinite set regvar fae ae region variables ae range region variables 
grammar target language texp ae delta delta delta ae ae ae letrec ae delta delta delta ae ae letregion ae common functions represented closures region polymorphic functions introduced letrec delta delta delta delta delta delta represented called region function closures different closures 
expression form ae ae indicates region closure representing put 
qualifies 
letrec ae delta delta delta ae ae ae indicates region function closure put 
subsequent application ae delta delta delta ae ae extracts region function closure store applies actual arguments ae ae creates function closure ae finite set fae ae region variables write letregion ae ae letregion ae delta delta delta letregion ae shall separate static semantics target language semantics extracted translation rules section 
proceed dynamic semantics 
dynamic semantics target assume denumerably infinite set fr region names range region names 
region names serve identify regions runtime 
assume denumerable infinite set offset offsets range offsets 
region finite map offsets storable values 
storable value integer constant function closure region function closure 
sv range storable values set storable values denoted 
variable environment finite map program variables values 
range variable environments set variable environments denoted 
region environment finite map region variables region names 
range region environments set region environments denoted 
function closure quadruple hx ri program variable target language expression give meaning free program region variables region function closure tuple form hae delta delta ri 
region function closures represent region polymorphic functions region variables ae ae required distinct referred formal parameters region function closure 
address pair region name offset 
range addresses addr denote set addresses 
address write mean component region name store finite map region names regions 
range stores set stores denoted store 
value address 
range values set values denoted 
shall brief indirect addressing address write mean 
similarly write 
svg shorthand fr 
fo 
svg define planar domain written pdom finite set addr dom dom write nn frg read mean store dom frg 
inference rules dynamic semantics texp shown 
allow infer sentences form read store variable environment region environment target expression evaluates value modified store rule evaluation rule application region function closure 
function closure created region closure 
imagine runtime error occurs premises satisfied example ae dom som ae 
correctness proof shows premises satisfied programs result translation 
rule concerns region polymorphic possibly recursive functions 
keep number constructs target language chosen combine recursion region polymorphism language construct 
functions defined letrec need recursive letrec construct define region functions produce non recursive functions 
rule creates region closure store handles recursion creating cycle store fresh address chosen side conditions ae dom environment ff 
stored region function closure hae delta delta delta ae ri turn stored fresh address chosen earlier 
yield region function closure rule desired letrec introduces recursion 
function application operator expression evaluate pointer ordinary function closure hae ae operator expression form ae delta delta delta ae ae 
consequently single rule function application suffices 
pushing popping region stack seen rule 
expressions ae dom ae 

cg hae ae ae dom sv hx fae 
ae ae delta delta delta ae ae 

svg ae dom ae 

hx rig hx fx 
fx 
ae dom ff 

hae delta delta delta ae rig letrec ae ae ae dom fr 
fgg fae 
rg letregion ae nn frg illustrate rules examples comment design decisions embodied rules prove properties semantics 
example function values consider evaluation expression section 
ae ae ae occur free allocated evaluation begins 
show snapshots evaluation just closure allocated just closure applied assume regions names bound ae ae respectively 
notice dangling harmless pointer 
ffl ffl hy ae fx 
fflg fae 
gi ffl ffl hy ae fx 
fflg fae 
gi ffl ffl example region polymorphism example illustrates region polymorphism polymorphic recursion 
consider source expression computes th fibonacci number 
letrec fib fib fib fib corresponding target expression shown 
target expression fib function takes arguments ae region located ae place fib supposed put result 
due polymorphic recursion region inference system recursive calls fib regions different ae ae recursive calls separate regions 
example call reserves space result call ae reserves space actual argument ae creates actual argument performs call deallocates actual argument uses result till discarded 
letregion ae letrec fib ae ae ae int ae delta delta delta ae delta delta delta ae letregion ae ae letregion ae ae fib ae ae ae letregion ae ae ae letregion ae ae fib ae ae ae letregion ae ae ae ae letregion ae ae fib ae ae ae ae fibonacci function annotated regions 
result single integer ae letrec stores cyclic region function closure store new address hae ae delta delta delta 
ag fae 
ae 
gi assuming ae bound application fib near program stores function closure region denoted ae hx delta delta delta 
ag fae 
ae 
ae 
ae 
gi see region inference produced allocations similar traditional stack implementation 
maximal memory usage example proportional maximum depth recursion pure stack discipline 
design choices region semantics relies number design choices crucial 
crucial sets offset denumerable sets 
assume sets ordered notion address locality 
particular physical implementation region stack built theory 
essential real computers flat address space region stack conceptually dimensional 
particular implementation choice ml kit described birkedal second crucial semantics uses called flat environments alternative linked environments represent environment linked list environment frames :10.1.1.24.9456
popular representation block structured languages functional languages 
linked environments closure creation cheap regions environment frames interspersed regions stack 
example essential copy environment closure ae binding destroyed leave scope ae pop stack 
inessential choices 
need represent objects boxed ml kit integers values fit machine word represented unboxed 
recursion probably implemented unfolding closures cycles store 
deep need keep region environment variable environment separate closures ml kit merges clear region names values 
properties region evaluation state formally complete evaluation expression decrease store 
arbitrary finite maps say extends written dom dom dom 
say succeeds written dom dom dom 
lemma dom dom proof straightforward induction depth inference re formula dom dom lemma expresses store resulting elaboration regions store evaluation begins regions may allocated temporarily evaluation 
evaluation may write values existing regions possible ae removes overwrites values syntactic equality expressions target expression 
set program variables occur free written fpv 
set region variables occur free frv 
source language target language shall consider expressions equal obtained renaming bound variables 
extends closures 
example hx hx considered equal equal sense 
allow free variables may renaming free variables provided course corresponding change domain obtain 
loosely speaking corresponds admitting value environments declarations allowing usual renamings permitted expression form consider hx hx equal fpv fpv 
allows introduce delete unused program variables domains environments inside closures 
similarly region closure ae ri allow renamings ae fpv frv elimination unused program variables expect closure written ae equality semantic objects dynamic semantics defined smallest equivalence relation closed transformations described 
region inference rules specify translations legal called region inference rules 
section region types semantic objects occur region inference rules rules section 
sections state prove properties region inference system example translation refinement milner type discipline 
semantic objects region types assume denumerably infinite pairwise disjoint sets ff tyvar type variables ae regvar region variables ffl effect variables avoid subscripts primes place ae range region variables 
atomic effect term form put ae get ae ffl atomic effect range atomic effects 
effect finite set atomic effects 
range effects 
concrete example effect expression example fput ae put ae put ae types types places int ff ffl gamma gamma 
type ae type place function type ffl gamma gamma 
object ffl called arrow effect 
formally arrow effect pair effect variable effect refer ffl handle latent effect respectively 
function type latent effect interpreted effect evaluating body effect variables useful expressing dependencies effects 
example target expression ae ae type ff ae ffl gamma gamma ff ae ae ffl fput ae gamma gamma gamma gamma gamma gamma gamma gamma 
ff ae ffl fget ae ffl gamma gamma gamma gamma gamma gamma gamma gamma gamma ff ae ae occurrence ffl indicates appropriate type evaluates function evaluates value evaluation may involve application 
happens evaluation involve application type express 
equality types defined term equality usual set equality latent effects 
example arrow effects ffl fput ae get ae ffl fget ae put ae considered equal 
wonder pair ffl function arrow just say effect 
reason region inference algorithms rely unification just ml type inference damas milner 
effect sets function arrows pose problem existence principal unifiers 
solution arrow effects certain invariants effect variables 
basic idea effect variables uniquely stand effects ffl ffl occur proof tree formed inference algorithm ffl ffl case arrow effects ffl ffl occur proof tree ffl presence ffl implies subsumes entire effect ffl stands 
representation invariants special notion substitution defined prove existence principal unifiers types contain effects sets 
detailed account done scope 
invariants mentioned needed proving soundness region inference shall consider follows 
substitution type substitution map type variables types range type substitutions 
region substitution map region variables region variables range region substitutions 
effect substitution map effect variables arrow effects range effect substitutions 
substitution triple range substitutions 
substitution types region variables effects defined follows 
effects fput ae put ae fget ae get ae fj ffl ffl ffl ffl ffl fffl types region variables int int ff ff ae ae ae ae ffl gamma gamma 
ffl gamma gamma gamma gamma gamma gamma gamma 
ffl ffl concrete example consider substitution ffl ae ffl fget ae put ae ffl ffl ffl ff ae int ff ff ff ff ff ae ae ae ffl ae ae ff ff refer 
int ae ffl fget ae put ae gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma int ae ae ffl fput ae gamma gamma gamma gamma gamma gamma gamma gamma 
int ae ffl fget ae get ae put ae ffl gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma int ae ae specific type appropriate occurs application expression int ae ae ae able infer type place int ae ffl fget ae get ae put ae ffl gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma int ae ae applying substitutions semantic objects bound names type scheme bound variables renamed avoid capture necessary 
substitutions compose id identity substitution 
support type substitution written supp set fff tyvar ff ffg 
similarly region substitutions 
support effect substitution written supp set fffl ffl ffl support substitution written supp defined supp supp supp 
finite maps appropriate types take liberty consider triple substitution explicitly extending finite maps total maps 
type schemes type schemes resemble type schemes damas milner additional quantification region variables effect variables oe simple type scheme ae delta delta ff delta delta deltaff ffl delta delta compound type scheme 
definitions stated compound type schemes easily extended simple type schemes 
type scheme oe ae delta delta ff delta delta deltaff ffl delta delta bound variables oe written bv oe set fae ae ff ff ffl ffl mg write sequences bound variables vectors ff ae ffl respectively 
type schemes equivalent obtained renaming reordering bound variables 
type instance oe written oe exists substitution supp bv oe want explicit say instance oe written oe equivalent type schemes instances 
write shorthand simple type scheme confused compound type scheme compound type schemes special significance exclusively types functions region polymorphic functions take empty list actual region parameters 
underlining serves clear type scheme regarded simple compound 
ff tyvar regvar ffl effect fin put ae regvar get ae regvar type tyvar type regvar theta tyvar theta theta type oe fintg ffl gamma gamma 
theta theta ffl theta effect type theta regvar te var fin 
theta regvar semantic objects region inference type environment finite map program variables pairs form oe ae 
te range type environments 
semantic objects summarised 
notion free variables extend larger semantic objects type environments 
example type variable said occur free te occurs free te 
semantic object frv denotes set region variables occur free ftv denotes set type variables occur free fev denotes set effect variables occur free fv denotes union 
inference system inference rules allow inference statements form te read te translates type place effect 
region inference rules non deterministic te may infinitely satisfying te 
non determinism convenient express type polymorphism express freedom choice region variables 
region inference rules allow put values single region practice worst possible choice 
region translation expressions te te ae int ae fput ae te ae te ae te oe ae oe ae delta delta ff ffl oe fget ae put ae te ae ae ae ae te fx 
ffl gamma gamma 
frv frv te te ae ae fput ae te ffl gamma gamma 
ae te te fffl get ae te ae te fx 
ae te te ff 
ae ffl ae ae ae fv ff ae ffl fv te te ff 
ff ae ffl ae te letrec letrec ae ae te ae frv te te letregion ae fput ae get ae te ffl fev te te ffflg rule note effect referring empty effects relate access region store environments rule instances bound region variables actual region parameters target expression 
resulting effect includes get ae put ae access region closure ae create ordinary function closure ae 
rule effect creating function closure region ae simply fput talpin jouvelot allowed information function precise increasing latent effect 
useful cases expressions functional type including latent effects arrows may evaluate different closures 
freedom increase effects useful wants prove typed exp program milner translated region inference rules see lemma 
shall explain side condition frv frv te moment 
rule see latent effect brought function applied 
get ae resulting effect due fact access closure ae order perform function application 
rule note region polymorphic type polymorphic inside body 
polymorphic types regions effects 
limitation type polymorphism inside region inference decidable 
rule concerns letregion expressions 
basic idea goes back early effect systems lucassen 
suppose te assume ae region variable occur free te typically ae occurs free indicating ae computation 
ae purely local evaluation sense rest computation access value stored ae 
example consider expression section 
subexpression ae ae ae ae ae type environment force expression produced te fg type place int ae ffl fget ae put ae gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma int ae int ae ae ae effect fput ae put ae put ae put ae note ae region variable occurs free occurs free te rule allows discharge ae resulting effect fput ae put ae put ae letregion ae ut rule allows discharge effect variable effect letregion introduced discharge influence evaluation 
owe explanation side condition frv frv te rule 
case region variable occur free translated expression occurs free type effect expression 
example fails hold fg ae ae ae ae int ae fput ae put ae get ae put ae see ae free target expression occurs free effect resulting type place 
reason ae dead code executed 
rule demand free region variables body lambda abstraction 
side condition satisfied applying rule repeatedly necessary just applying rule 
simplifies soundness proof specifically proof lemma 
mentioned earlier region inference rules give rise static semantics target language just consistency replaces sentences te te 
prefer form emphasises rules specify translation 
region inference refinement milner type system section prove region inference system refinement milner type discipline milner sense expression translated region rules typed milner type discipline defined section 
particular shows problem determining closed expression region annotated decidable 
show expression translated typed 
define function projection semantic objects region rules semantic objects milner rules ff ff int int ffl gamma gamma 
ae ae ff ffl ff oe ae oe te ffi te lemma te te 
proof straightforward induction depth te 
ut show typed term translated 
define relation milner objects 
ae fixed region variable ffl fixed effect variable 
basic idea choose ae need region variable translation choose ffl fget ae put ae ffl need arrow effect translation 
unfortunately simply map distinction simple compound type schemes 
define inductively follows ff ff int int ffl fget ae put ae ffl gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma 
ff ff ae oe oe oe oe ae dom te dom te dom te te te te te clearly te exists te te te lemma te te te te satisfy frv fae frv fae fget ae put ae ffl proof induction depth inference te show cases rest straightforward 
assumption te oe oe te te te oe ae oe satisfies oe oe oe may simple compound compound quantified region variables 
ae unique type place satisfying oe desired follows rule rule 
te inferred premise te fx 
te fx 
te fx 
unique type place related induction exist te fx 
frv fae frv fae fget ae put ae ffl rule conveniently allows inclusion prove te ae ffl fget ae put ae ffl gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma 
ae fput ae desired results follows 
ut substitution lemma lemma substitutions te te 
proof straightforward induction depth inference te appropriate variants case letrec 
shall state lemma effect operation making type schemes type environment type polymorphic decrease set possible translations 
formally say oe type polymorphic oe written oe oe oe oe identical oe oe compound oe ff oe ff 
furthermore write te te dom te dom te dom te oe ae te oe ae te oe oe ae ae lemma te te te te 
omit proof straightforward induction depth inference te 
note similar statement concerning region polymorphism replacing oe ff ffl oe ae ff ffl true applications region functions target expression affected change 
fortunately precisely ability assumed type schemes type polymorphic need 
effects describe continuations proof soundness translation scheme need relate values dynamic semantics source target language 
refer relation consistency relation 
values addresses target language semantics consistency relation involve stores 
consistency naturally depends types type int source level integers consistent pointers integers target functional type closures related 
region inference rules yield expressions types places effects contain free occurrences region variables 
relate region variables region names identify regions runtime need region environment definition definition region environment connects effect store frv dom ae frv ae dom 
considerations assume defined consistency relation theta theta val theta store theta read region environment store source value consistent target value type place obvious idea lift relation types places type schemes oe pointwise extension environments te 
try prove statement conjecture te te connects exists store target value 
problem conjecture 
informally states consistency preserved evaluation 
unfortunately expect hold 
see problem consider example 
conjecture point source language closure hy fx 
gi closure region consistent 
sense consistent application closures map consistent arguments consistent results 
notice consistency exist source environment fx 
representation target semantics partly destroyed region popped region stack 
see intuitively speaking consistency gradually deteriorates computation 
saving factor turns consistency left rest computation succeed running inconsistencies 
intuitions precise need notion consistency respect rest computation 
possibility explicitly continuations evaluation contexts 
explored possibility need purpose soundness proof simple summary regions accessed rest computation 
specifically suffices summarise rest computation effect describes currently existing regions accessed rest computation 
define relation theta theta val theta store theta theta effect written read type place region environment store source value consistent target value respect effect represents effect rest computation 
example fput ae get ae put ae connected region environment regions fact rest computation access current contents evident fact region variable free connected environments closures consistent respect rest computation 
second version conjecture conjecture te te connects exists store target value words start consistency cover evaluation effect rest computation effect computation consistency left rest computation 
conjecture quite strong proved induction 
consider source language closure hx ei target closure hx ri think representing hx ei 
source closure applied body evaluated environment fx 
argument function 
assuming target value consistent corresponding evaluation target language takes form fx 
delta delta delta 
region environment evaluated necessarily region environment force point application takes place regions may allocated closure created 
important establishing fx 
fx 
consistent known consistent establish consistency fx 
fx 
order induction prove results function applications consistent 
example consider target expression letregion ae ae letregion ae ae ae letregion ae ae consider point evaluation just closure created 
say region environment fae 
ae 
ae 
store fr 
fg 
fo 

fo 
hy ae fx 
ig reasonable expect fx 
int ae fx 
fx 
fget ae get ae put ae net effect remainder computation point 
expect defined 
consider point actual argument stored closure fetched just evaluate body region environment fae 
store fr 
fo 
gg reasonably expect int ae fget ae get ae put ae effect continuation point 
reasonably expect obtain fx 
int ae 
int ae fx 

fx 

evaluation function body going take place see rule 
theorem needs strong handle situation region environment consistency established region environment expression evaluated 
incidentally similar situation block structured languages inner block call function declared enclosing block 
appears variable environments obey stack discipline region environments 
ut prove theorem holds just region environments agree definition region environments effect 
say agree frv frv 
able state main theorem shall prove defined consistency relation theorem te te connects agree frv exist premise frv included proof simpler helps ensure closures target language contain free region variables 
note effect rest computation approximation data live notion usually employed garbage collectors data live reachable memory graph incomparable seen data reachable memory graph dead deallocated region inference conversely data keep alive region rest computation garbage collector detect 
consistency simplicity consistency relation form inference rules underlying mathematics 
shall explain rules viewed describing maximal fixed point certain monotonic operator 
suffices read rules follows rule holds premises hold 
rules characterize consistency source values storable target values sv defined section 
rules rules characterize consistency source target values recall target values addresses 
precisely rules rule see significance idea representing rest computation effect get ae claim consistency values region ae allowed ae denotes garbage 
rule pdom ae value stored address consistent source value described rules 
recall pdom abbreviates dom dom 
rule says consistency environments pointwise extension consistency values 
rule straightforward 
rule note te occur rule invent te justify target expression compilation result source expression 
environments consistent te 
region environment may regarded region environment force closures applied saw earlier necessarily region environment force target closure created rule 
purpose soundness theorem clearly need know related turns suffices require agree 
condition frv ensures target closure contains free region variables premises rule ensure fpv dom closure contains free program variables 
hygiene useful proofs specifically lemma 
rule similar rule deals recursion 
premises satisfied te domain 
recursion handled unfolding source language semantics ff 
hx fig consistent just 
rule similar rule relates recursive closures region function closures compound type schemes 
simple type schemes uses rule rules 
types storable values sv int int ae te ae ae fput ae te agree frv dom ae hx ei hx te ae ae fput ae te ff 
hx fig agree frv dom ae hx fi hx type schemes storable values oe ae sv te ff 
oe ae ae ae fput ae oe ae delta delta ff delta delta deltaff ffl delta delta bv oe fv te ae agree frv dom fae ae te ff 
oe ae ff 
hx fig oe ae hx fi hae ae ae sv ae sv type schemes addresses oe ae ae pdom oe ae oe ae get ae oe ae environments te dome te te relation defined maximal fixed point operator means powerset defined theta theta val theta store theta theta effect theta theta regvar theta val theta store theta theta effect theta theta regvar theta val theta store theta theta effect theta theta env theta store theta theta effect members referred consistency claims 
fl range claims gamma range sets claims 
example claim form oe ae sv read claimed storable value sv consistent source value type scheme oe resides ae store region environment respect effect 
note complete lattice 
define operator 
definition expressed syntax inference rules equally expressed non recursive definition cases gamma gamma defined unique set ffl fl gamma inferred inference rules rules similar rules shall explain 
types storable values sv gamma int int ae gamma te ae ae fput ae te gamma agree frv dom ae hx ei hx gamma te ae ae fput ae te ff 
hx fig gamma agree frv dom ae hx fi hx gamma type schemes storable values oe ae sv gamma te ff 
oe ae ae ae fput ae oe ae delta delta ff delta delta deltaff ffl delta delta bv oe fv te ae agree frv dom fae ae te ff 
oe ae ff 
hx fig gamma oe ae hx fi hae ae gamma ae sv gamma ae sv gamma type schemes addresses oe ae gamma ae pdom oe ae gamma oe ae gamma get ae oe ae gamma environments te gamma dome te gamma te gamma operator monotonic gamma gamma implies gamma gamma 
tarski fixed point theorem exists greatest fixed point greatest fixed point greatest set gamma satisfying gamma gamma 
gamma greatest fixed point 
definition take gamma write example mean induction prove properties consistency relation prove set gamma claims consistent gamma gamma suffices prove gamma gamma 
properties consistency section prove important lemmas consistency relation useful proof main theorem theorem address issues safe re deallocated region dead pointers 
lemmas proved special style inductive proof call rule induction 
rule induction rule inductive proof style proof possible inductive proof form resembles ordinary induction depth inference 
scenario set operator monotonic respect set inclusion 
defined finite set inference rules case rules 
gamma maximal fixed point gamma gamma gamma gamma consider lemma states relation theta fl fl fl gamma fl fl fl gamma gamma ffl fl gamma fl fl refer formally members fl gamma consequences lemma 
stated gamma gamma principle induction suffices prove gamma gamma fl exists fl gamma fl fl fl gamma inductive proof organised follows take fl fl gamma fl fl show fl gamma show fl inferred inference rules define premises consequences lemma 
proved case analysis fl note fl fl gamma implies fl inferred application rules define premises gamma note proving fl gamma equivalent inferring fl gamma fixed point rules case rules premises fl consequences lemma fl gamma fl fl 
word inductive proof normal inductive proof depth inference related fixed points fixed point rules rules define name style inductive proof rule induction 
emphasise rule inductive proof proof depth inference inductive proof establishes claims finite proof tree constructed fixed point rules 
preservation consistency lemma states consistency preserved decreasing effect increasing store 
expected easier obtain consistency respect observer observer observes little lot larger store easier contain bits target values consistent source value 
lemma lemma special case lemma lemma agree rng frv similarly forms notice domain need subset domain lemma apply 
crucial proof main theorem case letregion 
store resulting computation involves local regions result removing local regions region variables free variables local regions 
proof prove lemma corresponding statements concerning forms consistency rule induction 
cases inference rules arranged judgement forms 
cases assume agree rng frv types storable values sv assume sv remarks section suffices prove sv inferred rules premises lemma 
recall rules express fixed point premises formulae line rule hold premises rule hold premises rule hold 
deal case turn rule int ae ae sv int 
sv rule 
rule exist ae te inferred premises te ae ae fput ae te agree frv dom ae hx ei sv hx agree obviously agrees rng frv claim te consequence lemma 
rule sv desired consequence lemma 
rule similar previous case 
type schemes storable values oe ae sv assume oe ae sv inferred rule rule 
case rule similar case rule 
consider case rule 
oe takes form ae sv claim ae sv lemma 
rule oe ae sv required premise ae sv consequence lemma 
type schemes addresses oe ae assume oe ae inferred rule rule 
case analysis strictly speaking say claim te consequence lemma chosen formulation easier read adopt 
get ae get ae exist ae pdom oe ae ae give pdom claim oe ae consequence lemma claim oe ae consequence lemma 
rule gives oe ae premise consequences lemma 
get ae oe ae rule 
environments te case rule straightforward 
region renaming order prove re old regions safe lemma shall want rename region variables occur free semantic object occur free effect rest computation region variables occur free effect rest computation 
region substitution 
yield written yield set fs ae ae supp definition semantic object effect substitution 
say region renaming respect frv injective supp yield frv supp supp 
general case implies substitutions reason map region variables set frv frv variables free making consistency harder achieve 
special case holds lemma region renaming respect 
similarly consistency judgement forms 
intuitively far concerned region variable ae frv frv denotes garbage region different garbage region 
proof rule induction consistency judgement forms 
cases ordered judgement forms 
types storable values sv assume region renaming respect sv rules rule int ae ae sv int 
sv 
rule exist te ae te ae ae fput ae te agree frv dom ae hx ei sv hx 
reason introducing clear 
prove sv wish find te satisfying te ae ae fput ae te agree frv dom sv hx claim consequence lemma 
comparing tempting idea simply apply 
necessarily region renaming te necessarily consequence lemma 
fae ae frv te fae ae distinct new region variables new sense fae ae frv 
fae 
ae ng te te 
region renaming te respect 
defined follows 
dom frv 
inferred rule frv frv te 
injective frv 
region variable ae frv exists region variable ae frv ae ae define ae ae 
definitions hx hx equal 
lemma fact ae ae obtain desired 
notice agree region renaming respect 
holds 
lemma te 
region renaming te respect claim consequence lemma desired 
rule gives sv desired 
rule identical previous case ff 
hx fig hx fi hx ei 
conclude rule rule 
type schemes storable values oe ae sv assume oe ae oe ae region renaming oe ae respect oe ae sv rules rule exist te ae ae ff ff ffl ffl te ff 
oe ae ae ae fput ae oe ae delta delta ff delta delta deltaff ffl delta delta bv oe fv te ae agree frv dom fae ae te ff 
oe ae ff 
hx fig hx fi sv hae ae previous cases necessarily region renaming te ff 
oe ae fae old ae old fae ae frv te frv oe ae 
fae new ae new distinct new region variables new sense fae new ae new frv oe ae 
fg fae old 
ae new ae old 
ae new fg 
region renaming fae ae te ae respect te te 
lemma te ff 
oe ae ae ae fput ae ae ae identity type effect variable oe ae delta delta deltas ae ff delta delta deltaff ffl delta delta fs ae ae fff ff fffl ffl mg fv te ae injective frv fae ae te ae 
define follows 
dom frv fs ae ae rule get frv frv te ff 
oe ae 
ae exists unique ae frv ae ae ae ae 
closures hae ae hs ae ae equal 
agree 
agree frv dom fs ae ae lemma agree get te ff 
oe ae ff 
hx fig notice region renaming te ff 
oe ae respect 
get get claim te ff 
oe ae ff 
vg consequence lemma 
rule oe hx fi hs ae ae desired result rule rule oe simple takes form ae sv 
claim ae sv consequence lemma 
oe ae sv desired 
cases remaining rules rules straightforward 
ut region allocation consistency general preserved increasing effects decreasing stores 
example addresses fae 
rg int ae fg fget ae store empty 
point need increase effects case main proof concerning expressions form letregion ae starting assumption form te wish extend new region yielding fr 
fgg increase fput ae get ae get put effects representing effects new region able claim fae 
rg te fput ae get ae possible trivial region may earlier may dead pointers old region named 
extend observing effect region variable free type environment consistency really preserved lemma te ae frv te dom frv fae 
rg te fr 
fgg 
similarly forms proof proof rule induction 
assume frv dom brevity fr 
fgg 
case analysis case rules 
types storable values sv assume ae sv ae frv ae rules rule sv int int 
fae 
rg ae sv rule 
rule inferred premises te ae ae fput ae te agree frv dom hx ei sv hx loss generality assume ae frv te ae frv te 
ae fresh region variable fresh sense ae frv te 
consider substitution fae 
ae lemma te ae ae fput ae region renaming te respect lemma gives te region environment defined follows 
ae dom domain dom dom fae values ae ae ae ae ae ae ae ae sv hx frv dom sv sv equal frv dom 
agree ae ae free 
lemma te assume holds 
claim fae 
rg te lemma 
fae 
rg fae 
rg agree rule fact frv dom fae 
rg get fae 
rg ae sv sv hx fae 

rule frv frv te ae frv 
sv sv equal desired result 
rule similar previous case 
type schemes storable values oe ae sv assume oe ae sv ae frv oe ae rules rule oe compound exist te ae ae ff ff ffl ffl te ff 
oe ae ae ae fput ae oe ae delta delta ff delta delta deltaff ffl delta delta bv oe fv te ae agree frv dom fae ae te ff 
oe ae ff 
hx fig hx fi sv hae ae case rule may assume ae frv te fx 
oe ae loss generality 
get claim fae 
rg te ff 
oe ae ff 
hx fig consequence lemma 
fae 
rg fae 
rg 
agree rule oe ae hae ae rule frv frv te ff 
oe ae 
gives ae frv ae fae ae sv hae ae equal really desired result 
rule oe simple 
write oe form ae frv ae 
rule ae sv 
claim fae 
rg ae sv consequence lemma 
fae 
rg oe ae sv rule 
type schemes addresses oe ae assume oe ae ae frv oe ae rules rule ae pdom oe ae fae 
rg ae ae dom pdom 
claim fae 
rg oe ae consequence lemma 
rule fae 
rg oe ae desired 
rule get ae ae ae get ae fae 
rg oe ae rule 
environments te case rule straightforward 
ut lemma te te ffflg 
similarly forms proof straightforward inductive proof 
recursion source target languages handle recursion differently 
source language closure time recursive function applied see rule 
target language closure recursive function contains pointer back see rule 
prove correctness translation show representations consistent point create cycle store 
lemma te oe compound type scheme ae ff ffl bv oe fv te ae te ff 
oe ae ae ae fput ae agree frv dom frv ae ae dom dom te ff 
oe ae ff 
hx fig 
ae ig ff 
proof te te ff 
oe ae ff 
hx fig ff 

ae ig 
lemma suffices prove te proof induction 
oe ae hx fi ae oe ae hx fi te gamma gamma fq show gamma gamma 
consider turn 
gamma oe ae ff ffl bv oe fv te ae te ff 
oe ae ae ae fput ae agrees frv dom frv ae gamma rule 
get ae gamma rule 
assume get ae 
agree ae ae dom gamma gamma rule 
lemma te te 
dom te dom dom dom te te te 
gamma gamma rule 
proof correctness translation section proof theorem 
proof depth derivation inner induction depth inference te 
cases rule dynamic semantics source language 
cases inner induction consists base case te inferred syntax directed rules rules plus inductive step rule applied 
turns inner inductive steps independent start doing 
deal syntax directed cases 
cases assume te te connects agree frv inner inductive step rule applied assume takes form te letregion ae inferred rule premises te fput ae get ae ae frv te lemma choose ae ae frv 
ae frv te 
address satisfying dom 
fae 
rg fr 
fgg 
lemma get te fae 
rg 
connects agree frv inner induction applied exist nn frg 
rule gives letregion ae note agree ae frv 
rng frv 
lemma get required 
inner inductive step rule applied assume inferred rule premises te ffl fev te 
lemma get te connects agree frv dom 
inner induction exist desired 
syntax directed cases constant rule connects fput ae agree fput ae ae exists dom 
take dom 
rule ae 

cg 
letting 
cg furthermore get int ae desired 
variable rule cases depending te associates simple compound type scheme variable 
deal turn variable simple type scheme assume inferred rule 
variable te oe simple oe 
type oe 
evaluation rule 
dom 
letting desired 
rule oe desired recall identify 
variable compound type scheme assume obtained rule 
variable form ae ae te sae sae inferred application rule premises te oe oe ae delta delta ff ffl oe fget put inferred rule 
dom te oe 
get definition rules gives pdom recursive closure hx hae ae furthermore exist te ff ff ffl ffl te ff 
oe ff 
vg te ff 
oe fput bv oe fv te agree frv fae ae loss generality assume ae ae chosen satisfy fae ae frv dom 

offset dom 
fae 
ae kg sv hx notice ae exists 

svg 
follows rule ae ae desired 
remains prove consult rules concerning get done 
get pdom required rule 
remains prove sv te te ff 
oe inferred rules equally te fput fae ae frv get agree lemma get te ff 
vg get frv rule hx desired 
lambda abstraction rule assume inferred rule takes form te fput inferred rule yielding hx ei connects dom 
offset dom 
fv 
hx ig 
rule notice te lemma 
frv 
rules required 
application non recursive closure rule inferred rule premises te ffl gamma gamma gamma 
te fffl get inferred rule premises hx fx 
fffl get effect remains computation note get te connects agree get frv frv induction exist ffl gamma gamma gamma 
notice get definition tells pdom exist te hx te ffl gamma gamma gamma 
fput te agree frv fffl get effect remains computation lemma furthermore lemma te get connects agree induction exist te te fx 
inferred rules 
exists te lemma 
lemma te lemma get fx 
fx 
combining get te get connects agree induction exist get desired 
lemma desired 
application recursive closure rule case similar previous case include sake completeness 
rule exist ffl te ffl gamma gamma gamma 
te fget fflg assume inferred application rule premises hx fi ff 
fx 
induction time split effect fget fflg te connects agree frv frv induction exist ffl gamma gamma gamma 
notice get rules rules pdom exist te hx te ffl gamma gamma gamma 
fput te ff 
agree frv induction second time split remaining effect fget fflg lemma 
lemma te imply connects agree induction exist te te fx 
inferred rules 
exists effect te lemma te ff 
ff 
fx 
fx 
te get agree get connects induction exist rule gives desired 
lemma gives desired expressions rule assume inferred rule takes form te inferred rules premises te te fx 
fx 
effect remains evaluation note te connects agree frv frv induction exist lemma get lemma get te combining get te fx 
fx 
fx 
connects agree induction exist fx 
desired results 
rule get desired letrec rule case takes form te letrec letrec ae ae inferred application rule premises te ff 
ae delta delta ffl fv ff ae ffl fv te te ff 
oe ae ae delta delta oe ff ae ffl inferred rule premise ff 
hx fig inferred rules fput dom 

offset dom 

ff 
fv 
hae ae ig 
lemma te ff 
oe te te ff 
oe ff 
hx fig 
frv fae ae frv lemma te lemma get te get connects agree induction exist rule get letrec ae ae desired results 
concludes proof theorem 
algorithms algorithms implementing region inference rules ml kit described 
shall give brief overview 
ordinary ml type inference performed milner algorithm extended core ml 
output phase explicitly typed lambda term say 
region inference done phases 
decorated fresh region effect variables region effect variable required explicitly typed version fully region annotated target expression 
phase called spreading 
spreading recursive function type scheme oe ml say general type scheme oe oe ml projection sense section 
example letrec bound int int function type scheme ae ae ffl int ae ffl gamma gamma int ae 
spreading phase performs unifications suggested inference rules 
example occurrences rule suggest unification types places operator operand 
spreading employs rules aggressively possible application rules 
resulting program call annotated regions fact type schemes assumed recursive functions may general compared type schemes inferred lambda expressions define functions 
second phase called fixed point resolution takes input 
recursive function region inference steps unification iterated general type schemes recursive functions till fixed point reached 
similar spirit mycroft algorithms full polymorphic recursion mycroft 
possible extend notion principal unifiers types notion principal unifier region annotated types region annotated types contain effects 
relies invariants arrow effects outlined section 
prove types underlying ml type general unifier provided arrow effects satisfy invariants 
reason separation spreading fixed point resolution takes care iteration handle polymorphic region recursion terminate 
particular danger arrow effects grow larger fresh region effect variables generated 
division spreading fixed point resolution solves problem generating fresh variables spreading phase 
shown second phase terminates 
approach give principal types cases function fixed point resolution responsible forming type schemes refused opportunity quantify region effect variables permitted inference rules 
happens implementation simply prints warning possible loss principal types continues principal type scheme 
fortunately happens infrequently practice soundness result shows correctness derivations te safety violated 
language extensions section outline extensions region inference rules order handle exceptions recursive datatypes ml kit 
assume primitives ref creating dereferencing assignment respectively 
purpose region inference treated variables type schemes ref ae ffl ff ae ffl fput ae gamma gamma gamma gamma gamma gamma gamma ff ae ref ae ae ffl ff ae ref ae ffl fget ae gamma gamma gamma gamma gamma gamma gamma ff ae ae ae ae ffl ff ae ref ae ff ae ae ffl fput ae put ae gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma unit ae interesting assignment 
new contents represented pointer word value unboxed representation 
assignment updates pointer word 
put effect region resides 
assignment copy stored value 
assignment constant time operation downside old new contents regions see occurrences ae type 
values boxed representation different contents kept alive long live 
functional programs serious problem side effects expect reasonable memory usage long relatively 
long lived contain boxed values assigned freshly created contents hostile region inference 
exceptions approach simple minded exception values put global regions 
evaluation exception declaration gives rise allocation global region 
application unary exception constructor argument forces argument global regions 
constructs may exception values unary exception constructors gets space leak space leaking region ae contains constructed exception values 
uses nullary constructors going allocation evaluation exception declaration 
recursive datatypes far type constructor paired region variable 
values recursive datatypes additional region variables called auxiliary region variables associated type constructors 
example consider declaration list datatype datatype list nil list region annotated version type ff list takes form ff ae list ae ae ae stands region contains list elements ae contains spine list constructors nil ae auxiliary region contains pairs applied 
lists kept boxed region ae cons cell takes words tag saying am cons second pointer pair applied 
region ae called auxiliary holds values internal datatype declaration auxiliary region type constructor product type formation constructor datatype 
occurrences type constructor declared put region 
receives type ae ae ae ff ff ae ff ae list ae ae ae ffl fput ae gamma gamma gamma gamma gamma gamma gamma ff ae list ae ae sequential datatype declarations pose interesting design problem datatype int datatype datatype delta delta delta datatype gamma gamma delta delta delta declaration give occurrences gamma righthand side different regions 
gives regions introduces unnecessary sharing gives different regions number auxiliary region variables grows exponentially potentially leading slow region inference 
third possibility put limit number auxiliary region variables allow 
chosen second solution spreading regions possible systematic empirical study different solutions conducted 
strengths weaknesses region inference rules implemented prototype system tofte talpin ml kit birkedal :10.1.1.24.9456
systems garbage collection 
section records experience gained systems special emphasis details region inference rules influence memory management 
illustrate consequences region inference rules series small complete examples 
report results larger benchmarks run ml kit 
standard ml syntax milner 
roughly fun translated letrec val 
small examples examples grouped general point intended 
polymorphic recursion generally speaking polymorphic region recursion favours recursive functions balanced call tree opposed iterative computation call tree list 
illustrate examples 
exponential version fibonacci function fun fib fib fib val fib fib due region polymorphism recursive calls fib different regions local body see 
memory usage appears 
example called reynolds birkedal depth search tree predicate record path root node :10.1.1.24.9456
datatype tree lf br tree tree fun mktree lf mktree val mktree br fun search lf false search br true search fn 
orelse max inf reg max fin reg max stack final ii iii iv fib appel appel reynolds reynolds string string memory usage running sample programs ml kit regions version maximal space bytes variable size regions region page bytes ii maximal space bytes fixed size regions iii maximal stack size execution bytes iv number bytes holding values computation regions stack data variable sized regions orelse search fn 
orelse val reynolds search fn 
false mktree due polymorphic recursion recursive call search put closures fn 
orelse region space usage proportional depth tree 
leads memory utilisation 
contrast consider order variant called reynolds uses list represent path 
obtained replacing search function reynolds fun member false member rest orelse member rest fun search lf false search br member true search orelse search val reynolds search mktree saw section region inference distinguish list tail cons cells node tree put region 
gives poor memory utilisation difference reynolds exponential depth tree 
generally connection recursive datatype count polymorphic recursion separate life times value type values type contained tail recursion common pattern computation iteration 
best implemented recursive function type scheme takes form ff ae ffl ffl gamma gamma 
note argument result types region annotation 
function called region endomorphism 
write simple loop sum numbers fun sum acc sum acc sum acc val sumit sum ml functions principle takes argument case tuple implemented ml kit 
think pairs pile region analysis called storage mode analysis birkedal discovers region reset just pair written fact region contain pair :10.1.1.24.9456
memory usage independent number iterations example 
contrast non tail recursive version fun sum sum sum val sum sum uses stack space proportional number iterations 
program appel variant program appel fun nil fun length length xs length xs val fun val length val appel nil nil uses space theta theta 
problem iteration list length created put fresh region passed recursive call uses list compute list stays live till recursive call rule tell bound allocated evaluation body cure case polymorphic recursion fun val length true val appel nil storage mode analysis discover region containing entire list reset iteration tail call optimisation recursive datatypes 
transformation indirect way instructing region inference algorithm want polymorphic recursion optimiser eliminated conditional desired effect 
probably better allow programmers state intentions directly 
memory consumption 
higher order functions function lambda bound region polymorphic rule 
example consider fun foldl acc acc foldl acc xs foldl acc xs fun concat foldl op fun blanks blanks blanks val val string concat blanks despite fact foldl region polymorphic lambda bound applications concatenation operator concat put results region leading theta space usage 
obtain theta space usage specializes foldl resulting function turns region endomorphism fun concat acc concat acc xs concat acc xs fun concat concat fun blanks blanks blanks val string concat blanks larger benchmarks number benchmarks new jersey standard ml benchmark suite ported kit compared space time usage execution stand programs standard ml new jersey version 
largest benchmark simple lines program originally arrays floating point numbers extensively 
run kit support arrays arrays translated lists ported program probably indicative write program arrays start 
life lines uses lists extensively mandelbrot lines uses floating points extensively knuth bendix lines extensive dynamic allocation data structures represent terms 
initially programs space running kit example shows region profile original version knuth bendix benchmark produced region profiler 
region profiler pinpoint program points responsible space leaks 
source program changed region friendly 
interestingly transformations region inference sml nj see knuth bendix example 
surprising static analysis able infer shorter lifetimes may values need live shorter time garbage collection 
region profile improved knuth bendix completion shown see comparison sml new jersey version 
automatic program transformation apart functions deliberately written region endomorphisms general rule regions separated better aggressive re cycling memory possible 
kit performs optimisations separate regions 
include replacing cases syntactic value occurs value denoted larger constant 
optimisation implemented specialisation curried functions string example kit attempt turn functions region endomorphisms thing string 
matter principle kit avoids optimisations lead increased memory usage 
useful ability region inference suggest space leaks may expected 
function compound type scheme ae ff ffl ffl gamma gamma 
contains atomic effect form put ae ae bound region variables ae quite possibly space leak call rp ps region profiling fri jul inf inf inf fin fin inf inf inf inf inf inf inf inf inf inf inf inf seconds bytes maximum allocated bytes regions 
region profile knuth bendix optimisations 
region ae unbounded size indicated inf picture responsible space leak 
additional profiling reveals single program point application exception constructor constant string responsible values region 
rp ps region profiling fri jul inf fin fin inf inf inf fin fin inf inf inf stack inf inf inf inf inf inf seconds bytes maximum allocated bytes regions 
region profile knuth bendix optimisations time time space space kit sml nj kit sml nj mandelbrot orig 
life orig 
life impr 
knuth bendix orig 
knuth bendix impr 
simple orig 
comparison stand programs created ml kit hp pa risc code generator sml new jersey respectively 
orig means original program impr means improved region inference 
times user time seconds hp measured unix time command 
space maximal resident memory kilobytes measured top includes code runtime system 
values average runs 
function put value region external function 
addition ae occur free reason concern value part result function 
words function side effect implementation level 
easily happen side effects source program 
cases implementation simply issues short warning 
turns useful practice 
usage inferred information ability detect dead code 
consider rule letregion rule 
put ae get ae value put ae 
example detect functions fun fun fn 
fn 
shown previous examples case ml program automatically runs stack regions 
program region friendly style aided profiling tools find space leaks 
programming regions different usual ml programming relies garbage collector memory management 
hand region discipline offers feel attractive combination convenience expressive programming language ability reason time space performance programs 
relationship model regions concrete implementation close model combined profiling tools mentioned earlier tune programs resulting space efficient programs executed written added costs unbounded size 
acknowledgments impossible assess practical region inference rules software developed ml kit regions development team 
lars birkedal wrote compiler region annotated lambda terms runtime system martin elsman niels extended hp pa risc code generation including register allocation instruction scheduling 
magnus developed multiplicity inference inferring region sizes 
niels implemented region profiler 
peter sestoft peter bertelsen conducted thorough tests system improved storage mode analysis 
author wishes thorup bob paige generously providing algorithmic specifically graph algorithms input important detailed design implementation region inference algorithms kit 
depth search algorithms section suggested john reynolds 
wish referees constructive suggestions comments 
aiken fahndrich levien 
better static memory management improving region analysis higher order languages 
proc 
acm sigplan conference programming languages implementation pldi pages la jolla ca june 
acm press 
appel 
compiling continuations 
cambridge university press 
baker 
list processing real time serial computer 
communications acm april 
baker 
unify conquer garbage collection updating aliasing 
functional languages 
proceedings acm conference lisp functional programming pages june 
birkedal tofte 
region inference von neumann machines region representation inference 
proceedings rd acm sigplan sigact symposium principles programming languages pages 
acm press january 
gifford jouvelot sheldon 
fx manual 
technical report mit lcs tr mit laboratory computer science sept 
damas milner 
principal type schemes functional programs 
proc 
th annual acm symp 
principles programming languages pages jan 
dijkstra 
recursive programming 
numerische math 
rosen programming systems languages mcgraw hill 
elsman 
optimizing backend ml kit stack regions 
student project department computer science university copenhagen diku july 
georgeff 
transformations reduction strategies typed lambda expressions 
acm transactions programming languages systems oct 
hudak 
semantic model counting abstraction 
acm symposium list functional programming pages 
jouvelot gifford 
algebraic reconstruction types effects 
proceedings th acm symposium principles programming languages popl 
inoue 
analysis functional programs detect run time garbage cells 
acm transactions programming languages systems 
knuth 
fundamental algorithms volume art computer programming 
addison wesley 
lieberman hewitt 
real time garbage collector lifetimes objects 
communications acm june 
lucassen gifford 
polymorphic effect systems 
proceedings acm conference principles programming languages 
lucassen 
types effects integration functional imperative programming 
phd thesis mit laboratory computer science 
mit lcs tr 
milner 
theory type polymorphism programming 
computer system sciences 
milner tofte harper 
definition standard ml 
mit press 
mycroft 
polymorphic type schemes recursive definitions 
proc 
th int 
conf 
programming lncs 
peter naur ed 
revised report algorithmic language algol 
comm 
acm 
murtagh 
lifetime analysis dynamically allocated objects 
proceedings th annual acm symposium principles programming languages pages january 

talpin 
theoretical practical aspects type effect inference 
doctoral dissertation may 
available research report emp cri ecole des mines de paris 

talpin jouvelot 
polymorphic type region effect inference 
journal functional programming 
tofte 
talpin 
theory stack allocation polymorphically typed languages 
technical report diku report department computer science university copenhagen 
tofte 
talpin 
implementing call value lambda calculus stack regions 
proceedings st acm sigplan sigact symposium principles programming languages pages 
acm press january 
index index refers sections concepts introduced 
example entry region name means notion region name introduced sections appears meta variable ranges region names 
region arguments type schemes modification finite maps restriction finite map nn restriction store fin finite maps oe ml ml see instance function abstraction ff see type variable ff sequence type variables fl see claim consistency gamma set claims gamma maximal fixed point ffl see effect variable ffl sequence effect variables ffl see arrow effect ae see region variable ae sequence region variables type oe type scheme ml ml type oe ml ml type scheme hx ei hx fi hx ri hae delta delta ri see closure te ml ml type rules source evaluation source expressions evaluation target expression te region inference rules addr see address address addr theta offset agreement region environments arrow effect ffl allocation directive bv bound variables type scheme see integer constant domain consistency induction claim consistency fl closure dynamic semantics source language hx ei hx fi target language hx ri hae delta delta ri connecting effect store consistency dom domain finite map see environment effect see effect variable effect variable ffl atomic effect substitution env see environment environment see type environment region environment dynamic semantics source env var fin val dynamic semantics target var fin addr type schemes see program variable monotonic operator sets claims fev free effect variables fpv free program variables frv free region variables ftv free type variables fv free type region effect variables get get effect instance source language oe ml target language oe integer constant letregion see offset projection offset see region variable powerset constructor planar domain store pdom program variable put put effect see region name see region environment see region environment see region name region offset fin see region region see region region allocation region environment regvar fin region function closure hae delta delta ri see closure region name region renaming region substitution region variable ae rng range finite map sexp source language te type environment te ml ml type environment texp target language see store see substitution see effect substitution see region substitution see type substitution store see store store store fin region see value storable substitution support supp sv see value storable see environment see value tyvar see type variable type type place type theta regvar see type place type environment te var fin theta regvar type scheme oe type substitution type variable ff type place val see value value source language val storable sv target language addr see environment target language see program variable yield yield appendix example address code address code ml kit produces way hp pa risc code example section shown 
temporary variables start fixed registers stack pointer sp function call return 
example compiler discovers regions represented stack cases letregion translate calls runtime system procedures resemble lightweight malloc free operations 
label main 
allocate global region rho 
letregion rho rho move sp sp rho offset sp sp move sp rho offset sp sp app non tail call operator letregion rho eliminated record move allocate storage record move represents store component record move represents store component record tag move save address record result record scope move allocate storage closure fn 
lab store code pointer closure move save free variable closure move save free variable rho closure move save address closure result letregion rho eliminated operator operand move represents operand push lab push return address move move fetch code address closure jmp label return address move app offset sp sp letregion rho offset sp sp letregion rho halt label code function fn 
record move allocate storage record rho access variable extract component record 
store component record move access variable store component record tag move save address record result record return pop jmp 
