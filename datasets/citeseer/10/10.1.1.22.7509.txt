lisp symbolic computation international journal fl kluwer academic publishers manufactured netherlands reasoning programs continuation passing style amr sabry sabry cs rice edu matthias felleisen matthias cs rice edu department computer science rice university houston tx keywords calculus calculus continuation passing style cps transformations inverse cps transformations calculus 
plotkin calculus call value programs weaker fij calculus programs continuation passing style cps 
identify callby value axioms correspond fij cps terms define new cps transformation inverse mapping interesting right 
new cps transformation determine precise language cps terms closed fij transformations call value axioms correspond called administrative fij reductions cps terms 
inverse mapping map remaining fi equalities cps terms axioms call value terms 
pure constant free set terms resulting set axioms equivalent moggi computational calculus 
call value language includes control operators abort call current continuation axioms equivalent extension felleisen calculus equational subtheory talcott logic 
contents compiling continuations calculi semantics origins practice cps original encoding universe cps terms compacting cps transformation article revised extended version conference title 
technical report title contains additional material 
authors supported part nsf ccr texas atp 
sabry felleisen pass cps transformation cps transformation administrative source reductions reductions cps language cps inverse transformation gamma composing gamma equational correspondence pure language completeness soundness equational correspondence non local control operators extended language semantics cps language inverse translation equational correspondence realistic language core scheme cs cps language cs equational correspondence summary results example coroutines continuations original program simplifying program research proofs reasoning programs continuation passing style list definitions equational correspondence fischer cps transformation administrative cps reductions fi cps transformation cps transformation size terms evaluation contexts reductions fi lift fi flat cps language cps inverse cps transformation gamma normal forms cps transformation control operators cps language cps callcc inverse cps transformation control operators gamma list figures coroutines continuations 
source reductions df fj fi lift fi flat fi id fi omega correspondence reduction steps 
axioms fc current elim lift abort tail 
additional axioms cs additional axioms cs theory cs theory cs pseudo coroutine code 
sabry felleisen 
compiling continuations compilers higher order applicative languages continuationpassing style cps transformation generate intermediate representation :10.1.1.15.8355
cps intermediate language desirable properties ffl language consists basic primitive operations procedure applications semantics independent parameter evaluation technique optimizations sequences fi reductions 
ffl exposes control flow program complicated control facilities source language exception handlers call continuation translated simple procedures manipulate continuation arguments non standard ways 
ffl constitutes assembly language standard reduction sequence mimics behavior typical target machines 
cps transformation global transformation affects subexpression program 
restructures programs extent original aspects 
transformation obscure analysis optimizations rely execution paths having matching call return pairs private communication hans boehm october 
reasons fair number compilers usually called direct compilers rely cps intermediate representation 
choice compilation strategy significant classes compilers performed optimizations 
important class optimizations expressible framework cal cps compilers advantage 
cps compilers full calculus reductions perform optimizations direct compilers apparently rely weaker calculi calculus calculus 
naturally ask optimizations cps compilers perform performed direct compilers 
technical terms set call value axioms corresponds fij reductions cps terms 
set cps compilers report optimizations terms original program direct compilers benefit performing optimizations correspond fij reductions cps programs 
reasoning programs continuation passing style main technical result identification axioms call value languages correspond fij ffi reductions cps programs 
order simplify technical exposition focus pure constant free call value language 
specifically strengthen plotkin translation theorem cf 
theorem identifying axiom set fi fij cps cps strategy identification axioms consists steps 
develop new cps transformation produces canonical form cps programs 
new transformation provides simple characterization cps language closed fij reductions 
identifies subset call value axioms 
second develop inverse transformation maps canonical cps programs back original language 
danvy lawall convincingly argue translation cps direct terms useful right 

studying connection cps transformation inverse mapping systematically derive remaining axioms set resulting calculus variant moggi untyped computational calculus 
complete treatment relationship programs cps transforms analyze language control operators language facilities continuations conceived 
extend language typical control operators expressible cps framework abort call 
operators suffice express wide variety control abstractions error exits jumps intelligent backtracking coroutines exception handling 
call name languages reductions fij valid source language cps language cps translation create new opportunities equational reasoning page 
cps framework express control delimiting facility prompt 
include prompt language reasons 
current language implementations include facilities 
second cps translation prompt generates expressions longer independent timing parameter evaluation 
consequence associate different semantics cps language call value semantics classic semantics control delimiters call name semantics yields lazy prompt semantics incompatible fij reductions cps language point little practical motivation pursue analysis lazy prompt :10.1.1.42.4772
sabry felleisen addition abort call current continuation extends set cps programs generates new set program equivalences provable fi reductions 
order re establish correspondence source cps calculi extend cps transformation inverse proceed way pure language 
resulting calculus includes reductions calculus equivalent equational subtheory logic impredicative theory operations control abstractions classes 
lisp similar languages include facilities just procedures control operators consider language core scheme includes constants conditionals assignments 
develop theory reasoning core scheme proves equations hold cps framework 
illustrate power theory optimize scheme program implements coroutine facility class continuations 
left program due haynes define coroutine lambda callcc lambda maker lcs resume lambda dest val callcc lambda set 
lcs dest val resume resume maker lambda lcs error fell define coroutine lambda letrec lcs lambda lambda dest val callcc lambda set 
lcs dest val error fell lambda lcs coroutines continuations 
friedman wand result clear understood design steps far complicated necessary 
initialization part coroutine non trivial involves capturing continuation artificial procedure resume assigns proper value local control state lcs 
second program variant folklore avoids clumsy initialization phase immediately returns closure 
new set axioms rewrite left program second 
derivation subject section 
reasoning programs continuation passing style section introduces basic terminology notation calculus semantics 
sections dedicated pure call value language 
section includes short history cps transformations motivates ideas lead new cps transformation section 
inverse mapping subject section 
section identify complete set axioms prove completeness respect fi reductions cps terms 
section extends result language includes non local control operators abort current continuation 
section deals addition constants assignments conditionals 
conclude brief discussion theoretical practical implications directions research 
appendix includes tedious straightforward portions proofs 

calculi semantics language pure constant free functional language 
set terms generated inductively infinite set variables vars includes values applications 
values consist variables abstractions applications terms values vars adopt barendregt chapters notation terminology syntax 
abstraction variable bound variables bound abstraction free set free variables term fv 
term closed free variables 
identify terms modulo bound variables assume free bound variables interfere definitions theorems 
short follow common practice quotient ff equivalence 
write ff equivalent terms term result capture free substitution free occurrences xz 
context term hole place subterm 
operation filling context term yields term possibly capturing free variables process result filling 
variables may captured filling context called trapped variables denoted trap 
sabry felleisen calculi calculus equational theory finite number axiom schemas inference rules 
familiar axiom schemas called notions reduction gamma 
arbitrary fi gamma 
value fi mx gamma 
fv gamma 
fv reduction may applied context yielding context case holes contexts treated placeholders arbitrary term 
reductions sets trapped variables contexts empty cf 
evaluation contexts 
set inference rules identical calculi 
extends notions reduction equivalence relation compatible syntactic contexts gamma 
contexts compatibility reflexivity transitivity symmetry underlying set axioms completely identifies theory 
example fi generates theory fi fi generates theory fi union fi generates theory fij 
general write refer theory generated set axioms theory proves equation write proof inference rule symmetry write gamma gamma 
notion reduction church rosser cr implies exists term reduce gamma gamma 
gamma gamma 
term normal form reductions starting results relate calculi different languages 
provide uniform terminology relationships systems introduce concept equational correspondence 
definition equational correspondence languages calculi respectively 
translation translation calculus equationally corresponds calculus conditions hold reasoning programs continuation passing style 
ffi 

ffi 




correspondence similar correspondence calculus combinatory logic 
third clause left implication refers soundness calculus left implication refers completeness calculus relative 
semantics semantics language partial function eval programs answers 
program term free variables practical languages answer member syntactic category values 
typically eval defined machine manipulates counterparts hardware stacks stores registers examples secd machine cek machine 
equivalent method specifying semantics standard reduction theorem 
standard reduction theorem defines partial function gamma programs programs corresponds single evaluation step machine standard step decomposes program special context leftmost outermost redex inside abstraction ii fills contractum special contexts evaluation contexts definition call value call name variants respectively conceptually hole evaluation context points current instruction fi fi redex 
decomposition redex means current instruction rest computation continuation 
call value language syntax terms reformulated follows values evcont sabry felleisen similar definition exists call name language arguments evaluated function call evaluation contexts include contexts shape 
evaluation contexts definitions standard reduction functions call value call name respectively follows gamma 
gamma 
complete evaluation applies single step functions repeatedly reaches answer diverges 
notation gamma 
denotes reflexive transitive closure relation gamma 
semantics defined follows eval gamma 
call value eval gamma 
call name 
origins practice cps idea transforming programs continuation passing style appeared mid sixties 
years transformation remained part folklore computer science fischer reynolds codified 
subsection briefly reviews original encoding cps transformation 
second subsection analyze universe cps terms called administrative cps reductions 

original encoding fischer studied implementation strategies heap retention strategy variable bindings retained longer needed stack deletion strategy variable bindings destroyed control leaves procedure block created :10.1.1.15.8355
concluded real power lost restricting oneself deletion strategy implementation program translated equivalent correctly implementation page 
origin concept continuation traced back van wijngaarden defined source source transformation eliminates jumps goto instructions program favor procedures return 
reasoning programs continuation passing style translation refers fischer cps transformation 
definition fischer cps vars variables occur argument mn values reynolds investigated definitional interpreters higher order languages 
goals desire definition language parameter passing technique defining language 
developed method transform interpreter indifferent underlying parameter passing technique callby value call name 
transformation essentially transformation fischer 
plotkin proved reynolds ideas correct 
theorem plotkin simulation eval eval indifference eval eval translation fi fi 
implication reversible 
fi fi 
simulation theorem shows evaluation cps program produces correct outputs 
indifference theorem establishes evaluation yields result call value call name 
translation theorem establishes soundness incompleteness fi reasoning cps programs 

universe cps terms interested analysis fij equality cps terms universe discourse consists terms contribute proofs equations fij reynolds transformation continuation second argument procedure 
sabry felleisen notion reduction fij cr suffices consider equations form fij gamma gamma 
universe discourse cps terms set fp fij gamma gamma 
pg unfortunately set includes large terms counterpart source language 
example source reduction gamma 
corresponds derivation cps terms kx ky gamma 
ky kx gamma 
ky kx gamma 
kx gamma 
kx gamma 
kx gamma 
ky gamma 
derivation consists reductions correspond reductions source terms 
new reductions cps terms known administrative reductions 
order give precise definition new reductions modify fischer cps transformation abstractions introduced translation 
reduction abstractions constitutes administrative reduction 
definition fi vars variables occur argument mn reasoning programs continuation passing style values fi reduction administrative reduction involves abstractions gamma 
fi mx gamma 
fv simplify derivation source reductions correspond fij cps terms split problem parts finding source reductions correspond administrative cps reductions section finding source reductions correspond proper cps reductions sections 

compacting cps transformation identify source reductions correspond cps administrative reductions define compacting cps transformation performs administrative reductions output produces terms fij normal form 
subsection formally defines process eliminating administrative reductions output analyzes connection elimination process evaluation cps programs 
second subsection includes new compacting cps transformation illuminates effect administrative reductions 
subsection includes source reductions correspond elimination administrative cps reductions 
subsection includes definition simplified universe cps terms new cps transformation 

pass cps transformation relation combines fischer cps transformation elimination administrative reductions 
definition fij fij normal form 
source term related exactly cps term fij normal form 
proposition relation total function sabry felleisen proof sufficient show unique fij normal form 
fi reductions starting special kind reductions called developments section 
follows unique fi normal form corollary 
term fi normal form fij normal form corollary 
follows unique fij normal form 
words function specifies cps transformation produces terms administrative redexes 
proposition establishes administrative reductions performed order affecting result 
quick look effect standard reduction sequences particularly illuminating 
plotkin standard reduction sequence source program relates standard reduction sequence cps counterpart described diagram ffl gamma 
ffl gamma 
ffl 
ffl ffl ffl ffl ffl ffl 
improved robert harper 
function eliminates administrative cps transformations :10.1.1.42.4772
example applying yields kx 
example steele rabbit transformation danvy filinski transformation yield term xk yk mbk term contains source redexes optimize eliminating source redexes fij xk yk mbk mbk yk yk ka ka kx reasoning programs continuation passing style term result eliminating administrative reductions standard reduction sequence proper reduction 
solid lines represent reduction source redexes dashed lines correspond reduction administrative redexes 
plotkin analysis role administrative reductions locate source redex standard reduction sequence restructure cps program redex occurs top level 
example term df redex standard reduction sequence 
cps conversion elimination administrative reductions get df redex delta delta delta occurs top level 
action lifting redex delta delta delta top level happens naturally cps framework require explicit cps conversion rewrite original program follows gamma 
example suggests administrative cps reductions naturally expressible source language 
investigate exact nature source reductions subsection 

cps transformation specifying function new original way illuminates effect administrative reductions reduction source cps terms directly identify notions reduction source terms perform task administrative reductions 
key insights necessary derive new cps transformation ffl evaluation context syntactic representation continuation cf 
section 
ffl redex standard reduction sequence occurs inside evaluation context cf 
section 
ffl administrative reductions lift redex occurs inside evaluation context top level cf 
section 
sabry felleisen insights develop new compacting cps transformation transformation relies definition set evaluation contexts suitable definition definition generates set section 
definition phi cps transformation uses mutually recursive functions transform terms phi transform values transform evaluation contexts 
vars variables occur argument phi phi phi phi values phi phi evcont transformation complete program 
function parametrized variable represents current continuation 
cps transform values straightforward 
translation generates term unknown procedure applied continuation result applied argument phi 
cps transform conceptually lifts redex outside evaluation context producing converts resulting term cps 
cases translation evaluation contexts continuations intuitive explanation 
cps transformation ck spirit similar cps transformation friedman wand haynes chapter differs significantly formal part 
reasoning programs continuation passing style case term function position result intermediate computation 
cps transformation gives intermediate result fresh name proceeds translation simpler term 
phi defined structural induction relatively easy check functions defined appropriate notion size 
definition size size term jm number variables including binding occurrences 
size context jej number variables including binding occurrences plus 
particular size smaller size empty context replaces application 
size greater size 
proposition verifies outputs identical 
consequence result establishes total function 
proposition 
proof definition suffices establish statements ffl fij 
ffl fij normal form 
ffl unique fij normal form 
claim follows proposition 
proofs claims appendix page 

administrative source reductions reductions function incorporates reduction administrative redexes output fischer cps 
reduce common term administrative reductions identical 
definition function shows cases different inputs mapped output 
proposition verifies cases 
lemma fi lift fi flat evcont vars fv ul fv sabry felleisen proof proof claim straightforward 
proof second claim appendix page 
identity second statement holds modulo decorating administrative abstractions 
characterize effects translation introduce reductions capture effect administrative reductions 
definition reductions fi lift fi flat set axioms contains reductions gamma 
fi lift fv gamma 
fi flat fv lemma shows reductions define equivalence classes source terms map cps term 
point decorating special abstractions irrelevant 
remainder ignore distinction 
cps language equivalence functions specify universe cps terms follows df fp fij gamma gamma 
pg ignoring outermost binding continuation 
context free grammar generates set directly derived right hand sides equations definition 
definition terms cps language application continuation value 
values variables abstractions transform continuations 
continuations variables result application value continuation abstraction transforms value answer 
earlier version erroneously included arbitrary term place variable reasoning programs continuation passing style definition cps grammar cps program cps vars fkg set continuation variables vars vars 
cps answers cps values cps values cps evcont continuations special status reserved variable ensures continuation parameter occurs exactly body abstraction program cps form closed term form special continuation parameter 
working quotient language ff equivalence special status name disappears linearity constraint remains 
theorem establishes definitions cps terms define language 
theorem cps 
proof left right inclusion suffices show output subset cps language closed fij reductions 
omit proof claim 
second claim follows subject reduction lemma lemma 
opposite implication cps suffices show cps exists fij gamma gamma 
proof auxiliary claim appendix page 
complete proof theorem need establish fij reductions cps preserve syntactic categories terms 
lemma subject reduction cps cps values cps evcont 
fij gamma 
implies cps 

fij gamma 
implies cps values 

fij gamma 
implies cps evcont 
proof see appendix page 
lemma implies fij reductions cps terms naturally characterized reductions apply continuations reductions apply values 
sabry felleisen corollary reductions fi cps decomposed reductions apply values fi reductions apply continuations fi gamma 
fi gamma 
fi wk gamma 
kx gamma 
fv 
cps inverse order map cps reductions fi fi reductions source language define mapping cps presenting new transformation subsection study connection cps transformation second subsection 

transformation gamma inductive definition cps language specification inverse cps transformation straightforward source term corresponding evaluation context syntactically represents continuation value corresponds definition gamma phi gamma gamma cps cps values cps evcont gamma cps gamma gamma phi gamma phi gamma cps values values phi gamma phi gamma phi gamma wk gamma phi gamma gamma reasoning programs continuation passing style gamma cps evcont evcont gamma gamma gamma gamma gamma gamma gamma correctness function gamma subject theorem 
part theorem establishes composition gamma respects fij equality 
second part theorem establishes stronger property restricted images terms composition gamma yields identity function 
theorem cps cps evcont 

fij ffi gamma fij ffi gamma 
ffi gamma ffi gamma exists evcont 
proof see appendix page 

composing gamma compacting cps transformation maps members equivalence classes cps term cf 
section 
inverse cps transformation maps cps term back particular element equivalence class element fi lift fi flat normal form 
order establish result define subset fi lift fi flat normal form 
definition language subset includes terms fi lift fi flat normal form 
values evcont omit simple inductive proof elements language fi lift fi flat normal form 
range function gamma included output gamma fi lift fi flat normal form 
sabry felleisen lemma cps cps evcont gamma gamma evcont proof see appendix page 
help lemma specify precise relation cps transformation inverse 
effect composing cps transformation inverse reduce terms fi lift fi flat normal form 
naturally term fi lift fi flat normal form composition yields identity function 
theorem 
fi lift fi flat gamma gamma 
gamma ffi 
gamma ffi exists cps gamma 
proof see appendix page 
put differently theorem asserts reductions fi lift fi flat capture possible equivalences introduced administrative reductions 
cps transforms related administrative reductions eliminates case related axioms fi lift fi flat proposition fi lift fi flat proof assume function gamma maps cps transform source term theorem reduce fi lift fi flat reductions 
follows fi lift fi flat 
equational correspondence pure language partial inverse cps transformation systematically derive set additional axioms fi fi ab complete fij reasoning cps programs 
new axiom set prove soundness second subsection 
subsection briefly discuss correspondence calculi 
reasoning programs continuation passing style 
completeness specified corollary possible fi reductions cps terms fi fi illustrate technique outline derivation reductions corresponding kx gamma 
fv 
applying gamma sides reduction get gamma kx gamma understand left hand side reduce right hand side proceed case analysis ffl reduction gamma 
empty context generally stands arbitrary term extended set axioms contain reduction gamma 
fi id ffl reduction gamma gamma 
gamma similar argument case add reduction set gamma 
fi omega ffl cases introduce new reductions 
cases reductions cps terms similar 
resulting set source reductions includes previously derived reductions see 
equational theory generated full set gamma 
fi gamma 
fv gamma 
fv fi lift gamma 
fv fi flat gamma 
fi id gamma 
fv fi omega source reductions df fj fi lift fi flat fi id fi omega axioms fi corresponds moggi untyped computational calculus appeared original edinburgh lfcs technical report 
sabry felleisen completeness lemma summarizes connection notions reductions cps new reductions 
lemma completeness cps 

gamma 
fi fi id fi omega gamma gamma gamma 
gamma 

fi gamma 
gamma gamma 

jw gamma 
gamma gamma gamma 
gamma 

fi gamma 
fi fi lift fi id fi omega gamma gamma gamma 
gamma 
proof proof case independent proofs cases 

reduction proof outlined section 

fi reduction definition gamma gamma gamma 

jw reduction applying phi gamma left hand side get term phi gamma equivalent gamma 
show term reduces phi gamma cases ffl reduction reduction zx gamma 
ffl sides reduction identical 
ffl sides reduction identical 
ffl gamma gamma 
gamma reduction 

fi reduction see appendix page 
completeness theorem direct consequence results 
theorem completeness cps 
fij gamma gamma 
fi gamma gamma gamma 
gamma proof pasting proofs completeness lemma 
reasoning programs continuation passing style 
soundness set source reductions sound respect equational theory cps terms 
fact prove stronger results correspondence reduction steps 
lemma soundness 
fi gamma 
fi gamma gamma 


gamma 
jw gamma gamma 


fi lift gamma 


fi flat gamma 


fi id gamma 
gamma gamma 


fi omega gamma 
gamma gamma 

proof proofs fi lift fi flat lemma 
proof fi reductions appendix page 
proofs similar 
soundness theorem summarizes results subsection 
theorem soundness fi gamma gamma 
fij gamma gamma 
proof pasting proofs soundness lemma 

equational correspondence completeness soundness theorems previous sections formulated precise way 
particular theorems relate reduction steps calculus reduction steps calculus 
theorems composition cps transformation inverse imply results 
dotted lines correspond application gamma solid lines represent sequences reductions 
correspondence reduction steps reveals close relation source terms normal form cps terms 
unfortunately correspondence reduction steps relies crucially properties functions gamma appear hold arbitrary cps transformation inverses 
sabry felleisen sw fi fij fi fi lift fi flat fi lift fi flat gamma ffi gamma ffi correspondence reduction steps 
contrast correspondence equalities source cps calculi holds transformations cps satisfy equations fij cps fi gamma transformations straightforward deduce variants theorems relate equalities calculus equalities calculus 
combination theorems implies equational correspondence sense definition 
theorem equational correspondence theory fi equationally corresponds theory fij cps functions satisfying 
formulation calculus fi axioms necessary correspondence reduction steps 
equational correspondence reason distinguish reductions fi flat fi id fi omega summarize reductions reasoning programs continuation passing style axiom fv fi omega axiom fi omega remainder 

non local control operators establishing equational correspondence theorem pure callby value languages turn attention languages control operators 
specifically investigate addition control operators abort call current continuation callcc 
informally permits programmer ignore rest computation return value subexpression result entire program callcc provides programmer procedural abstraction rest computation 
operators manipulate global control state program cps transforms procedures manipulate continuation non standard ways 
consequence cps language includes new terms equational correspondence theorem longer applies 
remainder section formalize ideas conclude version equational correspondence theorem extended language 
development section follows development sections exception 
intermediate results concerned mapping reductions calculus reductions 
intermediate results relate equalities calculus equalities 
point open question results re established reductions opposed equalities 

extended language semantics extension source language functional constants callcc results language callcc callcc providing formal semantics callcc terms standard reductions follow traditional route immediately specify griffin established presence control operators similar callcc standard reductions source terms correspond standard reductions cps terms 
result imply arbitrary sequence reductions calculus correspond sequence reductions calculus 
sabry felleisen translation values cps form translation formal semantics 
extensions consist additional clauses function phi phi callcc phi cps transform callcc procedure expects continuation argument non standard manipulation continuation manifest second argument procedural abstraction continuation 
similarly cps transform procedure expects continuation argument procedure ignores continuation argument immediately returns value argument 
non non standard manipulation continuation 
cps transformation formal semantics source language eval eval phi order simplify discussions proofs cps transformation compacting suited analysis definition 
definition control operators vars variables occur argument phi phi phi phi phi phi callcc phi phi felleisen talcott alternative definitions rely cps transformation 
reasoning programs continuation passing style extensions callcc transformation differs function definition aspect 
new function translates expressions form uniformly values including special clause kind value cps transformation may produce terms administrative redexes 
presence administrative redexes irrelevant affect set reachable cps terms longer concerned mapping reductions calculus reductions calculus 

cps language inverse translation closure output fij reductions yields extension cps language definition 
definition cps grammar cps callcc extended cps terms generated grammar cps callcc answers values continuations vars vars fk vars vars comparison definition explains addition callcc affects set reachable cps terms affects semantics 
intuitively callcc permits programmer label arbitrary points program 
continuation potentially lexically visible point execution program 
extended cps language accommodates fact providing infinite set continuation variables singleton 
addition permits programmer ignore current continuation returning value answer entire program 
extension reflected cps language extending syntactic category answers include values directly 
equivalent way understand effect ignores current continuation uses initial continuation 
may extend syntactic category continuations initial continuation 
cps language closed fij reductions addition initial continuation results programs shape gamma 
extends syntactic category answers values 
inverse cps transformation mapping extended cps language callcc 
sabry felleisen definition cps callcc 
values continuations language gamma phi gamma gamma gamma phi gamma phi gamma phi gamma callcc gamma gamma gamma gamma phi gamma gamma gamma transformation differs function definition aspects 
inverse answer term aborts value phi gamma 
second binding continuation cps language corresponds capture continuation source language 
continuation explicitly invoked 
changes exploit idea due danvy lawall 
discovery call value axioms correspond fij reduc tions cps terms proceeds manner pure language 
resulting axioms consist axioms pure language control specific axioms 
new axioms intuitive explanation 
axiom shows current continuation implicitly applied 
axiom elim garbage collection rule continuations captured collected 
axiom lift characterizes capture continuations callcc axiom abort shows continuations abort context invocation 
callcc axiom implies continuation application indistinguishable continuation body 
operator eliminates evaluation contexts 
set axioms current elim lift abort abort constitute control specific axioms calculus 
full theory fi xc danvy lawall perform counting analysis determine continuation non standard way include callcc necessary 
analysis unnecessary purposes 
outputs inverse transformation provably equal outputs axiom system achieving effect counting analysis 
implementation continuation interpret law imposing tail call optimization faithful implementations 
reasoning programs continuation passing style callcc km callcc current callcc fv elim callcc callcc lift fv callcc callcc fv abort callcc callcc fv tail abort axioms fc current elim lift abort tail 
corresponds restriction theory language callcc relationship function gamma subject lemmas 
lemma establishes cps term fij equal ffi gamma contains free continuation variables lemma proves general result accounts terms free variables 
generalization necessary cps terms 
lemma cps callcc continuation value language 
free continuation variables terms fk 
fij ffi gamma 
fij ffi gamma 
fij phi ffi phi gamma proof see appendix page 
second lemma relates terms gamma ffi axioms pure language control specific axioms 
lemma callcc evaluation context language variable free 
ffl fi xc gamma ffi ffl fi xc gamma ffi proof see appendix page 
sabry felleisen 
equational correspondence establish calculus fi xc proves equations fij prove cps terms 
key lemma completeness lemma 
lemma cps callcc free continuation variables fij implies fi xc callcc callcc gamma callcc callcc gamma proof consider notion reduction separately 

reduction gamma 

proof case appendix page 

reduction wk gamma 
free apply phi gamma gamma sides equation answer value 
ffl answer 
gamma callcc gamma phi gamma phi gamma phi gamma ffl value 
phi gamma callcc gamma phi gamma similar argument preceding subcase applies 

reduction kx gamma 
free gamma kx gamma equal gamma fi omega 
reduction gamma 

proof appendix page 
soundness new axioms subject lemma 
lemma callcc fi xc implies fij 
lemmas imply calculi fi xc fij satisfy equational correspondence theorem 
theorem equational correspondence theory fi xc equationally corresponds theory fij cps functions satisfying 
reasoning programs continuation passing style 
realistic language useful correspondence theorem hold presence programming languages constructs conditionals constants mutable data objects 
address issue consider small typical subset scheme core scheme define subsection 
second subsection introduces cps language core scheme 
previous sections cps language subset result cps equational theory includes axioms just fi subsection discuss different constructs affect correspondence theorems 
development section includes details adapted reader favorite language 

core scheme cs core scheme basic constants include numerals booleans functional constants include operations manipulate basic constants addition operations create access update data structures lists cells 
formal definition extends grammar section true false integer 
add ref deref setref informally integer 
recognizes integers add denotes increment function integer division operator ref creates cell deref returns contents cell setref 
updates contents argument cell value second argument 
set axioms specifies semantics new constructs 
convenience write aef abbreviation delta delta delta setref setref 
ref ref sabry felleisen abbreviation delta delta delta true false add add div div integer 
true int integer 
false int ref aef fv ref ae deref ae deref ae setref 
ae setref ae ae ae ref additional axioms cs sets axioms straightforward set specifies semantics cells 
combination equational theory fi xc new axioms results inconsistent equational system due example show terms true integer 
int integer 
false int avoid consistency problem restrict equational theory source language eliminating reasoning programs continuation passing style 
cps language cs extensions source language cps language subset cps transformation encodes new constructs source language procedures 
encoding proper cps transformation cps language include constructs correspond extensions source language 
set cps terms extends language definition additional clauses true false integer 
add ref deref setref 
semantics new constructs cps language matches semantics corresponding constructs source language 
set axioms specifies semantics precisely 
convenience aef abbreviation ref delta delta delta ref setref 
delta delta delta setref 
free cps language includes constant functional constant source language 
main difference takes additional continuation argument receives result primitive application 
essentially equivalent 
term contrary spirit cps translation cf 
theorem evaluation sensitive parameter passing technique 
example evaluation yields error call value yields call name 
similarly assuming cell contents evaluation term aef deref setref 
yields call value yields call name 
sabry felleisen true false add integer 
true intk integer 
false intf ref aef fv ae deref ae ae setref 
ae ae ae ae additional axioms cs 
equational correspondence setting basic framework define translations cps transformation inverse languages cs cs cps transformation new constructs cs phi phi phi phi phi clause conditionals duplicates evaluation context branches conditional expression 
duplication due reasoning programs continuation passing style factors 
fischer cps transformation conditionals duplicates continuation variable 
second transformation eliminates administrative redexes output fischer cps transformation 
extensions cps language result simple extensions inverse cps transformation gamma phi gamma gamma gamma gamma gamma phi gamma gamma gamma phi gamma phi gamma phi gamma order establish correspondence source cps calculi need prove results similar lemma lemma lemma lemma 
previous results extended immediately eliminate call value equational theory 
furthermore source cps equational theories include additional axioms constants conditionals respectively 
revisiting proofs lemmas establish ffl proof lemma rely ffl proof lemma uses restricted version continuations callcc callcc kx callcc trap callcc xk callcc ax alternative translations cause exponential increase size code ck phi ck ck kk phi ck ck kk translation compilers duplicates entire evaluation context close language fij reductions 
second translation relies allison cps translation keeps local transfer control independent continuation 
sabry felleisen proof requires axiom conditionals lift axiom introduced compacting phase cps transformation administrative call value reduction cf 
definition 
ffl proof lemma shows reductions occur source language result reductions cps terms 
ffl proof lemma shows reductions cps terms occur result reductions source terms 
consequence complete equational theory core scheme cs respect cps language consists previously derived axioms corresponding cps equational theory consists axioms excluding 
summary results full equational theories cs cs figures 
correspondences different axiom systems sublanguages previous sections summarized table 
language call value theory cps theory typed gamma fij callcc gamma fij cs gamma fij cs gamma fij reasoning programs continuation passing style axioms gamma fi fi omega fi lift axioms callcc callcc lift callcc callcc tail callcc km callcc current callcc elim callcc callcc abort abort callcc kx callcc callcc xk callcc ax axioms true false lift add add div div integer 
true int integer 
false int ref aef fv ref ae deref ae deref ae setref 
ae setref ae ae ae ref theory cs left column gives name source language 
language cs simply typed variant cs columns list call byvalue axioms corresponding cps axioms 
names axioms refer definitions figures 
column includes check mark possible extend theories respectively 
rightmost column includes check mark correspondence holds simply typed variant language 
simply typed languages calculi semantically complete respect denotational cps models 
result consequence completeness calculus respect full type structure 
sabry felleisen axioms fij fi fi kx axioms true false add integer 
true intk integer 
false intk ref aef fv ae deref ae ae setref 
ae ae ae ae theory cs 
example coroutines continuations equational theory core scheme cs provides basis semantic manipulation programs programmers programming tools alike 
example programmers may theory evaluate programs symbolic manner prove equivalence programs simplify program series meaning preserving transformations 
subsection includes intuitive explanation program implements coroutines class continuations second subsection includes simplification phase cs axioms 

original program convenience superset core scheme includes assignments variables set various syntactic extensions error df df df fv reasoning programs continuation passing style mn df letrec df set 
original definition coroutines class continuations define coroutine lambda callcc lambda maker lcs resume lambda dest val callcc lambda set 
lcs dest val resume resume maker lambda lcs error fell intuitively procedure coroutine accepts argument contains programmer coroutine code 
example pseudocode implements player hypothetical game 
define player code board board lambda resume shot letrec loop lambda shot shot fatal 
lost game loop resume player compute shot loop shot define player coroutine player code pseudo coroutine code 
procedure resume handles transfer control coroutine 
definition coroutine shows resume takes arguments destination denotes coroutine resumed value passed resumed coroutine 
resuming destination resume saves current continuation local control state lcs active coroutine possible resume current coroutine execution 
sabry felleisen 
simplifying program transformation program proceeds applying axioms cs calculus step 
clarity redex surrounded box 
transformation set 
treated free variable 
alternatively axioms calculus example superfluous 
define coroutine lambda callcc lambda maker lcs resume lambda dest val callcc lambda set 
lcs dest val resume resume maker lambda lcs error fell uses tail define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker resume resume maker lambda lcs error fell uses fi reasoning programs continuation passing style define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker resume callcc lambda set 
lcs maker lambda lcs error fell lift define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker callcc lambda kk resume lambda set 
lcs maker lambda lcs lambda kk resume error fell error fell fi lift applied expansion sabry felleisen define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker callcc lambda kk resume lambda set 
lcs maker lambda lcs lambda resume kk error fell error fell abort define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker callcc lambda kk resume lambda set 
lcs maker lambda lcs lambda resume error fell error fell elim reasoning programs continuation passing style define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker resume lambda set 
lcs maker lambda lcs lambda resume error fell fi define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker resume set 
lcs lambda resume error fell maker lambda lcs fi lift sabry felleisen define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker resume maker set 
lcs lambda resume error fell lambda lcs abort define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val callcc lambda maker maker set 
lcs lambda resume error fell lambda lcs current elim reasoning programs continuation passing style define coroutine lambda lcs resume lambda dest val callcc lambda set 
lcs dest val set 
lcs lambda resume error fell lambda lcs fi define coroutine lambda lcs set 
lcs lambda lambda dest val callcc lambda set 
lcs dest val error fell lambda lcs letrec macro definition define coroutine lambda letrec lcs lambda lambda dest val callcc lambda set 
lcs dest val error fell lambda lcs sabry felleisen 
research equational correspondence theorems establish equational reasoning call value programs powerful reasoning cps counterparts 
consequently cps programming tool performs sequences fij reductions substituted equivalent tool require explicit conversion cps 
applications compilers partial evaluators transformation systems numerous 
example direct compilers chez scheme zinc benefit including reductions cs basic repertoire optimizations 
similarly partial evaluators transformations fi lift fi omega produce residual programs better quality 
set axioms cs base expression simplifier compilers tools extending talcott 
result questions practice transforming programs cps order simplify improve code generators partial evaluators data flow analyzers tools 
fact established code generators typical cps compilers perform implicit inverse cps transformation true intermediate representation typical cps compiler subset source terms fi lift fi flat normal form 
furthermore literature contains claims cps framework improves accuracy data flow analyzers conjecture observed improvements orthogonal passing continuations side effects axioms cs currently investigating relationship cps transformation precision data flow analysis 
acknowledgments carolyn talcott outstanding efforts behalf go far ordinary duties editor 
scheme code typeset dorai sitaram sl referees comments improved presentation results 
proofs proof auxiliary claims proposition page 
ffl fij 
ffl fij normal form 
reasoning programs continuation passing style proof proof induction size argument transformation term refers evaluation contexts extend fischer cps transformation accept evaluation contexts strengthen inductive hypothesis take evaluation contexts account 
extension fischer cps transformation evcont extended function satisfies property state proof ffl fi ffl fi 
prove statements induction size argument ffl fij fij ffl fij normal form 
proof proceeds case analysis possible inputs functions 
fij kf 
cases 
fij normal form 

inductive hypothesis fij fij normal form 
result follows 

fij cases vars jej jgj 
inductive hypothesis fij fij normal form 
argument similar case fij phi phi fij normal form 
result follows phi 
sabry felleisen vars jej jgj inductive hypothesis apply 
inlining arguments cases fij fij normal form 
result follows subcase 

fij result follows inductive hypothesis argument similar case 
fij 
fij normal form 

fij result follows inductive hypothesis 

fij result follows inductive hypothesis 

fij size smaller size 
inductive hypothesis implies fij fij normal form 
fij 
simple case analysis form term new redex created term fij normal form 
proof second claim lemma page 
evcont vars ul fv ul fv proof proof induction size proceeds cases reasoning programs continuation passing style 
identical phi phi right hand side ul ul phi ul phi sides equation differ abstraction terms identical abstraction part administrative redex term 

phi ul phi induction 
phi ul phi induction 
ul 
right hand side ul 
result follows create administrative redex 

ul induction 
ul induction 
ul induction proof auxiliary claim theorem page 
ffl cps exists fij gamma gamma ffl cps evcont exists evcont fij gamma gamma 
sabry felleisen proof proof lexicographic induction element cps element cps evcont number abstractions form jgj size proof proceeds case analysis possible elements cps cps evcont 
cases take 
take 
abstraction form inductive hypothesis exists fij gamma gamma 
take 
inductive hypothesis reachable term take 
inductive hypothesis reachable evaluation context argument similar case reachable value take 

inductive hypothesis reachable evaluation context repeating argument case values reachable respectively 
term 
phi phi gamma gamma 
induction gamma 
fi gamma 
fi 
inductive hypothesis exists reaches repeating argument case exists value reaches take 

take 

inductive hypothesis exists reaches take 

similarly case take evaluation context 

take reaches induction 
proof lemma page 
cps cps values cps evcont reasoning programs continuation passing style 
fij gamma 
implies cps 

fij gamma 
implies cps values 

fij gamma 
implies cps evcont 
proof proof induction structure terms 
cps assume fij gamma 
definition form cps evcont cps values 
kinds reductions possible ffl fij gamma 
gamma 
inductive hypothesis cps evcont cps 
ffl fij gamma 
gamma 
result follows inductive hypothesis 
ffl fij gamma 

simple inductive argument substitution preserves syntactic category 

cps values assume fij gamma 
term variable cps evcont 
ffl fij gamma 
gamma 
result follows inductive hypothesis 
ffl fij gamma 
cps values definition 

cps evcont assume fij gamma 
term variable cases ffl subcases fij gamma 
gamma 
result follows inductive hypothesis 
fij kx gamma 
kx cps evcont definition 
ffl cases fij gamma 
gamma 
result follows inductive hypothesis 
fij gamma 
gamma 
result follows induction 
fij gamma 
inductive argument substitution preserves syntactic category 
sabry felleisen proof theorem page 
cps cps evcont 

fij ffi gamma fij ffi gamma 
ffi gamma ffi gamma exists evcont 
proof proof claim lexicographic induction number abstractions form size element cps cps evcont 
cases ffi gamma 
ffi gamma kx 
ffi gamma ffi gamma induction ffi gamma ffi gamma result follows inductive hypothesis 

ffi gamma ffi gamma phi ffi phi gamma inductive hypothesis fij ffi gamma argument similar case fij phi ffi phi gamma 
ffi gamma ffi gamma phi ffi phi gamma phi ffi phi gamma induction similar case fi 
ffi gamma ffi gamma phi ffi phi gamma phi ffi phi gamma induction similar case reasoning programs continuation passing style 
ffi gamma 
ffi gamma ffi gamma result follows inductive hypothesis 

ffi gamma ffi gamma case similar case 
ffi gamma ffi gamma result follows induction 
proof second part identical excludes cases correspond images source terms 
particular excludes cases image source term body abstraction form excludes cases contain administrative redex image source term 
proof lemma page 
cps cps evcont gamma gamma evcont proof proof lexicographic induction number abstractions form size terms 
proceeds case analysis possible inputs gamma gamma 
gamma gamma phi gamma 
induction gamma evcont remains establish phi gamma values 
phi gamma values 
phi gamma values 
wk phi gamma gamma 
term wk abstraction form inductive hypothesis applies 
gamma shows term phi gamma values 
phi gamma gamma result follows induction 

gamma evcont 
gamma gamma 
result immediate gamma evcont induction 

gamma gamma 
occurs exactly term abstraction 
gamma evcont inductive hypothesis 
sabry felleisen 
gamma gamma result follows induction 
proof theorem page 

fi lift fi flat gamma gamma 
gamma ffi 
gamma ffi exists cps gamma 
proof order prove claim strengthen statement follows 
fi lift fi flat gamma gamma 
gamma ffi fi lift fi flat gamma gamma 
gamma ffi proof induction size proceeds cases 
subcases gamma ffi 
gamma gamma 
gamma ffi induction gamma ffi 
gamma ffi gamma ffi phi gamma ffi phi cases ars jej je inductive hypothesis applies gamma gamma 
gamma ffi 
result follows gamma gamma 
phi gamma ffi phi case 
ars cases depending structure gamma ffi ii 
result follows induction 
iii 
gamma 
fi lift gamma gamma 
gamma ffi gamma ffi reasoning programs continuation passing style iv 
gamma 
fi flat gamma 
fi lift gamma gamma 
gamma ffi gamma ffi 
gamma ffi gamma ffi phi gamma ffi phi left hand side gamma 
fi lift gamma gamma 
gamma ffi gamma gamma 
gamma ffi phi gamma ffi phi 
gamma ffi 

want show gamma gamma 
gamma ffi gamma ffi 
result immediate inductive hypothesis applies 
gamma gamma 
fi lift gamma gamma 
gamma ffi induction gamma gamma 
gamma ffi 
gamma gamma 
un fi flat gamma gamma 
fi lift gamma gamma 
gamma ffi induction gamma gamma 
gamma ffi proof second claim proceeds restricted terms form gamma cps 
grammar definition context cases iii empty 
cases iv impossible 
cases account reductions follows identical gamma ffi 
proof case lemma page 
cps cps values fi fi lift fi id fi omega gamma gamma gamma 
gamma sabry felleisen proof fi fi lift fi id fi omega gamma gamma phi gamma gamma 
gamma phi gamma gamma gamma 
gamma steps straightforward step requires appropriate proof 
prove claims 
fi fi lift fi id fi omega gamma phi gamma gamma gamma 
gamma 

fi fi lift fi id fi omega gamma phi gamma gamma gamma 
gamma 
proof relies auxiliary claim state prove main proof 
main proof lexicographic induction number abstractions form size terms 
proof proceeds cases arguments gamma gamma 
gamma phi gamma gamma phi gamma phi gamma gamma gamma 
gamma phi gamma phi gamma remains establish substitution commutes phi gamma 
cases phi gamma phi gamma phi gamma 
result immediate 
immediate free 
phi gamma phi gamma gamma phi gamma gamma gamma 
gamma phi gamma phi gamma phi gamma gamma phi gamma gamma phi gamma gamma gamma 
gamma induction phi gamma 
claim vacuously true 
gamma phi gamma gamma phi gamma gamma gamma 
gamma gamma reasoning programs continuation passing style 
gamma phi gamma gamma phi gamma gamma gamma 
gamma gamma 
immediate free 

special case clause 

gamma phi gamma gamma phi gamma gamma phi gamma phi gamma gamma gamma 
gamma phi gamma readability 
goal prove gamma phi gamma reduces gamma proceed cases gamma gamma 
gamma gamma 
gamma fi id gamma gamma gamma gamma gamma gamma gamma 
gamma gamma case lem 
gamma gamma 
gamma aux 
claim gamma gamma gamma gamma 
gamma gamma fi lift gamma gamma 
gamma aux 
claim gamma gamma auxiliary claim cps cps evcont 
fi lift gamma gamma gamma gamma 
gamma 
fi lift gamma gamma gamma gamma 
gamma sabry felleisen proof auxiliary claim induction number abstractions size proceeds case analysis possible elements cps cps evcont 
gamma gamma gamma gamma phi gamma gamma gamma 
gamma phi gamma gamma equivalence holds free 
sides identical gamma 

gamma gamma gamma gamma 
gamma gamma 
gamma gamma gamma gamma 
gamma gamma gamma 
gamma gamma gamma 
gamma gamma fi lift gamma gamma 
gamma gamma proof case lemma page 
values fi gamma gamma 
proof main proof uses result state proof 
fi gamma gamma 
fi gamma gamma 
main proof definition phi term reduces phi 
remains establish substitution commutes reasoning programs continuation passing style 
fi phi gamma gamma 


fi phi gamma gamma 

proof induction size argument case inductive hypothesis applies immediately 
interesting case occurs 
left hand side phi phi phi gamma 
phi phi phi phi gamma gamma 
phi phi line follows cases variable 
follows inductive hypothesis 
readability 
goal prove phi phi gamma gamma 
proceed cases 
sides identical 

phi gamma 
phi fi gamma gamma 
phi aux 
claim proof lemma page 
cps callcc continuation value language 
free continuation variables terms fk 
fij ffi gamma 
fij ffi gamma 
fij phi ffi phi gamma proof proof lexicographic induction number abstractions form size terms 
proceed cases 
ffi gamma gamma gamma 
fi twice sabry felleisen 
ffi gamma phi gamma phi ffi phi gamma gamma gamma 
phi ffi phi gamma result follows inlining case proof 

ffi gamma gamma phi gamma cases phi gamma phi ffi phi gamma 
substituting free continuation variable particular substituting inductive hypothesis get 
ffi gamma gamma phi gamma ffi gamma phi ffi phi gamma result follows inductive hypothesis 
ffi gamma ffi gamma phi ffi phi gamma ffi gamma phi ffi phi gamma result follows inductive hypothesis 

wk 
cases similar preceding cases 

phi ffi phi gamma 
phi ffi phi gamma phi callcc gamma phi gamma phi gamma gamma gamma gamma gamma substituting remaining free continuation variables inductive hypothesis term abstraction get kz equal proof lemma page 
callcc evaluation context language variable free 
reasoning programs continuation passing style ffl fi xc gamma ffi ffl fi xc gamma ffi proof induction size terms 
proceed cases 
gamma ffic gamma phi phi gamma ffi phi 
cases show phi gamma ffi phi 
phi gamma ffi phi 
phi gamma ffi phi phi gamma callcc gamma ffi callcc induction callcc fi lift current elim fi callcc phi gamma ffi phi phi gamma callcc callcc callcc elim callcc callcc fi callcc current callcc twice phi gamma ffi phi phi gamma callcc elim fi 
gamma ffi gamma phi phi gamma phi phi gamma ffi phi gamma ffi phi gamma ffi phi phi gamma ffi phi result follows inductive hypothesis repetition argument case 
gamma ffi gamma 
sabry felleisen 
gamma ffi gamma ffi gamma ffi phi gamma ffi phi result follows inductive hypothesis repetition argument case 
gamma ffi gamma ffi gamma ffi induction fi omega proof case lemma page 
free continuation variables fi xc callcc callcc gamma callcc callcc gamma proof applying gamma yields gamma phi gamma gamma phi gamma fi get gamma phi gamma 
remains show gamma commutes substitution 
prove statements induction structure terms ffl gamma phi gamma gamma 
ffl phi gamma phi gamma phi gamma 
ffl gamma phi gamma gamma 

gamma phi gamma gamma 

gamma phi gamma phi gamma gamma 
gamma phi gamma phi gamma phi gamma phi gamma similar case gamma reasoning programs continuation passing style 
gamma phi gamma gamma phi gamma phi gamma phi gamma gamma phi gamma induction gamma 
phi gamma phi gamma phi gamma phi gamma 
phi gamma phi gamma phi gamma 

phi gamma phi gamma callcc gamma phi gamma callcc gamma induction phi gamma 
gamma phi gamma gamma 

gamma phi gamma gamma phi gamma result follows induction 

result follows straightforward application inductive hypothesis 
proof case lemma page 
free continuation variables 
fi xc callcc callcc gamma callcc callcc gamma proof context callcc callcc kn arbitrary context suffices prove fi xc gamma gamma left hand side gamma gamma phi gamma gamma callcc gamma remains prove statements induction structure fi xc gamma gamma callcc gamma fi xc phi gamma phi gamma gamma fi xc gamma gamma callcc gamma sabry felleisen main proof relies auxiliary claim state proof 
continuation cps callcc free continuation variables kn fi xc gamma fi xc gamma auxiliary claim implies evaluation context gamma gamma result implies gamma callcc gamma callcc gamma gamma gamma callcc gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma main proof proceeds case analysis 
gamma callcc gamma gamma 
left hand side gamma phi gamma callcc gamma callcc gamma callcc gamma gamma auxiliary claim callcc gamma gamma callcc gamma gamma gamma callcc callcc gamma auxiliary claim gamma callcc gamma 

left hand side gamma gamma phi gamma gamma callcc gamma phi gamma gamma gamma phi gamma gamma gamma gamma phi gamma gamma gamma callcc gamma phi gamma reasoning programs continuation passing style 
result immediate 

phi gamma callcc gamma callcc gamma callcc gamma callcc gamma gamma 
gamma callcc gamma gamma 
gamma callcc gamma 

gamma gamma gamma callcc gamma gamma callcc gamma 
left hand side gamma gamma phi gamma gamma callcc gamma phi gamma gamma gamma phi gamma gamma gamma callcc gamma phi gamma 
allison practical denotational semantics 
volume cambridge computer science texts cambridge university press 

appel compiling continuations 
cambridge university press 

appel jim continuation passing closure passing style 
conference record th acm symposium principles programming languages 
sabry felleisen 
barendregt lambda calculus syntax semantics 
volume studies logic foundations mathematics north holland revised edition 

jensen implementation pc scheme 
proceedings acm conference lisp functional programming 

boehm 
demers implementing russel 
proceedings acm sigplan symposium compiler construction sigplan notices 

bondorf improving binding times explicit cps conversion 
proceedings acm conference lisp functional programming 

clinger friedman wand scheme higher level semantic algebra 
reynolds nivat editors algebraic methods semantics cambridge university press 

crank felleisen parameter passing lambda calculus 
conference record th acm symposium principles programming languages 

curry feys combinatory logic volume northholland amsterdam 

danvy back direct style 
science computer programming 
appear 
preliminary version proceedings th european symposium programming 
lecture notes computer science springer verlag 

danvy filinski abstracting control 
proceedings acm conference lisp functional programming 

danvy filinski representing control study cps transformation 
mathematical structures computer science 

danvy lawall back direct style ii class continuations 
proceedings acm conference lisp functional programming 

felleisen theory practice class prompts 
conference record th acm symposium principles programming languages 
reasoning programs continuation passing style 
felleisen friedman control operators calculus 
wirsing editor formal description programming concepts iii north holland 

felleisen friedman syntactic theory sequential state 
theoretical computer science 
preliminary version conference record th acm symposium principles programming languages 

felleisen hieb revised report syntactic theories sequential control state 
theoretical computer science 
technical report rice university 

felleisen friedman kohlbecker duba syntactic theory sequential control 
theoretical computer science 
preliminary version reasoning continuations proceedings st ieee symposium logic computer science 

felleisen wand friedman duba continuations mathematical semantics handling full functional jumps 
proceedings acm conference lisp functional programming 

fischer lambda calculus schemata 
proceedings acm conference proving assertions programs sigplan notices 

flanagan sabry duba felleisen essence compiling continuations 
proceedings acm sigplan conference programming language design implementation 
appear 

friedman haynes kohlbecker programming continuations 
pepper editor program transformations programming environments springer verlag 

friedman wand haynes essentials programming languages 
mit press 

talcott simplifier untyped lambda expressions 
proceedings conditional term rewriting systems lecture notes computer science 

griffin formulae types notion control 
conference record th acm symposium principles programming languages 
sabry felleisen 
haynes friedman wand obtaining coroutines continuations 
journal computer languages pergamon press 

hieb dybvig bruggeman representing control presence class continuations 
proceedings acm sigplan conference programming language design implementation 

kelsey hudak realistic compilation program transformation 
conference record th acm symposium principles programming languages 

kranz kelsey rees hudak philbin adams orbit optimizing compiler scheme 
proceedings acm sigplan symposium compiler construction sigplan notices 

landin mechanical evaluation expressions 
computer journal 

leroy zinc experiment economical implementation ml language 
technical report inria 

mason talcott equivalence functional languages effects 
journal functional programming july 

mazurkiewicz proving algorithms tail functions 
information control 

meyer wand continuation semantics typed 
proceedings workshop logics programs lecture notes computer science 

moggi computational lambda calculus monads 
proceedings th ieee symposium logic computer science 
appeared lfcs report ecs lfcs university edinburgh 

morris formal language descriptions 
lisp functional programming 
appear 

nielson denotational framework data flow analysis 
acta informatica 

plotkin call name call value calculus 
theoretical computer science 
reasoning programs continuation passing style 
rees clinger revised report algorithmic language scheme 
sigplan notices 

reynolds definitional interpreters higher order programming languages 
proceedings acm annual conference 

sabry felleisen reasoning programs continuationpassing style 
proceedings acm conference lisp functional programming 
technical report rice university 

shivers control flow analysis higher order languages taming lambda 
phd thesis carnegie mellon university 

sitaram felleisen reasoning continuations ii full abstraction models control 
proceedings acm conference lisp functional programming 

steel editor 
formal language description languages computer programming 
north holland 

steele rabbit compiler scheme 
mit ai memo massachusetts institute technology 

strachey wadsworth continuations mathematical semantics handling full jumps 
technical monograph prg oxford university computing laboratory programming research group 

talcott theory program data specification 
theoretical computer science 
preliminary version proceedings international symposium design implementation symbolic computation systems lecture notes computer science 

wand correctness procedure representations higher order assembly language 
brookes editor proceedings conference mathematical foundations programing semantics lecture notes computer science springer verlag 
