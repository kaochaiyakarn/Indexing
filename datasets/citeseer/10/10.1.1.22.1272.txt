methodology decompilation cristina cifuentes john gough qut edu au gough qut edu au school computing science queensland university technology gpo box brisbane qld australia proposed methodology decompilation binary programs description particular implementation methodology dcc 
dcc decompiler intel architecture takes input binary program dos environment produces programs output 
decompiler divided separate modules resemble structure compiler 
front module machine dependent performs loading parsing program generation intermediate representation 
universal decompiling machine module machine language independent performs flow analysis program 
back module language dependent deals details target high level language 
problem decompilation insoluble general partial solution gives information binary program 
describes results far 
key words decompiler reverse compiler halting problem compiler executable program takes input program written high level language produces output executable program target machine words input language dependent output machine dependent 
appeared xix de inform atica buenos aires argentina august pp 

decompiler reverse compiler attempts perform inverse process executable program aim produce high level language program performs function executable program 
input case machine dependent output language dependent 
compilers early widely known methods writing compilers language 
decompilers hand accepted methodology construction 
desirable decompilers perform automatic program translation compilers unfortunately possible decompilation insoluble general 
naive approach decompilation attempts enumerate valid phrases arbitrary attribute grammar perform reverse match phrases original source code 
algorithm solve problem proved halting problem equivalent 
sensible approach try determine addresses contain data ones contain instructions binary program 
von neumann machine data instructions represented way computer memory algorithm solves data instruction problem solve halting problem impossible 
means decompilation problem belongs class non computable problems equivalent halting problem partially computable 
words build decompiler produces right output input programs input programs general 
reader ask interested building decompiler 
reasons get solution cases possible recover source code second get information underlying algorithm input program cases complete solution 
proposes methodology decompilation describes current development state dcc decompiler project currently development queensland university technology qut 
brief description decompilers decades proposed methodology phases explained followed explanation implementation dcc summary 
previous decompilers tools translation software second third generation machines 
decompiler developed maurice halstead navy electronic labs 
decompiler took machine code ibm fl input produced code fl possible 
flagged ambiguities produced inline assembler pieces code decompiled 
decompilers port programs recreate lost source code modify existing binaries document debug binaries 
piler system attempt general decompiler large class source target language pairs 
large number languages operating systems tried cover finished 
decomp decompiler took input vax fl bsd fl object files produced code 
decompiler worked correctly complete decompiler takes input object file symbol table information program compiled debugging flag binary file symbol table information 
general different techniques decompilation implemented including pattern matching assembler instructions prove ideal graph oriented methods suitable job 
methods limited analysis underlying graph took granted problem separation data instructions input programs assembler files binary files 
assumption simplifies problem considerably 
decompiler modules decompilation part wider area reverse engineering 
brief reverse engineering attempts produce source code object code disassemblers decompilers debuggers related tools 
people believe reverse engineering commercial programs violates author copyright exclusive right copies debate case fair permits copying programs purpose learning idea product idea protected copyright law 
europe european parliament decided permit reverse engineering products sole purpose interoperability similar law proposed australia 
usa japan laws permit reverse compilation japan case provision fair usa decompilation permitted qualifies fair 
proposed methodology section presents proposed methodology reverse compilation programs 
concerned moment particular machine language binary program need produce program high level language 
output language necessarily language program compiled 
binary program loader code generator parser code front phases decompiler structured similar way compiler series modules deal machine language dependent features 
proposed main modules dedicated features machine dependent module reads program loads virtual memory parses front machine language independent module analyses program memory universal decompiling machine language dependent module writes formatted output target language back refer 
way different front ends different machines different back ends built different target languages easier write decompilers different machine target language pairs 
front front module deals machine dependent features produces machine independent representation 
takes input binary program specific machine loads virtual memory parses produces intermediate representation program see 
loader operating system program loads executable program memory sufficient free memory available sets segment registers stack transfers control program 
decompiler loader perform similar function allocating dynamic memory virtual memory load program loading relocating addresses specified relocation table setting initial contents registers 
note executable files contain information segments data ones code data segments contain code addresses 
parser decides type machine instruction memory location determines operands offsets involved 
parsing machine instructions easy appear 
addressing modes depend value variables registers runtime 
second indexed indirect access memory locations difficult resolve 
third complex machine instruction sets today machines utilize combination bytes hard determine byte instruction data 
fourth difference data instructions stored memory von neumann machine 
idioms compiler writers perform function minimal number machine cycles group instructions sense logical way individually 
order determine bytes information instructions ones data start unique entry point program loader 
entry point instruction program order execution 
instructions parsed sequentially flow control changes due branch procedure call case target location new entry point part program onwards instructions parsed previous way 
instructions parse due procedure program return branch control occurred continue parsing level 
method traverses possible instruction paths 
time data placed global local symbol table depending data stored offset stack definite memory location 
major problem introduced access indexed indirect memory instructions locations 
idiom sequence instructions forms logical entity meaning derived considering primary meanings individual instructions 
handle heuristic methods need implemented determine information possible analytic methods emulation provide range solutions anyway 
general impossible solve types problems equivalent solving halting problem previously mentioned 
different problems introduced self modifying code virus tricks 
way tackle cases flag sections code involved comment final program 
assembler code produced cases 
suggested optimal algorithm parsing consists finding maximum number trees contain instructions combinatorial method proved np complete 
dense machine instruction sets algorithm solve problem data residing code segments 
intermediate code generator produces intermediate representation program 
works close parser invoking get instruction 
machine instruction gets translated intermediate code instruction representation machine language independent 
defined du chains registers attached intermediate instruction data flow analysis phase 
quality intermediate code improved optimization stage eliminates redundant instructions finds probable idioms replaces appropriate intermediate instruction 
idioms machine dependent reveal semantics associated program hand 
idioms represent low level functions normally provided compiler higher level multiplication division integers powers 
idioms machine independent reflect shortcut compiler writer order get faster code fewer machine cycles function addition long numbers 
idioms widely known compiler community coded decompiler 
universal decompiling machine universal decompiling machine udm intermediate module totally machine language independent 
deals flow graphs cfg generator con ol flow analysis data flow analysis code con ol flow graph code udm phases intermediate representation program performs flow analysis input program needs see 
control flow graph cfg generator constructs cfg basic blocks procedure 
cfg connected directed graph nodes representing basic blocks directed arcs representing flow control node 
basic block needs record information predecessors successors associated intermediate code 
type basic block determined final intermediate instruction changes flow control unconditional conditional branch procedure call procedure return self loops way branch program 
instructions met basic block reached 
type basic block falls labelled basic block 
backward branches may split basic block create labelled basic block passes needed generate graph create list basic blocks transform list graph basic blocks 
due nature machine code instructions compiler need introduce intermediate branches executable program machine instruction capable branching basic block sequence instructions single entry point single exit point 
labelled basic block entry point target branch 
certain maximum distance bytes architecture dependent optimization pass cfg removes redundancy replacing target branch location conditional unconditional jumps branch unconditional jump recursive branches format final 
performing process basic blocks going referenced intermediate branches 
nodes eliminated graph 
control flow analysis phase concerned analysis flow control cfg 
phase needs determine type graph dealing reducible irreducible reducible graphs structure graph set high level language constructs 
flow graphs produced structured languages goto statement reducible 
structured control constructs loops loops case statements loops multilevel exits commonly languages pascal modula ada produce reducible flow graphs 
introduced goto statements available language pascal introduced optimizer 
know optimizer unstructured graph safe say languages implement goto modula bliss produce structured graphs 
languages allow gotos small probability graph hand irreducible needs converted reducible 
graph reducibility concept introduced frances allen defined terms intervals graph construct defined john cocke 
interval headed node maximal subgraph unique entry node closed paths contain selecting proper set header nodes flow graph partitioned unique set disjoint intervals 
process reducibility consists constructing series graphs collapsing intervals graph single node 
limit flow graph determines original graph reducible trivial graph reducible irreducible 
irreducible graphs transformed functionally equivalent reducible graphs method node replication known node splitting different algorithms specified literature 
node splitting assure generation reducible graph successive applications interval reduction node splitting transform irreducible graph reducible 
practical cases node splitting needs applied 
structuring algorithm determines high level language hll structures graph 
concerned control structures available languages loops conditionals case statements form basis creation control structures 
structuring algorithm determines hll constructs extent 
predetermined set hll constructs selected commonly constructs current high level languages 
set forms basis algorithm 
common constructs include loops conditionals 
piece code structured selected constructs goto target node flagged needing label code generation 
data flow analysis phase compiler optimization theory analyse data determine type temporary variables intermediate operations expressions described intermediate code arguments procedures functions values returned functions 
def chains built registers parsing stage determine expressions 
aliases value sets variable tracked order generate better easier understand high level language code 
order collect information possible global data flow analysis desirable 
back back module language dependent deals target high level language 
module optionally restructures graph control constructs available particular target language generates code language see 
code generator program ng con ol flow graph code back phases restructuring stage optional aims structuring graph control structures available target language set control structures structuring algorithm see section utilized 
instance target language ada multilevel exits allowed 
graph structured multilevel exits look loop abnormal goto exits 
restructuring stage check target destination goto determine exit statement suitable 
example loop loop equivalent loop induction variable 
case induction variable needs 
final stage code generation emits code target language cfg associated intermediate code 
global variables defined type described global symbol table 
code emitted procedure procedure basis depth traversal cfg 
procedure local variables defined type specified local symbol table 
flow control type basic block hand sequential code produced basic block associated intermediate code 
basic block flagged needing label unique label emitted branches entry basic block replaced gotos 
variables get assigned names form var var information concerning 
way procedures named proc proc 
data types simple functions supported binary program exe com cfg generator code generator loader asm code generator program asm program code generator parser con ol flow analysis data flow analysis structure dcc target language placed header file imported decompiled program 
project reverse compilation project currently development school computing science qut 
aim produce decompiler intel fl architecture dcc takes input exe com files dos environment produces programs output 
selected target output language flexibility ease low level manipulation portability 
decompiler currently implemented decstation fl virtual machine built 
dcc decompiler differs previous decompilation projects ways 
binary programs analysed assembler object files 
dealing von neumann machines heuristic methods separate instructions data 
second reducibility underlying program control flow graph checked irreducible programs produced optimizer language gotos previously discussed 
third known idioms dependent computer architecture checked replaced logical meaning 
fourth data flow analysis phase implemented determine type data related data issues 
restructuring control structures target high level language constructs introduced optional stage order eliminate possible gotos maximize number hll constructs 
main structure dcc illustrated 
structure follows proposed method integrates disassembler system assembler code produced program parsed constructs data need analysed case 
paragraphs highlight important aspects project 
implementation aspects heuristic methods implemented widely known implementation case statements indexed tables 
particular implementation case statements 
case assembler statement form jmp word ptr cs de bx provide necessary information calculate target jump address 
known idiom check lower upper bounds indexing table 
way statements preceding indexed jump information need bounds bx register 
heuristic method works cases 
example statements cmp ax check contents register ax case offset table calculated register bx indexed jump performed unconditional jump case statement code occurs 
heuristics needed building control flow graph specifically trying determine extent basic block reaches program 
dos executable different possible ways exiting program 
interrupts depend contents certain registers 
approach simulate state virtual machine registers interrupt reached cmp ax jmp mov bx ax shl bx jmp word ptr cs de bx cs de dw lab cs de dw lab 
cs eoe dw lab cs lab 
cs lab 
cs case 
implementation indexed tables contents required registers checked 
difficult case indirect procedure calls indexed branches fit case statement idiom 
heuristic method implemented cases flag corresponding basic block going 
instructions parsed instructions current path basic block finished 
case indirect indexed data accesses locations placed symbol table expect data flow analysis provide plausible data type variables 
idioms considered machine dependent general 
machine dependent idioms procedure entry preamble procedure exit number local variables defined stack decreasing contents register sp 
general idioms machine independent cover functions multiplication division integers powers shifting register left right swapping variables access local variables offsets stack 
intermediate language project simple assembler address code representation operands explicit named icode 
icode provides mapping assembler icode instructions assembler add instructions handled icode add instruction 
control flow graph built optimization pass removes redundant intermediate branches reduced size cfg different programs tested dcc 
simplifies structure graphs hand 
checking reducibility implemented constructing derived sequence graphs finding intervals implementation pointers 
cfg irreducible graph flagged stage node splitting implemented minority graphs irreducible 
set high level language constructs selected base set structuring algorithm case statement loop repeat loop endless loop 
constructs high level languages modula pascal ada 
constructs belong major groups loops cases way branch conditionals 
algorithm graphs find nested loops immediate dominators find conditionals way branch reverse walk underlying tree performed cases 
abnormal exits control structures goto statement 
detailed explanation algorithm 
data flow analysis stage implemented 
code generation implemented get feel type output expected dcc 
results output programs dcc reflect control structures program instructions low level assembler 
idioms currently coded dcc 
idioms machine independent give semantic interpretation group instructions 
example absolute value number placed register eax calculated way sign number moved carry bit temporary register ecx borrow order get zeros positive numbers bt eax sign 
carry sbb ecx ecx sbb eax negative xor eax ecx negative idiom absolute value ones negative numbers zero original number eax resulting number negative xor registers eax ecx negate negative number leave positive number unmodified 
sequence instructions translated abs variable placed eax refer 
programs decompiled dcc include header file defines simple data types byte word macros manipulate data types defines macros manipulate registers accessed union regs structure defined global program defines constants true false includes simple functions supported swap 
major problems face amount extra code included compiler setup procedures libraries included library functions normally invoked program indistinguishable procedures written programmer library procedures procedure preamble just user procedure 
means program displays hello world screen printf procedures decompiled 
program written pascal produces procedures 
initial solution check compiler signatures feasible know compiler compiled code pattern matching decompiled code start library procedure possible different memory models pc produce different entries piece code 
new solution user decide procedures interested decompiling compiler signature string placed compiler data section binary file 
normally contains details name compiler release version 
available procedures giving indication procedures appear low level possibly hand coded assembler due machine instructions having procedure preamble 
obvious need data flow analysis stage planned implemented 
stage able determine expressions temporary variables removed provide precise data type variables variable 
output dcc provides comments different levels depending switch specified user running dcc 
default procedures comments dos interrupts reflect function invoked 
available switches extra information verbose verbose 
switch displays information binary file file size file type number relocation items maximum memory allocated tree procedures flags set procedure basic blocks creation graph 
switch displays relocation table control flow graph derived sequence graphs interval information 
switches available dcc produce assembler output display memory map data instructions bytes data instructions unknown areas print procedure list print statistics graph optimization stage 
summary proposed methodology decompilation binary programs describes current development state dcc decompiler intel architecture built proposed methodology 
decompiler structure resembles compiler main modules distinguished front machine dependent universal decompiling machine udm machine language independent back language dependent 
front deals loading binary program parsing producing intermediate representation program icode 
udm constructs graph procedure associates intermediate representation node checks graph reducibility determines high level structures program performs data flow analysis order learn data program able determine probable data types existing variables 
back performs restructuring needed accommodate structures program structures available target high level language emits global variable information code procedure 
dcc decompiler takes input dos executable programs exe com produces programs output 
ff stage implements stages defined proposed methodology 
currently data flow analysis implemented output programs 
control structures program defined variables defined terms types byte word string 
decompilation problem insoluble general partial solutions provide information original program 
releases expected 
jeff clarifying concepts associated project 
research partly funded australian research council arc 
breuer bowen decompilation enumeration types grammars tech 
rep prg tr oxford university computing laboratory road oxford ox qd 
horspool approach problem computer programs computer journal vol 
pp 

goldschlager computer science modern 
prentice hall international 
halstead machine independent computer programming ch 
pp 

spartan books 
piler system computer program translation tech 
rep probe consultants sept 
reuter decomp tar public domain software 
anonymous ftp cs washington edu directory pub 
hollander decompilation object programs 
phd dissertation stanford university computer science jan 
study decompiling machine languages high level machine independent languages 
phd dissertation purdue university computer science aug 
decompilation 
phd dissertation university california irvine computer science 
swartz case reverse engineering business computer systems vol 
pp 
dec 
anon software protection edge workgroup computing report vol 
apr 
mcnamara australia proposals open reverse engineering debate oct 
reverse compilation computer programs berne convention computer law practice vol 
pp 
mar apr 
hecht flow analysis computer programs 
vanderbilt avenue new york new york elsevier north holland 
kosaraju analysis structured programs journal computer system sciences vol 
pp 

allen control flow analysis sigplan notices vol 
pp 
july 
allen basis program optimization proc 
ifip congress amsterdam holland pp 
north holland pub 
cocke global common subexpression elimination sigplan notices vol 
pp 
july 
allen cocke graph theoretic constructs program control flow analysis tech 
rep rc ibm thomas watson research center yorktown heights new york july 
cifuentes structuring algorithm decompilation 
submitted publication 
