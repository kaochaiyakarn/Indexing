usability analysis visual programming environments cognitive dimensions framework green mrc applied psychology unit road cambridge cb ef uk thomas green mrc apu cam ac uk www mrc apu cam ac uk personal thomas green petre dept mathematics computer science open university milton keynes mk aa uk petre open ac uk january appear journal visual languages computing contents psychology hci programming psychology programming hci programming sketch framework cognitive dimensions design alternatives vpls basic labview prograph applying cognitive dimensions abstraction gradient closeness mapping consistency error proneness hard mental operations hidden dependencies premature commitment progressive evaluation role expressiveness secondary notation escape formalism viscosity resistance local change visibility discussion cognitive dimensions framework tell designer progress cognitive dimensions progress vpl design appendix viscosity test usability analysis visual programming environments cognitive dimensions framework green petre cognitive dimensions framework broad brush evaluation technique interactive devices non interactive notations 
sets small vocabulary terms designed capture cognitively relevant aspects structure shows traded 
purpose propose framework evaluation technique visual programming environments 
apply commercially available dataflow languages examples systems conclude effective insightful hci evaluation techniques focus different aspects complements 
insofar examples representative current vpls successful achieving closeness match designers need consider viscosity resistance local change secondary notation possibility conveying extra meaning choice layout colour 

evaluation full scale programming environments presents challenge existing hci 
evaluative techniques proposed hci designed concentrate physical low level details interaction user device 
goms onwards tradition close inspection simple tasks deleting word text editor trying predict time taken learn perform task 
tradition suitable evaluating programming environments 
tried evaluate programming environment way overwhelmed mass detailed time predictions simple task performed environment 
timings digest address questions designers ask 
goms similar hci approaches far applied notational issues identifier declarations programming language hci approach concentrated interactive situations notational design 
green alternative approach called cognitive dimensions notations framework broad brush assessment kind cognitive artifact 
approaches cognitive dimensions framework task specific concentrating processes activities finished product 
broad brush framework supplements detailed highly specific analyses typical contemporary cognitive models hci say users hci specialists 
cognitive dimensions framework cognitive dimensions constitute small set terms describing structure artifact mutually orthogonal principle derived seeking generalised statements structure determines pattern user activity 
cognitive artifact described terms description high level predict major aspects user activity 
dimensions guidelines unrelated precepts design descriptions devices descriptions devices definitely cognitive model user rest common sense proto theory users 
discussion tools descriptions artifact user relationship intended raise level discourse 
briefly claims cognitive dimensions framework 
broad brush analysis usable non specialists hci avoids death detail offers striking points covering couple pages pages analysis 
extremely quick cheap afternoon careful thought system probably needed 

assessment structural early stage design 
token needs supplemented stage methods 

claim terms uses conform notions recognisable unnamed discourse non hci specialists 
readers expect discover new ideas recognise previously 

introducing defined vocabulary ideas framework easier converse cognitive artifacts having explain concepts provides checklist 
designers evaluators find easier avoid gross including cross part spreadsheet 

different types user activity possible set preferred profile dimensions 
exploratory design require type profile tightly specified safety critical design require different profile 

defined vocabulary place easier describe remedies weaknesses provided different dimensions trade 
explicitly presenting ideas discussion tools believe new approach hci doing doing recognising discussion users carries corridors institutes internet 
hope improve level discourse influence design roundabout way 
hci tried direct route explicitly attempted develop methods design 
aim 
feel suggest cognitive psychologists tell professional designers design programming languages 
attempt lay set evaluative criteria designs meet books guidelines 
purpose cognitive dimensions framework lay cognitivist view design space coherent manner possible exhibit cognitive consequences making particular bundle design choices position artifact space 
designer decide specification locate artifact design space invent solution 
designer cognitivist weigh cognitive costs benefits requirements expense software engineering personnel training organisational design structure cognitive dimensions method evaluating visual programming languages vpls environments 
simplicity shall distinguishing language environment 
start briefly reviewing major findings psychology programming hci programming outline cognitive dimensions show dimensions contemporary theory 
dimensions consider successes weaknesses visual programming environments 
chosen attempt review state art vpls 
illustrate cognitive dimensions shall draw commercially available vpls labview prograph 
languages state art genuinely usable complex programs successfully built users scientific specialists programming specialists 
languages adopt dataflow model box wire representation illustrate different design decisions different usability consequences 
brief descriptions section 
commercially available able benefit personal experience comments help experts certain amount empirical observation 
cognitive dimension related languages 
taken examples specific issues vpl designs 

psychology hci programming framework cognitively relevant dimensions founded tightly alas day views activity programming shall review briefly 
programming seriously overloaded term comprising host different activities situations fortunate space enter 
follows high level view restricted relevant cognitive dimensions framework 
start need consider users situation 
wish design programming environment 
doing 
aspects activity affected programming environment 
shall assume may user expert novice user computer science professional 
shall ignore large literature experts know novices know shall take account extra support novices need 
second shall tend limit discussion situations exploratory incremental programming 
shall pay attention design criteria safety critical design coding efficiency parts software creation process communication negotiation requirements elicitation demands local situation organization known affect choice cognitive strategy 
thing time 
thirdly limits shall try consider programming process affected programming environment 
just coding just comprehension 
shall distinguish loosely psychology hci programming environment psychology refer meaning code solve problem 
code mean hci mean interaction notational system control layout searching items 
psychology programming maxims information representation start may easily get overlooked data information 
data usable form information choice representation affects usability 
usability simply better worse representation depends want 
diagrams better text problems worse 
school thought maintains difference lies cognitive processes locating indexing components information view analysed pulley problems mechanics larkin simon show representations diagrammatic symbolic carried information imposed different processing costs 
mental processing analyses apply just differences programming languages 
green vessey independently developed bodies research demonstrate notational structure effects 
summarised maxims 
notation highlights kinds information expense obscuring kinds 
highlighted 
language highlights dataflow may obscure control flow language highlights conditions actions taken rule language probably obscures sequential ordering actions 
corollary part notation design problem obscured information visible 
seeking information cognitive fit mental representations external representation 
mental representation control flow form find dataflow language hard think iteratively recursion hard 
taken maxims mean programming system including language programmer successful language fits tasks programmer needs programmer mental representation fit language representations 
mental representations mental representation program higher level pure code 
demonstrated various ways 
soloway ehrlich introduced notion schema programming plan binding semantically related dispersed statements program group taken achieved goal form running total 
reviews literature rist extends schema concept relates full theory program development comprehension novices experts 
prolog corresponding notion technique similar function 
dispersal related statements seen major problem learning program 
spohrer soloway report contrary received wisdom says novice bugs caused misconceptions language constructs bugs arise result plan composition problems difficulties putting pieces program 
novice knows bits required linking bits difficult 
analysis familiar problem smart students solve simple programming problems brought home importance plan composition cause failure program 
dataflow languages received degree attention shown schema analysis applied spreadsheets visual dataflow languages 
concentration programming plans may led researchers types knowledge 
gilmore shows possessing strategies planning debugging prerequisite programming success 
development visual programming may give scope visual spatial reasoning older text languages 
showed spreadsheet programmers reasoned formulae terms areas spreadsheet green navarro showed mental representations programs different structures basic spreadsheets labview 
far research needed area message possible spatial reasoning support 
order program development development program linear 
programmers write program text order start finish top highest mental construct smallest 
jump high level low level vice versa frequently revise written far 
purposes programming support need know 
causes nature deviations top development inspired research implication programming environment quite straightforward order working left programmer prescribed environment 
effect environment green showed coding stage programmers languages develop code little possibly corresponding mental chunks schemas written far 
follows programmers need read understand written far order knit new material 
called cycle parsing backwards 
davies extended consider relationship environment editor allows easy access large window code cycle easier 
done see ball developments straightforward implication window access needs large 
problem program brooks described program design terms mappings problem domain program domain 
subsequent research strongly reinforced view 
spatial reasoning mentioned seen intermediate mapping possible 
powerful corollary easy deal entities program domain corresponding entities problem domain 
lewis olson show potential user programmers abundance low level primitives great cognitive barriers programming 
nardi argues case task specific languages definition high proportion entities map directly back problem domain 
visual programming languages possible way create task specific programming languages effective 
anderson distinguish inherent goals exist problem domain planning goals exist solely solution domain 
computing gross profit year inherent goal declaring identifier called profit planning goal 
crux problem designing programming language users lewis olson avoid spawning planning goals 
problem abundance low level primitives view precisely weaving correctly creates planning goals 
problem plan composition mentioned seen problem spawning planning goals 
understanding evaluating program parsing cycle shows programmers need read evaluate incomplete programs finished ones 
experienced programmer smaller amount produced evaluated 
novices need progressive evaluation environment easy check program fragment adding 
ideally step checked individually combinations steps checked see gone 
environment needs allow seriously incomplete program fragments evaluated far cry early systems say pascal program pass rigorous syntactic check executed 
experts need check debug programs hardly surprisingly means locate bug big program cut program smaller fragments 
weiser identified slicing expert debugging strategy slice smallest fragment code run program reproduced errant behaviour 
textual languages support slicing commenting unwanted code 
maxims information presentation understandability programming language depends match way structured type question answered 
example traditional goto language highlights procedural information order execution statements expense declarative information types input distinguished type handled 
easier answer procedural questions goto language answer declarative questions 
demonstrated textual languages analogue demonstrated visual data flow languages 
way improve cognitive fit include cues improve accessibility information 
textual languages may include perceptual cues choice typeface symbolic cues 
alternatively environment may offer comprehension aids software visualization tools information structure highlights programmer wants know 
tools usually designed purely intuition day may possible design deliberately engineered complements programming language support 
hci programming previous section dealt primarily moving problem domain program domain short section need consider involved interacting code screen 
control layout text despite overwhelming literature design text editors word processors little known programming 
engineering estimates time required simple editing tasks conventional editors available surprising failed apply programming little presently known specialised editors program synthesizers 
known code management visual languages common box line structure 
straw comparison authors mentioned see section viscosity serious research needed tell programmers plan manage updating diagrammatic notations 
searching browsing similarly little known searching browsing visual programming languages known browsing kind language 
established programmers need wide access parts program 
far reading program line line visit different parts comparisons establish dependencies 
programmers existing code seed new code 
deliberately supported feature object oriented languages programmers frequently specialise existing class new purpose learners making example programs guide solutions 
different types browsers scrolling long text versus hypertext methods favour different strategies impose different costs general principles forthcoming 
type browser impose cognitive overheads finding way finding way back 
hypertext systems create long trails windows confusing systems give explicit support keeping track trails 

sketch framework cognitive dimensions framework cognitive dimensions consists small number terms chosen easy non specialists comprehend capturing significant amount psychology hci programming 
supposed apply programming wide variety notations interactive devices shall discuss applications 
dimensions called meant coherent physical dimensions 
place scientific knowledge craft knowledge inventing framework 
scientific knowledge form psychological hci literature just reviewed tells certain empirical effects observed rely craft knowledge tell effects important context significant effects missed 
craft knowledge acts check scientific knowledge strengthening discounting 
opposite just true craft knowledge tells experts think controlled observation gives different viewpoint separates myths 
framework tested comparing post hoc roots show dimension taken turn empirical support tested trying seeing known phenomena important ones place framework tested seeing experienced programmers designers users respond dimension recognition understanding phrase know just didn name tested showing dimensions internal coherency dynamics day formulating theory information artifacts 
ultimate test people find useful easier talk designs notations easier find problems comparisons 

simple assume scientist viewpoint privileged davies show different narratives software design seen different stake holders contributions 
dimensions outline list dimensions shall follows 
dimension supply thumb nail description 
account dimension relation underlying evidence appropriate section 
abstraction gradient minimum maximum levels abstraction 
fragments encapsulated 
closeness mapping programming games need learned 
consistency language learnt rest inferred 
symbols graphic entities required express meaning 
error proneness design notation induce careless mistakes 
hard mental operations places user needs resort fingers annotation keep track happening 
hidden dependencies dependency overtly indicated directions 
indication perceptual symbolic 
premature commitment programmers decisions information need 
progressive evaluation partially complete program executed obtain feedback am doing 
role expressiveness reader see component program relates 
secondary notation programmers layout colour cues convey extra meaning official semantics language 
viscosity effort required perform single change 
visibility part code simultaneously visible assuming large display possible parts side side 
code dispersed possible know order read 
trade offs dimensions point view designer important tradeoff relationships cognitive dimensions 
position artifact cognitive dimensions space adjusted arbitrarily 
changing structure reduce viscosity example affect dimensions 
parallel quantities define physical systems heating body change temperature change volume compressed case pressure change 
designers need understand trade offs find right compromise conversing trade decisions difficult remain accepted vocabulary level cognitive dimensions 
far analysis trade relationships needs done consider relationships observed 
important bear mind trade relationships exist notable success dimension may reduced poor performance 
forms engineering design matter compromise 

design alternatives vpls show cognitive dimensions framework yield shall apply different target languages small repertoire commercially available vpls old faithful basic 
languages commercially available actively advantages familiar readers supplement observations expert users 
guarantees environments complete workable research systems 
designers vpls obviously need choose computational model type visual language box wire represent model 
cognitive dimensions framework little say high level choices relevance starts details start worked 
illustrate chosen vpls dataflow computational model box wire representation prograph labview 
despite similarities surface differences greatly affect assessment 
prograph programs deep call structure labview ones flat structure labview closely modelled schematic circuit notation electronics visual presentation facilities intended construction virtual instruments prograph aims building applications prograph object oriented labview 
shall contrast basic highlight contrasts textual languages class vpls 
bring various differences shall differing solutions yardstick problem taken curtis compared comprehensibility wide variety design choices notations 
authors formed text versions superior graphical ones graphical notations flowchart modern dataflow approach 
shall solutions rocket trajectory problem illustrative languages 
unfortunately easy way illustrate dynamic aspects programming environments 
rocket program computes vertical horizontal trajectory rocket forces acting thrust gravity 
time zero rocket stands stationary vertical level ground mass pounds 
engine develops thrust foot pounds mass pounds fuel second fuel exhausted seconds 
rises vertically seconds adopts retains angle radians degrees vertical 
downwards acceleration gravity feet sec 
rocket program specification 
deduced programs curtis 
basic basic probably commonest user programming language single language family closely related dialects versions 
older readers remember 
days lines numbered programs burst sides gotos 
date versions structured control statements affording example informal language widely 
shows version rocket program microsoft basic version dialect includes loops 
basic mechanism distinguish constants variables easy bring vertical horizontal components groups show clearly similarity computations 
control structures basic vary somewhat implementations gotos allowed means handling conditionals 
note variables initialise zero default typical feature identifier time example programs reserved keyword replaced tim 
programming environment basic usually simple text editor 
normally interpretive language quick test edit cycle 
mass fuel force gravity tim angle tim force mass mass fuel force cos angle mass gravity force sin angle mass print tim tim tim solution rocket program microsoft basic 
labview labview visual data flow language marketed national instruments version 
usual box line structure enriched constructs conditionals loops sequences 
data flows typed numbers booleans strings arrays type line 
operators provided give excellent coverage needed construct virtual electronic instrument operating real time considerably coverage provision domains computing 
graphical realisation labview forcefully presents view electronics schematic wiring diagram conceptual model impressive referring input output panel containing pictures knobs sliders control structures loops sequences conditionals expressed spatial containment instance loop rocket program represented thick rectangle surrounding operations scope 
data flows left right connectors wires bent number right angles 
equivalent subroutine library provided virtual instrument feature program packaged away represented new icon drawn user 
panel rocket program illustrated contains output indicator show time rocket hits ground pair charts showing horizontal vertical distance time 
wiring diagram contains actual program 
large rectangle loop termination controlled test bottom right hand corner little arrows left right sides denote shift registers recycle data values iteration 
example top horizontal data line carrying initially set zero new iteration preserves value computed previous iteration 
icons box handle summation multiplication trig functions obvious manner 
obvious iteration counter arises box bottom left corner 
program number iterations represents elapsed time identifier 
values angle force set conditional boxes represent arms conditional allow arms visible simultaneously arms shown 
lexical distinction possible true constants gravity constants initialisation 
code vertical horizontal components laid similar ways perceptually grouped strongly text languages 
rocket program labview 
input output front panel illustrated 
prograph prograph visual data flow object oriented language marketed tgs systems 
version 
language built methods subroutines represented icons connected usual lines carrying data objects top bottom screen 
method may cases conditional choosing 
methods cases realised separate window complete scroll bars making busy screen 
method browser browsers classes attributes overview call graph methods 
method windows data flow runs downwards entry bar terminals supply incoming data exit bar terminals accept outgoing data 
method called represented icon accepting data top producing data bottom double clicking non primitive icons opens method window turn 
terminals connected lines usual way 
labview dataflow lines lines placed diagonally contain bends 
prograph version rocket program shown 
quantities fuel gravity represented constants pascal version represented global variables true constants distinguishes quite satisfactorily variables explicitly show constants 
remaining quantities mass time represented parameters single method view version 
terminals compute compute just lab show quantities updated iteration 
method window compute reading left right nb direction significance prograph concurrent operation language operations increment time compute new mass compute new angle compute new force attached identifier vertical height rocket test zero test returns true attached annotation bar terminates loop success condition 
cycle time vertical distance output compute gathered list terminal eventually displayed scrolling table values code shown 
computations vertical horizontal acceleration encapsulated methods partly reduce clutter top level compute partly exhibit similarities vertical horizontal velocities distances computed main loop laid look similar general clutter obscures 
rocket program prograph 

applying cognitive dimensions section show dimensions considering turn relating existing evidence showing briefly applies vp languages labview prograph occasionally languages 
aim evaluate languages illustrate cognitive dimensions demonstrate type framework leads 
abstraction gradient abstraction grouping elements treated entity just convenience change conceptual structure 
programming languages grouped abstraction abstraction tolerant abstraction hungry minimum starting level abstractions readiness desire accept abstraction 
flowcharts abstraction 
contain decision boxes action boxes 
abstraction tolerant permitting exactly come allowing new abstractions kinds created 
low initial level abstractions novices start learning fields invisible fields variables 
higher minimum starting level novice new ideas learn able write program 
criteria learnability main focus ought point having master abstractions presents novices rubber hamburger 
suggestions incremental learning environments scaife taylor 
smalltalk having high starting level abstraction hungry language start writing program modify class hierarchy 
user feed new abstractions 
new 
program requires new abstraction novice programmer simply map problem entities domain entities 
course experienced programmers stock abstractions learnt ready applied new situation 
finding right balance easy 
learning think terms high educational achievement 
concept variable difficulties novices ay spohrer 
abstraction hungry systems obvious disadvantages 
abstraction hungry systems necessarily take long time set suffer sort delayed gratification appropriate abstractions defined programmer inherent goals attacked 
done understanding satisfactory mechanisms browsing editing abstractions especially cognitively relevant level story carroll rosson smalltalk illustrates need intensive iterated development 
surprisingly potential users abstraction hungry systems 
reasons 
classic solution viscosity problems introduce abstractions components treated group reasons development object oriented programming 
chosen abstractions increase comprehensibility language 
abstractions increase protection error proneness example declaring identifiers detected compilation run time 
application main example languages provide relatively standard control abstractions conditionals loops subroutines 
different approaches taken data abstraction 
labview preserves closeness mapping target domain abstraction called bundle wires suitable parallel signal streams provision extending data abstractions 
prograph having dominating metaphor preserve close mapping full object oriented system 
abstractions built incrementally abstraction editor avoids imposing unnecessary 
see early versions prograph extraordinarily successful example language abstraction gradient gentle far reaching 
specifically visual possibilities envisaged forms burnett ambler write information hiding supported visibility 
value visible screen accessible logically 
visual mechanism replaces approach information hiding textual languages generally rely combination declarations scenes scope rules due simple powerful approach done declarative formulas managed create visual data abstraction facility low overhead abstraction level user think variables declarations sequencing control flow pointers state modification event loops inheritance hierarchical scope rules order program 
sort target try achieve 
closeness mapping programming requires mapping problem world program world 
closer programming world problem world easier problem solving ought 
ideally problem entities user task domain mapped directly task specific program entities operations problem entities likewise mapped directly program operations 
conventional textual languages long way goal vpls surprisingly effective 

introduced version gentle change marketing emphasis 
sum sum sum sum sum differences number primitives amount syntax 
fragments add vector appropriate list 
left right basic prograph labview spreadsheet 
introduces unusual primitives relationship user inherent goals requires programming games put 
extreme labview single primitive 
notations prograph labview explained 
illustrates scale problem 
version wealth unusual primitives lexical clutter kinds parenthesis kinds assignment operator just lines components arranged hard remember structure syntax rules semicolon 
basic fuss syntax wrap loop structure 
prograph life somewhat easier system stops loop right place automatically explicit mention need size array case list 
labview just needs single primitive array comes left note thick data line sum leaves right 
spreadsheet system amount unusual components understood 
unfortunately detailed studies area 
hoc reviews know programming language semantics mental models 
methodology beginners asked perform task hand situation constraints possible everyday procedures observed 
asked instruct device step step perform task data stores visible times data stores covered 
technique gives remarkable insights everyday methods beginners try modify programming world 
technique time consuming broad brush technique cognitive dimensions framework widely adopted know everyday methods 
application dataflow languages target languages avoid programming games associated computational models 
labview affords close mapping electronics schematic metaphor metaphor fits user domain language may transparent task 
task specific library functions help 
wiring metaphor fails difficulties example looping sequence constructs require understanding shift register local variable transfers values iteration 
extra piece conceptual apparatus course part program world part external domain world 
ably argued nardi users domain specific programming language supported visual formalism spreadsheet grid give best worlds 
approach sum extended repenning agentsheets 
agentsheets program consists sheet agents organized grid 
agents interact locally reachable agents neighbours grid represent display 
underlying definitions agents lisp supplied designer system supports user programmers select agents place worksheet create programs 
agentsheets ways spreadsheets plus visual effects added feature components active 
put simulation water programmer just place virtual pipes agents images know join water flow 
agentsheets appears score closeness mapping 
objects programming domain match behaviour objects problem domain resemble appearance top agents know join interact ways eliminates programming games systems 
interesting see system fares action 
consistency notion consistency harmony programming language design goes back long way difficult define 
doubt widely agreed language inconsistent pascal allows reals integers read written booleans booleans treated way integers reals purposes 
purposes take particular form person knows language structure rest successfully guessed 
green produced arguments consistent language easier learn suggested level grammar way model programmer knowledge consistency led task action grammar clear estimating consistency creating special grammar required detailed analysis unsuitable broad brush approaches 
little alternative rely introspection 
reisner clear confusion early approaches problem meanings consistency language put random arbitrary way seen highly consistent designer create problems learner understanding structure different inconsistent designer lisp example problem 
learners understand structure function call foo arg arg come define function may write defun foo arg arg 
consistent structure defun took argument function 
correct form defun foo arg arg 
correct form defun call function foo argument arg arg second argument 
second perfectly consistent consistent different structuring 
application vpls shown real improvement consistency partly simpler syntax 
target languages noticed particular problems consistency 
notations lot symbols lot space achieve results notations achieve compactly 
difficult dissect difference wholly satisfactory way notations close mapping problem domain require fewer lexemes achieve results appear terse interest notations independently closeness mapping 
cognitive implications self evident material scanned smaller proportion held working memory greater disruption caused frequent searches text 
problems 
wholly different programs hardly different visible way scanning difficult 
clearly happy mean pretend know state 
application real estate problems visual notations commonplace 
surprising number entities lexemes 
pretend perfect definition entity count words icons connectors results rocket program unexpected say 
basic rocket program occupies lines uses words fitting easily screen 
lab view rocket program uses icons counting shift registers come pairs pair wires total different graphic entities 
readily fits medium sized screen 
prograph diffuse rocket program occupies windows total icons methods constants tests connectors making graphic entities 
counted data bars top bottom method inserted system method created 
question having program visible simultaneously large inch inch screen 
conclude firstly adopting dataflow paradigm reduced number entities expected secondly physical size hardly related number entities 
error proneness course errors errors 
conventional distinguish mistakes slips slip doing didn mean knew wrong contrast parts program design coding deeply difficult mistakes problem analysis quite common 
distinction means perfect serve 
textual programming languages contain number syntactic design features help slips occur hard find occurred 
merely having type long identifiers source obviously early language designs facilities catching declaration invented new identifiers declared languages 
consequence known war stories single fortran basic prolog program caused disasters long program thought fully debugged 
potent source slips paired delimiter system parentheses lisp pascal wide variety paired symbols cases uncommon pairing go wrong 
pascal semicolon separator convention problem novices think semicolon terminator write application error sources target languages serious quantity 
far fewer identifiers needed easy fetch names copying direct 
pairings inserted automatically cases occur languages paired data ports loops instance 
delimiters separators needed syntactic structure different 
data flow dependencies explicit lines 
frequency slips due causes dramatically reduced compared primitive language early fortran 
hard mental operations consider sentence case lawn shed case oil tool box key hook need cut grass 
innocent amusement dressing fairly simple contingencies possible 
delight forced real stuff programming languages avoid brain mental equivalents tongue 
hard mental operations defined properties 
problematic mental operations lie notational level solely semantic level topic interest design notations question meanings hard express notation 
conditionals negatives meet requirement familiar problems re expressed decision tables various formats showing substantial component difficulty notational level semantic 
second defining property hard mental operation term combining offending objects vastly increases difficulty 
single conditional clauses easily interpreted 
multiple negatives problem complex booleans self embedded sentences man horse dog chased kicked fed cat broad brush test hard mental operations fit constructs get incomprehensible 
ii way language making comprehensible 
just really hard idea grasp 
answer counts 
application vpls simple intuitive idea surprised realise need hard mental operations uncommon 
difficulties observed control constructs 
difficulties arise labview conditionals built logic gates 
authors observed subjects professional electronics engineers amateur experienced labview users solved problems :10.1.1.57.1633
subjects seen winding fingers screen trying follow logic evidently experiencing great difficulties keeping track 
degree strategies improved experience expert readers schematics experienced difficulties 
similar results reported petri net programs 
clear process severe demands working memory 
hard mental operations labview 
problem tired thirsty false outputs receives true signal 
surprising task difficult logic gate notation extremely known standard design notations 
simple problems expressed popular notation hard 
answer may notation evolved notation 
allows reader annotations showing combination signals drives wire input output gate gate true state 
allows reader little pencil marks help keep track search process 
screen pencil annotation impossible annotation task maze searching 
plausible account typical procedure agreeing patterns behaviour observed follows see illustration search take truth value tired false 
scan find tired program 
propagate false wire 
place finger choice point consider direction turn 
propagate horizontally 
reaching component sleep abandon branch haven sent true output 
propagate downwards 
reaching start propagate true 
reaching junction place finger choice point consider direction turn 
propagate horizontally 
reaching gate place finger start search backwards 
search reaches input thirsty 
look truth value false 
return finger abandon branch conjunction false 
return previous finger 
start propagate downwards 
reaching gate place finger start search backwards 
reaching remember invert signal 
search reaches thirsty set false set true 
return finger continue propagating true 
search reaches argue 
output argue 
search path solving problem posed 
choice points marked points remembered case search backtrack 
prograph fares better 
control loops repeated reversals success failure signs classic hard mental operations example 
noted analysis purely speculative unsupported empirical data confident 
consider searching list item demanding task 
prograph uses success failure signals control searches flag result 
solution tutorial supplied uses methods cases 
method searcher case calls method search list method succeeds target control switches case gives message method fails control stays method case gives message 
method case tests container equal target 
succeeds fail second container list 
succeeds switch case recurses list members recursion fails case fails 
back case container list case succeeds 
prograph program search list target see text explanation 
configuration inputs boxes generate box inputs generate 
case consistent box allowed send signal 
box receives different signals suppressed box receives conjunction difficult configuration show tell 
complex expressions undoubtedly overwhelming 
example hard mental operations 
interesting vpl show tell uses dataflow model usual conception replaced consistency constraint data flow box inconsistent state 
inconsistency originates box receives inputs agree input disagrees stored constant ingenious device visibility problems encapsulation required creates serious difficulty conditionals get complex 
case presence input conflicts box causes box suppress signals allowing box send 
understanding examples labview prograph show tell reminds classic knights puzzles knights tell truth lie indistinguishable 
typical example taken rips goes says says type knights 
answer goes follows suppose knight said false different knight hypothesis 
alternatively suppose knight type hypothesis 
answer 
rips showed subjects university students training formal logic poor scores problems 
exact explanation matter disagreement cognitive theorists means possible give complete account impose avoid hard mental operations 
research needed investigating psychology testing comprehensibility vpls 
hidden dependencies hidden dependency name suggests relationship components dependent dependency fully visible 
older text languages side effect form hidden dependency function subroutine altered value global variable 
today classic example spreadsheet 
formula cell tells cells takes value tell cells take value 
worst case sheet cell cell certain safe change cell 
hidden dependencies apparently responsible high error frequency spreadsheets possibly spreadsheet programmer hopes best checking consequences change 
spreadsheets viewed data view mode formula view mode problem acute 
examples include gotos subroutine structures subroutine cases absence come means risky change code 
vpls especially data flow goto dependencies explicit subroutines remain problem may amplified nesting 

readers commented obscure exactly point 
units price item unit price units price tax total price apples 
tax total hidden explicit dependencies 
spreadsheets top contain hidden dependencies interfere comprehension debugging cell records cells refers indicate cells supplies data 
data flow representation bottom left dependencies visible increases viscosity 
conventional imperative text languages bottom right variables names remembered matched symbolically perceptually classed partially hidden 
notice required material visible cases dependencies hidden 
cross call graphs remedies hidden dependencies conventional languages antecedents dependents trees remedies data flow languages 
computed targets permitted computed gotos general remedy possible 
unfortunate consequence impossible discover objects live referred object dead 
small systems exhaustive search may discover objects dead 
large systems search infeasible system accumulates objects presumed dead throw away just case aren dead 
unix typically contain large number hidden dependencies large numbers dot files data scripts fact system 
hidden dependencies severe source difficulty 
eisenstadt recorded detail activity lengthy sessions recorded types problem 
directly related hidden dependencies problems traversal indirect data influences data flow requires detective 
understanding precise conditions particular event happens control flow logic requires detective effects debugging dramatic illustrates 
application contrast text languages box line representation data flow scores really local level lines making local data dependencies clearly visible 
labview prograph avoiding problem 
labview uses virtually variables prograph act global variables 
different positions design space 
prograph position presumably globals allowed program get cluttered lines 
read units tax units total tax local dependencies visible long range data dependencies different issue 
prograph extraordinarily large number long range hidden dependencies created combination deep nesting lack overview nesting structure 
programmer quickly navigate call graph clicking method icons open window clicking icons way proceed call graph way 
general discover method calls method determine preconditions require extensive search 
alleviate difficulty searching tool provided interesting know successful tool expert users 
premature commitment user forced decision information available 
problem arises notation contains internal dependencies medium working environment constrains order doing things order inappropriate 
try writing contents list page numbers write book 
difficulty see efforts little idea initial choices nature system choices forced re ready 
general enforced look ahead danger premature commitment occurs internal dependencies components ii order constraints restrict components created 
may consequences programmer readily recover commitment system fluid viscous 
discussion viscosity see section 
system viscous catastrophic 
observation suggests programmers cope enforced guess ahead various ways working problem advance mentally leaving placeholders needed going back fill holes 
second style repeatedly observed studies programmers pascal languages 
unfortunately know comparable studies vpls 
application vpls box line representation commitment order creating code text languages 
typically allow code developed order allowing programmers expand conceptual goals subgoals order compatible conceptual order come mind 
kinds lookahead problems arise 
shall identify number forms observed 
interesting example occurred pursuit environment visual programming demonstration difficult explain see commitment layout obviously visual programmer mark virtual page 
program takes shape may clear mark unfortunately placed subsequent marks ill placed respect 
way adjust layout viscosity may high comfort 
certainly case complex lab view programs 
commitment connections dimensional layout vpls requires subroutines associated callers ports definite placing 
target languages easily finds data terminals arranged order wants particular purpose 
example prograph order terminals usually chosen minimise wire crossings lookahead get right quite extensive simple rocket program unnecessary crossings occur 
shows visual spaghetti created looking ahead example drawn practically method window opened author file prograph programs 
point possible looking program true language 
point needs lot look ahead avoid making mess 
worse high viscosity languages takes time clear mess gets left 
visual spaghetti 
avoid programmer look ahead 
example prograph problem occurs labview box wire language 
commitment order creation interpretation program depends order entities created risk premature commitment 
visual spreadsheet cleverly model constraint systems evaluation certain formulas depends order creation cells shuffle operator build cells wrong order delete start 
potential example occurs forms visual data type event receptors represented screen cells 
cells overlap screen top cell gets event 
difficulty clever cells created right order created receive event user means shuffle order 
commitment choice construct programmer chooses syntactic construct adds code construct may turn subsequently construct wrong changed 
programmers may prefer postpone commitment particular construct code developed 
gray anderson noted novices problems construction lisp conditionals 
lisp conditionals require programmer early commitment particular form instances change episodes cases programmer guess wrong undone 
early versions labview suffered exactly problem control construct selected tiresome chore change 
versions labview solve premature commitment problem partly postponing commitment making easier change decision specifically possible draw loop existing code just statement inserted textual program 
progressive evaluation standard finding domains novices need evaluate problem solving progress frequent intervals 
possibility progressive evaluation essential novices 
experts usually live prefer instance experts tend run programs frequently debugging novices 
consequently programming environment needs support progressive evaluation partially finished programs 
opposite type environment contrast prohibits testing program completely ready 
compiled run 
programmers arounds defeat systems example early stages development pascal programmers regularly procedure stubs empty procedure definitions declaration part body write procedures full 
application labview programs executed wire sound data sink attached source subroutines required 
requirements similar pascal 
prograph hand excellent progressive evaluation 
fact allow nonexistent program evaluated new code added time evaluation runs go incorrect partial results computed programmer options simply changing data transmitted changing code executed causing execution roll back repeat 
role expressiveness folklore programming widely agreed programming languages hard read unfortunately ones hard widely agreed 
dimension role expressiveness intended describe easy answer question bit studies comparative comprehension equivalent programs expressed different notations cases cause difficulty clearly presence hard mental operations poor secondary notation role expressiveness presumably enhanced meaningful identifiers structured modularity secondary notation signal functionally related groupings presence beacons signify certain highly diagnostic code structures 
note interest readily available target languages 
role expressiveness improved adding explicit description level 
hendry green shown works spreadsheets vpls explored 
application labview programs identifiers poor secondary notation admittedly limited experience contain obvious beacons 
structured welldefined subroutines programmers case sequence constructs simply modules 
prograph programs contain identifiers poor secondary notation 
standard clich code groups possibly serve beacons 
programmers forced syntax create methods easy signal modularity putting module method 
prograph contains notable piece lexical ambiguity annotation methods tick cross 
annotation self disclosing necessary remember structure shown means case test fails case test fails far better introduce indicator show meant 
especially unfortunate problem arises expression conditionals difficult best circumstances source potential trouble programmers 
assist deciphering rocket program readers may know meaning fact case test fails 
conditional test prograph combines icon greater icon saying test fails unfortunately explicit indication means stick case failure switch case failure 
secondary notation escape formalism programming languages allow extra information carried means formal syntax commenting choice naming conventions choice programming construct grouping related statements 
techniques place formal semantics algorithm convey meaning human reader 
regrettably extra channel communication programmer reader little investigated 
domains experts regard indispensable 
petre green electronics cad designers regarded component placement valuable resource substantial difference readability schematic 
conversely experienced designers apparently produce schematics hard read experienced designers 
applies programming give experts languages scope secondary notation creating complex programs need understood date forgotten program worked 
novices hand possibly benefit start constrained system secondary notation minimised pure conjecture research needed 
difficulties researching area may secondary notation idiosyncratic private tightly managed industrial programming 
laboratory settings shown secondary cues indentation improve comprehension known indentation styles vary greatly observations expert programmers wild showed secondary notation different ways petre preparation 
conventional programming languages surprisingly allow substantial amount secondary notation 
basic version rocket program statements collected paragraphs help reveal rhyme vertical horizontal components treated 
allows reader check see differences just expected vertical component allows gravity horizontal 
revised version allowed air resistance component obvious 
thrust cos angle mass gravity thrust sin angle mass paragraphs frequently textual languages 
note white space choice statement order get desired effect 
closely related secondary notation possibility escape formalism altogether 
programming language captures programmer say program 
programs means communication mechanism provided escape bounds formalism 
petre green electronics designers cad packages point 
programmers need map program domain tell story need document sources part follows method doubts intentions part untested ll check soon 
green put forward argument formalised means allow programmers desired assertions program description level 
main existing resource comment applied single program primitive combination primitives 
comments apply single primitive useful means communicating programmer view program structure 
application large gaps existing research study effects secondary notation vpls 
target languages opportunities layout means express secondary aspects limited 
prograph secondary notation fact nil 
comments attached primitives userdefined methods data ports groups objects commented 
method boxes principle laid window practice layout dominated wish keep dataflow lines reasonably tidy case deep nesting prograph code methods means code visible window opportunities layout communicate quite restricted 
labview flatter representation information window careful placement operators data lines possible show relationships parts program 
requires practice exceedingly tiresome system noted viscous 
comments attached operators wires groups 
backgrounds coloured may useful times 
rocket program processing paths vertical horizontal components laid similar fashion emphasize algorithmic similarities rhyme allows nearly possible simple accurate perceptual level comparison laid differently topological comparison needed 
achieve parallelism means moment 
contrast swift re arrangements possible basic pascal 
expert labview programmers see important 
informants reported quite spend hour just moving boxes wires change functionality comprehensible come back hard imagine pascal programmer having spend hour doing re arranging components program comprehensible 
text programmers aware need white space usually solve go 
hand text programmers spend time going back program inserting comments 
case swings 
regard weak secondary notation serious deficiency vpls typical existing box line designs 
visual grid systems offer different possibilities 
repenning agentsheets system replaces box line sheet agents organized grid see section 
need interaction constrains placement agents probable arrangement modified programmer convey extra information 
thorough going approach create explicit description level 
hendry green added simple description level commercial spreadsheet system 
system deliberately minimal avoid raising abstraction level unnecessarily 
allowed tags attached groups cells necessarily contiguous user control shading attached tagged cells 
tagged regions linked arrows 
simple allowed representation assertions corpus descriptions spreadsheets professional users 
viscosity resistance local change viscosity fluid resistance local change 
apply programming languages information structures mean user put effect small change 
obviously depends precise change general programming languages environments need 
standard example viscosity having global change hand environment contains global update tools 
smart environment reduces viscosity introducing abstractions 
see detailed account viscosity 
viscosity matters 
studies programming show changes revisions course programming activity specifying designing coding 
programmers designers stupid careless human reasoning works need see sketch talk back 
skilled designers moderate problems heads 
normal designers easy problems heads 
big hard problems heads 
ones effects viscosity apparent 
impression dataflow vpls low viscosity 
add extra bit code break wire insert new boxes 

box line style favoured vpl designers easily viscous system diagram editor 
potential layout viscosity box line notations means diagram editors essential 
component moved individually layout viscosity extremely high shown 
better method treat links rubber bands 
application straw test viscosity change version rocket program added code take account air resistance exerting drag proportional square velocity 
topological change program tiny time taken change different programming languages 
wanted measure time edit program time taken solve problem straw test conducted stages 
author tg constructed modification appendix shows labview solution example took screen dump 
gave experienced user original program screen dump required final result timed long took edit original programs required shape 
inserting material labview took surprisingly long time boxes wires rebuilt 
prograph able absorb extra code deal air resistance little difficulty certainly evidenced labview 
new code placed new windows relatively little change existing layouts 
basic problem just typing lines 
time taken follows labview seconds prograph seconds basic seconds astonishing ratio extremes 
differences order magnitude programs larger expect increase proportionately increase faster labview slower basic 
visibility visibility dimension denotes simply required material accessible cognitive readily visible readily accessed order visible readily identified order accessed 
long intricate search trails poor visibility 
contrast hidden dependencies 
visibility measures number steps needed item visible hidden dependencies describes relationships manifest 
important component ability see portions program screen side side time 
early days programming programs relatively short little difficulty seeing program lengths increased orders magnitude necessary take drastic steps 
steps development notations high level operations notably apl 
increased procedures libraries hide localised detail 
procedures improves visibility level levels create real problems 
example hypercard little packets code scripts different places stack 
single script local visibility code usually associated closely object uses 
result dispersal visibility low 
noted section debugging difficulties eisenstadt caused hidden dependencies poor visibility 
early versions hypercard allow scripts viewed time 
code button remembered compared code 
happily oversight remedied 
spreadsheets layers data formulae asymmetric visibility 
sheet displaying data formula exactly cell visible 
obviously difficult compare formula 
sheet displaying formulas comparisons easy longer possible see values computed formulas loses point spreadsheet model 
viewing related components simultaneously essential model programming 
cognitive justification twofold 
programmers solve problem refining earlier solution related problem need simultaneous access pieces code 
ii programmers understand program just local inspection looking sweep things order form requiring ability view simultaneously quite number program items may widely dispersed 
absence side side viewing amounts psychological claim problem solved independently problems 
side side viewing supported environment programmers choices 
rely working memory frequently refreshed revisiting items compared turn hard copy component study 
second strategy amounts decoupling environment proving new environment side side viewing possible 
serious visibility problems remedied provision browsers smalltalk class browser provision alternative views instance hypercard problems eased systems providing contents list cards stack 
advanced systems especially lisp community allow definitions procedures functions called instantly navigating levels easier sufficient remedy different parts viewed simultaneously 
notice passing remedies rely view different abstraction main programming language 
application labview visibility areas conditionals problem 
total arm labview conditional visible moment true false 
shows arms conditionals rocket program side side view 
designers labview doubt opted preserve excellent closeness mapping labview program schematic improve visibility 
labview conditional rocket program showing arms 
labview environment arm visible screen time 
conditionals nested serious difficulty making hard answer questions program behaviour sorts stuff hidden away inside conditional sort maze explored 
fact subject performance worse lab view text study labview users electronics designers answered questions conditionals :10.1.1.57.1633
demand placed working memory invisible arms just 
visibility prograph weakened deep subroutine structure rat hole expert prograph programmer described creating steep visibility problems 

discussion psychologists difficult assess broad sweep programming language ways study certain details laboratory computer scientists difficult see creations point view inexperienced non specialist 
cognitive dimensions framework provides evaluative technique easy understand quick 
section report state vpl design cognitive dimensions framework 
cognitive dimensions framework tell designer evaluating system sufficient users designer wants know 
system unsatisfactory improved 
answer concentrate standard remedies trade offs 
standard remedies provide ways improving performance selected dimensions repeatedly emphasized changes arbitrarily 
fixing problem dimension usually entail change dimension 
designer choose degree dimension change properly conceived framework dimensions pairwise orthogonal arbitrary pair dimensions altered second held constant long dimension allowed vary 
standard remedies sound familiar 
viscosity reduced increasing number abstractions object oriented programming systems 
increasing abstractions tends create hidden dependencies clear abstractions instantiated consequences change quite abstractions bring problems visibility local visibility may remote visibility may poor example encapsulated subroutines abstractions subroutines may promote increased compared readily cost losing sight calling context 
increasing abstractions change closeness mapping better worse program structure map closely problem structure choosing right abstractions designing possible change forced creation abstractions designed reduce viscosity map problem domain 
abstraction level high problems arise user quite forced imposed guess ahead abstractions defined programmed point may apparent abstractions ill conceived abstraction hungry system usually problem delayed gratification takes lot get started manipulating understanding abstractions requires hard mental operations 
cases awkwardness remedied adding tools programming environment browsers display dependencies hidden 
usually partial remedy 
distractions invoking browser break pattern problem solving limited view browser programmer opportunistically advantage information sources 
progress cognitive dimensions cognitive dimensions framework finished entity 
actively seeking formalization device structure allow state relationships dimensions defined terms example help remove overlaps exist 
intend explore gaps revealed management abstractions interactive devices 
intention explore framework applicability types information artifact 
ultimate test approach practical hope framework put designers users researchers deficiencies insights reported 
pleased note successes 
approach evaluate improve design visual programming demonstration system write technique provides experts novices ability examine artifact proceed quickly high level discussion 
attribute compact shared vocabulary cognitive dimensions evaluation techniques 
technique provided insights designer working system years 
buckingham shum hammond evaluated graphical notations design rationale variety criteria cognitive dimensions framework helps underline wide applicability approach 
lastly yang developed framework practical system designers visual languages 
proposed variety easily measured benchmarks demonstrated applica bility different types visual language 
carried small study test benchmarks usable designers graduate students comprehend ideas successfully evaluate designs 
best results suggest design evaluated angles 
available evaluation techniques different strengths weaknesses 
best known goms claims analysis programming walkthroughs 
goms particularly strong evaluation low level aspects time taken edit diagrams giving estimates time taken perform standard operations 
programming walkthroughs derived cognitive walkthroughs hci contrast goms knowledge intensive approach intended determine programmer needs know solve task 
claims analysis derived general hci approach applied smalltalk hypercard technique rests thesis artifact embodies psychological claims user interaction process 
easy non specialist claims analysis particular demands high level psychological sophistication 
evaluation suggest combining approaches cognitive dimensions approach giving broad brush overview system process perspective ii programming walkthrough knowledge intensive analysis iii goms methodology examine detail frequent editing tasks 
constructing altering graphic layout example natural target goms analysis straw viscosity test reported suggests learnt 
progress vpl design having reviewed state vpl design offer needs tentative 
interesting unexpected points emerge vpl design stands may look progress 
construction programs probably easier vpls textual languages reasons fewer syntactic planning goals met paired delimiters discontinuous constructs separators variables higher level operators reduce need awkward combinations primitives order activity programmers proceed best putting pieces program 
issue needs study 
professional designers need able pursue design order allowing concentrate parts crucial 
estimate vpls easier ought assist designers substantive studies design activity visual environments 
ii secondary notation poorly developed box wire notations examined making harder understand believe large scale studies comprehension reported 
achieve aim making better visual medium vpls need facilities colouring commenting grouping 
recommend explicit description level 
techniques reduce cluttered wire problem greatly increase scope spatial layout form communication 
types representation agentsheets may offer possibilities emerging technology representations may helpful 
iii representation control flow remains problem vpls examined 
sections documented examples poor visibility need hard mental operations supported cases direct empirical observations apparent close similarity studied structures self embedded sentences knights puzzles 
impression remains problem general dataflow model needs vigorous consideration 
computational models may resolve difficulty course 
particularly area designers vpl environments beware assuming foresee users problems experience general field hci supported view 
iv viscosity surprisingly high languages looked 
role diagram editor crucial research papers visual programming literature discuss design effective diagram editors 
straw viscosity test range minute minutes making semantically equivalent changes programs different languages 
visibility poor 
systematic easy understand search tools need developed user tested possible de facto standards adopted 
famous real estate problem liability supposed 
believe respects vpls offer substantial gains conventional textual languages hci aspects developed 
improvements secondary notation editing searching greatly raise usability 
grateful friends colleagues list 
particular peter david hendry richard potter darrell raymond lengthy discussions visual programming colleagues rachel bellamy brad blumenthal david gilmore martin gilbert cockton robin jeffries friends contributed approach 
randy flanagan allowed time performance experienced labview user 
ann blandford wayne anonymous referees helped clarify wording structure 
labview trademark national instruments prograph trademark tgs systems 
international 

anderson farrell 
learning program lisp 
cognitive science 

bell rieman lewis 
usability testing graphical programming system things missed programming walkthrough 
proceedings acm chi conference human factors computing systems pp 
new york acm press 

bellamy carroll 
restructuring programmer task 
int 
man machine studies 

bellamy gilmore 
programming plans internal external structures 
keane erdos eds 
lines thinking reflections psychology thought 
vol 
pp 
new york wiley 

black 
visible planning screen impact working medium decisionmaking novice graphic designers 
behaviour information technology 

robertson vasconcelos vargas vera 
applying prolog programming techniques 
int 
human computer studies 

brooks 
theory cognitive processes computer programming 
int 
man machine studies 

buckingham shum hammond 
argumentation design rationale cost 
int 
human computer studies pp 


burnett ambler 
interactive visual data abstraction declarative visual programming language 
visual languages computing 

card moran newell 
psychology human computer interaction 
hillsdale nj erlbaum 

carroll kellogg 
artifact theory nexus hermeneutics meets theory design 
lewis 
eds proc chi wings mind 

new york acm 

carroll rosson 
evolution view matcher design space 
human computer interaction 

curtis sheppard bailey bailey boehm davis 
experimental evaluation software documentation formats 
systems software 

davies 
skill levels strategic differences plan comprehension implementation programming 
sutcliffe macaulay eds 
people computers pp cambridge cambridge university press 

davies 
role notation knowledge representation determination programming strategy framework integrating models programming behavior 
cognitive science 

davies 
characterising program design activity strictly top globally opportunistic 
behaviour information technology 

davies 
information coding activities effects expertise environment task 
cook scholtz spohrer eds 
empirical studies programmers th workshop pp 
norwood ablex 

davies 
individuals groups artifacts changing semantics design software development 
gilmore winder eds 
user centred requirements software engineering environments 
pp 
berlin springer verlag 


expert programming knowledge schema approach 

hoc green gilmore ay eds psychology programming pp 
london academic press 

domingue price eisenstadt 
framework describing implementing software visualization systems 
proc 
graphics interface pp 

toronto canadian information processing society 

eisenstadt 
debugging painful ought 
diaper guest eds 
people computers vii proc 
hci conference 
pp 
cambridge cambridge university press 

evans st 
reasoning knights discussion rips 
cognition 

gilmore 
expert programming knowledge strategic approach 

hoc green gilmore ay eds 
psychology programming pp 
london academic press 

gilmore green 
programming plans programming expertise 
quarterly exp psychol 


gray anderson 
change episodes coding programmers change code 
olson sheppard soloway eds empirical studies programmers second workshop 
pp 
norwood ablex 

green 
conditional program statements comprehensibility professional programmers 
occupational psychology 

green 
learning big little programming languages 
wilkinson ed classroom computers cognitive science pp new york academic press 

green 
cognitive dimensions notations 
sutcliffe macaulay eds 
people computers pp 
cambridge cambridge university press 

green 
cognitive dimension viscosity sticky problem hci 
diaper gilmore cockton shackel eds 
human computer interaction interact 
pp 
amsterdam elsevier 

green 
describing information artifacts cognitive dimensions structure maps 
diaper hammond eds 
proceedings hci usability annual conference bcs human computer interaction group pp 
cambridge cambridge university press 

green navarro 
programming plans imagery visual programming 
appear gilmore 
interact pp 
london chapman hall 

green petre 
visual programs harder read textual programs 
van der veer tauber eds human computer interaction tasks organisation proceedings sixth european conference cognitive ergonomics ecce pp 
rome 

green fitter 

art notation 
coombs eds 
computing skills user interface 
pp 
london academic press 

green bellamy parker 
parsing model device 
olson sheppard soloway eds 
empirical studies programmers second workshop 
pp 
norwood ablex 

green gilmore blumenthal davies winder 
cognitive browser oops 
int 
human computer interaction 

green petre bellamy 
comprehensibility visual textual programs test match mismatch conjecture 
koenemann moher robertson eds empirical studies programmers fourth workshop 
norwood nj ablex 
pp 


olson 
comprehension differences debugging skilled novice programmers 
soloway iyengar eds 
empirical studies programmers pp 
norwood ablex 

hendry green 
visual description language spreadsheets 
journal visual languages computing 

hoc 
analysis beginners problem solving strategies programming 
green payne van der veer eds 
psychology computer 
pp 
london academic press 

johnson laird byrne 
meta logical problems knights rips 
cognition 

kimura choi mack 
show tell visual programming language 
glinert ed visual programming environments paradigms systems 
pp 
new york ieee press 

koenemann robertson 
expert problem solving strategies program comprehension 
robertson olson olson eds 
reaching technology proc 
acm conf 
human factors computing systems chi pp 
reading ma addison wesley 

larkin simon 
diagram worth words 
cognitive science 

lewis 
creating interactive graphics spreadsheet machinery 
glinert ed visual programming environments paradigms systems pp 
los alamitos calif ieee computer society press 

lewis olson 
principles cognition lower barriers programming 
olson sheppard soloway eds 
empirical studies programmers second workshop pp 
norwood ablex 

lewis rieman bell 
problem centered design expressiveness facility graphical programming system 
human computer interaction 

mayer 
cognitive aspects learning programming language 
carroll ed 
interfacing thought pp 
cambridge mass mit press 

green myers visual programming visual domain case study cognitive dimensions 
cockton draper weir eds 
people computers ix proc 
hci 
pp 
cambridge cambridge university press 

moher mak blumenthal 
comparing comprehensibility textual graphical programs case petri nets 
cook scholtz spohrer 
eds empirical studies programmers fifth workshop 
norwood nj ablex 
pp 


monk walsh dix 
comparison hypertext scrolling folding mechanisms program browsing 
jones winder eds 
people computers iv pp cambridge cambridge university press 

nardi 
small matter programming perspectives user computing 
mit press 

neal 
system example programming 
lewis 
eds proc chi wings mind 

new york acm 

nguyen xuan hoc 
learning command device 
european bulletin cognitive psychology 

norman 
cognitive artifacts 
carroll ed 
designing interaction pp 
new york cambridge university press 

olson olson 
growth cognitive modeling human computer interaction goms 
human computer interaction 

ball 
programming knowledge design strategy determine shifts focus prolog programming 
cook scholtz spohrer eds 
empirical studies programmers th workshop pp 
norwood ablex 

halverson jr 
individual group spreadsheet design patterns errors 
proc 
th hawaii intl 
conf 
system sciences hawaii vol iv pp 

payne green 
task action grammars model mental representation task languages 
human computer interaction 

pennington 
stimulus structures mental representations expert comprehension computer programs 
cognitive psychology 

pennington 
comprehension strategies programming 
olson sheppard soloway eds empirical studies programmers second workshop pp 
norwood ablex 

pennington grabowski 
tasks programming 

hoc green gilmore ay eds 
psychology programming pp 
london academic press 

petre green 
draw line text claims logic designers graphics notation 
diaper gilmore cockton shackel eds 
human computer interaction interact pp 
amsterdam elsevier 

petre green 
learning read graphics evidence seeing information display acquired skill 
journal visual languages computing 

reisner 
apt description user interface inconsistency 
int 
man machine studies 

repenning 
agentsheets design evolution domain oriented visual programming languages 
phd dissertation 
univ colorado boulder dept computer science 

repenning 
agentsheets applying grid spatial reasoning humancomputer interaction 
proc ieee workshop visual languages pp 
los alamitos ca ieee cs press 

rips 
psychology knights 
cognition 

rist 
plans programming definition demonstration development 
soloway iyengar eds empirical studies programmers pp 
norwood nj ablex 

rist program structure design 
cognitive science 


robertson davis okabe fitz 
program comprehension line 
diaper gilmore cockton shackel eds 
human computer interaction interact pp 
amsterdam elsevier 

ay 
acquisition programming knowledge skills 

hoc green gilmore ay eds 
psychology programming pp 
london academic press 


visual information chunking spreadsheet calculation 
int 
man machine studies 


extracting implicit tree structures spreadsheet calculation 
ergonomics 


transforming verbal descriptions mathematical formulas spreadsheet calculation 
int 
human computer studies 


goals plans basis user interfaces spreadsheet calculation 
eds west east pp 
finland university press 

scaife taylor 
graduated learning environments developing computational concepts year old children 

artificial intelligence education 

shneiderman 
user interface hypertext multi window program browser 
interacting computers 


smart students solve simple programming problems 
int 
man machine studies 

shum 

cognitive dimensions design rationale 
diaper hammond eds people computers vi proceedings hci pp 
cambridge university press cambridge 

sinha vessey 
cognitive fit recursion iteration empirical study 
ieee transactions software engineering se 

soloway 
empirical studies programming knowledge 
ieee transactions software engineering se 

spohrer soloway 
novice mistakes folk correct 
comm 
acm 
reprinted soloway spohrer eds 
studying novice programmer pp 
hillsdale nj erlbaum 

spohrer soloway pope 
goal plan analysis buggy pascal programs 
human computer interaction 


effects naming style expertise program comprehension 
int 
human computer studies 

vessey 
cognitive fit empirical study information acquisition 
information systems research 

visser 
plan design opportunistic deviations specification 
int 
man machine studies 

axtell 
interplay cognitive organizational factors software development 
appear gilmore 
eds human computer interaction interact pp 
london chapman hall 


initial stages program comprehension 
int 
man machine studies 

weiser 
programmers slices debugging 
comm 
acm 

wright reid 
written information alternatives prose expressing outcome complex contingencies 
applied psychology 

yang burnett zloof 
representation design benchmarks aid vpl navigable static representations 
oregon state university corvallis dept computer science technical report 
appendix viscosity test appendix show modified versions rocket program 
straw viscosity test gave experienced user original program print appropriate modified version timed modification process 
appendix revision labview 
program modified labview user tg 
step surrounding box enlarged space new operation icons 
moving icons adjusting wires quite operations elements slightly different configuration relative positions original layout approximately reproduced 
steps enabling steps meet planning goals 
new icons dropped space inherent goal 
seen new section densely packed hard read 
confirming parallel operations performed vertical horizontal components considerably harder new subtraction icons shown rings differently laid comparisons topological perceptual 
appendix revision prograph 
effects existing layout minimised entering new code new windows 
price worse visibility 
horizontal component right illustrates prograph special device complex arithmetic formulas 
mass fuel force gravity tim angle tim force mass mass fuel force cos angle mass gravity sign force sin angle mass sign print tim tim tim appendix revision basic program 
additional code required allow air resistance shown italics 

