theory program refinement doctor philosophy university edinburgh mo ph give canonical program refinement calculus lambda calculus classical order predicate logic study proof theory semantics 
intention construct metalanguage refinement basic principles program development studied 
idea possible induce refinement calculus generic manner programming language program logic 
concreteness adopt simply typed lambda calculus augmented primitive recursion paradigmatic typed functional programming language classical order logic simple program logic 
key feature construction refinement calculus modular fashion combination orthogonal extensions underlying programming language case simply typed lambda calculus 
crucial observation refinement calculus extending programming language allow indeterminate expressions stubs involving construction program 
factoring study extensions lambda calculus providing separate analyses call true stubs structured specifications 
questions concerned calculi stubs interact programming language suitable notion structured specification program development 
full refinement calculus constructed natural way combination subcalculi 
claim subcalculi orthogonal extensions lambda calculus justified result refinement factored simpler judgements subcalculi logical reasoning simple decomposition 
semantics calculi henkin models additional structure 
simply typed lambda calculus order logic interpreted henkin models 
subcalculi require extra structure full refinement calculus modelled henkin models combination extra requirements 
soundness completeness results calculus virtue certain embeddings models infer refinement calculus conservative extension subcalculi turn conservative extensions lambda calculus 
gordon plotkin john power supervising thesis providing advice encouragement 
hope suffering writing vain 
marcelo supervised early stages 
john famous chats 
useful conversations alex joe morris moreira hasegawa thomas david aspinall st brn 
supported epsrc studentship final year part time research contract gordon plotkin 
thesis examined don sannella peter hearn 
helpful comments 
parents support 
ran 
declaration declare thesis composed contained explicitly stated text 
table contents chapter 



calculi 




choices 





notation 
chapter preliminaries simply 
syntax 





chapter refinement terms 

chapter syntax 
judgements 

metatheory 
models 


chapter refinement types 
example 

syntax 
judgements 



metatheory 
revisited 
models 

chapter refinement calculus 

syntax 
judgements 



comparisons 

aspinall asl 

lego 

metatheory 
models 
chapter discussion 


chapter 






annotations 


secondorder 



cycle 
prototyping 
maintenance 

appendix notation bibliography chapter program refinement programming methodology formal description program specification gradually refined executable program satisfying specification 
thesis study program refinement simple idealised programming specification language 
analysis theoretical give motivation practical considerations 
kind issues concerned logical machinery semantic principles involved program refinement 
interesting fragments refinement calculus practical uses 
program logic suitable specification language program refinement 
understanding general relationship refinement calculus programming language program logic 
structure calculus inform architecture tools program development 
pose questions general terms concreteness typed calculus paradigmatic functional programming language classical order logic program logic 
hope making clear choices affect analysis attain degree generality 
significance decisions discussed 
order address questions carry modular analysis simple refinement calculus 
suggest refinement calculus understood combination extensions underlying programming language accounting specifications call pure refinement 
just lambda calculus metalanguage studying functional programming languages lambda calculus refinement calculus develop metalanguage studying refinement functional programming languages 
interest studying metalanguages provide simple setting fundamental issues studied 
purpose analysis justify consider refinement viable methodology develop industrial strength refinement calculus fully theory refinement limited area 
ultimately knowledge help delimit boundary manual automated program development theorem provers 
certainly theory specification programming necessary precursor having tools support automatic manual refinement synthesis 
suggest theory inform construction tool 
give overview issues involved refinement calculus built 
start description refinement methodology program development section section describe related notion program verification terms simple satisfaction relation programs specifications relevance program logics refinement 
see essentially themes refinement structure specifications internalisation development discussed section give overview calculi thesis 
section compare particular form refinement studied methodologies 
section discuss significance choices programming language program logic 
sections describe related summarise thesis 
refinement methodology describe program refinements constructed consider features calculus order formalise refinement 
uses refinement 
methodology construction correct programs 
second refinement form basis framework programming knowledge collections refinements 
contradiction terms say 
stepwise development programmers write programs mixture top bottom development 
central method top development idea stub 
suppose writing program main body needs sorting function lists 
prefer get structure main body correct writing sorting function order get program compile type check declare sorting function give dummy body stub 
fun sort nil function defined sort list conceptually inelegant 
practically program compile run programmer bear mind true code 
testing behaviour partially written program taken account 
way avoiding behaviour depends dummy bodies kind error exception mechanism stub 
entirely satisfactory possible programmer forget various stubs left program 
better language construct allows true stubs written 
sorting function written fun sort int list idea int list stands unwritten code type int list 
type checked system give warning message effect certain lines code remain implemented 
able compile run partially written programs 
general possible program just big stub 
understanding programs stubs lets possible 
true description part programmers practice 
little convenient notation recording development program sequence abstractions 
essence refinement lies able full expressive power program logic 
just stub program logic say program 
just specify type program extend meaning program proposition contain free variable type 
example suppose defined predicates sorted permutation order logic 
write fun sort 
int list sorted permutation thought description program takes list returns list sorted permutation nondeterministic function returns contrast nondeterminism refer underdeterminism central importance thesis discussed detail 
think combinations logical specifications program code kind program 
languages combine program specification constructs way called wide spectrum languages 
proceed doing case analysis input 
input nil list clearly just return nil list 
form xs decide sorted 
decompose nonempty list correct insertion element sorted list sorted sorted sorted write insertion proposition list insertion list thatis int list int list proposition prove sorted insertion sorted idea replace specification sorting constructive form 
fun sort 
int list nil nil int xs int list xs xs int list sorted xs permutation xs xs insertion xs specification recursive form 
assuming existence refinement rule lets replace recursive specification recursion specification aim shift recursion specification code 
clearly explained example 
write insert specification int list int int list int list int insertion introducing recursion sorting specification fn int list listrec nil insert specification insertion sort 
may large step cover similar example detail chapter 
decompose specification simpler specification insertion function code carry recursion list 
development far represented process refinement piece unwritten code corresponding original specification summarise sort fn int list 
int list nil nil int xs int list xs xs int list sorted xs permutation xs xs insertion xs fn int list listrec nil insert hierarchical separation concerns illustrates stepwise refinement methodology program development 
idea gradually implement specification stages 
stage simplify specification possibly decomposing combination introduce program code 
refinement seen consisting alternating phases 
hand logical specifications replaced equivalent specific amenable implementation 
decomposition rules specification split number simpler specifications introducing program constructor 
refinement inherently top methodology bottom aspect 
want programs written library say 
called problem reduction program directly implement specification 
example written insertion function able take library 
illustrate simply assuming free variable ins int list int int list int list int insertion ins 
final step refinement ins int list int int list int list listrec nil insert int list listrec nil ins typical general form programming problems 
practice question ask library component programs implement specification 
start empty context decomposition specification construct subprograms 
represent formally global context assumptions form meaning program type proposition contain holds 
example insertion function assumed ins int list int int list int list int insertion ins final step refinement follows simple rule problem reduction important characteristics refinement stepwise piecewise 
stepwise mean specification refined program number small steps piecewise means large specification refined piece time knowledge leads valid refinement specification 
means calculus rules refinement relation transitive compositional respect program constructors 
refinement rules syntax directed far possible 
features refinement calculus 
place requirements output convenient assumptions input 
example specification search function assume input list sorted 
expressed notation fun search sorted bool true allowed fact sorted implementing body 
int list sorted type programming language produce function works arguments type int list 
particular implementation specification produce result unsorted lists 
point purpose implementing specification matter result unsorted lists 
sense regard implementations give results sorted lists 
write int list sorted int bool int list sorted int bool specification functions int list sorted bool equality specification 
intention annotating stubs logical properties course eventually replaced code satisfying property 
slogan refinement methodology correctness preserving programs automatically correct construction 
requiring refinement step preserve properties program eventually constructed chain refinement steps specification guaranteed satisfy original specification 
proof correctness carried essentially sideeffect program construction 
easier verifying completed program independent construction 
start refinement mixture specification code correct refinement 
mean individual rules correct 
related question specifications logic refinement relate 
natural specify program mixture logic algorithm 
discuss specifications detail 
just want able reason programs able reason programs 
formalise defining notion satisfaction specifications programs extending programs 
carried context assumptions form satisfaction judgement sat xn sat pn sat say refinement rule correct means specifications sat sat notation refinement suggestive fact refinement inequality 
raises question relationship bears underlying equality programming language 
general address questions conservativity refinement calculi program logics equational theory programming language 
addition completeness refinement respect logic possible sat able obtain program refinement programming knowledge researchers portrayed refinement framework eventual automated programming tools seen sole selling point notion equivalence programs 
refinement methodology 
doubt constructing program refinement involves just writing directly 
point discipline imposes offers framework programming easily carried 
feel aspect refinement sufficiently emphasised literature 
actual programming practice involves sequence decisions programmer figures solve problem 
figuring implement specification programmer number insights order informally justify decisions 
sequence decisions usually discarded just leaving final program 
approach reasonable program intended consumption computer 
program comprehension necessary program intended processed humans 
activities essential verification maintenance 
difficulty understanding programs arises need rediscover insights programmer writing program place best retained 
led study paradigm programming derivations primary 
scherlis scott ss discuss need logic programming distinct logic programs 
early advocate refinement program comprehension wirth wir 
idea explaining program refinement principle applied program optimisation 
executable program may consist optimised spaghetti level structured code derivation 
relationship justified optimising transformations 
particular knowledge application domain collected library programs paired specification prog sat spec 
viewed refinement spec prog give information useful programmer 
insightful read relationships sequence abstractions 
similarly teaching purposes algorithms general programming principles best explained refinement levels abstraction 
knowledge experienced programmers essentially having solutions generic problems apply particular situations 
empirical studies shown programming knowledge encapsulated collections derivations se 
certain extent modern programming languages encourage programmers indicate levels abstraction data types structured programming methods possible express structure program text 
refinement paradigm applicable programming languages development methodologies 
program logics specification specification computer program formal description essential properties 
correctness program means satisfies intended specification verification task establishing correctness 
verifying program satisfies specification sense dual refining specifications programs 
program properties expressed number ways 
consider logics propositions refer programs program logics 
term program logic specifically order dynamic logic harel har see survey vl example generally logic programs consider 
harel har gives survey different techniques proving program correctness 
basic distinction drawn extensional intensional properties 
extensional functional properties concerned program input output behaviour viewing black box 
formally say properties preserved extensional equality suitable inductive definition 
intensional properties hand depend structure program 
examples notions include complexity program style 
concerned extensional properties say section 
program analysis nie task program finding specific class properties satisfies 
typically computational nature strictness properties binding times 
specification hand generally complex properties 
concreteness classical order equational theory calculus program logic 
lay basis chapter give outline 
pre expressions types terms tn tt propositions tn variable contexts propositional contexts respect collection ground types constants primitive predicates extensional predicates iszero 
formedness judgements proof judgement wf meaning values types proposition holds holds 
question write specifications program logic 
simplest choice write allowed free specification property program type holds 
satisfaction judgement formulated sat meaning values types proposition holds type holds 
take judgement derived abbreviation axiomatise directly structure correspondence theorem 
example rules sat sat sat really just alternative presentation logic consider give satisfaction rules 
possible rules structure terms sat sat sat spirit refinement types introduce notion specification 
chapter give set theoretic semantics logic making extensionality clear prove sound complete 
real difference specification proposition program logic specification possesses structure large 
important structure specifications order handle large scale complexity involved real systems 
structure allows reason specifications compositional way particular carry component wise refinement 
distinguish approaches structuring specifications algebraic type theoretic 
distinction best illustrated considering datatype specified 
signature basic types operations axioms signature 
axioms base logic specifications constructed top 
generates theory datatype consisting theorems provable axioms 
algebraic specification generated theory regarded specification structuring specifications takes place level theory 
example take union theories 
theory level structuring contrasted structuring signature 
type theory signatures axioms existential types specifications combined type theoretic constructors 
example take product specifications 
axioms type theory 
section suggest third approach combines aspects algebraic type theoretic specification 
calculi observed discussion refinement section basic construct calculus means expressing 
factor study separate extensions construct 
believe extensions independent interest providing respectively analyses pure refinement structured specifications 
coming direction expect refinement subsume verification able extend verification calculus section minimal way get refinement calculus 
ask question satisfaction system minimum additions needed get refinement calculus 
essentially things need added notion structured proof structure transferred proof program means backwards search 
additions correspond extended calculi mentioned structured proofs refinement types internalisation backwards search refinement terms 
refinement terms develop simple equational theory refinement lambda calculus true stubs 
ml notation fun sort int list write lambda term int list int list 
call lambda terms possibility stubs refinement terms refer possibility terms partially determined underdeterminism 
careful distinction underdeterminism nondeterminism regard computational opposed phenomenon 
example regard abstractions underdetermined body determined authors led viewing terms nondeterministic 
difference just intuition different axioms satisfied 
imagine nondeterminism underdeterminism arising concurrent setting example 
particularly important maintain distinction 
elaborate differences chapter 
logic calculus may simple interesting worth studying number reasons 
full refinement calculus quite complicated act stage understanding full system 
see justified virtue full calculus conservative extension 
secondly having logical annotations stubs possible automatically check formedness fact evaluate terms cases 
calculus serve basis simple practical program development system 
forms judgement calculus 
letting range refinement terms give judgements typing xn refinement xn refinement subsumes equality defined mutual refinement 
lambda calculus possible regard typing derived judgement meaning clearer keep judgements separate 
refinement rules decomposition problem reduction intuitively think programs terms evaluate computing mathematical value 
think programs terms implemented 
intuitive way think set realizers obtained possible ways filling stubs program code 
refinement subset relation 
axiomatise refinement complete respect semantics 
intuition see determined terms substituted variables substituting directly duplicate underdeterminism 
example term nat nat equal nat nat expect nat nat nat 
similar reasons computational lambda calculus mog leads introduce construction albeit different axiomatisation :10.1.1.41.840
direct motivation introducing construct comes considering result combining underdetermined terms 
suppose programs developed depends 
partially developed programs andr free variable intended replaced program current state development 
want consider system prove property say just substitute 
combined system represented term type 
refinement types give calculus formalise specification language program logic 
task phrased general terms addressing question suitable notion specification programming language properties interest expressed program logic 
just interested input output relations programs classical order logic suffice program logic 
section program logic give specifications directly noted section useful abbreviation combining specifications 
write specification functions arguments satisfy return result satisfies 
formulation specifications useful reasoning inductively 
general idea type constructors combine specifications 
similarly write specification pairs left component satisfies right satisfies 
saw section natural introduce notion equality specification 
leads take specifications primitive types 
combination program logic type theory programming language form refinement types 
general idea refinement types levels underlying level program types expressive level program properties treated types 
expressive level specifications 
provides alternative simply program logic type theory irrespective logic discuss advantages chapter 
simple extension replacing types refinement types affords considerable degree conceptual simplicity 
satisfaction specifications programs formalised refinement typing judgement 
write sat regard satisfaction generalised typing write 
terms calculus extended allowing refinement types abstractions 
subsumes idea indicating assumptions input annotating types abstractions 
contexts consist variable assumptions form 
means refinement typing judgement formalises satisfaction specifications programs assumption programs satisfy specifications 
convenient essential allow propositions assumptions context 
need define notion refinement specifications refinement types 
replacement specification logically specific replacement stubs code 
just program logic refinement specifications logical implication 
refinement types define refine ment judgement give form subtyping specifications type 
refinement calculus combine calculi stubs specifications get logical refinement calculus 
fundamental construct logical stub refinement type 
logical stubs combine specifications code gives useful means specifying programs 
example refinement type sorted list specify search function nat sorted list bool true rules refinement calculus natural generalisations subcalculi 
satisfaction specifications programs generalised programs idea program property program refine property 
lets ask partially developed programs properties guaranteed fully written 
refinement rules underlying logic just introduced notion equality specification refinement specifica tion 
write refinement refinement type omit significant 
fact idea significant 
refinement calculus kinds refinement inherited 
reflect programming practice 
partially implemented program consists mixture logical specification program code 
stage options open write code replacing piece specification concrete program modify specification replacing equivalent specification constrained 
connection logic refinement rule particular case rule example search function specified information sorted expressed refinement typing sorted list refining body 
sufficient derive uses logic refinement 
example refinement steps generate proof obligations factored instance decomposition 
summarise want calculus prove propositions prove refinement typings correctness preserving refinement rules prove refinements form generalise ordinary program equality 
extension lambda calculus usual equivalences hold addition express refinements 
construct refinement calculus modular fashion combination calculi 
justified understanding refinement calculus way conservative extension subcalculi 
summarise important judgements different calculi indicate connections calculi classes models 
upwards arrows intended indicate conservative extensions calculi inclusions models sense correspondence meanings judgements 
methodologies refinement just methodologies formal program development approaches include program extraction deliverables example 
idea start formal description behaviour judgements refinement terms refinement calculus inclusion calculi refinement terms refinement types refinement terms refinement types determined terms types theories models refinement calculus refinement types simply typed calculus order logic henkin henkin models logical factoring henkin models factoring henkin models overview calculi models structure program usually expressed logical language construct program meets description 
idea program refinement construct program stepwise manner specification explicit record stage development wide spectrum language 
advantage wide spectrum language convenient specify mixture logic algorithm 
refinement formal program development methodology refinement step preserves correctness program guaranteed meet description 
possible study refinement encoding type theory assuming programming language constructs suitably encoded necessarily case presence recursion 
luo luo gives encoding data refinement extended calculus constructions 
explicit calculus refinement advantage forces think directly formalism semantics 
contrast drawn program data refinement 
refinement program written data type stacks rewritten concrete data type lists say 
data type stack seen specification implementation lists refinement program 
program refinement hand starts specification program datatype 
thesis concerned program refinement 
authors see data refinement central concept program development 
basis vdm methodology jon example 
believe calculus data refinement incorporate program refinement anyway stepwise development datatype include stepwise development operations programs program refinement natural starting point 
similar concept called programs program development program skeletons 
templates code expressing useful algorithm schemes divide conquer 
regard refinement terms simple formalisation skeletons kind meta entity 
general express skeletons parameterisation parameters range code contain local variables 
people program refinement program transformation synonyms 
basic idea generalised include useful draw distinction refinement logical specification concrete code transformation concrete program code better code 
thesis notion refinement incorporate program transformation 
key aspect approach refinement equational paradigm viewing refinement kind generalised equality spec prog 
equality natural thing consider studying lambda calculi notion program equivalence primary reasoning programs languages 
important example hardware derivation 
study refinement higher order manner terms prove refines 
possibility 
search oriented system user starts specification directly refines program explicitly indicating refinement 
useful practice curiously equational paradigm received far attention refinement calculus community 
search oriented system natural formalism program synthesis 
leave conjecture time equational refinement calculus theory generated search calculus 
choices involves choices typed language functional language 
providing element syntax direction types help narrowing number refinement rules applied stage 
explained types structure specifications 
choose functional language simply theory better understood 
lambda calculus paradigmatic functional language comes flavours 
part longer term research plan tackle problem finding refinement calculi complicated computational scenarios modular way finding refinement calculus simply typed lambda calculus extending suitable way 
consider full recursion 
may significant omission non termination significant addition calculus require various choices central basic theory refinement 
founded recursion sufficiently expressive get interesting programs 
reasoning involved constructing fully recursive terminating programs constructing programs founded recursion 
classical order logic program logic 
intention able choose arbitrary logic corresponding refinement calculus induced general rules 
turns fact choose extensional logic 
logic extensionally equal propositions 
refinement calculus essential replacing equals extensional equals possible specifications described intensional properties programs 
intuitionistic logic property matters atomic propositions extensional 
classical order logic example simple expressive logic 
lambda calculi extensional logics better understood intensional calculi connections 
approach taken start programming language specification language equational theory notion satisfaction 
reasonable understand language equational theory concerned extensional properties 
alternative approach start operational semantics programming language understand satisfaction operationally 
example equational theory considered generated call name operational semantics 
sort question addressed find natural refinement calculus corresponding call value semantics say 
related group relevant way comparison calculi thesis 
describe related concepts underdeterminism structured specifications calculi program development 
refinement terms study indefinite descriptions goes right back earliest modern logic ros idea description ranges semantic values 
hilbert collaborators introduced operator see monograph lei formalisation indefinite descriptions order provide alternative formulation mathematical logic 
expression meaning defined denotes unknown fixed element satisfies exists denotes arbitrary fixed element 
logic expressions modelled arbitrary fixed choice function picks member nonempty set returns empty set 
means value interpretation terms depend denotes constant function 
operator indefinite descriptions essentially localisation global variables 
descriptions appear embedded term just global variables denotation value 
imagine similar technique purposes terms calculus thought kind parameterised programs 
simplest choice just consider terms free variable global context representing hole filled program code 
variable capture prevents variable replaced programs contain local variables 
embed underdeterminism locally terms construct 
discuss chapter 
hermida jacobs study indeterminates lambda calculus hj essentially form global indeterminacy account substitution allowing variable capture 
published refinement calculi fully axiomatised systems 
morgan mor describes classical refinement calculus developed independently back morgan morris 
imperative language extended specification constructs 
system uses nondeterminism express specification constructs 
believe mistake nondeterminism computational phenomenon distinct view underdeterminism phenomenon level programming language 
want consider combination nondeterminism underdeterminism example developing logic program 
proof development systems lego lp allow users interactively construct proof refinement 
intermediate states proof development may modelled underdetermined terms 
idea allowing existential variables terms similar refinement terms 
similar vein called logical variables artificial intelligence essentially concept 
extensive comparison refinement calculi back lego section 
concept underdeterminism arises linguistics name underspecification semantically ambiguous statements student noun phrase studied 
bos bos example considers language metavariables representing statements 
refinement types number authors advocated program analysis annotated type systems 
example non standard type system program logic paradigm nn system binding time analysis optimisation 
jensen jen performs strictness analysis intersection types primitive types indicate termination 
burn bur considers general framework intersection union types 
systems property deductions refinements pfenning introduced term refinement type gave refinement type system expressing properties mini ml programs fp 
pfe gave extension lf possibly intensional properties normal form property derivations refinement types 
allow refinement types abstractions 
works idea refinement types offer greater expressivity carefully restricted retain desirable properties 
coppo damiani giannini cdg quite similar approach refinement types dead code elimination 
give semantics pers 
various approaches type theorists combining logic types 
feferman system variable types fef extends subset types equality depend type 
refinement refinement types defined logic explicitly axiomatised 
talcott tal similar form refinement types underlying theory untyped feferman order express local information transformations introduce continuations 
lacks typed equality local assumptions discharged take form satisfies say 
type theoretic approaches include asp ac differ concerned subtyping type families 
dependency level types allow dependent structure refinement type level 
aspinall asp dependent type theory formally similar subtyping dependent functions products 
dependency comes singleton types special case subset types 
purpose aspinall system specification language give type structure specification building operations 
system subtyping refinement types 
discuss aspinall thesis 
hayashi hay rich type theory conservatively extending polymorphic lambda calculus singleton union intersection types 
refinement type philosophy maintaining distinction types specified subsets order eliminate non computational information program extraction 
refinement types allowed abstractions 
dependent function product types defined constructors hay subset types constructed full second order intuitionistic logic 
type theory notions realisability refinement 
pointed hayashi schemas specification language spi seen refinement types 
comprise parts typing declaration logical predicate collection axioms 
deliverables approach bm mck consider program paired proof correctness 
similarly motivated wanting structure specifications program types differ proof existence important proof terms need witness satisfy refinement type 
mck mckinna suggests dropping requirement proof existence implementations regarded equal extensional equivalence :10.1.1.45.9064
proposes definition specification includes explicit definition 
calculus regarded internal language notion 
luo luo presents encoding specifications specification morphisms corresponding terms expressive type theory 
provides direct analysis concept specification giving explicit syntax axiomatisation 
existential form martin type theory subset types nps similar refinement types regarded providing alternative interpretation system 
program refinement community traditionally unstructured specifications form 
example morgan mor describes refinement calculus propositions order predicate logic 
refinement calculi papers refinement calculi authors area explicit proof theoretic axiomatisations refinement logic reasoning refinement terms 
laws usually introduced needed 
proving properties partially developed programs considered sense regarding programs specifications satisfying property amounts refinement 
classical refinement calculus back morgan morris bac mor mor dijkstra guarded command language dij calculus deriving imperative programs specifications expressed terms preand postconditions order logic 
consider refinement expressions 
guarded command language nondeterministic refinement calculus influenced refinement calculi nondeterminism specification 
bun continued approach functional language retaining imperative features state monad style computational lambda calculus 
nh ward war consider functional languages untyped lambda calculus 
authors calculi nondeterminism see consequences axiomatisation refinement 
presence nontermination nondeterminism gives rise choice nondeterminism choice arising computational considerations believe unnecessary 
consider nontermination 
authors considered total correctness leads nondeterminism 
ward adds nondeterminism doubtful brings advantages considering concurrency 
mentioned algebraic approach specification section 
program specification development methodology vl centred data types 
adt specified algebra sense universal algebra signature satisfies collection axioms 
simple specification consists signature collection axioms signature 
various theory level operators combining specifications 
simplest approach programs thought total algebras various extensions cope partiality errors 
styles semantics 
hand specification viewed exact description program semantics defined specific algebra initial terminal algebra specification respect algebra homomorphisms 
hand specification taken description required properties program leaving possibilities open 
loose approach semantics specification taken collection algebras satisfy specification possibly restriction reachable algebras 
loose approach appropriate program development 
refinement thought implementation specification defined formally sp implementation sp sig sp sig sp mod sp mod sp model inclusion signature 
general semantic definition refinement 
axioms proving refinements example 
elaborate notions terms constructors abstraction developed sannella tarlecki st 
extended ml san kst wide spectrum language extends subset functional programming language ml 
similar calculus essentially specification features place holder facility incorporate logical axioms signatures 
see section discussion 
bb system rules finding programs inhabit specifications 
partial terms representing intermediate steps search inhabitation explicit refinement relation 
lego proof system lp notion refinement proof state 
regard refinement terms representations proof state lego notion refinement 
relational calculus ruby js essentially untyped functional language extended inverses 
inverses gives language power 
specifications ruby usually functions refinement amounts equational transformation 
summary thesis chapter preliminary definitions rest thesis 
give basic equational theory simply typed lambda calculus describe applied theory booleans naturals 
give firstorder logic theory explaining induction formalised 
calculus logic semantics henkin models class non standard set theoretic models define 
prove soundness completeness equational logical theories respect class models 
chapter give calculus refinement terms 
add terms simply typed lambda calculus formalisation true stubs getting system study call simply typed underdeterminism 
judgements calculus show terms expressed particular canonical form derive results refinement 
show refinements standard form replacement stubs code precedes equational reasoning 
terms interpreted henkin models type ascribed set terms context interpreted appropriate notion environment subsets show terms expressed canonical form prove completeness calculus respect class models 
study order logical theory refinement atomic propositions refinements give semantics henkin models logic proven sound complete 
infer logical theory conservative equational theory 
fact order logic equality chapter complete respect class models able show refinement equivalent proposition order logic involving equality 
chapter give calculus refinement types 
involves analysis suitable notion specification refinement independently considerations underdeterminism 
argue natural syntax representing partial equivalence relations pers specifications 
terms denote equivalence classes pers 
refinement typing subsumes typing formalises satisfaction specifications programs 
refinement relation refinement types 
judgements calculus interpreted structure sets henkin model 
prove soundness completeness respect henkin pers lets conclude system conservative extension lambda calculus order logic 
chapter combination subcalculi giving refinement calculus refinement specifications order logic lambda terms 
syntax full refinement calculus rn rr rn show subcalculi embedded full refinement calculus defining relations terms generalise nonlogical refinement logical equality systems 
show logical refinement factored relations 
extend result chapter standardisation refinements full calculus 
calculus simple underdeterminism refinement terms interpreted sets 
refinement terms refinement types interpreted pers henkin models show generalises semantics subcalculi 
prove soundness calculus careful completeness formulated 
restricted class terms omitting higher order features completeness various judgements respect interpretation class models 
chapter suggestions suggesting simple notion refinement described extended situations refinement incorporated larger theory program development 
notation martin mar refer atomic statements theory basic judgements 
judgements formedness truth 
general form judgement general form assumption hypotheses context free variables 
thesis contexts consisting combination variables propositional assumptions 
metavariable contexts appropriate whichever calculus consideration 
write judgement empty context just metavariable conventions thesis listed appendix top level grammar syntactic categories expressions basic judgements ref wf wf judgements chapter preliminaries chapter give theoretical basis build refinement calculus 
describe simply typed lambda calculus products explain formulate applied theories 
theory booleans naturals primitive recursion particular example 
define henkin interpretations models give semantics lambda calculus 
describe order logic equational theory simply typed lambda calculus show modelled henkin interpretations prove completeness theorems 
simply typed lambda calculus base theory refinement explicitly typed church style formulation simply typed lambda calculus cro mit 
simply typed lambda calculus means finite products axioms signature ground types constants emphasis axioms feature thesis 
syntax terms applied lambda theory respect signature ground types constant symbols 
definition type signature consists collection symbols call ground types 
define simple types type signature bythe grammar technical reasons assume signatures thesis countable bother repeat assumption 
order define notion constant type signature follow mitchell mit making distinction types sorts 
constant ascribe sort metalevel construct explains form formed terms constant 
definition sort type signature arity list simple types write sort functional notation 
definition type signature 
define constant signature collection symbols constants ascribed sort definition signature sg consists type signature constant signature write indicate constant signature sg sort 
mean welltyped term formed arguments correct types tn term tn formed type 
example conditional formed term type bool 
alternatively chosen give constants functional type choice significant 
practice drop brackets arguments constants allow form mixfix notation 
write sort nullary constants just write 
consider nullary constants functional type ambiguity unary constants 
definition signature sg grammar tn tt type assume countably infinite number variables drawn set strictly speaking set parameterised signature variables 
adopt convention writing variable drawn set variables type 
metavariables ground types constant symbols respectively 
henceforth assume existence signature writing 
contexts constructed types variables grammar notation obvious meaning construct contexts assume variables context distinct 
assumption formedness external system 
calculi give explicit rules formedness contexts 
ordering variables important simply typed lambda calculus significant extended calculi chapters 
typing judgement means assumption term type typing rules standard cro mit repeat 
judgements context variable typings xn write sg judgement derivable signature sg drop sg clear signature intended 
write fv set free variables notation indicate capture avoiding substitution free occurrence variable simultaneous substitution tuple syntactic environment variables context indicated similarly 
write distinguish free occurrences variable mean free variable appears free writing may indicate substitution 
adopt usual notational conventions lambda calculus avoid excessive bracketing example tx means tx 
round brackets increase readability 
write syntactic equivalence bracketing equivalence contrast provable equality defined 
obvious extensions conventions hold syntactic categories introduced 
weakening permutation substitution rules derivable typing judgement 
case equality judgement presence axioms add rules section 
axiom systems give extralogical axioms top logical axioms basic theory respect particular signature 
common literature distinguish collection axioms theory generate 
definition axiom system consists signature sg collection ax equations context typed respect sg sg sg 
theorems generated rules kinds rules pure theory calculus rules inferring theorems axiom system 
figures give rules pure theory calculus give additional rules necessary inferring theorems arbitrary axiom system 
possible give stronger rule substitution derive congruence rules prefer give explicitly establishing pattern calculi 
definition sg ax axiom system 
define theorems sg ax equations inferred rules figures 
write sg ax indicate equation theorem axiom system sg ax general assume types inhabited closed terms 
recall complete equational theory simply typed lambda calculus differs depending empty types allowed semantics mm 
explicitly state assumption inhabitation necessary giving completeness theorem 
booleans naturals booleans natural numbers running example axiom system thesis 
consider complex data types regarded simple case study datatypes treated refinement calculi 
add booleans naturals ground types bool nat reflexivity symmetry transitivity constants rules equational reasoning succ true false natrec section take time explain meaning various constants 
signify boolean truth values numerals 
metavariables expressions type bool nat respectively 
fact family recursion operators natrec 
explicit introduce polymorphism just ignore unimportant point 
similarly separate conditionals type ignore 
give equations booleans naturals figures 
constant primitive recursion 
natrec nat nat axiomatise constants equationally opposed giving operational semantics idea natrec loop applied times stage example function sum natrec nat nat add xy allow abuse language referring loops termination 
primitive recursion natrec loop times guaranteed terminate 
corresponds loops imperative languages 
function equations product equations unit equation tx congruence equations fv tn tn equality rules axioms weakening permutation substitution ax theorems generated axiom system sg ax axioms true bool false bool bool true true false false bool bool true false axiom system booleans axioms nat succ nat nat natrec nat nat nat natrec zs nat nat natrec zs succ sn natrec axiom system naturals iteration special case primitive recursion stage number 
natiter th composite formally natiter nat natrec sx subsequent chapters explain treatment constants extended richer calculi naturals booleans examples 
equalities booleans equality 
equality deduce commuting conversion models simply typed lambda calculus give interpretations calculus henkin models 
form non standard set theoretic model simply typed lambda calculi particular systems containing arithmetic complete 
usual concrete models applied lambda calculi consider henkin models order get completeness 
give church style semantics interpreting typing derivations write linear shorthand derivation judgement 
chapters interpret pre judgements derivations 
fixed signature define henkin interpretations stages 
definition sg signature 
sg applicative structure products tuple families indexed types generated sg proj proj app type just ground types ascribe set constant function ka projection application maps proj proj app henkin interpretation applicative structure additional conditions extensional satisfies environment model condition 
definition applicative structure products extensional exactly element proj proj app app proj proj proj proj meanings environment 
contexts xn environment tuple ai range environments notation form obvious environment 
write indicate environment interpretation generally drop obvious interpretation intended 
extensionality allows implicit interpretations abstractions pairs unit unique 
guarantee elements structure interpret terms 
second condition forces models elements simply saying interpretation exists 
define interpretation terms extensional applicative structure 
write meaning term context environment henkin interpretation usually drop strictly speaking arbitrary applicative structure defines partial meaning function 
give semantics assume fact total 
definition applicative structure satisfies environment model condition interpretation defined 
definition say applicative structure henkin interpretation extensional satisfies environment model condition 
general bijection mediated projection functions proj proj induced pairing map 
general embedded bijective fora write unique element proj proj 
write write environment ina 
definition henkin interpretation signature sg 
say henkin model axiom system sg ax axiom ax theorem soundness henkin model axiom system sg ax sg ax proof proof induction derivation judgement 
remarked complete axiomatisation lambda calculus depends nonemptiness types assumed 
types allowed empty form case analysis emptiness require having special rule logic powerful derive section 
alternatively wider class models mm 
just assume types syntactically inhabited closed terms type 
fact completeness slightly weaker assumption suffice system closed strengthening 
tn tn unique unique proj proj ma unique app ma proj proj tt app interpretation terms simply typed lambda calculus theorem completeness equational system sg ax axiom system types syntactically inhabited 
henkin models sg ax sg ax proof give sketch proof 
idea construct minimal term model signature ground types constants equational assumptions empty types 

fix infinite context infinite number variables type 
judgements mean finite example means 

define set equivalence classes open terms type 
write equivalence class 
nonempty variables type 
projection application constant interpretation mappings interpreted syntactically 

fact contains infinite number variables type show extensional 
app app tx equations function equations 
condition products straightforward 

prove obvious meaning 
environment model condition holds henkin interpretation 

means correctly sg ax 
ax infer andthe interpretation henkin model sg ax 
arbitrary equation true term model xn setting xn gives inhabitation implies conclude completeness equation true models true term model provable 
order logic simply typed lambda calculus follow pattern section define notion signature axioms signature 
extend signatures primitive predicate symbols called relation symbols 
definition order signature consists signature collection predicate symbols arity sort list types write pred 
definition sg order signature 
sg tn types respectively 
atomic propositions equalities predications 
constructors sufficient define 
need formedness judgement sg wf omit rules 
particular proposition formed type pred predication tn formed ti list propositions write sg wf 
sg wf definition order axiom system consists order signature sg collection ax closed propositions formed sg sg wf 
take axioms order logic closed propositions simplicity sake important quantification gives expressiveness allowing propositions context 
allowing arbitrary closed propositions axioms subsumes equational axioms axiom systems 
adopt convention subsequent chapters schematic rules included calculus rules understood calculus metavariables range expressions calculus 
figures give rules classical natural deduction modified allow possibility empty types 
rules necessary give derived rules connectives 
form judgement means variables proposition true true 
property want proof system provable judgements formed 
necessary place formedness conditions formulae appear hypotheses 
example infer pre proposition definition sg ax order axiom system 
define theorems sg ax propositions inferred rules figures figures 
write sg ax indicate theorem axiom system sg ax thesis important distinction booleans propositions 
booleans terms computational datatype evaluated propositions expressions logical language 
common blur distinction program development frameworks reason branches conditionals booleans propositions refine proposition conditional proposition condition 
making distinction clear refinement propositions specifications booleans part program development 
gives order axioms booleans naturals 
induction rules expressed schemas closed propositions inference rules 
derive general rules sg wf sg bool wf true false bool sg wf sg nat wf nat succ nat retain equational axioms figures part order axiom systems 
conjunction disjunction implication universal quantification falsehood sg wf sg wf natural deduction rules classical order logic equality assumptions axioms sg wf sg wf sg wf ax natural deduction rules cont 
defined order logic simply typed lambda calculus include rules section derivable 
convention axioms arbitrary contexts means rules superfluous 
general equality rule reflexivity derive rules congruence equations 
induction rule booleans says true false closed booleans 
prove bool true false fact implies equality booleans 
rule mathematical induction deduce computational induction nat sg nat nat natrec sg wf founded induction nat 
nat sg nat wf booleans true false bool sg bool wf naturals nat succ nat sg nat wf order logic booleans naturals models order logic give henkin models order logic 
define interpretations particular signature 
definition order signature 
order henkin interpretation henkin interpretation family subsets interpret predicate symbols pred gives interpretation propositions order henkin interpretation 
interpret formed propositions context wf set environments holds usually drop superscript write mean henkin interpretation say write 
definition sg ax order axiom system 
henkin interpretation signature sg model sg ax axiom ax reason studying logic complete class models equational theory 
completeness respect class henkin models axiom system 
order prove completeness arbitrary axiom system construct term model theory 
main problem lies constructing witnesses tn tn interpretation formed propositions existentials 
achieve notion henkin theory vd 
henkin theory property proposition isint 
definition order henkin theory axiom system sg ax context collection propositions formed closed derivation sg ax proposition construct henkin theories adding witness variables existentials care empty types 
pointed definition assume countably infinite set variables type 
definition context set propositions 
define henkin closure procedure 
enumerate types 
type decide inhabited 
define proposition inh 
list formed propositions form pn inhabited 
countable signature countable 

list variables yn yn yn pn 
define henkin closure yn pn pn yn 
henkin models 
infinite supply variables context necessary meet definition henkin theory proof 
point completeness proof construct maximal henkin theory 
theorem soundness completeness logical system sg ax order axiom system 
sg ax iff henkin model sg ax proof soundness straightforward prove 
completeness minimal henkin model logical system term model order prove deductive completeness showing consistent theory satisfiable 
axiom system sg ax sg ax iff henkin models sg ax 
note assume types nonempty 

sg ax want find henkin model sg ax environment 
construct maximal consistent theory infinite context ax henkin theory 
henkin closure ax 
consider consistent theories form partial order theories ordered pairwise inclusion 
poset nonempty contains deductive closure member henkin theory 
poset closed unions chain upper bound 
zorn lemma collection maximal element 

define term interpretation equivalence classes open terms provably equal 
renaming variables assume loss generality terms open write equivalence class iff 
show extensional 
interesting case function types 
show ta inhabited 
contains infinitely variables inhabited type exists variable appear tx tx maximality consistent terms implication trivially holds 

prove satisfies environment model condition henkin interpretation 

prove iff induction proof rules construct 
fact maximal consistent theory formed proposition crucial case virtue henkin theory 
follows henkin model sg ax axiom clearly 

extension property xn define environment xn andthen corollary completeness results deduce order calculus conservative equational calculus 
corollary sg ax axiom system 
types inhabited sg ax iff sg ax proof systems complete respect henkin models statements interpretation 
chapter refinement terms chapter develop theory simple refinement 
see addition aspects refinement stubs skeletons top program development studied language 
give calculus short express constructs simple semantics henkin models calculus proven sound complete 
introduce extension simply typed lambda calculus expressing notion call underdeterminism 
consider term type nat 
term determined sense complete knowledge 
suppose know term type returns pairs left component know right component 
write means unknown type possibly depending 
allow stand subterm formed local context unknowns contain variable contrast variables indeterminates 
stub type parameter writing term substitute term formed global context 
point variable capture substitute get course crucial stubs 
determined term nat term type nat 
general partially constructed terms anyway intuition tells term nat carries information nat chapter den 
nat 
prove equivalences general consider specialisation ordering type nat nat nat study underdeterminism interacts usual equational rules interest calculus comes belief fundamental aspect program development 
refinement methodology program development consists writing term meaning program satisfies specification transforming step step actual program satisfying specification 
view types rudimentary specifications defer study logic chapter 
believe worthwhile study underdeterminism isolation logic difficulty reasoning refinement calculi understanding underdeterminism interacts programming features 
section describe language refinement rules 
equational theory studied part simple logic 
give simple denotational semantics section show calculus complete proving refinements valid class models 
calculus give syntax language classes judgements 
give syntactic results short example refinement 
syntax start defining notion signature 
fact signatures axioms defined previous chapter significance discussed 
definition signature sg consists collection ground types ranged collection constant symbols ranged assigned sort 
extend simply typed lambda calculus underdeterminism construct meaning term type 
view type rudimentary specification refer terms holes programs supplied refinement terms 
assume fixed signature types constants 
types contexts rn rr say term determined contains stubs subterms form 
call term underdetermined 
range determined terms arbitrary underdetermined terms 
note primitive constants determined 
fact term lambda calculus determined 
converse hold allow determined 
see determined term provably equal term simply typed lambda calculus 
intuitively think term kind description specification determined terms example nat term specifies pairs terms term type nat 
conversely satisfies nat formally denotes set values 
program refine denotes member set 
abstraction set functions nondeterministic function 
intuitively refines tions argument refinement 
nondeterministic program takes argument returns term 
provably equal eliminate determined subterms show determined term provably equal ordinary term simply typed lambda calculus 
terms language denote sets values want regard variables ranging single values order retain familiar rules allow determined terms substituted variables 
axiomatisation expressions asin computational lambda calculus mog way discharging arbitrary underdetermined term substituting directly variable defers substitution refined determined lets reason substitution 
expression refines refinement refinement ofr 
assume types inhabited closed terms various statements restriction 
avoids semantic complications mentioned chapter 
empty types may may appropriate particular programming language assumption independent calculus specification 
reader assume assumption means calculus interest studying program specification traditional type theoretic approaches specifications viewed possibly empty types 
idea chapter types specifications specification may unsatisfiable ordinary program type 
specification nat set natural numbers notation subsequent chapters nat 
judgements axiomatise equational theory basic judgements typing refinement context variable assumptions 
usual lambda calculi equations type drop significant 
write refinement asr indicate determined note authors refinement 
take equality derived notion defined mutual refinement 
reasonable show semantic argument calculus conservative extension simply typed lambda calculus determined terms mutually refinable provably equal contexts formed wf contain distinct variables 
adopt convention writing judgement assume context formed 
typing judgement axiomatised 
just extends rules simply typed lambda calculus typing rules constructs 
write sg indicate typing judgement derivable signature sg 
axiom systems define notion axiom system respect signature set typed equations context determined terms 
variables constants unit stubs product terms function terms terms rn rn rr typing rules definition axiom system sg ax consists signature sg collection ax equations context typed respect signature sg sg 
discuss allow axioms arbitrary refinements 
assume fixed axiom system sg ax 
definition sg ax axiom system 
define theorems sg ax refinements inferred rules figures 
write sg ax indicate refinement theorem axiom system sg ax write equality mean mutual refinement extend rule convention mentioned previous chapter include rules equality rules taken mutual refinements 
gives rules inferring theorems axiom system 
natural extension rules chapter condition substitution restricted determined terms 
equality rules figures top lambda calculus chapter read mutual refinements 
rules determined terms 
show various generalisations arbitrary underdetermined terms prefer give axioms calculus minimal form clearly shows refinement axiomatisation top underlying equational theory 
figures axiomatise underdeterminism combines program constructs expressions 
rules taken computational lambda calculus 
exception rule abstractions explicit hidden dependency specifications variables context 
specification abstraction refined terms contain remarked important difference 
outside applied 
rule addition moggi computational lambda calculus significant consequences see lemma 
logically think rule form abstractions correspond universal quantifications existential quantifications 
axioms weakening permutation substitution ax theorems generated axiom system sg ax view associativity abbreviation nested term 
note assumption formedness contexts omit side conditions occurrence variables 
example associativity formed isnotin figures axiomatise refinement relation 
intuition refinement relation correspond increase information decrease possible programs term refine 
top rules decomposing specification refinement combination simpler ones 
weakening rule weakening may thought claiming auxiliary lemma congruence rule lets derive corresponding rules pairs applications projections 
number similar refinement rules destructors sequent style bottom rules making context derived propositions respectively 
equality rules figures chapter beta eta associativity equality rules example definitions signatures axiom systems 
just axiomatisation booleans naturals chapter figures 
important point axioms equations determined terms refinements 
practical implication enrich language new operations extra required give refinement rules equalities trivial form refinement 
valid refinements derivable rules calculus unnecessary come new rules 
theoretical justification follow completeness theorems 
axiom system rules give sufficient prove true refinements 
indicate done case booleans 
need general rule combining terms constants 
constant wehave xn rn xn rn booleans gives example bool constants rn xn rn xn rn applications pairs projections abstractions xx rr zx equality rules cont 
variables constants unit pairs abstractions refinement rules congruence reflexivity transitivity weakening fv refinement rules cont 
abs refinement rule constant 
sg combination congruence rule terms particular bool nat bool say term satisfiable exists determined refines unsatisfiable 
consequence way axiomatised constants particular conditional unsatisfiable term see type nat conditional true unsatisfiable 
apply equation true determined 
contrast refinement calculi nondeterminism bun mor worth considering expect term unsatisfiable 
calculus equational idea terms represent stages search program 
expect term arisen refinement intention refine conditional branches refined program code 
possible term unsatisfiable 
fact satisfiability term depends satisfiability subterms means reason specifications compositionally 
order implement specification need just implement components 
alternative implementation combine resulting specifications implementation 
adhere principle modular decomposition advocated sst 
principle applies refining application terms see 
consider naive approach free variables sufficient 
suppose represent stage refinement term xn free variables xn qn xn xn 
free variables stand unwritten programs refine replace free variable term possibly introducing free variables constraints 
refine ym say introducing new free variables ym constraints rm ym ym address possibility refining abstraction 
constraint global free variable 
represent variables abstractions functional variables write fx fx just avoids issue unwritten program representation variable type progress 
logically leads arbitrarily nested quantifiers 
fact logic refinement formalism just 
justifies need theory refinement handle reasoning naturally 
naive global variables unable account variable capture form variable labelled local context 
need distinction variables representing taken representing remains implemented 
suggestions system logical variables section 
refinement calculi traditionally formulated terms kind specification construct variations stubs 
equivalence axiomatisation terms logical variables subject 
nonterminating undefined term 
call value operational semantics nat true 
inhabited call name semantics 
inhabitant 
significantly show interpreting cpo provide sound model 
chapter noted hilbert operator differs 
particular models global choice function abstraction interpreted constant function 
equational theory 
developed chapter idea substitute arbitrary underdetermined terms variables terms 
expressions denote individuals substituted terms 
example sound 
fact operator axiomatised adding case underdetermined terms 
logic hol proof assistant contains polymorphic operator bool 
modelled choice function explicit refinement 
lemma provides insight underdeterminism 
stubs embedded term give canonical form underdeterminism moved outside 
example nat equal nat nat fx term viewed simple combination program specification 
lemma terms context exists determined term context xn xi appears exactly xn proof rules move underdeterminism outwards important case abstractions 
note linearity stub counts exactly canonical form refines 
linearity appeals lemma 
note canonical forms need unique 
useful abbreviation xn canonical form 
example nat equal nat fx fact repeated pairing express terms simpler form convenient write xn stands local context xn write informal notation xn 
expressing terms canonical form prove results expressions 
results hold computational lambda calculus 
lemma rules admissible 
commutativity 
contraction 
strengthen local context fv proof prove 
show zx abstractions zx weakening zx congruence lemma form associativity beta associativity form proofs carried similarly expressing terms canonical form 
commutativity corresponds idea matter order solve subproblems long depend contraction says solve identical problems just solving problem solution twice 
third rule illustrates dependence underdeterminism context 
determined terms satisfy term left refining possible outside bound variable right 
types inhabited fact terms satisfiable 
rule weakening strengthened equality fv fact derive strengthened forms equality products equality units chapter arbitrary underdetermined terms appropriate type 
proposition types inhabited 
ri 
proof 
derived second equality refining determined term type andthe instance weakening 

suppose type 
canonical form say type 
unit equation prove inhabited equals 
strengthen equality abstractions assumption nonemptiness 
proposition admissible proof auxiliary result type ft fx ft proposition derive landin equation principle possible define terms abstraction application 
lead unnatural looking equivalents axioms 
significant reason making primitive equation fails incorporate logic calculus chapter 
proposition reduce applications arbitrary function bodies 
significant means underdetermined terms executed point ordinary programs 
general possible evaluation proceed stub encountered 
example reduced 
observation form basis single step operational semantics discuss chapter 
point pause review motivation studying calculus 
program refinement stepwise decomposition logical specifications gradual replacement code 
calculus studying formalises refinement limited form specification logic fragment larger calculus studied chapter 
statement corresponding proposition hold full system see auxiliary result fails 
presence logic reduce arbitrary function bodies 
problem specification language intended evaluated 
reduction sense 
believe motivation studying full logical refinement calculus 
implementation program development system able evaluate partially developed programs formalised dynamic semantics extended ml kst 
system logical refinement calculus chapter directly evaluate terms 
fragment calculus 
propositions show deduce general forms equality axioms pairs abstractions determined terms 
equalities arbitrary pairs abstractions 
see recall think intuitively terms describing set values 
equality terms corresponds equality sets values 
possible different sets functions return set results argument 
equation rx valid 
likewise different sets pairs set second projections 
illustrate give terms set results argument equal 
letr bool bool 
terms different refine function bool constant function 
prove set results argument 
fact 
bool bool bool bool bool computational lambda calculus application distributes rules associativity twice applica tions get equalities hold arbitrary pairs abstractions inequalities admissible 
proposition admissible rx proof sketch proof statement 
lemma canonical form tx distribution application lemma refines tx equations congruence equals thatis proposition axiom abstraction follows simpler zx term determined 
proof step show induction terms sufficient prove terms canonical form 
abstraction case induction get fx 
prove full axiom 
assume fx fx fx lemma says refinement rules complete sense allow construct refinement program satisfies specification recalling view types rudimentary specifications 
lemma proof proposition fact proven trivially motivates restricted calculi better suited proof search construction structure discuss chapter 
booleans define form binary choice terms 
define bool prove commutative associative idempotent reasonable notion choice 
definition useful helps illustrate differences underdeterminism nondeterminism dij 
reader unfamiliar nondeterminism safely ignored 
compare axiomatisation underdeterminism notion external nondeterminism nondeterminism arises environment making choice 
particular compare nondeterministic choice operator 
example intuitively expect nat nat nat constants naturals 
contrasts properties binding refine formed local context 
example nat nat 
nat nat nat reverse 
difference nondeterministic failure terms analogous idea underdeterminism unsatisfiable terms 
suppose type 
unsatisfiable terms type 
term form term type unsatisfiable 
nondeterministic failure expect term empty unsatisfiable empty unsatisfiable 
informally empty empty 
show underdeterminism commutes determinism sense underdeterminism particular type expressed lower type relevant term constructor 
offers conceptual justification regarding underdeterminism feature level programming language 
interaction computation 
proposition derivable 


inhabited inhabited 

satisfiable 
proof prove clearly refinement rule pairs lets refine left right 
prove direction 
proofs statements carried similar way expressing terms canonical form axioms lemma manipulate terms 
derive useful refinement rules 
mentioned possible derive bottom style refinement rules complementing top rules primitive various congruence rules 
bottom rules put existing programs top rules decompose specifications 
formulate bottom rules terms manipulating variables context 
proposition derivable bottom refinement congruence yt fv fv rn rn fv proof bottom refinement rules obtained substitution 
projection rule example derived alternatively derived directly substitution 
congruence rules follow rule terms 
example rule pairs follows equals congruence refines equals similar point lemma 
refinement calculus discussed chapter rules direct refinement expect rules primitive 
intention give system complete proving arbitrary refinements form goal directed refinements point infer forms bottom rules substitution takes place terms example forms gave suitable directed refinement 
example weakening derived rule contraction lemma combine equivalent stubs step uses weakening second uses refinement rules variables reflexivity pairs congruence 
example give short example refinement derive swap function 
transitivity refinement means refinement derivation form equational reasoning 
main steps 
formally trans 
hypothesis follows congruence abs second derived see congruence pairs variables congruence metatheory trans 
variables congruence congruence section prove results illustrate fine structure refinement relation 
intuitively refinement combination coding stubs replaced program code equational reasoning rules calculus 
possible formalise defining explicit coding relation refinement combination 
definition define coding relation typed terms reflexive transitive congruence closure step relation express term 
means subterm appears local context subterm appears exactly 
means exists determined term ti tn show refinement program standard refinement sequence consisting coding followed equational reasoning 
lemma sg ax axiom system suppose sg ax exists term sg sg ax proof prove lemma induction derivation refinement 
inductive case involves showing coding extended back rule 
consider cases 
reasoning similar 
weakening suppose 

inductive hypothesis exists details refinement matter terms ui ui refining ui ti 
abstractions rule equation consider directions refinement separately 
suppose 
zx 
abbreviated notation terms 
clarity just indicate specification records context induction exist terms ui ui ui ui zx refine left term ui zx zx equals ui equals consider reverse refinement 
suppose 

zx induction terms ui ui zx ui ux ux ui ux ui refine left term standard way 
lemma deduce auxiliary claims weakening immediately satisfied 
lemma sg ax axiom system 
sg ax exists determined term sg sg ax sg ax proof suppose 
andr 

lemma exist ti uj ti uj ti ti uj lemmas hold crucial ax axiom system just consist determined equations example constants axiom thatis bool able find specific bool 
said refinement thought intuitively reduction set programs satisfy specification refinement term 
formalise defining ordering formed terms forall determined lemma refinement mappings xn ym exist terms ym ti ym tn xn proof note reduced repeated pairing variable case 
lemma exist term definition 
terms need assume types inhabited 
empty types 
term refine determined term empty context produce term 
point context refine terms related 
metatheoretic results completeness proof section 
models interpret calculus simple generalisation henkin models 
chapter section henkin interpretations give models simply typed lambda calculus 
terms type interpreted elements set apparatus interpret underdetermined terms subsets elements 
additional assumption models 
require function sets closed factoring 
definition say henkin interpretation satisfies factoring condition letting exists app app exists element app app app 
words writing function associated app exists function exists element note require factoring condition essentially form choice axiom necessary order prove soundness 
recall signatures 
definition sg ax signature 
henkin interpretation sg ax henkin interpretation sg ax factoring condition 
note require environment model condition directly interpretation 
terms underlying henkin interpretation 
condition lifts sense satisfiable terms nonempty interpretations 
extensionality condition means programs unique interpretations singleton sets 
proceeding give example henkin interpretation factoring condition 
example full set theoretic function hierarchy sets full settheoretic function hierarchy signature defined inductively projection application maps usual set theoretic maps constants interpreted elements appropriate sets 
see open term model example 
give example henkin interpretation satisfy factoring condition 
example applied theory primitive types nat bool constants nat succ nat nat true bool false bool cond bool nat nat nat eq nat nat bool henkin model set natural numbers set boolean truth values constants expected interpretations function sets subsets space elements model just generated environment model condition just elements required interpret terms calculus 
particular element corresponding predecessor function function pred pred succ identity positive naturals nat cond eq clearly exists 
chapter meanings environment 
context xn environment isa tuple elements defined tuple subsets 
write environment interpret inductively structure typing derivation 
define interpretation terms context environment written 
write interpretation equivalent emphasise fact interpretations subsets 
similarly write interpretation 
say typing judgement istrue interpretation environment written rn mn rn ai mi proj proj app proj proj rr app interpretation formed terms true written true environments easily seen soundness typing 
similarly say refinement istrue interpretation environment written define truth interpretation environments 
usually drop explicit annotation interpretation definition sg ax axiom system henkin interpretation sg 
say henkin model sg ax axiom ax true prove soundness refinement easy see determined interpretation 
prove standard lemma 
lemma substitution lemma formed terms context xn ti xn ti xi ai unique inhabitant ti 
proof proof straightforward induction typing judgement xn 
may compared analogous form substituting underdetermined term follows directly semantics terms 
theorem soundness henkin model axiom system sg ax sg ax proof proof induction derivation judgement 
cases straightforward 
prove key cases 
beta interpretation defined determined unique member substitution lemma interpretation 
abstractions equality rules easier prove simpler rule proposition sound implies soundness full rule 

aim prove zx zx zx fb zx ab fb ab prove equivalent 
suppose 
define ab app 
fb zx ab substitution lemma holds 
suppose 
define ab ab witness existential 
note function 
factoring condition construct corresponding element henkin model 
define unique inhabitant 
ab ab substitution lemma ab 
read factoring condition exists element define app app comp elements comp jx exist environment model condition 
prove 
assumption fb ab substitution lemma zx holds 
naive interpretation 
cpo interpreted sound 
cpo strict functions interpreted nat weakening axiom fail 
example nat sound 
hand non strict functions conflicts fact variables theory range values determined equations extensional 
example eta rule booleans deduce interpreted interpreted nat nat nat respectively equation sound 
significantly completeness equational theory simply typed underdeterminism respect class henkin models factoring 
implies system conservative extension simply typed lambda calculus 
reasons case theorem get completeness result restrict nonempty types 
theorem completeness equational system sg ax axiom system types inhabited 
henkin models sg ax sg ax proof give sketch proof 
idea construct minimal term model signature ground types constants equational assumptions empty types 

define term interpretation theorem 
define infinite context infinite number variables type 
define set equivalence classes open respect determined terms type thatis 
projection application constant interpretation mappings interpreted syntactically 
recall theorem gives defined henkin interpretation 
see interpretation satisfies factoring condition suppose wheref andf 
says terms exists term 
particular variable exists term 
define 
prove obvious meaning 
case uses lemma 
abstractions ut result follows iff 
terms interpretation set exists conversely lemma exists 
prove iff sg ax step equivalent 

show turn equivalent clearly 

get completeness need prove converse 
crucial step uses canonical form refinement terms 
suppose 

particular express canonical forms xn ym assume xn ym lemma deduce existence terms ym ti ym tn xn weakening ym wehave ym ym tn xn equal ym equals types nonempty substitute closed deter mined terms variable getting interpretation model sg ax conclude completeness 
steps standard completeness proofs third particular calculus 
corollary corollary axiom systems inhabited types 
conservative extension proof clearly term models axiom systems satisfy factoring condition complete henkin models 
calculi complete henkin models determined equation interpretation result follows 
fact conservativity probably holds restriction nonempty types 
shown general notion model kripke models mm 
alternative probably equivalent approach interpret term context set mappings single map environment subset approach avoid factoring condition 
order logic simply typed refinement just order logic simply typed lambda calculus section give order logic equational theory simple refinement 
combination logic refinement logic stubs carried chapter 
section external logic reasoning refinement 
regard logic orthogonal refinement 
classical order logic signature primitive predicate symbols constant symbols ground types 
order axiom systems definition atomic propositions predications form rn refinements addition rules refinement assume extralogical axioms 
universal quantification take loss generality closed propositions 
definition order signature order signature 
definition sg order signature 
sg rn types respectively 
formedness judgement sg wf natural extension section 
list propositions write sg wf sg wf 
definition order axiom system consists order signature sg collection ax closed propositions formed sg sg wf 
continue write equations determined terms formally propositions form intuition constructing refinement theory top theory natural restrict axioms involve equations 
allow arbitrary propositions refinement see encode refinements propositions form anyway 
definition sg ax order axiom system 
define order theorems sg ax judgements inferred natural deduction rules order logic figures chapter extended propositions figures convention means formed contexts order include equational theory refinement logic 
judgements form variable context list propositions formed proposition formed 
meaning context proposition true true 
write sg ax indicate proposition context theorem axiom system sg ax chapter logic complete class models equational theory order henkin models 
giving semantics proving completeness able conclude refinement encoded logic just equality 
mean tion refinement superfluous 
consider useful high level notation proposition 
gives interpretation propositions order henkin interpretation 
interpret formed propositions context wf rn ai ri interpretation formed propositions set environments holds usually drop superscript write mean henkin interpretation say write 
completeness respect class henkin models axiom system factoring condition 
extend definition henkin theory account refinement 
idea refinement form existential add witness 
fact completeness stronger assumption uniform choice term 
definition order henkin theory axiom system sg ax context collection propositions closed derivation sg ax proposition proposition exists term subtle point sure adding witnesses refinements preserves consistency 
refinement equivalent fx theorem soundness completeness logical system sg ax order axiom system 
sg ax iff henkin models sg ax proof modify proof theorem 
soundness straightforward prove completeness shown term model 
show consistent axiom system satisfiable 
axiom system sg ax wewant show sg ax iff henkin models sg ax 
theorem assume types nonempty 

sg ax want find henkin model sg ax environment 
construct maximal consistent henkin theory infinite context ax henkin theory 
proof theorem construct order henkin theory extends ax henkin closure ax limit sets propositions formed consistent extensions 

construct term interpretation set equivalence classes determined terms iff show 
requires generalisation lemma logical contexts 
contrast holds construction henkin theory 
henkin interpretation factoring condition 

prove iff 
crucial cases go virtue henkin theory 
case proven theorem observation appropriate generalisation lemma holds 

henkin model sg ax xn defining xn wehave canonical forms proof theorem suggests translate refinement order logic just equality determined terms 
denote canonical form open term xn andr ym define ym xn completeness results theorems infer logical system conservative extension equational system turn conservative extension simply typed lambda calculus 
fact corollary sg ax order axiom system types inhabited 
sg ax iff sg ax iff sg ax proof systems complete respect henkin models factoring condition statements interpretation 
corollary suggests alternative proof completeness 
proposition order logic prove directly 
iff fol completeness order logic calculus theorem deduce completeness order 
language chapter simple believe captures important part program refinement 
combination calculus specifications chapter gives calculus conceptually simple expressive study program development 
chapter refinement types chapter develop theory refinement types 
intended give calculus refining specifications proving programs satisfy specifications 
necessary part theory program refinement 
justify view specification outline constructs requires calculus associated judgement forms 
give calculus illustrate example verification 
final section give semantics henkin models prove system sound complete 
address question suitable notion specification programming language properties interest expressed program logic 
recall restrict attention languages studied typed lambda calculi typed functional programming languages 
number possibilities considered 
say specification type expressive type theory 
approach taken luo nps example 
integer square root function specified existential type nat nat nat 
logic encoded type theory 
problem works intuitionistic logic 
classical logics common specification easily encoded type theories 
programming languages generally simple type system related specification type theory 
problem easy combine nontermination type theories 
earlier versions chapter den den 
possibility say specification just proposition program logic distinguished free variable 
square root example proposition nat 
free variable type nat nat 
approach traditionally taken program refinement community 
morgan mor describes refinement calculus order predicate logic 
approach number shortcomings illustrate example 
main point compositional verification program development better put structure specifications 
thesis suggest third possibility combination program logic type theory programming language known refinement types 
notion refinement type studied extensively program analysis different names different systems depending area interest 
general idea levels underlying level program types expressive level program properties treated types 
expressive level specifications 
exploit type theoretic structure specifications need encode propositions types directly 
describe verification calculus simply typed lambda calculus products ground types nat bool 
satisfaction specifications programs axiomatised generalised typing relation sense precise 
viewing specifications refinements underlying type expressed program logic 
typed classical predicate logic program logic axiomatise ordering refinement types viewed increase information refinement specifications 
refinement types constructed combinations types propositions program logic 
types trivial refinement types restrict refinement type elements proposition holds 
similar subset types nps quite maintain distinction types 
convenient form dependent functions products level refinement types underlying types dependent 
refinement types subtypes 
example nat subtype real say refinement type 
careful distinguish refinement types subtypes equality stratified different refinement types subtyping systems 
contexts consist variable assumptions propositions combined explicit mutual dependencies wellformedness 
dependency arises allow refinement types terms turn appear propositions 
give simple set theoretic interpretation calculus 
main result chapter soundness completeness respect resulting class models 
section consider simple example specifying verifying program order motivate features calculus 
give syntax rules calculus section 
section return example 
section gives semantics proofs soundness completeness 
give section 
example consider specifying division naturals verifying program satisfies specification 
take simply typed lambda calculus classical order predicate logic simple programming specification languages respectively 
constant natiter iteration naturals natiter th iterate fn 
approximation specifications propositions distinguished free variable write proposition program div implements division naturals uses auxiliary function div nat div nat nat div natiter nat nat specified div spec nat nat nat fn fn want axiomatise satisfaction relation sat programs closed terms specifications prove div sat div spec simple way doing say sat just taken notation typing proposition rule sat 
example reduces proving nat div div specification language cumbersome stands introduce dependent products functions abbreviations fx dependent function specifies function returns combined quantifications fx read ifp fx 
allow ourself abbreviation viewing types trivial specifications example nat stand nat write specification compactly div spec nat nat abbreviations rule admissible definition sat nat div sat nat nat div sat nat nat informally understand sequent nat sat mean closed nat equivalently numerals sat 
general want consider satisfaction arbitrary context 
note similarity typing rule 
fact useful structuring devices specifications useful proofs specifications programs tend naturally expressed proved shape similar program 
example program div abstraction specification div spec form 
rule directly reflects natural proof div satisfies div spec 
similarly auxiliary function div specification div spec nat nat nat proof turn involves showing pair satisfies product specification abstraction satisfies functional specification 
induction show iteration satisfies specification parameterised naturals 
consider example fully section 
throw away original rule satisfies 
significant benefit writing specifications structured form conceptual preferable structure specifications task comprehension need duplicated unnecessarily specification program 
separate checks formedness type checking correctness involve duplication effort better combine types correctness properties 
order basis useful program development methodology helps specifications proofs reflect structure programs 
small example disadvantage propositions specification obvious 
structure essential large specifications build theory 
natural incorporate equality definition specification express separate proposition 
mckinna led mck 
final aspect specifications consider equality 
kind specifications concerned specify input output characteristics programs 
interested programs extensional equality 
alternative type theoretic setting intensional equality distinguish programs basis syntactic form 
unnatural view specifications inducing equality terms 
partial equivalence relation terms underlying type 
symmetric transitive relation set equivalently equivalence relation particular subset 
partiality terms corresponding type need satisfy specification 
example specification nat min proposition min minimum element list refinement type type list nat 
want regard functions list nat equal solutions specification give results nonempty lists 
program satisfying specification defined empty list interested value takes 
useful abbreviation specifications write equal ity specification wheret means tx tx attain conceptual simplicity specifications subsume types satisfaction subsume typing equality specification subsume usual equality type left implicit 
example nat place nat nat bool nat bool abbreviates similarly 
point cease regard convention means equality respect arguments fx 
believe misleading regard specifications rich form types refer specifications idealised specification language refinement types 
regard types part programming language specifications constructed level 
infact refinement type denotes set set take program calculus denote equivalence class alternative take program denoting element domain unnatural distinguishing programs extensional equality 
refinement types induce set terms underlying type 
converse true pers terms correspond refinement types 
example naturals odd 
notation equivalence classes pers allowing refinement types variables abstractions 
example denotes class denoted nat functions corresponding set equal give results arguments nat nat nat denotes class nat nat nat 
meaning equality denote sets equivalence class 
refinement types underlying type want consider refinements thought semantically inclusion equality implies equality 
square symbol indicate information ordering refinement specifications type 
convention refinement opposite direction usual subtyping relation 
calculus give syntax system describe judgements 
syntactic results give operational intuition language 
syntax idea construct theory refinement types top underlying theory order logic theory 
generated signature types constants predicate symbols underlying theory axioms full theory 
formedness conditions axioms explained section 
construct theory refinement types basic data order theories lambda calculus 
signature order signature 
repeat definition 
definition signature sg consists collection ground types ranged collection constant symbols ranged arity sort write 
collection predicate symbols ranged arity sort write pred 
arbitrary refinement types primitive signature get expressiveness predicate symbols 
example primitive type nat predicate pred nat write refinement type nat 
definition sg signature 
pre expressions sg mutual recursion pre refinement types terms propositions tn tt tn pre contexts say pre expression context pre context pre expression fv 
previous calculi assume countably infinite set variables 
adopt usual abbreviations fv metavariables refinement types 
abbreviate assumption abstractions contexts conceptually simpler distinguish types refinement types syntactic categories 
informal sense formal refinement types viewed refinements underlying types example refinement just say 
formally types just refinement types logical information containing propositions 
metavariables types refer type underlying refinement type 
extend variable convention writing assume drawn set variables type 
term unit type 
introduce equality judgement see unique term equality 
meaning refinement types terms satisfaction satisfies satisfies satisfies term satisfies satisfying tt formed satisfies satisfies satisfies proposition holds 
think terms calculus simple specifications terms underlying refer terms total terms 
terms usual meaning lambda calculus abstraction thought simple specification terms satisfy 
example specifies total terms type nat nat identity arguments 
application formed arguments satisfy behaviour constrained 
note means refinement type nat nat term type nat nat 
intuitively say term refinement type behaviour uniquely determined total terms satisfy equal 
propositions typed order predicate logic equalities typed refinements 
practice omit subscript classical typed order logic example simple expressive logic 
choice order classical logic significant insofar example call extensional logic 
type theory distinction extensional intensional equality nps 
terms extensionally equal input output behaviour proposition called propositional equality intensional equality definitional equality generally decidable 
sense intensional means relating syntactic form general sense respect richer properties input output behaviour time complexity kind predicate want contrast 
allow propositional equality properties system sense extensional predicates 
essential fact terms propositions ift extensionally equal holds 
converse clearly holds express saying require leibniz satisfaction predicates observational inputoutput behaviour equality coincide 
matter logic classical intuitionistic 
contrasted say intensional logic modal calculus terms viewed transition systems reduction sequences 
judgements main judgements calculus forms atomic propositions include equality refinement separate judgement classes propositions 
write mutual refinement 
judgements context variable assumptions propositions mutually dependent formedness judgements wf ref wf say term formed context exists refinement type 
need unique underlying type unique 
understand mean variables context satisfy relevant refinement types term refinement type 
write 
formedness judgement refinement types ref says refinement type context type 
abbreviate ref wf type significant 
extra information required formedness check formedness refinements 
metavariable syntactic environments tuples terms satisfy refinement types propositions context 
abbreviations indicate simultaneous satisfaction equality substitution respectively 
think ref refinement ref 
attribution refinement types contravariant function types 
example nat nat nat regard nat subtype nat nat refinement type 
difference power types refinement types seen considering encodings higher order logic 
power types may encoded prop refinement types correspond prop specifications comprise partial equality relation 
calculus seen convenient formalism relations 
axiom systems axiom system consists collection order axioms signature 
crucial difference definition 
refinement types appear terms formedness involves logical reasoning particular depend axioms 
axioms formed dependencies axioms 
problem axiom schemas possible instance needed prove formedness 
example induction principle naturals schematic proposition forn nat formedness require induction 
problem common logics formedness depends provability 
introduce hierarchy axioms solution adopt drop requirement axioms formed check proof 
natural give axioms deliverables style mck 
unary constant sort give axioms form argument satisfies specification result satisfies specification 
write mean refinement type refinement type 
note judgement form see axiom side conditions 
definition 
definition axiom system sg ax consists signature sg collection axioms ax formed pre contexts pre expressions sg 
axioms forms propositions context axioms constants 
put formedness requirements axioms check formedness point axiom proof 
similar convention adopted pitts dependently typed algebraic theories pit 
intend sort ref ref axiom system 
example required axiom fv follow automatically formedness check axiom similarly constant axioms 
note sorting axiom say unary constant formed term necessary number arguments 

consider axioms 
allowing arbitrary propositions axioms subsumes definition axiom systems include equations context determined terms clear necessary allow arbitrary propositions axioms definition 
show section induction schemas follow axiomatisation corresponding constant recursion 
suggests may need propositional axioms order axiomatise predicate symbols 
axioms form 
axioms constants form xn xn equivalent natural general form tn 
rules calculus definition sg ax axiom system 
define theorems sg ax judgements inferred rules figures 
write sg ax indicate judgement theorem axiom system sg ax note consider judgements formedness theorems involve logical reasoning 
rules calculus listed figures 
distinctive feature calculus mutual dependencies different syntactic categories different judgement classes 
refinement types contain propositions contain terms turn contain refinement types abstractions 
give rules generating theorems axiom system 
check axiom formed 
substitution rule arbitrary basic judgement rule quite simple explicit congruence rules equalities 
encoding proposition rules implication universal quantification derive general rule describe formedness rules starting contexts 
empty context formed rules extending existing context 
figures give formedness rules contexts refinement types respectively 
formedness rules refinement types essentially involve stripping logic checking fits correctly 
checks formedness context base cases ensure provable judgements formed 
similar conditions base cases judgement classes 
straightforward formulate formedness rules propositions 

proving formedness implication assume truth proving formedness equality formed require formed refinement types type 
refinement type 
allows express refinement typing proposition appeal refinement typing formedness axioms weakening permutation wf ax wf wf substitution theorems generated axiom system sg ax empty context variable assumption propositional assumption wf wf wf wf wf formedness contexts unit product function refinement types ground types wf ref ref ref ref ref ref ref ref wf ref wf ref formedness refinement types involves logical reasoning propagates formedness rules syntactic categories 
similarly refinement wellformed type 
figures give refinement typing rules serve formedness rules terms 
differs simply typed lambda calculus logical reasoning pervades rules 
evident constants rule formedness uses logical axiom 
constant symbol axiom ax infer refinement typing general context 
ti infer tn 
reason general context axiom nat infer context nat 
fact case refinement typing derive general rule constants simpler equations keep rules form 
refinement typing rules natural generalisations usual typing rules simply typed lambda calculus products 
example rule abstractions formed context sufficient necessary formed context 
notion formedness having refinement type 
example nat nat body formed context nat 
obvious rule proving term inhabits refinement type weakening rule corresponding elimination rule concluding follows weakening rule refinement rules give 
rule inferring refinement typing equality may strange saves rules 
reason proving refinement typings equalities falsehood implication universal quantification predication wf wf wf wf wf wf wf tn ref ref tn wf equality refinement ref wf ref ref wf formedness propositions pred variables constants wf ref ref ref tn tn unit product terms function terms wf wf ax tt refinement typings refinement type equality weakening refinement typings cont 
need able combine assumptions subterms 
equalities subscripted refinement type rule lets equality rules prove refinement typing 
example congruence equation abstractions wf lets prove nat infer nat 
general inference sound 
example term nat refinement type nat nat nat nat 
figures give equality rules terms 
combination rule equality equations abstractions lets prove asp example nat nat nat incomparable obstacle subtyping systems 
equalities abstractions pairs unconventional hypotheses enabling combine logical typing assumptions 
tx tx fv usual hypothesis abstraction rule 
example essential rule 
example equality abstractions infer refinement typing 
nat nat nat fx nat fn nat nat nat nat fx nat fn nat nat nat fx nat fn nat nat nat fx nat nat fn nat nat nat fx nat function eqs 
similarly rule pairs order prove example formedness hypothesis rule logical congruence important stratified equalities require equality appropriate refinement type 
define singleton types 
write refinement type iff conjecture calculus conservative extension aspinall singleton asp 
example nat nat nat nat ref types reflexivity cong eqs 
nat equality nat symmetry rule deduce symmetric forms ences 

lists refinement rules 
kinds structural logical 
obvious structural rules wf interesting rules refinement involving propositions 
say arbitrary refinement type refinement type proposition refines 
refinement rule transitivity refinement 
equational reasoning function equations product equations unit equation tx tx ti fv equality rules constant equations ref ref ref tn tn congruence equations wf logical congruence weakening ax wf equality rules cont 
unit product function refinement types transitivity wf refinement rules conjunction disjunction implication wf wf universal quantification falsehood assumptions elimination rules wf wf wf natural deduction rules theory refinement types rules logic 
natural deduction presentation typed classical predicate logic equalities refinements 
assumptions context assumptions elimination rules 
order derivable formedness rules false assumptions explicit formedness hypotheses 
prevents proving non formed equalities 
contexts differ usual formulations typed lambda calculi contain propositions 
forms assumption combined context explicit mutual dependencies 
illustrated rules need refinement typing elimination rule refinement typings infer propositions rules wf booleans naturals give axioms booleans naturals combine typing logical rules chapter 
give axiom system booleans 
ground type bool constants true bool false bool bool 
axiom schema conditionals abbreviates bool true false says truth boolean condition implies falsity implies assumptions infer respective branches refinement type conditional refinement type 
fact axiom implies 
particular case axiom true false axioms true bool false bool bool true false bool bool true false axiom system booleans expressed elegantly sums studied 
give axiom system naturals making singleton type notation 
zero successor constants constants recursion 
refinement typing equational axioms form recursion 
give constants primitive founded recursion 
primitive recursion enables write simple terminating programs loop finite set values type stage program access computation previous value 
functional equivalent loop 
constant natrec primitive recursion naturals 
programs naturally expressed form recursion stage looping values type program access computations previous values 
example recursive call merge sort algorithm tail list sublist 
require functional equivalent loop 
problem general loops terminate add construct full recursion simply typed calculus results inconsistency 
constants mu mu mu prove typed equations 
bool bool eq bool bool bool negation equality functions respectively 
equality conditionals prove bool eq bb true bool eq false 
substituting forb prove true false 
axioms nat succ nat nat natrec nat nat nat nat nat nat natrec nat succ nat nat succ natrec zs nat succ nat natrec zs succ succ sn natrec nat nat nat nat gn gn axiom system naturals solution restrict recursion loops terminate 
done defining founded order data recursion stage computation value computations values lower order 
form recursion known founded recursion 
founded recursion naturals usual ordering 
write nat 
separate proof termination formedness build defining constant construct terminating loops 
termination requirement expressed refinement types 
sorting nat nat nat axiom refinement typing nat nat recursion formulated sacrificing termination nat nat gn gn nat recursively body loop applied values smaller define 
fn thought looping 
induction rules chapter derived 
nat wf derive rule mathematical induction nat nat nat nat natrec nat nat similarly derive founded induction computational induction forg nat nat nat wf nat gn gn nat gn fact noted founded induction follows mathematical induction turn derived axiom natrec 
constants added simple type theory axioms refinement types 
example defined appropriate type recursion equation holds appropriate refinement type 
semantically interpreted map set underlying type interpretation constrained refinement type 
metatheory prove syntactic results calculus 
results needed section proving completeness respect semantics 
standard metatheoretic results listed deduced completeness 
lemma derivable proof show rule refinement type derivable 
lemma rule derivable 
proof easy proof show formed refinement types reflexivity refinement 
give derived refinements 
lemma rules derived 


wf wf wf wf wf fx wf wf wf fx 
wf wf wf wf wf wf wf said refinement types correspond relation type subset 
consequence give canonical form refinement types simply type proposition contrast nps subset types meaning translation underlying basic type theory see section 
introduce notion proof completeness 
properties types 
example logical import sense inhabited underlying type express refinement types canonical form propositional subset 
definition signature grammar see keep dependent constructors consider example refinement type nat nat nat 
expressed form lemma wf exists proposition proof rules lemma 
lemma ref proof lemma assume loss generality canonical form 
proof straightforward induction 
evident generalisation arbitrary propositions wf holds 
formedness terms combination typing satisfying logical properties 
illustrated proposition 
proposition context equivalent 
typify typed typing context typify typify replaces occurrence refinement type underlying type removes propositions context 

exists refinement type 

exists type ref prove 
proof clearly implies lemma implies 
induct show equivalent 
write typify 
just consider cases 
applications tt exists induction tt 
conversely tt induction tt 
abstractions thatis 
conversely induction 
definition context 
conditions proposition hold say structured 
extend definition structuredness arbitrary pre expressions write ws wf 
say informally expression structured 
note formed wf iff wf 
levels formedness 
called structured corresponds terms put correctly irrespective logical annotation formed means logic respected 
contrast formedness proposition shows decidable 
distinction reminiscent rough types sannella aspinall type underlying refinement type 
see section give semantic interpretation terms 
proposition ref 
proof typify proposition infer types gives 
refinement definitional extension refinement typing sense ref types ref types fact strengthened showing wf natural question eliminate refinement relation treat syntactic sugar 
calculus stands weakening rule refinement typing refinement hypothesis naively treat syntactic sugar 
system reformulated believe insightful explicit definition refinement chapter 
practice applying rules backwards find proof refinement type rules refinement types form emphasised intuition calculus match perfect 
example expect equality nat nat mean arguments equal nat results equal nat 
example nat nat equal nat nat nat term nat nat refinement type nat nat 
section define relations terms terms related nat nat 
think terms calculus uniquely specifying total terms refinement type 
mismatch refinement typing equality implies define form annotation proposition refinement type 
notion completeness proof 
definition state properties 
wf wf 

division revisited illustration refinement types provide useful proof technique give division example section 
recall define iteration general recursion fv 
program natiter tt natrec nat div nat div div natiter nat nat prove satisfies specification div nat nat div nat nat nat fact little interest main part proof 
refinement types explicitly indicate structure specification enables proof carried syntax directed fashion 
useful automation 
write abbreviation nat nat see nat nat nat nat nat nat nat nat natiter nat nat nat nat nat natiter nat nat nat nat nat proof continues nat nat nat nat remainder proof arithmetic reasoning 
practice theorem prover 
models nat nat contrast previous chapters interpret derivations judgements pre judgements 
unique refinement typings unique derivations particular refinement typings 
show semantics derivations gives unique interpretations require analysis coherence avoid 
quite call curry style interpretation erase refinement types terms 
chapter henkin models interpret simply typed lambda calculus order logic 
extend interpret terms sets total realizers 
refinement types type interpreted pers definition henkin interpretation signature henkin interpretation order signature 
raw data order interpretations definition induced semantics different 
assume henkin interpretation write 
henkin interpretation models axiom system constants predicates interpretation axiom true interpretation defined 
environment model condition interpretation terms defined 
strictly speaking meaning function partial mapping pre expressions meanings 
show total structured terms 
proj proj proj proj proj ar app app ar interpretation refinement types expressions interpreted context context define environments written dropping significant tuple elements domains pers refinement types 
define recursively interpretation refinement types propositions 
write indicate domain ara 
define notion equality environments obvious way simultaneous equality elements corresponding written define 
avoid questions coherence interpret pre terms pre propositions pre refinement types 
mentioned refinement types interpreted pers 
interpretation adopt convention pers set corresponding underlying type 
unit ground types interpreted identities product function refinement types interpreted expected combination pers interpreted restriction elements holds 
easy see types interpreted identities 
apparent asymmetry definition product fact formed refinement type context soundness result states 
pre term context interpreted environment subset total realizers type underlying types implicit interpretation 
alternative explicit giving interpretation structuredness judgements 
approach taken asp example 
tn mn tn ka ai mi proj proj app proj proj tt app interpretation terms refinement type abstractions interpret terms sets single elements 
example interpreted set elements nat nat identity arguments 
give interpretation propositions 
interpret context set environments 
mentioned interpretation function partial terms interpretation 
example defined interpretation syntactically formed 
proposition ws defined 
proof induct pre expressions consider cases 
applications tt ws tt inductive hypothesis defined subset defined subset tt isa defined subset 
abstractions ws induction anda defined 
tn mn tn ai mi ar interpretation propositions may say semantic analogues judgements 
henkin interpretation assume 
define anda words interpretation unique equality 
say 
particular refinement true inclusion pers 
define wf mean wf mean 
define validity basic judgement truth environments means defining interpretation models axiom system require formed axioms hold 
definition sg ax axiom system 
henkin interpretation sg model sg ax ax sg ax wf ax sg sg ax ref sg ax ref write 
give substitution lemma 
lemma substitution lemma ti xn ti xi ai ti xn 
proof induction xn need condition ti weaker requirement ai ti ai sufficient 
example model nat nat nat nat nat nat 
note substitution pre expression ti xi wellformed 
ti 
consequence substitution lemma wf unambiguously notation dropping 
express instance lemma generally lemma wf 
proof 

lemma wf 
proof immediate consequence lemma 
verify interpretations respect rules calculus calculus sound respect models axiom systems 
consequence axiom system booleans naturals consistent give nontrivial models 
theorem soundness henkin model axiom system sg ax sg ax sg ax wf wf sg ax wf wf sg ax proof simultaneous induction derivations 
soundness equality abstractions follows lemma 
assume andlet 
interpret term environment set soundness theorem shows contexts seen pers interpretation term gives rise morphism pers map equivalence classes 
example think interpretation variable map element equivalence class relevant refinement type 
informal remarks clarified chapter 
challenging question calculus sense complete particular judgement holds models axiom system provable 
ideal completeness theorem refinement typings 
unfortunately fails reasons 
firstly due way formedness combined satisfying logical properties assume judgement formed mean formedness component expressions 
possible non formed terms unique interpretation semantically refinement type 
example interpreted unique inhabitant unit type typed system 
second point arises higher order terms due calculus requiring arguments abstraction refinement type abstraction model just needing equality arguments refinement type give equal results 
example nat nat refinement type nat nat model calculus 
show term context refinement type model exists term refinement type words correspond equivalence class 
give syntactic characterisation 
previous chapters prove completeness notion henkin theory suitably extended 
regard theories infinite contexts rooted left iff 
say infinite context formed finite prefix formed 
definition sg ax axiom system 
henkin theory sg ax formed infinite context closed derivation sg ax term 
completeness proof rests construction term model formed suitable henkin theory 
number possibilities priori consider class terms set firstly choice total terms arbitrary terms 
choice formed terms refinement type ref structured terms 
rule total terms types interpretation immediately obvious construct environment proof completeness 
example halt ref nat refinement type encodings programs halt halt nat context term term type nat equals arbitrary terms refinement types pointed discussion lemma lead substitutions formed 
example nat nat nat nat nat nat contain pre term formed 
structured terms definition characterise term model 
definition define proposition replacing equality write ref lemma proof induction lemma suppose fv 

lemma exists 
proof induction 
definition formed terms total 
define sat mean definition sense arbitrary formed terms idea formalises total realizer superscript context writing sat infinite contexts clash convention writing mean sub context 
definition define mean exists term definition defined henkin closure collection order propositions adding variables nonempty type propositions stating existentials witnesses 
analogous definition repeat refinement types nonempty types propositions problems 
problem just assume variable logical import give contradiction current context 
see suffices fact definition assumption logical import 
problem arbitrary structured proposition need formed context 
added complication order assumptions listed significant 
get round problems trick 
structured expression give formed proposition wf says formed 
example proposition wf formed formed equivalent similarly structured pre refinement type refinement type wf notation formed 
order matters henkin theory variables precede expressions appear 
similar definition order definition context 
define henkin closure procedure 

iterate structured deciding inhabited definition 
list structured propositions form pn inhabited 

list variables yn yn pn fv pn yn 

qn wf pn pn pn yn wf 
define henkin closure 
case order minimal term models due having propositional assumptions term model construction prove completeness 
slight generalisation standard consistency implies satisfiability argument 
generalise consistency satisfiability sets closed propositions arbitrary contexts 
say context consistent satisfiable exists model environment thatis 
case context closed propositions reduce usual definitions consistency satisfiability 
write mean informally model axiom system 
want show suppose consistent assumption satisfiable 
situation judgement form refinement typings reduced propositions 
theorem completeness sg ax axiom system 
sg ax wf henkin models sg ax sg ax sg ax wf sg ax wf models sg ax sg ax 
proof context consistent 
sketch construc tion particular model environment steps deduce completeness step 

construct maximal consistent henkin theory 
henkin closure ax 
apply operation axioms interpretation model 
consider sets propositions property inserted giving consistent extension exists context subcontext consists plus propositions order 
form partial order sets ordered subsetting 
clearly nonempty 
closed unions chains 
see formalise insertion set mapping adding new elements right possible insert way supersets inserted way extends insertion 
limit necessarily embedding union try insert set place example 
careful spread set achieved inserting element double index naive embedding define 
chain upper bound zorn lemma collection maximal element 
define insertion clearly theory formed closed deduction 

define relation structured terms 
ws define mean wf sat sat formed 
intuition definition terms formed correspond set structured terms equal 
define set equivalence classes structured terms open respect thatis position context matter formed 
write equivalence class construct henkin interpretation interpreting constants syntactically 
constant symbol define kt kt un un 
terms structured interpretation defined 
predicate symbol pred define un un 
show extensional environment model condition clearly holds interpretation 

characterise interpretation terms refinement types term interpretation need cases wf prove wf carried lemma sketch completeness 

interpretation model axioms 
axiom form define closed equivalent write obvious inductive definition formed previous step get show axiom loss generality just consider unary constants 
step 
singleton types discussed derive lemma models sg ax 
proof completeness order ifx xn variables define environment xn show induction subcontexts 
arbitrary context consistent satisfiable 

show proposition refinement typing writing 
suppose consistent previous step environment 
situation refinement typings reduced propositions equivalent crucial point permissive formedness rule equalities equality formed need refinement type 
implies lemma 
order prove equivalence step need characterise interpretation expressions term model mutual recursion terms refinement types propositions carry proof syntactic category simultaneously 
reasons pers correspond exactly equalities 
lemma context define proof theorem 

wf 
wf sat 
wf iff proof simultaneous induction expressions unpacking definition term model 
inductive ordering interesting cases propositions prove detail 
save symbols write 
construction 

inductive hypothesis 
lemma inductive hypothesis 
words 
maximality henkin theory contradicting 
conversely suppose 
inductive hypothesis lemma exists inductive hypothesis 
formed 
define maximal refinement type max max max max max max max terms refinement type max 
max ref 
wf permissive wellformedness rule predications 
induction sat andu rules 
conversely forsome definition sat sat sat sat wehave show equivalent induction 
assume induction thisis deduce see prove directly 
exist term suppose 
henkin theory forsome deduce exists contradiction 
maximally consistent 
refinement types proposition gives transitivity conversely suppose lemma inductive hypothesis weget order logic order logic simply typed lambda calculus refinement types calculus complete class henkin models assumption nonemptiness corollary calculus conservative extension order logic formed equation provable provable calculus refinement types 
corollary calculus conservative extension order logic wf contain refinement types provable order logic provable calculus refinement types 
significance corollaries free specification language proving program equivalences reasoning programs program logic knowledge faithfully reflects equality underlying programming language proofs program logic 
described refinement type methodology specification 
way combining type system programming language program logic give specification language 
alternative approaches rely encoding logic expressive type theory simply program logic 
give refinement relation specifications constitute full refinement calculus mor 
idea specifications programs consider refinement relation mixtures specification program 
proof div satisfied specification proof div implicit element refinement terms 
explicit chapter 
chapter refinement calculus chapter full refinement calculus 
stepwise refinement logical specifications programs correctness partially developed programs formalised 
calculus combines refinement terms refinement types calculi previous chapters 
define notion refinement axiom system corresponding class henkin models logical factoring 
prove soundness calculus models prove completeness restricted fragment 
intuition specification refinement previous chapters 
recall scenario studying refinement 
programming language program logic 
chapter showed simple notion partial development programming language terms refinement terms record stage development program 
chapter studied construct specification language program logic specifications refinement types 
orthogonal extensions programming language case simply typed lambda calculus 
combine calculi give refinement calculus stepwise refinement logical specifications programs 
claim orthogonality backed section 
discuss features subcalculi combined 
main issue combining logic refinement 
central language construct logical stub 
write refinement type denote unknown program refinement type combine unknowns language features chapter 
simpler system refer terms refinement terms 
expresses properties interest refinement 
general useful specify mixture logic program code 
course liberty write specifications implemented types inhabited 
contrast bearing refinement rules 
refinement methodology refinement correctness preserving 
clear notion partially developed program refinement term satisfying property 
fact main reasons keeping explicit record stage development draw inferences partially developed programs 
course development questions arise form certain implementation steps final program guaranteed certain property chapter formulated satisfaction specifications programs having refinement type 
generalise rules programs partially developed programs generalise rules proving proving 
main technical problem combining underdetermined terms logic 
substitute arbitrary terms variables infer 
intuitively show determined term refines holds 
write second fact 
cumbersome prove quantifications observe preserve truth quantifications rules words refinement type methodology proving arbitrary refinement type substituting directly proposition 
chapter refinement decomposition stubs replacement code 
chapter idea refinement refinement types formalised logical manipulations specifications 
combined refinement calculus combine distinct aspects refinement adding rule refines refines 
just equality defined respect refinement type extend idea refinement refinement type write refinement complementary aspects refinement correspond ing forms refinement subcalculi 
manipulate specifications replace specific 
corresponds refinement refinement types decompose specifica tions replace holes refinement terms code formalised refinement refinement terms difference calculus refinement context logical assumptions 
particular refinement carried important define notion nonlogical refinement refinement terms meaning ifr notion formal system 
main results chapter factorisation 
chapter saw refinement sequence implementation steps terminating program refinement calculus refinement types natural refine term 
particular take determined 
natural choice consider terms modulo refinement type 
notion program unique term itis unique equality refinement type 
spirit refinement refine far necessary 
give term replacing refinement types term underlying types 
calculus pattern previous chapters give syntax calculus judgement classes 
define notion axiom system give rules calculus 
syntax define applied refinement calculus giving signature ground types constants predicate symbols 
terms generated basic signature calculus 
definition signature sg consists collection ground types ranged collection constants ranged arity sort write 
collection predicate symbols ranged arity sort write pred 
definition sg signature 
pre expressions sg generated grammar rn rr rn pre contexts chapter write respectively fv 
abbreviate assumption refinement types meaning correspond partial equality underlying type 
specification construct logical stub refinement type meaning unknown refinement type 
stub carries data concrete implementations regarded equal 
clearer section 
general terms thought specifying collection programs equivalence 
say term determined contains stubs underdetermined range determined terms arbitrary refinement terms 
refinement types appear binding constructs abstractions terms 
useful specification refinement 
refining body abstraction information 
thought specification programs constrains result arguments 
regard determined general uniquely specify program programs unique equality refinement type give canonical example replacing refinement types underlying types 
term description specified 
example term nat nat specifies nat class contains nat terms meaning chapter 
chapter interaction formedness logical reasoning means define formedness give rules calculus axioms assumed formed proof 
judgements refinement calculus consists basic judgements 
propositions include refinement terms refinement types formedness judgements wf ref wf judgements extend chapter similar intuitive readings 
metavariable syntactic environments tuples determined terms 
axiom systems adopt definition axiom system calculus 
definition axiom system consists signature sg collection axioms ax formed pre contexts pre expressions sg 
axioms forms propositions context axioms constants 
comments definition relevant 
restriction axioms fragment natural restriction disallow refinements axioms 
ensures certain metatheoretic properties 
rules calculus summarise different forms judgement calculus 
basic division judgements formedness syntactic category judgements truth 
division formedness truth somewhat arbitrary judgements involve logical reasoning refinement typings formalise formedness terms satisfaction specifications 
upward arrow indicates inclusion rules 
refinement separate judgement class propositions 
similarly equality rules just mutual refinements 
definition sg ax axiom system 
define theorems sg ax judgements inferred rules figures 
write sg ax judgement provable axiom system sg ax ax obvious just write meaning provable 
calculus consider provable formedness judgements theorems 
formedness rules contexts refinement types figures chapter 
formedness rules propositions natural extensions chapter additional rule formedness refinement requires underlying type 
refinement typing rules figures obvious generalisations chapter side conditions elimination rules ensure substitute underdetermined terms refinement types see 
example elimination rule function terms hypothesis abbreviates side condition fv 
rules logical stubs terms 
special case rule product terms connection logic refinement typing lies rules refinement type 
rule derivable chapter natural include 
generalise rule arbitrary underdetermined terms general having formedness refinement wf wf ref truth equality summary judgements refinement calculus refinement type encoded proposition discussed section 
case determined terms predications 
refinement elimination rule generalisation equality rule 
refinements infer refinement typings 
related rule admissible special case subject refinement lemma 
unnatural take rule primitive proving refinement typings require guessing term subject refinement admissible calculus stronger rules abstractions terms expected fv derive obvious simpler forms letting 
general reason see 
corresponding rule abstractions inferring follows rule equality elimination 
final rule refinement typing weakening rule 
need add axioms necessarily closed weakening 
figures formalise refinement terms 
includes equality rules determined terms equality rules terms figures straightforward extension chapter replacing arbitrary types arbitrary refinement types 
conveniently nonlogical equality mutual see 
mentioned new judgement meta judgement meaning refinement type refines refinement type 
weuse different symbols distinguish abbreviation meta judgement clarity sake 
formally write rules abbreviates schemas formed superficially abstractions rule stronger form refinement types zx fv may equivalent 
absence proof equivalence adopt technical reasons 
need generation lemma 
primitive rule stubs see chapter 
derive refinement rules terms listed figures 
allows refinement refinement types inside terms formalises interaction forms refinement weakening rule refinement weakening strengthening rule logical congruence 
lists rules refinement refinement types extends order logic chapter additional rule predicates lets substitute arbitrary directly predication derive refinement type rule converse addition add rule limited form subject refinement expected rule admissible assumed context way conclude 
prove directly prove rule rule necessary case 
refinement type rules elimination rules arbitrary underdetermined terms 
elimination rules determined terms derived 
chapter introduced terms substitute arbitrary terms variables terms 
similarly substitute arbitrary terms variables refinement types 
case rr 
carrying similar extension refinement types restriction elimination rules function product terms problem arise 
discussed chapter 
axioms weakening permutation wf ax wf wf substitution theorems generated axiom system sg ax example axiom systems booleans naturals section serve axiom systems repeat 
main 
need special refinement rules particular constants 
important means extend theory new constants need add equations determined terms refinement rules automatic general rules calculus 
constant refinement rule omitting formedness hypotheses example admissible rule refining conditionals falsehood implication universal quantification predication wf wf wf wf wf wf wf rn ref ref rn wf refinement ref wf ref ref wf formedness propositions pred variables constants wf ref ref ref rn rn unit stubs product terms function terms terms wf wf ax rr refinement typings fv refinement type refinement elimination weakening refinement typings cont 
derived refinement rule constant founded recursion particularly interesting rules recursive refinement central refinement calculi see example bun 
axiom nat nat simplifying formedness hypotheses refinement rule nat wf nat nat derive rule recursive circular refinement nat nat nat nat compare discussion equality 
rule equivalent intro 
rec 
func 
bun 
mentioned general form equality hold calculus equality determined constant equations ref ref ref tn tn function equations product equations tx tx fv wf unit equation ax equality rules determined terms beta eta associativity term equalities arguments bodies 
refinement calculi nondeterminism bun mor 
illustrate nat fermat ref nat nat nat specification solutions fermat theorem index tuples xn yn zn 
contrast bun mor nat fermat fermat left hand side unsatisfiable right hand side satisfiable 
similar situation asl extended ml 
observed sst section principle modular decomposition means module decomposed application parameterised module module parameterised module implemented arbitrary arguments implementation independent particular properties actual argument 
similar point example 
discuss detail section 
general equality hold underdetermined means common programming technique refining abstracting specific implementing recursively general argument 
example recursive refinement get constants rn xn rn xn rn applications pairs projections abstractions ax xx rr zx term equalities cont 
variables constants wf ref ref ref unit pairs abstractions wf wf wf refinement rules ax stubs congruence fv wf fv logical congruence reflexivity transitivity weakening fv refinement weakening refinement rules cont 
unit product function refinement types transitivity predicates wf refinements refinement types rules chapter 
order logic refinement calculus interesting retrospect general equality 
fragment discussed 
means certain extent evaluate terms programs 
illustration difference refinement calculi nondeterminism bun war call value nondeterminism arbitrary abstractions considered values nondeterministic functions 
example refinement example consider involves sorting association lists keys complex values 
idea association lists values complex datatype manipulated efficiently pairing keys encode useful information 
develop programs sorting function function determines lists permutations 
axiom system naturals booleans example extend axiom system keys values association lists give axioms 
axiom system defined follows 
key value assoclist eq key compare key nil cons head tail remove listrec ordered sublist ground types key value assoclist 
define association pairs assocpair key value 
efficient equality comparison functions keys signature lists compare key key key bool eq key key key bool nil assoclist cons assocpair assoclist assoclist head assoclist assocpair tail assoclist assoclist remove assocpair assoclist assoclist listrec assoclist assocpair assoclist constants head tail defined lists including nil 
axioms say values nil 
listrec whichis primitive recursion lists fold left functional programming 
axioms include head assoclist nil assocpair tail assoclist nil assoclist listrec nil listrec cons xs listrec xs assoclist listrec nil assoclist assocpair cons assoclist predicate symbols axioms ordered pred assoclist assocpair assocpair bool pred assocpair assoclist sublist pred assoclist assoclist assocpair nil xs xs xs sublist nil sublist cons sublist remove ordered nil ordered xs ordered xs ordered holds list sorted relative ordering holds pair list mathematically terms key 
assoclist proposition perm defined perm sublist sublist specify ordering association pairs compare assocpair assocpair bool key value compare key true compare true example compare assoclist assoclist compare key sorting function sort spec ref assoclist assoclist sort spec assoclist assoclist ordered compare perm note specification say happen values key matter 
seman tics sort spec truly underdetermined 
define specification sorting assoclist ordered compare perm ref assoclist refinement begins sort spec assoclist assoclist ordered compare perm assoclist listrec nil assoclist assocpair cons assoclist assoclist listrec nil assoclist assocpair cons plan stage implementation 
possibility construct new list systematically removing elements inserting correct position new list 
insertion sort 
need implement specification assoclist assocpair cons ref assoclist assocpair fact need argument 
specification insertion function assoclist insert spec assocpair cons ref assocpair assoclist assoclist says assocpair sorting return sorting cons insert correct position sorted list 
assoclist assocpair cons assoclist insert spec refinement rule listrec refine insert spec 
assoclist cons 
insert spec assocpair assocpair listrec nil assoclist assocpair cons assocpair listrec cons nil assoclist assocpair cons assocpair assoclist assocpair compare cons cons cons cons assocpair assoclist assocpair cons assoclist assocpair compare cons cons cons step refinement generates proof obligation 
give code sorting algorithm sort assoclist listrec nil assoclist insert insert assocpair 
listrec assoclist assocpair compare cons cons cons guaranteed subject refinement see lemma sort sort spec 
suppose want write function test association lists true permutations implement perm 
sort lists sort compare corresponding entries compare key 
thisis quite right pointed distinct values may key different relative orderings separate lists 
specify sorting sense context independent sense pairs list sorted order matter appear list 
done strengthening specification insert case values key insert function predetermined choice dependent value 
require value choose choose specify insert assocpair assoclist assoclist choose value value bool assocpair assoclist ordered insert pl compare perm insert pl cons compare lexicographic ordering orders key choose compare compare key true true eq key true choose false leave implementer insert find injective ordering exploiting implementation details values 
define permutation function perm assoclist assoclist bool perm eqlist sort sort eqlist defined listrec uses insert functions head tail partial sense results defined argument nil 
vl various ways accounting partiality algebraic specification considered 
ways simple approach total algebras extended 
hand extend syntax specifications algebra semantics 
error algebras specification augmented error values type predicates distinguish error non error values axioms explain errors propagated 
complicates specifications considerably terms interpreted total functions 
extension idea monotonic continuous algebras type axiomatised poset cpo 
terms interpreted total functions monotonic continuous respect orderings 
alternative approach just change definition algebras specifications 
partial algebra terms interpreted partial functions carrier sets 
necessitates change definition homomorphism satisfaction 
approach alters notion specification algebra order sorted algebras 
form subtype polymorphism ordering defined sorts 
idea give terms specific sorts total 
example define list tail list 
approach differs ideas 
form subtyping constrain domains primitive functions 
regarding terms representatives equivalence classes away irrelevant details 
natural approach day write total programs underlying programming language 
say functions computationally total partial 
comparisons compare related approaches program development 
extended ml lego notion refinement 
calculi morgan refinement calculi nondeterminism 
show metalanguage studying comparing program development methodologies 
compare alternative approaches program development type theory 
extended ml extended ml language similar spirit approach takes existing language case standard ml conservatively extends specification constructs give wide spectrum development language 
constructs added placeholders question marks axioms corresponds exactly modular analysis 
defined semantics kst methodology san 
semantics separated static dynamic verification parts 
static semantics analogous finding underlying type term formalised directly 
refinement typing corresponds static verification semantics 
difference verification checks program annotated respect particular interpretation showing particular property holds interpretations 
dynamic semantics formalises evaluation terms possible order experiment programs 
formalised suggest considered 
intention formalise specification language terms arbitrary logic institution 
specification style property oriented 
terms interpreted respect things particular question mark interpretation 
syntactic mapping arbitrary expressions 
number differences 
question marks replace arbitrary expressions particular types 
booleans propositions combined 
satisfaction properties behavioural equivalence 
proof theory 
general forms refinement rule particular application generates proof obligations verified respect semantics 
contrast rules low level proven sound complete 
rules san suitably translated form admissible 
take simple example model functors functor sig sig exp abstractions sig exp coding rule san derived 
rule sig sig sig sig sig sig sig follows admissible aspinall asl thesis asp aspinall presents number lambda calculus calculi program development 
spirit constructs main calculus number subcalculi studies separately 
development methodology specification type satisfaction subtyping refinement idea specification language parameterised respect arbitrary institution 
underlying type theory specification language gives type structure specification building operations institution 
subcalculi power extensions dependently typed lambda calculus singleton power types respectively 
singleton types simple form specification independent institution power types allow parameterisation specifications arbitrary specifications 
studied parameterised specifications 
significant similarities 
aspinall intention provide framework modular specification constructors studied independently particular logic specifications functions simple form specification parameterised program gives specification language anyway 
notion refinement defined accounts singleton types general propositions 
propositions added top institution 
aspinall calculi parameterised signature consequence relation signature satisfies certain properties 
contrast axiom systems defined signature explicit set axioms inference rules 
specifications treated types notion rough type originally due sannella analogous underlying types 
similarity uses semantics interpreting specifications pers underlying type 
interprets terms elements pers interpret equivalence classes 
evident interpretation abstractions aspinall take account uses rough type 
completeness results 
type theory general approaches type theory program derivation 
hand subtyping approach exemplified sannella tarlecki st aspinall 
specifications formalised types refinement specifications formalised subtyping spec spec refinement continues obvious program satisfies specification inhabits type 
approach exploits constructive nature type theory curry howard isomorphism 
specification phrased theorem proof theorem constructive logic type theory automatically gives program satisfies specification extraction mechanism 
nps nordstr petersson smith martin type theory unified formalism specification programming extraction style 
derivation methodology idea typing rules read goal directed tactics 
levels martin type theory basic type theory dependent types top theory subset types 
subset type consists type propositional function types terms type true 
split levels similar types refinement types important difference refinement types correspond relations types subsets 
regard formalising alternative interpretation subset theory 
consequences type theoretic formalism specification programming logic intuitionistic programs terminate 
subset types proposition translated underlying type theory intuitionistic 
interpretation subset theory basic theory translation type basic types propositional functions 
example translated type nat nat propositional function nat fx inf 
typing rules translated way curry style rules abstractions labelled types 
program refinement conceived thesis similarities type theoretic approaches 
refinement relation 
corresponds program extraction approach refinement implicit corresponds subtyping approach 
lego lego lp example proof assistant implements extraction style type theoretic development 
subtyping explicit notion refinement existential variables 
stage refinement lego user proof state consisting context assumptions xn number goals stored representation proof far hidden user goals context 
naively represent state refinement term xn ym translation proof far 
see goals context arise suppose goal refine 
resulting proof state contains assumptions xn single goal 
goals hidden assumption refine 
fact proof states correspond arbitrary refinement terms 
certain extent user able manipulate terms contain existential variables corresponding refinement terms 
sophisticated approach nps incorporates existential variables explicit notion refinement implicit straightforward type theoretic approach 
existential variables correspond stubs free variables 
fact refinement calculus may viewed explicit formalisation lego refinement process 
conversely lego may viewed tool performing refinement 
closer comparison lego version 
calculus constructions consider underdeterminism orthogonal type theory 
basic commands lego setting goal claiming lemma making local definition refining current goal changing order goals 
commands corresponds naturally refinement step calculus 
step development setting goal introduces refinement term claiming lemma refinement weakening making local definition weakening determined contain existential variables 
refinement goals lego performed directly solving goal unifying goal library function sothat refined 
translate rearrangement goals corresponds commutativity terms 
regard nontrivial justification reordering goals lego simpler expressions arising obviously sound 
lego ability perform automatic unification refinement 
steps derived basic ones 
interesting formally compare rules lego 
apply metatheoretic results lego 
example lego rules 
conclude claims unnecessary 
refinement calculus back morgan morris compare calculus imperative refinement calculus back morgan morris 
version taken mor 
simplified grammar language skip abort pn cn fi re er var con expressions order logic plus arithmetic notation procedures consider 
commands specified expressions 
specification constructs 
notation specification command precondition state results postcondition altering variables frame alternation construct fi choice commands ci guard pi true 
pi true command unsatisfiable 
declaration logical constants con program code abbreviation introduced development ultimately refined code 
annotations assumptions coercions defined commands specifications 
assumption pre pre coercion post post 
fact abort skip defined specifications 
distinction imperative functional languages theoretically irrelevant study refinement 
translate imperative features calculus style idealised algol 
example add primitive type state define translation terms calculus com state state assign var new order avoid considerations nontermination assume recursion terminating encoded primitive recursion say 
interested translating features calculus 
logical constants translated con imperative refinement calculus choice expressions authors useful translation 
define bool connection propositions booleans usually satisfactorily accounted 
commonplace useful write propositions place booleans explained ultimately refined booleans 
study associate boolean term proposition sum types asserting mean case may assumptions reasoning respectively 
write propositions convention 
fi true true final branch intended mean false term unsatisfiable 
put force term unsatisfiable 
logically pre postconditions just particular form property 
define frame proposition fr differ variables 
propositions pre post properties state 
var sx 
show pre post pre post fr pre pre form annotation coercions neat representation 
assume hoare logic commands schematically 
example propositions variables sufficiently powerful type theory object level substitutions definition internalised 
morgan introduces large number refinement laws arranged complete system refinement rules logic refinement terms 
consider laws mor 
absorb assumption pre pre post pre pre post hold calculus 
see observe general able satisfy second expression satisfiable able expression unsatisfiable 
translation left hand side law pre pre post fr failure equivalence mean calculus impossible external assumptions reasoning specifications 
satisfiability leads complications 
order understand entire system needs considered 
believe satisfiability specifications local assumptions contextually explicit global local context 
expression form pre pre post arise refinement anyway 
contrasting status law mor indicative difference underdeterminism nondeterminism see 
alternation pre pre post refines pre post pre post fi pre post fr pre post fr 
show need auxiliary results pre post fr com 

refine second branch get refines 
final branch unsatisfiable refine com term refines com metatheory section prove number proof theoretic results refinement calculus 
completeness proof section results inherently interesting provide insight nature refinement 
extend results section showed simple refinement relation 
factored coding equality 
main idea refinement factored simple form non logical refinement logical equality 
relations seen generalisations simply typed refinement relation 
logical equality respectively 
mirroring results simple refinement turn factored coding coercion 
proving factorisation characterisation logical equality show refinement typings proven standard way 
called generation lemmas useful metatheoretic reasoning judgements 
idea lemma term satisfies specification able prove induction structure term 
example pair satisfies specification able prove conclude pair satisfies 
formally say refinement types general 
case 
possible directly infer term satisfies specification taken axiom example 
fact refinement type rules break structural form refinement typing sense inferred refinement type need relationship term 
formulate generation lemma account possibilities 
proof exploits fact refinement elimination useful combination subset rules corresponding relation logical eta define eliminated 
lemma generation derived rule refinement type followed weakening derived structure follows 
exists 

rn axiom ri 

exists wf 
exists wf 

exists wf wf 



exists wf 

exists wf 

rr exists wf wf 

exists wf 
proof show eliminate nonessential uses refinement elimination rule 
rule useful combination refinements logical equality rules 
induct rules show case replace rule followed refinement elimination single derived basic rule hypotheses refinement typings formedness conditions 
example place function equations rule wf func 
eqs 
ref 
elim 
wf note eliminating uses refinement elimination 
derived rule 
rule eta eta ref 
elim 
proven directly similar analyses hold rules 
assume loss generality provable ref type intro 
inferred refinement typing rules derived rules weakening 
need just show rules preserves conditions lemma sense hypotheses rule derived standard way described lemma inferred standard way 
fact immediate refinement typing rules derived rules 
need just check case weakening 
example suppose inductive hypothesis exists 
cases show hypotheses suffice elimination rules 
point view completeness restriction rules product terms function terms problem 
proof lemma depend factorisation result give 
lemma subject refinement proof induction generation lemma 
example follows ref 
type intro 
followed weakening case predicate symbol ref type intro 
weakening want split refinement equality form nonlogical refinement independent refinement type 
immediately clear definition defined refinement specific refinement types 
refinements provable refinement type term refined definition 
example nat refines refinement type nat 
definition define form untyped refinement terms 
say holds provable wf provable order prove factorisation theorem need fact axioms factorised 
easiest way doing assume axioms assumed definition 
theorem factorisation exists term term proof give sketch proof 
central idea partition rules call logical eta simple refinement computation defining relations figures respectively 
note decomposition rules top refinement rules derivable certain extent definitions relations arbitrarily get proof go 
example include eta rule simply clear commutes rules fact needed proof 
combining computation simple refinement logical eta respectively get nonlogical refinement logical equality 
specifically define reflexive symmetric transitive closure define reflexive transitive closure 
show contained contained 

refinement rules kinds axioms hypotheses contain refinements congruence rules 
prove axioms factor congruence rules substitution preserve 
disjunction assuming refinement factors rp assuming factors rq assuming factors rp rq defined ing annotations choice 
rules exclusively stubs refinement rule complex congruence rules 

induct show 
clearly holds conclude commutes factors 
show 

corollary refinement relation proof theorem 
result follows generation lemma show 
corollary exists term proof suppose theorem exists term necessarily case determined 
construct term replacing stub determined refinement generalise canonical forms lemma chapter show term canonical form equal refinement types 
lemma canonical forms terms context exists context xn determined term xn wf xi appears exactly xn proof rules move underdeterminism outwards 
shown arbitrary refinement 
show refinement determined term 
defined reflexive transitive closure fact way lemma exists proof show commutes direction result follows 
eta axioms weakening strengthening congruence function equations fig 
eta fig 
axioms form wf fv congruence rules constants pairs applications projections logical eta coding weakening stubs eta congruence fv simple refinement decomposition beta eta equalities congruence wf wf function equations fig 
product equations fig 
product equations fig 
unit equation fig 
figures eta computation chapter defined coding relation extend definition obvious way 
definition define coding relation formed terms reflexive transitive congruence closure onestep relation possible refine terms simply weakening refinement types binders 
define relation notion coercion 
definition define coercion relation formed terms reflexive transitive congruence closure step relation wf wf wf chapter showed refinement determined term 
factored coding equality lemma 
generalisation lemma lemma proof show rules factor 
clearly commute 
need show rules weakening eta eliminated weakening suppose clearly 
eta suppose consequences completeness proof lemma 
exists term 
exists term proof 
suppose lemma exists term lemma exists determined 
theorem exists part lemma exists term lemma completeness refinement programs proof follows directly substitution 
definition wf define mean determined lemma refinement mappings 
exists suchthat 
proof definition 

lemma means exists aterm 
models motivate semantics calculus section giving details section proving soundness completeness 
discussion discuss properties semantics refinement calculus give intuitive meanings refinement typing refinement calculus 
intention model calculus form henkin interpretation enable comparison models subcalculi 
chapter refinement term thought denoting set values realizers corresponding programs satisfy specification 
chapter determined terms seen denoting sets total realizers 
unexpectedly think terms full refinement calculus denoting sets 
see consider meaning refinement typing 
approximation means realizer 
wrong want nat nat true realizer certainly nat nat 
problem interpretation set losing information realizers determined nat 
analogous distinction nat nat 
fn 
refinement types correspond sets total terms say extension represent different equalities 
recast example dis refinement terms nat nat nat fx problem interpretation refinement types uses pers just types 
need involve pers interpretation terms 
chapter said true realizers equal 
certainly prevent having refinement type nat nat nat nat nat nat true 
solution think refinement terms sets equivalence classes 
case interpret single class nat 
term nat nat fn interpreted classes nat nat fn interpret immediately obvious equivalence classes set equivalence classes just simply interpret refinement terms pers 
example refinement term interpreted refinement type 
succinctly express semantic meaning refinement typing true meaning meaning 
show section determined terms terms calculus interpreted single equivalence class 
regain set theoretic intuition underdetermined term corresponds set realizers realizers thought determined terms corresponding equivalence classes means thought 
semantically final stage refinement single equivalence class 
intuition refinement term think refinement 
semantically forms refinement reducing number classes restriction reducing size classes quotienting 
example nat nat nat restricted operations give 
practice refinement consist progressive restrictions semantic sense specification program 
non discrete equivalences arise refinement types abstractions 
quotienting correspond relaxing assumptions increasing domain definition 
think refinement combination reducing number classes making classes finer 
relations combined saying true capitals meaning expressions contained closure thatis 
fact require 
example nat nat true single class denoted nat equal nat nat 
pointed refinement type nat nat 
similarly nat nat nat nat goal refinement reach term represents single equivalence class syntactically determined term necessarily term semantic standpoint consistent continuing metavariable determined terms 
henkin models suggested 
possible approaches giving semantics 
possibility interpret 
interpret calculus henkin models additional structure introduced model subcalculi sections factoring structure 
difference factoring condition strengthened account logical structure 
follow pattern previous chapters giving interpretation pre expressions defining interpretation signature models axiom system 
define notion environment chapter write environment henkin interpretation pre expression context interpreted environment 
interpret pre expressions avoid need establishing coherence calculus 
basic data axiom systems order axiom systems give interpretation pre expressions firstorder henkin interpretation environment figures 
gives interpretation refinement types pers set corresponding underlying type 
interpretation calculus repeat 
gives interpretation refinement terms pers 
element singleton consisting class models soundness theorem imply choice semantics abstractions important similarly binding expressions 
define pers sets pairs 
explain cases abstractions pairs 
abstraction denotes relates functions arguments related results related similar relates individuals exists pair related soundness implies choice matter 
interpretation pre propositions set environments true 
convenient write truth falsehood 
having interpretation pre expressions definitions 
definition order henkin interpretation 
say satisfies logical factoring condition require exists exists definition sg signature 
henkin interpretation sg order henkin interpretation sg satisfies proj proj proj proj proj ar app app ar logical factoring condition 
interpretation refinement types obvious extension definition expressions 
calculus turns expressions defined interpretation 
fact expressions interpretation example nat bool interpreted empty 
henkin interpretation define wf implies 
formedness interpreted semantically equal environments giving equal interpretations 
define mean mean 
particular 
see asymmetric meaning refinement symmetric formulation 
judgement write 
definition sg ax axiom system henkin interpretation signature sg 
say model sg ax formed axiom write rn mn rn ai mi proj proj proj proj app app proj proj am proj proj am rr app app fm am am bm interpretation refinement terms rn rn rn ai ri interpretation propositions formed axiom ai ka ka 
write meanings judgements may equivalently expressed terms equivalence classes 
cl cl metavariables equivalence classes writing cl class value 
lemma 
cl cl cl 
cl cl cl cl proof prove part 
suppose literal reading inclusions pers andr 
cl 
cl exists rx set 
cl conversely suppose cl cl cl cl 
cl cl exists cl cl cl choose cl 
lemma determined terms singleton class 
proof induction formalise sense interpretations generalise semantics subcalculi 
observe axiom systems axiom systems 
henkin interpretations give rise henkin interpretations similarly environments interpretation functions different 
terms 
interpreted sets terms interpreted pers 
interpretation terms subcalculi special kind 
particular types terms 
interpreted discrete pers 
terms determined terms interpreted pers 
subscript interpretations calculus 
define mappings sets pers 
set 
define pers sy discrete sy proposition formed term type 

pre term refinement type proposition 
proof induction expressions 
proposition calculus conservative extension 
semantic sense sg ax axiom system henkin model sg ax suppose terms 

sg ax axiom system henkin model sg ax suppose terms 
proof 




cl cl cl cl cl cl cl cl class need generalisations lemmas soundness completeness proofs subcalculi 
lemma substitution lemma ti xn ti xi ai ti xn 
proof induction xn written substitution lemma lemma stated sets pers 
analogues lemmas follow similarly 
theorem soundness henkin model axiom system sg ax sg ax ranges basic judgements particular sg ax wf wf sg ax wf wf sg ax sg ax proof simultaneous induction derivations judgements 
sim proof soundness observing rules need show follows 
key cases omitting proofs 
variables suppose wf 
suppose sob constants fix 
sob ka ka soundness suppose models axiom ka ka 
function equations suppose 
iff exists elements app app 
holds iff iff substitution lemma 
beta suppose andb 
substitution lemma term equalities projections suppose exists abstractions similar proof chapter uses stronger factoring condition 
sake simplicity consider closed terms 
show zx zx fb zx ab fb ab follow line reasoning chapter prove statements equivalent 
interesting direction showing implies 
define ab 
says logical factoring condition exists remainder proof follows chapter 
logical congruence suppose suppose br exists implies similarly refinement rules soundness figures follows corresponding proofs chapter 
implies give semantics mapping classes 
write environment meaning member class 
chapter problem formulating completeness result interpretation refinement types pers correspond exactly rules calculus currently stand 
kinds mismatch 
hand term wellformed semantics virtue having unique interpretation syntactically formed example 
problem arose higher order terms due calculus requiring arguments abstraction refinement type abstraction model just needing equality arguments refinement type give equal results 
example nat nat refinement type nat nat model calculus 
got round chapter defining contextual equivalence terms 
forthe wehave nat nat nat nat 
possibility restrict statement completeness avoid classes terms chapter 
virtue simpler easier extend completeness theorem suggestions chapter 
suppose judgement true models relevant axiom system 
order show judgement provable assume wellformed formedness judgement means wf wf thatis additional assumption judgement rank equal rank defined recursively syntactic category idea exclude higher order refinement types 
example rank nat bool nat rank nat nat 
completeness proof pattern previous chapters 
construct term model appropriate notion henkin theory 
definition calculus regard theories infinite contexts rooted left 
definition sg ax axiom system 
henkin theory sg ax formed infinite context closed derivation sg ax term determined term suchthat fy theorem completeness sg ax axiom system 
sg ax wf rank henkin models sg ax sg ax particular assuming rank sg ax wf models sg ax sg ax sg ax wf sg ax wf models sg ax sg ax 
proof consistent context 
sketch construction model environment derive completeness 

construct maximal consistent henkin theory 
construction follows theorem 

construct term model open terms 
define set equivalence classes structured open terms ref respect equivalence 
construct henkin interpretation interpreting constant predicate symbols syntactically 
prove satisfies factoring condition defined interpretation 

wf prove 
uses characterisation expressions term model lemma 

model axioms reasoning similar step 
xn variables define environment xn show arbitrary consistent context satisfiable 

final step show just 
suppose consistent previous steps environment 
situation refinement typings reduced propositions equivalent crucial point permissive formedness rule refinements refinement means formed need refinement type 
implies refinement elimination 
order prove step lemmas 
characterise interpretation refinement terms types term model semantic interpretation understood fixed 
discussed restrictions pers correspond equality 
completeness implicit definition sat 
explicit definition 
definition wf define sat mean refinement types interpreted pers equivalence classes oneto correspondence determined terms 
lemma proof define term induction 
lett andt 
prove induction iff 
interesting cases clearly iff 
case deduce lemma rank restriction 


wf sat 
wf proof simultaneous induction expressions 
inductive ordering proof uses lemma 
prove cases propositions writing 
cases proven chapter 
means inductive hypothesis sat implies 
wf 
assume loss generality pred andr canonical form show equivalent 
suppose 
inhabited sat 
maximality consistency infer 
refinement type terms subject refinement 
predicates 
conversely refinement type definition sat subject refinement sat 
show equivalent turn equivalent suppose lemma sat exists sat representatives equivalence classes 
inductive hypotheses reasoning chapter suppose corollary exists determined term sat exists sat definition wehave conversely suppose sat corollary exists sat lemma show reasoning corresponding step completeness proof calculus 
assume loss generality terms canonical form assumption formedness lemma gives canonical forms equal terms 

lemma exists term 
suppose inhabited 
term type 
term exists assumption types inhabited 
lemma implies 
similarly wf 
context term refines refines equals 
characterisation interpretation expressions lemma specific term model 
example term model nat nat consists equivalence classes terms type nat nat full set theoretic function hierarchy definition classes consist arbitrary functions 
lemma showed determined terms interpreted single equivalence class 
give simple characterisation class term model 
lemma rank restriction sat sat proof follows lemmas 
lemma see term model arbitrary refinement terms interpreted pers consisting classes form 
corollary rank restriction iff determined proof statements interpretation result follows soundness completeness 
step proof completeness suggests general strategy proving express canonical form prove 
know refinement typing true completeness propositional fragment proposition provable 
conclude subject refinement chapter calculus refinement calculus notions refinement term refinement type 
chapter discuss give basis comprehensive theory software development 
chapter thesis constructed canonical refinement calculus lambda calculus classical order predicate logic studied proof theory semantics 
summarise main points formalisation formalisation refinement programs lambda terms programs refinement terms specifications refinement types gave set theoretic semantics henkin models calculus proven sound complete 
far know proof completeness refinement calculus 
key feature approach construction refinement calculus modular fashion combination orthogonal extensions underlying programming language case simply typed lambda calculus 
subcalculi interesting right provide separate analyses structured specifications non logical decomposition 
full refinement factored logical equational reasoning simple decomposition 
level formalisation specifications consisting underlying level program types expressive level program properties 
discuss issues raised introductory chapter addressed 
set task investigating logic semantics refinement calculi saw possible induce refinement calculus extensional program logic equational theory programming language canonical case simply typed lambda calculus 
construct structured specifications refinement types notion equality specification 
syntactic category refinement terms consists combinations specifications programs 
order logic simply typed lambda calculus modelled henkin interpretations models particular lambda theories logics form model corresponding refinement calculus 
refinement calculus completely characterised underlying theories sense complete certain restrictions respect class models induced models underlying theories 
completeness theorems deduce restrictions conservativity refinement calculi program logics equational theories programming languages 
refinement calculus thought constructed subcalculi calculus refinement terms calculus refinement types 
calculi useful right 
example saw terms calculus evaluated program fashion 
factorisation theorem justifies regarding subcalculi orthogonal extensions programming language program logic 
factorisation suggests interesting possibility construction modular refinement tool checking program correctness combination type checking theorem proving 
modularity come constructing verifier specification checker existing theorem prover think oracle type checker program logic programming language respectively 
write separate program handle simple refinement combine get refinement tool 
thesis simple calculus believe motivated general methodology inducing refinement calculus programming language logic constructing development methodology scratch 
believe theoretical standpoint approach useful formal methods 
naive expect programmers treat programming mathematical activity working directly refinement calculus 
dangerous viewpoint insofar leads mathematical formalisation primary object interest theory actual programming practice 
formalisation relevant concepts desirable realistic provide theoretical underpinning tool support 
intention calculus directly serves underlying theory 
believe factoring complicated calculus subcalculi proven worth research methodology 
extensions suggested studied extensions subcalculi 
believe principles outlined general applied structures traditionally studied data flow diagrams example 
logic arbitrary point constrained type theory 
interesting line research see type theoretic semantic ideas help 
calculus provide foundation specification formalisms specific suggestions 
refinement terms interested see calculus usefully combined logical frameworks pfe 
logical variables example underdeterminism 
lego richer type system studied fragment studied 
metalanguage 
interesting 
metalanguage giving semantics lego prove metatheoretic results 
concept underdeterminism arises computing science linguistics strengthens belief important concept study general informatics 
annotate types simple properties exception raised point 
useful intermediate stage calculus refinement terms full refinement calculus 
refinement types number systems intersection union types 
expressed system 
example refinement type corresponds odd odd 
hayashi hay intersection union powerful 
clear degree expressivity system particularly useful see comments quotients 
level nature calculus suggests construction modular tool checking program correctness combination type checking theorem proving 
modularity come constructing specification checker existing theorem prover type checker program logic programming language respectively 
similar done interactive proof development systems nuprl pvs type checking generate proof obligations 
technical extensions conjectures suggestions various technical extensions results calculi 
extensions particular aimed tidying main loose ends restrictions completeness chapter restrictions dependent refinement types chapter 
final ideas suggestions reformulations calculi 

place restrictions statements completeness due underlying mismatch refinement type semantics 
example prove nat nat refinement type nat nat 
problem rules stand abstraction refinement type require case refinement goes opposite direction nat nat nat 
sound general say conditions 
rule appear sound 
define dom set terms refinement type 
dom dom combination dom dom means dom dom quotient 
rule prove nat nat nat nat may strengthen theorems completeness unrestricted versions 
similarly rule sound may admissible provable consequence rule nat nat nat nat 
combination quotienting subset type refinement types interesting specification 
specification formalisms form quotienting interesting see arise naturally order get completeness 

chapter refinement types avoid combination underdetermined terms refinement types 
problem arose chapter level terms led introduce terms 
introduce notion types obvious meaning 
rule rr special rule stubs 
wf refinement rules types analogous equalities terms 
give convenient extend singleton type notation arbitrary refinement terms write refinement type example 
may maximal order henkin theory order henkin theory 
witness condition refinements may follow condition existentials 

conjecture 
factoring condition equivalent satisfaction choice axiom fx 
conjecture calculus conservative extension aspinall calculus asp 

define notion strong formedness requires appropriate refinement typings equalities predications strongly formed formulate connection different restrictions completeness 

suggested axioms particular form investigated 

conjecture term equality abstractions chapter equivalent typed form avoid meta judgement formal system 

satisfactory account section remains 
example eta commute rules 
taken refinements kinds atomic propositions separate judgement classes 
conjecture restricted calculi atomic propositions equalities refinements separate judgement classes complete 
full systems conservative extensions 
considered natural approach specification refinement complex just underlying program logic 

conjecture 
complete alternative semantics 
avoid factoring conditions 

suggestive notation dependent form refinement rule pairs 
overlap refinement rules terms refinement types 
combine judgements form meaning natural rules notation introduced overlap clear giving rules types 
example 
base refinement calculus primitive definitions 
natural usually omit subscripted anyway 
operational semantics denotational semantics give modular operational semantics giving semantics subcalculi 
just outline subcalculi 
restrict specific axiom systems booleans naturals 
refinement terms terms calculus mixture specification program inherit notion reduction lambda calculus give operational semantics satisfaction terms properties canonical terms 
canonical terms closed terms form arbitrary determined term booleans true false numeral 
operational semantics figures consists evaluation relation determined terms tt evaluation mutually recursive relations extensional equality canonical terms satisfaction relation canonical underdetermined terms validity propositions want equality refinement extensional determined terms arbitrary underdetermined terms define typed extensional equality canonical terms induction 
second component operational semantics satisfaction relation example 
fact unique canonical form equal written assume uniqueness 
define 
forr say define validity refinement exists say axiom system operationally complete refinement operationally valid provable 
example signature operationally complete example 
nat nat succ identity positive naturals nat cond eq form recursion define predecessor term prove refinement 
important practice ensure operationally complete signatures avoid writing specifications implemented intuitively implementable 
saw axiom systems denotationally complete respect class henkin models factoring condition 
operationally exists exists exists exists satisfaction iffd equality canonical terms exists validity propositions complete theories complete arbitrary henkin models 
refinement types give operational semantics calculus satisfaction terms properties canonical terms 
mutually recursive components operational semantics extensional equality canonical terms satisfaction underdetermined terms canonical terms validity propositions define extensional equality induction 
satis faction refinement types canonical terms defined define 
say operationally valid annotations program reasoning manipulation requires facts true local program point 
example known variable certain bounds programmer compiler may able perform partial evaluation optimisation 
annotating program text propositions suggested floyd flo refinement calculi bun facilitate reasoning express local assumptions 
extending type system refinement types gives simple notion program annotation variables abstractions labelled logical information 
explicit annotations calculus define certain forms 
define assertion guard showed combine guards refinement types 
example assertions treated similarly 
consider calculus true annotations 
possibility extend simply typed lambda calculus terms form proposition operational meanings implies appropriate type satisfy define meaning preserving 
translation subset annotation calculus alternative formulation refinement calculus take annotations primitive 
define set theoretic opposed specifications search calculi thesis pym pym presents theory proof search 
idea developed pw give hierarchy calculi regarded metatheory search space proofs increasingly constrained 
idea applied refinement 
refinement traditionally formulated generalised equality pointed lemma style calculi 
refinement specification program thought refinement ordering 
calculi contain rules directing search 
commented section consider search oriented equational refinement calculus 
seen solution search program satisfy 
section defined number auxiliary relations 
relationship interesting mirrors difference refinement search 
pw consider hierarchy subsystems full equational refinement theory 
example 
type inhabitation 
coding 
simple refinement 
nonlogical refinement type inhabitation consider simple task finding program inhabit type 
presents backward oriented rules may automate search 
rules viewed reformulations refinements form wheret read rules included labelled deduction 
consider rules proving inhabitation arbitrary coding thought big step refinement 
rules equality omitted equality orthogonal refinement sense exists andt system embedded general system proving refinements form thinking refinement search inhabitation specification think generalised equality 
view refinement calculus means representing stages search inhabitants specifications metatheory search calculus 
study difference equational search oriented refinement semantic viewpoint 
search calculus modelled possible worlds semantics 
logical variables related idea distinction equational search oriented refinement presenting refinement calculus natural deduction sequent calculus styles 
chose essentially sequent calculus presentation natural deduction better suited proof search 
pointed previous section calculus search oriented anyway 
natural deduction style presentation clearer 
best give equational theory natural deduction style translate search oriented calculus sequent calculus style prove equivalent 
refinement calculus true sequent style logical variables 
effectively unification paradigms refinement sense search theory gives rise associated equational theory rules equational theory restricted search oriented subset 
second order data refinement extension second order polymorphic lambda calculus offers hope combining program data refinement formalism allowing specification observational equivalence 
account specifications chapter brings equality fore especially useful data refinement natural consider different equalities concrete types 
combination refinement types existential variables natural way augmenting mp equations 
interesting see calculi extended second order 
reduce number rules impredicative encodings unit product sum 
importantly calculus able express inductive types iteration 
ought get derived refinement rules data types nat list 
define data types existential types 
question connection view data refinement back morgan categorical studies hoare hoa tennent arises 
parametric polymorphism throw light relations model oriented data refinement 
full recursion nontermination say plotkin computational metalanguage raise particular issues 
possible integrate nontermination smoothly 
modular approach help tackling problem 
traditional type theoretic approaches nps handle nontermination terms terminate 
example naively adding full recursion simply typed lambda calculus results inconsistency see 
type theoretic maintaining curry howard isomorphism 
complications arise nontermination underdeterminism modelled nondeterminism 
clearly seen semantic point view 
models powerdomains 
simple sets interpretations determined terms possibly nonterminating suffice 
reflects intuition underdeterminism computation interact 
contrast powerdomain approaches raise myriad questions concerning exactly interact 
example authors distinction erratic nondeterminism clear notions transfer underdeterminism 
extending nontermination distinction partial total correctness arises similarly refinement 
model specifications pers possibly want add condition downward closure 
contradict comment nontermination interact underdeterminism presumably model terms sets equivalence classes 
questions address interaction refinement types recursion ensure progress recursive refinement avoiding refining 
recursion level specifications separate issue 
possible subtyping systems recursive types useful 
program transformation people program refinement program transformation synonyms 
basic idea generalised include useful draw distinction refinement logical specification concrete code transformation concrete program code better code 
separation concerns corresponds idea particular program development calculus simply typed lambda calculus factored orthogonal extensions lambda calculus program development consists stages developing functionally correct code satisfies extensional specification application optimising transformations produce efficient code 
reconciling approaches address common concern emphasis methodologies developing structured programs result inefficient code optimal programs tend hard understand 
approaches combined programs constructed refinement specification optimised transformations 
transformations refinements recorded possible view program various levels abstraction non optimal clear code logical specification 
just allow arbitrary possibly incorrect transformations give transformation calculus applied theory consists particular intensional feature time complexity collection atomic transformations respect 
intensional feature incorporated extended type transformation rules generated atomic rules 
interesting variety intensional features incorporated framework 
example formalising program style recast way 
ability express equality refinement type useful program transformation 
example want transform function type nat nat prescription maintain value evens improve odds way 
express part saying terms equal refinement type nat 
viewpoint semantics refinement calculi extended general categorical framework 
previous tended characterise refinement terms inclusion models preservation properties proof rules derived 
took opposite approach giving explicit axiomatisation refinement order get tractable syntactic definition 
question characterisation general semantic framework 
example factorisation refinement semantic counterpart 
significant motivation carrying general notion model offers hope making connections refinement popular development methodologies 
hermida uses fibrations model predicates complicated type theories 
uses fibrations indeterminates model parameterisation 
models calculi fibrations 
example dependently typed calculus modelled fibrations handle dependency logic 
underdeterminism separate feature top set 
able characterise semantically specialisation order example fio 
derived assumed structure ordering morphisms corresponds refinement 
generally envisage categorical structure cells correspond proof refinement 
congruence rules give categorical structure 
interpret cell define congruence rules valid refinement 
interchange law follows terms correspond refinement 
aspects software life cycle theoretical formal methods program verification development 
software life cycle consists activities comprehensive theory include 
suggestions refinement extended related areas 
prototyping calculus formalises partially developed programs combinations specification code induces logic logic underlying programming language 
possible reason partially developed programs class artifacts general possible evaluate arbitrary combinations specification program code 
possible give operational semantics language terms evaluated certain situations programs 
idea thinking dynamic semantics extended ml section interesting investigate simple notion prototyping see possibilities offers specification testing 
maintenance problem software maintenance modify legacy code performs function performs related function 
formulated language refinement 
program satisfies specification specification bears relationship problem construct program satisfies appropriate formalisation relates possible automatically construct partially developed program code needs rewritten replaced appropriate specifications 
possible reuse refinement part refinement constructing refinement idea extracting part term specification similar program slicing investigate connections view maintenance 
reverse engineering general idea reverse engineering recover high level description actual implementation 
useful comprehension maintenance 
researchers considered problem reverse engineering program specification war 
appears sight anyway dual problem refinement formal connections 
appendix notation refinement terms determined terms total terms individual variables function variables boolean variables natural number variables variable contexts propositional contexts propositions ground types types refinement types basic judgements judgements expressions constant symbols predicate symbols henkin interpretations models sets individuals mappings syntactic environments environments relations theories bibliography ac david aspinall adriana 
subtyping dependent types 
proceedings eleventh ieee symposium logic computer science 
asp david aspinall 
subtyping singleton types 
proceedings computer science logic volume lncs 
asp david aspinall 
type systems modular programs specifications 
phd thesis department computer science university edinburgh 
bac back 
calculus refinements program derivations 
acta informatica 
bb 
program development specification verification isabelle 
isabelle users workshop university cambridge 
bm burstall mckinna 
deliverables categorical approach program development type theory 
mathematical foundations computer science th international symposium volume lecture notes computer science pages 
earlier version appeared lfcs technical report ecs lfcs 
bos bos 
predicate logic 
tenth amsterdam colloquium 
bun alex 
expression refinement 
phd thesis department computing science university glasgow 
bur burn 
logical framework program analysis 
launchbury sansom editors proceedings glasgow functional programming workshop pages 
springer verlag workshops computer science series july 
cdg mario coppo damiani paola giannini 
refinement types program analysis 
static analysis third international symposium sas volume lecture notes computer science pages 
springer verlag 
cro roy crole 
categories types 
cambridge mathematical textbooks 
cambridge university press 
den 
refining refinement types 
informal proceedings types workshop subtyping inheritance modular development proofs university durham 
den 
simply typed underdeterminism 
eu kit ios international workshop formal models programming applications institute software beijing 
appear special issue journal computer science technology 
den 
refinement types specification 
david gries willem paul de roever editors ifip working conference programming concepts methods shelter island new york usa pages 
chapman hall 
dij dijkstra 
discipline programming 
prentice hall international 
fef solomon feferman 
theory variable types 
proceedings fifth latin american symposium mathematical logic volume revista de matem 
fio marcelo fiore 
axiomatic domain theory categories partial maps 
phd thesis department computer science university edinburgh 
flo robert floyd 
assigning meanings programs 
schwarz editor proc 
symp 
applied mathematics pages 
fp tim freeman frank pfenning 
refinement types ml 
proceedings sigplan symposium language design implementation pages 
acm press 
har david harel 
order dynamic logic 
lecture notes computer science 
springer verlag 
har david harel 
proving correctness regular deterministic programs unifying survey dynamic logic 
theoretical computer science 
hay hayashi 
logic refinement types 
types proofs programs volume lecture notes computer science 
springer verlag 
hay hayashi 
singleton union intersection types program extraction 
information computation 
claudio hermida 
fibrations logical predicates indeterminates 
phd thesis department computer science university edinburgh 
hj claudio hermida bart jacobs 
fibrations indeterminates contextual functional completeness polymorphic lambda calculi 
mathematical structures computer science 
hoa hoare 
data refinement categorical setting 
unpublished manuscript 
jen thomas jensen 
strictness analysis logical form 
hughes editor proceedings conference functional programming computer architecture volume lncs pages 
jon cliff jones 
systematic software development vdm 
prentice hall international 
js geraint jones mary sheeran 
relations refinement circuit design 
carroll morgan jim woodcock editors rd refinement workshop springer workshops computing 
kinoshita hearn power tennent 
axiomatic approach binary logical relations applications data refinement 
lecture notes computer science 
kst stefan donald sannella andrzej tarlecki 
definition extended ml gentle 
theoretical computer science 
lei 
mathematical logic hilbert symbol 
university mathematical series 
macdonald technical scientific 
lp luo pollack 
lego proof development system user manual 
technical report ecs lfcs department computer science university edinburgh 
luo luo 
program specification data refinement type theory 
lfcs technical report ecs lfcs department computer science university edinburgh 
mar martin meanings logical constants justifications logical laws 
nordic journal philosophical logic 
mck james mckinna 
deliverables categorical approach program development type theory 
phd thesis department computer science university edinburgh 
mit mitchell 
foundations programming languages 
foundations computing series 
mit press 
mm mitchell moggi 
kripke style models typed lambda calculus 
annals pure applied logic 
preliminary version proc 
ieee symposium logic computer science pages 
meyer mitchell moggi statman 
empty types polymorphic lambda calculus 
proc 
th acm symposium principles programming languages pages 
reprinted minor revisions logical foundations functional programming ed 
huet addison wesley pages 
mog moggi 
notions computation monads 
information computation 
mor morris 
theoretical basis stepwise refinement programming calculus 
science computer programming 
mor morgan 
programming specifications 
prentice hall 
mp john mitchell gordon plotkin 
types existential type 
acm transactions programming languages systems july 
nh 
logical specifications functional programs 
mathematics program construction volume lecture notes computer science 
nie flemming nielson 
annotated type effect systems 
acm computing surveys june 
nn hanne nielson flemming nielson 
automatic binding time analysis typed calculus 
proceedings fifteenth annual acm symposium principles programming languages 
bengt nordstr terminating general recursion 
bit 
nps nordstr petersson smith 
programming martin type theory volume monographs computer science 
oxford university press 
pfe frank pfenning 
refinement types logical frameworks 
herman geuvers editor informal proceedings workshop types proofs programs pages 
pfe frank pfenning 
practice logical frameworks 
ne kirchner editor proceedings colloquium trees algebra programming volume lecture notes computer science pages 
invited talk 
pit pitts 
categorical logic 
technical report university cambridge computer laboratory may 
pages 
pw david pym lincoln wallen 
investigations proof search system order dependent function types 
proceedings th international conference automated deduction volume lecture notes artificial intelligence pages 
springer verlag 
university edinburgh lfcs report ecs lfcs 
pym david pym 
proofs search computation general logic 
phd thesis department computer science university edinburgh 
ros rosser 
consistency quine new foundations mathematical logic 
journal symbolic logic 
san donald sannella 
formal program development extended ml working programmer 
proc 
rd bcs facs workshop refinement workshops computing pages 
springer 
se elliot soloway kate ehrlich 
empirical studies programming knowledge 
ieee transactions software engineering se 
spi spivey 
notation manual 
prenticehall international nd edition 
ss william scherlis dana scott 
steps inferential programming 
mason editor information processing proceedings ifip th world computer congress 
sst donald sannella stefan andrzej tarlecki 
formal development programs algebraic specifications parameterisation revisited 
acta informatica 
st don sannella andrzej tarlecki 
formal development programs algebraic specifications implementations revisited 
proc 
joint conf 
theory practice software development volume lncs pages 
springer 
extended 
tal carolyn talcott 
theory program data type specification 
theoretical computer science 
disco special issue 
vd dirk van dalen 
logic structure 
springer verlag 
vl jan van leeuwen editor 
handbook theoretical computer science volume formal models semantics 
elsevier mit press 
war martin ward 
transforming program specification 
technical report tr centre software maintenance university durham january 
war nigel ward 
refinement calculus nondeterministic expressions 
phd thesis university queensland 
wir niklaus wirth 
program development stepwise refinement 
communications acm 
programs algebraic specification annotations axiom system order order bottom coding coercion computational lambda calculus consistent correctness data refinement determined environment model condition existential variables extensional factoring condition full set theoretic function hierarchy generation lemma henkin interpretation index order henkin model order henkin theory order order maximal refinement type nondeterminism partiality power types problem reduction program analysis program logic quotient recursive refinement refinement terms refinement types rough types satisfiable search signature constant order order type singleton types skeleton stub subset types syntactic environment total transformation underdetermined underdeterminism structured wide spectrum 
