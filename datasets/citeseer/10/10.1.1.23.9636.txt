typed memory management static capabilities david walker carnegie mellon university karl crary carnegie mellon university greg morrisett cornell university region memory management alternative standard tracing garbage collection operations memory deallocation explicit verifiably safe 
article new compiler intermediate language called capability language cl supports region memory management enjoys provably safe type system 
previous regionbased type systems region lifetimes need lexically scoped language may checked safety complex analyses 
type system may deployed settings extensible operating systems performance safety untrusted code important 
central novelty language static capabilities specify various operations memory access deallocation 
order ensure capabilities relinquished properly type system tracks aliasing information form bounded quantification 
previous region type systems proof soundness type system relatively simple employing standard syntactic techniques 
order show language may practice show translate variant tofte talpin high level type effects system region memory management language 
combined known region inference algorithms translation provides way compile source level languages cl categories subject descriptors programming languages formal definitions theory semantics syntax programming languages processors compilers logics meanings programs semantics programming languages operational semantics logics meanings programs studies program constructs type structure general terms languages theory verification additional key words phrases certified code region memory management compilation typed intermediate languages material supported part afosr national science foundation 
eia 
opinions findings recommendations expressed publication authors reflect views agencies 
research performed second authors cornell university 
authors addresses david walker karl crary carnegie mellon university computer science department forbes avenue pittsburgh pa 
greg morrisett cornell university computer science department upson hall ithaca ny 
permission digital hard copy part material fee personal classroom provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission acm copy republish post servers redistribute lists requires prior specific permission fee 
acm acm transactions programming languages systems vol 
tbd 
tdb month year pages 
walker crary morrisett 
motivation background current trend systems software allow untrusted extensions installed protected services relying language technology protect integrity service hardware protection mechanisms lindholm yellin wahbe bershad necula morrisett kozen hawblitzel 
example spin project bershad relies modula type system protect operating system kernel erroneous extensions 
similarly web browsers rely java virtual machine byte code verifier lindholm yellin protect users malicious applets 
situations goal eliminate expensive communications boundary crossings allowing extensions directly access resources require 
necula lee necula lee necula proposed proof carrying code pcc morrisett suggested typed assembly language tal language technologies provide security advantages high level languages overheads interpretation just time compilation 
systems low level machine code heavily optimized hand compiler automatically verified type checking 
systems spin jvm tal touchstone necula lee compiler generates pcc aspect programmers optimizing compilers little control memory management 
particular soundness depends memory reclaimed trusted garbage collector 
applets kernel extensions may perform optimized memory management 
furthermore garbage collectors tend large complicated pieces software degree trust language protection mechanisms diminished 
goal provide high degree control memory management programmers compilers pcc tal frameworks verification safety programs straightforward task 
regions tofte talpin suggest type effects system verifying soundness region memory management 
tofte show infer region types lifetimes implement theory tofte birkedal birkedal birkedal 
advantages region memory management point view important region memory management implemented relatively simple constant time routines 
memory operations explicit program text safety guaranteed 
advantage implications 
regions secure system simplicity implementation leads smaller trusted computing base 
may possible formally verify region operations implemented correctly 
contrast formal analysis garbage collector acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities onerous task 
second region operations constant time trace structure heap programs suffer pauses associated conventional garbage collectors 
consequently regionbased memory management systems may practical alternative real time garbage collectors baker wilson 
second advantage gives programmers greater control memory 
region profiler birkedal programmers quickly identify memory regions causing performance problems applications 
allocation deallocation operations explicit program text programmers profiling data accurately relate run time behavior programs static representation 
words information ways regions run time straightforward examine program code identify memory intensive routines reason lifetimes data structures allocated 
trouble spots identified programmers concentrate optimization efforts small portion code 
importantly programming process type checker guarantees memory operations safe 
specifically prevents dereferencing pointer object deallocated programmers worry programs crashing due memory faults 
ensures memory region allocated program deallocated assuming program enter infinite loop 
order ensure regions safely tofte talpin language includes lexically scoped expression letregion delimits lifetime region region allocated control enters scope letregion construct deallocated control leaves scope 
programs may allocate values live regions notation values may region deallocated 
example letregion allocate region allocate value region lifetime function may access deallocate tofte talpin ensure deallocated values accessed type effects system 
informally expression uses value region type system expresses fact effect access 
effects occuring scope letregion construct masked 
specifically expression effects access set effects effect expression letregion simply 
effect entire program region access occured scope corresponding letregion construct 
words values region lifetime 
condition holds conclude program safe 
tofte talpin language efficient memory provided lifetimes values coincide lexical structure program 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett lifetimes deviate program structure style region memory management may force programs considerably memory necessary 
consider region annotated program fragments 
scope call site dead scope function fun dead return value argument function allocated scope function call 
suppose executed dies quickly 
value exhibits inverse behavior 
allocated inside returned function result 
lifetimes span lexical scopes live long scope 
consequently vanilla region inference perform setting 
best wrap function call pair letregion commands 
scope call site letregion letregion dead scope function fun dead return regions live longer need due inflexibility letregion construct 
regions allocated outside function call 
notice dead function call returns outer region deallocated inner region deallocated 
lexical scoping enforces stack allocated deallocated memory management discipline 
example better solution memory management problem separate region allocation newregion deallocation freeregion 
program takes approach 
principle lifetimes regions overlap memory regions reused 
acm transactions programming languages systems vol 
tbd 
tdb month year 
scope call site newregion dead freeregion typed memory management static capabilities scope function fun dead freeregion newregion return unfortunately write program tofte talpin language idea lexical scoping 
consequence language design program transformation alters program structure affect memory management 
devastating transformations tofte talpin type system continuation passing style cps transformation successive computation placed scope previous computations result regions deallocated entire computation completed 
example cps transformation prevents region deallocated code executed deallocated soon completed computation 
letregion code letregion code observation tofte talpin type system poor memory cases 
birkedal aiken proposed optimizations allow regions freed early 
optimizations safe simple proof type checker client check output code 
order construct safe efficient region language reexamine fundamental question program access value contributions solution problem provably safe efficient region memory management takes inspiration operating systems hydra wulf 
hydra solves access control problem associating unforgeable key capability object requiring user capability gain access object 
furthermore need arises hydra revokes capabilities preventing access protected objects 
define new strongly typed compiler intermediate language region memory management uses compile time notion capability ensure acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett region operations performed safely 
tofte talpin language lexical scoping plays part verification capability language cl 
type system threads static information form capabilities control flow path program 
order value region particular control flow point program capability region 
traditional capability systems type system keeps track capability copies carefully determine capability truly revoked 
traditional capability systems allow operating system revoke capabilities cooperation client code programs language give capabilities 
capabilities language purely static concept implementation requires run time overhead 
mechanism provides efficient way check safety explicit arbitrarily ordered region allocation deallocation instructions 
purely syntactic argument subject reduction progress lemmas style felleisen wright wright felleisen type system cl sound :10.1.1.44.5122
contrast tofte talpin formulate soundness system complicated greatest fixed point argument tofte talpin soundness aiken optimizations aiken depends argument 
part reason extra complexity tofte talpin simultaneously show region inference translates lambda calculus terms operationally equivalent region calculus terms stronger property prove 
system security main concern soundness critical property 
formal translation variant tofte talpin language calculus 
type safe tofte talpin program translation produces type safe cl program 
translation combined region inference algorithm tofte birkedal provides way compile source language programs type safe low level code secure extensible systems 
technical sections article derived earlier sixth symposium principles programming languages crary 
section presents syntax semantics cl formally motivates design decisions 
section type soundness theorem discuss interesting parts proof 
complete proof may appendix section demonstrates cl expressive tofte talpin language 
define semantics variant language give translation cl translation preserves type safety property appendix proves fact 
demonstrate expressiveness cl sketching couple optimizations possible restrictive language 
section informally explores applications capabilities 
section explains connections related 
section concludes 

capability language central technical contribution article cl statically typed intermediate language supports explicit allocation deallocation access memory regions 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities mentioned type system language propagates static information capabilities control flow path program 
elegant natural form language continuation passing style cps reynolds 
functions cl return values functions finish calling continuation function typically provided argument 
fact means transferring control functions cps means call return direct style simplifies tracking capabilities 
direct style formulation possible complications involved obscure central issues 
remainder assume familiarity cps 
syntax capability machine appears 
remainder section explain motivate main constructs typing rules language 
notation 
treat terms types differ names bound variables equivalent 
notation 
xn xn notation 
xn xn denote finite partial maps equivalent reordering elements 
subsections follow build sophisticated notion type equivalence top standard conventions 
finite partial map dom denotes domain map 
notation denotes new map maps identical denotes new map undefined identical notation denotes standard capture avoiding substitution sequence bindings form ranges dom sequence constructor variables 
occasionally notation 
cn refer simultaneous capture avoiding substitution 
cn 

dom 
notation indicate constructor context formed concatenating elements 
notation defined dom dom elements common 
preliminaries specify operational behavior cl call value allocation semantics morrisett morrisett harper allocation data memory explicit 
semantics specified deterministic rewriting system mapping machine states new machine states 
machine state consists pair memory term executed 
memory finite mapping region names regions region block memory stores collection individual objects 
regions created run time declaration newrgn extends memory new region binds name region binds handle handle region 
considered bound variables purposes alpha conversion 
new region occur current memory region name occur domain current memory occur stored value expression executed 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett kinds type rgn cap constructor vars constructors types int handle 

regions capabilities multiplicities con 
contexts value contexts region types 
memory types 
word values handle heap values fix 
xn 
vn arithmetic ops declarations iv newrgn freergn terms 
vn halt memory regions 
hn memories 
rn machine states fig 

capability machine syntax 
region names handles distinguished order maintain phase distinction compile time run time expressions 
region names significant compile time type checker identifies region object inhabits region name see 
region names type constructors run time significance may erased executable code 
contrast region handles hold run time data necessary manipulate regions 
addition accounting phase distinction separation region names handles allows refine contexts region handles needed 
handles needed allocating objects region increment region allocation pointer freeing region return region memory free storage list needed reading data region 
regions freed declaration freergn handle region freed 
objects large require heap allocation function closures tuples called heap values allocated declaration handle region allocated 
data read region ways functions read function call tuples read declaration binds data residing ith field object address operations may performed region question freed 
enforcing restriction purpose capability mechanism discussed section 
region maps locations heap values 
address pair region name location 
abbreviate address lookup address update 
course execution word sized values substituted value variables type acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities constructors constructor variables heap values substituted value variables 
executing declaration handle handle region allocated region say address substituted code 
programs refer values indirectly address 
term cl consists series declarations branch function call halt 
class declarations includes constructs discussed plus standard constructs binding variables values ranges integer arithmetic 
example program allocates region puts pair integers inside 
components pair projected tuple region deallocated 
program sums integers terminates 
newrgn allocate region allocate pair access region handle required freergn deallocate region halt terminate types 
types cl include type constructor variables int type region handles tuple function types 
region handle type region handle 
tuple type 
contains usual field tuples specifies tuples allocated region region name frequently region variable 
function type 
contains functions arguments types may called capability satisfied see subsection 
return type intended suggest fact cps functions invoke continuations returning direct style function 
suffix corresponding suffix tuple types indicates region function allocated 
functions may polymorphic types regions capabilities adding constructor context function type 
atr 
convenience types regions capabilities combined single syntactic class constructors distinguished kinds 
type constructor kind type region constructor kind rgn capability constructor kind cap 
metavariable range constructors metavariables constructors types regions capabilities respectively 
metavariables constructor variables kind rgn cap metavariable type variables generic constructor variables 
technically function types form 
empty type 
abbreviate 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett handle dom dom vi dom dom 
vn newrgn handle freergn handle dom 
cm 
vn fix 
xn 
cm 
dom 

vn 
xn fig 

capability operational semantics example polymorphic identity function allocated region continuation function may region may type type rgn appropriate function argument type continuation type called 
detailed explanation functions contained subsection discuss role capabilities 
specifies formed constructors constructor contexts 
main judgments assume constructor context formed 
judgment states formed constructor context second judgment states formed constructor kind 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities ctxt empty dom ctxt var cap cap dom ctxt sub type var type sub int type type int rgn handle type type handle type rgn 
type type cap rgn 
type rgn type name cap type rgn cap type single cap cap cap cap cap type bar type plus type tuple type arrow fig 

capability static semantics type context formation 
typing rules region types assign type location allocated region memory types assign region type region allocated memory 
necessary understand constructs preliminary development defer discussing describe static semantics machine formal detail see section 
capabilities central problem ensure statically region freed 
typing rules enforce system capabilities specify acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett operations permitted 
main typing judgment states memory type free constructor variables kinds free value variables types legal execute term provided capability held 
related typing judgment states capability held legal execute declaration results new constructor context new value context new capability capabilities indicate set regions presently valid access regions freed 
capabilities formed joining collection singleton capabilities provide access region capability variables provide access unspecified set regions 
capability joins written associative commutative idempotent section define equality capabilities formally see examples equivalent empty capability provides access regions denoted 
abbreviate capability rn 
rn 
order read field tuple region necessary hold capability access rule cap 
iv dom subgoal indicates capability held equivalent capability includes 
similar rule allocate object region 
type heap value reflects region allocated heap value typing judgment second subgoal provided region 
cap handle functions 
functions defined form fix 
xn dom stands function may appear free body specifies function constructor arguments function capability precondition 
empty appear free function body abbreviate fix form 
xn order call function residing region necessary hold capability access hold capability equivalent function acm transactions programming languages systems vol 
tbd 
tdb month year 
capability precondition typed memory management static capabilities cap cap 
vi 
vn body function may assume function capability precondition satisfied indicated capability premise rule 
xn 
xn xi dom expected annotation indicates closure value resides region resultant function type 
extend required capability function quantified capability variable similar row variable 
variable may instantiated capabilities leftover satisfying required capability 
consequently function may variety contexts 
example functions type cap 
may called capability extends 
source languages standard ml milner polymorphism normally restricted second class status polymorphic functions stored data structures passed arguments functions languages support type inference unannotated programs 
typed intermediate language cl unnecessary place restrictions polymorphic functions explicit type annotations type checking class polymorphism straightforward 
additional expressiveness class polymorphism necessary function say allocates new region returns result 
case continuation polymorphic respect returned region leading type cap 
rgn res similar scenarios main motivations choosing continuation passing style language 
direct style calculus define new syntax allow functions return static type region capability information calling contexts 
similarly context statement require special annotations compute join capability information branches 
polymorphic continuations provide uniform solution problems 
function continuation polymorphic type constructor arguments may instantiated time leading partially applied polymorphic functions form 
mentioned section type constructors may rule specializes full rule fix case function polymorphic recursive 
type res pair region containing actual function result handle region continuation deallocate 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett erased code executed 
consequently partial application treated class value typing rule 

common case apply multiple type arguments 
abbreviate multiple type applications cn 
cn 
indicated rule function call function fully applied called 
allocation deallocation 
delicate issue typing region allocation deallocation 
intuitively typing rules newrgn freergn declarations add remove capabilities appropriate region 
naive typing rules newrgn rgn handle wrong handle freergn wrong able rule allocation naive rule freeing regions fundamentally flawed 
example consider function fix rgn rgn handle int 
freergn function formed naive typing rule function begins capability removed freergn declaration leaving 
tuple allocated projection legal 
code operationally incorrect instantiated region case declaration frees second attempts read problem familiar 
free region safely necessary delete copies capability 
instantiating region variables create aliases making impossible tell inspection copies exist 
alias control desire system alias control easily enforced type system expensive complex program analyses 
possibility linear type system girard wadler 
linear type system aliasing trivially controlled region name consume name ensuring 
linear type system naive rules allocating deallocating regions sound 
unfortunately linear type system restrictive permit useful programs 
example suppose type rgn rgn int int 
suppose integer tuples allocated region called arguments require acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities instantiating region 
generally type function takes arguments allocated region 
approaches syntactic control interference reynolds permissive linear type system restrictive purposes impossible instantiate multiple arguments region 
uniqueness 
approach trying prevent aliasing type system track aliasing 
precisely track non aliasing uniqueness 
tagging regions capabilities multiplicities 
form capability access region understood heretofore 
second form permits accessing region adds additional information unique represents different region region appearing capability formed 
example capability indicates permissible access indicates represent distinct regions 
guarantees appear capability formed capability just access free may type region deallocation rule handle cap freergn allocation region adds new capability unique newrgn rgn handle dom dom main tasks type system ensure uniqueness information properly maintained unique capability appears twice current capability freergn rule guarantee requires system unsound 
immediately initial allocation region clear unique capability region appear twice typing rule newrgn adds single unique capability context 
point forward careful choice axioms capability equality ensure subsequent instructions duplicate unique capabilities 
particular capabilities considered equivalent capabilities 
generally prove equation cap contains unique capabilities 
example current capability contains copy checking freergn command equation cap appears premise freergn rule duplicate 
certain contains privileges deallocated region unique capabilities say appear appear exactly acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett equivalent say duplicatable 
note capability variables stand capability including ones 
occasionally prevents typing desired programs provide stripping operator replaces multiplicities multiplicities 
example 
capability capability duplicatable 
programs need unknown duplicatable capability may stripped variable 
see section stripping operator essential translation tofte talpin region language cl complete rules equivalence capabilities constructors appear 
notice single rule eq flag equates duplicatable capability barred capability 
consequently form redundant presence bar operator 
notation pleasing foil notation flags give convenient way distinguish regions appear regions potentially appear times single capability 

capabilities provide privileges 
say write 
complete system various rules section modified account 
example function call rule 
vi 
vn suppose type rgn rgn atr 
hold capability may call instantiating 
relation may call hold instantiating 
contains rules 
reading rules remember cap 
fact derive judgment cap discussed informally cap sub bar cap eq flag cap sub eq cap sub trans relation accounts forgetting uniqueness information 
intuitively second source generated forgetting entire capability 
example provide privileges reasonable suppose 
construct sound cl incorporating axiom omit doing allows specify memory management obligations prove stronger property space usage 
notice omitting axiom give flexibility may write function acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities ctxt eq empty dom ctxt eq kind cap eq reflex eq symm dom ctxt eq bound eq trans cap cap eq congruence plus cap cap cap eq congruence bar cap cap eq cap cap cap eq comm ci cap cap eq assoc cap cap eq dup cap rgn cap cap cap eq bar eq flag eq bar idem cap cap cap eq distrib fig 

capability static semantics equality 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett cap sub eq sub trans sub congruence plus sub congruence bar sub var cap sub bar fig 

capability static semantics equality relations 
called extra capabilities capability variable discussed section 
omitting axiom type system may formally specify responsibility freeing region 
failure follow informal conventions common source bugs languages manual memory management 
type system rules bugs 
example consider type rgn cap handle system 
consequently function type return call continuation type take action satisfy capability free 
general type system prevents region leaks programs deallocate memory regions terminate theorem 
operating system clean program halts 
typing rule halt states capabilities may held capabilities may forgotten means regions freed 
int cap halt type system certainly prevent forms memory leaks 
times course evaluation may dead regions deallocated dead objects live regions 
type system provide degree static error checking possibility encode certain memory management protocols 
bounded quantification 
system point sound sufficient compiling real source languages 
need able recover uniqueness region name duplicated 
see suppose hold acm transactions programming languages systems vol 
tbd 
tdb month year 
capability type typed memory management static capabilities rgn rgn 

able instantiate may free calls continuation final argument 
unfortunately continuation possesses capability capability necessary free help strengthen capability continuation example may call 
may recover uniqueness information quantifying capability variable 
suppose hold capability type rgn rgn cap 

may instantiate continuation possess capability allowing free unfortunately body function longer capability access type draws connection 
solve problem bounded quantification relate 
suppose type rgn rgn 

hold capability may call instantiating instantiating 
instantiation permissible 
continuation possess capability allowing free body capability access 
bounded quantification solves problem revealing information capability requiring function parametric 
function calls continuation regain stronger capability free capability temporarily hidden order duplicate generally bounded quantification allows hide privileges calling function regain privileges continuation 
support statically checkable attenuation amplification capabilities 
static semantics far 
parametric polymorphism bounded parametric polymorphism notions uniqueness aliasing provide flexible language expressing lifetimes regions 
figures formally summarize rules type checking instructions values depend concepts 
explained majority rules previous sections rules specified obvious ones integers type int 
notice form judgment heap values slightly different judgments instructions small values judgment states memory type free constructor variables kinds bounds free value variables types heap value resides region type 
static semantics machine described type constructor language cl typing rules main term level constructs 
fact previous section contains acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett type 
xn 

xn dom fix 
xn vi rgn 
vn 
type var int int fix tuple eq 



type eq fig 

capability static semantics heap word values 
type sub information programmers compilers require write type safe programs cl order prove type soundness result style wright felleisen wright felleisen able type check programs step evaluation :10.1.1.44.5122
section give static semantics run time values normally manipulated programmers necessary prove soundness result 
formal definition semantics may appear quite complex number different judgment forms 
forms follow naturally development previous sections allocation semantics morrisett 
extra complexity definition language pay come prove type soundness main invariants expressed directly typing rules proof follows straightforward inductions rules 
specifies rules typing memory straightforward 
judgments specify memory types region types formed 
elements sequence 
xn different write 
xn distinct 
memory region types regions memory finite partial maps elements domain map distinct 
typing judgments memory region types side conditions acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities int int int handle 
iv newrgn rgn handle dom val handle cap freergn int 
vi 
vn int cap halt dom prim dom dom proj dom newrgn dom app halt freergn fig 

capability static semantics declarations expressions 
effect 
judgment states memory described judgment states region name described 
informally judgments ensure addresses type memory described contains value address type 
judgment sat called satisfiability judgment formalizes connection static capability run time state memory 
clearly current capability contain regions memory lead runtime error 
equally important memory contain regions capability regions freed 
consequently satisfiability ensures time acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett execution machine capability equal occurs exactly current memory 
furthermore virtue fact cap unique regions may appear properties essential ensure regions safely 
contains rules small values appear run time addresses region handles 
rules typing address quite unusual crucial type soundness proof 
rule addr lifetime region region memory domain memory type 
rule addr applies type 
consider point computation region deallocated 
region longer memory addresses may appear embedded tuples closures allocated regions type 
region appear memory type type system flexibility give function type rule tuple type rule addr tuple 
glance rules appear lead unsoundness address dangling pointer may valid type 
fortunately capabilities prevent going wrong 
satisfiability judgment ensures programs possess capabilities regions appear memory explained earlier programs access regions capabilities 
consequently dangling pointer may valid tuple function type capabilities prevent accessed 
components necessary define formed machine state 
state formed memory described formed heap type exists capability satisfies heap type expression formed respect formal properties sat program type soundness 
important property cl type soundness 
type soundness states program enter stuck state execution 
state stuck exist halt example state tries project value tuple appear memory stuck 
theorem type soundness 
stuck 
previous sections article explained type memory relate memory typing static capabilities collection capabilities rules typing expressions prevent unsafe accesses store 
invariants main elements formal proof soundness 
details fill 
proof style wright felleisen wright felleisen uses standard type preservation acm transactions programming languages systems vol :10.1.1.44.5122
tbd 
tdb month year 
typed memory management static capabilities 
distinct region type 

distinct memory type 
hi 
hn 

distinct region sat ri 
rn 
memory 
distinct 
cap 
sat 
distinct sat fig 

capability static semantics memory 

type 

type 
addr dom addr tuple handle handle handle dom addr arrow fig 

capability static semantics run time values 
progress lemmas 
progress states typed states stuck preservation states evaluation steps preserve typedness 
lemma type preservation 
lemma progress 
exists halt length tedium proofs lemmas moved proof soundness appendix acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett complete collection 
second important property language welltyped terminating programs return memory resources system halt 
call property complete collection 
theorem complete collection 
diverges halt 
subject reduction progress terminating programs formed machine states halt 
typing rule halt expression requires capability empty 
fact infer memory contains regions 
appendix contains formal proof theorem 
decidability 
third property interest typed languages 
strongly believe cl decidable studied property formal detail 
concerned decidability type soundness expressiveness language type checking providing additional annotations direct reconstruction full typing derivation 
user level programming language excessive type annotations hinder programmer productivity compilers higher tolerance handling tedious details 
fact necula lee necula necula lee proof carrying code suggest compilers produce full proofs type safety encoded order predicate logic 
argue proof checking opposed proof inference engineered quite fast trusted computing base proof checker somewhat smaller sophisticated type reconstruction algorithm theorem prover 
course way compiler obtain full typing derivation proof carrying code methodology 
section describe translation variant tofte talpin regionbased language cl proof translation produces typed code constructive proof builds typing derivation output code possible fully annotate subsequently verify compiler output 

regions capabilities part section develops high level type effect system regions tofte talpin 
second part section defines formal translation tofte talpin language cl composing translation tofte birkedal region inference technology tofte birkedal may obtain type preserving compiler front 
region calculus preliminaries 
source language compiler region calculus shown 
language explicitly typed variant calculus tofte talpin 
cl contains integers tuples functions 
cl allocation deallocation regions combined single construct letregion construct allocates new region places handle region term variable 
executes expression region deallocated 
discussed acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities kinds type rgn eff constructor variables constructor contexts type schemes constructors int handle 
term variables term contexts terms 
en en 
cn letregion fig 

region syntax 
lexically scoped construct flexible separate newrgn freergn constructs provided cl main goal section show compile letregion expressions lower level primitives 
original tofte talpin calculus region language prenex predicative polymorphism 
term allocates closure polytype 
closure polymorphic type context may contain ordinary type variables region variables effect variables explained 
closure allocated region expression evaluates region handle expression describes body function 
previous region type systems treat type constructors including region constructors compile time objects 
term 
cn denotes type application runtime effect 
type checking type scheme polymorphic function instantiated types 
cn obtain resultant type expression dynamic semantics program shown depend types 
types may erased program run affecting computation 
cl data structures required allocate deallocate regions treated ordinary values type handle 
types effects 
main interest type constructor portion region language presence effects 
effects capabilities control program access regions particular prevent access regions deallocated 
intuitively effect term set regions term accesses 
formally effect empty effect effect variable singleton set union effects 
operator associative commutative idempotent unit union operator 
write eff equality effects abbreviation eff effect 
functions latent effects incurred function called body executed 
effect appears arrow types tofte talpin require arrow type annotated arrow effect con acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett type dom type eff rgn 
int type type rgn 
type eff rgn eff fig 

region type formation 
eff eff eff eff rgn handle type rgn eff type 
type eff eff eff eff eff eff eff fig 

effect equality subset 
eff eff eff specifies set regions function type may access invoked 
rules type constructor formation may 
effect equality subset relations summarized formally 
equality types syntactic renaming bound variables modulo equality effects 
static semantics 
static semantics terms judgment form track effects produced expression 
strained form 
type variable name effect plays role inference system 
interested type checking type inference need name effects arrows 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities int int int int ei en handle 
en en 

int handle 
ci 
cn 
cn 
rgn handle ftv dom letregion dom type fig 

region term static semantics 
dom judgment states type context value context term type produces effect 
example rule projection states expression type 
atr produces effect projection produces effect 
projection operation reads region subexpression may read write regions 
resulting effect union 
rules involving functions complex 
consider function call 
assume generates effect evaluates closure type produces effect type 
expressions evaluated code function projected closure resides region function produces effect effect call union 
contrast value application rule rule type application produces effect remember types erased expression executed 
examine rule letrec term 
components effect produced expression effect evaluating handle expression acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett letregion letregion letrec count handle int count count count letrec region scope deallocate region scope deallocate count 
handle int unit fig 

count region calculus 
effect writing closure data structure region effect subsequent expression 
checking types match properly sure effect produced body function subset declared effect 
technically rule functions specifies effect body exactly equals declared effect 
body produces lesser effect possible rule subsumption increase effect body equals declared effect 
examine rule letregion construct 
notation denote effect occurences replaced 
rule discharges effect effect produced subexpression intuitively letregion construct discharges effects constructs pass effect information subexpressions enclosing expressions access region outside scope letregion detected type checker reject expression 
shows example program function count counts zero 
order interesting allocation behavior integers involved count allocated cell 
count function stored region takes arguments handle region integer allocated region 
nonzero count decrements storing result recurses 
function effects read resulting recursive call read write effect resulting line read line store 
give function count effect 
code allocates regions stores closure count stores integer calls count deallocates 
translation order formal connection region calculi corroborate claims region inference techniques developped tofte front capability compiler defined type preserving translation region calculus previous section cl appendix contains proof formed source term acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities type type rgn rgn eff cap 

int int 

rgn cap handle handle 
xn 
xn fig 

region capability kind type translation 
translated formed target term 
kind type translation 
translation continuation passing style transformation simultaneously transform effects capabilities 
kind type transformation 
kind translation trivial effects capabilities kinds unchanged 
translation types equally simple 
translation base types identity general translate types recursively translate components recombine corresponding capability constructor 
tuples mapped tuples handles mapped handles translation function types involved 
recall usual arrow type transformed accepts translated continuation translation region arrow types structure complications arise transform effects capabilities 
complication involves finding region continuation closure 
solve problem allocating new region hold continuation translated function abstracts region 
second complication effect function may mention subset regions live call site 
resulting cl function thread capability describing live regions context function called body function continuation 
accomplish task abstracting additional capability variable function context sensitive 
mechanism thread capability calling context function continuation 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett third complication type translation ensure equal types region calculus translated equal types cl part obligation satisfied trivially equality relation region types corresponding cl analogues simple syntactic equality conversion bound variables 
equality relation effects set equality equality relation arbitrary capabilities set equality necessarily idempotent 
fortunately equality duplicatable capabilities exactly set equality 
type translation carefully translates arrow effects duplicatable capabilities 
insights naturally lead translate region function type form cl function type rgn cap cont notice capability translated function subtype 
capability gives translated function access regions requires regions regions accessed source language function region containing continuation contains regions calling context threaded call continuation 
notice capability appears type duplicatable prove equal types translated equal types 
explained section continuation type cont bounded quantification allows continuation recover uniqueness information necessary deallocate regions function 
definitions straightforward prove essential properties types formedness equality substitution preserved translation 
lemmas proven simple induction formedness equality derivation 
lemma formedness preservation 
lemma equality preservation 
eff cap eff cap lemma substitution preservation 
type 
term translation 
heart term translation continuation passing style fischer plotkin transformation 
variations transformation danvy filinski sabry felleisen harper lillibridge danvy produce efficient code lead simpler correctness proofs 
chosen simple translation straightforward prove type preserving may focus details relevant region memory management 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities informal description basic mechanics cps term translation ignoring details relevant regions capabilities 
main arguments translation type checking context source language term target language continuation source term formed context type continuation translation produce formed target term 
operationally target term computes producing value result calls continuation argument 
source term value integer variable translation simply function call 
hand assuming left right evaluation order source term represents computation say computation cps translation arranges compute producing value compute producing value allocate pair pass resulting pointer continuation write translation follows 


translation subcomponent requires continuation continuation contains code subsequent subcomponents 
primitive operation op applied resulting values result passed compilation arithmetic operations projections form 
couple details notice translation 
taken liberty annotating expressions types necessary 
second translation introduces new variables add variables translated types context 
decision influence behavior translation facilitates statement proof type correctness theorem 
translation function application begins way operations translate passing resulting value continuation contains translation 
continuation contains function application 
user defined cps functions primitive operations return continuation passed directly translated function 


expressions declare functions translated result expects extra continuation argument xcont calls continuation return 
xcont xcont cont xcont acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett type function continuation cont 
type function cont 
simple cps translation provides basic structure translation region language cl previous researchers observed translation introduces unnecessary administrative redexes 
example scheme far translation simple pair respect continuation simpler term 
concerned time required execute extra function applications concerned space required additional function closures 
region translation directly naive translation forced allocate additional regions expressions 
previous avoided problems defining translation terms level type system passing translation meta level continuations target level continuations 
interested space properties translation simpler solution 
allocating continuation closures expression bind result computation pass continuation 
solution avoids additional allocation lead complexities level type system 
translation pair respect continuation notation denotes static translation time run time application continuation value 
continuation represented target language expression intuitively application simply 
continuation pair variable continuation parameter body 
representation natural define translation occurs compile time 
notation define cps translation pairs general follows 
region expressions capability language 
basic cps transformation hand ready investigate formal details translation region language expressions cl expressions 
discussed translation form 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities 
cn 
cn int 
xn en xn xn en xn 
xn xn ix int int letregion newrgn rgn handle freergn fig 

region capability term translation 
context 
components region type context region value context 
third component translation environment 
environment contains cl type context cl value context pair capabilities context describes kinds new type variables introduced translation capability type variables possibly bounds 
value context describes types new value variables introduced translation 
intuitively capability represents current capability point translation contains uniqueness information necessary deallocating capabilities single capability variable 
capability bound contains regions accessed current function single capability variable see translation function declarations differences 
notation denote translation environment acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett fix rgn cap xcont cont 
xcont atr handle cont rgn cap handle xcont cont newrgn fcont fix fcont freergn fcont fig 

region capability term translation functions 
formal translation figures 
translation assumption variables fresh introduce variable term continuation fresh conflict variables source term type checking context continuation 
invariant guiding transformation main parts region language term formed type value contexts 
formally 
continuation formed current context 
formally 
current capability contains superset regions mentioned effect formally 
case simplified cps translation translation values simplest 
example translate variable integer simply apply continuation respectively 
type application expression 
cn value take interpretation types erased run time 
apply continuation directly 
cn 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities translation tuples follows informal description closely 
translate computations 
en tuple sequence bind resulting values 
xn 
translated expressions allocate tuple 
xn region handle xn 
order tuple allocation operation safe ensure region say corresponds region handle xn live 
words able prove current capability contains capability 
invariants provide means deduce fact informal reasoning 
invariant states expression 
en en formed effect 
inspection region language typing rule tuples reveals contains effect 
second part invariant states capability contains capabilities regions appear effect including course 
part invariant know current capability contains 
consequently tuple allocation operation safe 
similar reasoning straightforward verify informally translation arithmetic operations projections statements fail type check lack sufficient capabilities 
translation statement duplicated continuation inside branches 
main concern proof type preservation opted simplicity translation 
practice duplication lead considerable code growth cases implementation want bind continuation variable entering statement 
translation term letregion difficult letregion translated newrgn declaration followed translation inner expression freergn declaration deallocate 
simple reasoning allows check stated invariants hold transformation 
particular translation inner expression reflects fact new region just allocated translation environment step contains capabilities 
know may conclude invariant part satisfied 
inspection typing rule letregion reveals effect effect entire letregion expression 
contains know contains capabilities regions including course 
satisfy invariant part translation recall region type system ensures region inside continuation translation safely free region proceed invariant specified expected capability exactly capability context freeing region 
complex part translation involves functions 
fortunately type translation explained specifies main invariants translation functions terms follows directly specification 
specifically extend function type context region continuation closure capability hiding extra regions calling context acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett current capability bounded 
add value argument translated function continuation xcont 
simple verify translated function translated function type 
body function translated assumptions 
continuation part translation invoke function new argument xcont 
examine translation function application 
translation allocates new region continuation closure 
translation allocates continuation 
continuation defined expect capability 
maximum capability point computation permits continuation deallocate region containing closure 
just conventional stack language implementation allocates stack frame function call deallocates stack frame function return cps region implementation allocates continuation closure function call deallocates continuation closure return 
allocating continuation translation continues translation actual function application 
translated function value type rgn cap calling function code instantiate variables properly 
code naturally instantiates region just allocated 
point program capability represents current capability upper bound 
code instantiates legal provided prove 
invariant states easy verify fact 
need verify term arguments continuation fcont types expected translated function easily checked 
properties translation 
proven translation preserves types 
theorem cps type preservation 
int halt fresh empty proof proceeds induction typing derivation source language term invariants forming induction hypothesis 
appendix contains formal proof representative cases 
prove translation correct preserves space program tackled problems 
minamide proven standard cps translation preserves maximum amount reachable space constant factor 
defines semantics simply typed lambda calculus refines blelloch greiner 
augment semantics sort acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities space profiling information may able prove similar result translation 
informal inspection translation indicates resultant term allocates data structures source term exception continuation closure require return function call intuitively closure corresponds stack space required save local variables function call 
formal investigation space properties translation scope 
example 
program translation count function previous section 
simplifications output formal translation improve readability program 
particular optimized away administrative redexes performed optimization recursive call count function 
writing capabilities equivalent form 
program begins allocating regions newrgn declaration puts closure count 
count function requires capability capability cont needed access argument continuation passes capability continuation type check body count function verify possess capabilities necessary data accesses legal 
comments code indicate checks occur 
calling count pass continuation cont 
continuation requires capability order free regions 
application site count capability instantiated stronger capability needed continuation 
example 
context count function uses regions currently allocated capability variable redundant 
code instantiates call site count exactly regions cont appear bound general hide left capability 
example allocated fourth region need instantiate capability corresponding changes continuation 
hide capability fourth region count preserve call deallocated continuation count hiding left capability newrgn newrgn newrgn newrgn count 
capability held cont 
count cont acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett newrgn newrgn capability held count fix count rgn cont rgn cap cont handle int cont capability held cont ok cont ok count cont ok cont ok newrgn capability held cont capability held freergn freergn unique freergn unique halt unique count cont fig 

function count 
power bounded quantification comes play function called regions may may 
example original code rewritten cont share region changing function count way count cont sharing newrgn newrgn count 
capability held cont 
count cont example cont instantiated instantiated capability required cont 
count proceeds exactly acm transactions programming languages systems vol 
tbd 
tdb month year 
newrgn newrgn capability held count fix count rgn cont rgn typed memory management static capabilities cont handle int cont capability held ok freergn unique capability held cont ok newrgn capability held ok count cont ok newrgn cont capability held freergn freergn unique halt count unique cont fig 

function count efficient memory usage 
cont optimization 
examples count tail recursive allocate new cell time loop deallocate cells count complete 
contains live values current argument safe reduce program space usage deallocating argument region time loop shown 
note optimization possible region lifetimes lexically scoped 
order deallocate argument revised count requires unique capability argument region 
note program rewritten cont shared region lead run time error deallocated early program longer typecheck order satisfy acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett bound count instantiated capability containing cont region scenario count required capability contain occurrences instantiation 
capabilities required unique union satisfied current capability 
instance instantiated function call typecheck current capability 
hand program rewritten count cont share region fail run time typecheck 
case legal instantiate possible prove capability held point function call expected capability 

discussion believe general framework capability system quite robust 
ways extend language number directions research 
language extensions article concentrated cl implement safe region memory management changes believe capability apparatus may variety settings 
potential application involves reducing overhead communication user kernel address space boundary traditional operating systems 
typically systems data user space kernel kernel copy data ensure integrity preserved 
user process hands unique capability region kernel kernel copy region data capability user longer read modify contents region 
handing user capability kernel ensure kernel exclusive access data governed capability 
generalize idea capabilities ensure mutually exclusive access shared mutable data multithreaded environment viewing locks analogous regions 
associate piece sensitive data lock statically check client data obtains corresponding lock associated capability attempting access 
code releases lock type system revoke capability data just revokes capability region freed 
flanagan abadi investigated idea context highlevel lexically scoped language 
just compiled tofte talpin high level region language cl conjecture compile flanagan abadi locking language variant cl locking primitives allocation primitives 
third application capabilities control reason aliasing basis region basis 
smith walker morrisett smith walker morrisett investigated idea associating different capability individual object including type object capability 
code possesses unique capability object may deallocate object chooses may explicitly reuse space object store value different type 
new design acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities may viewed extension conventional linear type systems girard lafont wadler abramsky admits aliasing allows safe deallocation objects 
techniques extend typed assembly language implementation morrisett operations explicit verifiably safe memory management 
general system wishes restrict access data statically ensure certain sequence operations performed may consider capabilities 
fact walker shown combination capabilities simple logic sufficiently powerful encode safety property alpern schneider schneider 
related formalisms reasoning computational effects programming languages including type effects systems gifford lucassen lucassen jouvelot gifford tofte talpin monads moggi peyton jones wadler launchbury peyton jones filinski linear types girard lafont wadler abramsky capabilities 
researchers actively investigating relationships different areas picture fully understood 
eager continue line research explore formal links system 
translation tofte talpin region calculus cl reveals relationship effects capabilities quite close 
necessary prerequisite system type inference performed programmer compiler research effects systems concentrated difficult task 
focus inference effect systems usually formulated bottom synthesis effects 
may viewed producing verifiable evidence correctness inference 
effect systems typically bottom specifying effects occur take top approach specifying capabilities effects permitted occur 
tofte talpin effect system capabilities sensitive control flow 
constructing effect expression union effects subexpressions losing information order evaluation verify programs safe checking instruction capability produced previous instructions verify instructions follow safe 
connection drawn capabilities monadic type systems 
relating effects monads viewed effectful functions pure functions return state transformers 
called ex post view effect takes place function execution 
contrast take ex ante view capability perform relevant effect satisfied function execution 
considerable similarity views just monads ensure store single threaded computation typing rules thread capability summarizes aspects store execution path program 
closest relationship occurs linear type systems capabilities 
inspection axioms capability equality reveals acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett similar structural rules linear type systems 
particular linear assumptions unique capabilities allow contraction weakening rules nonlinear assumptions duplicatable capabilities allow contraction weakening rules 
essential difference formalisms capability access object say separated type object say int 
level indirection possible allow aliasing verify deallocation safe 
significant amount prior research specific topic theory implementation region memory management 
respect implementation birkedal describe optimizations basic region allocation scheme ml kit regions improve space efficiency 
observations functions different contexts context live object remains region function call second context may live objects remaining region call 
order avoid code duplication ensure efficient space usage call site passes information called function run time 
information function may dynamic decisions region deallocation 
type system powerful encode storage mode polymorphic functions 
believe dynamic tests may viewed form intensional type analysis harper morrisett crary augment cl variant harper morrisett typecase mechanism may able verify results optimizations 
aiken studied optimize original tofte talpin region framework 
cl separate region allocation region deallocation 
technique verifying results optimizations safe 
conjecture soundness proof aiken analyses analysis produce typing annotations verification take place cl gay aiken developed extensions gives programmers complete control region allocation deallocation 
counting prevent programmers accidentally accessing deallocated regions 
hawblitzel von eicken hawblitzel von eicken notion region language passport support sharing revocation multiple protection domains 
groups run time checking ensure safety interesting investigate hybrid systems combine features static type system dynamic systems 
tofte talpin studied soundness region type systems length 
greatest fixed point construction coinductive argument prove correctness region inference scheme 
contrast formulation cl allows syntactic proof techniques popularized wright felleisen 
despite high level differences proof formulations linear logic admit weakening rule allows assumption completely forgotten 
explained earlier allow complete forgetting capabilities leads space leaks 
admit restrictive weakening rule allows capability forgotten 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities techniques illuminating similarities details 
notably tofte talpin proof involves notion consistency relates source target values region inference translation 
consistency defined respect effect rest computation 
informally consistency conditions states source value consistent target value region respect effect appear 
effect capability rest computation deallocate region rest computation distinguish dangling pointer value source language 
tofte talpin proof effect rest computation plays role similar capability 
able give syntactic proof soundness language continuations capabilities explicit framework tofte talpin introduce idea metalevel construction proof 

new strongly typed language admits operations explicit allocation deallocation data structures 
furthermore language expressive serve target region inference admits relatively straightforward proof soundness 
believe notion capabilities support statically checkable attenuation amplification revocation effective new tool language designers 
appendix soundness capability language notation capability derived form expository purposes article 
equivalent 
sake simplicity proof operates new language include capabilities form 
syntax capabilities form new syntax unique capabilities 
way form duplicatable capability bar operator multiplicity annotations unnecessary 
rule eq flag derived rule 
abbreviation replaced definition clear rule simply special case reflexivity need system 
convenient continue abbreviation emphasize fact capability unique 
continue metavariable range 
notational conventions abbreviate abbreviate cn cn 


notation denote fact subcomponent acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett overview proof broken series lemmas proven induction typing derivations induction syntax language 
proof proof type soundness complete collection 
supporting lemmas grouped follows lemmas describe extensions type contexts exchanges elements type context permissible 
lemmas state constructors involved equality subtyping judgements formed free variables formed constructors bound type context 
definitions lemmas describe capabilities equal capabilities subtypes 
provide higher level abstraction rules equality subtyping frequently rest proof 
lemmas substitution lemmas types values respectively 
lemma states formed small values heap values declarations formed types 
lemmas canonical forms lemmas 
type lemmas describe shape memory values 
lemmas describe conditions add labels regions memory type preserve typing 
lemma states satisfiability preserved equality subtyping empty context 
lemma states satisfiability preserved region corresponding unique capability removed memory current capability 
lemmas preservation progress lemmas respectively 
directly proof type soundness 
lemma 
dom dom 
proof 
induction derivation 
lemma type context exchange 
dom dom 
proof 
induction derivations 
rule type var know domains disjoint 
consequently 
lemma type context extension 
dom dom acm transactions programming languages systems vol 
tbd 
tdb month year 

typed memory management static capabilities proof 
induction derivation 
cases follow directly inductive hypothesis 
rules ctxt sub type arrow require type context exchange 
lemma 
ftv dom 
proof 
induction derivation 
lemma equality regularity 

proof 
induction derivation 
lemma subtyping regularity 

proof 
induction derivation 
rule sub var show induction derivation cap 
definition 
atomic capability type variable kind cap singleton capability barred capability 
meta variable ranges atomic capabilities 
definition 
set elements appear 
xn notation set elements 
xn lemma equality 
cap cap atomic capabilities 

ai ai ai ai ai ai cap 
cap 
permutation 

cap 
subsequence 
duplicate barred elements removed 
cap sets equal 
cap cap 
cap cap 
proof 
part follows induction derivation cap 
case type immediate 
case type single follows application equality rules eq 
case type plus intricate 
inductive hypothesis gives cap cap 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett induction rules eq eq assoc eq trans cap 
equality congruence eq trans cap 
induction eq assoc eq symm eq trans cap 
case cap ih 
congruence cap 
induction cap 
ai ai atomic element ai barred eq bar idem rule show ai ai cap 
case induction congruence rules done 
part follows induction eq assoc eq comm transitivity symmetry equality 
part corollary part 
part follows induction number barred duplicates uses part transitivity symmetry eq dup rules 
part follows induction equality judgment 
part may proven follows cap parts 
cap parts 
parts congruence equality aj cap cap jm aji contain duplicates ordered ji canonical ordering 
aji ji order 
constructors syntactically equal definitionally equal 
part follows induction typing derivation 
definition 
fora capability unique exist capability duplicatable lemma 
cap duplicatable cap 
proof 
induction typing derivation 
lemma 
cap unique cap 
proof 
induction typing derivation 
lemma capability equality cardinality preservation 
cap cap unique duplicatable iff unique duplicatable 
number unique occurences 
proof 
induction derivation 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities lemma capability subtyping cardinality preservation 
cap region names iff 
region names unique unique 
proof 
induction derivation capability equality cardinality preservation 
note subtyping regularity lemma type variables appear consequently rule sub var appears derivation 
lemma type substitution 

cn 
cn 
cn 
cn 
cn 

bn 
bi ci 
bi ci ci ci cap 
cn 
cn 
cn 
cn 
cn 
cn 
cn 
cn 
cn 
cn 
cn 
cn 
cn 
proof 
induction derivations 
cases follow directly ih 
part prove lemma rules 
cap case result type context extension 
second case assume ci ci cap 
subtyping regularity tells ci cap 
type context extension know ci cap 
part lemma follows rule cap type context extension 
part case apply induction hypothesis inspection rules declarations show general acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett lemma value substitution 

xn vi 
vn 
xn 
vn 
xn 
vn 
xn 
vn 
xn 
proof 
induction typing derivations 
part case induction hypothesis inspection typing rules declarations reveals general lemma term judgment regularity 
cap rgn type type cap 
proof 
induction typing derivations 
cases follow directly induction hypothesis equality regularity subtyping regularity 
part consider case type application 

induction hypothesis inspection typing rules arrow types deduce judgment form cap type 
type type substitution may deduce 
second type application rule follows similarly 
lemma canonical memory forms 

rn 
dom 
ri 
vm vj 
ri fix 
xn 

xn acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities proof 
inspection typing judgments memory regions heap values 
lemma canonical memory forms ii 

proof 
induction typing derivations 
lemma canonical forms 
int handle handle 

cm fix 
xn 
bm bi ci bi ci ci ci cap 

cm 
cm 
cm type 

xn 

vn vi 
proof 
part follow inspection typing rules word values 
part follows induction derivation canonical memory forms inspection typing rules word values type application rules 
case trivial 
case trivial 
canonical memory forms 
trivial 
trivial 
inspection judgment 
case ca cb 
ca cap cb 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett term judgment regularity lemma 
inductive hypothesis follows 
cn fix 
xn 
bm bi ci bi ci ci ci cap 
ca 
cm ca cb 
cm ca 
cm type ca ca 

xn 

cn ih 
result follows trivially 
assume 
ih 
ih typing judgement states ca cap 
ih type substitution 
ih 
case similar 
part follows inspection typing rules word values 
notice rule rule tuples apply 
assuming trivial immediate follow canonical memory forms 
lemma memory type gc 

proof 
induction typing derivation 
cases follow directly ih rule case trivial assume canonical memory forms 


type 
type context extension type 
cases rules dom 
lemma memory type extension 
appear acm transactions programming languages systems vol 
tbd 
tdb month year 

typed memory management static capabilities proof 
induction typing derivation 
part rule 
type 
assumption result holds similarly analogous rule arrow types 
lemma region type extension 
dom dom sat sat 
proof 
induction typing derivation 
lemma 
cap cap cap 
subset 

proof 
lemma cap 
lemma 
ai unique duplicatable ai unique duplicatable 

implies 

lemma capability satisfiability preservation 
sat cap sat 
sat cap sat 
proof 
symmetry transitivity equality inspection sat derivation 
induction subtyping derivation 
case equality part 
case transitivity ih 
case apply context empty lemma capabilities contain free variables 
case assume 
cap 
sat 
distinct acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett 
rule eq congruence bar 
cap 
constructor equality rules 
cap 

sat case assume 
cap 
sat 
distinct 
equality regularity formed empty context 

lemma 
cap 


conclude 

lemma eliminate duplicates assume loss generality 
contain duplicates form 

assume anticipating contradiction appear 


appear appear ca 
contradict indicating assumption false 
may assume loss generality 
distinct 
conclude sat domain restricted 

analogous reasoning definitions yields sat 
inductive hypothesis sat 
inductive hypothesis sat 
inspection sat judgment know 
cap 

cap 

know 
eq congruence 

acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities 
know 



reasoning analogously steps deduce 

contains du region names aside multiplicity flag 

lemma parts may eliminate duplicate region names flag reorder choose 
set multiplicities 
know 


distinct 
cap 

cap 
distinct 

sat lemma 
sat sat 
proof 

assume sat 


know 

distinct 
cap 
appears 


equality lemma part 


cap 
transitivity equality equality lemma part 

cap 
sat 
lemma preservation 
proof 
proof proceeds cases structure case show form typing judgment inferred inspection typing rules refer case typing judgment 
give transition specified operational semantics 
facts derive result 
sat 
typing judgment value substitution 
sat acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett handle handle dom dom 

inspection heap value typing rules typing judgment 
typing judgment inspection memory typing rule 
sat region type extension 
typing rules word values 
value substitution 

iv 
iv sat iv iv 
vn iv vi typing judgment 
sat typing judgment 
vi canonical forms typing judgment 
vi value substitution typing judgment 
vi 
freergn sat handle freergn freergn freergn handle freergn 

memory type gc typing judgment 
sat typing judgment 
sat capability satisfiability preservation sat lemma acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities typing judgment memory type gc 

newrgn cap sat 
newrgn newrgn newrgn rgn handle operational rule rgn handle newrgn handle follows 
memory type extension typing judgment 
assumption operational semantics satisfy side condition sat judgment 
prove cap congruence rule equality 
consequently sat 
handle typing judgment application type value substitution memory type extension lemmas 
handle 
int sat 
typing judgment 

vn vi cap 
cap sat 
vn 
vn 
vn 
cm fix 
bm 
xn bi bi ci 
cm 
vn 

xn 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett typing judgment 
sat capability satisfiability preservation 
sat capability satisfiability preservation typing judgment 
dom 



typing judgment 

bm 
xn canonical forms 

cm 
cap transitivity equality canonical forms 
type value substitution 
lemma progress 
exists halt int 
proof 
proof proceeds cases structure heavy canonical forms lemma 
trivial 
handle sat handle directly typing judgment 
term judgment regularity lemma canonical forms handle 
capability satisfiability preservation sat dom 
inspection memory typing rules dom 

iv 
sat iv iv iv capability satisfiability preservation sat 
dom canonical forms 
vn typing judgment iv vi 
acm transactions programming languages systems vol 
tbd 
tdb month year 
newrgn trivial 
freergn sat typed memory management static capabilities handle cap freergn freergn freergn term judgment regularity lemma canonical forms handle 
capability satisfiability preservation sat 
dom inspection memory typing rules dom 
consequently freergn 
int canonical forms integer 
operational rules applies 

vn vi cap 
cap sat 
vn 
vn subtyping regularity lemma 
capability satisfiability preservation sat dom 
canonical forms 
cm fix 
bm 
xn bi bi ci 

cm 

vn 
xn halt 
vn 
int cap sat halt halt part holds inspection typing judgement 
definition 
machine state stuck halt exist 
theorem type soundness 
stuck 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett proof 
induction number steps taken operational semantics preservation 
progress typed state stuck halt 
theorem complete collection 
halt 
proof 
assume assume 
preservation progress halt int cap sat halt halt sat judgment dom 
consequently 
inspection judgment memory types 
region translation type preservation section prove translation region calculus cl type preserving 
words formed source language term result translation formed cl term 
section describes syntax static semantics term constructs 
notation notation indicate types formed type context 
formally overview type dom theorem uses lemmas proof soundness including lemmas manipulating capabilities lemma asserting formedness lemma 
require number lemmas lemmas describe additional formedness constraints types effects appear region calculus judgments 
lemmas state formedness constructors constructor equality substitution preserved translation 
lemma describes way subset relation preserved translation effects sets capabilities sets 
lemma lemmas proof 
lemma miscellaneous lemma required proof letregion construct 
lemma gives conditions static application continuation closure arguments formed 
lemma 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities 
eff eff proof 
induction derivations 
lemma 
type eff proof 
induction derivation 
lemma formedness preservation 
proof 
induction derivations 
lemma equality preservation 
eff cap eff cap proof 
induction equality derivations 
lemma substitution preservation 
type type 
proof 
induction typing derivation 
lemma 
eff 
proof 
induction derivation 
lemma 

proof 
inspection sub effecting rule eff effect lemma 
definition type translation 

lemma 
cap cap 
proof 

cap equality 

definition 

lemma 



definition 

equality cap 
lemma 
cap 
proof 
proof induction structure 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett 
definition 
result follow immediately reflexivity equality 
similar 

reasoning provides result 
definition rule eq rule eq dup 
induction know 
reasoning provides result 
def 
eq dup eq comm eq comm eq dup lemma 

proof 
term defined derivation proof lemma 
lemma 
type proof 
proof induction typing derivation expressions 
theorem cps type preservation 
int halt fresh proof 
proof induction typing derivation expression inductive hypothesis 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities abbreviations conventions proof 
meta variable range type checking contexts form abbreviate derivations involving 
derivation abbreviated dn dn typing rules contain side condition cl variable contained context judgment 
assumed variables translated term generated fresh case 
sake brevity mention side condition time occurs proof 
rules contain formedness constraints types capabilities 
formedness constraints follow directly source typing judgement lemma 
order concentrate important aspects proof mention conditions time appear derivation 
prove result difficult cases letrec type application value application letregion equality 
cases follow similar simpler pattern 
case letrec 
translation fix xcont cont 
xcont cont rgn cap handle xcont cont source typing derivation acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett handle dom order derivations case manageable abbreviations 
handle handle handle handle handle showing continuation translation formed appropriate context call fact 
var xcont cont var xcont eq reflex derivation follows recall rgn cap 
sub var eq distrib shown 
rule sub var conclude expand abbreviation eq comm eq dup 
apply induction hypothesis obtain xcont apply induction hypothesis obtain handle build typing derivation code continuation translating call fact dx fix xcont dr handle acm transactions programming languages systems vol 
tbd 
tdb month year 
derivation dx derivation dr typed memory management static capabilities var handle 
assumption assumption lemma eq distrib 
apply induction hypothesis translation giving final result case type application 
translation 
cn 
cn 
source typing derivation 

cn ci 
cn 
show value 
cn formed context conclude rule var 
induction number constructors ci applied rule type conclude 
cn substitution lemma lemma 
cn 
cn 


cn 

fact assumption lemma obtain final result 
cn case application 
translation acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett newrgn fcont fix fcont 
freergn fcont source typing derivation term showing result translation type correct showing body innermost continuation newrgn wellformed appropriate context 
order derivation manageable abbreviations rgn handle fcont cont fcont cont fcont fcont fix fcont app freergn cont cont derivation follows app dx dr fcont cont fcont dx dh fcont newrgn derivation proven follows 
rule var deduce rgn cap cont judgment applications rule type give cont acm transactions programming languages systems vol 
tbd 
tdb month year 
rule sub conclude typed memory management static capabilities cont required relation holds rgn assumption assumption lemma rule sub bar derivation dx var var fcont cont consider derivation dr show rgn capability reasoning straightforward rgn rule eq comm assumption assumption lemma def 
translation rule eq distrib consider 
judgment prove 
follows rules sub eq eq reflex 
consider dx judgment prove handle 
judgment follows rule var 
prove dh var handle eq reflex rgn cap freergn judgment trying prove derivation 
rule var conclude 
assumption tells lemma result 
show 
prove rgn capability fact follows rule sub dup 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett satisfied requirements necessary show body innermost continuation formed letregion source typing derivation 
fulfill requirements induction hypothesis may conclude letregion fact source typing derivation apply induction hypothesis conclude equivalent result trying prove 
case letregion translation letregion newrgn rgn handle freergn source typing derivation rgn handle letregion ftv dom dom show continuation translation formed appropriate context dx rgn handle freergn judgment prove rgn handle 
rule var conclude rgn handle 
fact assumption lemma conclude 
judgment prove follows rule eq reflex 
derivation dx rgn acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities var rgn handle handle fulfilled requirements necessary show body innermost continuation formed call fact 
typing derivation 
order apply induction hypothesis show rgn assumption rule sub bar rule eq distrib rgn assumption lemma rule eq comm satisfy preconditions applying induction hypothesis 
result rgn handle ck rgn handle show result translation type checks newrgn ck rgn handle equality rule 
source typing derivation type continuation formed appropriate context lemma equality judgment type deduce type 
lemma deduce 
recall assumption states cap 
fact source typing derivation states lemma deduce acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett cap 
apply induction hypothesis obtain done 
completed proof induction hypothesis preserved translation 
order obtain proof cps translation theorem simply instantiate induction hypothesis 
part int 
continuation halt halt rule part part trivial 
part straightforward int int cap int halt rule sub eq rule eq dup definition conclude empty translation environment trivial continuation halt acknowledgments lars birkedal martin elsman neal glew dan grossman chris hawblitzel fred smith mads tofte stephanie weirich steve zdancewic comments suggestions earlier drafts article 
grateful anonymous reviewers toplas article reviewers appeared sixth symposium principles programming languages 
abramsky 
computational interpretations linear logic 
theoretical computer science 
aiken hndrich levien 
better static memory management improving region analysis higher order languages 
acm conference programming language design implementation 
acm press la jolla california 
alpern schneider 
recognizing safety liveness 
distributed computing 
baker 
list processing real time serial computer 
communications acm 
bershad savage pardyak sirer fiuczynski becker chambers eggers 
extensibility safety performance spin operating system 
fifteenth acm symposium operating systems principles 
acm press copper mountain 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities birkedal rothwell tofte turner 
ml kit version 
tech 
rep department computer science university copenhagen 
birkedal tofte 
region inference von neumann machines region representation inference 
third acm symposium principles programming languages 
acm press st petersburg 
blelloch greiner 
provably time space efficient implementation nesl 
acm international conference functional programming 
acm press philadelphia 
crary walker morrisett 
typed memory management calculus capabilities 
sixth acm symposium principles programming languages 
acm press san antonio 
crary weirich morrisett 
intensional polymorphism type erasure semantics 
acm international conference functional programming 
acm press baltimore 
danvy pfenning 
proving syntactic properties cps programs 
third international workshop higher order operational techniques semantics gordon pitts eds 
electronic notes computer science vol 

elsevier paris 
danvy filinski 
representing control study cps transformation 
mathematical structures computer science dec 
filinski 
controlling effects 
ph thesis carnegie mellon university school computer science pittsburgh pennsylvania 
fischer 
lambda calculus schemata 
proceedings acm conference proving assertions programs 

flanagan abadi 
types safe locking 
lecture notes computer science swierstra ed 
vol 

springer verlag amsterdam 
appeared eighth european symposium programming 
gay aiken 
memory management explicit regions 
acm conference programming language design implementation 
acm press montreal 
gifford lucassen 
integrating functional imperative programming 
acm conference lisp functional programming 
acm press cambridge massachusetts 
girard 

linear logic 
theoretical computer science 
harper lillibridge 
explicit polymorphism cps conversion 
twentieth acm symposium principles programming languages 
acm press charleston 
harper morrisett 
compiling polymorphism intensional type analysis 
second acm symposium principles programming languages 
acm press san francisco 
hawblitzel chang czajkowski hu von eicken 
implementing multiple protection domains java 
usenix annual technical conference 
usenix new orleans 
hawblitzel von eicken 
type system support dynamic revocation 
acm sigplan workshop compiler support system software 
acm press atlanta 
jouvelot gifford 
algebraic reconstruction types effects 
eighteenth acm symposium principles programming languages 
acm press orlando 
kozen 
efficient code certification 
tech 
rep tr cornell university 
jan lafont 
linear machine 
theoretical computer science 
launchbury peyton jones 
state haskell 
lisp symbolic computation dec 
lindholm yellin 
java virtual machine specification 
addison wesley menlo park california 
lucassen 
types effects integration functional imperative programming 
ph thesis mit laboratory computer science 
acm transactions programming languages systems vol 
tbd 
tdb month year 
walker crary morrisett milner tofte harper macqueen 
definition standard ml revised 
mit press boston 
minamide 
space profiling semantics call value lambda calculus cps transformation 
third international workshop higher order operational techniques semantics gordon pitts eds 
electronic notes computer science vol 

elsevier paris 
moggi 
notions computation monads 
information computation 
morrisett crary glew grossman samuels smith walker weirich zdancewic 
typed assembly language intel ia architecture 
see www cs cornell edu latest implementation 
morrisett felleisen harper 
models memory management 
acm conference functional programming computer architecture 
acm press la jolla 
morrisett harper 
semantics memory management polymorphic languages 
higher order operational techniques semantics gordon pitts eds 
publications newton institute 
cambridge university press cambridge uk 
morrisett walker crary glew 
system typed assembly language 
fifth acm symposium principles programming languages 
acm press san diego 
morrisett walker crary glew 
system typed assembly language 
acm transactions progamming languages systems may 
necula 
proof carrying code 
fourth acm symposium principles programming languages 
acm press paris 
necula lee 
safe kernel extensions run time checking 
proceedings operating system design implementation 
usenix assoc seattle 
necula lee 
design implementation certifying compiler 
acm conference programming language design implementation 
acm press montreal 
peyton jones wadler 
imperative functional programming 
twentieth acm symposium principles programming languages 
acm press charleston south carolina 
plotkin 
call name call value lambda calculus 
theoretical computer science 
reynolds 
definitional interpreters higher order programming languages 
conference record th national acm conference 
boston 
reynolds 
syntactic control interference 
fifth acm symposium principles programming languages 
acm press tucson arizona 
reynolds 
syntactic control interference part 
automata languages programming th international colloquium 
lecture notes computer science vol 

springer verlag italy 
sabry felleisen 
reasoning programs continuation passing style 
lisp symbolic computation 
schneider 
enforceable security policies 
acm transactions information system security feb 
smith walker morrisett 
alias types 
lecture notes computer science smolka ed 
vol 

springer verlag berlin 
appeared ninth european symposium programming 
tofte birkedal 
region inference algorithm 
transactions programming languages systems nov 
tofte talpin 

implementation typed call value calculus stack regions 
acm symposium principles programming languages 
acm press portland oregon 
tofte talpin 

region memory management 
information computation 
acm transactions programming languages systems vol 
tbd 
tdb month year 
typed memory management static capabilities wadler 
linear types change world 
programming concepts methods broy jones eds 
north holland sea israel 
ifip tc working conference 
wadler 
taste linear logic 
mathematical foundations computer science 
lecture notes computer science vol 

springer verlag poland 
wahbe lucco anderson graham 
efficient software fault isolation 
fourteenth acm symposium operating systems principles 
acm press asheville 
walker 
type system expressive security policies 
seventh acm symposium principles programming languages 
acm press boston 
walker morrisett 
alias types recursive data structures 
workshop types compilation 
montreal 
wilson 
uniprocessor garbage collection techniques 
international workshop memory management cohen eds 
number lecture notes computer science 
springer verlag st malo 
wright felleisen 
syntactic approach type soundness 
information computation 
wulf levin harbison 
hydra mmp experimental computer system 
mcgraw hill new york ny 
received february accepted may acm transactions programming languages systems vol 
tbd 
tdb month year 
