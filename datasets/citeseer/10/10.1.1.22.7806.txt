fun functional dependencies draft types values static computations haskell thomas december illustrates haskell type class system express computations 
computations type level performed type checker computations static performed compile time type system decidable terminate 
haskell provides means express static computations clear distinction static dynamic computations 
instance declarations de ne predicates types case multi parameter classes relations types 
functional dependencies multi parameter classes directly specify functions get type checker compute values function applications just checking result application say way expressing computation gives power small rst order functional programming language pattern matching structural recursion 
easily de ne things booleans natural numbers lists functions types 
give examples completely static computations elaborate implementation insertion sort 
give examples static dynamic computations mixed 
concepts programs programming languages computations values types probably familiar readers 
long story short programming languages express computations 
computations manipulate values 
typed programming languages distinguish types values 
types related values typing relation says values belong types usually think types sets values 
expressions program parts assigned types indicate kind values produce manipulate 
types document programs clarify kind values involved certain part program help detect programmer mistakes 
statically typed languages types seen take part computations allows compiler check program type correct running program 
seeing types way organize values ask question meaningful similar way organize types 
answer di erent programming languages di erent ways organize types 
widely known probably way types organized class hierarchies object oriented programming languages 
haskell pet class system wb organize types originally introduced allow systematic treatment overloading 
haskell classes quite classes object oriented languages relation types classes similar relation values types types belong classes 
example class eq group types allow values tested equality show class contain types values converted strings 
interesting observation haskell levels things described 
ground level values 
values belong types form second level types belong classes form third level 
relations values types types classes 
section re ections similarities di erences relations 
values types vs types classes haskell unsurprisingly ways introduce values types classes create relations 
values types introduced data type declarations 
example de nition data bool false true simultaneously introduces values false true type bool states false true belong type bool 
classes relations types introduced slightly di erent way 
classes introduces stating names parameters giving types overloaded operations types belonging class support 
example class types support equality introduced declaration class eq bool types declared belonging class referred instance class separate instance declarations 
means de nition types belong particular class left open allowing class extended new instances arbitrary points program 
contrast data type de nitions closed 
declare booleans tested equality give declaration instance eq bool suitable implementation equality booleans 
type de nitions parameterized 
typical example de nition list type type parameter give type elements list data list nil cons list parameterized types declared instances classes useful assumptions parameter types 
example de ne lists tested equality need refer equality test elements list 
instance declarations kind look instance eq eq list 
instance relation seen computation rule equality test arbitrary type example bool gives equality test lists containing values type example list bool 
see gives way express computations type level 
computations dynamic computation haskell computations usually expressed functions values values 
example de ne natural numbers abbreviation sample number data nat zero succ nat succ succ succ zero de ne functions tell number odd follows zero true succ odd odd zero false odd succ interactive haskell system hugs jon ask expressions computed odd true static computation mentioned earlier instance declarations haskell seen computation rules 
haskell statically typed computations expressed way static performed compile time 
predicates de ne odd numbers prolog programmer de ne predicates zero 
succ odd 
odd succ 
names lowercase letter denote constants need declared 
direct transcription program haskell type classes rst need declare constants involved data zero data succ type succ succ succ zero just sample number 
class class odd note prolog constants predicates types classes respectively 
interested values types classes de ned data types constructors classes overloaded operations 
de ne predicates instance declarations instance zero instance odd succ instance odd succ question ask haskell system check number 
computations performed type checker hugs way type checker ask compute type expression check expression type 
de nitions express desired computation practical reasons small addition class class odd saying type representing number element referred name 
instance declarations left unchanged 
ask hugs check number odd type error illegal haskell class constraint inferred type expression type odd zero got type error number 
interpretation line zero odd 
type absence type error means odd number 
relations prolog programmer wanted de ne relation corresponding directly functions odd section result probably zero true 
succ odd 
odd zero false 
odd succ 
multi parameter classes jjm direct haskell transcription 
start declaring constants haven data true data false class class odd odd practical reasons included overloaded operations classes interested types 
prolog relations transcribed instance zero true instance odd succ instance odd zero false instance odd succ ask hugs check number odd type odd undefined true odd undefined true type odd undefined false odd undefined odd succ succ succ zero false false type undefined false undefined false queries look bit complicated 
rst example asked related true relation odd hugs replied case 
second example ask way false hugs says case program contained instance declaration instance odd succ succ succ zero false program doesn 
prevent adding instance odd longer correspond functions odd section 
fact functions anymore kind relations 
ask hugs compute function applications 
try type odd undefined odd undefined odd succ succ succ zero hugs reply means result applying odd type provided program contains instance declarations allowing derive odd succ succ succ zero holds 
hugs try enumerate possible values prolog system 
instance declarations possible value true instance relation open seen premature commitment say true 
functions de nitions previous section hugs idea intend odd functions arbitrary relations 
added possibility declare functional dependencies parameters multi parameter class jon 
rede ne odd follows class class odd odd says relation function prevents time declaring zero true zero false allows computed known number type undefined undefined false type odd undefined odd undefined true having seen strange looking de nitions compute feel motivated go de ne functions natural numbers 
dynamic ones add zero add succ succ add mul zero zero mul succ add mul static counterparts class add add instance add zero instance add add succ succ class mul mul instance mul zero zero instance mul add mul succ undefined note introduced convenient abbreviation undefined 
try static additions multiplications type add add succ succ succ succ succ succ zero type mul mul succ succ succ succ succ succ succ succ succ zero note command type asks hugs just infer type expression compute value 
ordinary dynamic haskell computations performed examples 
mixing static dynamic computations seen haskell allows de ne dynamic functions section computations performed run time static functions section computations performed compile time 
mix de ne functions computed partly compile time partly run time 
answer de nitely 
happens time overloaded functions ordinary haskell programs 
precise compiler opportunity perform computations compile time choose delay run time jon 
common example illustrate static vs dynamic computations power function 
dynamic version de ned pow zero pow succ mul pow completely static version de ned type succ zero class pow pow instance pow zero instance pow mul pow succ haskell type int dynamic part computation de ne version power function base dynamic exponent static follows class pred pred instance pred succ class power power int int instance power zero power instance power power succ power power pred example computation power mul simple example bit pointless interactive environment compile time run time coincide 
computation proceeds roughly follows type checker computes times 
application power reduced type checker generating version power computes dynamic function applied result computed interpreter 
optimizing compiler function repeatedly possibility move computations compile time course give considerable speed 
larger example static computation sections way express static computations haskell class system 
show way expressing static computations limited simple algorithms seen far 
start representation lists conclude implementation insertion sort 
constructors list type data nil nil data cons xs cons generating descending sequence numbers class xs xs xs instance zero nil instance xs succ cons xs comparing numbers class lte lte instance lte zero instance lte succ zero instance lte lte succ succ insertion sort class insert xs ys xs ys insert xs ys instance insert nil singleton instance lte ys insert cons ys class xs ys xs ys instance xs cons cons xs instance insert xs ys xs cons ys class sort xs ys xs ys sort xs ys instance sort nil nil instance sort xs ys insert ys zs sort cons xs zs test de nition de ne tests hugs type cons succ succ zero cons succ zero cons zero nil type sort sort sort cons succ succ zero cons succ zero cons zero nil cons zero cons zero sort error unresolved overloading type sort nil insert zero insert succ zero insert succ succ zero cons zero cons zero expression sort unfortunately hugs type checker doesn reduce types far expected 
reason time writing unknown 
concluding remarks particular type classes explored esoteric kind probably intended 
people discovered multi parameter classes functional dependencies useful conventional programming tasks 
haskell version haskell include multi parameter classes functional dependencies 
ghc ghc hugs jon support extensions varying degree 
appears limits done haskell type systems 
examples tricks stretch limits oka wei 
ghc glasgow haskell compiler 
www haskell org ghc 
simon peyton jones john hughes editors lennart augustsson dave barton brian boutel warren burton joseph fasel kevin hammond ralf hinze paul hudak thomas johnsson mark jones john launchbury erik meijer john peterson alastair reid colin runciman philip wadler 
report programming language haskell non strict purely functional language 
available haskell org february 
jjm simon peyton jones mark jones erik meijer 
type classes exploring design space 
haskell workshop 
jon mark jones 
dictionary free overloading partial evaluation 
acm sigplan workshop partial evaluation semantics program manipulation orlando florida june 
jon mark jones 
hugs 
www haskell org hugs february 
jon mark jones 
type classes functional dependencies 
proceedings th european programming esop number lncs berlin germany march 
springer verlag 
oka chris okasaki 
fast exponentiation square matrices adventure types 
international conference functional programming pages paris france september 
pet peterson 
haskell home page 
haskell org 
wb wadler blott 
ad hoc polymorphism ad hoc 
proceedings symposium principles programming languages pages austin texas 
wei stephanie weirich 
type safe cast 
international conference functional programming montr eal canada september 
