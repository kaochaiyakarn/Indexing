logical operations kolmogorov complexity ii andrei muchnik institute new technologies moscow russia vereshchagin dept mathematical logic theory algorithms moscow state university gory moscow russia mail ver ru investigate kolmogorov complexity problem defined minimum length program outputs outputs prove known problems kind complexity expressible terms kolmogorov complexity pairs triples solves problem posed 
second part consider theorem strings mutual information large common information strong sense 
theorem proven non constructive argument 
constructive proof solving problem posed 

kolmogorov complexity binary string defined minimal length program generates string 
definition extended sets strings 
finite infinite set strings 
define complexity length shortest program generates string informally consider problem generate element complexity problem 
evidently minfk ag generalization gives really new 
combined definition logical operations sets strings goes back kolmogorov kleene notion realizability 
sets strings 
define sets follows authors partially supported russian foundation basic research ffl fha bi bg ffl fh ai ag fh bi bg ffl fp ag delta deltai computable encoding pair strings stands output considered program applied input may undefined example 
strings 
consider set simplify notation identify string singleton fsg 
set contains programs map easy see bja bja denotes complexity conditional known examples 
ffl complexity ha bi usual notation 
ffl minfk 
ffl bja ajb log 
lower bound bja ajb gamma obvious upper bound proven 
ffl cja cjb log denotes complexity hha bi ci 
lower bound evident cja cjb gamma upper bound established 
complexity problems computed additive log term 
note complexity set obtained singletons fag fbg exceed 
sound level precision 
simplify notation neglect additive terms order log 
ffl bja bja stands conditional complexity ci 
solution string type hc pi program mapping upper bound denote minimum length program mapping ha ci string hc program pairing input applying belongs complexity bja 
lower bound program mapping having minimum 
need prove bja 
bja program mapping transformed program mapping ha ci apply find apply find 
remains equality gamma 
ffl cja cjb solution hp qi problem may transformed solution problem 

problem equivalent problem 

problems called equivalent algorithm solution problem computes solution second vice versa 
equivalent problems complexity differing 
problem equivalent problem 


previous item see complexity equal cja cjb ffl 
cja 
ffl minfk cja upper bound obvious 
prove lower bound method weaker assertion minfk proven 
denote set strings length string complexity search program print denote program 
program function fix program string complexity finds applies program empty input 
triple strings called coherent definition triple coherent enumerate coherent triples 
enumerated coherent pair 
assume choose function triples coherent log 
assume case prove cja log 
find component enumerated coherent triple 
find find apply program mapping pair gives solution problem know complexity problem cja log 
examples possible express complexity problem consideration terms complexity involved strings pairs triples additive logarithmic term 
conditional complexity possible avoid means equality xjy gamma 
context notion useful 
complexity vector tuple ha vector length gamma consisting complexity pairs triples instance complexity vector triple ha ci defined hk natural question arises 
substitute singletons fa fa variables propositional formula connectivities denote resulting problem 
true formula complexity determined additive log term complexity vector tuple ha 
realize formulation vague notion determined additive term rigorously defined 
notion rigorous ways sure intuitive meaning suffices results 
question posed shen workshop algorithmic information theory nancy see 
prove answer negative formula 
solution problem pair hp qi programs maps maps construct sequences quadruples strings dn dn having complexity linear complexity vectors differ corresponding components difference dn gamma dn linear growth 
implies complexity problem determined complexity vector ha di additive term 

authors grateful shen bringing attention topic 

preliminaries programming language partial computable function theta argument program second argument called input called output program input programming language called universal programming language exists constant tf solomonoff kolmogorov theorem see universal programming languages exist 
fix universal programming language define xjy minimum length kolmogorov complexity conditional string kolmogorov complexity 
abbreviate 
known facts easy prove algorithm constant domain strings equality jk gamma gamma yjx log proven kolmogorov levin see 
log denote log talk random string set mean 
assume non negative integer constant ff fixed 
random string set string blog gamma ff 
strings complexity non empty set random string ff 
ff increases weaker notion randomness 
known principle allows prove string low complexity 
assume enumerable family vn sets strings 
vn means set fhn xi vn enumerable 
assume jv constant fi fi vn assume sequence sn sets js fin fi rational constant 
prove random strings sn satisfy property argument 
assume enumerable property pn elements sn fraction sn satisfying pn 
finitely random elements satisfy pn easy consequence principle 

complexity problem best bounds complexity problem known authors theorem 
theorem 
minfk cja djb djb cja dja gammak bja djb gammak ajb proof 
definition solution problem pair hp qi programs maps maps shortest programs get upper bound cja djb complexity 
letting equal program mapping inputs program pairing input applying resulting pair minimum length program mapping hb ci obtain upper bound djb 
upper bound cja proven similar way 
prove lower bound hp qi solution 
consider triple hp ri shortest program mapping ha ci triple find hb di apply get apply ha ci get apply get dja bja dja gamma bja 
bound djb gamma ajb proven similar way 
instance obtained cutting random binary string length blocks length lower upper bounds theorem equal complexity problem 
easy find strings lower bound upper bound complexity problem equal lower bound 
take example random string length divide blocks length lower bound equal upper bound 
complexity problem equal take phi sign phi refers bitwise addition modulo 
harder find strings greater lower bound theorem 
start giving example 
find quadruple strings having complexity vector complexity problem equal lower bound theorem 
prove complexity problem determined complexity vector difficult find method applied example 
prove built form constant number blocks random string equal lower bound theorem 
method linear algebra finite fields 
fn denote field cardinality consider points lines planes threedimensional affine space fn points lines exact number lines gamma gamma planes space 
bi take random pair different intersecting lines common point common plane 
easy see lower bound theorem equal case 
theorem 
gamma log 
proof 
solution hp qi maps maps consider set consisting pairs different intersecting lines ha bi maps common point maps common plane generate elements pair bi belongs conclude gammao log jsj log log jsj suffices prove cardinality exceed direct corollary lemma 
lemma 
function mapping line point line function maps line plane having line 
consist pairs ha bi ae 
jsj proof 
see bound proven easy arguments 
line lines plane cardinality times bigger number lines gives bound jsj bound proven counting number lines passing 
note argument fact line pass second line lie plane 
plan follows modify argument show average number pairs ha bi having second component argument take account condition 
argue symmetrical way show average number pairs ha bi having component partition slices slice consists pair ha bi value 
upperbound number pairs slice sum obtained bounds 
fix plane upperbound number ha bi ae consider point denote set lines plane set lines passing passes lies 
number pairs ha bi satisfying ae exceed ja jjb ja jb sums right hand side clear interpretation 
ja determines probability event lines plane chosen random satisfy 
specifically denote total number lines plane prob prob prob prob ja fixed probability event exceed probability line passes point 
probability equal gamman prob gamman ja gamman sum jb determines average number common points lines chosen random set consisting lines lie plane 
specifically jb prob prob prob jb jm distinct lines common point equal lines common points jb prob jm jb jb jjm jm jm recall number ha bi ae exceed pp ja jb exceed jm jm jm inequality proven mere squaring 
remains sum obtained bounds jsj jm families lines form partition set lines sum cardinalities equal number different equal sum equal jsj define quadruple ha di having complexity vector di 
take random binary string length cut blocks length ups vqs 
easy see quadruples complexity vector phi map recall theorem states 
note formula formulas examples depth 
problem depth complexity expressible terms complexity vector involved strings 

solution problem program strings computes strings formula substitution ha ci hb di ha di quadruples constructed 
easier compute ha ci hb di easier compute hb di ha ci easy show complexity resulting problem ha ci hb di 
problem equivalent problem 
know complexity problem different constructed quadruples 
may prove exhaustion complexity problems depth determined complexity vector involved strings 
gap obtained lower bound upper bound theorem 
possible find equal upper bound theorem bigger lower bound theorem 
theorem answers question positive 
theorem 
strings complexity complexity pairs bi ci di equal complexity triples ci di equal complexity quadruple di equal complexity problem equal equalities hold additive log term 
easy verify quadruple lower upper bounds theorem equal respectively 
get example looked 
proof 
fix call set strings length uniform triple ha ci strings length unique ha di define uniform set effectively di take random quadruple imply corollary 
obtain inequality define inequality true quadruples ha di specifically fraction quadruples satisfy inequality 
inequality true random quadruple large 
satisfy remaining requirements complexity vector di suffices ensure triples di di complexity 
note need care di implied inequality 
dj dj dj dj way ensure di di 
construct complexity problems majority quadruples implies symmetrical argument triples di di random random quadruple di large 
gamma log gamma ff constant ff specified 
suffices find uniform set inequalities holds quadruples inequality means hp qi complexity pairs 
suffices prove lemma 
constant ff fi uniform set holds 
set consisting functions sets fha di hf gi dg fha di hf gi dg fha di hf gi dg fi quadruples proof 
prove high probability uniform set chosen random satisfies statement lemma 
sets symmetrical suffices show probability close elements say serves ha di pair hf gi fix upperbound probability serves quadruples call triple ha ci bad gamman jm pairs hf gi property depend 
call triple 
probability event ha ci hf gi chosen random equal gamman fraction bad triples fraction triples greater gamma 
triple ha ci probability serves ha di chosen random 
serves ha di belongs set fg hf gi cg 
ha ci set gamman jm gammalog elements 
known chernoff bound single trial probability success gamma probability number successful trials sequence independent trials greater gamma simple corollary bound obtained letting probability number successful trials greater pn case trials correspond triples gammao trial ha ci choose random trial successful serves ha di 

probability gamma gamma omega gamma ha ci triple ha di served number served quadruples number served quadruples plus number bad quadruples probability gamma gamma omega gamma quadruple ha di called triple ha ci 
number different delta gamma log gammaff gammaff probability gamma gammaff delta gamma gammao gamma gamma gammao gamma gammaff serves quadruples ff large probability tends tends infinity 
requirements lemma decidable 
find brute force set satisfying lemma 
explained random quadruple satisfies statement theorem 
quadruple complexity vector theorem consider random binary string length cut parts length obtain phi phi know phi find find new proof fact complexity problem determined complexity vector instructive compare new proof old 
proofs show quadruple having specific properties quadruple having complexity vector lower bound 
lower bound stronger second proof proof constructive 
mean 
proofs effectively find set take arbitrary random element important difference proof set explicitly second 
proofs type called effective ones second type quasi effective consider proofs existence object specific properties 
cases probabilistic algorithm probability close computes object having desired property 
note algorithm deterministic case complexity object log 
case algorithm runs polynomial time addition multiplication division field fn performed polynomial time second case know efficient algorithm 
interesting find set satisfying lemma exists polynomial time algorithm finds ha di effective quasi effective proofs opposed non effective ones construct algorithm find object desired properties 
usually proof easier find 
exception know easier proof existence complexity problem greater lower bound theorem 
example theorem quasi effective proof easy known non effective ones 

constructing strings having large amount mutual information having common information known strings mutual information omega gamma gamma ajb gamma bja large common information sense small cja cjb small complexity 
string may regarded piece common information computed 
specifically sequences bn omega gamma sequence cn ja cn jb cn 
may obtained follows 
string length result independent trials random variable string obtained way binary variable eta may choose dependent random variables outcome determine outcome vice versa 
easy corollary theorem shannon entropy proven ahlswede korner 
effective proof existence strings having large mutual information having common information 
pointed words common information may understood stronger sense 
relevant definition 
main idea consider string piece common information smaller 
words ajc bjc 
definition sense true ha bi provided 
need modify requiring 
precise consider sequences complexities linear growth 
consider set triples hu wi reals string cn un log jc vn log bn jc wn logn 
set called complexity profile instance random strings length having common substring length substring may taken profile contain triple 
profile decreases common common information simplify presentation restrict done case bn 
minimum complexity profile 
consists triples hu wi satisfying inequalities inequalities min denote set 
easy verify profile includes set min show suffices consider strings consisting substrings shortest programs print shortest programs mapping 
detailed proof see 
theorem 
sequences bn profile equal min equalities valid additive log term 
proof theorem non effective authors wonder quasi effective 
note profile constructive examples known 
quasi effective proof theorem 
profile equal min holds 
triple simultaneously belong profile inequalities holds profile bn contain hu wi 
direct consequence inequalities ajc bjc ajc bjc respectively 
suffices construct strings log bn log property 
satisfying inequalities wg gamma gamma jc bn jc linear function log specified 
construct directed graph vertices strings length number edges ha bi take random edge graph 

properties graph need 
follows 
set cardinality gammak small fraction edges incident node applying property set strings complexity gamma prove random edge ha bi graph complexity greater gamma gamma log 
property follows 
edges graph belong set fha bi satisfying inequalities string jc bn jc wg able find set define decidable property ensure set having property edges graph belong property 
set union satisfying inequalities sets union sets form theta jaj jbj call set pairs strings length special property 
suffices prove lemma 
lemma 
function log constant fi graph nodes strings length satisfies properties 

number edges gamma 
set cardinality gammak fi delta edges incident node 
special set fi delta edges 
proof 
independent trials choosing trial edge random allow loops 
prove probability close properties hold 

fixed set pairs nodes cardinality gamma probability random edge gets gamman gamma probability edges get gamma number delta gamma delta probability edges get set cardinality gamma exceed gamma delta gamma delta 
probability random edge incident node fixed set cardinality gammak provided log 
chernoff bound probability happens fraction random edges exceed gamma omega gamma gamma gammalog gammao number delta gammak log gammak probability gamma log gammak delta gamma gammalog gammao edges graph incident node probability tends 
prove special set edges 
number exceed 
fixed union sets form theta jaj jbj gammak pairs 
multiplying number get gammak log provided log 
special probability gamma random edge get chernoff bound probability gamma gamma omega gamma edges graph get estimate number special sets 
fixed delta delta delta gammak log special sets 
rising number power number different obtain upper bound gammak log number special sets 
probability gamma gammak log delta gamma gammalog gammao gamma gamma gammalog gammao gamma log gammak special sets edges graph 
suffices log order probability close 
ahlswede korner 
common information related characteristics correlated information sources 
preprint 
th prague conference information theory 
bennett acs li vitanyi zurek 
information distance ieee transactions information theory vol 

chernoff 
measure asymptotic efficiency tests hypothesis sum observations 
annals mathematical statistics 
kleene 
metamathematics 
new york toronto 

zur der logik 
mathematische zeitschrift bd 

li vit anyi 
kolmogorov complexity applications 
springer verlag 

muchnik shen vereshchagin 
upper semi lattice binary strings relation simple conditional 
proc 
th annual ieee conference computational complexity atlanta may 

muchnik 
conditional kolmogorov complexity codes 
published theoretical computer science 
shen vereshchagin 
logical operations kolmogorov complexity 
published theoretical computer science 
