automata theoretic approach planning temporally extended goals giuseppe de giacomo moshe vardi dip 
informatica sistemistica univ roma la sapienza salaria roma italy dis uniroma department computer science rice university box houston tx vardi cs rice edu 
study automata theoretic approach planning temporally extended goals 
specifically devise techniques nonemptiness buchi automata infinite words synthesize sequential conditional plans generalized setting goals general temporal properties desired execution dynamic systems represented finite transition systems incomplete information initial situation allowed states partially observable 
prove techniques proposed optimal wrt worst case complexity problem 
scalability nonemptiness algorithms techniques promise applicable fairly large systems notwithstanding intrinsic complexity problem 
artificial intelligence interested analysis synthesis dynamic systems behavior 
particular research area reasoning actions concerned representing reasoning systems order analyze interesting properties behavior area planning concerned synthesis devices plans order control system behavior achieve desired conditions goals 
areas developed research quite different directions 
reasoning actions lot done finding ways represent reason dynamic systems dynamic properties increasing generality 
area planning focus achieving effectiveness planning process lately notable results obtained limited capabilities modeling dynamic system kind goals considered 
study synthesis sequential conditional plans setting close considered area reasoning actions 
call sequential plans plans sequences primitive actions conditional plans plans include choice points resolved ascertaining conditions runtime 
particular spirit reiter formalization dynamic systems situation calculus assume incomplete information initial situation initial states compatible information available initial situation ii deterministic actions performing action state brings determined state iii actions conditional effects effects action depend state action performed 
allow partially observable states 
words agent observe part state choices action perform may depend part 
kind goals consider temporally extended goals goals specify acceptable sequences states :10.1.1.45.7847
kind goal subsumes usual goals expressing reachability desired conditions generalized goals don disturb restore requirements 
generally complex temporal properties typically specification processes expressed :10.1.1.42.2841
observe deal goals expressing general temporal properties sequential plans may fact involve loops goals form may require infinite executions 
consider example plan satisfy requirement certain triggering conditions met finite undetermined number steps specified state affairs brought triggering conditions met 
major compromise accept order get effective planning techniques outlined setting restrict attention systems finite number states 
radical simplification wrt compromise widely accepted planning 
formally model dynamic systems finite transition systems 
transition system thought graph nodes represent states labeled part state observable edges represent state transitions labeled actions cause state transitions 
representation formalisms ai transition systems 
example strips formalisms action languages formalisms compactly represent transition systems different generality 
furthermore formalizations logics situation calculus dynamic logics tightly related transition systems 
goal specification adopt automata infinite words desirable traces correspond language accepted automaton 
way specifying goals close adopting linear time temporal logic ltl goal specification language ltl specification translated automaton :10.1.1.42.2841
framework establish techniques characterize worstcase computational complexity synthesizing sequential conditional plans adopting approach theory automata infinite objects infinite words case approach widely verification hardware control intensive opposed data intensive software 
rest structured follows 
introduce transition systems buchi automata infinite words 
study sequential planning initial state unique complete information initial situation states fully observable 
section section study sequential planning conditional planning initial state unique states partially observable 
briefly discuss algorithmic techniques related works 
draw 
preliminaries transition systems finite transition system defined act obs finite set possible states 
finite set possible initial states act set possible actions 
theta act transition function actions deterministic function state action return state 
obs finite set possible observations model observable part states 
obs observability function returns current observation observable part current state 
execution transition system infinitive sequence states act trace observe execution 
example trace corresponding execution 
observable behavior dynamic system set possible traces transition system 
automata infinite words finite nonempty alphabet sigma infinite word element sigma infinite sequence symbols sigma buchi automaton tuple sigma ae sigma alphabet automaton 
finite set possible states 
set possible initial states 
ae theta sigma transition function automaton automaton need deterministic 
set accepting states 
simplicity wlog assume total function 
model case transition exists making return special dummy state 
way describing observable behavior dynamic system corresponds called linear time view dynamic system contrasted called branching time view see discussion 
input words infinite words sigma run infinite word infinite sequences states ae 
run accepting iff lim lim fs occurs infinitely 
word run accepting gets infinitely times turn means finite state visited infinitely 
language accepted denoted set words accepting run 
nonemptiness problem automaton decide automaton automaton accepts word 
proposition 
nonemptiness problem buchi automata nlogspace complete :10.1.1.42.2841
algorithms nonemptiness fair reachability graphs 
idea algorithms best explained line prolog implementation nonempty ini cn acc cn 
cn rho 
cn rho cn 
ini denotes elements acc denotes elements rho denotes relation corresponding transition function cn denotes states connected rho chain cn transitive closure rho 
words automaton nonempty starting initial state reach accepting state cycle back 
nondeterministic algorithm nonemptiness follows nondeterministically chooses initial state accepting state checks connected connected 
run algorithm need store state current states plus constant number control bits 
encode states bit vectors need log jsj bits 
gives nlogspace bound 
linear time deterministic algorithm nonemptiness decompose transition graph automaton maximally strongly connected components linear cost ii verify intersects linear cost 
buchi automata widely verification specify properties dynamic systems :10.1.1.42.2841
transition system representing dynamic system observe strong similarity naive algorithm check plan existence traditional approaches fact reachability graphs ini cn goal 
cn result 
cn result cn 
ini denotes initial states typically goal states goal satisfied result corresponds result function return state resulting executing action operator current state cn transitive closure 
fig 

automaton eventually fig 

automaton eventually words accepted automaton put correspondence traces transitions system specified properties 
examples specifications shown 
automaton accepts traces certain point property hold forever 
automaton accepts traces point trace guaranteed sooner certain property hold 
generally property expressible propositional linear time temporal logic ltl expressed buchi automaton vice versa 
generalized buchi automata 
generalized buchi automaton sigma ae ff gamma variant buchi automata sets accepting states gamma acceptance condition run lim gamma 
generalized buchi automaton sigma ae ff gamma transformed equivalent buchi automaton sigma ae theta gamma theta ae ae theta fig ae ae theta theta planning complete information start investigation considering simplified case 
assume complete information initial situation full observability state 
kind plans interest case sequential ones sequences actions conditional plan exists iff sequential plan 
standard techniques transform ltl formulas buchi automata 
size resulting automaton worst case exponential wrt formula :10.1.1.42.2841
sense ag 
model dynamic system interest transition system act obs singleton set containing initial state unique assuming complete information initial situation 
obs obs simply identity function assuming full observability 
buchi automaton specifying behavior desired executions system 
formally obs ae obs plays role alphabet automaton 
finite set possible states automaton 
set possible initial states 
ae theta obs transition function automaton automaton need deterministic 
set accepting states 
plan infinite sequence actions act execution starting initial state infinite sequence states 
trace tr starting initial state infinite sequence 
plan realizes specification iff tr 
synthesize plan 
check nonemptiness buchi automaton act ae act alphabet automaton theta theta fw ae iff ae theta get result theorem 
plan realizing specification exists iff 
notably nonemptiness algorithm easily modified return plan plan exists 
plan returned consists parts sequence arriving certain state second sequence forms cycle back state 
plans finite representations 
immediate consequence construction get theorem 
planning setting decidable nlogspace 
proof 
automaton built fly checking nonemptiness nondeterministic algorithm need log jw log jsj bits 
observe adopt compact logarithmic representation transition system example propositions denote states computing transitions directly propositions planning setting pspace 
complexity planning strips seen special case setting considered reachability desired state affairs kind goal considered strips certain transition systems compactly representable 
considering strips pspace hard conclude theorem 
planning setting nlogspace complete pspace complete wrt compact representation 
sequential planning incomplete information consider general case 
assume partial information initial situation assume part state observable 
section consider generating sequential plans section turn conditional plans 
model dynamic system interest general transition system act obs defined section 
transition system initial states fw gamma reflecting uncertainty initial situation 
previous section specify behavior desired executions system buchi automaton plan infinite sequence actions act execution starting oh infinite sequence states ih 
trace tr plan infinite sequence 
plan realizes specification iff tr gamma 
synthesize plan 
check nonemptiness buchi automaton 
time construction slightly involved 
build generalized buchi automaton act ae theta theta gamma ae iff jh ih jh ae ih ih gamma 
ff theta gamma theta gamma theta theta want stress assuming formalisms able represent transition system compactly realistic 
number possible transition functions jw jw number transition functions distinguishable log jw bits log jw jw cases compact representations transitions systems exist digital circuits described compactly means hardware description languages 
automaton get equivalent buchi automaton act ae theta theta gamma theta gamma theta ae iff jh ih jh ae ih ih gamma mod ip 
theta gamma theta theta theorem 
plan realizing specification exists iff 
nonemptiness algorithm easily modified return plan plan exists 
plan consist parts sequence arriving certain state second sequence forms cycle back state 
note possibility expressing plan finite sequence cycle guaranteed spite uncertainty initial state 
building automaton fly check nonemptiness nondeterministic algorithm needing delta log jw log jsj bits bounded size jw considering pspace get theorem 
planning setting decidable pspace 
adopt compact representation transition system planning setting expspace 
lower bounds 
theorem says upper bounds tight 
theorem 
planning setting pspace complete wrt compact representation 
proof 
need prove hardness 
consider problem finding string accepted intersection deterministic finite state automata alphabet pspace complete 
easy reduce problem planning setting 
particular reduction works restrictions obs identity function ii specification automaton denotes achievement goal 
transition system represented compactly techniques lift pspace lower bound expspace lower bound 
note plan existence strips incomplete information initial situation pspace complete polynomial reduction case initial situation completely known 
means pay price time generalizing setting wrt traditional approaches 
observe reduction proof theorem tells increase complexity essentially due coping general form transition systems allow possible initial states partial observability states general form goals considered 
conditional planning incomplete information turn synthesis conditional plans general setting introduced previous section 
transition system specification automata defined previous section 
vector plan infinite sequence vectors actions act execution ex component starting initial state infinite sequence states ih ih 
trace tr component infinite sequence 
vector plan realizes specification iff tr gamma 
vector plan conditional plan simply parallel compositions sequential plans initial state 
conditional plans vector plans actions agree executions observations 
formally define conditional plans introduce notion equivalence finite traces 
wn finite traces hw wn iff wn conditional plan vector plan executions pair components nl hw wn intuitively conditional plan composed infinite sequence case instructions step base observations select proceed 
synthesize conditional plan 
follow line construction previous section checking nonemptiness buchi automaton time act alphabet 
specifically build generalized buchi automaton act ae theta theta set equivalence relations set gamma theta gamma theta iff ae iff ffl jh ih jh ae ih ih ffl am ffl iff jl jm ff theta gamma theta theta gamma theta theta theta automaton transformed buchi automaton 
theorem 
conditional plan realizing specification exists iff 
nonemptiness algorithm immediately modified return plan plan exists 
plan returned consists parts sequence arriving certain state second sequence forms loop state time element sequences tuples actions 
observe formally deal vectors sequential plans conditional plan returned put convenient form case instructions loops 
easy verify complexity bounds previous case hold 
theorem 
finding conditional plan setting pspacecomplete expspace complete wrt compact representation 
practical algorithms results show planning reduced nonemptiness buchi automata 
algorithms checking nonemptiness buchi automata proved suited scaling large systems 
breakthrough technology symbolic methods idea encoding states bit vectors representing sets states transitions symbolically boolean functions encoding ordered binary decision diagrams obdds efficiently manipulate boolean functions 
industrial strength system hardware protocol verification developed commercially success 
indicates notwithstanding worst case complexity possible implement planners general setting considered 
experimental results adopting symbolic techniques planning quite promising see 
focus attaining propositional goals actions nondeterministic symbolic techniques adapted framework 
related need dealing incomplete information put forward area planning need going goals specify reachability desired state affair :10.1.1.45.7847
particular planning setting close considered studied dynamic systems represented transition systems single initial state nondeterministic actions allow modeling incomplete information fully observable states goals temporally extended goals expressed variant ltl includes metric time plans generated reactive conditional plans 
analogous planning setting studied additional assumption deterministic actions focuses generating finite sequential plans considers plans consisting possibly observe need bits represent equivalence relation gamma :10.1.1.45.7847
infinite sequences actions 
approach adopted obtaining planning algorithms somewhat ad hoc formula decomposition 
approach proposed fundamental relationship ltl buchi automata 
automata theoretic approach separates logical algorithmic aspects planning problem resulting clean optimal algorithms 
demonstrated approach quite flexible easily adapted various planning scenarios 
studies intrinsic complexity specific planning problem tackle 
particular complexity lower bounds established 
worth mentioning similarities automata theoretic approach adopted approaches planning techniques operations research mdps pomdps considered quite promising dealing incomplete information generalized goals stochastic domains 
precise relationships established 
particular best knowledge encoding general temporally extended goals expressible buchi automata ltl mdps pomdps rewarding function remains open problem 
automata infinite objects studied synthesis hardware control software 
automata theoretic techniques synthesizing discrete controllers 
setting studied incomplete information initial situation plus deterministic actions naturally arise planning reasoning actions simpler general synthesis framework enabling obtain algorithms lower computational complexity 
studied planning temporally extended goals incomplete information initial situation available states partially observable number possible states finite 
devised techniques nonemptiness buchi automata infinite words synthesize sequential conditional plans characterized worst case computational complexity 
techniques introduced framework easily specialized wide range formalisms reasoning actions transition systems 
spite high worst case complexity scalability practical algorithms involved promises automata theoretic approach planning feasible general setting considered 
acknowledgments yves lesperance participated discussion set stage esslli cesta gave precious comments relate material traditional planning 
partially supported nsf ccr ccr asi murst esprit ltr project dwq 
bacchus boutilier grove 
structured solution methods nonmarkovian decision processes 
proc 
aaai 
bacchus kabanza 
planning temporally extended goals 
ann 
math 
ai 
backstrom 
equivalence tractability results sas planning 
proc 
kr 
kabanza st denis 
synthesizing plant controllers real time goals 
proc 
ijcai 
blum furst 
fast planning planning graph analysis 
artif 
intell 
bryant 
symbolic boolean manipulation ordered binary decision diagrams 
acm computing surveys 
burch clarke mcmillan dill hwang 
symbolic model checking states 
information computation 
bylander 
tractability artificial intelligence 
experimental theoretical computer science 
cimatti giunchiglia giunchiglia traverso 
planning model checking 
proc 
ecp 
cimatti roveri traverso 
automatic obdd generation universal plans non deterministic domains 
proc 
aaai 
cormen leiserson rivest 
algorithms 
mit press 
daniele vardi 
strong cyclic planning revisited 
submitted 
de giacomo nardi rosati 
moving robot kr approach 
proc 
kr 
deshpande varaiya 
tableau control pltl formulae 
proc 
th conf 
decision control 
ieee 
drummond 
situated control rules 
proc 
kr 
emerson 
temporal modal logic 
handbook theoretical computer science 
etzioni hanks weld draper lesh williamson 
approach planning incomplete information 
proc 
kr 
fikes nilsson 
new approach application theorem proving problem solving 
artif 
intell 
garey johnson 
computers intractability guide npcompleteness 
freeman san francisco 
geffner 
classical probabilistic contingent planning models algorithm 
proc 
aips 
planning combinatorial search 
geffner bonet 
high level planning control incomplete information pomdps 
proc 
aips 
integrating planning scheduling execution dynamic uncertain environments 
gelfond lifschitz 
action languages 
linkoping electronic articles computer information science 
golden weld 
representing sensing actions middle ground revisited 
proc 
kr 
hardin har el kurshan 
cospan 
computer aided verification proc 
th int conf lncs 
springer verlag 
harel kupferman vardi 
complexity verifying concurrent transition systems 
proc 
th int conf 
concurrency theory lncs warsaw july 
springer verlag 

tutorial proving correctness concurrent systems spin 
proc 
th int conf 
concurrency theory 
springer verlag 
kabanza st denis 
planning control rules reactive agents 
artif 
intell 
kaelbling littman cassandra 
planning acting partially observable stochastic domains 
artif 
intell 
kautz mcallester selman 
encoding plans propositional logic 
proc 
kr 
kupferman vardi 
synthesis incomplete 
nd int conf 
temporal logic manchester july 
kluwer academic publishers 
kurshan 
computer aided verification coordinating processes 
princeton univ press 
levesque 
planning presence sensing 
proc 
aaai 
aaai press mit press 
manna waldinger 
clear block theory plans 
automated reasoning 
mccarthy hayes 
philosophical problems standpoint artificial intelligence 
machine intelligence 
mcmillan 
symbolic model checking 
kluwer academic publishers 
pednault 
adl exploring middle ground strips situation calculus 
proc 
kr 
pnueli rosner 
synthesis reactive module 
proc 
th acm symp 
principles programming languages austin january 
ramadge wonham 
control discrete event systems 
proc 
ieee jan 
reiter 
knowledge action logical foundation describing implementing dynamical systems 

preparation 
rosenschein 
plan synthesis logical perspective 
proc 
ijcai 
sandewall 
features fluents 
representation knowledge dynamical systems 
volume oxford university press 
shanahan 
solving frame problem mathematical investigation common sense law inertia 
mit press 
vardi 
automata theoretic approach fair realizability synthesis 
wolper editor computer aided verification proc 
th int conf lncs 
springer verlag berlin 
vardi 
automata theoretic approach linear temporal logic 
moller birtwistle editors logics concurrency structure versus automata lncs 
springer verlag berlin 
vardi wolper 
automata theoretic approach automatic program verification 
proc 
st symp 
logic computer science cambridge june 
vardi wolper :10.1.1.42.2841
reasoning infinite computations 
information computation november 
weld etzioni 
law robotics call arms 
proc 
aaai 
