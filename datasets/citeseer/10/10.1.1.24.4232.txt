jvm susceptibility memory errors chen alan philippe fu zoran milojicic univ rochester hp labs ucsb stanford univ 
william mary college cs rochester edu hpl hp com zoran cs ucsb edu stanford edu cc gatech edu cs wm edu modern computer systems powerful larger memories 
high systems little attention paid high availability 
particularly true transient memory errors typically cause entire system fail 
believe situation improved addressing memory errors levels system bring commodity systems closer mainframe class availability 
fault injection experiments investigate memory error susceptibility highest level jvm java benchmark applications 
consider jvm data structure checksums increase detection silent data corruption affecting jvm applications 
results indicate jvm heap area higher memory error susceptibility static data area detect memory errors jvm application 
believe techniques allow commodity systems robust error prone transient errors 
demand high performance availability commodity computers increasing ubiquitous computers internet services 
commodity systems tackling performance issues availability received attention 
common belief software errors administration time continue probable cause loss availability 
failures clearly commonplace especially desktop environments probability certain hardware errors increasing 
hardware errors classified hard errors transient soft errors 
hard errors require replacement relinquished component 
typically caused physical damage component damage connectors 
transient errors result invalid state corrected example overwriting corrupt memory location 
ziegler shown factors increased semiconductor technology density reduced supply voltage lead increased transient errors cmos memory effects cosmic rays 
tandem indicates errors apply processor cores chip caches modern die sizes levels 
increased error correction codes ecc significantly reduce probability transient errors greater speeds denser technology lower voltages increase likelihood errors significant systems 
ecc protection multiple bit errors may escape scope hardware protection corrupt values random memory locations 
applications potentially incorrect value access called silent data corruption 
typical examples transient errors processor registers alu multiple bit memory errors forth 
result errors escape hardware protection possible software detect 
promising applications java technologies ecc protection allowing errors exposed system 
current commodity systems little consideration transient memory errors 
example systems ia architecture transient memory error occurs cpu simply enters machine check abort mca exception os panic reboot 
new ia architecture increased scope useful mca handling 
time mca exception cpu provide current recovery java applications jvm operating system hardware firmware extended recovery propagating memory errors 
memory errors detected lower layers corrected propagated higher levels system applications information current cpu status notify operating system handle exception 
ability provides new opportunities systems recover gracefully memory errors 
existing research outlined opportunity memory error recovery increased hardware support :10.1.1.37.1424
research proposes operating system extended increase recoverability receives memory error exception 
recoverability system complex involves participation levels hardware application software 
propose os determines memory error occurred application error exception application processing 
focus java virtual machines jvm java applications exception handling level see 
application level jvms java applications particular interest large garbage collected heaps virtual machine abstraction integrated exception mechanism 
large garbage collected heaps sweet spot research garbage collector may uncover errors part heap sweep collection 
heaps usually larger explicitly allocated heaps increasing probability memory error sweep 
presenting abstraction operating system applications virtual machine application level recovery simpler 
jvm increased information application status semantics memory usage improved chance recovery 
java integrated exception handling allow applications written memory error aware trapping new exceptions :10.1.1.37.1424
virtual machine isolate error solely application generate exceptions allow application handle memory error gracefully 
memory failure recoverability complex problem 
tries identify memory error susceptibility java virtual machine java applications step tackling potential problem 
major contributions include quantifying memory error consumption susceptibility rate kaffe jvm sample java applications evaluation extensions kaffe jvm detect silent data corruption 
rest organized follows 
section outlines related yo problem 
section describes problems addressing 
methodology fault injection experiment method detecting silent data corruption described section 
section presents experimental results 
lessons learned section 
ends recommendations section section 
related effects trends soft errors reported ziegler field experimental evidence alpha particles cosmic rays source random system failures 
soft errors greater concern semiconductor susceptibility particles increases technology density voltage drops 
availability computer systems determined hardware software reliability 
high level hardware reliability traditionally existed proprietary servers specialized redundantly configured hardware critical software components possibly support processor pairs ibm parallel tandem nonstop 
reliability difficult achieve commodity software extensive testing quality assurance 
commodity software fault recovery evolved far time 
operating systems support form memory protection units execution detect prevent wild read writes 
commodity operating systems addressed problems memory errors taken software reliability research general 
examples include windows linux 
typically rely fail solutions microsoft high availability linux projects 
lot undertaken fault tolerant community regarding problem reliability software recovery 
include techniques check pointing backward error recovery 
conducted context distributed systems single systems 
techniques efficient recoverable software components rio file cache recoverable virtual memory rvm 
fine project uses fault injection techniques study fault tolerance unix systems 
fine set experimental tools capable injecting hardware software induced errors unix kernel tracing execution flow kernel key variables 
fault injection operates application level uses debugger tool ptrace trace application behavior 
research attempted quantify absolute number errors seen particular configurations 
example estimated gb memory system mbit drams combined visible error rate failures time fit errors hours single error correct double error detect sec ded ecc 
equivalent errors machines years 
tandem estimates typical processor silicon soft error rate fit approximately affect processor logic affect large onchip cache 
due increasing speeds denser tech nology lower voltages errors probable single hardware component failures 
hp labs studied trends error rates repercussions processor error handling support operating system handling recovery application recoverability :10.1.1.37.1424
reports part 
memory error susceptibility memory errors computer system serious exceptions detected silent data corruption memory undetected 
current java environments memory errors discovered silent data corruption memory detection correction hardware 
concentrate analysis recovery corruptions occur application data area 
errors native instruction sequence errors kernel area scope study addressed :10.1.1.37.1424
suppose transient error happens word inside application data area error may may consumed accessed application 
error consumed error may may eventually lead application error 
example suppose error occurs id string array id changed unexpectedly 
id matched searches error won lead application errors 
studying affect transient memory errors jvms java applications valuable benefits 
lets understand application behavior silent data corruption design efficient software methods detect silent data corruption 
infeasible detect errors study focuses data areas susceptible memory errors 
rest section defines terms describes experimental environment 
memory error definitions refer act application accessing memory location containing soft error consumption 
define memory error consumption rate consumption rate number errors consumed error consumed versus number memory errors memory errors consumption rate error consumed memory errors equates portion total error rate seen application errors memory locations accessed noticed 
consumption rate smaller 
definition consumption rate upper bound errors seen execution real situation 
simplification assume memory error persists consumed application exits 
necessary high operating systems memory pass physical memory removing correctable errors finds 
presence ecc memory memory clear correctable errors exist memory 
error consumption eventually causes application crash return erroneous result say caused application error 
verification performed comparing result known correct result 
lastly refer error susceptibility memory region likelihood application error caused error consumption 
memory susceptibility susceptibility memory area defined ratio actual application errors errors application divided number memory errors previous formula susceptibility errors application memory errors assume memory errors distributed uniformly application total virtual memory area 
memory errors affect physical memory similar assuming working set fits physical memory 
jvm memory error susceptibility jvm data area divided roughly partitions allocated statically virtual machine vm allocated heap java objects 
want identify error susceptibility different memory areas guide recovery studies 
errors heap want know susceptibility varies different heap object types 
feature jvm unused java objects freed explicitly application collected freed garbage collector 
garbage collector gc consumes memory errors interesting 
silent data corruption detected hardware solutions need design software solution detect errors 
propose simple detection scheme checksumming heap objects 
fault injection efficiency approach 
experimental setup chose kaffe experimentation open source package allows get source code extend freely 
having source code allows examine memory usage instrument fault injection experiments extend detect silent data corruption 
mature system reasonable performance widely 
experiments redhat linux running kaffe interpreter mode 
assume ia error handling architecture kaffe hasn ported ia ia architecture pentium iii processor system 
appropriate point different memory error implications type processor 
experiment methodology section explain method setup fault injection experiments 
describe prototype implementation detecting silent data corruptions 
fault injection experiment method basic experiment method inject errors application data area track error tion monitor application behavior consumption 
ptrace system call trace jvm execution manipulate debug registers set data breakpoint track error data consumption 
data breakpoints ia architecture debugging registers set data breakpoints 
identified dr dr 
dr breakpoint status register dr debug control register dr dr set addresses breakpoints 
breakpoint address ia architecture allows user set breaking execution breaking writes breaking read write 
experiment set cpu break readwrite injected error address 
time set address 
method limitation access read write 
overcome limitation duplicating breakpoint setting read write write 
unable get correct debugging status register value linux system 
don know breakpoint fires 
may possible overcome limitation 
ptrace debug registers privileged cpu resources user application read write directly 
fortunately linux provides ptrace system call accessing registers user processes 
normally ptrace system call way 
debug process uses fork create child process 
return fork child process calls ptrace parameter inform parent process wants traced 
child process calls similar functions execute debugged application 
side parent process calls wait return fork 
child process calls generates uncaught signals parent process watch process starts fork continue set watch point receive trap signal record clear data set trace flags start kaffe randomly generate error raise signal consume data record exit status return exit tracing error consumption ptrace 
wakes previous wait 
waking parent process examine set status child process ptrace call 
way ptrace illustrated 
modified kaffe executive start watch monitor process 
watch process uses fork create run vm 
certain points vm execution memory error generated raised inform parent watch process set data breakpoint error address 
receiving signal watch process child process data address space layout obtain child data address easily sets appropriate data breakpoint 
child process resumes may may consume injected error 
error consumed child process traps parent wakes trap signal 
consumption recorded breakpoint cleared 
child process exits normally incorrectly watch process signaled status recorded 
child process exits normally check output correct 
generating recording memory errors instrumented kaffe virtual machine inject memory errors data memory area record memory status 
interpreter mode virtual machine executes loop interpreting byte code 
code instrumented certain number byte codes executed loop calls error injection procedure generate memory error 
memory error injected data memory areas static memory area vm object heap 
test set errors injected areas 
time byte randomly chosen specified area location bits flipped 
error injected object heap record type information object byte located 
purpose information record includes object type size base address 
vm stores error address global variable raises signal inform watch process memory error generated 
receiving signal watch process global variable get error address set data breakpoint address 
vm allowed continue 
error consumed inspect vm status see consumed garbage collector 
kaffe uses mark sweep algorithm inspection fairly easy gc running user threads stopped 
detecting silent data corruption experimental results error consumption implemented prototype solution detecting silent data corruption kaffe virtual machine 
believe method applied virtual machine implementations 
basic idea pure java application java object array accessed specific group bytecode operations getfield putfield 
operations add code checksum computation 
heap object management modified store checksum results 
space checksums directly extending kaffe object data structure extra fields storing checksum data extended heap memory management data structure bytes memory block 
conforms way kaffe manages object status 
kaffe heap memory management module objects classified small objects big objects 
small objects generally objects sizes smaller system page size 
large objects objects needing page 
small objects grouped pages 
page divided size blocks 
block assigned object 
head page meta data structure blocks inside page 
contains information block size garbage collection status object type 
bytes added small object byte bit pattern checksum checksum validity 
checksum invalidated native calls native accesses implementation 
big objects arrays efficient checksum structure 
byte megabyte array accessed don want compute checksum array 
divide object fixed size small blocks checksum computed small blocks 
add extra memory overhead checksum computed efficiently large objects arrays 
checksum computation java application running objects accessed created new operator fields read written putfield get entry array read bytecodes entry array written bytecodes part array copied system array copy object array operated native functions object walked garbage collector 
kaffe static fields class related stored class objects data objects 
due time limitations unable instrument kaffe add checksum protection static areas class objects 
results instrumenting data object accesses 
instrumentation object field array entry read bytecode compute checksum read value rest object array compare checksum previously stored object block meta data structure 
object updated bytecode update checksum value 
simplicity implementation checksum computed xoring bytes object polynomial checksum tcp ip 
experiment results section experimental results error consumption silent data corruption detection 
experiments assume uniform memory error probability memory area 
convenience experiments inject number errors experiment sets 
benchmark applications experiments extracted spec jvm benchmark suites 
selected applications suite jess java expert system db java database javac java compiler jack java parser generator 
experiments conducted medium data configuration percent 
data size experiments finish reasonable time large cause garbage collector run 
static dynamic areas inject memory errors benchmarks 
dynamic area experiments benchmarks run error detection mechanism record error consumptions detected 
total running time experiments took hours pentium iii mhz platform 
total code size error injection tracing lines lines memory error detection 
memory error consumption experiment divided parts 
part inject memory errors vm static memory area part inject errors object heap 
areas differently kaffe 
static data area includes global variables constants 
intuitively errors area cause real problems java application consumed 
hand java application data objects stored heap walked garbage collector started 
heap higher error consumption rate static data area garbage collection 
static memory results injecting errors static data area summarized 
graph mid gray part comprises errors consumed application injected dark gray part comprises errors consumed application don cause application errors application accessed erroneous data executed correctly light gray part illustrates number application errors case application crashes gives wrong result 
susceptibility rates listed table 
size data area kb 
see graph benchmark applica tions exhibit similar behavior 
error consumption rate average 
average memory susceptibility rate 
errors consumed cause errors applications 
static data jess db javac jack susceptibility object heap table susceptibility static data experiment inject errors object heap 
kaffe heap size grows dynamically application need grows 
experiment injected errors range virtual addresses heap occupies 
experiments application heap sizes varied kb kb see table 
heap size jess db javac jack minimum heap size maximum heap size jess db javac jack kb kb kb kb kb kb kb kb table heap size error injection results heap injection summarized appropriate susceptibility rates listed table 
cases application error consumed error injected consumed meaning 
object heap jess db javac jack susceptibility table susceptibility heap application errors errors consumed app error errors injected consumed benchmarks error consumption jvm static data 
percentage jess db javac jack benchmarks application error gc application error gc error consumed error gc errors consumed error gc errors injected consumed error consumption jvm heap region 
observation heap higher error consumption rate 
example jack error consumption rate heap versus static data area 
closer look reveals consumption comes garbage collector 
kaffe uses mark sweep strategies garbage collection 
collection started touches object heap 
wonder consumes errors 
don count errors consumed gc error consumption rate higher static data area 
noted susceptibility depends memory region size 
assume uniform error probability memory area heap size bigger static area conclude heap susceptible static data 
consumption takes place garbage collector relatively errors cause real problems 
reason garbage collector cares object field 
won types fields computations 
object checks valid masks possible errors 
average error consumption gc caused application errors 
comparison static data error consumption caused application errors 
understand source application errors collect object types object error injected 
show result javac 
distinguish objects primitive arrays arrays areas 
example lat percentage injected consumed errors error consumption object type 
area heap objects ref array prim array objects ter areas belong jvm object object freed garbage collector block inside page allocated object 
results indicate errors injected unused parts caused application errors 
may consumed overwriting 
graph see errors injected normal objects objects created new consumed cause application errors application errors caused objects 
see errors injected primitive arrays 
understandable user applications tend store large data sets arrays 
large structures containing particular single errors errors consumed array accesses may rarely erroneous data 
depending application data usage errors primitive arrays may cause application errors error consumption rates indicate 
hand arrays cause application errors false pointer easily cause segmentation fault jvm 
due space limitations details error data types included 
briefly constant fixed objects occupy large percentage heap object part 
objects include data bytecodes constant pool 
total objects occupy objects types 
readonly objects recovery objects types straightforward 
percentage errors jess db javac jack detected errors object array errors happened benchmarks checksum detection application errors checksum silent data corruption detection demonstrate effectiveness scheme detecting silent data corruption implemented prototype kaffe 
compared proposal prototype implementation limitations 
native functions system array copy called simply clear object array checksum validity update checksum result 
limitation don compute checksums large objects deal large arrays 
assume won see large objects java applications java object embedded objects stored 
ran fault injection experiments prototype implementation benchmarks 
recorded cases consumed errors detected 
shows percentage application errors detected error consumed 
light gray areas represent errors detected 
dark gray areas represent errors know took place objects arrays corrected applied checksumming 
applied object big operated native functions easily 
mid gray area comprises cases memory error detected corrected caused application error 
effectiveness detection depends nature application 
objects arrays account actual errors occurring technique effective 
example javac errors objects arrays account nearly error occurrences 
technique detect errors 
percentage errors detected current implementation limited time constraints 
implementation improved updating checksums native function calls array copies 
technique extended including heap objects checksum detection constant pools bytecode sections 
heap objects changed loaded extra checksumming overhead small checks read access required 
compared relative slowdown prototype implementation original kaffe implementation 
interesting see performance overhead induced checksum process 
measured total execution time original kaffe implementation prototype implementation 
relative slowdown compared original version shown table benchmark 
lessons learned jess db javac jack slowdown table vm slowdown detection ptrace tool fault injection experiments 
lets generate data breakpoints kaffe vm track consumption injected errors 
time error consumption breakpoint allows vm examine internal state 
originally thought collecting execution traces study error consumption rate extremely difficult derive vm status time error consumption traces 
course ptrace limitations 
clear successfully study kernel mode errors 
experiment data analysis interesting observations derived kaffe virtual machine java applications running memory errors object heap higher error consumption rate susceptibility rate static data area 
heap size larger static data size 
assume uniform error distribution draw heap memory dominant part memory susceptibility 
large portion error consumption heap caused garbage collector case jack 
consumption leads application errors consumption vs 
memory errors occurring object heap errors injected normal objects created new arrays caused application errors 
adding simple checksums normally undetected errors detected increasing error coverage 
adding checksums clearly comes performance cost 
unoptimized checksum routine adds functionality increase run time 
optimizing checksum computation platform maximizing explicit parallelism hardware support block checksums help acceptable jit run times 
coverage silent data corruption detection easy increase placing checksums object types static objects 
overhead reduced limiting additional unnecessary checks 
objects java heap relatively large covered checksums 
assumption relaxed experimentation 
needed complete study memory failure recoverability application level 
need extend optimize prototype silent data error corruption implementation handle heap objects including large objects constant pool byte code extensions expect achieve higher error detection rate 
second reduce effect garbage collector detecting errors possible modify memory expect memory errors recover 
similar construction memory task high availability operating systems 
third interesting investigate relationship consumption rates susceptibility 
factors depend largely application workload input understand correlations classifications susceptibility consumption rates 
handling memory errors java java provides elegant exception programming model try catch blocks 
path investigation consider supporting exception mechanism signal memory errors applications interested providing error recovery application state exit 
support may great interest fault tolerant java applications java databases java persistent systems 
memory error occurs affect jvm application integrity 
determining error affected jvm java application fairly complex jvm state stored inside outside heap 
propose possible errors occur jvm data areas outside heap jvm throw asynchronous exception 
similar existing exception 
allow cleaner fail handling redundant machines 
errors vm heap structures serious difficult detect 
sensitive memory small errors seriously affect vm application 
achieve suitable level coverage heap structures need fully updated modifications 
similar error exception raised sufficient detection support 
majority memory errors occur state object 
propose circumstances may possible raise 
large question approach limiting scope handling exception execution 
thread method highlights concerns 
raising exception allow system leave state objects undefined state 
generate exception target prepared handle 
believe possible solutions overcome problems dispatch dependent threads allow informed safer clean exception 
internal vm exception threads prepared handle desire 
handling exception mechanism probably complex application 
proposed limit scope useful application programmers wrap critical code exception handling 
critical sections outgoing rpc rmi access database accesses candidates may hold transactions benefit improved reliability approach 
exceptions occuring times resort exceptions application clean improve graceful exit restart state lost 
clearly support exception handling complex poses challenges performance coverage support 
see research undertaken investigate aspect 
summary described studying memory error susceptibility kaffe virtual machine fault injection 
kaffe vm benchmark applications ran heap objects comprise memory error consumption 
prototype implementation detecting silent data corruptions object checksum 
simple technique detect nearly application errors caused silent data corruption 
experiments executed kaffe interpretive mode 
order kaffe superior performance jit compiler jit need modified generate checksum routine inline object accesses 
errors occur memory possible consider checksumming generated code size proves necessary 
apart kaffe jit behavior reported heap management system 
introducing extra overhead counter today jit research overhead represents upper bound performance loss 
ia architecture performance improved times ability multiple arithmetic units explicitly parallelize computation compared ia architecture processors 
acknowledgments indebted peter markstein commenting context presentation 
help significantly improved document 
arnold gosling holmes java programming language third edition sun microsystems 
bartlett nonstop kernel proceedings eighth symposium operating systems principles asilomar ca pp dec 
brown memory checkpoint rollback recovery ieee computer pp feb 
chen etal surviving operating system crashes proc 
th asplos pp october 
compaq product description tandem nonstop kernel 
download feb www tandem com prod des pd pd htm 
dell white benefits correct ecc pc server main memory ibm microelectronics division nov 
gray reuter transaction processing concepts techniques morgan kaufmann 
intel ia architecture software developer manual volume intel 
intel ia architecture software developer manual volume intel 
kao fine fault injection monitoring environment tracing unix system behavior faults ieee se vol 
november 
kermarrec recoverable distributed shared memory integrating coherence recoverability proc 
th ftcs pp june 
milojicic increasing relevance memory hardware errors case recoverable programming models th acm si european workshop :10.1.1.37.1424
murphy windows dependability proc 
ieee international conference dependable systems networks june 
murphy measuring system software reliability automated data collection process quality reliability engineering intl 
vol pp 
nick cluster technology parallel ibm systems journal vol pp 
pfister search clusters prentice hall 
satyanarayanan lightweight recoverable virtual memory 
proc 
sosp pp dec 
standard performance evaluation 
spec specjvm specification august 
www spec org osg jvm tandem compaq data integrity compaq nonstop servers white 
tweedie designing linux cluster technical white red hat january 
see www linux ha org ziegler ibm experiments soft fails computer electronics ibm journal vol pp jan 
ziegler terrestrial cosmic rays ibm journal research development vol pp january 
