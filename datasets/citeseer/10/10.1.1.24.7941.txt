maintaining stream statistics sliding windows extended datar gionis piotr indyk rajeev motwani consider problem maintaining aggregates statistics data streams respect data elements seen far 
refer model sliding window model 
consider basic problem stream bits maintain count number elements seen stream 
show ffl log bits memory estimate number factor ffl 
give matching lower bound omega gamma ffl log memory bits deterministic randomized algorithms 
extend scheme maintain sum positive integers 
provide matching upper lower bounds general problem 
apply techniques obtain efficient algorithms lp norms vectors sliding window model :10.1.1.102.5483
algorithm basic counting problem adapt techniques sliding window model multiplicative overhead ffl log memory ffl factor loss accuracy 
include maintaining approximate histograms hash tables statistics aggregates sum averages 
applications concept data stream possibly infinite appropriate data set 
nature stored data set appropriate significant portions data queried updates small relatively infrequent 
contrast data stream appropriate department computer science stanford university stanford ca 
email datar cs stanford edu supported part nsf iis microsoft graduate fellowship 
department computer science stanford university stanford ca 
email gionis cs stanford edu supported part nsf iis 
mit laboratory computer science technology square ne cambridge massachusetts 
email indyk theory lcs mit edu department computer science stanford university stanford ca 
email rajeev cs stanford edu supported part nsf iis foundation 
data changing constantly exclusively insertions new elements unnecessary impractical operate large portions data multiple times 
challenging aspects processing data streams length data stream may unbounded making impractical undesirable store entire contents stream applications important retain ability execute queries past data 
order support queries sort bounded amount storage necessary devise techniques storing summary synopsis information previously seen portions data streams 
generally tradeoff size summaries ability provide precise answers queries involving past data 
consider problem maintaining statistics streams regard data elements seen far 
refer model sliding window model 
identify simple counting problem solution prerequisite efficient maintenance variety complex statistical aggregates stream bits maintain count number elements seen stream 
show ffl log bits memory estimate number factor ffl give matching lower bound omega gamma ffl log memory bits deterministic randomized algorithm 
extend scheme maintain sum positive integers 
provide matching upper lower bounds general problem 
apply techniques obtain efficiently algorithms norms vectors sliding window model :10.1.1.102.5483
algorithm basic counting problem adapt techniques sliding window model multiplicative overhead ffl log memory ffl factor loss accuracy 
include maintaining example order detect fraudulent credit card transactions useful able detect pattern transactions particular account differs significantly earlier transactional history account 
approximate histograms hash tables statistics aggregates sum averages 
motivation model related applications naturally generate data streams 
telecommunications example call records generated continuously 
typically processing done examining call record operating window call records update customer billing information records archived examined 
cortes report working long distance call records consisting records day customers 
second application network traffic engineering information current network performance latency bandwidth generated online monitor adjust network performance dynamically 
generally impractical unnecessary process data 
traditional emerging applications data streams play important natural role web tracking personalization streams web log entries medical monitoring vital signs treatments measurements sensor databases financial monitoring name 
applications traditional data treated stream due performance constraints 
data mining applications example volume data stored disk large possible pass small number passes data :10.1.1.32.1927
objective perform required computations stream generated single scan data bounded amount memory recourse indexes hash tables precomputed summaries data 
example data streams generated intermediate results pipelined operators evaluation query plan sql database materializing temporary result pass data possible 
applications goal decisions statistics models gathered observed data elements 
example interested gathering statistics packets processed set routers day 
maintain statistics continuous fashion 
gives rise sliding window model data elements arrive instant expire exactly time steps portion data relevant gathering statistics answering queries set elements arrive 
sliding window refers window active data elements time instant 
previous stream computations addresses problems approximating frequency moments computing differences streams :10.1.1.102.5483
maintaining histograms :10.1.1.29.634
jagadish address line version computing optimal histograms guha koudas give technique maintaining near optimal time histograms streaming data :10.1.1.29.634
queries supported histograms constructed range point queries time attribute 
earlier underlying model data elements seen far relevant 
believe sliding window model important applications interested gathering statistics outdated data 
maintaining statistics sum average histograms hash tables frequency moments differences sliding windows critical applications 
knowledge previous addressing problems sliding window model 
summary results focus sliding window model data streams 
formulate basic counting problem solution building block solving problems mentioned earlier 
problem 
stream data elements consisting maintain time instant count number elements 
easy verify exact solution requires theta bits memory 
applications prohibitive omega gamma memory 
instance consider network management application large number data packets pass router second 
applications suffices produce approximate answer 
goal provide approximation memory 
section provide solution uses ffl log bits memory equivalently ffl log buckets size log provides estimate answer instant ffl factor actual answer 
algorithm require priori knowledge caters possibility window size changed dynamically 
algorithm guaranteed log memory long window size bounded algorithm takes log note measure space complexity terms number bits number memory words 
worst case time process new data element arrival amortized time element 
count queries processed time 
algorithm relatively simple easy implement 
section presents matching lower bound 
show approximation algorithm deterministic randomized relative error ffl omega gamma ffl log bits memory 
proves algorithm optimal terms memory usage 
section extend technique handle data elements positive integer values just binary values referred sum problem 
provide matching upper lower bounds memory usage general problem 
section show techniques sketching techniques indyk efficiently maintain norms vectors sliding window model :10.1.1.102.5483
section provides brief discussion application sum algorithms adapting problems sliding window model maintaining histograms hash tables statistics aggregates averages sums 
reduction problems entails multiplicative overhead ffl log memory ffl factor loss accuracy 
discuss problems min max distinct values 
algorithm approach solving problem maintain histogram records timestamp selected active belong elements 
call histogram exponential histogram eh reasons clear 
getting details algorithms need introduce notation 
follow conventions illustrated 
particular assume new data elements coming right elements left ones seen 
note data element arrival time increments arrival leftmost element considered arrived time 
addition employ notion timestamp corresponds position active data element current window 
timestamp active data elements right left element position 
clearly timestamps change new arrival wish explicit updates 
simple solution record arrival times counter log bits timestamp extracted comparison counter value current arrival 
mentioned earlier concentrate data stream 
refer th mean th encountered data stream 
maintain histograms active data stream 
bucket histogram keep timestamp called timestamp number called bucket size 
timestamp bucket expires reaches longer interested data elements contained drop bucket reclaim memory 
bucket active guaranteed contains single expired 
instant bucket bucket containing may expired 
time instant may produce estimate number active follows 
bucket add number 
bucket count number bucket 
actual number active bucket estimate 
obtain fact 
absolute error estimate size bucket 
note approach window size fixed priori window size calculate expiry time thing bucket bucket largest timestamp expire time 
approximation scheme define exponential histograms technique maintain guarantee count estimates relative error ffl ffl 
define ffl assume integer integer replace affecting basic results 
fact absolute error estimate size bucket 
size th bucket know true count gamma bucket contains remaining buckets contribute exactly size total count 
relative estimation error cm gamma 
ensure relative error maintaining invariant invariant 
times bucket sizes cm gamma number active instant 
bucket sizes satisfy 

arrival time increasing time 
elements current time instance 
increasing ordering data elements histogram buckets active data elements seen timestamps window active elements 
illustration notation conventions followed 
order satisfy invariant buckets possible maintain buckets exponentially increasing sizes satisfy second invariant 
invariant 
times bucket sizes nondecreasing delta delta delta cm gamma cm bucket sizes constrained log 
size bucket bucket size size bucket bucket size 
size th bucket 
invariant satisfied guaranteed buckets sizes gamma indexes consequently gamma 
follows invariant satisfied invariant automatically satisfied 
maintain invariant easy see cover active require log buckets 
associated bucket size timestamp 
bucket size takes log values maintain log log bits 
timestamp requires log bits total memory requirement bucket log log log bits 
total memory requirement bits eh ffl log 
implied maintaining invariant guaranteed desired relative error memory bounds 
query time eh 
achieve maintaining counters size bucket sum sizes buckets total 
estimate total minus half 
counters updated time data element 
detailed description update algorithm 
algorithm insert 
new data element arrives calculate new expiry time 
timestamp bucket indicates expiry delete bucket update counter containing size bucket counter total containing total size buckets 

new data element ignore create new bucket size current timestamp increment counter total 

traverse list buckets order increasing sizes 
buckets size merge oldest buckets single bucket double size 
merger buckets size may cause number buckets size exceed leading cascade mergers 
update counter bucket result new merger 
example 
illustrate algorithm steps 
assume current bucket sizes left right 
new arrives older merged bucket sizes 
arrive merging cascades buckets size get buckets sizes 
merging buckets corresponds creating new bucket size equal sum sizes buckets timestamp timestamp older bucket 
merger requires time 
cascading may require theta log mergers arrival single new element standard arguments allow argue amortized cost mergers new data element 
obtain theorem theorem 
eh algorithm maintains data structure give estimate problem relative error ffl log buckets ffl memory requirement log log log bits bucket 
arrival new element processed amortized time logn worst case time 
time instant data structure provides count estimate time 
maintaining timestamp bucket maintain timestamp bucket maintain difference timestamps successive buckets reduce total memory requirement log 
lower bounds provide lower bound verifies eh algorithm optimal memory requirement 
start deterministic lower bound omega gamma log 
theorem 
deterministic algorithm provides estimate problem time instant relative error integer requires log bits memory 
proof argument go follows 
show large number arrangements deterministic algorithm provides estimates small relative error differentiate pair arrangements 
number memory bits required algorithm exceed logarithm number arrangements 
argument formalized lemma 
lemma 
exist gamma delta blog arrangements length deterministic algorithm relative error differentiate arrangements 
proof 
partition window size blocks size right left blog gamma 
consider th block size subdivide contiguous sub blocks size block choose sub blocks populate placing remaining positions 
block gamma delta possible ways place total number distinct arrangements gamma delta blog bc argue deterministic algorithm relative error differentiate pair arrangements 
words exists pair arrangements deterministic algorithm differentiate time interval arrangements different answers problem algorithm give relative error 
assume algorithm arrangements length followed sequence length refer illustration pair arrangements differentiated deterministic algorithm relative error consider algorithm differentiate arrangements numerical sequences blog gamma encode arrangements 
th number sequence specifies choice sub blocks th block populated 
sequences distinct arrangements encoded distinct 
index point sequences differ arrangements different choice sub blocks th block 
number sub blocks block right left highest numbered sub block chosen arrangements say consider time instant sub block expires 
instant number active sub blocks block arrangement number active sub blocks block 
arrangements followed sequence time correct answer gamma correct answer gamma 
algorithm give absolute error gamma arrangements translates relative error point time 
prove theorem observe choose nk log log extend lower bound space complexity randomized algorithms 
proofs theorems omitted 
follow easily yao minimax principle lemma 
theorem 
randomized las vegas algorithm relative error integer requires log bits memory 
theorem 
randomized monte carlo algorithm problem relative error integer prob rel error block block block ax ay 
pair arrangements differentiated deterministic algorithm relative error 
ability gamma ffi ffi requires log gamma log gamma ffi bits memory 
consider extension case elements positive integers problem 
sum stream data elements positive integers range maintain time instant sum elements 
assume log 
realistic assumption simplifies calculations 
generalize eh setting follows 
view arrival data element value arrival data elements value time employ insertion procedure 
note algorithm section require distinct timestamps required nondecreasing 
earlier active nr 
ffl results section imply eh require log nr buckets 
bucket require log log log log bits memory store timestamp size bucket 
note distinct timestamps point bucket sizes take log log distinct values 
number memory bits required ffl log log log 
catch appears need omega gamma time insertion 
rest section devoted devising scheme requires log log amortized time logn log worst case time insertion 
note poly amortized insertion time worst case time logn 
total size buckets time instant 
log nr sequence denotes number buckets size invariant 
sequence satisfying conditions called canonical representation algorithm represents valid sum canonical form 
claim canonical representation sum unique computed time log 
lemma 
canonical representation positive number unique 
proof 
give proof contradiction 
assume distinct canonical representations loss generality assume smallest index sequences differ 
happen agree indices equal second sequence nonzero components indices greater sum 
case gamma gamma contradiction gamma 
case sequence nonzero indices greater representations give sum 
happen strictly greater sum 

index jk gamma implies gamma ij gives contradiction 
procedure computes canonical representation time logs 
procedure canonical find largest gamma gamma find 
set guaranteed gamma gamma binary representation set canonical representation tells exact positions buckets start 
note multiple belong data element may multiple buckets starting single data element implying multiple buckets timestamp 
observation critical incremental maintenance buckets 
algorithm section guarantees certain data element case active indexed certain time interval indexed 
indexed mean element bucket timestamp maintained timestamp bucket 
time progresses buckets may get merged data elements may indexed 
happens element indexed time gets indexed 
preceding observation allows devise scheme incrementally maintain buckets small amortized update time 
assume know buckets certain time instant 
think data element series 
buffer new elements separately maintain sum elements eh updated steps 
period query answered combination eh buffer sum 
buffer gets full delete expired buckets eh 
expired buckets deleted sum sizes active buckets 
sum elements buffer 
calculate canonical representation determine positions new buckets 
requires log logn log time nr 
create new buckets timestamps values elements buffer timestamps sizes old buckets 
total time required process elements buffer log log time suffices maintain buffer sum number buckets new histogram log log 
time required construct new histogram log log amortized update time element log log 
choosing theta log amortized update time log log worst case time logn log 
buffer needs log logn log memory bits memory requirement eh 
note poly amortized update time worst case time log 
obtained memory upper bound ffl log log log bits summarized theorem 
theorem 
generalized eh sum problem maintains data structure provides estimates relative error ffl log nr buckets ffl memory requirement log log log log bits bucket 
arrival new element processed log log amortized time logn log worst case time 
time instant data structure provides sum estimate time 
prove lower bound omega gamma ffl log log log bits 
log omega gamma lower bound section applies 
need consider case assume log fact assume log 
consider arrangements 
break window size log blocks size log consider th block log choose log positions place element value setting elements 
argument similar section deterministic algorithm relative error differentiate arrangements 
total number arrangements gamma log delta log log log number memory bits required log log log omega gamma ffl log log log 
assume log ffi ffi 
note lower bounds apply randomized algorithms provide approximate answer 
computing norms vectors extend eh technique combine sketching technique indyk compute norms vectors sliding window model 
assume window broken smaller contiguous buckets 
numbered right left denoted bm consider function defined intervals properties 
poly jb 
concatenation adjacent buckets constant 
function admits sketch requires jbj space composable sketch composed efficiently sketches 
function admits properties efficiently estimate sliding windows eh technique 
maintain buckets invariants associate bucket timestamp sketch 
invariant 
bn cf 
invariant 
bn bn 
observation estimate function current window composing sketches earliest leftmost bucket 
leftmost bucket may certain expired data elements suffix data elements active 
part suffix leftmost bucket active ignored contribute estimate 
concatenation buckets sketch compose sketches individual buckets 
current window exact answer 
estimate answer underestimate 
relative error bx gammaf bx 
bx gammaf cf bx gammaf cf bx gamma cf bn gamma gamma invariant observation invariant property imply number buckets log size window 
memory required maintain time stamp sketches buckets log logn 
maintain invariants timestamp sketches estimate function relative error gamma log log memory bits 
maintain invariants timestamp sketches new data elements added 
algorithm similar eh 

new data element arrives calculate new expiry time 
timestamp bucket indicates expiry delete bucket 

create new bucket just new data element 

traverse list buckets right left 
invariant violated pair buckets bn bn merge new bucket sketch bucket composed sketches bn bn may need merge 
argue algorithm maintains invariant invariant 
adding new bucket violate invariant increase size suffix 
invariant violated buckets involved satisfy bn bn 
merge property guarantees cf invariant valid new bucket algorithm may need lot merges number buckets log 
amortized time 
omit details dealing fact function window size may greater bounded constant theorem 
function properties estimated sliding windows relative error gamma log log bits memory 
norms argue norms vectors restricted model admit properties efficiently computed sliding windows :10.1.1.102.5483
consider restricted model data element pair gamma represents increment ith dimension underlying vector 
window represents vector norm aj note case sum problem 
denote estimate :10.1.1.102.5483
function clearly admits properties 
admits sketching technique requires log log ffi ffl memory bits sketch composable 
technique requires log log ffi log ffi ffl random bits common sketches 
see theorem 
sketches computing function exact 
provide approximation relative error ffl probability gamma ffi setting accuracy parameter ffl correctly sure algorithm works probabilistic manner relative error ffl ffl function ffl 
proves restricted model compute relative error ffl log logn log log ffi ffl bits memory 
estimate probabilistically approximately correct 
note computing small relative error translates computing small relative error 
lower bounds sum problems special cases computing norms underlying vector single dimension 
lower bounds problems apply problem computing norm 
note upper bounds obtained section match lower bounds 
norm defined distinct value problem deal problem section 
applications briefly discuss eh algorithm building block adapt techniques sliding window model multiplicative overhead ffl log memory ffl factor loss accuracy 
basic idea adapt sliding window setting scheme relying exact counters positive integers eh play role counter 
counter required omega memory bits eh requires ffl log memory bits maintains count ffl error 
hash tables simplest case 
data element gets hashed bucket 
maintaining counter bucket eh maintain approximate counts number data elements hashed bucket data elements stream 
works required maintain count elements hash bucket 
sums averages section showed maintain sum positive integer data elements generalized version eh 
requires ffl log log log bits memory 
maintaining sum require log log bits multiplicative overhead ffl log 
maintaining averages similar 
histograms bucket boundaries histogram maintain sum average statistics corresponding bucket generalized eh 
finding optimal bucket boundaries optimize memory requirement orthogonal problem 
equi width histograms natural choice histograms bucket boundaries fixed 
note histograms discussed time histograms attribute data :10.1.1.29.634
min max prove lower bound memory requirement algorithm maintains min max sliding window 
lower bound counting argument prove lower bound 
data elements drawn set distinct numbers 
consider nondecreasing arrangements numbers 
number arrangements gamma delta deterministic algorithm gives correct answer time instant differentiate arrangements 
arrangements different minimum place differ left right 
lower bound number memory bits required log gamma delta log 
lower bound valid randomized algorithms arguments similar section 
poly lower bound says store elements 
easiest way maintain exact minimum sliding windows maintain list pairs value timestamp value timestamp strictly increasing 
scheme worst case space requirement log bits 
data elements arrive random order expected space complexity logn log 
distinct values dit easy adapt technique flajolet martin estimate number distinct elements data elements 
probabilistic counting technique maintains bitmap size log upper bound number distinct values data set 
case sliding windows bitmap size log suffices 
maintain bit timestamp size logn 
bit re set data element update timestamp data element 
enables keep track bits set elements 
consequently estimate number distinct elements expected relative accuracy log bits memory 
note lower bound problem applies distinct value problem 
instance problem create input mapped mapped distinct value arrival time element instance 
number distinct values number ones 
reduction shows lower bounds problem apply distinct value problem 
alon matias szegedy 
space complexity approximating frequency moments 
proc 
eighth annual acm symposium theory computing 
cortes fisher pregibon rogers 
hancock language extracting signatures data streams 
proc 
acm sigkdd pp 

chaudhuri motwani narasayya 
random sampling joins 
proc 
acm sigmod pp 

fang garcia molina motwani shivakumar ullman 
computing iceberg queries efficiently 
proc 
th international conference large data bases vldb 
feigenbaum kannan strauss viswanathan 
approximate difference algorithm massive data streams 
proc 
th symposium foundations computer science 
flajolet martin 
probabilistic counting 
proc 
th symposium foundations computer science 
moon diot lyles tobagi 
architecture passive monitoring system backbone ip networks 
technical report tr atl sprint labs 
guha koudas shim :10.1.1.29.634
data streams histograms 
appear proc 
third annual acm symposium theory computing 
guha mishra motwani callaghan 
clustering data streams 
proc 
annual ieee symp 
foundations computer science pages 
henzinger raghavan rajagopalan 
computing data streams 
technical report tr compaq systems research center palo alto california may 
indyk 
stable distributions pseudorandom generators embeddings data stream computation 
proc 
st symposium foundations computer science 
jagadish koudas muthukrishnan poosala sevcik suel 
optimal histograms quality guarantees 
proc 
th international conference large data bases vldb 
motwani raghavan 
randomized algorithms 
cambridge university press 
netflow services applications 
whitepaper cisco systems 
available www cisco com warp public cc pd tech wp htm 
