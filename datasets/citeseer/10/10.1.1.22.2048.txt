randomization graph optimization problems survey david karger june randomization pervasive technique combinatorial optimization 
survey thesis subsequent uses common randomization techniques attack numerous optimization problems undirected graphs 
randomization pervasive technique combinatorial optimization 
randomization develop algorithms faster simpler better performing previous deterministic algorithms 
article surveys thesis kar presents randomized algorithms numerous problems undirected graphs 
uses important randomization techniques random selection lets easily choose typical element set avoiding rare bad elements random sampling provides quick way build small representative subproblem larger problem quick analysis randomized rounding lets transform fractional problem solutions integral ones monte carlo simulation lets estimate probabilities interesting events 
mit laboratory computer science cambridge ma 
email karger lcs mit edu url theory lcs mit edu karger 
supported part arpa contract nsf contract ccr fellowships alfred sloane david packard foundations 
apply techniques numerous optimization problems undirected graphs 
graph common structures computer science optimization modeling things roads communication transportation networks electrical circuits relationships individuals hypertext collections resource allocations project plans database program dependencies parallel architectures 
graph problems address finding minimum spanning tree finding maximum flow determining connectivity minimum cut graph network design graph coloring estimating reliability disconnection probability network random edge failures 
great deal done problems 
due space limitations unable discuss related 
discussion thesis 
extremely important note carrying expected case analysis algorithms running random inputs 
consider worst case inputs random choices algorithm solve efficiently 
article survey applications randomization techniques sketching methods problems resulting algorithms 
detailed discussion algorithms proofs hopefully give flavor 
notation address undirected graphs directed graphs far techniques apply 
discussion consider graph edges vertices 
graph edge may weight reflecting cost capacity associated 
simplify presentation focus unweighted graphs graphs edge weights equal algorithms apply equally weighted graphs 
parallel edges multiple edges endpoints graph gamma delta notation denotes log constant overview results show randomization ways problems varying degrees difficulty 
easy solve minimum spanning tree problem long line research resulted closer linear time algorithms random sampling gives final small increment truly linear time algorithm 
harder problems improves running times significant factor 
example improve time needed find minimum cuts mn give efficient parallel algorithm problem 
addressing hard np complete problems network design graph coloring finding exact solution polynomial time thought hopeless randomized rounding give better approximation algorithms previously known 
problem determining reliability network complete problem thought harder np complete ones monte carlo simulation give efficient approximation algorithm 
randomized algorithms deals randomized algorithms 
typical model algorithm source random bits variables mutually independent take values probability 
extracting random bit source assumed take constant time 
algorithms complex operations flipping biased coins generating samples complex distributions take account time needed simulate operations unbiased bit model 
event probabilities taken sample space random bit strings produced random bit generator 
event occurs high probability problems size occurs probability greater gamma constant low probability complement occurs high probability 
random choices algorithm affect running time correctness 
algorithm fixed deterministic running time low probability giving incorrect answer called monte carlo mc 
running time algorithm random variable correct answer certainty algorithm said las vegas lv 
depending circumstances type algorithm may better 
las vegas algorithm stronger sense 
las vegas algorithm monte carlo having terminate arbitrary wrong answer exceeds time bound 
las vegas algorithm exceed time bound converted algorithm give wrong answer 
hand universal method making monte carlo algorithm las vegas algorithms monte carlo las vegas version apparent 
fundamental problem impossible check algorithm correct answer 
failure probability monte carlo optimization algorithm arbitrarily small repeating times best answer shall see examples 
particular reduce failure probability far unavoidable events power failure incorrect answer 
survey techniques results section provide high level overview randomization techniques various algorithms able develop 
random selection simplest randomization technique discuss random selection 
intuition idea single randomly selected individual probably typical representative entire population 
random selection provides way avoid choosing rare bad elements 
idea quicksort hoa assumption randomly selected pivot extremely large extremely small serve separate remaining elements roughly equal sized groups 
apply idea new algorithm finding minimum cuts undirected graphs 
cut partition graph vertices groups value cut number total weight edges endpoint group 
minimum cut problem identify cut minimum value 
distinguish global minimum cut minimum cut required separate specific vertices finding minimum cuts great importance analyzing network reliability plays role solving traveling salesman network design problems 
recursive contraction algorithm joint clifford stein ks 
idea algorithm simple randomly selected edge cross particular minimum cut endpoints probably side 
merge vertices side minimum cut affect minimum cut reduce number graph vertices 
find minimum cut repeatedly selecting random edge merging endpoints vertices remain minimum cut obvious 
efficient implementation idea leads strongly polynomial time algorithm minimum cut problem weighted undirected graphs 
contrast best deterministic bound due hao orlin ho mn 
algorithm finds minimum cuts high probability 
extends enumerating approximately minimum cuts minimum way cuts constant constructing cactus graph compact representation minimum cuts 
algorithm theoretically parallelization 
derandomization algorithm joint rajeev motwani km gave proof fast deterministic parallel algorithm minimum cut problem 
implementation experiment shows algorithm reasonable time bounds practice cgk 
contraction algorithm monte carlo gives correct answer high probability small chance wrong 
unaware algorithm verifying cut minimum unable devise las vegas version algorithm 
case willingness occasionally wrong provide significant speedup 
contraction algorithm gives important new bound number small cuts graph may contain important applications network reliability analysis graph sampling see 
subsequent bk contraction algorithm efficiently solve graph augmentation problem adding minimum possible capacity graph increase minimum cut value joint ur 
random sampling general randomization random selection generate small representative subproblems 
representative random sample central concept statistics 
possible gather great deal information large population examining small sample randomly drawn 
approach obvious advantages reducing investigator gathering analyzing data 
optimization problem may possible generate small representative subproblem random sampling natural sample graph random subset edges 
intuitively subproblem form microcosm larger problem 
goal examine subproblem glean information original problem 
subproblem small spend proportionally time examining spend examining original problem 
approach frequently optimal solution subproblem may nearly optimal solution problem 
situations approximation sufficient 
situations may easy refine solution truly optimal solution 
floyd rivest fr approach fast elegant algorithm finding median ordered set 
select small random sample elements set show inspecting sample gives accurate estimate value median 
easy find actual median examining elements close estimate 
algorithm simple implement uses fewer comparisons known median finding algorithm 
floyd rivest algorithm components needed algorithm 
definition randomly sampled subproblem 
second approximation theorem proves solution subproblem approximate solution original problem 
components typically yield obvious approximation algorithm speed accuracy tradeoff 
third component refinement algorithm takes approximate solution turns actual solution 
combining components yield algorithm running time determined refinement algorithm intuitively refinement easier computing solution scratch 
application approach randomized lineartime algorithm finding minimum spanning trees comparison model computation 
result reflects joint philip klein robert tarjan kkt 
long stream results reduced best known deterministic time bound linear linear time bound remained elusive 
fundamental insight construct subgraph graph random sample graph edges minimum spanning tree subgraph nearly minimum spanning tree entire graph 
precisely graph edges improve sample minimum spanning tree 
examining edges refine approximation actual minimum spanning tree little additional cost 
apply sampling minimum cut problem related problems involving cuts graphs including maximum flows 
maximum flow problem widely studied graph optimization problems having hundreds applications 
vertices capacitated edges goal ship maximum quantity material exceeding capacities edges 
value graph maximum flow completely determined value minimum cut graph 
prove cut sampling theorem says choose half graph edges random approximately halve value cut 
particular halve graph connectivity value minimum cuts maximum flows 
theorem gives random sampling scheme approximating minimum cuts maximum flows compute minimum cut maximum flow random sample graph edges 
sample fewer edges computation faster 
time sampling theorems show approach gives accurate estimates correct values 
want get exact solutions approximations samples starting points apply inexpensive refinement algorithms 
leads simple randomized divide conquer algorithm finding exact maximum flows 
put results graph sampling larger framework examining sampling matroids kar 
generalize minimum spanning tree algorithm problem finding minimum cost matroid basis extend cut sampling maximum flow results problem matroid basis packing 
techniques give paradigm applied packing problem goal collection feasible subsets universe find maximum collection disjoint feasible subsets 
example maximum flow problem attempting send units flow unit flow travels path feasible edge sets paths 
apply sampling paradigm problem packing disjoint bases matroid get faster algorithms approximating exactly finding optimum basis packings 
continued apply random sampling technique thesis 
results include ffl log time monte carlo algorithm finding minimum cuts kar ffl compression algorithm lets transform undirected graph graph edges roughly cut values speeding algorithm depends cut values bk ffl application log time monte carlo algorithm finding constant factor approximation minimum cut bk ffl time las vegas algorithm finding constant factor approximation max flow kar ffl time algorithm finding maximum flow simple uncapacitated graph kl joint matt levine 
bounds significantly better best general time bound finding maximum flows directed graphs mn strongly polynomial bound gt log scaling algorithm goldberg rao gr 
suggests better bound maximum flow achieved undirected graphs 
randomized rounding powerful randomization technique randomized rounding 
approach find approximate solutions np hard integer programs 
problems typically ask assignment values variables linear constraints form satisfied 
relax integer program allowing take real value get linear program solved polynomial time giving values raghavan thompson rt observed treat resulting values probabilities 
randomly set probability expected value raghavan thompson techniques ensuring randomly chosen values fact yield sum near expectation giving approximately correct solutions integer program 
view randomized rounding way sampling randomly large space answers subproblems 
linear programming relaxation construct answer space answers ones 
graph sampling theorems apply randomized rounding network design problems 
problem specified input graph edge assigned cost 
goal output subgraph satisfying certain connectivity requirements minimum cost measured sum costs edges 
requirements described specifying minimum number edges cross cut formulation easily captures classic problems including perfect matching minimum cost flow steiner tree minimum join 
applying randomized rounding improve approximation bounds large class network design problems log due goemans ggp cases 
graph sampling theorems provide necessary tools showing randomized rounding works case 
apply randomized rounding classic graph coloring problem 
linear programs devised provide useful fractional solution powerful semidefinite programming starting point 
show colorable graph colored polynomial time colors improving previous best bound blu 
give presently best results colorable graphs 
way discover new properties lov asz function object received great deal attention connections graph coloring cliques independent sets 
joint rajeev motwani madhu sudan kms 
gave slight improvement avrim blum bk 
monte carlo estimation randomization technique consider monte carlo estimation 
technique applied want estimate probability event probability space 
monte carlo estimation carries repeated trials samples probability space measures fraction trials event occurs 
gives natural estimate event probability 
monte carlo approach breaks interesting probability small 
estimate need carry experiments see occurrences expect see occurrence trials may carry efficiently 
solution problem explored karp luby madras klm carry monte carlo simulation different biased way event occur get fewer trials 
trick choose new simulation gives useful information original probability space 
apply technique network reliability problem 
problem interested estimating probability network disconnected random edge failures unsurprising randomization useful 
graph edges fail randomly independently certain specified probabilities 
goal determine probability graph disconnected edge failures 
unfortunately known hard worse np hard exactly determine reliability network 
monte carlo methods give fully polynomial randomized approximation scheme network reliability problem kar 
failure probability edges algorithm time polynomial ffl returns number estimates probability fail graph disconnected 
high probability range sigma ffl fail 
algorithm monte carlo meaning approximation correct high probability possible verify correctness 
generalizes case edge failure probabilities different computing probability graph fails connected fixed general problem approximating tutte polynomial large family graphs 
algorithm easy implement appears satisfactory time bounds practice kar cgk kt 
natural way estimate network failure probability carry numerous simulations edge failures check graph disconnected 
mentioned take prohibitively trials failure probability extremely small 
cut counting sampling theorems prove small small cuts graph significantly fail 
cut algorithms enumerate small cuts biased monte carlo technique developed karp luby madras klm estimate probability explicitly enumerated cuts fails 
contraction algorithm give flavor results describing algorithm finding minimum cut undirected graph ks 
simplicity discuss unweighted graphs algorithm works equally graphs edge weights 
algorithm idea contracting edges 
suppose able identify edge cross minimum cut 
tell endpoints side cut 
information simplify graph contracting endpoints 
contract vertices replace vertex set edges incident union sets edges incident merge edges endpoint allow multiple instances edges 
remove self loops formed edges originally connecting formally delete edges replace edge edge 
rest graph remains unchanged 
denote graph edge contracted contracting edge mean contracting endpoints edge 
note contraction reduces number graph vertices 
imagine repeatedly selecting contracting edges vertex merged remaining 
define cut original graph side corresponds vertices contained 
easy see contract edge crosses minimum cut correspond sides minimum cut looking 
subgoal devise method selecting edge cross minimum cut 
sophisticated deterministic algorithms doing ni unfortunately slow 
rely observation edges graph cross minimum cut 
choose random edge contract probably get non mincut edge 
gives fast edge selection algorithm trade prepared occasionally mistakes 
describe algorithm 
assume initially multigraph vertices edges 
contraction algorithm described repeatedly chooses edge random contracts 
algorithm contract repeat vertices choose edge uniformly random return unique cut defined contracted contraction algorithm relatively straightforward implement algorithm time 
lemma 
particular minimum cut returned contraction algorithm probability gamma delta gamma proof 
fix attention specific minimum cut crossing edges 
term minimum cut edge refer edges crossing select minimum cut edge contraction algorithm vertices define minimum cut 
observe contraction minimum cut value new graph cut contracted graph corresponds cut value original graph value furthermore contract edge cross cut corresponds cut value corresponding cut minimum cut value contracted graph 
time contract edge reduce number vertices graph 
consider stage graph vertices 
contracted graph minimum cut minimum degree rc edges 
edges minimum cut 
randomly chosen edge minimum cut probability determine probability contract minimum cut edge simply multiply stage probabilities 
shows probability contract minimum cut edge gamma contractions gamma gamma gamma delta delta delta gamma gamma gamma gamma delta delta delta gamma note gamma delta gamma contraction algorithm described relatively small chance succeeding 
large useful 
improve chance success may simply repeat algorithm large number times 
run contraction algorithm ln times take best answer see probability fail give right answer just probability repetitions algorithm yield right answer gamma ln means algorithm works high probability 
amplification repetition standard randomized algorithms get exponential decrease failure probability linear slowdown running time 
contraction algorithm takes time iteration immediately get algorithm finds minimum cut high probability log time 
somewhat unsatisfactory algorithms flow ho find minimum cut mn time 
recursive contraction algorithm adding idea improve running time minimum cut algorithm 
aim share numerous iterations algorithm 
note failure probability contraction algorithm rises size decreases 
fact contract vertices probability algorithm destroy minimum cut exceeds follows truncating product analyze original contraction algorithm 
real problem contraction algorithm arises graph gotten small 
imagine switching deterministic algorithm graph small approach yields improved performance 
better application principle repetition improves chances 
graph gets small order improve odds success recursively carry executions algorithm remains 
contract denote subroutine runs contraction algorithm reduced vertices 
consider recursive contraction algorithm 
seen perform independent trials 
partially contract graph likelihood cut surviving small 
contracting graph vertices ensure probability contracting minimum cut edge expect average attempts avoid contracting minimum cut edge 
recursively apply algorithm partially contracted graphs 
described algorithm returns cut value easily modified return cut value 
alternatively want output cut encountered hoping enumerate minimum cuts 
analyze running time algorithm 
lemma 
algorithm recursive contract runs log time 
algorithm recursive contract input graph size vertices return weight unique cut repeat twice contract recursive contract 
return smaller resulting values 
recursive contraction algorithm proof 
level recursion consists independent trials contraction vertices followed recursive call 
performing contraction vertices implemented algorithm contract previous section time 
recurrence running time jj recurrence solved log analyze probability algorithm finds particular minimum cut looking 
say recursive contraction algorithm finds certain minimum cut minimum cut corresponds leaves algorithm tree recursive calls 
note algorithm finds minimum cut output minimum cut value 
lemma 
recursive contraction algorithm finds particular minimum cut probability omega gammai log 
proof 
give recursive argument 
algorithm find particular minimum cut iterations things happen call contract preserves minimum cut ii recursive call finds particular minimum cut 
probability iteration succeeds just product probabilities events ii 
algorithm succeeds iteration succeeds fails iterations fail 
probability double failure happens just square probability iteration fails 
success probability minus squared quantity 
yields recurrence lower bound probability success graph size gamma gamma solve recurrence change variables 
write gamma 
plugging recurrence solving yields clearly follows induction theta log theta log words trial recursive contraction algorithm finds particular minimum cut probability omega gamma log 
familiar branching processes see evaluating probability extinction contracted graphs containing minimum cut occur depth log theorem ks 
minimum cuts arbitrarily weighted undirected graph vertices high probability log time 
proof 
see gamma delta minimum cuts graph 
repeating recursive contract log times gives chance missing particular minimum cut 
chance missing gamma delta minimum cuts upper bounded gamma delta delta gamma 
counting cuts serving algorithm find minimum cuts contraction algorithm tells interesting things number minimum generally small cuts graph 
results extremely useful consider topic random sampling graphs 
definition 
ff minimum cut cut value ff times global minimum cut 
lemma 
gamma delta minimum cuts 
proof 
showed contraction algorithm outputs minimum cut probability gamma delta gamma suppose minimum cuts 
output probability output events disjoint algorithm outputs cut probability output just sum individual probabilities gamma delta quantity probability 
gamma delta theorem cut counting ks 
graph minimum cut ff cuts value ffc 
proof 
consider cut value ffc prove generalizing argument gave minimum cuts obvious way contraction algorithm outputs probability ff argument proceeds previous lemma 
random sampling far addressed random selection works finding typical element non min cut edge 
turn random sampling goal build small representative model input problem 
describe algorithms approximating exactly finding maximum flows minimum cuts undirected graph 
simplicity restrict discussion graphs unit capacity edges unweighted graphs techniques discuss applied weighted graphs 
due space limitations focusing thesis improvements algorithms minimum cut graph large 
unweighted graphs maximum flow problem find maximum set packing edge disjoint paths 
known ff value flow equal value minimum cut 
fact known algorithms finding minimum cut simply identify cut saturated maximum flow 
unweighted graphs classic algorithm finding maximum flow augmenting path algorithm cf 
tar amo 
graph flow value linear time depth search called residual graph show augment flow value prove value maximum flow 
algorithm find maximum flow value mv time finding augmenting paths 
course algorithm running time depends edge count flow value faster reducing quantities 
show random sampling 
sampling theorem algorithms model random sampling graphs 
unweighted graph sampling probability edge construct random subgraph skeleton vertices placing edge skeleton independently probability denote skeleton 
note cut edges crossing expected number edges crossing cut pk 
particular minimum cut value expect minimum cut value pv 
unfortunately samples invariably deviate expectations 
order effectively skeleton need show deviations small 
skeleton tell things original graph approximately correct 
minimum cut graph main theorem says long pc minimum expected cut value skeleton sufficiently large cut skeleton takes roughly expected value 
theorem kar 
ffl ln pc theta ln ffl 
ffl probability gamma cut value gamma ffl ffl times expected value 
result somewhat surprising 
graph exponentially gamma cuts 
naively cut deviate far expected value cuts probably 
saved cut counting theorem discussed previous section 
central limit theorem quantified chernoff bound che says expected value sample gets larger sample value tightly concentrated expectation 
particular cut value grows probability deviating ratio ffl expectation decays exponentially cut value 
cut counting theorem says number cuts value increases exponentially cut value 
parameters theorem chosen exponential decrease deviation probability dominates exponential increase number cuts 
applications show skeleton approach applied minimum cuts maximum flows 
definitions definition 
ff minimum cut cut value ff times value minimum cut 
ff maximum flow flow value ff times optimum 
immediate extension theorem theorem 
graph minimum cut theta ln ffl theorem 
suppose minimum cut value high probability minimum cut value gamma ffl pv ffl pv minimum cut value gamma ffl pc ffl pc 
corollary 
assuming ffl min cut corresponds ffl minimum cut proof 
assuming theorem holds minimum cut sampled cut value ffl 
minimum cut larger 
previous theorem minimum cut corresponds cut value ffl gamma ffl 
ffl ffl 
means augmenting paths find maximum flows skeleton find faster original graph reasons sampled graph fewer edges value maximum flow smaller 
maximum flow skeleton reveals minimum cut skeleton corresponds near minimum cut original graph 
extension idea lets find near maximum flows randomly partition graph edges groups skeleton find maximum flows group merge skeleton flows flow original graph 
furthermore approximately maximum flow turn maximum flow small number augmenting path computations 
leads algorithm called finds maximum flow mv log time improving basic augmenting paths algorithm large 
subsections detail algorithms just sketched 
lead straightforward algorithms 
approximate minimum cuts obvious application theorem approximate minimum cuts 
find approximate minimum cut finding minimum cut skeleton 
lemma 
graph minimum cut ffl approximation minimum cut value computed mv ffl time low probability error 
proof 
ffl determine corresponding theta log ffl theorem 
suppose compute maximum flow 
theorem times value computed maximum flow gives ffl approximation min cut value high probability 
furthermore flow saturated minimum cut ffl minimum cut chernoff bound che skeleton pm edges expectation high probability 
theorem minimum cut skeleton value pv 
standard augmenting path algorithm find skeletal maximum flow pm pv mv log ffl time 
improved augmenting paths algorithm section lets shave factor theta pc log theta ffl running time yielding claimed bound 
approximate maximum flows slight variation previous algorithm compute approximate maximum flows 
lemma 
graph minimum cut maximum flow gammaffl maximum flow mv time low probability error 
proof 
determined ffl randomly partition edges groups creating graphs 
graph looks distribution skeleton high probability minimum cut value pv gamma ffl 
maximum flow value computed pm pv time previous section skeletons independent sum probabilities violates sampling theorem negligible 
adding flows result gives flow value gamma ffl 
running time pm pv mv log ffl 
improved augmenting path algorithm section improve running time additional factor theta ffl yielding claimed bound 
las vegas algorithm max flow min cut approximation algorithms monte carlo guaranteed give correct output error probability arbitrarily small 
combining approximation algorithms certify correctness results obtain las vegas algorithm problems guaranteed find right answer small probability long time 
standard example turning monte carlo error prone algorithm las vegas correct occasionally slow checking correctness output trying wrong 
corollary 
graph minimum cut maximum flow gamma ffl maximum flow ffl minimum cut mv time las vegas algorithm 
proof 
run approximate min cut approximate max flow algorithms obtaining high probability gamma ffl maximum flow value ffl minimum cut value know verify correctness results need check ffl gammaffl happens high probability 
algorithm las vegas repeat algorithms demonstrates correctness switch deterministic algorithm randomized attempt fails 
right try high probability algorithm runs fast high probability 
exact maximum flows sampling ideas speed familiar augmenting paths algorithm maximum flows 
section devoted proving theorem theorem kar 
graph minimum cut value maximum flow value mv time las vegas algorithm 
assume log approach randomized conquer algorithm analyze treating subproblem random sample 
technique gives general approach solving packing problems augmentation algorithm including packing bases matroid kar 
flow attempting find seen packing disjoint paths 
algorithm call divide conquer augmentation 

randomly split edges groups edge goes group probability yielding graphs 
recursively compute maximum flows 
add flows yielding flow 
augmenting paths increase maximum flow 
algorithm note apply sampling cleanup phase step residual graph manipulate directed sampling theorems apply undirected graphs 
left condition terminating recursion graph sufficiently small say edge basic augmenting path algorithm 
outcome steps flow 
regardless value step transform flow maximum flow 
algorithm clearly correct question fast runs 
suppose maximum flow consider edge probability apply theorem deduce high probability maximum flow gamma global minimum cut theta 
holds graphs independent irrelevant 
follows flow value gamma gamma 
number augmentations performed maximum flow 
augmentation takes time edge graph 
intuitively suggests recurrence running time algorithm terms mv fact subproblems expects contain edges 
solve recurrence evaluates mv 
unfortunately argument constitute proof actual running time recurrence fact probabilistic recurrence number edges sizes cuts subproblems random variables guaranteed equal expectations 
particular recursion arguments false log 
proving result requires additional kar 
randomized rounding turn randomized rounding 
randomized rounding powerful method approximately solving integer programming problems 
basic idea take values relaxation problem linear program generate integer values define solution integer program 
elements randomized rounding approach relaxation preserves structure original intractable problem solved efficiently rounding strategy transforms relaxed solution integer proof works 
apply randomized rounding np complete problems network design graph coloring 
rounding approaches slightly unusual 
network design problem simultaneously round exponentially constraints 
graph coloring semidefinite programming traditional linear programming determine structure preserving relaxation 
network design network design problem mirror minimum cut problem 
input set vertices collection candidate edges purchased specified cost 
goal design network cuts sufficiently large 
example wish build minimum cost network connected 
alternatively want network sufficient capacity route certain amount flow vertices network minimum cut 
network design covers classic problems np complete including perfect matching minimum cost flow steiner tree minimum join 
minimum cost connected graph just minimum spanning tree larger values minimum cost connected graph problem np complete edge costs infinity 
network design problem formulated terms lower bound constraints capacity number edges crossing cut write integer linear program variable edge may purchased constraint cut 
problem tractable relax requirement variables take values allow take fractional values interval 
gives rise linear programming relaxation solved polynomial time 
linear programs represented compactly solved standard methods 
times relaxation exponentially constraints separation oracle minimum cut computation connected subgraph problem solved ellipsoid algorithm 
solving relaxation yields fractional solution 
randomized rounding convert fractional solution back integral 
fractional variable values xm convert integer values ym setting probability 
note follows ax constraint vector scalar ay words expected satisfy constraint 
problem course random experiment deviate somewhat expectation 
raghavan thompson rt showed deviations provably small resulting rounded solution approximately optimal solution integer program 
unfortunately analysis focused problems small number constraints lets argue massive deviations expectation happen 
network design problem exponentially constraints large deviations occur 
fortunately analogue cut sampling theorem bounds deviations randomized rounding applied fractional graphs approximation guarantees original raghavan thompson analysis 
results yields log approximation algorithm minimum connected subgraph problem kar 
graph coloring apply randomized rounding problem graph coloring 
problem np complete proven extremely hard approximate graphs large chromatic number ly 
remains hope possible reasonably coloring graph small chromatic number 
thesis focus colorable graphs show color colors 
technique extends give new performance ratios graphs larger chromatic number 
joint rajeev motwani madhu sudan kms built exciting goemans williamson gw maximum cut problem 
improved joint avrim blum bk 
attack graph coloring turned developed technique semidefinite programming 
rounding fractional valued scalars integers round vectors 
illustrate describe relaxation graph coloring problem 
aim assign unit length vector vertex graph adjacent vertices dot product delta gamma 
see done colorable graph consider star vectors unit circle ffi angles example gamma gamma gamma 
unit length dot product gamma vectors 
colored graph solve vector problem assigning vector red vertices second green third blue vertices 
proves colorable graph feasible solution vector problem means valid relaxation 
solving relaxation formulated finding feasible vector solution semidefinite program denotes set edges graph 
delta gamma delta fact system constraints linear combination dot products solved negligibly small error polynomial time difficult result gls fortunately black box 
unfortunately feasible assignments semidefinite program dimension higher 
constrain solution dimensional solve problem polynomial time decide take high dimensional relaxed solution transform coloring 
method doing quite straightforward choose number random unit vectors centers color vertex center closest show number centers sufficiently large adjacent vertices assigned center get legal coloring 
intuition argument simple 
vectors adjacent vertices point away semidefinite constraints 
near random center far center attached center 
technical arguments involving gaussian distributions suffice prove centers suffice probabilities 
monte carlo estimation randomization technique consider monte carlo estimation 
technique applied want estimate probability event probability space 
monte carlo estimation carries repeated trials samples probability space measures event occurs 
gives natural estimate event probability 
monte carlo estimation attack terminal network reliability problem network vertices links assumed fail disappear independently probability determine probability surviving network connected 
practical applications question communication networks obvious problem subject great deal study 
comprehensive survey col 
mentioned section problem hard solve exactly give fully polynomial randomized approximation scheme gives answer accurate relative error ffl time polynomial ffl 
algorithm quite general kar restrict discussion case edge fails independently probability fail denote failure probability edges fail probability basic approach consider cases 
fail large estimate polynomial time direct monte carlo simulation edge failures 
randomly fail edges check graph remains connected 
fail large small number trials gives data estimate 
fail small show focus small cuts graph 
enumerate cut algorithms biased monte carlo estimation technique determine failure probability 
observe graph disconnected precisely edges cut graph fail 
edge fails probability probability edge cut fails smaller cut fail 
natural focus attention small graph cuts 
particular probability graph disconnected probability minimum cut fails 
time probability ff minimum cut fails ffc describe cases 
fail gamma direct monte carlo simulation estimate failure probability 
single experiment consists flipping coins see edges fail checking graph connected 
carry roughly log ffl fail ffl experiments polynomial number see log ffl failures 
provides evidence give estimate failure probability che klm 
unfortunately fail small need simulations develop baseline note expect see single failure perform fail experiments number super polynomial 
turn enumeration small cuts 
gamma know ff minimum cut fails probability ffc gamma ff argued cut counting theorem number ff minimum cuts ff follows probability ff minimum cut fails gammaff exponentially decreasing ff 
relatively small ff probability greater ff minimum cut fails negligible 
approximate fail approximating probability ff minimum cut fails 
enumerating ff minimum cuts modification contraction algorithm ks applying dnf counting algorithm developed karp luby madras klm 
algorithm klm monte carlo methods uses biased sampling ensure see failures estimate likelihood constructed quickly 
contribution show possible build small formula fed dnf counting algorithm produce meaningful answer 
randomization essential tool design optimization algorithms 
randomization leads algorithms faster simpler better performing deterministic counterparts 
basic techniques random selection random sampling randomized rounding monte carlo estimation draw intuitions common cases representative samples expect usually happen typical randomization may give way turn suspicion algorithm 
demonstrated approach numerous basic optimization problems 
great deal remains done 
direct open question far particular results pushed 
minimum spanning tree minimum cut problems essentially done linear time algorithm linear time algorithm results minimum cuts maximum flows incomplete lower bounds evident upper bounds odd flows simple graphs kl ways suggest possible improve 
approximation algorithms apply capacitated uncapacitated problems exact algorithms far apply best uncapacitated problems 
suspect done 
questionable technology applied directed graphs 
absolutely results discussed article extend directed graphs contraction algorithm fails result unable prove sampling theorem cut counting theorem fact directed graph exponentially minimum cuts sampling theorem rounding theorem directed reliability 
possible explanation undirected graphs form natural matroids directed graphs kar 
thinking broadly fundamental question randomization truly necessary 
randomized algorithm gives insight problem devise deterministic algorithm properties 
theoretical computer science entire subfield devoted derandomization development techniques mechanically convert randomized algorithm deterministic 
example randomized rounding procedure polynomial size linear programs deterministic rag randomized rounding algorithm graph coloring 
derandomized contraction algorithm km 
possible algorithm may worth doing 
derandomization add complexity computational case contraction algorithm derandomization drastically slows algorithm conceptual randomized rounding intuitive expectation argument replaced complex numeric calculation motivations exploring derandomization question 
strongest wish algorithm predictable behavior 
situation lives stake unsatisfactory right time usually fast 
problem particularly acute monte carlo algorithms tell answer correct 
obvious place minimum cut problem monte carlo algorithm solve problem high probability time best known deterministic running time mn 
specific question deterministic linear time minimum spanning tree algorithm put problem rest 
question proven graph sparse skeleton accurately approximates cuts assorted uses 
skeleton constructed deterministically polynomial time 
comments questions survey welcome 
amo ahuja magnanti orlin 
network flows theory algorithms applications 
prentice hall 
bk ur karger 
approximate min cuts time 
miller editor proceedings th acm symposium theory computing pages 
acm acm press may 
bk blum karger 
improved approximation graph coloring 
information processing letters january 
bk ur karger 
augmenting undirected edge connectivity time 
karloff editor proceedings th annual acm siam symposium discrete algorithms pages 
acm siam january 
blu blum 
new approximation algorithms graph coloring 
journal acm may 
cgk chekuri goldberg karger levine stein 
experimental study minimum cut algorithms 
saks editor proceedings th annual acm siam symposium discrete algorithms pages 
acm siam january 
che chernoff 
measure asymptotic efficiency tests hypothesis sum observations 
annals mathematical statistics 
col 
combinatorics network reliability volume international series monographs computer science 
oxford university press 
eswaran tarjan 
augmentation problems 
siam journal computing 
ff ford jr fulkerson 
flows networks 
princeton university press princeton new jersey 
fr floyd rivest 
expected time bounds selection 
communications acm 
ggp goemans goldberg plotkin shmoys tardos williamson 
improved approximation algorithms network design problems 
sleator editor proceedings th annual acm siam symposium discrete algorithms pages 
acm siam january 
gabow galil spencer tarjan 
efficient algorithms finding minimum spanning tree undirected directed graphs 
combinatorica 
gls grotschel lov asz schrijver 
geometric algorithms combinatorial optimization volume algorithms combinatorics 
springer verlag 
gr goldberg rao 
flow decomposition barrier 
proceedings th annual symposium foundations computer science pages 
ieee ieee computer society press october 
gt goldberg tarjan 
new approach maximum flow problem 
journal acm 
gw goemans williamson 
improved approximation algorithms maximum cut satisfiability problems semidefinite programming 
journal acm 
ho hao orlin 
faster algorithm finding minimum cut directed graph 
journal algorithms 
preliminary version appeared proceedings rd annual acm siam symposium discrete algorithms 
hoa hoare 
quicksort 
computer journal 
kar karger 
random sampling graph optimization problems 
phd thesis stanford university stanford ca 
contact karger lcs mit edu 
available theory lcs mit edu karger 
kar karger 
minimum cuts near linear time 
miller editor proceedings th acm symposium theory computing pages 
acm acm press may 
kar karger 
better random sampling algorithms flows undirected graphs 
karloff editor proceedings th annual acm siam symposium discrete algorithms pages 
acm siam january 
kar karger 
random sampling greedy sparsification matroid optimization problems 
mathematical june 
preliminary version appeared proceedings th annual symposium foundations computer science 
kar karger 
random sampling cut flow network design problems 
mathematics operations research 
appear 
preliminary version appeared proceedings th acm symposium theory computing 
kar karger 
randomized fully polynomial approximation scheme terminal network reliability problem 
siam journal computing 
appear 
preliminary version appeared proceedings th acm symposium theory computing 
kar karloff editor 
proceedings th annual acm siam symposium discrete algorithms 
acm siam january 
kkt karger klein tarjan 
randomized lineartime algorithm find minimum spanning trees 
journal acm 
kl karger levine 
finding maximum flows simple undirected graphs faster bipartite matching 
proceedings th acm symposium theory computing 
acm acm press may 
klm karp luby madras 
monte carlo approximation algorithms enumeration problems 
journal algorithms september 
km karger motwani 
derandomization approximation nc algorithm minimum cuts 
siam journal computing 
preliminary version appeared proceedings th acm symposium theory computing 
kms karger motwani sudan 
approximate graph coloring semidefinite programming 
journal acm march 
ks karger stein 
new approach minimum cut problem 
journal acm july 
preliminary portions appeared soda stoc 
kt karger tai 
implementing fully polynomial time approximation scheme terminal network reliability 
saks editor proceedings th annual acm siam symposium discrete algorithms pages 
acm siam january 
ly lund yannakakis 
hardness approximating minimization problems 
aggarwal editor proceedings th acm symposium theory computing pages 
acm acm press may 
mil miller editor 
proceedings th acm symposium theory computing 
acm acm press may 
mahajan ramesh 
semidefinite programming approximation algorithms 
proceedings th annual symposium foundations computer science pages 
ieee ieee computer society press october 
motwani raghavan 
randomized algorithms 
cambridge university press new york ny 
ni ibaraki 
linear time algorithms finding edge connected node connected spanning subgraphs 
algorithmica 
rag raghavan 
probabilistic construction deterministic algorithms approximate packing integer programs 
journal computer system sciences october 
rt raghavan thompson 
randomized rounding technique provably algorithms algorithmic proofs 
combinatorica 
sak saks editor 
proceedings th annual acm siam symposium discrete algorithms 
acm siam january 
tar tarjan 
data structures network algorithms volume cbms nsf regional conference series applied mathematics 
siam 

