acm sigplan notices september 
copyright nimble computer minimizing count updating deferred anchored pointers functional data structures henry baker nimble computer meadow ridge way ca fax material supported national science foundation 
iii 
counting attractive form dynamic storage management 
recovers storage promptly garbage stack free list real time accesses performed constant time 
major drawbacks inability reclaim cycles count storage count update overhead 
update overhead especially irritating functional read data updates may dirty cache lines pages 
show count updating largely eliminated functional data structures linear style programming inspired girard linear logic distinguishing normal pointers anchored pointers indicate object depth stack frame anchors object 
anchor pointer essentially enclosing data structure temporarily locked collected duration anchored pointer existence deferred count 
anchored pointer implies count increment deferred cancelled performed 
anchored pointers generalizations borrowed pointers phantom pointers 
anchored pointers provide solution derived pointer problem garbage collection 
counting collins attractive form dynamic storage management functional read data structures cycles cause trouble counting exist data structures 
unfortunately counting extracts penalty creating destroying data structures simply traversing 
example length list computed counts cells list incremented decremented 
traversal results net change count perform count updates list length substantial 
modern risc architecture data cache count may cause lines brought cache touched worse lines requiring rewritten data eventually written identical brought 
shared memory multiprocessor system updates counts require synchronization order avoid losing gaining counts due conflicting reads writes 
count updating creation deletion structures may tolerable continual updating simple traversals 
classical count system count node indicates exact number nodes local variables currently point node 
copying causes count increment deletion causes count decrement 
linear style programming inspired linear logic see appendix helps minimize count updating caused copying deletion local variables 
linear style policy variable destructive reads cons change counts simply moved local variables storage 
linear style creation deletion explicit duplicating local requires calling function dup deleting local requires calling function kill 
function dup increments count target object function kill decrements count may reclaim object recursively killing component 
linear style help organize reduce count updating eliminate updating results simple traversal 
linear length function increment decrement counts cell traverses 
understand better show code linear length defun length length function linear style 
null progn kill kill nil 
dlet dissolve 
kill kill 
length result length 
length entered count certainly length consume argument return freelist 
assume count head list rest list logic languages syntax dlet immediately kill car acm sigplan notices september 
copyright nimble computer unshared 
standard dlet adds deletes immediately killed count passed recursive invocation length 
list extra nil killed returned 
length performs count updates element list count updated twice element list 
length eventually returns counts initial state happen simply avoided updates 
problem arises second succeeding nodes list counts dlet reclaim nodes put freelist 
suspend reclamation length progress 
suppose types pointers normal pointer deferred increment pointer 
normal pointer acts described deferred increment pointer signals reclamation turned 
words deferred increment pointer pointer deferred count increment 
copy deferred increment pointer dup simply copy bits copies deferred increment implies deferred increment similarly delete deferred increment pointer kill simply delete decrement associated kill cancels deferred increment 
cons performed normal pointer count adjusted simply transferred local variable cons cell 
cons performed deferred increment pointer count incremented deferred means deferred increment components data structures normal 
treatment dlet deferred increment pointer elegant deferred increment cancels dlet decrement local variables deferred increments deferred 
deferred increment pointers appear elegantly achieve goals executing length deferred increment pointer performs count updates 
deferred increment pointers efficient eliminate normal pointers altogether 
problem proposal storage recovered deferred increment pointers back realm tracing garbage collection 
consider kill cons 
cons returns deferred increment pointer kill cons cell lost 
cons return normal non deferred pointer 
propose system pointers dynamically typed normal deferred increment 
unfortunately system quite third function demonstrates defun third linearly return third cons list 
dlet dissolve cons 
dissolve second cons 
kill kill kill elements return rd cons 
third passed deferred increment pointer traverse list changing counts gets third cons cell 
returns deferred increment pointer third cons cell 
unfortunately caller third kill list case third cons reclaimed increment implied deferred pointer performed 
fix bug making policy normal pointers returned function 
policy returned value third coerced back normal pointer performing increment implied deferred pointer 
policy correctly somewhat prompt correct anchored pointer scheme described expensive defer count updates long possible 
pointer bit give cause normal deferred scheme better classical count scheme functions length win completely just bit distinction 
count updating scheme deferred increment pointers obtained cost additional pointer bits means anchored pointers 
anchored pointer deferred increment pointer additional component indicates anchor 
implementation integer component indicating level stack object anchored 
functional cell pointed deferred increment pointer dissolved components inherit level number associated anchored pointer indicates indicates extent deferral valid 
deferred increment pointer returned stack level level number strictly words returning deutsch bobrow count scheme deutsch deutsch count local variables avoids count updates 
scheme requires stack scan reclaiming storage scan nearly impossible stacks formatted optimizing compilers modern risc architectures 
normal deferred increment distinction essentially identical real phantom distinction owned borrowed distinction gelernter 
calls normalization operation materialization 
acm sigplan notices september 
copyright nimble computer deferred increment pointer stack level checks see level pointer coerced normal count increment performed 
implementation anchored pointer scheme confined dlet special form dissolves single list cell binds components 
identify anchor level index dlet stack dlet form level number 
dlet normal pointer checks count 
count cell unshared dlet pointer cell 
car cdr bound normal pointers cell recycled 
count cell shared car cdr bound anchored pointers level number current dlet level 
dlet return values values checked deferral normalized level numbers current level 
count cell input dlet decremented 
case involves anchored pointer input dlet 
case car cdr bindings anchored level number parent pointer 
parent pointer anchored level strictly current level return values need checked normal require normalization lower level 
working anchored pointers extremely efficient 
boyer benchmark gabriel example functional database rewrite rules bound top level stack level 
traversals data structures performed entirely anchored pointers updating counts extremely important characteristic shared memory multiprocessor implementation benchmark multiple processors concurrently access shared read rules 
anchored pointer scheme conjunction traditional tracing garbage collector deferred counts may give collector fits 
order accounting balance cell bound deferred dlet negative deferred dlet negative deferred normalized dlet returns values causing count decremented 
dlet garbage collector see negative deferred 
inclusion level number pointer local variable probably prohibitive today bit architectures additional information double number registers required store local variables 
newer bit architectures mips dec bit level number constrain avoid requirement additional registers 
checking masking level data efficiency problems architecture organized 
anchored pointer programming language construct dlet special form described works may complex strictly needed solve problem 
really need form normal pointer provides anchored pointer dynamic context 
words puts normal pointer escrow provides anchored pointer temporary construct exited values normalized pointer dropped 
suggest anchored pointer special form anchored pointer ap name binds ap name copy expression value 
anchored pointer form evaluates normal pointer anchored pointer 
evaluates anchored pointer anchored pointer acts just expression 
evaluates normal pointer pointer saved internally anchored pointer copy normal pointer bound name ap name 
body anchored pointer form evaluated new binding values returned body normalized depend pointer 
normal pointer killed just dynamic scope exited involves decrementing count 
constructs anchored pointer allow anchored pointers static type system 
body construct name bound value guaranteed anchored run time checks may omitted 
previous programmers temporary pointers objects updating associated counts decades unix file system counted distinguishes hard soft links soft links created ln 
gelernter uses distinction owned borrowed pointers uses concept phantom pointers 
concept anchored pointers generalizes techniques precise situations safe 
maclisp pdl numbers steele similar anchored pointers encode stack level safely dynamic context 
pdl numbers explicit count way normalize copying done stored global environment returned value function 
acm sigplan notices september 
copyright nimble computer schemes involving bit counts include wise stoye chikayama wise 
anchored pointers particularly useful count incremented particular reason bit wise chikayama 
linear scheme avoiding count updates goals similar deutsch deutsch especially barth park 
particular scheme defers count updating barth park hope decrement cancelling increment leaving net change 
simpler theirs requiring static linearity checking global flow analysis 
furthermore linear style avoiding count updates 
anchored pointers similar generational counts goldberg attempt minimize count updates explicitly identify generation escape analysis 
anchored pointers require count field slightly generational counts 
anchored pointers closely related schemes described baker cons baker safe 
scheme baker safe different goals works mutable data stores stack level numbers objects pointers objects 
count schemes deutsch deutsch avoid count updating overhead traversal counting local variables stack 
schemes require stack scanned cells reclaimed 
apparent scanning stack compiled language ada baker safe increasingly difficult making stack scanning schemes infeasible 
anchored pointers improve efficiency tracing non copying garbage collection 
realtime non relocating garbage collector baker anchored pointers accessed read barrier 
furthermore anchored pointer contains proof target object garbage anchored pointers need traced garbage collector 
tracing pointer reveal target object marked efficient trace pointer target paged main memory cache 
anchored pointers similar object declarations kyoto common lisp object declarations traced garbage collector 
kcl object declarations safe refer mutable data carry proof accessibility 
anchored pointers similar weak pointers traced garbage collector completely different purpose 
weak pointer expected escape context target protected reclamation target reclaimed escaped pointer cleared nil application know object gone 
anchored pointers hand primarily improving efficiency user visible semantic differences improved performance 
anchored pointers provide solution garbage collection problems derived pointers ellis nilsen boehm diwan pointers interior large object array 
ellis suggests derived pointer form normal pointer array element form derived pointer normalized normal pointer computing index derived ptr base ptr element size 
anchored pointers dynamic extent considered generalization static scheme proposed boehm 
anchoring scheme avoids tracing derived pointers non copying collector 
count scheme safe defers increments extent cell reclaimed anyway 
non prompt incrementation counts means garbage collection restores counts may restore counts improperly 
fix problem create negative cons dissolved dlet 
negative normalized dlet exits 
negative cleaned unwinding stack setjmp longjmp common lisp catch throw 
count scheme intended support efficient implementation functional read objects implemented means hash consing baker bb baker lll attempt handle mutable objects cycles 
linear style programming essentially requires functions total return value 
explicit killing normalization traps anchored pointers requires functions return normal way catch throw common lisp reified continuations scheme setjmp longjmp cause significant problems storage management scheme 
david wise kelvin nilsen constructive criticisms 
abramsky computational interpretations linear logic 
theor 
comp 
sci 

baker cons cons arguments 
acm sigplan 
march 
baker treadmill real time garbage collection motion sickness 
sigplan 

acm sigplan notices september 
copyright nimble computer baker boyer benchmark warp speed 
acm lisp pointers july sept 
baker lively linear lisp look ma garbage 
acm sigplan notices aug 
baker safe resource management ada limited types 
acm ada letters xiii sep oct 
baker equal rights functional objects 
acm oops messenger oct 
barth shifting garbage collection overhead compile time 
cacm july 
cohen eds 
memory management proc 
springer lncs 
berry boudol chemical machine 
theor 
comp 
sci 

boehm 
simple gc safe compilation 
gc workshop oopsla phoenix az oct 
chikayama multiple management flat ghc 
logic programming proc 
th intl 
conf mit press 
chirimar proving memory management invariants language linear logic 
proc 
acm conf 
lisp funct 
prog san francisco ca june acm lisp pointers jan mar 
collins method overlapping erasure lists 
cacm dec 
deutsch bobrow efficient incremental automatic garbage collector 
cacm sept 
deutsch alto implementation 
lisp conf stanford ca aug 
diwan compiler support garbage collection statically typed language 
acm pldi sigplan 
june 
smart pointers re smart re pointers 
proc 
usenix tech 
conf 

garbage collection 

ellis real time concurrent collection stock multiprocessors 
acm pldi 
friedman wise aspects applicative programming parallel processing 
ieee trans 
comput 
apr 
gabriel performance evaluation lisp systems 
mit press camb ma 
gelernter fortran compiled list processing language 
acm 
girard 
linear logic 
theoretical computer sci 

goldberg generational counting reduced communication distributed storage reclamation scheme 
acm pldi sigplan 
july 
optimization techniques mrb evaluation multi psi 
logic programming proc 
north american conf mit press 
kieburtz programming pointer variables 
proc 
conf 
data abstraction definition structure sigplan 
special issue 
lafont linear machine 
theor 
comp 
sci 

mechanisms efficient multiprocessor combinator reduction 
lisp funct 
progr 

nilsen garbage collection strings linked data structures real time 
sw prac 
exper 

evaluation mrb garbage collection parallel logic programming architectures 
logic programming proc 
th intl 
conf mit press 
park goldberg escape analysis optimizing counting lifetime 
proc 
pepm yale univ june 
dylan tm object oriented dynamic language 
apple computer camb ma 
steele fast arithmetic maclisp 
ai memo mit ai lab camb ma sept 
steele common lisp language nd ed 
digital press bedford ma 
stoye practical methods rapid combinator reduction 
lisp funct 
progr 
conf 

strom mechanisms compile time enforcement security 
proc 
acm popl jan 
strom yemini typestate programming language concept enhancing software reliability 
ieee trans 
sw engrg 
se jan 
wadler linear logic 
proc 
acm pepm new haven june 
wakeling runciman linearity laziness 
proc 
funct 
progr 
computer arch lncs springer verlag aug 
wise friedman bit count 
bit sept 
wise copy bit counting 
tr indiana bloomington oct 
design implementation kyoto common lisp 
info 
proc 

appendix short tutorial linear lisp linear lisp style lisp bound name referenced exactly 
parameter function just name introduced binding constructs linear language requires programmer explicit copying deletion paid back better error checking compilation better utilization resources time space run time 
pascal ada languages providing explicit deletion linear language dangling 
acm sigplan notices september 
copyright nimble computer identity function linear dispose argument returning value defun identity defun kill true linear lisp kill kill function returns values provides appropriate boundary condition parameter appearance kill signifies non linearity 
see definition kill 
square function requires occurrences argument non linear 
second copy obtained dup function accepts argument returns values copies argument 
see definition dup 
square function follows defun square prime dup dylan style syntax multiple values 
prime conditional expressions expressions require bit sophistication 
arm conditional executed relax occurrence linearity condition allow arms 
immediately see linearity implies occurrence arm occurrence arm 
condition similar typestates strom strom 
boolean expression part expression requires sophistication 
strict linearity requires name boolean part expression counted occurrence 
predicates shallow examine small shallow portion arguments null zerop modified policy required 
best syntax solve problem provisionally new expressions atom null zerop expressions require boolean part simple name count occur linearity condition 
modified rule allows shallow condition tested name reused arms conditional 
require mechanism linearly extract components lisp cons cell car precludes cdr vice versa due requirement single occurrence introduce destructuring operation dlet takes series binding pairs body binds names binding pairs executing body 
binding pair consists pattern expression expression evaluated value result matched pattern consists list structure embedded names 
list structure match value names bound portions list structure pattern unified value 
linearity requires name appear particular pattern 
linearity requires name bound dlet binding pair occur expression succeeding binding pair body dlet 
constructs program append factorial fact functions defun append linear lists 
null progn kill trivial kill dlet top level cons 
cons cons optimized reuse input cell 
defun fact zerop progn kill trivial kill 
prime dup dylan style multiple value syntax 
fact prime show way program kill dup functions 
defun kill return values 
expensive way decrement count 
atom kill atom dlet kill kill defun dup return values 
expensive way increment count 
atom dup atom dlet prime dup prime dup share possible cons cons prime prime reuse input 
parallel speculative execution arms conditional require strict linearity 
rule bit messy equivalent having shallow predicate return values predicate unmodified argument 
policy completely consistent linear semantics 
