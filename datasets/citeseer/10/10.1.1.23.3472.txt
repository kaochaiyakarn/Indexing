quickxplain conflict detection arbitrary constraint propagation algorithms ulrich junker ilog route des junker ilog fr existing conflict detection methods csp de kleer ginsberg powerful propagation unusable complex real world problems 
hand powerful constraint propagation methods lack ability extract dependencies conflicts unusable advanced ai reasoning methods require conflicts interactive applications require explanations 
non intrusive conflict detection algorithm called quickxplain tackles problems 
applied propagation inference algorithm powerful may 
algorithm improves efficiency direct non intrusive conflict detectors recursively partitioning problem subproblems half size immediately skipping subproblems contain element conflict 
quickxplain explanation component advanced industrial constraint configuration tool 
keywords constraint satisfaction constraint programming configuration 
advanced reasoning methods ai require detection conflicts nogoods 
conflict approaches common nonmonotonic reasoning belief revision model diagnosis configuration planning 
examples hitting set trees reiter conditionals geffner pearl tms default provers junker konolige years reasoning gaining interest field constraint satisfaction 
examples conflict backjumping prosser dynamic backtracking ginsberg distributed csp yokoo constrained csp tabu search propagation jussien verification constraint configuration models furthermore conflict detection essential generating explanations interactive applications 
particular web configuration requires explanation facilities detection conflicts arbitrary constraint propagation algorithms topic raising interest 
conflicts csp elegantly computed methods atms de kleer dynamic backtracking ginsberg keep track employed constraints computed conflicts 
unfortunately methods directly powerful constraint propagation algorithms profit compact representation variable domains exploit semantics constraint propagations sum constraint bounds calculated directly 
atms able achieve consistency de kleer clear exploit pruning power ary constraints leads significant speed ups problems queen sports league scheduling quasi groups 
hand constraint propagation algorithms lack ability compute conflicts case failure produce explanations deductions 
basic problem recording justifications propagation decreases time space complexity propagation algorithm 
example jussien notes jussien ac looses advantages compared ac recording explanations 
draw back powerful propagation unusable advanced ai reasoning methods interactive applications explanations guide human decision making 
constraint propagation algorithms usually incomplete discover failures cases distinguish propagation specific conflicts global conflicts 
global conflict set constraints solution 
global conflict propagation specific reasons propagation specific conflicts interesting sufficient propagation ensures behaviour 
provide explanations behaviour propagation engine 
computed polynomial time computing global conflicts csp np complete 
supposed propagation algorithm needs polynomial time represent compromise tractability completeness 
allow exploit powerful constraint propagation inside conflict ai methods bridge gap conflict reasoning powerful propagation 
global conflict derived conflicts atms intelligent backtracking 
consider conflicts explanations constraint propagation algorithm engine 
covers specific propagation algorithms ac family propagation engines employed constraint programming tools fernandez hill may employ ac main algorithm dedicated algorithms kind constraint 
constraint propagation algorithms compute conflicts record relevant information conflict detection possible detect conflicts aposteriori constraint propagation algorithm complex may 
set inconsistent constraints basic idea iteratively test consistency subsets constraints minimal conflict 
iterative conflict detections algorithms follow ideas de puget bakker need 
consistency tests find minimal conflict size constraints 
show efficiency iterative methods improved recursively partitioning conflict detection problem subproblems half size immediately skipping subproblems contain element conflict 
new algorithm needs 
log checks 
wins iterative methods small compared due behaviour call new method quickxplain 
principle employed quickxplain quite intuitive algorithm coming surprise 
believed long time conflict detection constraint propagation intrusive causing overhead slow 
quickxplain shows nonintrusive conflict detection done clever way sufficiently efficient real world problems 
particular quickxplain explanation component advanced constraint configuration tool ilog addresses important issues example raised quickxplain limited constraint propagation 
find conflicts automated theorem provers inference engines satisfying common properties 
organized follows section illustrate basic idea conflict detection method 
sections introduce technical prerequisites algorithm 
explanations require notions logical consequences csp defined section 
section list assumptions constraint propagation algorithms 
section define conflicts related notions 
non intrusive conflict detection methods including quickxplain described section 
fi added constraints deduction argument conflict table computing conflict propagation 
step activated constraints result partial conflict 
fail fg 
fail fg 
fail fg 
fail fg 
fail 
fail 
fail table finding minimal conflict 
nally summarize advantages quickxplain discuss ongoing 
non intrusive conflict detection section basic ideas conflict detection approach illustrate algorithm quickxplain simple example 
example suppose customer wants buy 
metal color 
abs 
roof 
additional seat 
special luxury version 
suppose cost dollars 
furthermore customer exceed dollar options 
model example constrained integer variable extra variable costs constraint 
furthermore model customer requests constraints 
short hand 
propagation algorithm supplied set constraints deduces new constraints mainly concern single variable 
example algorithm removes value domain variable deduces constraint removes values strictly smaller greater deduces constraint 
values removed variable domain failure occurs 
say inconsistency deduced 
example initially start constraint introduce requests 
step derive new constraint form increasing fourth column list requests needed deduce result shown table 
constraints sufficient deduce failure propagation know 
interested inclusion minimal conflicts subsets constraints sufficient deduce inconsistency propagation proper subset allows 
finding conflicts arbitrary constraint propagation algorithms open question long time 
classical approaches tms atms determine conflict keeping track explanations intermediate deductions 
constraint propagating local explanation deduced constraint form determined propagation engine 

local explanations synthesized global ones eliminating intermediate deductions 
achieved storing single local explanation deduction tms doyle propagating explanations done predecessor atms martins shapiro conflict detection csp follows second principle jussien approaches intrusive sense require constraint propagation algorithm determines records local explanations propagation 
intrusive approaches elegant deduction principles successfully applied problems specific structure numeric csp jussien open shop scheduling jussien encounter problems general case 
real world problems clear structure numeric csp scheduling problems 
applications web configuration crew scheduling time tabling users edit constraints significantly modify structure problem 
second bookkeeping explanations propagation increases space complexity propagation algorithms 
variables possible values variable cost book keeping 
explanations size 

memory consumption may excessive medium sized real world problems values 
large scale problems values method inapplicable 
third classical approaches guarantee minimality computed conflict local explanations minimal non trivial global constraints 
example listed explanations computed jussien algorithm constraints form cf 
fourth column table 
obtain local explanation minimal needed deduce lower bound deduce failure having explanation minimal conflict 
chosen choose extra violating budget 
get possible minimal conflicts significantly smaller fourth multiple conflicts classical approaches provide control conflicts 
consider non intrusive conflict detection approaches determine conflicts posteriori checking consistency different subsets constraints 
non intrusive methods require book keeping guarantee minimality conflicts provide control conflict 
fact determined conflict uniquely specified total order constraints 
introduce iterative algorithm de puget shown table add constraints order constraint propagation engine fail obtained 
fail occurs added consequently belongs minimal conflict 
backtrack initial state add 
result fail add remaining constraints time immediately obtain fail adding needed obtain fail minimal conflict case detection minimal conflict straightforward 
consider variant example slightly complex 
consider requests costs 
adapt scalar product correspondingly keep budget 
algorithm needs steps adds single constraint propagation engine 
table shows trace 
example elements conflict explored late 
algorithm backtracks detected element conflict constraints times 
improve behaviour iterative algorithm recursively partitioning conflict detection problem subproblems half size 
subproblems contain element conflict immediately skipped 
constraints subproblems need 
new algorithm called quickxplain needs steps summarized table 
lines quickxplain adds constraints usual 
element conflict detected problem decomposed subproblems 
subproblem consists finding conflict keeping detected elements conflict background hard constraints 
second subproblem consists finding conflict keeping conflict elements subproblem background 
order set subproblem quickxplain backtracks steps re adds detected element conflict line 
constraints subproblem solved lines resulting detection elements conflict 
set second subproblem quickxplain backtracks re adds detected elements conflict lines 
step activated constraints result partial conflict 
fail fg 
fail fg 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail table example needing frequent replays 
step activated constraints result partial conflict 
fail fg 
fail fg 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail 
fail table recursive conflict detection reduces replaying 
second subproblem solved lines leading detection remaining element subproblems solved way main problem recursively decomposed new element conflict detected 
logical csp csp consist set variables set constraints 
constraint form xn xn variables values ary constraint predicate 
ary constraint predicate associated ary relation global domain 
particular introduce constraints form value subset predicates interpret equality inequality set membership 
mapping variables values satisfies constraint xn iff xn 
mapping solution csp iff satisfies constraints set constraints set variables appearing constraints say constraint logical consequence set constraints iff solutions csp variables constraints satisfy constraint write case 
say set constraints consistent iff csp variables constraints solution 
write case unary constraint arbitrary variable empty relation 
mapping solution iff consistent 
mapped problem finding solution csp problem checking consistency set constraints 
deductive view propagation purpose explanation need deductive view constraint propagation engine 
section show achieved supposed propagation engine satisfies usual properties 
standard constraint propagation engine allows incrementally add constraint state 
propagation leads deduction new constraints 
example value removed domain variable constraint implicitly derived 
furthermore possible values variable removed domain say inconsistency derived 
characterize state propagation engine set constraints incremental adding function add maps set constraints new constraint new set constraints 
suppose add satisfies properties finiteness finite add finite 
order independence add add add add 
inclusion input add add 
closedness add add correctness add completeness checking fx xn vn vn add xn 
repeated application function add different constraints set allows define propagation operator maps set constraints new set constraints 
enumeration elements define propagation operator follows 
add result function add independent order constraints added result possible enumerations show satisfies properties deduction operator 
theorem function add satisfies properties satisfies properties 
implies tarski unique minimal fix point contains supposed finite 
characterize behaviour standard constraint propagation algorithm tarski deduction operator 
characterize important constraint propagation algorithms 
describes constraint checker entirely characterized properties 
additionally ensures arc consistency satisfies property 

property easily generalized non binary constraints 
characterize propagation engines maintain different notions consistency different constraint predicates 
just limit application properties relevant predicates 
characterize complete propagation engines check global consistency inconsistent 
conflicts arguments able introduce central concepts conflicts arguments propagation operator 
conflicts arguments subsets constraints sufficient deduce inconsistency constraint 
interested part conflict contains selected constraints split disjoint sets background set call tuple csp explainable form 
suppose finite sets constraints 
define definition propagation operator csp explainable form constraint 

subset called argument iff 
minimal argument iff proper subset argument 

subset called minimal conflict iff minimal argument 

subset called minimal counterargument iff minimal conflict 
describes constraint checker conflicts just correspond forbidden tuples constraints call local conflicts 
supports consistency refer conflicts conflicts 
supports global consistency checking conflicts equal global conflicts 
arguments counterarguments needed explanation purposes 
sections limit discussion problem conflict detection 
definition algorithms directly determine counterarguments 
order adapt argument detection tests form replaced tests form 
general inconsistent set constraints conflicts 
usually single conflict determined want control conflicts determined 
strict partial order constraints purpose 
analogy notion preferred solutions junker define preferred conflicts follows definition csp explainable form strict partial order 
total order superset 
enumeration elements increasing xn preferred conflict 
algorithm 
return 
throw exception conflict 
enumeration 


ck 

kg 
throw exception conflict 
kg 


ck 

kg 
return robust explanation total order unique preferred conflict 
total order uniquely specify characterize conflict detected algorithms 
computing minimal conflicts section iterative algorithms non intrusive conflict detection analyze behaviour 
develop recursive version improves efficiency iterative versions 
algorithms supplied csp explainable form determine conflict contains inconsistency 
throw exception indicating conflict 
algorithms consist exploration phase unexplored constraints step step added function add underlying constraint propagation engine 
order constraints added 
causes failure added belongs minimal conflict 
added addition undone 
undoing achieved storing intermediate states appropriate intermediate state different ways find elements conflict 
algorithm cf 
undoes addition 
step adds elements current add operations 
inconsistency occurs needed produce failure dropped 
added algorithm needs single exploration phase add operations adds times constraints size final conflict 
finds minimal conflict add order independent changes order constraints added 
practice constraint programming tools efficient trailing mechanism undo addition constraints search 
algorithm 
return 
throw exception conflict 
enumeration 






kg 
throw exception conflict 
kg 

kg 
return explanation replaying algorithm cf 
undoes addition constraints adding initial state 
inconsistency obtained minimal conflict algorithm 
avoids large number test operations needed ro 
new exploration phase started undoing addition lead detection new element reached 
procedure repeated minimal conflict detected 
algorithm performs exploration phases tests tests undo operations 
algorithm quickxplain cf 
combines advantages 
element detected divides remaining constraints disjoint subsets split 
usually split middle choose split 
recursively apply algorithm find conflict background conflict background 
set minimal conflict 
quickxplain immediately skips subproblem background subproblem inconsistent 
subproblems containing elements explored 
subproblems explored total leads maximal 
log add calls exploration 
counting add calls needed testing elements look depth recursive calls quickxplain 
time new element detected call depth increased 
th element detected depth smaller depth 
tested twice lines detected line smaller depths 
obtain maximal 
tests 
complexity different algorithms summarized table 
order prove correctness algorithms properties 
properties algorithms exploited quickxplain empty set minimal conflict 
algorithm quickxplain 
return 
throw exception conflict 
enumeration 


ck 

kg 
throw exception conflict 
kg 
split 






result quickxplain 






result quickxplain 


return explanation recursive partitioning explore test 



quickxplain 
log 
table complexity finding conflicts size terms add calls 
minimal conflict 
minimal conflict minimal conflict 

minimal conflict 
minimal conflict 
disjoint 
minimal conflict 
minimal conflict 


minimal conflict 
show correctness algorithm theorem algorithm quickxplain terminates 
contain inconsistency throws exception conflict 
returns minimal conflict 
characterize conflict theorem total order suppose quickxplain explores elements increasing contains inconsistency quickxplain returns unique 
mention quickxplain behaves re choose split developed non intrusive conflict detection algorithm able find minimal conflicts arbitrary constraint propagation algorithms engines monotonic inference engine 
quickxplain improves efficiency existing non intrusive algorithms de puget bakker recursively partitioning conflict detection problem subproblems skipping subproblems contain element conflict 
quickxplain appears choice conflict detection method cases explanation detection 
black box propagation engines able record local explanations required tms 
complex large problems methods atms tms lead high overhead 
minimizing conflicts built method tms jussien particular quickxplain explanation component advanced industrial constraint configuration tool ilog proved feasible typical configuration problems 
experimental comparisons different conflict detection methods preparation 
currently extending conflict detection method global conflicts 
investigate approaches 
apply quickxplain node systematic complete backtrack search solution 
sons node fail hyperresolution principle employed atms de kleer order compute conflict longer contain constraints added son nodes 
conflicts allow conflict backjumping prosser dynamic backtracking ginsberg search method 

apply systematic complete backtrack search solution step quickxplain 
detected solutions maintained internally serve starting points backtrack searches 
backtrack searches obsolete 

interleave nest approaches 
topics decomposition conflicts large explanations refinement conflicts contain conjunctive constraints 
furthermore adapt pbs junker find multiple preferred conflicts 
heuristics focus conflict detection relevant subset constraints reduce effort 
profited discussions derek bennett gerhard friedrich fred garrett olivier daniel thierry petit jean francois puget jean charles colleagues 
partially supported european commission contract ep vf 
bakker bakker 
diagnosing solving overdetermined constraint satisfaction problems 
ijcai pages 
de kleer johan de kleer 
comparison atms csp techniques 
ijcai pages detroit mi usa 
morgan kaufmann 
de puget de puget 
explanation generalisation failures 
ecai pages munich frg 
pitman publishers 
doyle doyle 
truth maintenance system 
artificial intelligence 
friedrich 
automated generation validation configurator knowledge bases ilog configurator 
technical report university klagenfurt 
fernandez hill fernandez hill 
comparative study constraint programming languages boolean finite domains 
constraints 
geffner pearl geffner pearl 
conditional entailment bridging approaches default reasoning 
artificial intelligence 
ginsberg ginsberg 
dynamic backtracking 
journal artificial intelligence research 
ilog ilog 
ilog configurator 
manual user manual 
ilog 
junker konolige junker konolige 
computing extensions autoepistemic default logics truth maintenance system 
aaai pages boston ma 
mit press 
junker junker 
preference search scheduling 
aaai pages austin texas 
jussien jussien 
dynamic domain splitting numeric csps 
ecai pages chichester 
john wiley sons 
jussien narendra jussien olivier 
local search constraint propagation conflict heuristics 
aaai pages austin texas 
jussien narendra jussien patrice boizumault 
maintaining arc consistency dynamic backtracking 
cp pages singapore 
springer verlag 
martins shapiro martins shapiro 
model belief revision 
artificial intelligence 
prosser prosser 
hybrid algorithms constraint satisfaction problem 
computational intelligence 
petit puget 
original constraint approach solving constrained problems 
cp pages 


filtering algorithm constraints difference csps 
aaai pages 
reiter reiter 
theory diagnosis principles 
artificial intelligence 
yokoo yokoo 
asynchronous weak commitment search solving distributed constraint satisfaction problems 
cp pages 
