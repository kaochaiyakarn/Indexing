minimization cooperative response failing database queries parke godfrey godfrey cs umd edu department computer science university maryland college park md usa query fails cooperative identify cause failure just report empty answer set 
cause query failure worthwhile report part query failed 
identify minimal failing subquery mfs query best way 
mfs unique may 
likewise identify maximal succeeding subquery mss help user recast new query leads non empty answer set 
database systems provide functionality types cooperative responses 
may part algorithmic approaches finding mfss msss failing query obvious 
search space subqueries large 
despite mfss past algorithmic complexity identification problems remained 
shows complexity profile mfs mss identification 
shown exists simple algorithm finding mfs mss asking subsequent queries length query 
find mfss msss hard 
shown find mfss msss np hard 
find mfss msss fixed remains polynomial 
optimal algorithm enumerating mfss msss ishmael developed 
algorithm ideal performance enumeration finding answers quickly decaying intractability predictable manner answers 
complexity results algorithmic approaches allow construction mfs mss facilities database systems 
results relevant number problems outside databases may find application 
supported air force office scientific research afosr national science foundation iri 
query said fail evaluation produces empty answer set 
empty answer set uninformative user 
presumed user expects answers query asked 
query fails surprise user 
system cooperative helping trace reason query failure pinpoint failure 
type queries considered conjunctive query formulas 
query 
literal 
call subquery iff fs ae kg subquery fails query fail 
stronger statement report failure subquery report failure query 
best possible response report minimal failing subquery mfs 
consider query fails ward patient ward name infected patient infection contagious name name 
query asks patients ward contagious infection 
say answer 
response subquery infected patient infection name 
fails informative 
coupled knowledge minimal failing subquery informative instance states implicitly patients infections 
db database datalog 
variables query formula 
tuple template answer set 
query fails db cases said query contains false presupposition query subqueries logical presupposition query evaluates false 
likewise database system respond failing query maximally succeeding subquery mss 
consider query 
system respond query fails subquery infected patient infection contagious name 
succeeds 
words patients contagious infections contagious infection ward 
query fail semantics database 
consider query ward patient ward name infected patient infection patient name gender male 
ask 
course cases user attempting confirm query fails majority case 
loss generality 
failing subquery minimal iff subquery fails 
may integrity constraint associated database ensures patient assigned ward female male 
query answers rules database change 
assume answer query lead contradiction 
query necessarily fails said contain misconception 
query contains misconception stronger statement query fails 
misconception cases explanation query fails produced contradiction proof 
query said misconception db see strictly stronger logically definition query contains false presupposition 
useful identify minimal subquery leads contradiction minimal conflicting subquery mcs 
example mcs query ward patient ward name patient name gender male 
worthwhile extend database systems facilities find minimal failing maximal succeeding minimal conflicting subqueries 
cooperative features database systems easier 
cooperative behaviors better response failing database queries require search minimal subquery 
search minimal focus 
research topic particular finding mfss 
formally addressed complexity finding mfss queries 
implicit assumption may cost exponential time worst case find mfs 
devoted heuristics means reduce search time find mfss search limited cases render problem tractable practice 
commercial database systems today offer cooperative features 
academic systems prototyped 
previous algorithms finding mfss queries shown intractable average case despite measures taken avoid 
apparent intractability may reason capabilities remain unimplemented mainstream information systems today 
complexity profile search problems quite surprising 
addresses inherent complexity mfs mss mcs facility relational deductive database systems 
offers bad news possibility facility 
certain mfs facilities quite tractable easy provide instance finding mfs query 
facilities intractable instance finding mfss query 
facility find mfss query warrants discussion addressed report 
find mfs mss query shown cost subsequent queries database number conjuncts original query 
find number subsequent mfss msss query expensive 
shown find mfss msss query size np complete 
section reviews previous done mfs problem preceded accomplishments 
section defines abstraction minimization problems 
abstraction involves finding minimal elements respect test monotonic respect subset set tests true superset test true finite boolean lattice 
call minimal element lattice respect test mel 
complexity analysis algorithms finding mel 
section extends problem enumerating mels 
complexity enumeration established enumeration problems mfss msss mcss shown equivalent complexity 
general algorithm enumerate mels ishmael developed section 
heuristics caching techniques evaluated potential improve performance 
section considers theoretical terminology arises fact user asks query necessarily fails indicates user misconception regards semantics database user thought query result answers 
issues raised mel enumeration problem 
issues remain 
particular probability distribution finding mels considered shown mel algorithm offer probabilistic attack np completeness 
section related problems applications may benefit analysis techniques algorithms mel mfs considered concluding remarks 
background student asks appropriate university database passed cmsc fall semester 
database returns answer leaving student possibly think cmsc hard course 
student asks failed cmsc fall semester 
database returns answer 
student suspicious asks taught cmsc fall semester 
database answers 
kaplan called behavior 
initial question asked person probably answered immediately reply oh course taught semester 
databases 
answer question regardless answer misleading 
prior interest behavior avoiding domain natural language dialog 
strawson claimed statement truth value necessary presuppositions true 
presupposition statement statement entailed original 
consider question king france bald 
statement answered strawson presupposition king france false 
belnap steel considered issues related information systems 
state question presupposes statement truth logically necessary condition true answer 
rigid condition strawson query considered false false presuppositions 
grice enumerated number maxims ought adhere conversation order cooperative 
states answer query correct non misleading relevant 
guarantees databases answer queries correctly 
databases answers misleading 
commonly happens query false presuppositions 
colmerauer addressed problem false presuppositions translate natural language queries logical formalism 
employ valued logic allows sentence marked undefined false presuppositions occur 
translate natural language sentences recursive datastructure call branch quantifier tree bq tree 
fig 
shows representation statement student owns car 
develop means identify false presuppositions user 
kaplan may note relevance false presuppositions databases 
subquery conjunctive relational query may considered presupposition query belnap steel view 
subquery fails evaluates false query necessarily fails 
student car owns student owns car 
student gamma 
car owns quantifier tree representation 
domain databases kaplan equates false presupposition problem finding minimal failing subqueries 
notes problem independent natural language issue formal query language query answering system 
kaplan built system called op cooperative query system couples natural language query system database management system seed 
op provides cooperative responses simple natural language questions requesting relevant data database 
system tested real database national center atmospheric research users programmers 
related lee developed database system detects presents false presuppositions database queries 
query language employed called hi iq hierarchical interactive query language 
noted independence mfs problem natural language 
studied computational feasibility reporting smallest subqueries fail 
considers conjunctive query set atoms satisfied subqueries elements power set 
gamma subqueries conjunctive query atoms disregarding query seen fail empty query 
query page atoms subqueries consider 
naive approach test 
incur exponential cost length query 
introduces algorithm finding minimal failing subqueries 
recognizes inherent intractability algorithm connectivity query exploited reduce number subqueries lattice need considered 
fig 
shows lattice query 
twelve subqueries need considered absent disjoint evaluated 
see section 
proposes integrity constraints associated database reduce number subqueries need evaluated 
kaplan algorithm similar operates query translated mql query language op employs internally consider computational issues involved 
points algorithm find false presuppositions independent domain specific knowledge 
techniques applicable domain 
kaplan introduces notion generalizing failing query query succeeds query fails due failing subquery failing parts removed resulting new query answers 
serve tool correcting possible errors users queries give user information related query asked 
considered finding mfss conjunctive boolean queries library searches 
disjoint query equivalent union independent queries 
powerful identifying maximally succeeding subquery seen examples 
ward infected contagious 
ward infected contagious 
ward infected 
infected contagious 
ward infected 
infected contagious 
infected 
contagious 
ward 
infected 
contagious 

lattice subqueries 
system reports number matches subquery displays results graphically 
mfss just subqueries zero matches 
intended help user choose subqueries pursue 
motro extended notion false presuppositions 
considering subqueries query defined considers certain generalizations query logical presuppositions query 
query generalizations obtained relaxing degree conditions query 
subquery extreme generalization conditions completely removed vacuously true 
example part query salary greater equal dollars year condition relaxed salary greater equal 
necessitates function predicate relaxed supplied 
step size relaxation step decided 
instance example salary relaxed dollar increments 
eventually literal may relax true removed 
method combines notion relaxing queries general queries searching false presuppositions 
finding minimal failing subqueries system return maximally generalized failing queries 
responses potential informative reporting just mfss 
motro method extends lattice presuppositions compared subquery lattice 
consider query employee age gender salary female 
fig 
shows start generalization lattice query conditions relaxed 
focuses finding mfss search considered briefly section 
may argue cost finding minimal failing subqueries remains high may offset benefits cooperative responses offer 
informed part query fails user waste time asking follow questions necessarily fail continues generalization lattice query necessarily finite subquery lattice 

female 


female 
female 
female 

female 
female 
extended lattice subqueries 
look information originally desired 
reduction cumulative query answering costs significant especially user asked spurious queries kaplan examples 
furthermore preventing user frustrated goal database system effective 
number people concerned detect misconceptions queries 
explored employ schema information relational database order correct misconceptions possible 
mccoy world general knowledge correct object related misconceptions user properties object class 
stated considered database integrity constraints eliminate subqueries consideration consider providing explanation query failure 
realization query failure assured integrity constraints meaningful just exhaustive failure motivated cooperative answering gal minker 
cooperative answering system developed gal identifies integrity constraints guarantee failure provides response user 
gal recognized need provide mcs address identify minimal subqueries misconceptions 
see survey background 
design implementation cooperative database system discussed misconception detection explanation key components 
system problems mfs mss mcs addressed 
analysis finding minimal failing subquery consideration may finding mfs query potentially intractable 
literature states case differently 
consideration show case 
recursive descent algorithm finds mfs query subsequent queries database section 
hand find mfss query hard 
requires exponential time worst case 
true due simple fact exponential number mfss query require exponential time report 
see assume subqueries size mfss breadth depth top bottom table search strategies finding mel query literals 
exist gamma delta subqueries 
gamma delta omega gamma 
natural question cost enumerate mfss query 
mfs known cost find second mfs third forth 
exist possibilities complexity enumeration algorithm 
case time required find subsequent answer bounded fixed polynomial 
require fixed polynomial time respect find subsequent mfs 
second case worse offers decent behavior 
require fixed polynomial time respect plus number answers point 
exponential number answers time find answer appears exponential respect time needed answers grow slowly predictably 
third case finding mfss find may intractable 
case important determine constant related size query 
abstraction abstraction mfs problem 
consider finite boolean algebra formed set fe respect containment powerset lattice consists elements top element bottom 
test unary relation monotonic respect subset superset sake discussion assume evaluating unit cost 
call minimal element lattice respect test mel 
mel iff ae mfs problem easily maps mel problem 
case ask query database system 
query fails test returns true 
query non empty answer set test returns false 
monotonic finding exists answer trivial 
ask exists answer 
indicates finding mel minimal answer may simple 
may counterintuitive initially divide mfs problem way parts test search space 
resulting strategy generate test rarely efficient approach algorithmically 
abstraction help shed light inherent complexity problem 
furthermore seen fact efficient algorithmic approach 
assume loss generality 
notation may initially confusing 
remember queries resulting empty answer sets test true 
boolean mel top var mel test top mel true top mel return true return false mel true top var mel set top minimal true minimal set choose ele set set set gamma ele test top gamma ele mel true top gamma ele mel minimal false minimal mel top algorithm algorithm finding mel steps 
finding mel find mel set monotonic test requires searching complete boolean lattice respect containment search space large 
search done breadth depth directed top starting bottom starting 
breadth lattice large breadth search fare 
depth lattice fixed depth search fare 
table shows search strategies fare 
find mels seen order exponential time simply exponential number mels 
number subsets length gamma delta breadth search order exponential time 
search top assume mels smaller 
search bottom assume mels larger 
case subsets length explored mel 
better results obtained depth search 
mel steps away lattice 
clear search proceed bottom intelligent fashion 
test help decide edge lattice traverse 
search proceeds top test advantage 
procedure alg 
algorithm finding mel set respect test 
proceeds depth top 
set initially tested fails need proceed 
element removed resulting subset tested 
subset fails element chosen tested 
possibilities fail known passed test subsets minimal mel 
hand subsets passed recursively proceed 
mel subset mel assumed test fails 
consider mel called set fa dg set single mel fag 
selection case checking query mfss query evaluated non empty answer set need proceed non empty query mfss 
fg fcg fbg fdg fag fa cg fa bg fc dg fa dg fb dg fb cg fa dg fa cg fb dg fa dg fa dg routine mel run fa dg find mel fag 
rule choose statement choose element set written 
assume set ordered 
fig 
demonstrates mel search 
solid lines show edges lattice mel true traverses 
underlined sets fail test search proceed 
boxed sets succeed mel called recursively 
theorem 
worst case running time mel theta length set invocation test costs unit time 
running time mel bound gamma steps 
proof 
algorithm mel completes gamma steps 
determine subset mel requires worst case immediate subsets tested 

assume worst case tests false 
recursive descent mel takes steps 
recursive call size input set reduced 
number tests performed gamma 
worst case gamma tests performed 
algorithm mel worst case running time omega gamma 
consider fe mel fe 
assume loss generality 
selection rule mel choose statement select element set 
consider sets ordered sets 
consider invocation mel true fe 
removed remaining subset tested removed forth 
sets fe ng fe fe gamma ng tested failing 
fe tested succeeds 
constitutes tests mel true fe recursively called 
call mel true likewise perform tests recursive invocation 
recursive stages mel true fe called 
call performs tests verify mel 
definitions asymptotic upper bound asymptotic lower bound omega gammad asymptotic tight bound theta employed 
array mel set integer boolean mels top test top mels true top return true return false mels true set minimal true foreach ele set test set gamma ele mels true set gamma ele minimal false minimal mel set algorithm naive algorithm finding mels 
initial call mel executed test calling mel true 
total results calls test 
worst case running time mel omega gamma 
algorithm mel worst case running time theta 
recursive descent method employed mel certainly new observation 
bylander show algorithm certain abduction problems closely related mel problem show find answer 
finding mels clear best search strategy finding mels set respect monotonic test search strategy finding number mels efficiently 
algorithm mel modified simple manner find mels principle 
algorithm mels alg 
shows algorithm 
loop mel replaced foreach loop mels possible paths mel explored turn 
global variables store mels array mel array type set mel added free slot array integer points array position mel filled 
mel 
algorithms suggested mfs search essentially isomorphic mels 
presents algorithm 
algorithm works top depth algorithm continues mfss 
procedural control mels 
assume array mel dynamically allocated fixed length 
motro presents algorithm search extended lattice query find maximal failing generalizations query 
trivial case relaxation operators return true input search lattice space mels maximal failing generalizations equivalent just mfss 
algorithm reduces mels 
proceeds top depth control mels 
finding mels motro stated algorithms find mfs time algorithms performance 
unfortunately performance mels algorithms breaks immediately 
time find second unique mel usually exponential 
consider fe test yields mels respect fe fe gamma algorithm mels find second throw stage 
second stage recursive invocation algorithm called find mels fe unfortunately throwing away fe gamma yield subset tests true 
foreach statement recursively invoke mels 
redundancy exist recursive invocation 
invocation mels fe arrive fe gamma gamma 
number times 
mels called fe spend gamma 
steps finding mel fe gamma finding mel fe fact way mels written insert mel fe gamma array mel exponential number times 
may considered oversight easily corrected 
check added clause assure set mel array adding 
course change time complexity algorithm 
algorithm find subsequent mel time subsequent mel unique necessary criterion 
algorithm modified report mel time second mel exponential worst case 
indicate possibility finding mel easy finding intractable 
paradoxical 
order presentation set reversed fen mel fe quickly 
mels symmetrically indistinguishable 
section shown find mels equivalent np complete problem 
find second third mel shown polynomial fact calls test 
indicates better algorithm enumerating mels mfss msss mcss devised 
faster algorithm finding mel continuing improvement algorithm mel alg 
finding single mel 
search mel shown 
algorithm mel fast alg 
runs time 
mel fast alg 
just call test needed element input set 
result true element thrown away 
result false element member mel constructed 
observation improvement possible 
lemma 
gamma feg mel contain proof 
assume mel contain subset gamma feg 
monotonic respect subset 
mel 
contradicts boolean mel fast top mel test top mel true top mel return true return false mel true set mel core set mel core choose ele set test set gamma ele core mel true set gamma ele mel core mel true set gamma ele mel core ele algorithm algorithm finding mel steps 
original assumption 
theorem 
algorithm mel fast running time steps size invocation test costs unit time 
proof 
algorithm mel fast call test element input set needed 
element thrown away show final answer 
case added accumulator core 
mel fast complete calls test 
complexity enumeration complexity finding mel established 
complexity enumerating mels considered 
shall shown find jsj mels np complete 
find mels fixed done polynomial time 
abstraction enumerating set theoretic version mel order consider algorithmic complexity 
definition 
define mel follows 
consider pair hs set turing machine represented enumeration elements properties ffl defined domain ffl halts returns input domain ffl runs polynomial time fixed polynomial input domain ffl returns input ae returns input words upwardly closed case say turing machine decides set 
take liberty notation write machine returns input 
consider pair hhs ai represented enumeration elements 
hhs ai mel iff ae seen mel polynomial time 
evaluate done polynomial time 
immediate subset tested evaluate false 
polynomial total 
definition 
define exists follows exists iff hx ci called certificate certifies exists 
interested class exists mel 
clearly exists mel np mel fact exists mel demonstrated algorithm mel alg 
theorem 
expand notion exists enumerate 
interested know difficult identify number certificates mel just exists 
definition 
define enumerate follows enumerate iff exist jx distinct certificates jx hx problems enumeration version intractable existence problem 
mel problem 
section shown linear function linear linear enumerate mel linear np complete 
section shown constant function constant constant enumerate mel constant 
notice stronger result just result exists mel 
enumeration hard shall show enumeration problem mels hard 
proof encode cnf propositional theory mel enumeration problem 
determine arbitrary cnf propositional theory satisfiable known problem sat np complete 
terms defined follows 
definition 
propositional theory cnf form form clause form lm represents propositional variable negation thereof 
shall consider cnf theory represented set sets 
inner set represents clause disjunction literals set 
set sets considered represent conjunction clauses 
call propositional theory propositional variable appears negated positive theory 
definition 
disjoint pair sets propositional variables ht fi truth table denote truth assignment assign true false undefined 
defined 
propositional theory 
denote truth table described satisfies shorthand fp png represent set propositional variables appear call subset model iff tm gammam models shorthand 
cnf propositional theory sat satisfiable iff exists truth assignment satisfies exists tests consider mel problems upwardly closed 
unfortunately models cnf theories upwardly closed 
fact tm models imply tn models oe shall consider positive cnf theories property upward closure hold 
inherent reason enumerate mel linear np exists mel definition 
define transformation cnf propositional theory positive cnf propositional theory 
pn propositional variables theory introduce new propositional variables pn negative occurrence clause replace positive occurrence pn call resulting positive theory pos 
lemma 
positive propositional theory 
ta ae tb words fm cg upwardly closed 
proof 
assume ta ae clause exists atom clause assures truth clause 
atom tb argument 
theorem 
function linear linear exists polynomial enumerate mel linear restricted domain pairs hs jt jsj np complete 
proof 
consider tuple hs 
assume jsj loss generality 
show enumerate mel linear np 
certificate hhs ai mel polynomial verify 
check gamma feg polynomial checked polynomial time 
check total check polynomial 
reduction sat enumerate mel linear 
cnf propositional theory fp png set propositional variables jsj 
loss generality size restricted constant factor assume loss generality fp fp assume constitute truth assignments pre check subproblem sat np complete 
tuple hs constructed respect pos 
fp propositional variables called atoms text 
pn positive propositional theory 
turing machine decides set fa ta pos ta ta cng 
combined test constructed fixed polynomial size respect size input problem sat 
size fixed polynomial size respect size transformation hs preserves size input 
assumed turing machine decides test smaller jsj loss generality 
individual test fa ta monotonic lemma 
union tests monotonic show hs enumerate mel sat 
hs enumerate mel answers passed models pos possible answers model cn sets fp pn answer ta pos 
note pn minimal 
truth assignment constructed satisfy fp ag 
gamma fp pn ag 
truth assignment ta gamma defined gamma 
ta gamma direction sat hs enumerate mel follows similar manner 
theorem devised independently address mfs problem 
noted similar theorem class abduction problems bylander 
proof theorem follows similar manner 
reason restrict domain mel theorem pairs hs jt jsj show mel enumeration problem intractable respect size input set just respect size input set hs naturally general case mel restricted domain np complete follows 
enumerating mfss msss mcss hard mfss easy see mfs problem mapped mel problem discussed 
top element lattice conjunctive query 
query consists literals lattice complete boolean lattice 
test evaluate query database 
call test database edb consider query edb iff evaluates empty set db 
edb monotonic respect subset 
subquery evaluates empty set query 
algorithm mel fast alg 
demonstrates mfs query asking queries database 
shown finding mfss query hard mel 
imagine smarter algorithm finding mfss mels intelligent exploitation database 
shall shown 
necessary show sufficiently hard databases exist 
proof theorem modified show encoding relational tables 
definition 
set mfs defined follows mfs edb mi mel respect edb theorem 
function linear linear enumerate mfs linear np hard 
proof 
proof constructed manner proof 
difference edb needs constructed cnf propositional theory fp png set propositional variables appearing assume loss generality fp fp assume consider pos 
edb constructed atom define binary database relation 
call relations names 
db constructed defining tables tuples relation 
ffl assume pos clauses fc ffl relation fp png construct table way clause fc atom corresponding relation name appear clause insert tuple hj table 
positive considered true 
ffl likewise relation construct table way clause fc atom corresponding relation name appear clause insert tuple hj table 
ffl entries table 
query pn yn pn yn 
length literals 
note empty 
contains pn 
join tables constructed 
subquery length empty single atom clause 
truth assignment satisfying form fp fp assumption assignments 
subquery form pn mfs 
mfss 
show hq edb enumerate mfs linear sat 
hq edb enumerate mfs linear answers passed models pos 
call mfs subset answer say atom satisfy corresponding literal missing answers literal corresponding atom satisfies literal assign corresponding atom value true 
constitutes model pos 
implies model 
direction sat hq edb enumerate mfs linear follows similar manner 
msss may consideration knew minimally failing subqueries mfss query simple procedure determine maximally succeeding subqueries msss query 
course subquery mfs succeeds definition 
reason assume subqueries maximal 
quite surprisingly appear direct procedure determine msss mfss 
knowing mfss help ascertain easily msss vice versa 
mss problem reduced mel problem solved accordingly 
query query msss 
construct test ndb follows ndb fs db gamma test ndb monotonic respect subset reason test edb monotonic 
mels set test ndb database db inverses respect query msss 
mel search finding msss 
proven search msss difficult search mels 
case mfss necessary show sufficiently hard databases mss search 
definition 
set mss defined follows mss ndb mi mel respect ndb theorem 
function linear linear enumerate mss linear np hard 
proof 
proof constructed manner proof 
difference ndb needs constructed cnf propositional theory fp png set propositional variables appearing assume loss generality fp fp assume consider pos 
fp propositional variables pos 
db constructed defining tables tuples relation 
ffl assume pos clauses fc ffl clause fc gamma gamma fp add hj ii table ffl construct view fc fs kg set clauses appears 
table ary 
ng gamma fi add ffl entries table 
query 
conversion shown np hard section 
length literals 
show hq ndb enumerate mss linear sat 
answer tuple form hx exactly msss form gamma fp pn subquery non empty answer set tuple ii answer set construction 
msss different form 
call mss inverse query contain pn literal subquery gamma fp pn known subquery maximal 
ng pn pn answer tuple form hx consider tuple answer set kg check value answer tuple 
say value assigning value true satisfies clause pos construction 
note value construction 
clause satisfied exists model pos 
model pos directly translated model direction sat hq ndb enumerate mss linear follows similar manner 
mcss linear enumeration mcss query necessarily np hard 
say query leads necessarily failure specially designated predicate called contradiction written derivable assuming answer tuple query 
mcs problem reduces abduction problem find smallest set support minimal subset base set facts support 
definition 
set mcs defined follows mcs mi ae theory written logic atom appearing monotonic proof theory applicable logic grounds constants appear abduction problems explored classified 
see 
proof reader 
theorem 
function linear linear enumerate mcs linear np hard 
proof 
proof constructed manner proof 
cnf propositional theory fp png set propositional variables appearing assume loss generality fp fp assume consider pos 
fp propositional variables pos 
theory constructed pos 
ffl assume pos clauses fc ffl clause fc introduce new propositional variable add rule ffl add rule ffl ng add rule pn show hp enumerate mcs linear sat 
mcss form fp pn mcss contains pn ng derivable mcs set 
means derivable 
consider rule derived form hc mcs 
assign true 
resulting model satisfies pos 
model constructed directly satisfies direction sat hp enumerate mcs linear follows similar manner 
enumeration algorithm criteria enumeration algorithm section shown standard algorithm mel mels alg 
highly intractable enumerating mels 
section shown find mels principle intractable 
middle ground 
enumeration algorithm mels properties 
finds subsequent mels quickly possible ffl runs halts quickly priori mels ffl stopped early partial results mels 
exploits decomposability mel problem 
optimal respect test calls test necessary shown find mel 
shown find mels find mels bounded forth 
see section 
enumeration algorithm run bounds enumerating mels sequentially 
problem finding mels set respect test decomposable mels subset passes test mels set 
time find mels subset diminished complexity factor smaller input set 
test may expensive case mfss test evaluate query database number calls test minimized 
factoring lattice problem search strategy mels alg 
mel encountered repeatedly 
arises fact lattice searched 
algorithm mels searches lattice tree 
way problem prune search space lattice mel previously mels rediscovered 
way follows collection mels seen set sublattices lattice 
mel mel 
mel possible construct set sublattices necessary explore sublattice find rest mels danger rediscovering previously seen mel 
construction possible call operation factoring lattice 
definition 
define incomparable iff define factors follows factors fa factor respect iff factors 
define max factors follows max factors fa factors factors ae ag maximal factor respect iff max factors 
theorem 
collection mels mel mel set max factors 
proof 
incomparable sets mels 
factor respect definition 
maximal factor proof complete max factors oe 
maximal factor 
mel construction previously seen mels contained sets max factors 
approach enumerate mels follows 
say collection mels known 
find set max factors known takes jsj steps find mel employing mel fast alg 

factoring simple contradict results theorem 
may maximal factors hl di 
fact shown number possible factors order jlj jdj 
find factor satisfies require examine exponential number factors satisfy 
factoring intractable 
shown np complete respect jdj 
note intractability respect number previously seen mels respect size lattice 
complexity factoring lattice definition 
define class set sat set saturation follows 
set collection subsets hl di set sat iff 
lattices represented top elements sets 
set theoretic abstraction factoring problem introduced previous section 
set sat appear garey johnson catalog np complete problems author knowledge 
proof provided 
theorem 
set sat conp complete 
proof 
reduction sat set sat 
show set sat conp 
hl di set sat iff factor 
size size arbitrary cnf propositional theory set clauses fc clause represented set propositional variables negated propositional variables transformation ffl set propositional variables appear ffl construct fa 
ffl kg separate positive occurrences propositional variables negative occurrences gamma gamma gamma fa gamma gamma fa fs gamma 
show hl di set sat sat 
ae oe kg consider gamma 
choose gamma 
fa cases 
models 
recall definition 

consider gamma gamma gamma 
choose gamma gamma 
note appears negated propositional variable models show direction sat hl di set sat 
model 
set fa cases 

loss generality say 

loss generality say gamma gamma gamma cases 

gamma loss generality 
gamma gamma gamma 

gamma gamma models gamma gamma loss generality say theorem weak imply factoring problem mel enumeration np complete 
mels pairwise incomparable subset 
subclass set sat 
show subclass conp complete employing result theorem proof 
definition 
define class set sat incomparable set saturation follows 
set collection subsets subsets pairwise incomparable hl di set sat iff factor 
theorem 
set sat conp complete 
proof 
reduction set sat set sat 
show set sat conp 
hl di set sat iff factor 
size size input set sat transform follows 
jdj fe 
ffl kg fe note pairwise incomparable 
fs ffe kg jg show hl set sat hl di set sat 
contains exactly contain say fe set constructed 
contain constructed 
assume loss generality gamma fe consider gamma choose gamma 
note gamma gamma 
choose gamma 
note gamma show direction hl di set sat hl set sat 
fe shown member incomparable ffl consider gamma 
choose gamma 
gamma 
gamma ffl consider 
ffl consider assume loss generality ffl consider fe assume loss generality empty 
fe fe construction 
fe clearly factors iff max factors 
theorem demonstrates find new sublattice list seen mels inherently hard 
algorithm factoring factoring shifts computational workload enumeration mels repeated search lattice dividing lattice sublattices factoring lattice 
factoring hard offers computationally better approach enumeration problem 
factoring approach yields performance enumerating number mels performance decaying slowly 
complexity factoring depends size factoring set 
enumerating mels set previously mels 
say factoring routine called mel search call factor routine empty call single mel size forth 
factoring computational bottle neck reasonable number mels accumulated 
seen approach repeated search lattice intractable mel 
algorithm factor alg 
finds maximal factor set top respect previously mels stored array mel mels alg 

written maximal factor returns guaranteed pass test 
approach follows 
previously seen mel considered recursive call factor 
top superset mel element top mel removed order guarantee new set constructed superset mel 
new set passed top recursive call satisfy rest mels 
recursive invocations mels checked remaining set returned new factor 
factor guarantees factor returned superset equivalent mels 
necessary factor guarantee set returned subset mels 
accomplished keeping list inverses top minus current mel stage 
invocation factor removes element top removes element inverses inverse list 
empty indicates factor set constructed subset mels routine fails halts returns false 
routine reduce alg 
implements routine 
required routine factor return maximal factor possible dispense routines justified alg 
shift justs alg 

routines necessary ensure factor maximal 
preferable routine factor find maximal factors 
clearly mels sought maximal factors non maximal ones need considered 
maximal factors returned exploration 
factor candidate tested factor test 
candidate returned passed 
list justifications kept 
justification element removed top constructing factor set 
justification list mels contain element 
removing element top justified guarantees resulting set superset mels 
justification element empty removal justified 
removing element result valid factor just maximal 
search revised second mel search intractable 
array mel set integer boolean factor top factor return factor top factor boolean factor top factor index justs index inv top gamma mel index inv justified mel index justs justs mel return factor top index justs mel choices mel index top false choices ele choices choices choices gamma ele reduce ele ele shift justs ele mel index justs justs ele factor top gamma ele index justs ele ele return test top factor top return true return false algorithm factoring lattice 
boolean reduce ele ele ele return true inv ele inv gamma ele inv ele return false reduce ele ele ele inv ele return true return false algorithm reducing inverses 
boolean justified factor justs justs mel justs justs mel return false justs eje just factor justs mel just return true return justified factor justs justs mel justs mel eje just mel algorithm checking mel justified 
routine justified checks current mel element removed current mel 
current mel added element justification factor recursively called mel 
current mel justified 
case element top mel removed 
mel added new element justification 
mels contain element stored previous justifications removed justifications added new 
removal process leaves previous justifications empty construction illegal factor fails 
enumeration routine factor place easy design rest mel enumeration program 
algorithm enumerate mels alg 

remain maximal factors test true continue generate mels 
algorithm finds mel factor 
note pass loop top returned factor 
algorithm enumerate mels satisfies desired criteria enumeration algorithm outlined section finds mels quickly possible 
fact enumerate mels limited finding mels fixed perform polynomial time 
lemma 
jmax factors jlj jdj proof 
maximal factor respect pairwise incomparable consider maximal factor means jdj set set equivalent minus 
missing maximal 
jaj jlj gamma jdj 
limits number potential maximal factors number subsets size 
number jlj jlj jlj jlj jdj theorem 
algorithm enumerate mels spends jsj jsj gamma time find boolean shift justs ele factor justs new justs steal justs ele justs ele just justs ele new justs ele just ele return true return false boolean steal justs ele justs ele just justs ele justs ele just justs ele return true justs selector ele just steal justs ele justs ele just justs ele append ele just ele just justs ele ele selector ele sets sets sets ele set selector ele sets selector ele sets algorithm shifting justifications 
array mel set integer enumerate mels top factor top factor mel true factor mel mel mel algorithm enumerating mels 
ishmael factor top core index ishmael factor top core index ishmael factor top core index justs index inv top core gamma mel index inv justified mel index justs justs mel ishmael factor top core index justs mel foreach ele mel index top reduce ele ele shift justs ele mel index justs justs ele ishmael factor top gamma ele core index justs ele ele cache test top core ishmael true top core algorithm factoring lattice ishmael 
mels assuming call test costs unit time 
proof 
time mel true called jsj steps spent find mel 
time spent call factor loop depends strictly mels enumerated 
worst case factor enumerates maximal factors searching tests true 
cost bounded number maximal factors 
lemma shows jsj gamma maximal factors gamma mels 
worst case tested find mel 
algorithm satisfy remaining criteria outlined section 
algorithm enumerate mels suboptimal respects 

call factor original set mels far 
call adds mel mel array 
decomposability exploited 
calls factor tend intractability quickly subsequent call larger input set 

redundant computation performed repeated calls factor 
better find subsequent factors backtracking factor algorithm continue exploring search space needing reconstruct search space time 

algorithm factor core set mel true alg 

search space explored repeatedly need 

redundant calls test 
final algorithm enumerating mels eliminate 
call ishmael iterative search minimal elements lattice 
ishmael procedure ishmael factor alg 
rewrite procedure factor 
core set added 
restriction added factor returned superset core 
procedure ishmael alg 
top level procedure 
mels initially checks input set passes test 
mels find 
procedure ishmael true similar mel true alg 

employs core set strategy finds mel time invoked 
similar mels true alg 
proceeds find mels array mel set failure set integer ishmael top test top ishmael true top ishmael true top core top mel core choose ele top cache test top gamma ele core current ishmael true top gamma ele core mel core ishmael factor top gamma ele core ele current ishmael true top gamma ele core ele algorithm ishmael enumerating mels 
input set set set top core 
accomplished calling ishmael factor factor set respect mel just 
procedures ishmael true ishmael factor interleaved 
initial call ishmael factor iterates possible factors calls ishmael true find mels factor 
search space factors traversed repeatedly 
call ishmael true proceeds follows 
invocation ishmael true top core find mels set contain core 
routine chooses element say ele top remove 
resulting subset tests false mels set include ele 
case element added core removed top ishmael true recursively called 
works way mel true alg 

procedure ishmael true splits search space lattice set parts ele ffl subsets set contain ele ffl subsets set contain ele 
ishmael true called find mels set gamma contain core 
ishmael factor called element ele added core 
assures invocation ishmael factor finds mels set contain ele 
just ones contain core contains ele 
ones contain ele 
invocation ishmael factor needs consider mels preceding invocation ishmael true factor lattice mels incomparable set need considered 
notice ishmael factor called core mel mel previous call ishmael true 
factors contain core 
futile look case 
algorithm ishmael satisfies criteria outlined section enumerates mels quickly possible enumerate mels properly exploits decomposability enumeration process minimizes number calls test 
section explains meant minimizing calls test proof ishmael 
minimizing number calls test search mel enumeration test procedure called repeatedly determine current set explored verify set minimal checking immediate subsets fail test 
executing test procedure may expensive 
beneficial limit number calls test procedure 
importantly redundant calls test 
properties hold 
set tested twice 
tested superset tested 
tested subset tested 
guaranteed test called set twice search 
recall algorithm mels calls test repeatedly set 
second third properties relevant test monotonic respect subset 
known likewise known algorithm ishmael exhibits properties inherently exhibit inherently 
ishmael calls cache test test explained 
lemma 
set tested execution ishmael 
furthermore tested superset tested 
proof 
tested call ishmael true top core top core top core immediately 
consider time tested 
activation ishmael true top core tested supersets 
subsets potentially tested 
ishmael factor invoked ishmael true invoked 
mels recorded 
call ishmael factor test supersets guaranteed factoring 
call ishmael true top core may recursive call 
consider return previous activation ishmael true 
call ishmael factor may proceed 
calls ishmael factor ishmael true incomparable mels mels recorded 
tested supersets 
activation ishmael true completes invoking tests 
consider return activation ishmael factor 
calls ishmael true incomparable mels mels recorded 
tested supersets 
note algorithm ishmael calls cache test test 
routine cache test guarantees actual test called set twice subsets tested accomplished caching failures 
routine cache test alg 
shows implementation 
efficient routine written hashing 
eventually mels elements failure cache cache expensive check 
point checking cache may expensive executing boolean cache test set fails false failed set failure fails true fails return false test set return true add failure set return false add failure set index offset index offset set oe failure index offset offset offset offset failure index failure index offset index index gamma offset failure set algorithm test 
test 
time point reached ishmael highly intractable due factoring lattice mels 
question cache really moot issue 
heuristics ishmael offers search strategy enumerating mels better search strategy mels 
considered heuristics directing pruning search ishmael lead improved performance average case 
mfss past focussed heuristics 
heuristics re evaluated light complexity results mel enumeration respect ishmael search strategy 
particular heuristics mfs enumeration considered 
raises point queries potential subqueries need considered searching mfss 
definition 
atoms query joined iff share variable common 
atoms query connected iff joined exists third atom query atom joined second atom connected 
relation connected transitive closure joined 
query said connected iff atoms query connected 
said disjoint 
reasonable insist queries connected 
user ask disconnected parts separate queries 
searching failed subqueries necessary consider connected subqueries 
instance consider subquery ward patient contagious name name 
query connected 
fail ward patient 
contagious name name 
fail independently 
ishmael algorithm mfss modified test disjoint subqueries break connected subqueries test 
extreme single variable literal query shares 

case subqueries connected 
extreme consider query chain 
xn xn 
adjacent literals share unique variable non adjacent literals share variable 
query disjoint 
case subqueries represent contiguous subsequences connected 
counting connected 
great majority subqueries disjoint 
limit probability subquery disjoint 
define connected quite way effect 
assumed general significant number subqueries query disjoint 
handling disjoint queries decomposing speed search mfss significantly average case 
motro suggests certain subqueries materialized query evaluated answer set stored table 
subquery part queries tested subquery need recomputed times 
materialized initially computed 
ishmael shown optimal respect test certain ways 
tests query twice 
query tests true evaluates empty answer set tested query tests false subquery tested 
see section course subqueries queries test true may test false non empty answer sets 
candidates materializing 
clear materialization heuristic 
failing subqueries materialized 
repeatedly components queries 
criteria needed decide choose 
idea warrants consideration 
motro suggests techniques optimizing multiple queries exploited mfs enumeration 
test enumerating mfss note necessary compute answers subquery considered necessary compute answer 
easier computation 
relational database systems facility ask existence queries 
facility greatly speed test 
ishmael allows natural halt heuristic curtail time spent searching mels 
time measured clock number steps algorithm taken number tests 
ishmael guarantees optimal enumeration mels results mels reasonable cut 
worthwhile estimate bounds ishmael guarantee mels algorithm proceeded steps 
bounds limit algorithm number steps tests guaranteed mels algorithm halted case priori mels 
light complexity mel enumeration certain heuristics judged detrimental 
motro imposes bound depth recursion searching maximally generalized failing queries mfss special case 
limit size search space render manageable 
discussed section depth lattice problematic search breadth 
bound heuristic may easily exclude mfss 
answer algorithm find longer guaranteed minimal 
fortunately depth limit necessary ishmael style algorithm 
issues mel problem enumeration algorithms raise number interesting issues 
address issues 
sec 
consider set msss derived set mfss 
sec 
consider probability finding mel 
sec 
outline issues study 
depth limit reasonably large new search space effectively just hard search original 
depth limit small eliminate mfss high probability 
converting mfss msss algorithm ishmael enumerate mfss query 
algorithm run different test find msss query 
section shown problems equal complexity 
mfss query known msss query derivable 
necessary run ishmael ask questions database invoke test times 
set msss deducible set mfss vice versa conversion np hard 
mel stands minimal element lattice passes test stand maximal element lattice fails test 
generalization mss mel generalization mfs 
theorem 
collection mels collection collection immediate subsets mels fb gamma feg ag 
max factors fa max factors ae bg 
proof 
max factors fa max factors ae bg consider max factors 
assume mel subset equivalent 
mel mel mel pairwise incomparable sets contradiction 

superset superset mel maximal factor respect superset 

consider fa max factors ae bg clearly subset mel minimal 
superset mel superset mel 
superset appear max factors 
maximal 
max factors fa max factors ae bg consider ae mel subset cases ffl ae assume max factors ae max factors argument 
means maximal contradicts assumption assume ae clearly subset mel 
means maximal contradicts assumption fs max factors ae bg 
ffl ae clearly equal mels 
mel subset pairwise incomparable set maximal feg means feg superset mel 
please avoid confusion 
fails test 
case mss means subquery non empty answer set succeeds query 
max factors 
theorem 
deducing set set set mels set np hard 
proof 
theorem seen union maximal factors respect immediate subsets sets contained maximal factors 
set immediate subsets polynomial determine 
problem constructing set max factors reducible deducing theorem shows constructing max factors np hard 
constructing np hard 
theorem indicates correlation number mels set number 
theorem hold 
determining mels hard preferable approach mels enumerated running ishmael 
algorithm factor alg 
modified find factors 
call test removed version 
approach calls test needed determine 
probability finding mel mel problem raises paradox offer probabilistic attack np completeness 
shown enumeration linear number mels np complete find mel polynomial 
algorithm mel alg 
demonstrates algorithm finds mel set polynomial time 
note algorithm mel non deterministic 
choose step choose remaining elements set eliminate 
sequence choices leads mel 
chance mel say mel return mel 
equally mel return mel offer probabilistic attack np complete problems 
recall proof theorem 
sat problem encoded mel problem 
mels represent model cnf theory input sat 
assume mels equally find 
mel run non deterministically number times searching mel model 
determine cnf theory model degree confidence require mel run finding mel model linear number times respect degree confidence 
mels equally 
actual case mel offers probabilistic attack np completeness 
worthwhile characterize mels find 
consider fa cg say mels fag fb cg 
fig 
shows lattice mels boxed 
tempting count number paths mel top lattice 
paths fag fa cg remove vice versa 
path fb cg remove path possible mel 
unfortunately paths equally general counting paths sufficient 
example paths considered equally leads probability fag fb cg 
assumed probability mel choosing element set elimination equal choosing 
way measure probability mel returning mel measure likelihood appropriate eliminations result mel remaining discovery 
formalized recurrence equation 
probability finding mel determined set mels known priori 
fg fcg fbg fag fa cg fa bg fb cg fa cg probability finding answer definition 
ps probability mel returning mel collection mels 
consider assume mels sets represented venn diagram fig 

formula calculates probability find fa cg ja ja fa cg ja fa bg gamma gamma gamma gamma cj element chosen mel elimination zero probability 
term absent equation 
choosing element excludes consideration leaving conditional probability element eliminated 
choosing eliminates conditional probability fa cg needs determined 
choosing symmetric case 
generalized recurrence relation 
gamma gamma gamma delta ps gammar fag unfortunately recurrence relation hard solve general 
furthermore requires set mels priori input known advance 
solve specific case 
consider set fp ffl ffe ng ng fp pn gg ffl ffp pn ffl cnf theory converted positive cnf theory pos 
assume set propositional variables fp png 
collection represents possible complete models pn represents collection represents contradictions 
probability mel run return set calculated 
necessary recurrence relation solve 
set size jmj mel element eligible chosen elimination set necessarily contains set consider mel arrived set size set size equally set 
gamma delta sets 
algorithm halts returned 
set eventually returned 
probability set returned gamma delta sterling approximation clearly ae limit 

jlj 
argument holds subset assumed mels set assumed mel 
clearly shows ishmael help solve sat 
leads hypothesis mel tends find mels smaller cardinality high probability 
ishmael means tend find mels smaller cardinality finding larger cardinality 
tendency may news 
applications mels smaller cardinality preferred 
abduction instance small set conditions holds large set conditions general 
fact mel algorithms find smaller sets beneficial 
worthwhile adapt algorithms extended lattices proposed motro section 
removing atoms query atoms relaxed 
maximally generalized failing queries 
mfss special case 
clearly complexity enumerating hard enumerating mfss 
appear worse 
algorithm mel adapted extended lattice 
assume literal query relaxed steps 
number steps find maximally generalized query delta possible modify ishmael search extended lattice 
new factoring algorithm replacements eliminations needed 
issues need addressed providing cooperative technique right 
particular relaxation operators relax atoms query provided step size relax condition determined 
type information available databases information manifested 
motro introduces supposition architecture system decides relax atoms 
consider taxonomic information represented inherently rules deductive database relax atoms queries 
chu consider extract employ taxonomic information relational database implemented system 
heuristics bounds needed ensure extended lattice searched finite 
fig 
lattice infinite limit needed far condition relaxed 
complexity analyses variations mel enumeration beneficial 
interesting explore conditions placed mels qualify answers problem stay complexity bounds 
clearly desirable conditions push problem intractability 
bylander look issues abduction problems 
instance adds condition answer mel minimum cardinality problem intractable find 
conditions added enumeration problem harder 
may useful certain problem domains 
algorithms designed past search minimal failing maximally succeeding subqueries ineffective highly intractable 
largely due fact complexity nature problems ill understood 
presents complexity profile problems presents algorithmic approach 
algorithms possible build practical facilities relational database systems finding presenting mfss msss 
facilities enable database systems give cooperative responses users case user query fails database systems easier 
databases growing size complexity database applications queries 
means cooperative techniques identifying mfss msss indispensable database systems 
organizations owning large valuable data stores growing interest data mining 
see 
data stores examined general patterns may characterizations data general 
characterization may reflect hidden semantics data large 
query fails evaluated database may simply data provides answer may query fail due semantics database 
distinction drawn section 
offers potential data mining tool :10.1.1.18.1674
query fails proof fail guaranteed integrity constraints database possible query represents missing integrity constraint 
failing queries collected analyzed program database administrator 
failing queries may promoted integrity constraints 
technique effective mfss failing queries considered queries 
mfss offer logically stronger statements better characterize database integrity constraints 
general results mel enumeration may applicable number domains outside databases 
certain semantics logic programs exists need minimization proof procedure 
arises deduction negative information non monotonic rule negation 
problem encountered proof procedure stable theories fern andez lobo 
enumeration minimal answers proof procedure follows complexity enumerating mels 
case answers desired 
ishmael style algorithm enumeration 
done domain abductive reasoning 
abductive reasoning tasks complex mel enumeration 
fair amount known complexity abductive reasoning enumeration algorithms ishmael may new domain 
algorithms ishmael may useful enumeration possible abductive supports needed 
interest minimal failing subqueries came originally interest false presuppositions natural language dialog 
kaplan lee showed identification problem false presuppositions independent natural language problem finding false presuppositions depends solely logical structure statements 
false presuppositions problem addressed databases 
may possible techniques adapted natural language systems identify false presuppositions occur natural language dialog 
acknowledgments number people contributed ideas 
jos alberto fern andez formalizing mel problem characterization mfs 
yuan liu lev contributed discussions search strategies 
carolina ruiz sergio alvarez helped characterize recurrence relation determining probabilities mels 
jack minker contributed support research discussions 
john guthrie william proofing suggestions led improvement 
research supported national science foundation iri air force office scientific research afosr 
belnap steel 
logic questions answers 
yale university press new haven ct 
bylander tanner josephson 
computational complexity abduction 
artificial intelligence 
chu 
cooperative database system 
imielinski pages 
appear 
chu chen 
lee 
structured approach cooperative query answering 
ieee transactions knowledge data engineering 
cole morgan editors 
syntax semantics 
academic press 
colmerauer 
natural logic 
gallaire pages 
kaplan wiederhold 
cooperative responses boolean queries 
international conference data engineering pages silver spring maryland 
ieee computer society press 
cormen leiserson rivest 
algorithms 
mit press cambridge massachusetts 
imielinski editors 
non standard queries answers 
oxford university press 
appear 
fern andez lobo 
proof procedure stable theories 
technical report umiacs tr cs tr university maryland institute advanced computer studies department computer science university maryland college park 
frawley piatetsky shapiro matheus 
knowledge discovery databases overview 
piatetsky shapiro frawley chapter 
godfrey minker 
overview cooperative answering 
journal intelligent information systems 
invited 
godfrey minker 
relaxation platform cooperative answering 
journal intelligent information systems 
godfrey minker 
overview cooperative answering 
imielinski pages 
appears 
godfrey minker 
cooperative answering system 
voronkov editor proceedings logic programming automated reasoning conference lecture notes artificial intelligence pages 
springer verlag st petersburg russia july 
gal 
cooperative responses deductive databases 
phd thesis department computer science university maryland college park maryland 
gal minker 
natural language database interface provides cooperative answers 
proceedings second conference artificial intelligence applications december 
gal minker 
informative cooperative answers databases integrity constraints 
dahl saint editors natural language understanding logic programming pages 
north holland 
gallaire minker 
nicolas editors 
advances database theory volume 
plenum press new york 
garey johnson 
computers intractability guide theory npcompleteness 
series books mathematical sciences 
freeman new york 
godfrey minker 
architecture cooperative database system 
litwin risch editors proceedings international conference applications databases lecture notes computer science pages 
springer verlag sweden june 
minker 
optimization deductive conventional relational data base systems 
gallaire pages 
grice 
logic conversation 
cole morgan 

feasibility informative answers 
gallaire pages 
joshi webber sag editors 
elements discourse understanding 
cambridge university press 
kaplan 
appropriate responses inappropriate questions 
joshi pages 
kaplan 
cooperative responses portable natural language query system 
artificial intelligence oct 
lee 
conversational aspects database interactions 
proceedings th international conference large data bases berlin 

correcting misconceptions database structure 
proceedings 
mccoy 
correcting object related misconceptions 
proc 
coling stanford university california july 
motro 
mechanism verifying user presuppositions query systems 
acm transactions office information systems october 
motro 
flex tolerant cooperative user interface databases 
ieee transactions knowledge data engineering june 
piatetsky shapiro frawley editors 
knowledge discovery databases 
aaai press mit press menlo park california 
sellis 
multiple query optimization problem 
ieee transactions knowledge data engineering june 
siegel 
rule discovery query optimization 
piatetsky shapiro frawley chapter 
strawson 
logical theory 
methuen london 
ullman 
principles database knowledge base systems volume principles computer science series 
computer science press incorporated rockville maryland 

