opportunistic data structures applications paolo ferragina universita di pisa giovanni manzini universita del address issue compressing indexing data 
devise data structure space occupancy function entropy underlying data set 
call data structure opportunistic space occupancy decreased input compressible space reduction achieved significant slowdown query performance 
precisely space occupancy optimal information content sense text stored bits input symbol worst case kth order empirical entropy bound holds fixed 
arbitrary string opportunistic data structure allows search occ occurrences occ log time fixed 
data achieve best space bound currently known compressible data solution improves succinct suffix array classical suffix tree suffix array data structures space query time :10.1.1.156.968:10.1.1.156.968:10.1.1.156.968
study opportunistic data structure dynamic setting devise variant achieving effective search update time bounds 
show plug opportunistic data structure glimpse tool :10.1.1.17.6054
result indexing tool achieves sublinear space sublinear query time complexity 
data structure central concept algorithmics computer science general 
decades investigated different points view basic ideas enriched new functionalities aim cope features peculiar setting dynamic persistent self adjusting implicit fault tolerant just cite 
dipartimento di informatica universita di pisa pisa italy 
email di unipi 
supported part italian murst project algorithms large data sets science engineering unesco 
dipartimento di scienze universita del italy imc cnr pisa italy 
mail manzini mfn 
supported part murst funds 
space reduction data structural design attractive issue exponential increase electronic data nowadays available intimate relation algorithmic performance improvements see knuth bentley 
motivated interest design implicit data structures basic searching problems see 
goal reduce possible auxiliary information kept input data introducing significant slowdown query performance 
input data represented entirety advantage possible 
importance issues known programmers typically various tricks squeeze data possible achieve query performance 
approaches boil heuristics effectiveness witnessed experimentation 
address issue compressing indexing data studying theoretical framework 
best knowledge result known literature study interplay compression indexing data collections 
exploitation data compressibility investigated respect impact algorithmic performance context line algorithms caching prefetching string matching algorithms see sorting computational geometry algorithms 
scenario 
research design indexing data structures directed devise solutions offer trade query update time versus space usage 
main approaches indices full text indices 
achieve succinct space occupancy cost mainly limited index linguistic texts achieve versatility guaranteed performance cost requiring large space occupancy see :10.1.1.51.7802
progress full text indices achieved asymptotical linear space unavoidable word indices appealing space occupancy primary concern :10.1.1.156.968
context compression appears attractive choice mandatory 
processing speed currently improving faster rate disk speed 
compression decreases demand storage expenses processing economical store data compressed form uncompressed 
starting promising considerations researchers concentrated compressed matching problem introduced task performing string matching compressed text decompressing 
collection algorithms currently known solve efficiently possibly optimally problem text compressed means various schemes run length lz lz huffman :10.1.1.21.2850:10.1.1.156.968
results asymptotically faster classical scan methods rely scan compressed text result unacceptable large text collections 
approaches combine compression indexing techniques nowadays receiving attention especially context word indices achieving experimental trade offs space occupancy query performance see :10.1.1.17.6054:10.1.1.51.7802
interesting idea direct compression index data structure proposed properties lempel ziv compression scheme exploited reduce number index points supporting pattern searches 
result index requires provably sublinear space cost limiting search grams worsening significantly query performance 
natural question arises point full text indices need space occupancy linear uncompressed text size order support effective search operations arbitrary patterns 
common belief space overhead paid full text indices provable need :10.1.1.51.7802
results 
answer questions providing novel data structure indexing searching space occupancy function entropy underlying data set 
data structure called opportunistic assumption particular distribution takes advantage compressibility input data decreasing space occupancy significant slowdown query performance 
data structure provably space optimal information content sense stores text bits input symbol worst case fixed kth order empirical entropy 
expresses maximum compression achieve character code depends characters preceding 
point case string space occupancy bits optimal concept opportunistic algorithm introduced characterize algorithm takes advantage compressibility text speed scan search operations :10.1.1.156.968:10.1.1.156.968:10.1.1.156.968
turn concept opportunistic data structure 
compressible string opportunistic data structure achieve sublinear space occupancy 
arbitrary pattern opportunistic data structure allows search occ occurrences occ log time fixed 
novelty approach resides careful combination burrows wheeler compression algorithm suffix array data structure obtain sort compressed suffix array 
show augment information kept burrows wheeler algorithm order support effective random accesses compressed data need query time 
design algorithms operating opportunistic data structure 
algorithm effective approach search arbitrary pattern compressed suffix array time worst case section 
second algorithm exploits compression speed retrieval actual positions pattern occurrences incurring log time slowdown fixed section 
sense result interpreted method compress suffix array support effective searches arbitrary patterns 
seminal manber myers introduced suffix array data structure showing search pattern log occ time worst case 
suffix array uses log bits storage 
grossi vitter reduced space usage suffix arrays bits cost requiring log time retrieve th suffix :10.1.1.156.968:10.1.1.156.968:10.1.1.156.968
searching succinct suffix array classical manber myers procedure takes log occ log time 
solution improves succinct suffix array space query time complexity :10.1.1.156.968:10.1.1.156.968:10.1.1.156.968
authors introduce hybrid indices achieve better query time complexity require bits storage :10.1.1.156.968:10.1.1.156.968:10.1.1.156.968
far problem counting pattern occurrences concerned solution improves classical suffix tree suffix array data structures achieve time complexity occupy log bits storage 
section investigate modifiability opportunistic data structure studying basic ideas dynamic setting 
show dynamic text collection 
size stored 
bit input symbol fixed short texts support insert operations individual texts log amortized time delete operations log amortized time search pattern log occ log time worst case 
point case text space bounds best known ones data structures support updates dynamic case left open section :10.1.1.156.968:10.1.1.156.968:10.1.1.156.968
investigate applications ideas development novel text retrieval systems concept block addressing introduced glimpse tool :10.1.1.17.6054
notable feature block addressing achieve sublinear space overhead sublinear query time inverted indices achieve second goal 
unfortunately known block addressing indices achieve time space restrictive conditions block size 
show opportunistic data structure devise novel block addressing scheme called standing compressed glimpse achieves time space 
background text drawn constant size alphabet 
central concept discussion suffix array data structure 
suffix array built array containing lexicographically ordered sequence suffixes represented pointers starting positions integers 
instance 
clearly requires log bits lot indexing large text collections 
long standing belief suffix arrays apparently random permutation suffix pointers 
results data compression field opened door revolutionary ways compress suffix arrays basic tools data structure 
burrows wheeler propose transformation consisting reversible permutation text characters gives new string easier compress 
tends group characters occur adjacent similar text substrings 
nice property exploited locally adaptive compression algorithms move front coding combination statistical huffman arithmetic coders structured coding models 
compressors best compressors currently available achieve compression ratio relatively small time space 
reversible 
distinguish forward transformation produces string compressed backward transformation gives back original text transformed 
forward consists basic steps append special character smaller text character form conceptual matrix rows cyclic shifts string sorted lexicographic order construct transformed text column notice column permutation column particular column call obtained lexicographically sorting characters strong relation matrix suffix array string sorting rows matrix essentially sorting suffixes consequently entry points suffix occupying prefix ith row cost performing forward cost constructing suffix array requires time 
cyclic shift rows crucial define backward easy prove observations ith row character precedes character original text 

number occurrences prefix 
th row starting character column corresponding located 
call lf mapping mapping set lf ready describe backward 
compute array storing number occurrences characters 
notice position occurrence 

define lf mapping lf follows lf equals number occurrences character prefix see observation 

reconstruct backward follows set lf 
shown derive suffix array linear time context pattern searching algorithm better known opportunistic algorithms 
implicit presence suffix array suggests take full advantage structure fast searching high compressibility space reduction 
ultimate hope indexer succinct fast 
section show result achievable provided slowdown wrt suffix array introduced cost listing pattern occurrences 
bw denote column output 
indexing data structure consists compressed version bw auxiliary array data structures support random access bw compress bw steps see 
move front coder briefly mtf encode character count distinct characters seen previous occurrence 
structural properties bw mentioned imply string mtf mtf bw dominated low numbers 

encode run zeroes mtf run length encoding rle 
precisely replace sequence number written binary significant bit discarding significant bit 
encoding new symbols resulting string rl rle mtf alphabet 

compress rl means variable length prefix code called pc encodes symbols bits symbol variable length prefix code blog bits zero 
resulting algorithm bw mtf rle pc sufficiently simple rest concentrate searching algorithm distracted details compression 
despite simplicity bw results possible show proof full exists constant jt log jt kth order empirical entropy 
expresses maximum compression achieve character code depends characters preceding 
searching compressed text denote arbitrary text alphabet bw 
section describe algorithm pattern reports occurrences uncompressed text looking 
algorithm relation suffix array matrix recall suffix array posses nice structural properties usually exploited support fast pattern searches suffixes text prefixed pattern occupy contiguous portion subarray ii subarray starting position sp position ep sp lexicographic position string ordered sequence text suffixes 
step counting occurrences describe algorithm called bw count identifies positions sp ep accessing compressed string auxiliary array data structures 
bw count consists phases preserving invariant th phase parameter sp algorithm bw corresponds procedure described algorithm bw count 

sp ep 
sp ep 

sp occ sp 
ep occ ep 

ep sp return pattern return ep sp occurrences 
algorithm counting number occurrences 
points row prefixed parameter ep points row prefixed 
pseudo code fig 

phase sp ep determined array defined section step 
values sp ep updated steps subroutine occ reports number occurrences bw 
note steps computing lf mapping respectively occurrence bw sp ep 
generic ith phase ep conclude occur 
final phase sp ep delimit portion suffix array containing text suffixes prefixed integer ep sp account number occurrences lemma proves correctness bw count assuming occ works claimed proof full 
lemma occurs step resp 
step bw count correctly updates value sp resp 
ep pointing resp 
row prefixed 
running time bw count depends cost procedure occ 
describe algorithm computing occ time ram word size log bits 
logically partition transformed string bw substrings characters called buckets denote bt bw 
partition naturally induces partition mtf buckets bt mtf bt mtf size 
assume run zeroes mtf entirely contained single bucket describe algorithm computing occ simplifying assumption 
general case sequence zeroes may span buckets similar discussion deferred full 
assumption buckets bt mtf induce partition compressed file compressed buckets bz bz defined bz pc rle bt mtf 
bt denote bucket containing character bw dk 
computation occ hierarchical decomposition bw substrings follows longest prefix bw having length multiple bt 
bt ii longest prefix remaining suffix having length multiple bt 
bt iii remaining suffix bw prefix bucket bt compute occ summing number occurrences substrings 
done time sublinear space auxiliary data structures 
calculations substring point array stores entry number occurrences character bt 
bt array stores entry value equals sum sizes compressed buckets bz bz calculations substring point ii array stores entry number occurrences character string bt 
bt concatenated string length 
array stores entry value equals size compressed buckets bz bz value bounded 
calculations compressed buckets array mtf stores entry mtf picture state mtf list encoding bt entry takes log bits bits 
table stores entry number occurrences characters compressed string assuming picture mtf list produce entry bz mtf stores number occurrences bt 
table entries occupying log bits maximum length compressed bucket 
computation occ proceeds follows 
bucket bt containing character bw determined dk position character bt parameter number occurrences prefix bt 
bt point determined number occurrences substring bt bt point ii determined 
compressed bucket bz retrieved notice starting position number occurrences bt accounted accessing bz mtf time 
sum quantities gives occ 
construction compressed bucket bz size blog bits 
choose log log 
assumption step occ consists arithmetic operations table lookup operations involving log bit operands 
consequently call occ takes time ram 
far space occupancy concerned arrays take log log bits 
arrays take log log log log bits 
array mtf takes log bits 
table consists log bit entries occupies log log log log bits 
conclude auxiliary data structures occ occupy log log log bits addition compressed file 
theorem denote output algorithm bw input 
number occurrences pattern computed time ram 
space occupancy jzj log log log bits worst case 
step ii locating occurrences consider problem determining exact position text occurrences pattern 
means sp sp ep want find text position pos suffix prefixes sth row 
propose approaches simple slow second faster relies special properties string bw algorithm logically mark rows correspond text positions having form log 
store marked rows starting positions corresponding text suffixes explicitly 
preprocessing done compression time 
query time find pos follows 
marked row done position directly available 
lf mapping find row corresponding suffix pos 
iterate procedure times points marked row point pos available set pos pos crucial point algorithm logical marking rows corresponding text suffixes starting positions 
solution consists storing row numbers level bucketing scheme 
partition rows buckets size log 
bucket take marked rows lying store packet tree key distance bucket 
bucket contains log keys log log bits long membership queries take time ram 
space required logical marking log log bits 
addition marked row keep starting position corresponding text suffix pos requires additional log bits marked row 
consequently space occupancy log log bits 
concerns time complexity algorithm computes pos log steps constant time 
occ occurrences pattern retrieved occ log time space overhead log bits 
combining results section theorem text preprocessed time occ occurrences pattern listed occ log time ram 
space occupancy bounded log log log bits input symbol worst case fixed 
refine algorithm order compute pos log time fixed 
idea marking rows introduce shortcuts allow move character time reducing number steps required reach marked position 
key ingredient new approach procedure computing lf mapping string drawn alphabet non constant size proof details full lemma string arbitrary alphabet compute lf mapping bw log time log log bits storage 
lemma compute pos log time intermediate result refined achieve final log time bound 
compression time logically mark rows correspond text positions form log 
consider string obtained grouping characters blocks size clearly length characters belong alphabet denote matrix associated notice consists marked rows mark rows corresponding suffixes starting positions jt log 
rows explicitly keep starting position corresponding text suffixes 
compute pos compute lf mapping reach marked row compute pos finding corresponding row computing lf mapping lemma reach marked row pos explicitly available construction 
marking counting number marked rows precede marked row required order determine position done constant time log log bits storage packed tree level bucketing scheme 
addition jt rows keep explicitly positions take jt log log bits storage 
space occupancy procedure computing lf mapping bw lemma 
simple algebraic calculation yields space occupancy log bits input symbol fixed time complexity algorithm finding marked row plus log finding marked row log time 
final time bound log computation pos achieved iterating approach follows 
main idea take log apply procedure computing lf mapping log steps identifying row matrix pos form log 
define string obtained grouping characters blocks size consider corresponding matrix construction corresponds row iterate scheme 
jth step operate matrix find row pos form log 
continues reaches value point matrix consists log rows 
choose store explicitly starting positions pos marked text suffixes sublinear space bits 
summing algorithm computes pos iterations log time 
arbitrary positive constant clear rewrite previous time bound log log 
space occupancy dominated required marking theorem text indexed occ occurrences pattern listed occ log time ram 
space occupancy log log log bits input symbol worst case fixed 
approach 
dynamic collection texts ft tm having arbitrary lengths total size collection 
may shrink grow time due insert delete operations allow add remove 
individual text string 
aim store 
succinct space perform update operations efficiently support fast searches occurrences arbitrary pattern 
texts 
problem solved optimal time complexity log bits storage 
section aim compressed index order keep 
reduced space able efficiently support update search operations 
result exploits elegant technique proposed adapted manage items variable lengths texts 
bound space occupancy data structure terms entropy concatenation 
texts 
better space reduction possibly achieved compressing separately texts 
texts similar statistics entropy concatenated string reasonable lower bound compressibility collection 
furthermore probabilistic setting assume text generated probabilistic source entropy concatenated string coincides entropy single texts provides tight lower bound compressibility collection 
focus situation length searched pattern log range values search operation implemented brute force way decompressing text collection searching scan string matching algorithm log occ time 
partition texts log collections containing texts length log 
possible independently lengths text strings 
upper bound length searchable patterns allows split long texts texts lengths log log pieces overlapping log characters 
covering single long text shorter ones allows find occurrences searched patterns 
collection partitioned series subsets defined follows contains texts having length range log 
set simultaneously indexed compressed opportunistic data structure 
searching arbitrary pattern 
log performed searching log subsets compressed index built 
takes log occ log time 
inserting new text 
consists inserting sets empty 
subset selected blog tc inserted approach 
empty compressed index built associated subset time 
new set ftg formed inserted subset empty insertion process propagated empty subset 
point compressed index built set ftg concatenating texts contained set form unique string texts separated special symbol usual 
noticing texts length conclude propagation process complexity proportional length moved texts 
single insertion may costly amortize cost charging log credits text character log obtaining amortized cost log insert 
care taken evaluate space occupied reconstruction set fact construction compressed index set requires suffix tree data structure compute log bits auxiliary storage 
ensured collection contains texts having length log 
log bits suffices support reconstruction process 
show support text deletions 
main problem side physically cancel texts order avoid listing ghost occurrences belonging texts longer 
side physical deletion time consuming performed fly 
amortization care taken answering query properly deal texts logically deleted 
sake presentation bw texts stored set store balanced search tree set interval positions bw occupied deleted text suffixes 
pattern occurrence bw compressed index check log time real ghost occurrence 
time text deleted search suffixes update accordingly log time 
additional space required store balanced search tree ji log log bits assuming physically delete texts soon fraction log suffixes logically marked 
set may undergo log reconstructions shrinks move back previous set consequently amortized cost delete log log log term denotes cost update second term accounts credits left order pay physical deletions 
identify text deleted append text 
identifier log bits keep track subset containing text table 
introduces overhead log bits reasonably assume texts short log bits 
theorem 
dynamic collection texts ft tm having total length occ occurrences pattern texts 
listed log occ log time worst case 
operation insert adds new text 
log amortized time 
operation delete removes text 
log amortized time 
space occupancy 
log bits input symbol worst case fixed 
simple application glimpse effective tool index linguistic texts :10.1.1.17.6054
high level point view hybrid inverted files scan approaches index 
relies observation need index word exact location occurs inverted files pointers area word occurs called block maintained 
glimpse assumes text logically partitioned blocks size index consists parts vocabulary containing distinct words text word list blocks word occurs 
blocking scheme induces space savings pointers word occurrences shorter occurrences word single block represented 
typically index compact original text size :10.1.1.17.6054
index structure search scheme proceeds steps queried word searched vocabulary candidate blocks sequentially examined find occurrences 
complex queries approximate regular expression searches supported agrep vocabulary block searches :10.1.1.48.8488
clearly search efficient vocabulary small query selective block size large 
requirements usually met practice main constraint effective glimpse remains strict relation block pointer sizes text sizes 
theoretical experimental analysis block addressing scheme shown glimpse approach effective medium sized texts roughly mb 
papers tried overcome limitation compressing text block individually searching proper opportunistic string matching algorithms :10.1.1.21.2850
experimental results showed improvement final performance implicitly proving second searching step dominates glimpse query performance 
opportunistic index naturally fits framework allows extend applicability larger text databases 
new approach named compressed glimpse shortly consists opportunistic data structure index text block individually way candidate block fully scanned query time index employed detection pattern occurrences 
sense compromise full text index suffix array word index inverted list compressed text 
theoretical investigation performance feasible model generally accepted information retrieval 
assumes heaps law model vocabulary size generalized zipf law model frequency words text collection largest ith frequency word normalization term parameter larger assumes number matches word errors 
hypothesis show achieves sublinear space overhead sublinear query time independent block size proof full 
conversely inverted indices achieve second goal classical glimpse achieves goals restrictive conditions block size :10.1.1.51.7802
issues remain investigated various models computation 
external memory interesting devise compressed index takes advantage blocked access disk achieves occ os locating pattern occurrences disk page size 
ram interesting avoid log overhead incurred listing pattern occurrences 
full show known techniques see designing hybrid indices achieve occ retrieval time cost restrictive conditions pattern length number pattern occurrences 
guaranteeing occ retrieval cost general case open problem uncompressed setting :10.1.1.156.968:10.1.1.156.968:10.1.1.156.968
amir benson 
efficient dimensional compressed matching 
proceedings ieee data compression conference pages 
amir benson farach :10.1.1.156.968
sleeping files lie pattern matching compressed files 
journal computer system sciences 
andersson 
sorting searching revisited 
karlsson lingas editors proceedings th scandinavian workshop algorithm theory pages 
springer verlag lncs 
baeza yates navarro 
block addressing indices approximate text retrieval 
journal american society information science 
bentley 
programming pearls 
addison wesley usa 
bentley sleator tarjan wei 
locally adaptive compression scheme 
communication acm 
burrows wheeler 
block sorting lossless data compression algorithm 
technical report digital equipment 
chen reif 
difficulty prediction decrease computation fast sort priority queue convex hull entropy bounded inputs 
proceedings th ieee symposium foundations computer science pages 
farach thorup 
string matching lempel ziv compressed strings 
algorithmica 
ferragina grossi 
string tree new data structure string search external memory applications 
journal acm 
ferragina muthukrishnan 
multimethod dispatching geometric approach applications string matching problems 
proceedings st acm symposium theory computing pages 
grossi vitter :10.1.1.156.968:10.1.1.156.968:10.1.1.156.968
compressed suffix arrays suffix trees applications text indexing string matching 
proceedings nd acm symposium theory computing 
sutinen 
lempel zip index grams 
serna editors proceedings th european symposium algorithms pages 
springer verlag lncs 
ukkonen 
lempel ziv parsing sublinear size index structures string matching 
ziviani baeza yates editors proceedings rd south american workshop string processing pages 
carleton university press 
karlin phillips raghavan 
markov paging extended 
proceedings rd ieee symposium foundations computer science pages oct 
knuth 
sorting searching volume art computer programming 
addison wesley reading ma usa second edition 
krishnan vitter 
optimal prediction prefetching worst case 
siam journal computing dec 
manber myers 
suffix arrays new method line string searches 
siam journal computing 
manber wu :10.1.1.17.6054
glimpse tool search entire file systems 
proceedings usenix winter technical conference pages 
manzini 
analysis burrows wheeler transform 
proceedings th acm siam symposium discrete algorithms pages 
full version www imc pi cnr manzini tr 
mccreight 
space economical suffix tree construction algorithm 
journal acm 
mehlhorn overmars :10.1.1.156.968
optimal decomposable searching problems 
information processing letters apr 
munro 
succinct data structures 
proceeding th conference foundations software technology theoretical computer science 
springer verlag lncs 
navarro de moura ziviani baeza yates :10.1.1.21.2850
adding compression block addressing inverted indexes 
information retrieval journal appear 
overmars van leeuwen 
worst case optimal insertion deletion methods decomposable searching problems 
information processing letters aug 

modified burrows wheeler transformation case insensitive search application suffix array compression 
proceedings ieee data compression conference 
witten moffat bell :10.1.1.51.7802
managing gigabytes compressing indexing documents images 
morgan kaufmann publishers los altos ca usa second edition 
wu manber :10.1.1.48.8488
agrep fast approximate patternmatching tool 
proceedings usenix winter technical conference pages 
usenix association 
