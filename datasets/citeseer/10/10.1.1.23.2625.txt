astoot approach testing object oriented programs ko sun microsystems laboratories california frankl polytechnic university brooklyn ny describes new approach unit testing object oriented programs set tools approach case studies 
approach test case consists tuple sequences messages tags indicating sequences put objects class test equivalent states return objects equivalent states 
tests executed sending sequences objects class test invoking user supplied equivalence checking mechanism 
approach allows substantial automation aspects testing including test case generation test driver generation test execution test checking 
experimental prototypes tools test generation test execution described 
test generation tool requires availability algebraic specification data type tested test execution tool formal specification available 
test execution tools case studies involving execution tens thousands test cases various sequence lengths parameters combinations operations performed 
relationships likelihood detecting error sequence length range parameters relative frequency various operations investigated priority queue sorted list having subtle errors 
case long sequences tended detect error provided range parameters sufficiently large likelihood detecting error tended increase threshold value parameter range increased 
key words software testing object oriented programming data types algebraic specification object oriented programming concepts data abstraction inheritance dynamic binding increasingly popular software development methodology 
research done developing object oriented analysis design techniques developing object oriented programming languages exploring methodology research supported part nsf ccr ccr new york state science technology foundation performed author polytechnic university 
authors address department computer science polytechnic university center brooklyn ny 
mail morph poly edu 
changes software development process 
relatively little research addressed question object oriented programs tested 
developed new approach unit testing object oriented programs ideas natural units test classes testing classes focus question sequence messages puts object class test correct state 
approach roughly speaking test case consists pair sequences messages tag indicating sequences result objects state 
test case executed sending sequence messages object class test invoking user supplied equivalence checking routine check objects state comparing result check tag 
testing scheme nice properties ffl expected results tests included test cases concise format boolean independent class tested 
facilitates automatic checking test results 
ffl test drivers different classes similar automatically generated class interfaces 
ffl algebraic specification class test available term rewriting generate test cases automatically 
algebraic specification available person develop test cases reasoning informal specification 
approach embodied prototype testing system astoot set tools object oriented testing includes interactive specification test case generation tool tool automatically generates test drivers 
class astoot automatically generate test driver turn automatically executes test cases checks results 
addition algebraic specification available astoot partially automate test generation 
system allows substantial automation entire testing process 
current version astoot targeted testing programs written eiffel assume classes tested written eiffel 
underlying ideas tools adapted relatively easily object oriented languages 
section review relevant background material software testing object oriented programming algebraic specification data types 
section describes ideas underlying astoot correctness class implements data type test case format test result checking 
tools described section 
section describes case studies performed order gain insight generate test cases 
compare approach related section note directions section 
eiffel trademark nonprofit international consortium eiffel nice 
background background software testing testing time consuming parts software development process 
increased automation testing process lead significant saving time allowing thorough testing 
aspects testing process potentially partially automated test data generation test execution test checking 
approach testing object oriented programs involves areas 
obvious opportunity partially automating testing generation test cases 
order automate test generation necessary analyze formal object source code formal specification 
research automated test generation involved program white box techniques techniques analysis source code program tested 
white box testing suffers certain limitations inability generate test cases intended exercise aspects specification inadvertently omitted program 
black box specification techniques analysis program specification overcome limitations automated kind formal specification available 
manual black box test generation techniques informal specifications widely practice 
testing scheme described black box approach automatable formal algebraic specification available applied manually 
area potential automation construction test drivers 
testing methods applied individual subprograms 
program unit tested program inputs outputs usually sets files 
unit tested procedure function inputs outputs may include values parameters global variables values read written files 
order test procedure necessary build driver program initializes global variables actual parameters appropriate values calls procedure outputs final values relevant globals parameters 
quite cumbersome initialize inputs check values outputs 
particularly unwieldy case objectoriented programming parameters complicated types 
model described testing object oriented programs circumvents problem 
problem arises testing software oracle problem running program test case necessary check result agrees specification non trivial problem example great deal output difficult calculate correct value 
testing method uses novel approach allows correctness test cases checked automatically test execution system 
overview object oriented programming object oriented languages support data types inheritance dynamic binding 
data type entity encapsulates data operations manipulating data 
object oriented programming programmer writes class definitions implementations data types 
object instance class created dynamically instantiation operation called new create 
language supports inheritance classes organized directed acyclic graph definitions shared reflecting common behavior objects related classes 
class consists interface lists operations performed objects class body implements operations 
state object stored instance variables called attributes static variables local object 
class operations called methods 
object oriented programs computation performed sending messages objects 
message invokes object methods arguments 
invoked method may modify state object send messages objects 
method completes execution returns control cases returns result sender message 
inheritance mechanism object oriented languages facilitates development new classes share aspects behavior old ones 
descendent subclass class inherits instance variables methods may extend behavior adding additional instance variables methods specialize redefining methods provide alternative implementations 
dynamic binding mechanism associate methods objects 
strongly typed object oriented languages legal assign object class variable class vice versa 
doing message sent object invoke method associated class example consider class polygon subclasses triangle square redefines polygon perimeter method 
assigning object class square variable class polygon sending perimeter message invoke square perimeter method 
allows construction polymorphic data types 
examples object oriented languages include smalltalk eiffel 
ada modula strictly speaking object oriented languages provide support data abstraction ideas discussed relevant 
see overview object oriented approach 
algebraic specification data types talk test class concept means correct 
means formal informal specifying entity intended implement stating conditions implementation conforms specification 
case intended implement data type algebraic specifications provide formal means doing 
algebraic specification syntactic part semantic part 
syntactic part consists function names signatures types take input produce output 
algebraic specification type functions return values types called observers provide ways query contents functions return values type called constructors transformers transformers called extensions 
distinction constructors transformers clarified 
semantic part specification consists list axioms describing relation functions 
specification techniques allow list preconditions describing domains functions allow functions return error values indicating function applied element outside domain 
term rewriting define formal semantics algebraic specifications 
sequences operations adt equivalent axioms rewrite rules transform specification modeled heterogeneous word algebra elements equivalence classes sequences operations 
specification useful consistent sufficiently complete 
consistent specification contain contradictory axioms contradiction derivable operation sequences specification 
set containing operation sequences consisting constructors transformers sufficiently complete sequence result applying observer defined 
discussion construct useful algebraic specifications 
algebraic specification languages functional notation 
convenience designed specification language syntax similar oo programming language syntax :10.1.1.23.2625
syntactic part specification includes export section lists operations available users adt 
designer specification classify operations categories constructors transformers observers 
classification process helps designer producing sufficiently complete specification facilitates test generation scheme described section 
additional advantage notation pointed section 
algebraic specifications priority queue functional notation shown 
sequences operations separated dots read left right example create add add represents result creating priority queue adding items order 
specification create add add delete equivalent create add apply axiom twice give create add add delete create add delete add create add 
difference constructors transformers clear point 
simplification complete constructors left operation sequence 
role transformers transform sequence constructors sequence constructors 
note appearance operation sequences bears strong resemblance trace specifications data abstractions specifying legality equivalence values traces operation sequences 
advantages trace specifications definition follows assumption goguen guttag opposite assumption sequences may assumed equivalent provably inequivalent 
specification class priority queue export create largest add delete empty eqn constructor create add integer transformer delete observer empty boolean largest integer eqn priority queue boolean var priority queue integer axiom create empty gamma true add empty gamma false create largest gamma add largest gamma largest largest create delete gamma create add delete gamma largest delete add eqn gamma empty empty true empty empty empty empty false largest largest delete eqn delete false specification functional notation type priority queue syntax create gamma priority queue add priority queue theta integer gamma priority queue delete priority queue gamma priority queue empty priority queue gamma boolean largest priority queue gamma integer eqn priority queue theta priority queue gamma boolean declare priority queue integer semantics empty create gamma true empty add gamma false largest create gamma largest add gamma largest largest delete create gamma create delete add gamma largest add delete eqn gamma empty empty true empty empty empty empty false largest largest eqn delete delete false specifications priority queue ability specify functions observers side effects ability handle operation sequences intermingled procedures functions 
axioms algebraic languages facilitate automatic test case generation discussed section 
self checking test cases section describe main concepts underlie astoot 
include notion correctness classes model test cases execution test checking mechanism 
early papers specification data abstractions liskov zilles pointed possible specify data abstraction specifying intended inputoutput behavior operations individually doing usually cumbersome may lead overspecification underlying representation data 
proposed algebraic specifications data types adts define intended behavior adt giving axioms describing interaction operations 
similarly possible test class testing methods individually treating function mapping input space output space selecting elements input space examining outputs see correct 
doing shifts focus testing away essence data abstraction interaction operations 
furthermore testing method individually necessitates construction complicated drivers output checking mechanisms 
example test case add operation priority queue consist priority queue item output priority queue 
driver initialize input priority queue checking output entail examining output priority queue see correct result 
contrast approach testing classes focuses interaction operations 
section restrict attention classes intended implement adts 
require 
operations side effects parameters 
functions observers side effects 
functions observers appear operation sequence 
sequence passed parameter operation contain functions observers 
main reason placing restrictions specify kinds side effects purely algebraic languages 
reason restriction sequences mix functions procedures syntactically valid algebraic specification languages 
restriction easier generate test cases astoot 
note restriction hinder ability express test cases involving parameters operation function side effects target object object message sent target object sequence observationally equivalent target object techniques relaxing restrictions restrictions discussed :10.1.1.23.2625
correctness adt implementation consider class intended implement data type function corresponds method inputting value type function corresponds sending message object class eiffel constructors transformers typically coded procedures explicitly returning object class procedure returns value modifying state object applied 
observer coded function explicitly returns object class 
refer object function procedure message sent target object object returned returned object 
procedures target object returned object typically value target object changed procedure call 
notice addition explicitly returning object function implicitly returns target object 
function side effect free value target object unchanged function call 
syntax functional syntax algebraic specification languages allows differentiate target returned values 
example sequence create add add largest final value target priority queue elements returned value 
say objects class observationally equivalent ffl built class identical values ffl user defined class sequence operations function returning object class observationally equivalent objects class observationally equivalent impossible distinguish operations related classes 
observationally equivalent objects state details representations may different 
example consider circular array implementation fifo queue 
arrays containing elements order observationally equivalent queues elements occupy different portions underlying arrays 
define notion correctness underlies approach 
class correct implementation adt signature preserving mapping operations ffl pair sequences operations equivalent corresponding sequences messages give rise observationally equivalent returned objects 
words correspondence states states preserves transitions states 
note definition returned object definition correctness demands operation sequences consisting entirely constructors transformers give rise observationally equivalent target objects operation sequences observers return observationally equivalent objects 
notions correctness corresponding specification methodologies investigated 
definition observational equivalence similar corresponding trace specifications limited algebraic specification methodology 
pragmatic intuitively appealing lends convenient testing strategy 
test case format definition correctness gives rise natural way framework testing 
infinite amount time way check objects observationally equivalent exhaustively test class follows ffl consider set consisting tuples tag sequences messages tag equivalent equivalent specification equivalent 
ffl element send message sequences objects respectively check returned object observationally equivalent returned object ffl observational equivalence checks agree tags implementation correct incorrect 
unfortunately infinite amount time testing fool proof way checking observational equivalence 
scheme suggests approach testing 
demand class returned function include method called eqn approximates observational equivalence checker select elements test cases 
addition shifting emphasis testing functionality individual methods notion state approach testing facilitates automation aspects testing process 
note elements viewed self checking test cases 
test case includes information form tag describing expected result execution 
furthermore format expected result single boolean concise independent particular class tested pair sequences executed 
facilitates automated execution checking test cases 
course generating test cases necessary consider specification adt order derive tags 
done semi automatically manipulating formal specification described section manually reasoning formal informal specification 
example consider priority queue integers functions described informally follows create creates empty priority queue add adds integer priority queue delete removes largest element priority queue largest returns value largest element priority queue modifying contents priority queue empty determines priority queue empty 
reasoning informal specification person generate test cases 
create add add delete create add equivalent 
create add add delete largest create add largest equivalent 
create add add delete create add equivalent 
create add add create add add equivalent 
test case says empty priority queue adding applying delete creating empty priority queue adding 
test case says objects returned applying largest priority queues equivalent 
test case says create empty priority queue add delete create empty priority queue add 
test case says priority queue obtained adding adding observationally equivalent obtained adding adding 
previous test cases test case captures aspect informal specification expressed formal specification derived formal specification term rewriting indicates formal specification partially describes intended semantics adt available manual generation additional test cases may useful 
refer test cases consisting pair sequences tag restricted format test cases 
general test case formats useful testing classes involving side effects dynamic binding introduced :10.1.1.23.2625
eqn method discuss eqn operation 
ideally eqn operation class check objects class observationally equivalent check sequence messages observer yields result sent sent clearly impossible send message sequence objects practice eqn approximate check observational equivalence 
axiom add add 
add add added specification aspect informal specification captured 
resulting specification longer satisfy finite termination condition 
quite easy produce recursive version eqn specification adt intended implement 
example axiom specifies eqn function priority queue specification 
note approximation true observational equivalence neglects possible effects building priority queues removing elements 
say objects equivalent eqn calls largest delete error operations may propagate eqn causing mask error 
hand error propagation help error detection demonstrated section 
approach developing eqn function write implementation level 
approach eqn detailed knowledge data represented manipulated class body 
example knowing fifo queue represented linked list traverse lists comparing elements 
general sufficient attention paid details representation eqn implement observational equivalence exactly 
hand possible misconceptions lead implementation errors methods may lead errors eqn 
furthermore representations data structures writing implementation level eqn operation may extremely difficult error prone methods relatively simple 
possible coarse approximation observational equivalence eqn function 
example consider fifo queues equivalent number elements front element 
version eqn may consider inequivalent objects equivalent 
naturally coarser approximation observational equivalence lead accuracy test results 
discuss closely related problem suggest oracle hypothesis explicitly stated 
context approach testing hypothesis describe conditions implementation eqn equivalent actual check observational equivalence 
tools astoot set tools approach described section 
current prototype handles test cases restricted format components driver generator compiler simplifier 
driver generator takes input interface specifications class test cut related classes outputs test driver 
test driver executed reads test cases checks syntax executes checks results 
compiler simplifier form interactive tool semiautomatically generating test cases algebraic specification 
note algebraic specification available drivers produced driver generator example consider implementation completely empties priority queue total number adds performed reaches particular number 
recursive eqn consider 
create add add delete equivalent create add fact performing additional gamma adds followed gamma deletes object leave empty leave non empty 
execute test cases derived person reasoning informal specification 
structure astoot illustrated screen dump astoot session shown 
driver generator approach testing leads relatively simple test drivers operate reading test cases form tag time checking sequences syntactically valid sending sequences objects cut comparing returned objects eqn checking value returned eqn agrees tag 
hand drivers complicated writing manually tedious error prone task 
particular checking syntactic validity operation sequences involves complicated parsing type checking 
example driver priority queue class lines code counting inherited classes deals checking syntax operation sequences 
luckily drivers testing different classes similar structure 
allowed write tool driver generator automatically generates test drivers 
driver generator viewed special purpose parser generator syntax described class interfaces generates test drivers parse test cases executing checking 
driver generator dg operates phases 
phase collect information interfaces cut ancestors classes parameter types return types cut operations 
dg checks classes exported eqn operation 
eiffel implementation language facility selective export eqn exported test driver integrity implementation preserved 
second phase dg builds test driver class implementation language 
current version driver generator targeted eiffel underlying ideas applied oo languages 
third phase dg compiles executes test driver test cases supplied user 
test generation tools astoot test generation component parts compiler simplifier internal representation called adt tree 
compiler reads specification written syntactic semantic checking specification translates axiom pair adt trees 
adt tree tree nodes represent operations arguments 
path root leaf adt tree represents possible state adt 
branching adt tree arises axioms having expressions right astoot access functions hidden implementation cut export functions test driver generated astoot 
eiffel achieved selective export test driver achieved making test driver friend class cut 
simplifier driver generator operate assumption create instantiation operation compiler sure constructor named create specification 
simplifier insist operation sequence create operation 
simplifier oe ae driver generator compiled axioms compiler test driver source source language compiler test driver original sequences implementation cut algebraic specification cut test results test cases components astoot screen dump astoot session 
upper left window shows execution test generator batch mode priority queue specification 
file pq seq contains initial sequence supplied user 
test generator generates test cases initial sequence writes corresponding constraints free variables file pq sim 
constraint test case obtained conjoining condition test case negations conditions previous test cases 
upper right window shows test cases user developed instantiating free variables values satisfy constraints 
generated test cases unsatisfiable constraint eliminated user 
driver generator invoked incorrect implementation priority queue described section 
invokes eiffel compile class test generates test driver class compiles executes test cases 
test cases detect bug second 
lower left window shows small portion test driver automatically generated driver generator 
ffl ffi fi fl void add delete ffl ffi fi fl delete ffl ffi fi fl add ffl ffi fi fl ffl ffi fi fl largest qk largest axiom priority queue adt tree form hand side 
edge adt tree boolean expression called edge condition attached 
path condition path root leaf conjunction edge conditions path indicates conditions operation sequence path equivalent original sequence 
path conditions tree mutually exclusive 
illustrates adt tree pair axiom 
clarity edge conditions shown rectangles implementation parameters operations operands boolean expressions represented adt trees 
simplifier inputs operation sequence supplied user translates adt tree applies transformations obtain equivalent operation sequences 
process simplification follows 
search axioms find axiom left hand side matches partial path adt tree ignoring edge conditions 
axiom bind variables axiom proper arguments partial path adt tree simplify arguments replace partial branch right hand side axiom 
repeat steps matching axiom 
worst case adt tree arising sequence operations may paths maximum number branches axiom 
deal complexity current prototype operate batch mode builds entire equivalent adt tree interactive mode allows user selectively guide construction particular path tree 
order simplifier properly set axioms specification convergent axioms properties finite unique termination 
property finite termination ensures process simplification go infinite loop 
property unique termination sure terminating sequences starting operation sequence results matter choice axiom rewrite axiom apply 
ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl qk ffl ffi fi fl void create create add add ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl delete add add create void ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl ffl ffi fi fl qk ffl ffi fi fl ffl ffi fi fl void create add add delete add simplification sequence create add add delete example involving batch mode simplification sequence create add add 
delete priority queue shown 
simplifier generate test cases form create add add delete create add equivalent path condition create add add delete create add equivalent path condition 
note simplifier suggests test cases equivalent tags 
instance exchange path conditions test cases get test cases create add add delete create add equivalent constraint create add add delete create add equivalent constraint 
adt tree paths simplifier generate test cases equivalent tags 
principle simplifier generate gamma test cases equivalent tags length original sequence maximum number branches axiom 
cases adt tree current version simplifier leaves selection test cases user 
note test cases generated simplifier contain symbolic values 
acceptable test driver user resolve path conditions constraints instantiate symbolic values corresponding actual values 
principle done automatically constraint solving system 
current prototype constraint solving left user 
important questions remain select original sequences input simplifier select paths resulting adt trees order increase likelihood exposing errors 
case studies gain insight kind original sequences person test generation tools select kind paths adt tree generated interactive mode performed case studies involving generating tests buggy priority queue implementation buggy sorted list implementation 
choose priority queue adt knew sufficiently complicated exhibit interesting phenomena 
purposely introduced bug believe easily occur practice 
sorted list tree implemented graduate algorithms class 
bug slight variation occurred program development 
wished gain insight questions length original sequence affect likelihood test case detect error 
selection parameters operations original sequence affect likelihood test case detect error 
ratio add delete original sequence affect likelihood test case detect error 
addressed questions randomly generating executing test cases various original sequence lengths various ranges parameters lie various frequencies occurrence different operations 
original sequence generated corresponding simplified sequence executed test case original sequence simplified sequence equivalent 
note extremely difficult execute check test cases astoot self checking test case concept 
testing buggy implementation priority queue case study cut priority queue implemented heap bug delete operation specifically sift operation performed delete error causes fail swap bottom row 
erroneous delete code shown appendix 
recall heap complete binary tree node greater equal children heap implementation priority queue delete operation performed removing root replacing right leaf sifting element proper position 
original correct incorrect gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma illustration buggy priority queue heap resulting sequence create add add add 
add add heap resulting applying correct delete 
resulting heap incorrect delete applied note failed swap bottom row 
discussed section eqn calls delete bug delete propagated eqn 
original sequence test case create add add add 
add add delete create add add add add equivalent produces incorrect heap eqn reports original sequence simplified sequence equivalent due bug delete 
case error masked propagation bug delete eqn 
hand consider test case create add add add add 
delete create add add add equivalent original sequence produces heap root root left child root right child 
simplified sequence produces heap root root left child root right child 
heaps correct observationally equivalent 
checking executing eqn check observational equivalence call erroneous delete routine 
call delete original heap root left child incorrect heap resulting simplified sequence root left child 
call largest compares roots eqn reports sequences equivalent bug detected 
case propagation error eqn helps error detection 
order carry case studies needed generate tens thousands test cases 
principle done astoot test case generator randomly generating original sequences symbolic values parameters sending original sequence simplifier generate test cases 
give test cases original sequence operations 
test case symbolic values constrained path condition corresponding path 
realistic randomly choose test cases randomly instantiate symbolic values test case actual values satisfy constraint test case manually aid constraint solver 
note number test cases needed experiments orders magnitude larger number test cases typically practice test implementation size 
order generate huge number test cases efficiently broad range testing variables test set program randomly generate test cases actual values variables astoot test generator 
program consists modules 
module generates original sequences time parameter number operations excluding create original sequence parameter add integer range ratio add delete appearing original sequences 
operations original sequence read second module time applied priority queue implemented list 
third module inspects contents list generates simplified sequence outputs appropriate test case 
note simplified sequences generated test case generator astoot instantiated real values satisfy constraints 
test set generated test cases 
average number add simplified sequences approximately gamma results priority queue case study percentages test cases expose bug test set shown 
inspection graphs shows large values parameter range long original sequences better short ones 
parameter range small longer original sequences may worse shorter ones 
fact results test sets worst respectively despite fact long original sequences 
parameter range increases test cases tend get better 
case appears threshold error detection probability levels 
likelihood exposing error depends somewhat buggy implementation failure occurred necessary swap right element bottom row heap 
apparently long sequences potentially cause object enter state application original simplified sequences propogation error eqn operation 
simply long sequence regard parameters chosen lead objects got interesting states 
range parameter values small duplicates heap item deleted sifted item strictly smaller elements compared supposed swap bottom row 
number operations ffl ffi pi range parameters ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi pi delta delta delta delta delta delta pi phi phi phi pi pi pi pi hhh range parameters ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi pi omega omega omega omega pi pi pi gamma gamma gamma pi pi range parameters ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi pi pi omega omega omega omega omega pi delta delta delta delta delta delta pi pi pi range parameters ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi pi gamma gamma gamma pi omega omega omega omega pi delta delta delta delta delta delta pi pi pi results testing priority queue randomly generated test suites sorted list duplicated elements class sorted list export create add delete nb elements find eqn constructor create create empty list add integer list add list proper order transformer delete integer nb elements delete th element observer nb elements integer number elements list find integer integer return value th element precondition nb elements eqn sorted list boolean equivalent list 
specification sorted list testing buggy implementation sorted list second case study data type sorted list integer operations create add delete find nb elements eqn 
interfaces preconditions informal specification sorted list shown 
eqn operation compared lengths lists compared element element 
note formal specification sorted list 
test cases generated program similar case study priority queue 
sorted list implemented tree special case tree 
implementation approximately lines eiffel code buggy version produced deleting particular line correct version implementation 
absence statement affects state tree situation occurs 
node children child ff children second child fi third child fl children 

fl children deleted 
ff fi fl incorrect ff fi fl correct ff fi fl original illustration buggy tree example deleting fl tree correct procedure 
copy fi fl 
delete fi 
copy ff fi 
delete ff 
line missing buggy version step procedure 
illustrated deleting get tree 
priority queue case study test sets randomly generated various original sequence lengths various parameter ranges various ratios add delete 
original sequences contained create add delete operations simplified sequences contained create add operations 
results sorted list case study results shown exhibit similar phenomena discussed priority queue example 
number elements sorted list equal range parameter values long sequences operations large range parameter values produce trees large number leaves 
error program failure occurs deletion performed tree particular kind state 
apparently trees large number leaves enter state 
number operations ffl ffi pi range parameters ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi 
pi pi pi pi phi phi phi pi pi pi hhh range parameters ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi pi theta theta theta theta theta theta theta theta pi pi pi hhh pi phi phi phi pi range parameters ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi pi fi fi fi fi fi fi fi pi phi phi phi pi pi pi pi xx range parameters ffl ffl ffl ffl ffl ffl ffl ffi ffi ffi ffi ffi ffi ffi pi pi pi pi pi pi pi results testing tree randomly generated test suites discussion case studies case studies intended provide insight effects factors length original sequence relative frequencies different operations original sequence range parameters operations 
case studies results showed long original sequences better short ones provided range parameters large take advantage length 
addition different ratios add delete original sequence gave different results 
certainly want generalize small examples 
safe say potential relative values parameters important apparent specification 
cases specification involved comparison items operator 
reasonable expect different orderings parameters added lead different states expose error 
hand testing stack queue adt expect particular parameters matter testing set adt expect number duplications important necessarily expect relative order parameters important course set implemented adt comparison tree 
phenomenon noticed different ratios adds deletes led different probabilities error detection 
ratio objects grow large course testing 
examples small objects apparently usually complicated excite failure 
offer tentative guidelines generate test cases ffl long original sequences variety relative frequencies different constructors transformers 
ffl specification conditional axioms comparison operators choose variety test cases original sequence various parameters chosen large range 
equivalently choose variety different paths adt tree arising original sequence 
guidelines obvious previous research suggested limiting complexity sequences ignoring semantics specification 
related compare approach related testing data abstractions 
previous systems generally fall categories test execution tools test generation tools 
contrast approach gives rise test generation test execution tools 
gaudel group suggests relatively simple sequences including regularity hypothesis asserting simple sequences length give correct outputs complex sequences 
results interpreted saying regularity hypotheses hold adt examined small similar observations lead gaudel introduce additional uniformity hypotheses 
test execution tools systems address question testing data abstractions data abstraction implementation specification test system 
uses axioms algebraic specification provide oracle testing implementations adt 
test case tuple arguments left hand side axiom 
executes test case giving input left hand side right hand side axiom checks output invoking user supplied equality function similar eqn 
test execution tool considered generalization 
example recall axiom priority queue specification shown says add delete gamma gamma largest delete add executing test case create add add axiom equivalent test case create add add add delete create add add equivalent second sequence obtained axiom rewrite sequence 
analog test cases form equivalent 
significant ramifications exhaustive testing may fail detect error results states erroneously combined single state 
extreme example consider erroneous implementation operations change state object 
sides axiom return state input error detected 
second distinction approach requires availability formal specification test execution tools drivers produced driver generator informal specification available second case study 
hoffman developed test execution tools data types trace specifications 
system protest consists subsystems 
protest tests implementation test cases containing expected output 
protest compares behavior implementation user supplied oracle written prolog 
test case protest tuple trace type trace sequence operations puts adt state exception raised trace observer expected value applying observer state type data type 
protest values generated prolog oracle written user 
protest program written prolog executes test cases calling operations implementation test interface supplied user 
operation interface defines prolog predicate calls corresponding function implementation 
user needs write functions called construct objects user defined classes passed parameters operations implementation 
astoot protest uses functions supplied user check equivalence objects corresponding adts 
astoot specification test generate expected outputs protest uses prolog oracle produce expected outputs 
oracle program needs tested 
distinction approach eqn function check outputs effect combine protest test cases single test case 
hand protest handling exceptions certainly important idea try incorporate versions astoot 
antoy hamlet proposed system compares class implementation representation term re writing derived directly specification 
user supplies explicit representation function mapping concrete representation representation 
code instrumented check diagrams corresponding method commute applying representation function analog method gives rise state equivalent obtained applying method applying representation function 
system cases give accurate checks correctness approach approximation observational equivalence eqn function compare concrete representations 
imposes programmer highly non trivial task writing correct representation function 
test case generation previous approaches generating test cases algebraic specifications reported 
gaudel research group developed general theory testing testing contexts triples consisting set hypotheses program set test data oracle 
approach nice property established hypotheses hold test set exposes errors program guaranteed correct 
course establishing hypotheses non trivial task involving analysis program text 
approach provides test data oracles furthermore oracles appear simple uniform format 
interesting direction research extending approach include hypotheses deriving conditions sequence pair represent class sequence pairs conditions instantiation parameters represent class instantiations 
gaudel group built tool testing data abstractions theory testing contexts 
tool inputs specification written dialect prolog definition complexity sequences uses prolog interpreter generate sequences operations complexities subject additional constraints 
approach provide useful means generate interesting original sequences simplifier 
suggest effective test cases generated syntactic part algebraic specification semantics 
experience tools indicates fact important consider semantic part different instantiations arguments sequence corresponding different paths adt tree lead profoundly different states specification 
necessary select different paths adt tree arising original sequence equivalently choose values parameters exhibit different relationships 
phenomenon demonstrated case study priority queue failure occurred necessary swap bottom row heap 
described new approach testing classes places emphasis fact classes implementations data abstractions set tools approach case studies 
approach test case consists tuple sequences messages tags indicating sequences put objects class test equivalent states return objects equivalent states 
test case restricted format consists single pair sequences tag indicating objects resulting application sequences observationally equivalent 
tests executed sending sequences objects class test invoking user supplied equivalence checking mechanism 
approach allows substantial automation aspects testing including test case generation test driver generation test execution test checking 
astoot set tools approach 
astoot consists tool automatically generates test drivers class interface specifications tool semiautomatically generates test cases algebraic specification class test 
drivers generated astoot driver generator automatically execute check test cases supplied test generator manual generation 
consequently astoot allows substantial automation entire testing process 
performed case studies buggy implementation priority queue buggy tree implementation sorted list 
case studies provided insight effects factors length original sequence relative frequencies different operations original sequence range parameters operations 
approach tools described assume specification implementation restrictions limit kind side effects operations may 
extensions basic model intended testing scheme applicable real world object oriented programs just pure data type implementations described 
include general format test cases allows testing classes methods side effects dynamic format allows testing virtual classes observations impact inheritance testing 
directions research include ffl interface test generator constraint solving system order decrease need manual intervention test generation 
ffl perform additional case studies including exploration complicated adt larger variety errors 
particular errors case studies tended exposed number duplicate elements sequence insertions low easy envision errors opposite true 
experience needed order develop better intuition kind test sequences generated arbitrary classes unknown errors 
ultimately intuition heuristics guide selection initial sequences paths adt trees enhancing test generator 
ffl explore various strategies involving picking special values parameters inserting elements ascending descending order help hinder ffl develop specification languages better able express aspects objectoriented programming side effects inheritance dynamic binding building tools 
ffl explore impact inheritance testing 
focused far unit testing interesting questions pertaining system test object oriented software 
hope address questions ultimately results expand improve astoot 
acknowledgments authors dan hoffman anonymous referees useful suggestions 
antoy 
systematic design algebraic specifications 
proceedings th international workshop software specification design pages may 
antoy hamlet 
automatically checking implementation formal specification 
technical report tr rev portland state university jan 
parnas 
assertions traces write specifications software modules 
gehani editors software specification techniques pages 
addison wesley publishing reading ma 
gaudel 
software testing formal specifications theory tool 
software engineering journal nov 
choquet 
test data generation prolog constraints 
proceedings workshop software testing pages 
ieee computer society 
:10.1.1.23.2625

approach testing object oriented programs 
phd thesis polytechnic university brooklyn ny january 
appeared computer science department technical report 


frankl 
case studies testing object oriented programs 
proc 
symposium testing analysis verification tav pages oct 
gannon hamlet mills 
theory modules 
ieee transactions software engineering july 
gannon hamlet 
data abstraction implementation specification testing 
acm transactions programming languages systems july 
gaudel 
generation test data algebraic specifications 
proc 
second workshop software testing verification analysis pages banff canada july 
goguen thatcher wagner 
initial algebra approach specification correctness implementation data types 
current trends programming methodology 
goguen winkler 
introducing obj 
technical report sri csl computer science laboratory sri international ravenswood ave menlo park ca aug 
goldberg robson 
smalltalk language implementation 
addison wesley reading ma 
guttag 
data types development data structures 
communications acm june 
guttag 
notes type abstraction version 
ieee transactions software engineering jan 
guttag horning 
algebraic specification data types 
acta informatica 
guttag horowitz musser 
extensions algebraic specifications 
proceedings language design reliable software pages mar 
guttag horowitz musser 
data types software validation 
communications acm dec 
hoffman 
module test case generation 
kemmerer editor proceedings acm sigsoft third symposium software testing analysis verification pages 
acm press dec 
hoffman snodgrass 
trace specifications methodology models 
ieee transactions software engineering sept 
hoffman 
automated module testing prolog 
ieee transactions software engineering sept 

testing completeness specifications 
ieee transactions software engineering may 

automated testcase generation data abstraction 
proceedings compsac pages chicago il oct 
knuth bendix 
simple word problems universal algebras 
leech editor computational problems algebra pages 
pergamon press ny 
liskov zilles 
specification techniques data abstractions 
ieee transactions software engineering mar 
mclean 
formal method specification software 
journal acm july 
meyer 
object oriented software construction 
prentice hall international new york ny 
musser 
data type specification affirm system 
ieee transactions software engineering jan 
stroustrup 
programming language 
addison wesley reading ma nd edition 
weyuker 
testing non testable programs 
computer journal 
appendix buggy delete delete local integer parent child integer boolean length move element array enter array entry length length length length correct statement length loop find proper child length array entry 
array entry parent array entry child array entry parent child swap array enter child array enter parent true loop delete 
