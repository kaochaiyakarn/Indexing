software engineering security roadmap devanbu department computer science university california davis ca usa devanbu cs ucdavis edu thing anymore software system doesn need secure 
system faces threats potential adversaries internet aware client applications running pcs complex telecommunications power systems accessible internet commodity software copy protection mechanisms 
software engineers cognizant threats engineer systems credible defenses delivering value customers 
perspectives research issues arise interactions software engineering security 
keywords security software engineering copy protection watermarking 
background just software system deployed today defend malicious adversaries 
modern society critically dependent wide range software systems 
threats software security breach range mild defeat copy protection video game disastrous malicious intrusion nuclear power plant control system 
advent internet increasing reliance public packet switched networks commerce risks malicious attacks increasing 
software system designers today think users adversaries 
security concerns inform phase software development requirements engineering design implementation testing deployment 
time changes software development practices software architectures opened new opportunities applying security engineering 
techniques cryptography tamper resistant hardware stuart stubblebine broad street suite new york ny usa stuart stubblebine org build trust software tools processes 
opportunities arise fact software systems longer monolithic single vendor creations 
increasingly systems complex late bound commercial shelf cots elements mobile code 
cots offers great savings custom written software 
cots vendors seeking protect intellectual property usually sell components binaries source code design documentation 
software developers faced risks constructing systems unknown black box components 
late mobile code applications concern 
research shown cryptographic techniques interactive proofs fair random coin flips security technologies hardware software practitioner address concerns 
interactions software engineering security engineering give rise fascinating research challenges opportunities 
subject 
structured roughly lines waterfall model requirements moving lifecycle activities deployment administration 
requirements policies security beauty eye 
public library clearly different view computer security central clearing house transactions 
specific security requirements particular installation determined careful consideration business context user preferences defense posture 
glossary defines security policy set laws rules practices regulate organization manages protects distributes sensitive information 
security requirement manifestation high level organizational policy detailed requirements specific system 
loosely ab term security policy refer policy requirement reflect current usage security software engineering research community 
security policies complementary normal functional requirements system features customer require 
kind nonfunctional requirement aspects performance reliability 
favored methods requirements engineering cases typically include security concerns integral part requirements engineering 
security concerns addressed requirements engineering stage security requirements come light functional requirements completed 
result security policies added afterthought standard functional requirements 
security models policies brief survey early formulations security policies concerned mandatory access control mac 
mac objects associated security classifications secret subjects may access appropriate classification 
enforcement system prevents type access 
contrast discretionary access control dac access restrictions identity user process groups belong 
dac discretionary sense subjects certain access permission pass permission subject 
early represented clear formulation model policies clear defined easily implementable 
followed classic bell la multilevel security model objects considered readable writable 
model subject object assigned security level 
subjects read objects levels write objects levels 
central innovation addition clear defined implementable policy allowed show information 
policy implemented correctly impossible subjects gain information reading objects information higher level security classification leak lower channel 
early followed researchers see example contributed innovations policy models 
efforts led broad rigorous understanding security needs 
breadth enables capture security requirements wide range applications rigor lets clearly formally characterize implications requirements 
different models security policies discussed find expression policy languages may thought specification languages expressing security requirements 
languages described 
policy languages implemented enforcement mechanisms 
wide word access read write open close connect denote act subject performing action object 
range approaches policy enforcement 
selection appropriate security policy model best done early product lifecycle 
challenge integrate security requirements analysis standard requirements process 
challenge unifying security systems engineering 
central challenge systems engineering develop product plans optimize limited project resources time funds personnel 
competitive software vendors utilize resources deliver value customers early possible 
mature markets competitive software vendors exhibit quite sophisticated product positioning practices systems engineers choose carefully variety possible features deploy demand maximize front load revenue 
functional requirements handled rational manner 
unfortunately security requirements typically received type careful analysis 
designing truly secure system defending credible threats expensive 
practice limited development resources force compromises 
currently compromises ad hoc basis afterthought 
strongly support view systems engineering unified security engineering 
just systems engineers analyze select market critical features security engineers develop applicable threat models select security measures needed market success 
available resources deployed build right combination customer features security measures 
challenge unifying security system models 
software engineers models early life cycle improve quality artifacts requirements documents 
attention quality early life cycle project requirements design leads defect detection avoidance 
known defects undetected propagate downstream costs detection removal greatly amplified 
trend high level object oriented models uml early life cycle support requirements analysis design activities 
modern requirements modeling object oriented design methods careful analysis ontology application domain 
model domain ontology constructed drives rest requirements process 
approach useful practice widely industry especially design information systems fusion methodology 
modeling useful reverse engineering 
tools built extract models legacy system 
models useful maintenance re engineering 
far security modeling policy largely independent system requirements system models 
typically system requirements design done security added afterthought 
lack interaction researchers working requirements modeling design modeling uml community security policy researchers clearly gained developing processes tools unify security policy development system development process specifically making system models designing security policies 
attractive approach adopt extend standards uml include modeling security related features privacy integrity access control advantage accrue unified design systems security policies 
modularity encapsulation compactness reuse inheritance policy representation 
leverage existing standards tools design analysis forward engineering activities analysis legacy code reverse engineering activities 
primary challenge extend syntax semantics standards uml address security concerns 
believe presents opportunity software engineering researchers 
develop tools processes help unify design systems security policies result surely systems effectively meet business requirements secure fashion 
readers interested object oriented modeling companion oo modeling 
architecture design se cure systems re engineering security software designers long recognized need incorporate non functional considerations performance reliability software design processes 
understood adding performance reliability requirements software architectures fact difficult impossible 
sadly situation security oriented non functional requirements advanced security effort directed mobile code systems security concerns burden mobile code host system development concerns applet developer general true design policy system unified 
afterthought 
typically means policy enforcement mechanisms preexisting design 
leads serious impossible design challenges enforcement mechanism rest system 
best resolution problem refine requirements design processes bring earlier focus security issues 
reasons poor planning security factor initial systems design 
advent networking open standards provide new business reasons re engineer internal legacy systems operated secure intra nets operation open internet 
cases alternative adding security system fact 
problems arise resulting different types architectural mismatch 
example data protocol incompatibilities may render difficult legacy system services available standard protocols iiop standard data formats xml 
problems important deserve attention 
issue directly related security discuss point related retargetability wrappers wrapper generation tools 
challenge legacy security mismatches 
security perspective serious problem mismatch security framework legacy system security framework target standard protocol 
example unix systems corba different security policies enforcement mechanisms 
unix authentication user password authorization 
corba uses kerberos authentication 
unix file system uses known access control user group 
corba access control flexible credentials owned corba client service controls encapsulate access control policy related corba servant 
difference greatly complicate systems principals authenticate mechanism unix corba unix corba services 
consider task making services particular unix application available corba object 
particular login permitted certainly sure user invoke services corba 
unfortunately simple way ensure 
suggests wrappers enforce unix style policies 
general mechanisms need flexible allowing administrators formulate policies suit needs full power corba security system offering secure services 
fraser propose sophisticated flexible wrapper mechanism surround cots components enforce policies applicable system hosting cots components 
rational linkage various security frameworks growing area concern 
customers demand single sign user authenticates specific mechanism gains access uniform manner different services different platforms 
developing uniform policies enforcement mechanisms group services span different platforms research challenge 
challenge separating security aspect central problem modifying security aspects legacy system difficulty identifying code relevant security changing integrating changes back system 
promising new approach constructing systems evolvable security features suggested confluence lines research aspect oriented programming architectural connectors 
aspect oriented programming approach simplifying software evolution 
idea aspects code naturally modular data storage placed database 
usually nonfunctional requirements performance distribution code 
changing way system distributed example involve difficult task identifying changing scattered code concerned location connection distribution aspect oriented programmers seek isolate fragments centrally ease comprehension maintenance achieving classic goal separation concerns task re scattering back code prior compilation automated program transformers known aspect 
strategy aspect distribution isolated easier change 
line research arises software architecture researchers study major elements architectures components form centers computation system connectors loci interaction components 
conceptual distinction design level course code level distinction exists 
view useful non design time activities performance modeling programming activities especially program understanding 
notion connectors encapsulate various aspects interactions suggests promising line research 
important security concerns authentication access control arise interactions components 
security concerns naturally placed architectural connectors 
authentication security policies enforcement mechanisms considered different aspects connectors 
aspect take task integrating implementation aspects rest system 
context security fea tures easier isolate maintain 
software piracy protection software piracy enormous challenge software business 
vulnerable vendors popular expensive products office suites commodity desktop machines 
cost legitimate copy piece software approaches cost machine office suite upgrade versus cost entire new machine incentives individual consumers commit piracy intense 
dangerous types pirates organized rogue entities especially countries lax enforcement copyright laws resources pirate thousands millions copies 
entities may export copies 
sources piracy acknowledged cost range annually 
law enforcement measures essential practical piracy 
measures augmented technology keep honest people honest 
various technologies exist combat piracy believe key innovation awaits model economics piracy 
model adversary effectiveness technologies properly evaluated 
adversary economics consider entity individual organization considering piracy software item 
assume software item needed entity 
entity buy cost cb item hack copy protection mechanism cost ch copies value cc bear small risk getting caught carries large possibly subjective cost 
cost probability may vary may civil liabilities software vendor individual lawsuit liabilities 
criminal penalties fines jail terms possible quite 
current technology ch usually high cases copyright enforcement lax 
confronted reality cb ch cc people organizations strong economic incentive commit piracy 
goal sell copies cb profit model apply 
may expect likelihood getting caught greater 
clearly approach reduce cb zero 
approach adopted free software movement remarkably effective discouraging illegal piracy 
barring technical challenge increase probability subscript called eleventh 
capture increase ch cc 
various approaches discussed possible attacks discussed 
approaches protection various technologies may discourage piracy 
hardware software tokens water marking code partitioning 
hardware software tokens 
software tokens common technique 
software product license file shipped 
file contains information product checks time run file information wrong product exits license violation error 
information may include information specific installation site hardware network card address 
hardware tokens installs physical machine usually serial parallel port 
software checks presence token starting normal function 
cases hardware software protection code checks presence valid token 
approach obtain token dynamically telephone network connection 
popular approach exploit idiosyncratic physical features specific particular digital medium timing anomalies specific floppy disk token protected program check copy features run 
cases basic goal raise cost breaking protection mechanism ch 
cases applicable attack locate token checking code patch 
debugger ability set breakpoints purpose 
approach search binary character string corresponding license violation error 
code easily patched 
names containing substrings license routines things easier attacker 
techniques difficult run debugger software approaches getting 
general token checking debugger hindering code fixed locations code removed mechanically locations known 
suggestions include level self checking program monitors detect tampering license checking mechanisms 
find self checking codes disable 
approach add self destruct code destroy copies software including code memory detection tampering efforts 
self destruct approaches detected running software full emulation system level debugger observing system calls 
entity making copies needs find remove checking mechanisms copies desired 
attack involves finding checking including self checking code patching 
cost primarily reverse engineering cost greater cost greater barrier piracy 
unfortunately existing proposals token technique come guarantees lower bound reverse engineering cost 
anecdotal evidence regarding commercial products approach leads discouraging reverse engineering costs low cases 
dynamic decryption code 
approach software stored encrypted form digital media decrypted prior execution independently stored key 
multiply encrypted keys des key encrypted rsa private key associated particular machine protect software 
proposed associating keys machines manufacture 
copying media key useless 
complications 
dynamic decryption may add unacceptable performance overhead 
customers may find difficult move application machines perfectly legal reasons retiring machine 
applicable attack direct monitoring program memory locations harvest decrypted code code memory prior execution 
exercising different features software possible gather code system 
necessary write monitoring program specific operating system platform decrypted code execution 
precise lower bounds harvest cost ch reasonable assume greater case simple token 
approach atypical software business fact aware mass market products 
watermarking 
approach discouraging piracy embed secret watermark software specific customer 
copy traced back original customer watermark 
effect approach increase probability getting caught 
large customers risk exposure 
watermarking applicable type object abstractly message 
research area concerned watermarking visual media 
abstractly message bits seeks embed smaller message watermark bits original message way identifying provenance 
goal time message watermark readily ex establishing provenance message adversary seeks disguise message watermark longer extracted 
collberg thomborson published useful analysis software watermarking techniques :10.1.1.33.8088:10.1.1.33.8088
describe desirable properties watermark stealth difficult find resilience remove damaging message divide software watermarking techniques static dynamic approaches 
static watermarking techniques encode watermarks static program properties ordering program text independent basic blocks 
static program analysis reveal watermark 
dynamic watermarks embedded program state typically response specific input 
watermarks called easter eggs example encode number particular state connectivity stored graph 
watermark detected running program input observing program state 
collberg thomborson discuss various types watermarking techniques applicable attacks :10.1.1.33.8088:10.1.1.33.8088
proposed techniques attacks offer useful intuitions difficulties watermarking programs 
useful metrics evaluating effectiveness watermarks application metrics known approaches remains open issue 
technical problem watermarking software wide variety meaning preserving transforms available attacker confound watermark 
watermarks proposed masked application program transforms 
domains digital imaging sound watermarking techniques successful plethora transforms available 
discussed earlier core aim watermarking raise probability getting caught 
course watermarking says actual cost getting caught 
suggests non technical means evade 
pirate hire difficult juvenile individual foreign country front man original purchase 
approach pirate copies jurisdiction lax enforcement 
addition legitimate consumers may privacy concerns associating specific software purchases 
customers may seek mask purchases cash anonymous transactions 
anonymity common commerce watermarks little discourage pirates 
code partitioning 
pirate access bus analyzer probe harvest software visible ordinary ram visible immediately prior execution 
recognizing inventors recommend placing portion software inaccessible memory 
early proposal recommends placing just license checking part application protected hardware 
case attacker find code application unprotected memory invokes protected license checking code patch 
discourage attempts necessary physically protect substantial portion application 
approach recommends placing proprietary portion application rom leaving rest ram 
bus analyzer simply harvest addresses instructions retrieved rom developing complete address instruction map rom allowing readily copied 
avoid attack necessary protect memory storing part program processor executing instructions memory bus 
approach relegate protected part program remote server administered trusted party software vendor 
program component invoked remote procedure call 
call received caller identity checked valid licensing allowed proceed 
long critical functions separated remote server copies unauthorized sites 
performance certainly issue approach 
critically users worry covert channels server attendant loss privacy 
issues addressed running protected components locally tamper resistant hardware device smart card 
protected part software shipped encrypted private key associated smart card manufacture decrypted run device 
central question code partitioning approaches criteria selecting portion code protected 
unfortunately issue remained open 
sander tschudin proposed approach protecting software 
homomorphisms rings create encrypted versions functions compute polynomials 
encrypted versions resistant reverse engineering adversaries feasibly decipher polynomials 
results computed polynomials encrypted sent back customers vendor decryption 
approach far restricted computation polynomials 
addition need final results decrypted vendor raises performance privacy concerns may suitable interactive applications 
approach elegant provably secure limitations ameliorated 
challenge attacker cost models 
research described section eco model adversary behavior 
model difficult judge effectiveness approach 
example consider token approach augmented self checking code additional measures inhibit debugging 
cost time reverse engineering cost identifying removing defensive measures 
quantify cost particular implementation approach 
dynamic decryption approach attack monitor hardware devices debugger instruction stream flowing past cpu gradually accumulate code entire system clear 
different approaches dynamic decryption code attempt complicate harvesting task provide clear model adversary cost 
criticism applies watermarking approaches 
collberg suggests measures evaluate resistance watermarking techniques attack :10.1.1.33.8088:10.1.1.33.8088
discusses applicable attacks 
actual human cost removing watermarks awaits investigation 
view adversaries full access hardware software operating platform best method protect software partitioning protected component executed entirely processor 
approach known quite proponents failed provide suitable cost model 
attacks break physical security processor passively reverse engineer contents 
task involve fully characterizing behavior protected component re implementing 
vendor ensure costs high 
techniques partition software meet considerations await development 
cost models possible attacks consider current attacks possible attacks 
way reduction techniques relate cost attacks cryptographic problems thought difficult difficulty inverting way functions factoring large numbers 
sander tschudin example moment results primarily theoretical interest limited computing polynomials 
strong results copy protection remains black art 
addition economic models cost attacks different protection techniques need model entire piracy process 
piracy cost relation reproduced cb ch cc best rudimentary 
trusting software components software development today largely matter integrating shelf components rarely new systems built entirely scratch 
middleware technologies see companion specifically middleware com corba rise wide range components frameworks libraries collectively known commercial shelf software cots 
useful summary research issues cots products attractive developers confronted stringent requirements cost quality time market 
products particularly safety critical systems fraught risk 
procurement policies customers safety critical systems utilities government traditionally required software vendors disclose details evaluate processes products safety 
policies compatible current component vendors faced risk intellectual property loss 
committee appointed national research council nrc see pp 
discussed reuse cots software nuclear power plants 
report states page para dedication commercial components requires information commercial vendors accustomed supplying 
vendors may unwilling provide share proprietary information particularly development testing procedures results service experience 
speaking issue voas page states software components delivered black boxes executable objects licenses forbid de compilation back source code 
source code licensed cost doing prohibitive leaves users cots products unpleasant choices forego components attendant cost savings live risk black box component 
cots vendor faces similar challenge assure users quality development process resulting product limiting intellectual property loss 
call grey box verification problem 
look opaque approaches 
black box approaches voas proposes complementary approaches test component situ sure doesn misbehave second test system sure function component misbehaves 
approaches treat component black box employ extensive testing ensure system functions desired 
significant advantage additional effort required cots vendor 
addition cots vendor need disclose intellectual property 
additional testing effort time consuming expensive contribute quality entire system effort spent 
cots vendor stringent testing verification practices approach lead duplicated effort 
context seek grey box allow cots vendor disclose details verification practices convince skeptical cots user protecting intellectual property 
grey box approaches described approaches interactive cryptographic techniques relying tamper resistant hardware 
cryptographic coverage verification 
suppose cots vendor achieved basic block coverage 
significant achievement indicative stringent qc process 
convince user typically third party trusted user verify coverage disclose source code tests applicable tools customer 
propose way customer provide credible evidence coverage disclosing practical situations test cases 
essentially approach driven fair random process 
unbiased coin flip say chooses basic blocks random vendor provides test cases evidence coverage blocks 
challenges unpredictable vendor easily cheat 
describe approach vendor claim level coverage say additional challenge lowers upper bound probability lying 
challenges reduce lying probability 
verifiable fair random process technically cryptographically strong pseudo random number generator allows vendor acting provide evidence 
vendor regardless reputation provide credible evidence stringent quality control modest additional effort cost coverage testing 
tamper resistant hardware 
suppose vendor great effort constructed formal proof component satisfies important safety property proof discloses significant details loop invariants datastructure invariants certainly vendor customer know proof exists disclosing proof details 
context suggest tamper resistant hardware de situation analogous proof carrying codes la 
vice smart card comprising secret private key 
attempts extract key render device 
embed proof checker device 
proof checking known simpler faster proof creation 
vendor presents device cots software appropriately annotated invariants proof smart card processes component proof 
private key smart card signs component statement applicable property proven private key 
assume corresponding public key introduced cots users appropriate certificates 
approach allows proof remain 
cots user reasonably rely signature trust proof checker smart card evidence correct complete proof desired property exists 
challenges grey box approaches 
approaches described beginnings address certain aspects grey box verification problem 
developed test coverage verification protocols block branch coverage 
government agencies require stringent coverage criteria data flow criteria 
protocols vulnerable certain types attacks example attempts vendor boost coverage including spurious easily covered code 
resilience attacks needed 
cryptographic approaches feasible verifying types quality control methods model checking approaches 
fair random choice approaches show particular model reasonable fair abstraction system model desired properties 
challenge provide grey box evidence claims disclosure 
verification systems military establishments long history building high assurance secure systems 
effort came called rainbow series books including orange book specified security feature requirements assurance requirements implementation features 
effort largely costly general purpose systems 
government forced move cots software meet cost quality schedule constraints 
latest evaluation criteria software common criteria internationally standardized 
evaluation required aligned needs commercial systems clear state evaluation technology adequately advanced evaluation practical systems companies 
traditionally high quality expectations secure sys tems led investigators apply rigorous formal methods show desirable security properties computing systems particularly access control information flow properties cryptographic protocols particularly showing properties authentication 
formal methods involve significant human labour expensive 
usually formal specifications actual implemented systems confidence formal verification subject concerns fidelity completeness specification respect customer expectations relationship final implementation specification 
addition implementations typically larger complex practical languages 
renders manual automated verification implementations difficult 
applicable engineering approach attempt show correctness conservative techniques model checking static analysis find defects 
techniques guarantee complete elimination defects useful adjunct conventional defect testing 
challenge implementation verification methods 
automated tools credible job finding security related defects implementations practical systems needed 
approach abstractions derived automatically source code identify states potential security vulnerabilities may exist 
approach analogy verisoft create hostile library versions popular apis file system api attempt applicable api calls simulate attacks program attempt expose vulnerabilities 
application re linked hostile library tested expose security vulnerabilities 
companion papers analysis testing useful summaries existing testing verification important issues 
secure software deployment component software popular desktop applications exploded 
consider particular component say produced vendor component may application word processor spread sheet mail program electronic game 
applications may created different vendors package ship application constituent components 
certainly time passes component vendor continuously updates component software fix defects improve functionality creating versions happen needed applications eventually require different incompatible versions component arises common difficult problem installing application may cause unrelated application fail 
users personal computers suffered consequences problems 
addition personal computer users asked update re configure systems response announced threats viruses newly discovered vulnerabilities 
announcements infrequent recommended remedies abilities unskilled user 
resolving problems time consuming may require user spend long hours technical support personnel help line discuss intimate details software installed pc 
certainly risks individual privacy 
worse potentially malicious outsider help line example induce unsuspecting user disclose critical details installation particular pc 
details reveal vulnerabilities subsequently exploited gain access critical data services user pc network 
task maintaining correct current configuration software machine called post deployment configuration management 
approaches automating aspects pd cm see companion volume configuration management 
provide timely distribution information correct configurations software releases 
security challenges remain addressed 
secure configuration management security issues need addressed systems controlled delegation administration privacy protection 
challenge controlled delegation 
complex task 
complex application configurations interdependencies considered deriving right configuration 
may involve expertise drawn organization 
sources may trusted certain types expertise 
addition software may published different sites varying trust levels 
response security events responsibility attack may properly fixed previously trusted source privileges may revoked 
user may rely administrators identify trusted sources information software releases 
administrators delegates may source information privileges revoked 
systems need provide facilities allow enforce flexible delegation revocation administrative privileges 
challenge privacy protection 
obtaining information software releases sources system user privacy 
course notions privacy may vary user user user able specify information site accessible 
system flexible regard take responsibility enforcing policies 
course theoretical limits full enforcement privacy policies limitation system best applicable technologies protect privacy 
secure computations secure computers software systems potentially error prone may expected produce incorrect results due defects software 
security concern users may worry system compromised attackers perform incorrectly 
general requires effort decide result computation correct 
need test oracle recognized significant problem software testers know system responded correctly test 
possible system produce proof correctness computed results user tester gain solid assurance system functioned correctly regardless attack 
efficient proof checker automate process checking proof providing automated test oracle 
early area includes check cryptographic operations performed untrusted assistant secure circuit evaluation 
approaches direction quorum schemes distributing trust servers threshold cryptography 
suffer performance issues associated quorum schemes 
low level step direction secure data structures 
scenario processor loads storage data untrusted processor 
context necessary verify data returned processor correct 
approaches reported loading rams secure stacks queues linked data structures 
higher level application servers provide useful service generate proof carrying answers come proof correctness 
example necula lee certifying compiler 
source program compiler certifier produces proof type safety resulting binary counter example illustrating potential violation 
example consider publication databases contents database published untrusted entity takes task responding queries customer 
context publisher provide compact proofs correctness answers 
show construct proofs correctness linear size answer query 
security software controlled systems critical normal everyday life 
timely effective correct construction systems ongoing difficult challenge faced software engineers 
outlined important open issues faced researchers software engineering security engineer security critical systems millennium 
common criteria version see csrc nist gov cc 
working group security criteria 
technical report international standards organization iso joint technical committee information subcommittee security techniques 
department defense trusted computer system evaluation criteria 
dept defense standard department defense dec 
abadi feigenbaum 
secure circuit evaluation 
journal cryptology 
allen garlan 
formalizing architectural connection 
proceedings th international conference software engineering 
ieee computer society may 
amato loui 
checking linked data structures 
proceedings th annual international symposium fault tolerant computing ftcs 
anderson kuhn 
tamper resistance cautionary note 
second usenix electronic commerce workshop 
usenix association november 

tamper resistant software implementation 
hiding information hiding international workshop volume pages 
springer verlag 
bell lapadula 
secure computer system unified exposition multics interpretation 
technical report mtr mitre bedford ma 
bellare 
practice oriented provable security 
okamoto editors proceedings international workshop information security volume lncs 
springer verlag 
blum evans gemmell kannan 
checking correctness memories 
algorithmica 
borgida greenspan mylopoulos 
knowledge representation basis requirements specifications 
ieee computer 
burrows abadi needham 
logic authentication 
technical report src research report digital equipment feb 
revised february 
software protection device 
united states patent 
coleman arnold hayes 
object oriented development fusion method 
prentice hall 
collberg thomborson :10.1.1.33.8088:10.1.1.33.8088
software watermarking models dynamic embeddings 
symposium principles programming languages 
corbett 
constructing compact models concurrent java programs 
proceedings international symposium software testing analysis issta march 
memon yeo yeung 
resolving rightful ownership invisible watermarking techniques limitations attacks implications 
ieee journal selected areas communications may 
department defense 
trusted computer system evaluation criteria orange book 
dang kemmerer 
astral model checker analyze mobile ip 
proceedings st international conference software engineering pages 
desmedt frankel 
threshold cryptosystems 
advances cryptology crypto 
devanbu fong stubblebine 
techniques trusted software engineering 
proceedings th international conference software engineering 
devanbu frakes 
extracting formal domain models existing code generative reuse 
acm applied computing review 
devanbu gertz martel stubblebine 
authentic third party data publication 
cs ucdavis edu devanbu pdf 
devanbu gertz stubblebine 
security automated distributed configuration management 
proceedings icse workshop software engineering internet 
devanbu stubblebine 
cryptographic verification test coverage claims 
proceedings fifth acm sigsoft conference foundations software engineering 
devanbu stubblebine 
cryptographic verification test coverage claims 
ieee transactions software engineering 
accepted appear 
devanbu stubblebine 
stack queue integrity hostile platforms 
proceedings ieee symposium security privacy oakland california may 
dwyer clarke 
data flow analysis verifying properties concurrent programs 
proceedings second acm sigsoft conference foundations software engineering 
dwyer hatcliff 
slicing software model construction 
proceedings acm sigplan workshop partial evaluation semantics program manipulation pepm 
emmerich 
software engineering middleware roadmap 
finkelstein editor software engineering special volume published conjunction icse 
engels 
object oriented modeling roadmap 
finkelstein editor software engineering special volume published conjunction icse 
estublier 
software configuration management roadmap 
finkelstein editor software engineering special volume published conjunction icse 
evans 
flexible policy directed code safety 
proceedings ieee symposium security privacy 
feigenbaum 
encrypting problem instances take advantage having trust 
advances cryptology crypto 
frankl weyuker 
applicable family data flow testing criteria 
ieee transactions software engineering august 
fraser badger feldman 
hardening cots software generic software wrappers 
ieee symposium security privacy 
garlan allen 
architectural mismatch hard build systems existing parts 
proceedings th international conference software engineering 
ieee computer society may 
godefroid 
model checking programming languages verisoft 
proceedings popl 
hall heimbigner van der hoek wolf 
architecture post development configuration management wide area network 
th international conference distributed computing systems may 
hall heimbigner wolf 
cooperative approach support software deployment software dock 
international conference software engineering may 
harrison ruzzo ullman 
protection operating systems 
acm 
harrold 
testing roadmap 
finkelstein editor software engineering special volume published conjunction icse 
hellman 
software distribution system 
united states patent 
pandey levitt 
security policy specification graphical approach 
technical report cs university california dept computer science davis california july 
hurley 
adage policy language www camb org ri adage index htm 
jackson rinard 
reasoning analysis roadmap 
finkelstein editor software engineering special volume published conjunction icse 
jackson 
lightweight extraction object models bytecode 
proceedings international conference software engineering los angeles ca may 
jacobson griss jonsson 
software reuse architecture process organization business success 
addison wesley 
jones lipton snyder 
lineartime algorithm deciding subject object security 
proc 
th annual foundations computer science 
ieee press 
joshi 
computer software security system 
united states patent 
kiczales lamping mendhekar maeda lopes 
loingtier irwin 
aspect oriented programming 
european conference object oriented programming ecoop number lncs 
springer verlag 
kilian leighton matheson tarjan 
resistance digital watermarks collusive attacks 
technical report tr princeton university computer science department july 

microprocessor providing software protection 
united states patent 
lindholm yellin 
java virtual machine specification 
addison wesley reading mass usa 
low maxemchuk paul 
anonymous credit cards collusion analysis 
ieee transactions networking dec 
castanet product family 
www com castanet ds html 

code protection cryptography 
united states patent 
mclean 
security models 
editor encyclopedia software engineering 
wiley sons 
menezes van oorschot vanstone 
handbook applied cryptography 
crc press 

secure keyed program network environment 
proceedings twentieth international conference software engineering 
mylopoulos borgida jarke koubarakis 
telos representing knowledge information systems 
acm transactions office information systems october 
avrunin clarke 
data flow analysis checking properties concurrent java programs 
international conference software engineering 
necula 
proof carrying code 
proceedings popl 
acm sigplan 
necula lee 
design implementation certifying compiler 
proceedings conference programming language design implementation 
neuman ts kerberos authentication service computer networks 
ieee communications 
nuseibeh easterbrook 
requirements engineering roadmap 
finkelstein editor software engineering special volume published conjunction icse 
omg 
common object request broker architecture corba www omg org 
omg 
security service www omg org homepages 
committee application digital instrumentation control systems nuclear power plant operations safety 
digital instrumentation control systems nuclear power plants safety reliability issues final report 
national academy press board energy environmental systems national research council 
pandey devanbu 
support system evolution software composition 
icse international workshop principles software evolution 
pandey olsson levitt 
policy driven runtime support secure execution user code extensible kernels 
cs ucdavis edu pandey ariel html 
perry wolf 
foundations study software architecture 
acm sigsoft software engineering notes october 

software protection method apparatus 
united states patent 
reed syverson goldschlag 
anonymous connections onion routing 
ieee journal selected areas communication special issue copyright privacy protection 

petersen pereira pun 
cryptographic copyright protection digital images watermarking techniques 
theoretical computer science sept 
sander tschudin 
software protection function hiding 
information hiding pages 
springer verlag 

tool securely integrating legacy systems distributed environment 
working conference reverse engineering wcre atlanta ga october 
stubblebine syverson goldschlag 
unlinkable serial transactions protocols applications 
acm transactions information system security november 
tolman 
anti piracy system separate storage alternate execution selected public proprietary portions computer programs 
united states patent 
minsky 
unified support heterogeneous security policies distributed systems 
th usenix security symposium san antonio texas 

security model distributed object framework applicability corba 
editors information systems security facing information society st century proceedings th international information security conference ifip sec pages greece may 
chapman hall 
voas 
certifying shelf software components 
ieee computer 
weyuker 
testing non testable programs 
computer journal 
www 
world wide web consortium www org 
yee tygar 
secure coprocessors electronic commerce applications 
proceedings usenix workshop electronic commerce new york new york july 
yeung 
digital watermarking 
communications acm july 
