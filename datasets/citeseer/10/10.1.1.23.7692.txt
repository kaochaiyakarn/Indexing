empirical study opportunities bit level specialization word programs caspi research project submitted department electrical engineering computer sciences university california berkeley partial satisfaction requirements degree master science plan ii 
approval report comprehensive examination committee professor john wawrzynek research advisor professor kurt second reader fall majority programs today written word computing ar microprocessor word programming languages 
word model convenient typically provides quantized word widths mismatch applications 
consequently bits word may go unused contribute useful information computation 
removing bits computation specialized hardware data paths may pro vide implementation significant savings run time area power 
project analyze quantify bit level waste model bit constancy binding time 
applying model ucla mediabench suite programs find bit level read operations eas ily identified constant data unused high order bits 
findings suggest significant opportunity bit level specialization programs relatively simple means narrower data paths 
contents project overview 
constancy word model 
word level constancy 
narrow width computation 
address computation 
profiling discover constancy 
capturing dynamic behavior 
source level profiling 
storage profiling 
model bit level constancy 
methodology overview 
instrumentation 
program transformations 
instrumented events 
run time data collection 
data structures 
profiler actions 
cost profiling 
run time result report 
call chain disambiguation 
results profiled applications 
rule bit storage 
bit constancy heap 
bit constancy variables 
constancy bit regions variables 
effects call chain disambiguation 
constancy lifetimes 
sensitivity inputs 
summary 
discussion problems limitations 
problems suif 
reducing memory usage 
analyses 
collapsing array information 
pushing variable declarations point 
bitwise reads write reads change 
exploiting bit constancy 
language features 
exploitation hardware 
probabilistic specialization 
online vs offline 
ii application specializing multipliers 
simpler constancy model bit regions 
profiling multiplies 
specialization models 
suif optimizations compilation sequence iii list figures tallying bit reads sample function invocation 
bit binding time domain 
exposing intermediate values temporary variables 
rule cumulative distribution variables responsible word reads 
rule cumulative distribution variable bits sible bit reads 
cumulative distribution variable bits bit binding time 
cumulative distribution variable bit reads bit binding time variable bit reads constant contiguous bit regions 
call chain disambiguation cumulative distribution variable bits bit binding time 
call chain disambiguation cumulative distribution variable bit reads bit binding time 
variable bit reads bits constant lifetimes 
bit binding times gzip bit reads different inputs 
pushing variable declaration point 
decomposition word bit ranges svc model model 
iv list tables components memory image 
components variable image 
breakdown bit read operations variables heap un known objects 
bit binding times heap 
breakdown variable bits bit binding time 
breakdown variable bit reads bit binding time 
variable bit reads constant contiguous bit regions 
call chain disambiguation breakdown variable bits bit binding time 
call chain disambiguation breakdown variable bit reads bit binding time 
call chain disambiguation change size performance applications 
variable bit reads bits constant lifetimes 
data files gzip input sensitivity experiment 
bit binding times gzip bit reads different inputs 
sequence steps compiling self profiling application 
people helped encouraged project 
advisor john wawrzynek wisdom telling start finish 
andr dehon intimate participation project second advisor professor kurt helping see bigger picture place project context 
office crew nick randy michael joe rest come gone pushing reverse psychology 
worked 
special denise patience late nights weekends 
kids josh ross giving perspective 
parents helping get cal cal greatest adventures life 
vi chapter large fraction computation today oriented word languages architectures bit parallel simd alus 
word model especially convenient arithmetic bit parallel logic single word operation represents parallel bit operations 
fixed width nature word model mismatch certain computations boolean logic decisions arithmetic small numbers 
cases substantial number bits word contribute useful information computation 
addition evidence significant fraction word operations traditional word architectures continually repeated previously seen inputs contributing useful steady state 
observations suggest traditional word model despite convenience lends significant computational waste consequently degraded run time area power implementation 
existing architectures sought overcome wasteful behavior word model ways 
microprocessors wasteful word operations re duced value prediction hardware value specific optimizations run time partial evaluation specialization 
wasteful bit operations reduced part going finer grained architectures 
multimedia instruction sets vis mmx done narrow word word parallel alus 
finest grain custom logic asic allow bit level specialization optimiza tion 
reconfigurable logic devices fpga allow dynamic bit level specialization adapting implementation time 
programming tools available exploiting fine grained architectures presently limited body programmers comfortable fine grained programming mmx assembly hardware description languages hdl logic schematic capture relatively small 
continued interest high level word model programming custom logic 
examples reconfigurable hardware include prisc napa garp 
project seeks quantify bit level computational waste inherent word architectures 
propose models bit level constancy lexical binding times gauge opportunity bit level spe word programs 
describe experimental framework apply models empirically dynamic executions programs 
applying methodology ucla mediabench suite find bit read operations easily identified constant data residing primarily high order bits words 
report organized follows 
chapter begins overview summary project 
chapter goes evidence literature computational waste word model introduces model quantifying waste 
chapter methodology describes experimental methodology study waste existing programs 
chapter results describes findings ucla mediabench suite 
chapter discussion discusses problems possible extensions methodology ideas exploiting bit level waste logic level specialization 
appendices included certain details experimental implementation 
project overview benefits reconfigurable computing devices ability implement data paths highly specialized application input data 
particular programmable reconfigurable devices poten tial instantiate execute minimum hardware required application 
instance fine grained device fpga possible implement alu operations add subtract arbitrary bit widths 
con trast microprocessors operations done large fixed width alus 
computation unused high order bits alus wasteful 
possible reconfigurable devices specialize data path known data values create partially evaluated smaller data path 
instance multiplier circuit constant input tially smaller faster general multiplier inputs variable 
similarly random logic partially evaluated bit level constant folding simplifies 
demonstrated number applications implemented fpgas sat solving string match ing specializing circuit particular known data values substantially smaller faster implementation specializing particular boolean formula sat particular character sequence string matching 
performance benefit specialization attributed effects smaller computational delay smaller circuit area 
smaller delay general reduce total run time 
programmable device limited size specialized circuit smaller area frees resources execute additional parallel operations 
specializing smaller area contribute smaller run time 
question posed master project raw opportunity specializing computations 
expect speed application factor data path specialization 
answer question clearly depends application applications constant data 
answer depends representation application 
example application written high level language forced particular data representations bit integers potentially wider application requires 
contrast application written hardware description language verilog arbitrary bit widths 
study focuses applications written popular high level language represents large body computation today 
word imperative sequential style programming represents way majority designers think code applications 
reasonable base representation analysis comparison asking opportunity specialization exists 
furthermore large base existing code benchmarks written available analysis 
analysis opportunity specialization necessarily specific program representation considered define wasteful operation context improved avoided specialization 
define wasteful computation result produces new information 
typically happens input values computation known constant seen 
computation specialized pre computing result avoiding run time computation 
inputs outputs computations represented named variables memory locations study concentrate identifying constant values variables memory locations 
word level example wasteful operation known inputs multiplication constant 
answer trivially known need multiplied 
generally actual value may known run time known value constant 
example dynamic constant case may profitable replace multiplier constant multiplier soon value encountered run time 
generally hardware implementation consider operations bit level 
may strictly constant value may certain constant bits 
example may significant bit zero may smaller dynamic low order bits 
operation certain known input bits specialized bit level instance removing partial products multiplier generally hardware implementation partially evaluating arbitrary bit operations 
analysis variables memory locations identify constant words constant bits words 
searching expose total actual opportunity specialize con stant values analysis able get artifacts language occlude constancy opportunity 
analyzing flow data values particularly difficult sequentialization fact value stored memory program pointers difficult know value stored memory value subsequently read memory 
addition wish account data dependent behavior constancy values known compile time 
analysis dynamic run time analysis looks actual program values execution paths 
static compile time analysis insufficient 
hypothesis explored programs written exhibit significant amount dynamic constancy bit level 
experimental methodology developed discover constant bits relate directly source 
methodology discover constant unchanging bits named variables 
furthermore methodology discover bits change respect block structure program 
corollary hypothesis existence bit level constancy constancy exploited data path specialization 
program implemented hardware methodology pinpoint constructs particular bits candidate specialization 
cause methodology dynamic data dependent program behavior results necessarily correct data set 
results directly specialize program guards additional error checking expressions hardware signal input bit value expected constant 
alternatively results analysis guide subsequent static compiler analysis prove possible input data veracity dynamically discovered constancy 
choose mediabench suite programs initial target analysis 
suite comprised various media processing tasks including signal processing data compression protocol file processing 
common element programs process large streams data audio input images fairly simple structured unchanging data paths dct adpcm 
static nature data paths expect cer tain amount constancy repeated computation multiplication fixed dct coefficient 
furthermore data paths parameterized command line options level compression jpeg encoding 
options determine constants operating modes remain fixed entire duration program execution 
behavior prime candidate tion necessary specialize data path near execution constants derived command line options 
constancy word model heart project premise computation known inputs produces useful new information 
results computation cached hard wired removing need perform computation run time 
notion means new 
commonly modern optimizing com run time specialization systems microprocessor hardware various forms caching prediction 
particularly interested extending premise bit level bit operation known bit inputs produces useful new information 
word operations implemented bit op erations ultimately boolean logic word operation inputs containing known bits exhibit computational waste bit level implementation 
section evidence constancy trivial computation word architectures 
discuss instances word level constancy computation known repeated slowly varying word values 
discuss instances bit level constancy word computation range limited arithmetic high order bits zero strided arithmetic low order bits fixed 
word level constancy traditional compile time constant propagation constant folding useful value constant operands known compiler 
compiler simply replaces computation result traditional techniques hoisting invariants loops applied dynamically valued constants exact value known compile time 
run time partial evaluation techniques value known create value specific specialized implementation 
compiler techniques deal constancy complicated typical lack mechanisms declare constant dynamically constant vari ables 
instance schilling analyzes collection scientific compiler related programs find variables declared const local non class variables behaved 
perkins finds similarly lines defense related ada code variables candidates 
number program analy ses exist automatically discover slowly varying quantities including binding time analysis staging analysis :10.1.1.43.8322
remain run time constants discovered practical analysis instance due heavy aliasing pointers files 
weaker form constancy exists word quantity takes value values values change quently 
evidence abundant microprocessors 
lipasti shen report collection spec multimedia oriented programs com powerpc dynamic instruction executions repeat operands previous execution repeat operands previous executions 
similarly wang franklin report subset specint dynamic instruction executions repeat pre vious executions 
smith report dynamic instruction executions generate fewer values static generate value 
calder reports integer instructions dynamic instruction executions repeat single frequent value 
cases operations previously seen inputs ex data value prediction hardware caches reuses results recomputing 
alternatively operations particularly simple inputs arithmetic operand special cased logic results cached 
richardson reports dynamic instruction executions spec perfect club trivial multiplication division self 
latency operation improved specializing operation recognize handle special case inputs directly emit multiplication 
latency advantage special case inputs frequent 
area cost approach augments replaces original implementation specialized 
narrow width computation microprocessors moved wide alus typically bits pri handle growing address spaces 
typical integer data values grown substantially full width alus 
high order bits data quantities remain zero act merely sign exten sion bits 
high order bits carry useful information bit worth sign alu bit operations associated effec tively wasted 
instance signal processing programs bit arithmetic implement prevailing standards 
boolean logic control flow decisions typically operates single bit quantities 
run bit bit alu cases invoke wasted bit operations 
brooks martonosi report bit processor implementation specint mediabench suites dynamic instructions operands wider bits 
additional dy namic instructions precisely bits heap stack addressing 
nearly instructions full bits 
trend microprocessors simd multimedia operations vis mmx altivec represents solution narrow arithmetic efficiently 
architectures segment wide alu typically bits vector parallel narrow operations typically bits 
architectures efficiently requires vectorizing algorithm 
furthermore bit width operations known statically peak efficiency power 
architectures waste bit operations instance case bit arithmetic implemented bits handle overflow 
brooks martonosi describe simd processor architecture ates need static knowledge bit widths dynamically recognizing bit operands 
selectively gating clock unneeded upper bits bit alu produced power reduction alu just 
dynamically vec bit operations packing wide bit alu produced speedup specint speedup mediabench 
determining precise minimum bit width word operations difficult impossible 
conservative lower bounds data widths value range analysis 
value range analysis program analysis uses interpretation estimate value range word quantities 
instance sum plus 
range limited quantities typically high order bits zero signed constant 
exist number analyses estimate data widths directly bit level 
analyses typically interpretation logic implementation computation arithmetic properties 
instance sum bit values bit value 
analyses conservative may overestimate minimum required width computation 
furthermore static performed compile time analyses discover cases word values dynamically narrow run time 
find tight bounds data widths approach project bit level uses dynamic profiling compile time analysis 
finding efficient bit width hardware implementation complicated just finding data widths 
approach improving com putational efficiency word alu measured metric bit operations area time implement narrower alu slices chain perform wide operations 
chaining may performed sequentially slice spatially multiple parallel slices 
approach suffers fragmentation operation width multiple slice width alu slice bits 
examples include recon arithmetic array haynes cheung comprised programmable multiply add blocks flexible array blocks fabs 
assump tion frequency multiplies designs falls haynes cheung find area efficient fab size 
sliced alu reconfigurable systems include chess alu elements finer level garp bit lut alu elements 
efficient slice width dependent statistics target applications architectural overheads implementation 
cases single bit slices may efficient 
prasanna consider sophisticated case bit widths grow time 
describe dynamic precision management scheme data path periodically reconfigured precise width re quired time 
target reconfigurable fabric single bit elements principle prevents technique applied fabrics wider alu slices 
address computation address arithmetic kind computation highly prone bit level constancy 
thing bit pointers small address space clearly zero high order bits 
brooks martonosi note adding small offsets large base addresses overflow full width base address 
small offset operations implemented narrow arithmetic long mechanism exists detect handle overflow case 
speculative approach added speedup spec dynamic vectorization approach 
alignment memory structures word boundaries suggests constancy lower bits addresses 
instance stepping array bit words byte addressable memory requires strided pointer lowest bits zero 
generally stepping array byte objects access offset object strided pointer constant significant bits 
phenomenon special case strided data patterns redundancy alleviated microprocessor systems strided value prediction hardware 
project described finds waste due constant low order address bits small mediabench suite 
profiling discover constancy project uses program profiling study bit level waste word ar 
introduce motivate salient features profiling approach 
details experimental methodology deferred chapter methodology 
capturing dynamic behavior accurately quantify bit level waste computation technique profiling 
profiling collects dynamic information actual execution program 
static program analyses profiling reveals actual data dependent statistics program 
source level profiling choose study programs language representative word architectures 
popular word programming language rela tively low level 
language directly represents features exist ing word processing architectures particularly features microprocessors including quantized word widths bits scalar data types known bit level representation signed complement pointer memory access 
popularity typical target architecture microprocessor suggest judicious collection programs taken representative modern word computing 
popularity means variety accepted benchmarks compilers analysis tools readily available 
concentrate ucla mediabench suite collec tion multimedia oriented benchmarks 
suif compiler modify applications run time profiling 
void add short short short bit operations call read bit reads read bit reads read bit reads write bit writes tallying bit reads sample function invocation profiling methodology collects statistics source level quan named variables related directly back program source 
results largely independent particular hardware implementation 
tallying bit operations profiler considers word op eration minimum bit width mandated original program data types fixed width particular alu implementation 
profiling results conservative report constancy typical microprocessor oriented profilers count bits alu active operation 
profiling program source level yields results reflect bit level waste original source description computation 
normally computation executed hardware 
program typically un extensive compiler optimizations execution 
preferable profile program source modified conventional compiler optimiza tions 
possible suif compiler applies optimizations source level 
storage profiling profiling methodology targets program data storage 
collects statistics access modification variables heap memory 
suif operates internal form translatable source 
storage elements represent inputs outputs primitive operations arithmetic data movement 
dynamic read accesses measure computational activity read access named variable input operation 
measure independent particular operation 
counting word read collection bit reads allows represent generic alu bit operations 
example tallying bit reads shown 
note addition operation accounted reading bit inputs 
bit storage interesting constant value change duration time 
storage location may rewritten times changing value individual bit 
bit read times changing value may profitable specialize constant 
profiling named variables source level allows relate frequency change storage bit program structure 
instance possible determine bit variable constant particular code block body loop 
way storage profiling empirically discover binding time variable bit identify 
profile storage alternative approach profile instruction operands directly 
approach popular microprocessors exe cution instructions previously seen operands sped value prediction hardware 
storage profiling instruction profiling easily differentiates constancy behavior different kinds oper ations 
instruction centric results necessarily architecture specific tied particular processor isa compiler intermediate form low suif suif compiler 
instruction centric results difficult relate back original program source 
model bit level constancy section described number different forms constancy lead compu tational waste word architectures 
word level constancy includes purely constant words slowly varying words words take small set values 
sub word constancy includes range limited words constant high order bits strided words constant low order bits words evolving precision requirement 
develop model constancy captures forms constancy bit level 
model works binary representation level focusing arithmetic word properties value range ad stride 
bit level approach oriented evaluating hardware costs identifies bits data path wasteful special ized 
applying model program gauges opportunity bit level specialization means narrower data paths logic optimization 
constancy model uses notion bit level binding times 
idea conventional word level binding time analysis static analysis assigns program quantity label domain undefined static dynamic :10.1.1.43.8322
model extends domain ways 
domain describes individual bits words differentiating sign extension non sign bits 
sign extension bits represent particular kind bit level waste comprise sub word region bits carry value zeros ones 
sign extension bits need constant perfectly correlated generally replaced hardware single representative bit 
second domain fills gap pure static dynamic classes additional labels denote frequency change 
notion frequency related program lexical structure 
bit value may constant executions program constant individual executions program constant inside lexical block 
particular class bits local variable constant dynamic entry variable scope definition 
model identify constancy finer time scale example smaller nested blocks 
lexical notion frequency change distinctly weaker flow sensitive formulations classic binding time analysis label variable different binding time point program 
lexical notion frequency applicable variables heap heap objects lexical scope definition 
heap objects analyzed subset bit binding time domain 
conventional binding time analysis gauges constancy statically definitions writes source code bit binding time model meant capture constancy dynamic execution 
dynamic constancy concerned retention change bit value 
bit storage may rewritten times execution retain value 
example unused high order bits range limited variable zero new variable values written 
bits effectively constant property evident dynamically statically 
run time analysis ignores write operations retain bit previous value 
remainder report terms bit binding time bit constancy may interchangeably 
shows domain bit binding times domain lattice bottom element undefined top element def equivalent bottom top conventional binding time analysis 
elements closer bottom static elements closer top dynamic 
strictly speaking model bit domain word domain built 
binding time domain dn bit word formed def sign block sign block sign exec sign compile sign def block block exec compile const undefined bit binding time domain direct product instances point wise bit wise upper bound lub additional restriction sign extension bits appear contiguous region high order bit positions 
non sign elements bit binding time domain shown right side undefined bottom element undefined bit bit allocated storage value defined write operation 
practice find read activity undefined storage negligible report information undefined bits 
const const bit bit variable defined const program source 
compile bit bound compile takes unique value executions compiled program 
exec bit bound execution takes unique value execution program 
value may different different executions 
block bit bound block takes unique value entry variable scope definition 
class applies local variables instantiated anew time control enters scope definition 
bit bound block value constant scope instantiation variable value may different different instantiations 
block bit bound block takes unique value scope instantiations variable 
bit takes multiple values scope instantiation 
def top element bit bound definition dynamic bit pattern change simply related variable scope def 
catch class necessarily imprecise 
name definition taken symmetry binding times necessarily imply new unique value definition point 
sign extension elements bit binding time domain shown left side designate bits serve sign extensions respective words 
sign extension bits appear contiguous region identically valued bits zeros ones high order positions 
bits change change 
sign extension elements bit binding time main correspond non sign elements frequency change 
elements include compile signed block signed exec signed def signed block signed bit def class may slowly varying way match model 
possible dynamically constant bit labeled def block scope definition larger scope 
solution described section 
bit binding time domain restricted bits heap heap objects lexically oriented lifetimes 
domain restricted ele ments undefined exec static def dynamic signed counterparts 
essentially reverts domain bit level version classical binding time domain continuum static dynamic extremes 
domain described captures forms constancy described section 
represent dynamic word takes small set arbitrary values 
represent small value set range limited constant sign bits high order positions 
generally domain conservatively represent small value set values differ bits 
bits designated constant differing bits designated dynamic 
bit binding time discovered profiling method progressive re 
bit allocated storage begins conservative designation undefined 
execution bit value defined redefined write op erations binding time designation moves domain lattice upper bound lub operations 
mechanism detailed chapter methodology described briefly 
profiling system maintains run time global incremental binding time bit allocated storage 
bits variables scope instantiation variable yields local binding time bit changed instantiation 
exit instantiation profiling system updates global binding time bit local binding time 
bits heap objects global incremental binding time associated lexical blocks 
binding time updated lub time heap bit written 
actual binding time bit taken global incremental binding time program exit 
bits storage written simply retain undefined designation execution 
bits intentionally omitted result report 
chapter methodology study bit constancy particular program modify program self profiling version 
run time profiling code processes read write accesses variables heap storage 
profiling code computes bit binding times incrementally program runs emits result report program exit 
methodology emit memory traces require post processing program termination 
chapter describes phase self profiling methodology program source code compiling processing statistics run time forming result report 
addition chapter describes call chain disam program transformation applied instrumentation analysis context sensitive yield separate results variable depending scope reached call chain 
overview profile program instrument modify source level profile read write access variables heap storage 
instrumentation process involves enumerating named variables lexical blocks inserting library calls code event interest 
calls profiling routines collect compute statistics program runs 
tation process described section 
actions profiling routines described section 
binding time storage bit computed incrementally pro gram runs 
bit storage profiling code maintains memory image bit value incremental binding time access counters information 
value changes detected write operations comparing written value value 
local variables instantiated anew entry variable scope profiling code maintain separate local memory image scope instantiation 
local information merged variable global memory image exit variable scope block 
local memory images kept stack support recursion 
manner binding time variable bit incorporate information local instances variable 
note management local information requires instrumenting entry exit program block special handling abnormal entry exit goto return 
attempt associate heap storage lexical scope 
local memory images assessment frequency change 
effect heap bits analyzed subset bit binding time domain undefined exec def signed variants thereof 
implementation identify compile bits 
determining bit bound compile require comparing value multi ple executions program 
values stored file executions read comparison new execution 
sake sim avoid mechanisms altogether concentrate individual executions 
strongest binding time implementation identify single execution exec 
instrumentation instrumentation programs done stanford suif compiler 
suif freely available extensible optimizing ansi compiler 
suif processor specific back ends internal program representation readily converted back compilation target processor 
suif way source level transformation engine 
number program transformations performed prior instrumentation enhance profiling results including variety tradi tional compiler optimizations 
section discuss transformations instrumentation convert program self profiling version 
program transformations just concern profiling program source level may re operations performed hardware 
apply number program transformations prior instrumentation help expose actual operations hardware implementation 
profiling unoptimized program may discover unrealistically plentiful con normally reduced compiler optimizations 
apply traditional compiler optimizations suif instrumenting program 
tra ditional optimizations constant propagation folding common sub expression elimination hoisting loop invariants reduce word level waste suif version harvard extensions bug fixes 
ansi suif considers int integers bits 
results bit utilization aggressive studies consider large bit alus 
removing alu memory operations possibly removing variables altogether 
compiler optimizations performed suif listed 
appendix gives details optimization man page 
forward prop forward propagate calculation variable definitions point const prop constant propagation dead code dead code elimination glob priv global variables locals cse common subexpression elimination loop invariants loop cond hoist invariants loop iterate iterate optimizations converge useful optimizations offered suif proved buggy fold constant folding reduction reduction move summation loop ivar induction variable detection reduction optimizations may available reliable versions suif instance suif beta november 
profiling read accesses variables heap objects may fully capture computational complexity deep nested expressions 
storage profiling ignores operations access storage ignore operations deep expression tree 
instance profiling code capture additions inputs read variables int int exposing intermediate values temporary variables multiplication 
effect storage profiling captures dynamic inputs outputs expression tree 
way better capture com plexity deep expression tree flatten expose intermediate quantities temporary variables 
instance profiling transformed code capture multiplication inputs read tempo variables 
unfortunately flattening transformation vastly expand program code size run time implementation 
section describes program transformation call chain disambiguation adds context sensitivity profiling analysis 
context sensitive analysis identify different results particular variable depending scope block reached call chain 
proposed transformation brute force approach 
disambiguates variable context uniquely duplicating procedures call chain 
instrumented events describe events program source code instrumented 
events instrumented insertion calls run time profiling routines routines described section names appear sans serif font 
events notably goto return statements require sophisticated handling 
language allows unrestricted jumping function goto return statements 
jump path allowed exit enter arbitrary lexical blocks 
properly profile block exits entries jump path goto return statement replaced sequence jumps special regions code called landing pads 
exit landing pad waypoint jumps exiting block 
appears block consists target label jump goto exit landing pad nearest enclosing block 
entry landing pad waypoint jumps entering block 
number pads may appear block original goto enters block 
entry landing pad consists target label calls local variable jump goto bypass adjacent entry landing pads 
list program events instrumented description code inserted handle event 
program entry exit main call initialize clean profiling library call named variable program call global variable 
function entry exit add exit landing pad return 
block entry exit call local variable add entry landing pad incoming goto add exit landing pad outgoing goto return static local variables transformed global variables pre instrumentation optimization 
profiled globals locals 

read storage call read read operation 
write storage 
goto 
return call write write operation target outside block call local variable nested block exited goto path target inside nested block insert goto new entry landing pad target block 
landing pad contain calls try local variable nested block entered goto path 
landing pads chained support goto targets arbitrarily distant code blocks non surrounding blocks handled goto function exit landing pad 
malloc calloc free replace call profile 
exit abort free create delete update corresponding memory image core entry replace call emit result report 
setjmp longjmp replace call record restore local memory images call chain run time data collection instrumented program performs self profiling calling routines pro filing library relevant program event 
compute bit binding times statistics profiling library maintains various bit masks flags coun ters variable allocated heap objects 
local variable library tracks dynamic call chain maintains local data structures scope instantiation variable 
section describes run time data struc tures maintained profiling code algorithms compute constancy statistics 
data structures identifying read write access variable heap object complicated pointers identifying access variable statically referenced name source code sufficient variable may accessed seemingly unrelated pointer 
similarly heap object may accessed multiple seemingly unrelated pointers 
classic problem pointer aliasing general impossible identify value pointer static analysis 
resort dynamically identifying variable heap object accessed dereferenced pointer 
identifying object reached dereferencing pointer job core data structure 
core maps arbitrary address memory image object containing address memory images defined 
core implemented interval set containing address ranges known objects memory including heap objects instances local variables presently call stack 
objects added core created heap object allocated lexical block containing local variables entered 
objects removed core destroyed heap object freed lexical block containing local variables exited 
possible dereferenced pointer access object known core structure created unprofiled library operating system routine 
number run time accesses unknown objects relatively small offset statistics collected known objects 
profiling library tallies reports total counts unknown known accesses 
memory image embodies profiling library run time information object memory 
library maintains image known object including allocated heap objects active instances local variables argc env arrays passed main 
memory image contains various bit masks flags counters incrementally compute bit binding times statistics 
bit binding times represented collection bit masks easy compute incrementally bit parallel logic 
counters bits prevent overflow 
table lists components memory image 
variable image embodies profiling library run time information variable 
variable image needed variable contains multiple memory images memory image represent global incremental results plus rough calculation fast profiling counter may overflow suppose original uninstrumented program runs mhz clock issues variable heap access cycle 
bit access counter overflow seconds original run time 
allow run times minutes bit counters 
bit deemed sign extension value value significant bit word identical 
condition checked bit written 
address range base pointers bit masks value value bit defined true bit defined write changed true bit value changed write sign true bit sign extension bit word counters reads number times byte read byte writes number times byte written flags true user allocated heap objects true variables objects allocated os argc argv main table components memory image stack local memory images represent active instance variable 
global memory image updated exit variable scope block block local memory image 
memory image contains bit masks represent simplified binding times heap bits undefined exec def signed variants thereof 
variable image contains additional bit masks conjunction global memory image represent entire bit binding time domain 
table lists components variable image 
counters bottom table experiment section 
enable flag dynamically enabling disabling profiling variable run time 
implementation statically instrumentation simpler 
memory images global incremental memory image stack local memory images bit masks true bits constant program execution true bits constant entry variable block scope definition true bits constant entry variable block scope dynamic entry flags true variable declared const source code enable true enable run time profiling variable misc name variable name size variable size bytes counters lifetimes number times variable block scope entered variable instantiated counters number lifetimes bit constant bit number lifetimes bit sign extension table components variable image 
counters bottom panes table experiment section 
bit binding times variables derived bit masks follows exec defined block exec defined block block defined def block defined undefined defined bit binding times heap objects derived bit masks follows exec defined changed def defined changed undefined defined bit sign variant binding times sign bit true 
profiler actions describe run time profiling routines called instrumented code 
program events instrumented listed section 
profiling routines actions follows called block entry local variable declared block allocate local memory image bits initially undefined add memory image core push memory image variable image stack read write called block exit local variable declared block pop memory image variable image stack merge local image global image called reading variable dereferenced pointer get accessed object memory image core increment read count reads reads detect unprofiled write object external library value call write called writing variable dereferenced pointer get accessed object memory image core increment write count writes writes mark bits defined defined detect value change changed changed value remember new value value called malloc calloc allocate heap object call malloc calloc create initialize new memory image insert core called heap object call update corresponding memory image core called free tally total reads writes deallocate heap object call free remove corresponding memory image core called setjmp unix setjmp save call stack longjmp jump back point program point deeper call stack 
handle jumps profiler save restore active local memory images variable 
local memory images kept stack variable image suffices save position stack 
create jump environment variable record stack pointer stack local mem ory images call conventional setjmp called setjmp restore jump environment variable pop stack local memory images restoring stack pointer jump environment call conventional longjmp called exit abort falling main 
variable repeatedly pop stack local memory images call popped image simulates clean exit exit deeply nested code block heap object call deallocate emit result report see section cost profiling profiling approach described nontrivial cost memory usage run time 
instrumentation self profiling expands code size fold due addition profiler function calls 
data size increases dramatically due overhead memory variable images 
assuming minimum size representations images tables bit heap object require bytes bit variable require bytes 
typical bit variable require bytes image overhead factor 
implementation significantly worse due indirection image representation due memory alignment 
implementation typical bit variable requires bytes overhead factor 
empirically total run time memory requirements instrumented pro gram seen times larger original mented program 
actual run time instrumented program seen approximately times larger original 
run time may larger physical memory insufficient program swaps disk virtual memory 
experiments project run machine gigabytes physical memory allowing swap free profiling programs originally require megabytes 
run time result report exiting instrumented program invokes profiling routine emit result report disk 
textual report summarizes access counts bit binding time information collected execution 
parts report may imported directly spreadsheet graphing fact graphs chapter results generated 
result report includes information minimum size variable image bytes assuming empty name string lifetime counters recursion 
dynamic level recursion adds local memory image additional bytes 

unknown accesses read write counts unknown objects 
heap statistics breakdown bits bit binding time breakdown bit reads bit binding time counts reflect allocations access heap exe cution 
bit binding times restricted heap domain undefined exec def 

variable statistics breakdown bits bit binding time 
breakdown bit reads bit binding time 
breakdown bit reads constant bit regions bit position 
considers exec exec sign bits 
region po sitions reported high order low order entire word remaining bit reads binned 
breakdown variables read count 
cumulative distribution word reads binned sorted read count variable 
intended verify rule word reads frequently read variables 
breakdown variable bits read count 
cumulative distribution bit reads binned sorted read count bit variable 
different previous bullet breakdown bit reads bit region position replaces earlier analysis emitted histogram bit reads binned lsb msb positions bit surrounding bit region 
variables different bit widths 
intended verify rule bit reads frequently read bits 
complete variable dump 
lists critical statistics variable bit width read write counts lifetime count ratios counts binding time bitmap variable fractional contribution bit reads binding time 
variables sorted read count 
call chain disambiguation approach merging bit constancy information run time instances variable conservative 
ignores possibility constancy behavior variable may vastly different depending lexical block reached dynamic call chain 
instance function may called constant arguments function dynamic arguments function context function specialized context 
section discusses program transformation adds context sensitivity profiling analysis 
transformation applied instrumentation target program proceeds normally profiling methodology 
transformation disambiguates call chain leading function replicating binding function separately possible call path 
effect turns static call graph tree recur sion 
local variables disambiguated analyzed independently path call chain uses 
attempt merge bit constancy information corresponding disambiguated variables 
experiment concerned disambiguating transformation significantly affects bit binding time profile entire program 
assumption unique call path executed frequently warrant specialization significantly affect total binding time profile program 
call chain disambiguation may allow compiler perform better inter procedural optimization 
disambiguated call paths folded away en optimizing compiler 
done suif pre instrumentation optimizations simply remove certain functions variables profiled program 
folding may done binary compiler post instrumentation optimization 
procedural replication may increase code size ultimately seen reduce run time profiled programs 
version suif extensions project implementation author knowledge perform inter optimizations 
chapter results profiled applications applications profiled project primarily multimedia processing tasks signal processing compression encryption 
applications tend data path intensive spend time processing large data streams small set computational kernels 
program form benefit significantly specialization savings realized specialized kernel amplified reuse kernel 
hypothesize typical media processing tasks exhibit particular behav iors computationally wasteful bit level 
programs implement communication storage standards deal quantities irregular bit width 
implemented word architecture microprocessor programs largest available data width leaving high order bits unused 
instance audio tasks bit samples need overflow bits resort bit computation 
encryption tasks face similar problem custom bit widths direct bit tion 
furthermore processing media streams typically involves sequential access blocks memory array indexes pointers range limited zero high order bits strided constant low order bits 
initial exploration profiling system done gnu gzip lzw compressor decompressor berkeley suite video compressor mpeg standard 
bulk tion done ucla mediabench suite collection multimedia processing benchmarks including signal processing encryption image manip ulation tasks 
mediabench components profiled include adpcm adaptive differential pulse code modulation audio coding com presses bit samples bit code words epic epic lossy wavelet image compression encode decode voice compression ccitt standards gsm toast speech transcoding european gsm standard com presses frames bit samples bit code words jpeg cjpeg djpeg lossy dct image compression mpeg mpeg encode mpeg decode lossy video compression mpeg standard mediabench components profiled due technical problems discussed section 
include ghostscript postscript interpreter mesa library implementing opengl standard appli cations mipmap pegwit public key encryption elliptic curves sha sym metric block cypher pgp public key encryption idea md rsa rasta speech recognition plp rasta rasta tech niques study general purpose applications attempted profile specint suite 
programs success fully pass profiling system reasons discussed section 
specint findings 
rule bit storage specialization relatively difficult task requiring non trivial time mem ory resources recompilation 
probably impractical specialize parts program 
desire situations specializing small part program kernels yield large performance gains 
traditional pro filing identifies kernel code blocks storage profiling identifies kernel variables 
kernel variables frequently accessed storage elements program 
presumably serve input output kernel code may accessed 
classic rule claims program typically spends time executing code 
wish verify corresponding rule storage 
program typically spend reads accessing variables 
similarly bit level program typically spend bit reads accessing variable bits 
questions distinguished different variables different bit widths discrepancy especially evident aggregates arrays 
figures attempt verify rule variables vari able bits respectively mediabench 
cumulative distribution variable reads sorted read count variable 
essentially graphs percentage variables responsible percentage variable read operations 
variables sorted horizontal access descending order read count frequently read variable tallied 
thick curve represents mean average profiled applications 
find average variable read operations access variables 
bit level analogue 
cumulative distribution bit reads variables sorted read count bit variable 
find average bit read operations variables access bits 
figures findings line rule rule breaker adpcm audio coding variable reads access variables 
dilution rule arises mediabench adpcm implementation essentially kernels 
adpcm smallest mediabench application having routines main encode decode profiled variables 
kernel accesses large fraction program variables single variable important 
rule include jpeg encode decode epic mpeg decoding bit reads access variable bits 
dilution rule apparently tables implemented statically declared arrays 
table accesses comprise large fraction program bit reads spread bits percentage variable reads percentage variables responsible read activity percentage variables epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average rule cumulative distribution variables responsible word reads percentage variable bit reads percentage variable bits responsible bit read activity percentage variable bits epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average rule cumulative distribution variable bits responsible bit reads tables 
particular table table region solely responsible overwhelming majority bit reads 
note rule figures exhibit great reuse storage 
adpcm variable read operations access variables 
similarly epic jpeg mpeg variable bit reads access variable bits case mpeg decode number variable bits 
bit constancy heap analysis performed variables different analysis performed heap 
analyses involve different bit binding time domains somewhat different profiling actions 
experiments run variables heap storage results chapter focus variables 
reason bias twofold 
observe profiled applications reads variables occur far frequently reads heap 
furthermore observe bit constancy variables fairly uniform applications bit constancy heap highly application dependent 
appears bit level computational waste variables endemic mediabench benchmark suite possibly larger class programs written high level lan guages 
waste variables interesting waste heap language phenomenon specialization potential 
table presents breakdown bit read operations mediabench variables heap objects unknown objects 
find average program spends bit reads accessing variables accessing heap objects 
applications heap storage application spends bit reads heap 
variable reads significantly frequent heap reads average times frequent 
table demonstrates read accesses unknown unprofiled objects practically non existent 
unprofiled objects include objects visible compile time structures returned library operating system routines 
table summarizes bit constancy behavior observed heap applications 
consider binding times bits value constant exec bits value dynamic def alloca tion lifetime enclosing heap object 
find fraction constant bits heap highly application dependent 
similarly fraction bit reads constant bits heap highly application dependent 
applications maintain reuse lot constant heap storage instance jpeg compression cjpeg heap bits heap bit reads constant val 
constant storage consist input image quantization tables huffman tables 
applications dynamic heap storage instance gsm speech transcoding encode heap bits heap bit reads dynamic valued 
bit constancy heap may difficult exploit specialization sheer size objects heap 
may practical specialize away small lookup table rom hard wiring values logic practical large tables values 
creating custom hardware choice rom logic implementation lookup table involves time space tradeoff scope 
total variable heap unknown reads reads reads reads millions epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average table breakdown bit read operations variables heap unknown objects indicates non zero quantity heap const dynamic heap const dynamic bits bits bits reads reads reads millions millions epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode table bit binding times heap indicates zero heap bit constancy variables summarize bit binding times variables media bench programs 
table lists breakdown variable bits binding time 
shows fraction storage falls binding time 
table lists breakdown variable bit reads binding time 
shows fraction dynamic bit reads bits binding time 
tables total contribution sign bits exec bits bits easiest specialize 
corresponding figures graph contribution bits bit reads binding time cumulatively 
bit binding times sorted horizontal axis frequency change partial ordering binding time domain heuristic information graphs convex curves indicate abundant constancy concave curves represent dynamic behavior 
note tables figures tally allocated storage remains undefined read 
find significant contribution exec bits change value execution 
table shows average variable bits bound exec sign extension bits non sign 
ta ble shows bits account average dynamic bit reads variables reading sign extension bits reading non sign 
profiled applications typically half dynamic bit reads re reading bits change 
find significant contribution sign extension bits 
table shows average variable bits sign bits 
table shows bits account average dynamic bit reads variables 
promising prospect specialization arithmetic data path needs representative sign bit 
single sign bit bits bit word byte bit word 
variable const sign exec bits exec exec block block block block def def sign thousands signed signed signed signed epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average percent variable bits table breakdown variable bits bit binding time const exec sign binding times variable bits exec block sign block binding time block sign block def sign def epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average cumulative distribution variable bits bit binding time variable const sign exec bit reads exec exec block block block block def def sign millions signed signed signed signed epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average percent variable bit reads table breakdown variable bit reads bit binding time const exec sign binding times variable bit reads exec block sign block binding time block sign block def sign def epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average cumulative distribution variable bit reads bit binding time fact variable bits sign bits indicates sign bits necessary word 
altogether find dynamic bit reads variables easily identified constant sign data 
average bit reads sign extension bits specialized narrower data paths 
additional bit reads exec bits specialized execution possibly executions know bits compile 
additional bit reads block bits specialized entry variable scope function entry loop iteration 

remaining bit reads variables dynamic quantities promising specialization 
split fairly evenly def def bits 
slowly changing bits categories may amenable probabilistic specialization techniques described section 
interesting note nearly mediabench applications const variables 
exception jpeg suite cjpeg djpeg uses numerous const arrays tables dct coefficients 
typical explicitly declared constants may due fact syntax declare dynamically valued constants 
schilling suggests due bad programming practice common languages allow declaring 
mediabench exhibits schilling problem having candidate undeclared expect find large contribution words bits block exec possibly signed 
question partially answered section table shows exec bit reads fully exec words 
tallied bit reads words allow block bits 
fraction bit reads words large argument addition declaration language feature 
note schilling reports local variables candidates report read basis comparison measure bit reads 
constancy bit regions variables bit position unchanging slowly varying bits affects potential impact specialization 
particular interest sign extension bits may allow high order bits removed data path 
generally interested contiguous regions unchanging bits inside word specializing may significantly speed arithmetic carry chains cascades 
unchanging bit regions significant position typical range limited arithmetic may sign constant 
unchanging bit regions significant position typical arithmetic involving multiples instance pointer arithmetic 
table corresponding show bit reads constant bit re variables mediabench 
show bit reads bits contiguous regions exec exec sign bits 
differ high order bit regions include msb low order bit regions include lsb entire word bit regions include bits word 
bit reads exec bits positions tallied column 
total contribution bit reads exec exec sign bits copied table 
find bit reads bits defined execution due primarily constant high order bit regions 
average total bit reads low high entire total non sign order order word exec exec high bit bit signed order region region epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average table variable bit reads constant contiguous bit regions containing exec exec sign bits 
percentages taken fractions variable bit reads application 
percent variable bit reads variable bit reads constant contiguous bit regions epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average entire word high bit range low bit range variable bit reads constant contiguous bit regions containing exec exec sign bits 
percentages taken fractions bit reads application 
exec exec sign bits bits high order bit regions 
constant low order bit regions word 
modest bit reads entirely constant words 
bits high order regions really sign bits 
constant non sign bits high order regions 
non sign bits significant positions high order regions left sign bits 
sign bits constant non sign bits simply removed data path 
specialized means bit level constant folding 
possible find contribution constant non sign high order bit reads simple arithmetic table columns 
sign bits come high order entire word regions calculate non sign high order bit reads non sign high order high order bit region entire word exec sign result shown rightmost column indicates average bit reads exec non sign bits high order bit regions 
bit reads constant bit regions 
remaining sign bits 
effects call chain disambiguation tables show bit binding times variables mediabench call chain disambiguation described section 
tables tables tally variable bits bit reads call chain disambiguation 
similarly corresponding figures analogous figures 
data collected application mpeg decode call chain disambiguation applied successfully 
table shows call chain disambiguation negligible effect size variable const sign exec bits exec exec block block block block def def sign thousands signed signed signed signed epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average table call chain disambiguation breakdown variable bits bit binding time percent variable bits const exec sign binding times variable bits call chain disambiguation exec block sign block binding time block sign block def sign def epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average call chain disambiguation cumulative distribution variable bits bit bindingtime variable const sign exec bit reads exec exec block block block block def def sign millions signed signed signed signed epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average table call chain disambiguation breakdown variable bit reads bit binding time percent variable bit reads const exec sign binding times variable bit reads call chain disambiguation exec block sign block binding time block sign block def sign def epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average call chain disambiguation cumulative distribution variable bit reads bit binding time variable storage breakdown bits binding time 
table hand shows call chain disambiguation significant effect access pattern variables 
applications experience negligible change applications change total number bit reads variables shrinks tenfold 
presumably program trans formation subsequently enables effective compiler optimization 
massive reduction bit reads beneficial outcome call chain disam 
resulting optimized program faster relatively dynamic harder specialize reasons described 
call chain disambiguation subsequent compiler optimization tends cre ate dynamic bit binding times 
fraction bit reads bits defined execution exec exec sign decreases average fraction bit reads dynamic bits def def sign increases average 
fraction bit reads sign bits drops binding times going total 
incorrect say call chain disambiguation program dynamic reduces total bit read count tenfold 
program relatively dynamic reduced activity 
table shows effect call chain disambiguation subsequent compiler optimization measures program size performance 
execution time seen decrease average executable size increases case mpeg encode expands tenfold similarly mpeg decode expanded call chain disambiguation completed 
interestingly call chain disambiguation tends increase program size increasing data size adding variable heap bits 
cases data size decreases 
testament program transformation enables effective compiler optimizations 
relative size relative performance executable variable heap execution variable heap bits bits time bit reads bit reads epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average table call chain disambiguation change size performance mediabench applications 
quantities relative call chain disambiguation 
transformations reduce bit reads variables leave bit reads heap largely unaffected 
greatly emphasizes heap access variable access 
potential benefit specializing constant variables reduced 
constancy lifetimes table shows variable bit reads mediabench non sign block bits 
bits take single value scope instantiations lifetimes value 
question pose dynamically bit class bound scope 
answer time bit specialized common case methods block bits 
uncommon case multiple definitions block detected time block handled accordingly 
probabilistic tion scheme profitable total cost handling uncommon case smaller savings specializing common case 
define local variable lifetime single pass control flow variable scope definition resulting creation destruction instance variable 
metric examine fraction variable bit lifetimes bit bound constant lifetime 
table show number bit reads block bits constant dynamic lifetimes 
note table tally block bits effectively constant lifetimes 
table tallies non sign bits sign bits interest ing specialized time narrowing data path 
results shown unoptimized versions mediabench applications 
break bit reads binding times results remarkably similar break optimized compilations 
total con tribution bit reads tabulated total contribution block bit reads optimized mediabench applications table 
results promising specialization 
bit reads block bits average bits constant lifetimes 
bit reads bits constant lifetimes 
indicates block bits rarely bound lifetime 
bits frequently bound lifetime may amenable probabilistic specialization contribution total bit read activity program small specialization negligible effect total run time 
bit reads bit reads total bits bits bit reads const const lifetimes lifetimes epic encode decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode average table variable bit reads bits constant lifetimes non sign block categorized fraction lifetimes bit constant percent variable bit reads epic encode variable bit reads bits constant lifetimes decode gsm toast gsm cjpeg djpeg mpeg encode mpeg decode pegwit encode pegwit decode average total bit reads bit reads bits const lifetimes bit reads bits const lifetimes variable bit reads bits constant lifetimes non sign block categorized fraction lifetimes bit constant sensitivity inputs natural question profile systems results profiling input set indicative application behavior inputs 
rel ative insensitivity inputs desired property profile driven specialization 
specialization easier yield better run time efficiency 
insensitivity inputs important validating results project results reported typically single data set application 
section presents preliminary evidence bit binding time profiles largely insensitive variation input data sets 
media processing applications typically run large streams data defined computational pipelines 
conceivable execution profiles application vary little different input data files processing pipeline fairly rigid 
find significantly dif ferent profiles different operating modes application different modes affect processing pipeline 
instance choosing com pression decompression mode may select entirely different pipeline 
mind conducted preliminary study input sensitivity gzip compression program 
gzip freely available lossless lzw compression suite 
convenient representative application experiment reasons 
implements compression de compression mode executable selected command line option 
second operate file input data sets plentiful 
input files chosen represent different data domains gzip executable machine code source code english text graphic image 
ta ble lists details input files 
profile compression mode instrument run gzip file 
profile decompression mode run gunzip effectively gzip compressed version file 
file content description uncompressed compressed size size powerpc machine code linux kernel mb kb gzip tar source code kb kb shakespeare english text mb kb lena raw bit image lena face kb kb ftp ftp dodds net pub linux ftp ftp cdrom com pub gnu gzip tar gz ftp std com obi shakespeare shakespeare ftp ftp cdrom com pub contrib wavelet pic lena raw table data files gzip input sensitivity experiment experiment conducted early project development suf technical flaws 
performed early version bit binding time lattice results distinguish tween sign non sign bits 
second compiler optimizations performed prior instrumenting application profile results reflect unop programmer model computation executed processor 
table presents bit binding times variables input files described 
shows results graphically 
find sensitivity inputs dynamic bit binding times little sensitivity 
particular largest binding time class promising specialization bits bound execution shows little variation 
contributes variable bit reads data sets operating modes 
variation operating mode compression decompression profile dynamic binding times 
compared compression decompression exhibits average bit reads def bits fewer bit reads block bits 
decompression marginally dynamic behavior 
operating mode profiles consistent input data files variable const bit reads exec block block def millions gzip gzip gzip tar gzip shakespeare gzip lena raw gzip average gunzip gunzip gzip tar gunzip shakespeare gunzip lena raw gunzip average average percent variable bit reads table bit binding times gzip bit reads different inputs gzip gzip gzip tar gzip shakespeare sensitivity inputs variable bit reads gzip gzip lena raw gunzip gunzip gzip tar gunzip shakespeare gunzip lena raw definition block block compile bit binding times gzip bit reads different inputs const graphic image lena raw 
image file tends gzip behave dynamically pushing bit reads block def compression pushing somewhat decompression 
image file differs inputs format known generally incompressible lzw 
sense image file known bad input high performance unimportant 
may draw weaker bit binding time profile gzip insensitive data inputs large variety compressible input formats 
similar findings reported literature data constancy largely insensitive particular data set 
calder report variety data invariance metrics processor instructions citing little variation data sets spec programs 
fisher freudenberger report similar invariance profile branch prediction spec programs concede program bad input sets exercise unusual parts code 
findings suggest program constancy behavior dependent algorithmic structure particular data values 
summary methodology tallies bit read operations 
consider read source code named variable memory location 
reads done words bit char types bit int types 
methodology tallies read collection parallel bit operations bit reads 
methodology reports bit reads accessed constant bits accessed dynamic bits 
categorization constant vs dynamic bits lattice binding times representing frequency bit change respect scope variable bit sign extension bit 
find constancy bits heap highly application dependent 
applications examined bit read opera tions heap unchanging bits 
wholly promising find accesses heap accesses variables 
subsequently concentrate variables 
find bit reads variables easily identified con stant bits 
represents significant raw opportunity specialization 
means bit operations doing repeated wasteful con stant previously seen inputs 
aggressive specialization able shrink number required useful bit operations 
applicable approaches specialization discussed chapter sections 
breakdown follows 
find average bit reads variables sign extension bits 
sign extension bits particularly easy exploit simply narrower data paths 
alu operation add subtract typically needs sign bit 
may possible remove half program bit operations simply specializing narrower data paths 
arguably promising useful finding experiments 
remaining results contribute relatively little opportunity specialization 
included completeness 
find average bit reads variables exec bits non sign bits remain constant program execution 
may possible specialize data paths process bits bit level partial evaluation execution bit values known 
bit reads touch average bits program variables 
represent large collection constant values large usefully specialized 
find average bit reads variables block bits non sign bits remain constant scope invocation vari able 
variables represent local variables instantiated anew execution enters block scope block curly statement block 
may possible specialize data paths process bits bit level partial evaluation entry block scope 
net performance benefit may total cost dynamic total savings specialized execution 
con tribution bits total bit read activity program small specialization probably worth effort 
easy bit reads find average bit reads variables block bits non sign bits remain constant scope invocations variable 
bit constant scope invocations variable specialized constant invocations provided additional hardware guards detect special case instances bit constant 
probabilistic specialization net benefit bit constant particular cost dynamic special casing savings specialized execution bit constant 
practice find bit reads category representing bit reads variables bits constant scope invocations variable 
contribution bits total bit read activity program small specialization probably worth effort 
find final bit reads variables def bits non sign bits change dynamically variable scope 
bits block bits patterns change correspond lexical blocks identified specialized methodology study 
possible bits retain constant value long epochs principle benefit dynamic specialization 
analysis discover cases discussed section 
addition explored program transformation call chain tion intended discover code block behaves differently called different call sites allow separate optimizations specializations differ ent call sites 
transformation enable substantial optimizations standard compilation leading program executions average times fewer bit reads substantial increase code size data size note programs affected transforma tion 
remaining code exhibits somewhat opportunity specialization 
particular bit reads variables sign bits compared code call chain disambiguation 
regardless value bit level specialization find program transformation may great value traditional compilation microprocessor architectures 
chapter discussion proposes analyses uncover bit constancy number techniques exploiting constancy hardware implementations programs 
chapter discussion experimental results chapter results indicate substantial opportunity bit level specialization programs 
chapter discusses possible applica tions findings specializing hardware software problems limitations possible extensions experimental methodology 
section discussion problems limitations profiling implementation study 
section particular discusses im plementation excessive memory usage control 
section proposes analyses uncover bit level constancy 
section discusses mechanisms exploiting bit level constancy profiling including possible language extensions run time support dynamic specialization 
section explores specialization multipliers proposing multiply centric profiling methodology cost model implementation issues 
problems limitations section discusses problems shortcomings profiling methodology project 
discuss conceptual limitations approach implementation issues weakened results prevented particular appli cations profiled 
discussion implementation large memory requirements reduce follows section 
relevance hardware serious shortcoming profiling approach project directly quantify available benefit specializing hardware implementation metrics time area power 
profiling bit level analysis identifies computations may benefit logic level spe hardware data paths 
profiling storage analysis abstracted specifics logic level hardware implementation 
finding constant bit storage location indicate performance benefit associated data paths get specializing bit value 
quantifying hardware benefit specializing program constant bits requires model hardware cost specialization techniques op eration bits 
different operations amenable different forms specialization 
section develops models multiply operation particular 
closest description extract program ac tual operations done hardware machine specific instruction sequence 
alternatively machine independent sequence suif inter nal program representation 
bit constancy profiled instruction operands storage locations 
analyzing instruction stream may appropriate evaluating alternative microprocessor hardware moving simd multimedia isa vector narrow alus 
instruction stream introduces isa specific grouping sequentialization primitive opera tions 
ideal evaluating savings custom hardware primitive operations may grouped parallelized flexibly 
aggregate data structures profiling methodology project geared integer data types 
sign bits bit binding time domain assumes word complement representation 
implementation aggregates structs arrays analyzed wide integer objects 
completely ignores structure individual words aggregate produces faulty information sign bits 
type aware analysis needed decompose aggregates constituent integer elements capture respective bit binding times 
recognizing component aggregate accessed simple direct variable access difficult pointer 
direct variable access component identified explicit name offset 
component accessed pointer profiling library knows run time address accessed 
core identify object contains address see section 
identifying component object accessed requires knowing type object 
easy object turns variable type known statically source code 
general impossible know type object heap 
heap allocation routine malloc strongly typed knows allocated object size 
clue type object heap comes type pointer access 
complication arises aggregate accessed pointers different types region memory block copied identifying component aggregate accessed dereferenced pointer possible union variable multiple types exist certain offsets aggregate array chars construct 
multiple typing problem exists variables heap objects 
similar nature multiple typing evident union aggregates exists specifically pointer aliasing 
solution determining type integer component accessed pointer believe type pointer 
char pointer ac cessing char int pointer accessing int 
solution may misinterpret location sign extension bits bit regions accessed object possible access byte storage different alignments larger integer accesses byte address may part bit short address bit int address 
com plication issue programs highly structured strongly typed conventions bytes storage accessed type 
problems suif suif compiler proved stumbling block profiling applications 
cases suif front accept program 
cases suif optimization passes crashed 
cases suif back emitted faulty program subsequently crash 
problems prevented number programs analyzed 
list programs specific problem encountered programs ucla mediabench suite ghostscript suif linker fails pegwit pgp rasta suif optimizations run mem ory programs specint ksim suif back crashes due variable length argument lists va list compress li emitted program crashes ijpeg suif back crashes perl procedure duplication call chain disambiguation fails copies certain suif optimizations proved frequently buggy profiled applications 
include fold constant folding reduction reduction move summation loop ivar induction variable detection reduction task running application suif transformation compilation pipeline difficult 
possible simply substitute suif compiler place traditional compiler 
suif pass front linking instrumentation back requires separate program execu tion 
passes operate individual source files traditional incremental compilation passes process entire file set 
sufficient traditional makefile rules simply map file extension 
application requires new custom makefile explicit sequence suif passes appendix explains compilation sequence 
applications sophisticated makefiles build scripts notably gcc specint identifying creating working set source files cre ating new makefile proved difficult applications altogether 
reducing memory usage major shortcoming profiling methodology project large memory requirement 
seen section analysis expands code data sizes leading memory requirement high times original program 
expansion data memory factor times larger necessary due poor implementation memory variable images 
promising way significantly reduce total memory requirement selectively profile small fraction program storage 
rule suggests able capture interesting activity program small fraction storage 
discuss ways choosing storage profile ignore 
profile kernels pass strategy seeks profile lexical blocks comprise computational kernels contribute large frac tion program execution time 
execution needed identify kernels profiling tool gprof 
second execution instrumented profiles kernels 
profile best variables pass strategy seeks profile variables excel particular metric highest read count 
execution needed compute desired metric variables necessary computing desired metric require memory conventional bit binding time analysis savings realized 
suif community quick point suif compile spec suite 
harvard extensions introduce bug fixes enable compilation spec 
suif unable successfully instrument compile spec 
suif presently beta promises compile spec 
second pass instrumented profile variables best metric 
note metric variable read count rank variable importance cost implementation 
cache best variables variables profile cache model select variables fly 
pass approach profiling system reserves fixed amount memory fully profile small number variables 
variables enter leave cache metric eviction policy 
appropriate metric probably variable read count 
additional memory may needed compute metric variables 
cache model assumes particular ing set frequently read variables emerge execution 
cache thrashing possible 
disadvantage scheme profiled variable may spend duration program cache binding time information incomplete 
cache con tents periodically analyzed written file order catch evolving working set variables 
additional savings memory may collapsing array variables keeping incremental binding time information single representative element 
discussed section 
analyses transformations analyses considered detail imple mented due lack time 
purpose collectively uncover forms bit constancy 
approaches discussed 
collapsing array information profiling system analyzes array single wide integer 
discussed section results arrays useful possi bly erroneous sign bits properly identified 
useful way analyze array profiling framework combine bit binding times array element upper bound lub single representative element 
refer collapsing array 
collapsing array single element lose significant element wise information 
array elements seldom accessed individually 
media processing programs particular tend walk sequentially ranges array elements entire array 
order analysis expect elements array similar constancy 
true representative element formed lub conservative specialization computationally correct 
actual collapsing elements done points profiling framework 
approach collapse program exit computing result report 
requires incrementally computing storing binding times array element execution 
alternative approach incrementally compute binding times representative element 
approach save significant memory array memory image simplified contain value possible avoid cost 
full memory variable image containing counters bit masks needed representative element 
possible avoid keeping value storage location 
requires write operation profiled immediately prior write previous value place 
approach recognize value changes unprofiled code library routine 
int 

int 
pushing variable declaration point pushing variable declarations point declaring variable may variable lexical scope appear needlessly large binding time needlessly weak 
bit binding time variable bit measures rate change respect variable scope definition 
binding time thought covariant constancy contravariant size block 
tighter analysis beneficial identify variable smallest block variable possibly declared 
consider instance variable updated iteration loop embody loop carried dependency value iteration subsequent iterations 
logical scope body loop 
variable declared outside loop body 
changes value lifetime bits classified def 
variable declared inside loop body 
constant lifetime bits classified block 
moving variable declaration smallest possible scope yields stronger binding time useful specialization system 
easy formalize automate process identifying smallest scope variable declared 
write suif compiler pass identify smallest scope transform program push variable declaration point 
best pass promote classification certain bits def block block 
bitwise reads write reads change bit binding time domain detect slowly varying behavior clearly related lexical block 
instance detect variable constant loop dynamic loop 
loop runs iterations may profitable specialize variable constant value 
variety source level transformations go way disambiguate value scope constancy profiling methodology 
pushing variables point section helps refining variable lexical scope 
transformation static single assignment ssa form add flow sensitivity disambiguate variable different places splitting separate variables 
similarly call chain disambiguation section adds context sensitivity disambiguates variable different call sites duplicating variable surrounding code 
shortcoming binding time model ameliorated transformations quantify numerically value changes 
transformations help refine lexical scope value scope says times value changed 
specializing constant value profitable con stant value reused times changing 
propose metrics orthogonal lexical binding time reads writes reads value changes 
counts number uses variable gets write operations 
counts number uses variable gets writes change variable values 
metrics help suif pass push variable declarations scope written fully debugged 
results discussed report 
identify instance block bits worth specializing block def bits worth specializing 
measuring average reads writes average reads value changes trivial 
equivalent computing ratio total reads total writes total reads total value changes respectively 
requires read write counters variable implemented 
requires change counter bit large overhead bit change counter bytes overhead byte original program storage 
measuring standard deviation metrics complicated computed incrementally additional counters 
value metrics may fact vary different times program execution 
consider reporting averages multiple times execution 
exploiting bit constancy goal analyses quantify computational waste form constant slowly varying bits 
ultimately goal find ways avoiding exploiting waste 
distinct approaches 
approach modify language program representation explicitly reduce computational requirements 
approach modify implementation specializing hardware software known bit behavior 
section pose thoughts approaches 
compute mean reads writes suppose write wi record number reads ri occured writes wi wi 
mean ri ri total reads total writes similarly mean reads value changes total reads total value changes language features results study suggest language features may help exploit constant bits run time constants explicit bit widths 
dynamically valued constant variable value constant known run time 
declaring effect allows pro grammer explicitly declare binding time variable lifetime value 
declare const keyword declares local variable value constant scope definition may dif ferent time scope entered 
respect bit binding times variable bits bound exec block including sign variants 
seen section mediabench entirely constant exec words subset account bit reads variables 
general account bit reads 
may tempted add language feature define individual bits variables 
level expressivity cumbersome error prone 
second language feature explicit bit widths allow programmer explicitly request narrow width computation 
high level languages data widths quantized certain powers typically bits 
variable needs just extra bit detect overflow width doubled available size 
sections support notion finding nearly half bit reads variables high order regions constant exec exec sign bits 
word data types contained explicit bit widths compiler infer minimum allowable precision bit width computation result bit bit bit bit adder 
alternatively programmer explicitly state bit width primitive operation bit bit done bit adder programmer guarantees values overflow 
explicit operation widths cumbersome programmer highly error prone 
exploitation hardware position constant bits variable possible cases specialization entirely constant words constant high order low order bits constant bits random positions 
specialization may considered cases regardless actual binding time bits 
bit binding times determine specialization take place 
computation constant word operands exec block bits folded entirety 
possible kind hardware im plementation microprocessor custom logic 
word operands constant custom hardware implementation specialized partial evaluation constant coefficient multiplier constant times dynamic 
computation operands constant high order low order bits may merit narrow data path implementation 
appropriate custom hard ware implementation data path arbitrary width may synthesized 
may possible microprocessor narrower alu operation available advantage lower power 
interesting narrow alu operations simd vector units associated multimedia instruction sets vis mmx altivec 
brooks martonosi describe approach automatically pack operations constant high order bits parallel slots simd vector instruction 
computation operands constant bits random locations specialized custom hardware logic optimizations bit level con stant propagation folding 
result minor area savings may fact adverse effect regularity data struc ture 
probabilistic specialization bit binding time information collected profiling necessarily data dependent may universally applicable 
constancy behavior program fact sensitive data specialization data set may appropriate data set 
example narrow computation appropriate data set may overflow data set affect program correctness 
section indicates bit constancy gzip compression program sensitive input file 
general prepared sensitivity ensure program correctness 
specializing profiled information done safeguards 
probabilistically specialize common case detect handle uncommon case 
detecting uncommon case amounts detecting assumptions input bit behavior violated particular special ized data path 
specialization assumes certain input bits constant comparator bits verify value 
narrow data path specialization assumes inputs certain width tors overflow detection verify 
hardware support verification microprocessors rare 
possible mechanism ensure storage location stays constant write protect virtual memory tech niques write detected written value verified 
technique may require placing storage element memory page leading substantial storage overhead 
variety actions taken handle uncommon case input assumption violated 
microprocessor available may possible handle uncommon case software 
true regardless common case implementation software reconfigurable logic custom asic 
appearance uncommon case may provide signal common case implementation specific general implementation subsequent computations 
reconfigurable logic implementation consider reloading slightly specialized configuration handle subsequent computation 
depending relative cost switching uncommon case implementation back may may beneficial return specialized implementation interruption 
online vs offline complementary processes profiling specializing application may done online real time offline 
profiling methodology described far considered offline large memory run time requirements impossible incorporate casual execution program 
online profiling methodology contribute negligible overhead program memory consumption run time 
modifying profiling method ology online version involve foremost implementing memory savings techniques described section 
additional run time sav ings realized profiling part execution 
gprof profiling system profiling interrupts 
coarse solu tion consider profiling snapshots storage interrupts 
alternatively periodically switch program self profiling non profiling modes 
require patching program profiling non profiling versions routine selecting version run jump tables 
continuum specialization approaches exists including online offline combinations thereof 
purely online specialization probably expensive consider requires online recompilation logic synthesis addition online profiling 
purely offline specialization including offline profiling easiest implement 
attractive hybrid approach involve offline generation specialized instances kernel routine online selection particular instance depending constancy behavior detected execution online profiling 
application specializing multipliers precise benefit specialization depends program bit binding time profile particular operations specialized 
different oper ations add multiply admit different mechanisms specialization different cost models specialized area performance 
project uses simplified profiling model intentionally avoids distinguishing particu lar operations 
section considers extensions profiling methodology assessing specializing particular operation integer multiplication 
multiplication simple non trivial operation specialize 
potentially large area benefit specialization narrow width operands spatial bit multiply area nm 
addition multiplication amenable specialization single constant operand constant coefficient multiplier 
decomposition word bit ranges svc model model 
simpler constancy model bit regions section evidence large part bit level waste appears sign bits contiguous regions constant bits high low order bit positions 
suggests binding time model section simplified consider contiguous bit regions individual bits 
shows possible models word analyzed group bit regions 
region labels shown sign extension bits 
high order bits carry value 
represented single sign bit create narrower arithmetic data paths 
variable dynamic bits 
dynamic bits priori known value 
constant static bits 
unchanging bits value known specialized partial evaluation logic 
svc model particularly simple admitting sign bits high bit positions 
model possible extension allow constant bits high bit positions 
possible bit region zero width svc may practice collapse sv range limited zero may collapse cv range limited non zero value 
rest section consider svc model 
see multiplication may specialized svc model consider decomposition component multiplications may specialized run time structures single bit xor controlled arithmetic negation controlled arithmetic negation constant im plemented word selection bit parallel multi plane conventional multiplier constant coefficient multiplier ands adders precomputed constant part multiply specialized area time benefit specialization depends actual widths bit regions minus cost producing specialization 
note svc model incorporate scope binding times 
consider fully dynamic bound definition bound compile execution 
possible identify slowly varying value regardless scope dynamic metrics uses value change equivalent section 
notation adjoining letters represent bit concatenation multiplication 
cation represented 
profiling multiplies multiplies may discovered profiling operands multiply instructions 
instance instruction profiling tively different storage profiling project differences discussed section 
approach implemented mentation suif intermediate form 
objective profiling discover svc profile operands multiply instruction 
done incrementally minimal storage requirements 
operand multiply profiling system main tain value incremental svc profile 
svc profile represented compactly bit positions bit range instance lsb msb integer pair bit mask 
dynamic execution multiply operand profiling system xor operand values discover changes update incremental svc profile widening appropriately 
operand initial profile marked undefined 
operand profile set maximal regions implicitely zero width specialization models practical specialization scheme decide multiplies worth special izing precisely specialize 
simplest model consider specializing multiplier execution compile 
value slowly varying consider dynamically multiplier different values 
possible principle detect specialize slowly varying precision operands varying widths 
requires significantly expensive profiling discussed 
specializing model consider fully dynamic fully static 
values operands particular multiply known priori execution bound compile multiplier specialized offline 
value operand known execution time bound execution multiplier specialized online soon values known 
may early dynamic execution multiply possibly earlier backwards data flow analysis delayed multipliers ready specialization 
specialized multiplier include input comparators ensure operands maintain expected values 
benefit specialization especially online specialization offset cost producing specialization may desirable specialize multipliers 
savings particular multiplier calculated roughly savings original cost specialized cost uses cost specialization uses number dynamic executions multiplier 
precise obtain comparable units cost cost producing specialization typically time microprocessor sav ings multiplier cost complex 
specialized multiplier may time advantages lower latency higher throughput pipelined feed forward computation time measures irrelevant throughput cycle latency largely ignored 
real benefit comes reduc tion multiplier area allows packing parallel hardware better throughput 
heuristic way express area savings time units scale time measure latency area reduction factor idealized savings pretending entire computation consists identical multipliers 
heuristic time savings specialized multiplier tspec uses cost area taken latency orig spec refer original specialized multipliers respectively 
specialization system choose profitable multiply instructions specialize ranking post profiling 
specializing slowly varying values dynamic part multiply operand changes value infrequently ag system may wish dynamically new value 
specialization treats constant converting svc operand sc 
possible necessary operands multiply specialized way 
run time benefit particular multiply depends number dynamic executions uses specialized instance 
heuris tic savings metric described valid applied specialized instance individually 
run time system change operand value total savings specialized multiplier changes tspec uses changes cost computing cost precisely difficult requires remembering bit pattern number uses unique value multiplier bit pattern needed ascertain precise area time cost 
con sider average costs tspec possible values savings formula changes changes changes tspec tspec tspec uses changes cost uses changes cost uses cost computing cost significantly easier requires profiler collect total number changes uses multiplier operand 
specialization system rank multiply instructions savings metric specialize profitable instructions 
cost constant coefficient multiplier depends coefficient value 
svc profile average cost computed possible values 
average cost possible bit patterns tabulated svc value 
alternatively profiler collects values multiplier average cost computed set values 
bibliography michael wolfe 
initial results variable analysis 
proc 
ninth international workshop languages compilers parallel computing pages san jose california august 
william blume rudolf eigenmann 
symbolic range propagation 
proc 
ninth international parallel processing symposium pages santa barbara california april 
viktor prasanna 
dynamic precision manage ment loop computations reconfigurable architectures 
proc 
ieee symposium fpgas custom computing machines fccm pages napa valley california april 
david brooks margaret martonosi 
dynamically exploiting narrow width operands improve processor power performance 
fifth inter national symposium high performance computer architecture hpca orlando florida january 
available www ee 
princeton edu mrm papers hpca pdf 
mihai budiu seth copen goldstein 
detecting exploiting narrow bitwidth computations 
second annual cmu symposium computer systems socs pittsburgh pennsylvania october 
available www cs cmu edu research socs ps gz 
brad calder peter feller alan eustace 
value profiling 
proc 
th international symposium microarchitecture micro pages research triangle park north carolina december 
timothy callahan john hauser john wawrzynek 
garp archi tecture compiler 
ieee computer april 
caspi 
binding time analysis bits 
project report course cs design analysis programming languages spring university california berkeley may 
available www cs berkeley 
edu cs report ps gz 
kenneth david chapman 
fast integer multipliers fit fpgas 
edn may 
charles consel fran ois general approach run time spe application proc 
rd acm sigplan sigact symposium principles programming languages popl pages st petersburg beach florida january 
joseph fisher stefan freudenberger 
predicting conditional branch directions previous runs program 
proc 
fifth international con ference architectural support programming language operating systems asplos pages boston massachusetts october 
virtual memory primitives user programs 
appel kai li 
proc 
fourth international conference architectural support programming language operating systems asplos iv pages april 
gabbay avi mendelson 
program profiling support value prediction 
proc 
th international symposium microarchitecture micro pages research triangle park north carolina de 
david 
hardware description language compiler fpgas 
proc 
ieee symposium fpgas custom computing machines fccm pages los alamitos california april 
maya gokhale 
high level compilation fine grained fpgas 
proc 
ieee symposium fpgas custom computing ma chines fccm pages napa valley california april 
maya gokhale janice stone 
napa compiling hybrid risc fpga architecture 
proc 
ieee symposium fpgas custom computing machines fccm pages napa valley california april 
gong rowe 
parallel mpeg video encoding 
picture coding symposium pcs sacramento california september 
see berkeley edu frame research mpeg 
susan graham peter kessler marshall mckusick 
gprof call graph execution profiler 
acm sigplan notices june 
brian markus mock philipose craig chambers su san eggers 
annotation directed run time specialization proc 
acm sigplan symposium partial evaluation semantics program manipulation pepm pages amsterdam netherlands june 
gunther milne narasimhan 
assessing document relevance run time reconfigurable machines 
proc 
ieee workshop fpgas custom computing machines fccm pages napa valley california april 
gzip home page 
www gzip org 
william harrison 
compiler analysis value ranges variables 
ieee transactions software engineering se may 
john hauser john wawrzynek 
garp mips processor reconfigurable coprocessor 
proc 
ieee symposium fpgas custom computing machines fccm pages napa valley california april 
simon haynes peter cheung 
reconfigurable multiplier array video image processing tasks suitable embedding fpga struc ture 
proc 
ieee symposium fpgas custom computing machines fccm pages napa valley california april 
luke hornof jacques noy :10.1.1.43.8322
accurate binding time analysis ative languages flow context return sensitivity 
proc 
acm sig plan symposium partial evaluation semantics program ma pepm pages amsterdam netherlands june 
jones gomard sestoft 
partial evaluation automatic program generation 
prentice hall international 
ulrik william scherlis 
compilers staging transformations 
proc 
th acm symposium principles programming languages pages st petersburg beach florida january 
leslie kohn guillermo maturana marc tremblay 
visual instruction set vis ultrasparc 
ieee computer society international conference compcon digest pa pers pages san francisco california march 
lee potkonjak william mangione smith 
media bench tool evaluating synthesizing multimedia communica tions systems 
proc 
th international symposium microarchitecture micro pages research triangle park north carolina de 
peter lee mark leone 
optimizing ml run time code genera tion 
proc 
acm sigplan conference programming language design implementation pldi pages philadelphia pennsylvania may 
lipasti john paul shen 
exceeding dataflow limit value prediction 
proc 
th international symposium microarchitecture micro pages paris france december 
lipasti christopher wilkerson john shen 
value lo load value prediction 
proc 
seventh international conference architectural support programming language operating systems asplos vii pages cambridge massachusetts october 
daniel liz peters karl pettis dan 
integer mul division hp precision architecture 
proc 
second ternational conference architectural support programming language operating systems asplos ii pages october 
tony alan marshall igor stansfield jean vuillemin brad hutchings 
reconfigurable arithmetic array multimedia applications 
proc 
international symposium field programmable gate arrays fpga pages monterey california february 
motorola altivec technology programming environments manual november 
available www motorola com sps powerpc manuals ec pem pdf 
alex peleg sam wilkie uri weiser 
intel mmx multimedia pcs 
communications acm january 
perkins 
programming practices analysis ada source developed air force army navy 
conference proceedings ada technology context application development deployment tri ada pages pittsburgh pennsylvania october 
rashid leonard mangione smith 
dynamic circuit genera tion solving specific problem instances boolean satisfiability 
proc 
ieee symposium fpgas custom computing machines fccm pages napa valley california april 
rahul michael smith 
high performance microarchitecture hardware programmable functional units 
proc 
th international symposium microarchitecture micro pages san jose cal november 
jeff reilly 
spec describes spec products benchmarks 
spec newsletter september 
available www spec org osg cpu news cpu descr html 
stephen richardson 
exploiting trivial redundant computation 
proc 
eleventh symposium computer arithmetic pages wind sor ontario june july 
james smith 
predictability data values 
proc 
th international symposium microarchitecture micro pages research triangle park north carolina december 
schilling 
dynamically valued constants lan guage feature 
acm notices april 
michael smith 
extending suif machine dependent optimizations 
proc 
suif compiler workshop pages stanford california january 
stanford university 
kai wang franklin 
highly accurate data value prediction hybrid predictors 
proc 
th international symposium ture micro pages research triangle park north carolina december 
robert wilson robert french christopher wilson saman ama jennifer ann anderson steven tjiang shih wei liao chau wen tseng mary hall monica lam john hennessy 
suif infrastructure research parallelizing optimizing ers 
acm sigplan notices december 
zhong martonosi malik 
accelerating boolean satis configurable hardware 
proc 
ieee symposium fpgas custom computing machines fccm pages napa valley california april 
appendix suif optimizations appendix describes compiler optimizations applied pro gram profiling 
optimizations standard options suif descriptions copied directly man page 
successfully applied optimizations include forward propagation forward prop forward propagates calculation local variables uses variables possible 
idea give informa tion loop bounds array indexing doing dependence analysis loop transformations generally pass doing analysis 
constant propagation const prop simple constant propagation 
dead code elimination dead code simple dead code elimination 
variable privatization variables listed annotation tree 
glob priv code transformations help privatization global variables calls 
looks possible global privatizable notations proc 
annotation expects find list global variables 
changes code new parameter added procedure symbol annotation uses sym bol replaced indirect new parameter callsites location symbol passed 
procedure tran procedure new parameter call ref parameter 
arranges arbitrary call graphs procedures 
result code semantics globals listed annotations referenced directly location passed parameter 
annotations put input code properly allows privatization global variables done globals local 
common subexpression elimination cse simple common sub expression elimination 
hoist loop invariants loop invariants moves calculation loop invariant expres sions outside loop bodies 
loop cond move loop invariant conditionals inside tree loop tree outside outermost loop 
iterate optimizations iterate flag says keep doing specified optimizations long progress 
additional useful optimizations successfully applied due software bugs include constant folding fold folds constants possible 
reduction reduction finds simple instances reduction 
moves sum mation loop 
ivar simple induction variable detection 
replaces uses induction variable loop expressions loop index moves incrementing induction variable outside loop 
appendix compilation sequence table describes sequence steps compiling self profiling appli cation 
steps include preprocessing number suif passes tion subsequent emission recompilation subsequent steps commu intermediate files listed inputs outputs columns 
steps incrementally source file time 
suif transformations notably dup procs instrument process entire file set 
rules entire com sequence programmed makefile included custom makefile application 
command inputs outputs description perl prof prep prepend include prof runtime profiling library header source file scc spd spd suif front preprocess read internal form spd spd suif linker reconcile global symbols internal form spd spd convert static local variables globals dup procs spd spd duplicate procedures call chain disam forward prop const prop dead code glob priv cse loop invariants loop cond iterate spd spd optional compiler optimizations spd spd loops form instrument spd spd instrument profiling spd convert gcc compile object code gcc runtime link executable profiling library prof runtime part suif distribution table sequence steps compiling self profiling application 
