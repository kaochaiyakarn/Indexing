user level infrastructure system call interposition platform intrusion detection con nement jain iowa state university ames ia cs iastate edu sekar state university new york stony brook ny sekar cs sunysb edu new approaches detecting malicious attacks computer systems con ning untrusted malicious applications emerged past years 
techniques rely fact system attacked remote location network damage ultimately system calls processes running target system 
factor lead surge interest developing infrastructures enable secure interception modi cation system calls processes running target system 
known approaches solving problem relied kernel approach interception mechanisms intrusion detection con nement systems implemented operating system kernel 
explore alternative approach uses mechanisms provided variants unix operating system implement system call interposition user level system calls process monitored process 
key problems need solved developing approach providing adequate set capabilities infrastructure portability security enhancements infrastructure different operating systems minimizing performance overheads associated interception wide range applications 
solution satisfactorily addresses issues lead platform rapid development deployment robust intrusion detectors con nement systems application speci security enhancements 
biggest problems faced businesses individuals organizations protection networked computing systems damage due malicious research supported part defense advanced research agency information technology ce darpa ito information system survivability program contract number 
attacks launched remotely internet 
attacks may utilize variety techniques exploit software errors privileged programs gain root privilege exploit vulnerabilities system con guration access con data rely legitimate system user download run legitimate looking trojan horse program icts damage 
intrusion detection refers broad range techniques developed past years protect malicious attacks 
majority techniques take passive approach ine monitoring system user activities identify activities deviate norm indicative attacks :10.1.1.94.6821:10.1.1.17.9158
proactive approaches emerged 
approaches prevent isolate attacks damage caused 
approaches aimed preventing intrusions observation attacks regardless nature attack damage ultimately effected system calls processes running target system 
possible identify prevent damage monitor system call process launch actions preempt damage abort system call change operands open different le speci ed terminate process 
addition preventive approaches system call interception signi cantly enhance power effectiveness ine intrusion detection techniques system audit data 
system audit logs provide information needed intrusion detection 
instance may need know value string read network connection target symbolic link contents le 
may possible identify record potentially useful information audit log approach impractical due excessive overheads involved 
consequently ine techniques bene active system call interception enables access data needed identifying intrusions incurring overhead accessing irrelevant information 
reasons mentioned problem develop ing infrastructures active interception modi cation system calls attracted lot research attention :10.1.1.143.5553:10.1.1.143.5553
modi cation effected user speci ed code fragments referred wrappers extensions interposed system call entry exit points 
research efforts demonstrated extensions enhance application functionality variety ways application speci access control intrusion detection transparent enhancements security data encryption fault tolerance data replication 
important note enhancements obtained system call interposition making changes applications 
presents new approach implementation system call extension infrastructure 
approach characterized user level implementation system calls performed process intercepted possibly modi ed process 
approach contrasts majority approaches area employ kernel implementation system call interposition 
improves providing extensive set capabilities extension code developing architecture implementation easily ported different versions unix operating system presenting comprehensive evaluation performance overheads associated extensions 
describe previous system call interposition summarize main bene ts approach 
previous system call interposition section review prior research system call interposition motivate user level implementations system call interception summarize research problems addressed context 
extended treatment related section 
earlier research efforts system call interposition implemented libraries 
instance system calls accessed wrapper function libc library unix systems 
linking different library contained modi ed versions wrapper functions effect system call interposition 
approach bene easy implement ef cient 
important drawback approach wrapper functions bypassed instance possible program directly invoke system call lower level mechanism execution software interrupt 
approach suitable security related applications intrusion detection con nement 
alternative approach suffer drawback kernel implementation 
particular system call interception implemented operating system kernel extension code processes monitored runs kernel mode 
approach adopted researchers area :10.1.1.143.5553
primary advantages kernel approach low interception overhead 
overheads system call interposition determined entirely extension code 
implementation offers power terms done extension code extensions executed process context process monitored 
power afforded kernel mode operation brings serious drawbacks normal protection mechanisms guard errors process damaging process apply code executed kernel mode 
possible errors extension code process corrupt memory les process worse bring entire system 
extremely careful potential making system secure adding extensions 
state art kernel resident software development lags user level software development signi cantly 
cumbersome error prone write extension code 
addition code kernel level require superuser privileges 
dif cult kernel approach normal users develop deploy extensions 
kernel implementations require kernel modi cations may viewed risky widely accepted 
factors motivated develop user level implementation infrastructure con ning actions helper applications launched web browser mail reader 
speci cally capabilities provided solaris operating system intercept system calls helper application monitored process monitoring process 
typically monitoring process runs privileges monitored process 
due focus helper applications solaris operating system important problems portability expressive power performance user level system call interposition explored 
instance study performance cpu intensive code system calls ghostscript mpeg play 
overheads system call intensive applications network le servers studied 
addition focus application speci access control requires limited capabilities extension code application real time real time low load high load gzip ghostscript tar cp ftpd httpd 
overhead system call interception different applications 
attempt modify system call data return code 
address portability system popular variants unix linux 
consequently comprehensive treatment issues user level implementation system call extension infrastructures remained open 
address problem show fact build powerful ef cient infrastructures user level 
key contributions summarized 
summary results approach implementing system call interposition infrastructure user level 
key issues addressed portability extension code clearly extension different unix variants features unique variants 
approach extensions portable restrict interface provided interposition infrastructure exposes features common unix variants 
approach unnecessarily restrictive 
better alternative permit extensions access system speci features assure extensions operate features common unix variants variants 
tackle problem designing object oriented interface encapsulates os dependencies terms system call names arguments hidden extension code 
approach enables similar system calls different system calls reading le grouped handled way 
varying grouping needed different unix variants possible write extension code modi cations variants 
detailed description approach context section 
portability interception infrastructure modern versions unix operating system solaris linux irix osf provide mechanism user process trace process userid rst process permissions superuser 
user level infrastructure implemented mechanism 
mechanism intended primarily debugging operate way different unix variants posing challenge terms portability infrastructure 
tackle portability problem partitioning infrastructure os architecture dependent component second component independent 
os independent component comprises bulk functionality infrastructure 
uses primitive capabilities provided os component may implemented differently different os processor architectures 
approach making infrastructure portability detailed section 
capabilities extension code operating systems provide ability intercept system calls provide adequate convenient mechanisms accessing modifying system call data 
instance unix variants linux provide way abort system calls need capabilities con ne applications prevent intrusions 
modi cation variable size data strings poses problem new value may occupy space originally available 
obvious approach overwriting data 
malicious applications may attempt modify system call arguments time checked monitoring program time system call executed 
changes possible malicious program multithreaded 
monitoring process monitored process typically run privileges need guard monitored process interfering operation monitoring process attempting kill monitoring process reduce priority 
approach addressing problem described section 
ef ciency compared kernel implementation user level implementation system call interception awake awake kernel post syscall extensions pre syscall open open 
entry processing extensions libc int exit processing syscall processing syscall await syscall await normal 
system call execution sequence process monitored 
incurs additional costs 
additional context switches introduced system call user level implementation 
second operations access modify memory monitored process generally ef cient available kernel implementation 
obtain acceptable performance adopt techniques 
employ fastest mechanism available os implementing memory access operations 
second selective interception capability selected subset system calls intercepted minimize context switches os provide capability 
lazy dereferencing accesses monitored process memory operations access system call arguments deferred values really needed 
techniques able obtain performance user level system call interception described 
performance analysis applications intrusion detection con nement overhead due context switch typically range time needed execute thousands instructions far outweighs overhead memory access operations executing extension code 
see section details 
performance analysis section focuses primarily overhead due interception leaving overheads due execution extension code 
measuring overhead due extension code execution useful comparison kernel versus user level implementation system call interposition 
summarizes performance results mhz pentium ii pc running redhat linux 
table shows overhead terms increase perceived execution time known real time 
measuring real time light load corresponded instance process case gzip ghostscript tar cp throughput mb httpd ftpd 
high load corresponds instances processes gzip ghostscript tar cp mb throughput servers 
results show cpu disk intensive applications overheads due system call interception small 
servers overhead moderate high loads believe overheads worth increase security obtained system call interposition 
note approach tackling rst issues largely applicable kernel implementations 
system overview versions unix provide mechanism process trace control execution process access memory system call ptrace 
primary mechanism implementing debuggers 
unix variants linux provide enhancement mechanism enable process trace system calls 
system release svr compatible versions unix support powerful convenient mechanism system call interception proc interface 
sequence actions involved system call tracing shown 
user process invokes sys runtime system supervisor objects supervisor interface os architecture dependent functions monitoring process kernel file mapping arch os independent functions 
components system tem call open refers entry point libc 
setting arguments system call number appropriate registers code transfers control kernel processor trap software interrupt int linux 
kernel mode entry processing code wakes monitoring process examine modify registers memory processing desired transfers control back kernel actual system call functionality performed 
exiting system call control transferred back additional actions examination modi cation system call return parameters return code may performed 
control returned back order trace effective userid root effective userid primary bene ts user level interception approach monitoring process need privileges superuser 
means ordinary users develop system call extensions ways choose 
equally important potential damage caused monitoring process caused monitored process 
note case kernel implementation interposition faulty extension code cause damage damage caused root owned process 
system call interception extension infrastructure built top system call tracing facilities provided different unix variants 
architecture system shown 
instance infrastructure resides single user process call monitoring process 
single process may monitor control behavior processes 
actual code monitoring process resides supervisor object implementation object 
monitoring processes running system monitoring processes 
monitoring processes number distinct users processes running system 
supervisor classes derived base class 
communication runtime system supervisor object happens method invocations interface 
supervisor classes dynamically loaded monitoring process new processes identi ed monitoring 
mapping le maps fully quali ed executable name shared library containing code supervisor class 
provides static mechanism identify supervisor class monitor process 
second dynamic mechanism provides parent process determine supervisor object monitoring child 
supervisor objects reside top runtime support infrastructure consists parts 
lower part runtime system consists code largely speci different operating systems architectures 
differences arise due differences system call interception mechanisms variations ptrace proc interface interfaces typically provide capabilities needed modifying behavior system calls 
implementation access registers architecture speci aspects system 
rest runtime system consists code os architecture speci functions 
code remains different architectures operating systems minor variations due fact system call names arguments vary slightly different unix variants 
supervisor interface supervisor interface designed supervisor classes written having intimate knowledge 
system call interception performed 
internal codes identify different system calls 
architecture os speci ways access system call arguments return value 
os speci mechanisms read modify monitored process data addition interface provide 
support functions control execution monitored process 
abstraction mechanisms writing supervisor class having hard code system call names argument types speci variants unix rst step de ne base class called supervisor classes derived 
system call methods interface corresponding entry exit system call 
instance corresponding read system call methods de ned void read entry integer fd buf integer count void read exit integer fd buf integer count integer rv monitored process enters exits system call say read runtime system identi es supervisor object sp monitoring invokes corresponding entry exit read entry read exit method 
approach addresses issues mentioned 
address issue system call arguments return value passed explicitly arguments entry exit methods 
issue addressed encapsulating value system call argument object 
frees supervisor object having deal details layouts system call arguments data particular os architecture mechanisms read memory monitored process 
relies methods provided objects conveniently examine modify elds system call arguments 
encapsulation system call arguments class objects enables lazy dereferencing arguments 
instance integer object constructed eld recording register argument located 
value register needed supervisor method invoke get operation point register contents fetched 
shown section lazy dereferencing enhance system performance operating systems 
illustrate system call argument classes give example class class int get char buf int len int put char buf int len int ensure value modified thread monitored process syscall completion get put obvious meanings 
understand operation note system call argument region memory shared multiple threads processes may possible threads processes making system call modify contents referenced pointer argument time examined supervisor time fetched kernel system call executed 
method indicate runtime system happen 
implementations system call argument classes provided runtime system described section 
issue addressed de ning symmetric interface called de nes support functions kill sends speci ed signal monitored process 
abort invoked method invoked system call entry prevents system call completing 
argument abort specify value return code set returning control calling program 
switch action replaces current supervisor object new object belonging class speci ed argument 
ability dynamically change supervisor object particularly useful suspect know fact monitored process misbehaving wish monitor process closely better con ne actions 
switch capability useful implement sophisticated policies regarding supervisor object monitor process execve program 
approach far addressed issue requires supervisor class support methods names exactly match system call names particular version operating system 
overcome problem developed higher level language provides abstraction groups related system calls abstracted higher level event 
abstraction mechanism features behavioral speci cation language intrusion detection prevention described 
basic form event de nition jcond jj 
jj shorthand denote list arguments denote system call event 
cyclic de nitions permitted 
cond provides binding variables terms values variables additionally cond may consist conditions variables condition expression syntax similar 
event denotes operations read le le descriptor operand de ned follows linux integer fd read fd readdir fd fd fd denotes argument value interest de ning event 
event may de ned differently osf integer fd read fd fd fd fd prede ned collections events speci ed interface de nitions serve purpose similar os speci header les 
supervisor class de ned operating system independent fashion providing method events interface de nition 
compiler interface de nitions responsible arranging call code corresponding event called corresponding condition satis ed 
code invoked parameter bindings condition 
effect compiler generates stub routine system call turn ends calling operation supervisor class name corresponding event note uses related approach making wrappers portable 
interface de nition les similar characterization les 
notion tagging system calls tags way similar event names 
advantage approach event abstractions composed tagging 
multiple events match system call invoked order 
undesirable interactions may arise due interference actions different events area current research 
example supervisor class provide example supervisor class illustrate api described far 
describe simple class restricts monitored process performing damaging system calls restricts les opened application 
de ning events interest fork execve connect bind listen chmod chown kill ptrace sendto mkdir rename 
disallowed calls omitted open md md creat truncate omitted trailing arguments system calls de nition conciseness 
de ning events provide implementation just methods 
system call match event de nitions default treatment system calls continue 
runtime include certain protection mechanisms ensure monitored process system calls kill monitoring process 
implementations methods may follows void entry abort void char fv get may want fv tmp exists fv abort code uses support functions determine le opened write inside tmp directory creating new le modifying existing 
runtime system monitoring process started name executable monitored 
optionally name supervisor class monitoring executable name le containing object code class may speci ed 
appropriate supervisor class identi ed mapping le 
monitoring process loads supervisor class forks uses attach primitive provided os speci module attach child process 
child process exec executable process set exist processes monitored pid wait monitored process enter exit sys call call pid call pre entry processing details omitted switch call get system call identifier case open entry id open entry open entry open entry open entry break cases system calls shown post entry processing omitted call pre exit processing omitted switch call get system call identifier case open exit id open exit open exit open exit open exit open exit break cases system calls shown post exit processing omitted call signal related processing omitted 
main loop runtime system monitored object speci ed supervisor class 
runtime system monitoring processes executing loop shown 
functions provided architecture os speci component runtime system 
component includes de nition array speci es registers offsets kernel maintained user structure monitored process contain system call arguments 
system call argument class objects integer constructed register numbers 
step happens implicitly type conversion rules 
runtime looks association table identify supervisor object corresponding process system call corresponding entry exit method invoked class 
return call monitoring process goes back 
action runtime system system call entry exit operations similar open operations require special treatment fork runtime system needs identify pid child process ready monitor 
supervisor object cloned copy monitoring parent process monitoring child 
execve special processing required part runtime system 
current supervisor object requires new process monitored different supervisor object explicitly invokes switch operation execve entry method appropriate shared library name class name new supervisor class 
alternatively switch operation may specify mapping le looked determine supervisor executable name 
switching new object done part processing 
kill runtime system typically runs userid process monitored careful ensure monitored process kill monitoring process damage ability monitor 
ensured intercepting potentially dangerous system call kill permitting go affect monitoring processes 
similar applies system calls interfere monitoring process 
exit completion entry function supervisor object monitored process destroyed runtime system 
implementation system call argument classes runtime system provides implementation system call argument classes 
implementations independent os machine architecture functions provided architecture speci module 
implementation classes routine way deal modi cations memory referenced pointer arguments discuss 
instance argument modify done place new name smaller old 
need allocate new storage change system call argument value point new location 
catch new location address space monitored process dif cult identify unused sections memory monitoring process 
approach allocate new storage stack top stack 
nd normally allowable stack size larger mbs value stack pointer space 
regardless new value requires storage space old value may choose store new value random location stack 
motivation follows 
window time assignment new value system call argument time arguments fetched user memory system call execution kernel 
multithreaded environment threads system call tries locate modify system call argument back original value 
worse rst thread may provide valid looking argument le name permitted supervisor object second thread changes le name unacceptable value 
putting modi ed value random location stack implies rogue thread search entire stack identify value stored 
suf cient stack space say mb may take millions instructions complete 
compared time window exploited probably smaller say instructions 
implies probability rogue thread succeeding effort small rogue program may try circumvent approach leaving little room stack runtime system may store arguments 
typical programs execute mbs available stack space times may simply terminate process cient stack space say mb detected 
race condition respect checking system call parameter values stored user memory rst addressed :10.1.1.143.5553:10.1.1.143.5553
identi ed ability deal race conditions reliably bene ts implementation 
similar guarantee probably provided user level implementation believe approaches exploit sort randomization reduce success probability race attacks negligible value 
noted successful attacks go undetected absence kernel support 
architecture dependent primitives module contains lowest level functions implementations vary signi cantly different operating systems processor architectures 
functions provided module include get system call number signal received monitored process os independent value identify intercepted system call entry exit signal 
module needs identify register numbers system call arguments stored 
get set values registers 
note register numbers necessarily correspond processor hardware registers 
simply handles created module refer location user structure process control block read modi ed architecture dependent module 
getdata read modify memory monitored process 
implementation different ptrace svr oses 
ptrace interface reading writing bulk data cient employ os architecture speci enhancements capabilities mem facility linux permits ef cient reads writes 
implementations operations different ptrace proc interfaces 
abort svr compatible unix versions provide special operation aborting system calls 
needed develop way modify return code value chosen supervisor object provided monitored program default value svr indicates error testcase normal time overhead execution spent time extension ftpd httpd 
system call interposition overhead 
system call interrupted 
ptrace implementation linux provides way abort system calls 
approach modify system call argument value cause call fail 
intercept system call exit set return values parameters appropriate 
identifying argument values cause system calls fail fairly simple cases null pointer value le names 
calls take arguments approach fails 
fortunately system calls change system state harm letting complete plus modify return values permitted executed superuser owned processes setup idle linux 
notable exceptions fork exit 
fork approach kill child completes rst system call 
exit arguable merit aborting simply complete 
application intrusion detection con nement built system intrusion detection application con nement application speci access control system call interposition 
approach specifying security relevant properties programs patterns sequences system calls executed processes 
speci cation language enables capture conditions system call names arguments 
response actions associated security property responses triggered property violated 
actions may variety purposes disallowing violating system call modifying argument different resource speci ed system call manipulated terminate process 
compiler language translates speci cations code supervisor object 
code compiled compiler linked system call interposition infrastructure provide intrusion detection con nement 
results shown obtained runtime system uses kernel system call interposition 
overhead measurements relating system call interception data access extrapolated userlevel interposition approach 
results establish approach achieving portability system call extensions interface system call argument classes implemented way runtime systems effective 
show overhead due execution extension code small fact negligible compared overheads system call interception argument access 
consequently user level approach performance applications intrusion detection con nement access control measured purely terms overheads system call interception data access 
precisely analyze performance section 
results shown taken mhz pentium ii linux pc mb memory gb eide disk 
include time spent extension code 
sample speci cation ftpd server 
speci cation consists approximately properties restrict operations ftp server accesses certain les user login certain les user login executes certain les performs host user authentication allows connections back ftp client arbitrary hosts privileged system calls system calls binding privileged tcp port enforces additional restrictions certain users anonymous users super user 
speci cations httpd similar 
performance results primary goal performance experiments assess impact additional overheads introduced user level system call interposition compared kernel interposition 
mentioned earlier time spent inside extension code remains approaches additional overheads incurred userlevel approach due context switches relatively cient operations access memory monitored process 
experiments designed null extension bodies extensions simply access possibly modify system call arguments 
kernel implementations overheads due extensions negligible compared overheads user level implementation 
measuring overhead due execution extension code serve measure computationally intensive tasks performed extension code 
measurements useful determining suitability system call interposition accomplishing particular task 
prior research results summarized previous section provide adequate evi application cpu time real time real time low load high load gzip ghostscript tar cp ftpd httpd 
overhead system call interception different applications 
dence ef ciency effectiveness system call interposition approach applications intrusion detection con nement access control 
measuring execution time extension code way help assess performance infrastructure developed 
reason focus simple extensions performance study 
results section obtained linux running mhz pentium ii mb memory gb eide disk obtained irix running sgi mhz mb gb scsi osf running dec alpha mhz gb memory 
measurements pertain irix osf indicate explicitly measurements pertain linux 
overhead system call interception performance analysis consider categories applications monitor cpu intensive disk intensive network intensive applications 
overhead measured terms increase cpu time formula cpu time monitored app monitoring process cpu time app cpu time taken sum times spent user system mode system behalf process 
measure perceived degradation performance computed real time called elapsed time cpu time 
perceived degradation shown lightly loaded heavily loaded conditions table 
table lightly loaded conditions refer single instance running application gzip ghostscript tar cp delivered throughput mb ftpd httpd 
heavy load corresponds running instances application gzip ghostscript tar cp delivered throughput mb higher ftpd httpd 
graph shows increase cpu time function number system calls different applications 
expect overhead mainly overhead seconds number system calls gzip gs tar cp ftp 
increase overhead increase number system calls 
due context switches cost independent cost system call 
expect linear relationship overhead number system calls 
graph shows overhead microseconds system call points concentrated microseconds 
variation result time measurement errors get ampli ed difference cpu times monitoring 
process monitored need additional processes monitoring turn lead poorer virtual memory cache performance 
impact hard predict may vary application application 
cpu intensive applications category meant represent typical cpu intensive applications frequently 
users typically sensitive additional overheads applications running time long perceived 
consider gzip ghostscript category 
gzip system calls ghostscript moderate number due socket related operations needed displaying windows 
overhead results con rm results svr compatible operating systems irix establishing similar overheads hold linux implementation uses ptrace facility 
disk intensive applications category studied tar cp recursive copy directories 
category applications tends large number system calls 
main overhead due context switching system call higher overheads expected programs 
due large amount operations mbits sec number clients normal monitoring 
ftp server throughput disk elapsed time larger cpu time perceived increase overhead typically small applications 
due opportunities multiplexing perceived overhead increases multiple concurrent instances applications run 
network servers network servers ftpd httpd important applications need increased security offered system call monitoring 
consequently performance analysis applications comprehensive 
measuring just increase cpu time due system call interception experiments geared evaluating degradation throughput latency experienced clients services 
test suite ftpd consisted les sizes uniformly distributed range mb 
ran server client different machines 
ensured requested les memory le cache server effect disk access completely eliminated tests 
shows throughput varies function number clients 
graph shows throughput limited network bandwidth curve mb probably close best achieved mb ethernet protocol overheads considered 
cpu utilization remains fairly low point overheads monitoring affect throughput throughput monitoring coincides throughput monitoring 
simulate happens higher cpu loads faster networks ran client server machine 
speci ed local le name client dev null eliminate effect disk access 
case throughput limited cpu usage signi cant degradation mbits sec number clients normal monitoring 
server throughput put 
figures shows throughput results httpd 
tests performed webstone widely benchmarks web server performance 
webstone standard included benchmark 
client machines server machine 
tested starting clients going clients increments 
time run set minutes took iterations 
server httpd run monitoring 
webstone provided results throughput response times 
client server run different machines throughput saturates mb monitoring performed 
number lower ftpd re ecting higher overhead due protocol due different distribution le sizes 
saturation point cpu utilization suf ciently high result measurable drop throughput 
experiments performed client server machine overhead pronounced 
webstone provides response times httpd shown 
response times meaningful ftpd experiments large le sizes meant time receive le completely due time transferring les 
latency milliseconds number clients normal monitoring 
response time 
operating intercept access arguments access follow pointers system read read read read write irix linux 
overhead reading writing system call arguments 
operating overhead system linux irix osf 
interception overhead irix osf linux 
interception overheads unix variants table shows overheads system call interception variants system release compatible operating systems irix osf 
show average overheads applications shown previous tables 
operating systems provide ner granularity control system calls monitored 
capability ignored uninteresting system calls read write 
addition system calls intercepted entry exit 
overheads interception conditions shown table compared times obtained linux 
linux permit selective monitoring subset system calls factor necessarily translate higher overhead monitoring 
overhead fetching arguments table shows overheads accessing modifying system call arguments 
overhead shown average taken ghostscript tar ftpd 
linux accessing system call argument requires single system call monitoring process modest overhead getting values 
irix system calls need access arguments additional overhead 
follow pointer arguments access monitored process memory additional overheads 
cases interested accessing arguments strings relatively small size le names overhead increase small 
follow pointer arguments reading buffers le read write operations leads substantial overhead 
case linux ef cient way perform bulk reads mem le proc directory 
writing bulk data cient requires ptrace system call bytes data written 
overheads modifying arguments shoots dramatically 
problem apply irix provides ef cient bulk read write operations 
overhead high follow pointer arguments implies system call entries exits including read write intercepted 
conclude overheads low limit accesses arguments le names 
intrusion detection access control con nement applications require accesses kind data performance degradation introduced applications low 
extensive access data may needed applications transparent data encryption le replication 
user level interception introduces signi cant overheads applications 
discussion runtime system described real time monitoring application absence source code need changing recompiling system software 
monitoring program resides separate address space essentially 
having user level approach provides ability selectively monitor certain system calls monitor call controlling granularity control 
features reasonable performance overhead give system power add enforce variety security policies discuss possible applications system policy auditing simplest form system record information system calls signals log le archival purposes source information investigate attacks 
information recorded include system call arguments system state related information customized process basis 
intrusion detection described earlier majority intrusion detection techniques system call information perform task 
system call enable obtain additional information may available audit logs improve ability detect attacks 
ability modify abort system calls enable intrusion detectors take proactive role prevent attacks succeeding 
access control fine grained access control users applications easily implemented infrastructure 
user level approach distinct advantage users deploy experiment new access control policies help system administrators 
con ning uncooperative malicious applications interception extension mechanisms bypassed con ne uncooperative applications 
factor mechanisms provide aborting system calls modifying arguments locking argument values changed intention exploiting race conditions give ability con ne malicious applications 
ability dynamically change supervisor object con nement policy provides increased exibility con ning malicious applications 
applications system call interposition applications transparent encryption data replication system support applications performance overhead higher 
ef cient implementations shared wrapper libraries offer better alternative 
drawbacks advantages kernel approach extension code perform operations context monitored program 
user level approach perform operations context monitoring process distinct monitoring process 
instance operations changing userid le system root monitored process possible approach 
possible constrain monitored process les accessible new userid new le system root 
user level implementation os kernel treats monitoring monitored processes really monitoring process defend malicious monitored process 
number ways monitored process try monitored program 
may thought completely implementor runtime system 
holes armor resulting due oversight exploited malicious program escape 
kernel implementations harder circumvent 
downside errors kernel implementations cause signi cantly damage errors extension code executing user level 
implementation adds moderate overheads monitoring overhead higher kernel implementations 
silver lining applications user sensitive performance programs overhead interception mechanisms noticeable 
approach implemented top interfaces provided operating system features intended debugging 
limitations mechanisms directly impact infrastructure 
instance current implementation ptrace mechanism linux race condition regarding fork system call 
particular child process inherit tracing ag run free monitoring process attaches 
window time ability monitor con ne child process 
appears race condition arises multiprocessor architectures 
problem arise svr compatible systems provide mechanisms enable monitoring program arrange tracing ags inherited fork 
appears possible develop dynamic modi cation code text segment better modifying instruction pointer point back specially constructed sequence instructions stack 
best solution eliminate bug os implementation 
assumptions approach policy incorporated supervisor code cause damage modify capabilities monitored process undesirable ways 
upside scope damage arise due errors minimized appropriate high level language specifying supervisor functionality having supervisors run user level 
related lot research done improving access control techniques available operating system unix 
works focussed improving lesystem protection model unix 
implementation approach modifying operating system kernel provide enhanced protection model operate process user level 
develops powerful exible access control method called domain type enforcement 
system administrators specify ne grained mandatory access controls interaction pro cesses objects accessed 
closely related implementation intercepting checking system calls os kernel 
research efforts developed interception techniques implemented libraries 
approach leads low overheads easily bypassed code directly invokes system call library appropriate intrusion detection con nement applications 
interception system calls kernel coupled ability add extension code executed point proposed researchers :10.1.1.143.5553
approaches similar techniques system call interception overwrite system call table kernel linux freebsd point modules route system calls extensions prior execution normal system call functionality 
kernel approaches generally exibility power terms actions performed extension code 
comprehensive set capabilities extending operating system functionality proposed :10.1.1.143.5553:10.1.1.143.5553
allow extensions operate user mode run top kernel level primitives developed opposed making features commodity operating systems 
deals issues addressed works mentioned handling race conditions arise malicious multithreaded program attempts change argument system call time checked extension code time argument system call 
dif cult provide absolute protection attacks approach technique copying arguments random location stack stack pointer provides solution 
dif cult malicious thread search entire stack usually mb size identify location monitoring program may copied arguments 
key distinction approach works aim user level implementation system call interception infrastructure similar 
system aimed con ning helper applications launched web browsers restrict system calls 
due focus sand boxing helper applications system provides abilities allow deny particular system call 
modifying system call arguments data referenced changes system call return code considered 
solaris address linux main interest issues portability unix variants 
languages proposed simplify writing system call extensions 
approaches simple high level language 
approaches geared maximize capabilities programmed extensions superset language writing extensions 
approaches strive balance expressive power robustness extensions ease writing extensions geared speci purpose intrusion detection prevention 
new approach developing user level infrastructure system call interception extension 
addresses important issues addressed previous research 
user level implementation offers similar level security comparable level capabilities kernel implementations system call extensions 
achieved main drawbacks kernel approach normal users develop deploy extensions damage due errors extension code limited bring entire system 
result infrastructure develop extensions accomplish variety tasks custom auditing logging access control intrusion detection con nement uncooperative malicious applications 
applications fault tolerance encryption possible performance degradation signi cant applications 
important distinction research developed techniques infrastructure portable versions unix 
importantly extension code easily ported 
techniques applied implementations extension infrastructures 
comprehensive analysis performance impact due user level interception system calls 
overheads moderate worst case imperceptible typical conditions 
performance point view believe results establish practicality user level monitoring system calls way improve system security 
performance analysis discussion section indicate approach suited applications intrusion detection access control con nement applications 
due limitations os provided mechanisms user level interception system calls techniques currently better suited con ning uncooperative applications malicious ones 
suited applications transparent data encryption le replication require extensive accesses memory monitored process 
anderson lunt javitz valdes generation intrusion detection expert system nides summary sri csl sri international 
berman selberg le protection unix operating system usenix winter technical conference 
bishop checking race conditions file access 
computing systems pp 

bowen operating system support security personal communication 
cheswick evening cracker studied winter usenix conference 
fred cohen associates deception toolkit home page www net html 
engler kaashoek jr toole exokernel operating system architecture application level resource management th acm symposium operating systems principles december 
fernandez allen extending unix protection model access control lists usenix summer conference 
fraser badger feldman hardening cots software generic software wrappers symposium security privacy 
forrest hofmeyr somayaji computer immunology comm 
acm 
petrou rodrigues anderson slic extensibility system commodity operating systems usenix annual technical conference :10.1.1.143.5553:10.1.1.143.5553
ghosh schatz learning program behavior pro les intrusion detection st usenix workshop intrusion detection network monitoring 
goldberg wagner thomas brewer secure environment untrusted helper applications usenix security symposium 
ilgun kemmerer porras state transition analysis rule intrusion detection approach ieee transactions software engineering march 
jones interposition agents transparently interposing user code system interface th acm symposium operating systems principles december krishnamurthy cola customized overlaying usenix winter conference january 
ko levitt execution monitoring security critical programs distributed systems speci cation approach ieee symposium security privacy 
kumar spafford pattern matching model intrusion detection nat computer security conference 
lai gray strengthening discretionary access controls inhibit trojan horses computer viruses usenix summer conference 
lu brien kernel secure applications annual computer security application conference december 
lunt real time intrusion detection expert system ides final report sri csl sri international 
porras kemmerer penetration state transition analysis rule intrusion detection approach eighth annual computer security applications conference 
russinovich segall fault tolerance theshelf applications hardware proceedings th international symposium fault tolerant computing sekar guang verma highperformance network intrusion detection system acm computer communication security conference 
sekar synthesizing fast intrusion prevention detection systems high level speci cations appear usenix security symposium 
sekar bowen segal preventing intrusions process behavior monitoring usenix intrusion detection workshop 
wahbe lucco anderson graham ef cient software fault isolation th acm symposium operating systems principles december 
con ning root programs domain type enforcement walker badger usenix unix security symposium july 

