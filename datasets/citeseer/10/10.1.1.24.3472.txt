ueda march ueda doctor engineering march copyright ueda thesis introduces programming language guarded horn clauses abbreviated ghc 
guarded horn clauses born examination existing logic programming languages logic programming general special attention paid parallelism 
main feature ghc extreme simplicity compared parallel programming languages 
ghc restriction resolution theorem prover horn clause sentences 
restriction aspects restriction data ow caused uni cation choice nondeterminism 
essential general purpose language provides ghc synchronization primitive 
required intended applications include system interacting outside world 
characteristic ghc restrictions imposed semantics sole additional syntactic construct guard 
guarded horn clauses classi ed family logic programming languages close relationship formalisms including data ow languages communicating sequential processes functional languages multiprocessing 
lack higher order facilities ghc viewed generalization frameworks 
simplicity generality ghc suitable standard parallel logic programming languages parallel programming languages 
simple regarded computation model programming language 
attention paid possibility ecient implementation design stage ghc 
showed stream merging distribution expected heavily implemented time complexity communication procedural languages 
furthermore available ecient compiler implementation subset ghc top prolog 
ghc lost completeness theorem prover deliberately result compromise 
ecient implementation exhaustive solution search horn clause programs 
showed automatically compile horn clause program exhaustive search ghc program 
ii acknowledgments author express deepest gratitude supervisor wada continuous 
judging committee members inoue masaru kitsuregawa valuable suggestions 
author joined logic programming community research nakashima satoru university tokyo 
motivation thesis goes back unsolved problems research 
intensive discussions colleagues author valuable learning programming programming languages 
addition author learned methodology reviewing programming languages detailed examination preliminary ada language members tokyo study group 
author joined nec started members icot institute new generation computer technology 
katoh yamamoto furukawa provided stimulating place gave continuous 
content thesis greatly bene ted reinforced daily discussions takeuchi miyazaki tanaka furukawa takashi chikayama icot members discussions members icot working groups kl kernel language version task group 
discussions researchers feeling uneasy parallel logic programming advocating helpful 
thesis set installed takagi 
discussions visiting researchers icot world stimulating useful 
particular ehud shapiro keith clark steve gregory gave invaluable suggestions design programming languages 
thesis bene ted discussions foreign researchers electric hard mails 
martin nilsson saito kaneko helpful comments earlier version thesis 
research done part activities fifth generation computer systems project japan 
author parents wife devoted support 
iii contents chapter 

motivation 

objectives 

contributions 

structure thesis 
chapter logic programming 

basic concepts logic programming 

syntax logic programs 

substitution uni cation 

procedural semantics 

declarative semantics 

advantages logic programming framework 

closer look logic programming general programming language 
virtue logical 

completeness multiple uses predicate 

result execution logic program 

extralogical features prolog 

cut symbol 

input output 

primitives modifying internal database 

time dependent operations 

sequentiality backtracking control structure 

call negation failure 

examining constructing non variable terms 

meta level nature result computation 

summary 
chapter parallel logic programming 

parallelism logic programming 

parallel execution logic programs 

parallelism parallelism 

correctness parallel execution 

restricting controlling parallelism 

previous works parallel logic programming 

parallelism 

parallelism 

examination concurrent prolog 

motivation method 

de nition concurrent prolog 
iv 
syntax 

semantics 

parallel programming concurrent prolog 

multiple environments commitment operation 

alternative permission 

second alternative permission eternal 

access local global information 

atomic operations uni cation 

smallest granularity alternative 

alternatives 

processing heads guards 

head uni cation 

head uni cation guard execution 

uni cation read variables 

predicate 

summary 
chapter guarded horn clauses 

principle oriented approach language design 

design principles 

syntax 

semantics 

important properties 

program examples 

binary merge 

generating primes 

generating primes demand driven computation 

bounded bu er stream communication 

meta interpreter ghc 

primitive operations ghc 

resolution 

uni cation anti substitutability 

commitment 

process interpretation ghc 

justi cation language design 

possible extensions 

implementation synchronization mechanism 

summary works 
chapter comparison ghc programming languages models 

concurrent prolog 

parlog 



oc 

communicating sequential processes csp 

sequential prolog 

delta prolog 

computational models 

data ow computation 

actor model 

process network model kahn 

functional applicative programming 

object oriented languages 
chapter implementation parallel logic programming languages 

stream array processing 



importance streams ghc languages 

necessity dynamic multiway stream merging distribution 
related works 

objectives 

outline sequential implementation ghc 

implementation merge predicate 

examination ary 

implementation technique fixed arity merge 

con guration process descriptor 

operations 

management suspend fail table 

properties fixed arity merge 

space eciency 

time eciency 

order clause checking 

program size 

base case 

dynamic change number input streams 

implementation distribute predicate 

distribution fixed number output streams 

dynamic change number output streams 

applying implementation technique distribution predicates mutable arrays 

summary 

concurrent prolog compiler ghc compiler top prolog 


linguistic non linguistic features 

compilation technique 
vi 
scheduling 

uni cation 

performance 

history possible extensions 

summary 
chapter exhaustive search ghc 

motivations 

outlines method 

previous research 

simple example 

general transformation procedure 

class programs 

performance evaluation 

summary works 
chapter works 

contributions implications 

applications ghc 

works 

formal semantics 

user language 

programming system metalevel facilities 

implementation 

theoretical issues parallel computation 

vii chapter 
motivation logic attracted attention programming language 
rst logic programming language prolog horn clause logic quite successful important logic programming language practice 
implementation technique prolog studied systems developed computers 
important prolog considered approximation ultimate logic programming language wemust continue search better approximations 
actual prolog systems extralogical concepts sequential control cut operator database update input output side ects system predicates sensitive current instantiation variable 
extralogical facilities introduced necessary useful 
examine truly essential introduced framework logic programming cleaner way 
extralogical concepts problem sequential control closely related performance execution 
researchers attempts design logic programming languages parallel execution 
relational language successor parlog clark gregory concurrent prolog shapiro contributed practice parallel logic programming showing non trivial program examples 
proposed parallel logic programming languages developed purpose alleviating restriction sequential control go far exclude inessential sequentiality 
interesting concurrency exploit conceptually practically design language extending semantics prolog special proof procedure suited sequential execution restricting general proof procedures horn clauses 
thesis mainly motivated interest 
solution lie far parlog concurrent prolog judged thorough examination languages useful designing new language 
languages de ned informally examination method similar employed part preliminary version ada thoroughly examined ueda 
motivation research desire promote practical aspects parallel logic programming founded clark gregory shapiro 
people languages concurrent prolog parlog ecient execution non trivial programs show ecient implementation 
people disliked concurrent prolog abandoned facilities obtain answer substitutions goal thought unique indispensable feature logic programming 
give persuasive answer search problems eciently solved parallel logic programming language dedicated feature exhaustive search 
research implementation applicability programming language important design language features especially prevalence language 

objectives stated previous section main objective examine current practice logic programming logic programming languages propose better alternative existing languages 
stick framework theorem proving set horn clauses may framework logic programming 
framework best studied put practice extensively proposal great uence logic programming community 
language propose called guarded horn clauses appearance guarded horn clauses abbreviated ghc sequel 
special interest consideration parallelism 
fact parallelism important design principles ghc 
employing parallelism principle language design justi ed fact formula classical rst order logic expresses sequentiality 
objective justify proposed language ghc practical point view 
crucial matter practical language ecient running implementation 
sequential implementation useful put programming ghc practice 
sequential implementation prototype form interactive system communicates human beings peripheral devices case stream communication ghc enables natural programming side ective prolog 
course satis ed sequential implementation parallel language 
parallel implementation main objectives japanese project began years truly far reaching goal 
best demonstrate show ghc implemented eciently sequential computer show compile ghc program ecient prolog program 
language important factor practicality 
order language accepted people communities wehave practices communities exercised framework 
important practices include communication mutable objects procedural programming exhaustive search logic programming show exercised ghc framework 
remarks helpful clarifying purpose research method taken 
examine logic programming framework general practical programming problem solving 
particularly regard fully controllable input output facilities essential feature general programming language 
regard basic framework primitives language primary importance user oriented facilities secondary 
interested result computation kind computation parentheses grouping entities 
approach formal 
know formality necessary useful aspects programming programming languages 
know informal consideration useful 
items suggest principles language design quite di erent nakashima proposed language prolog kr knowledge representation system 
nakashima interest fundamental concepts emerged arti cial intelligence research dealt logic programming framework main interest extract minimal set concepts truly essential programming language allows parallelism 

contributions contributions research thesis follows examined existing logic programming languages proposed simple general language guarded horn clauses introducing notion data ow restriction logic programming framework 
showed computational model provided ghc uniform general express notions appearing existing computational models 
provided starting point designing specialized ecient languages applications performance exibility 
showed viability ghc practical language conceptual language demonstrating allows ecient implementation sequential computer 
demonstrated exhaustive solution search usual framework logic programming done eciently ghc base language 
method proposes simpler alternative dedicated parallel machine approach 
guarded horn clauses going provide basis kernel language version kl multi sim sequential inference machine pim parallel inference machine developed institute new generation computer technology icot 

structure thesis thesis organized follows 
chapter reviews logic programming original sense provide foundation investigation parallel logic programming 
reviews practice logic programming part deviates basic framework 
review includes examination extralogical features prolog resolved ghc 
chapter introduces parallel logic programming 
giving motivations discusses parallel execution logic programs clari es problems parallelism parallelism 
surveys previous works parallel execution logic programs proposals parallel logic programming languages controlled parallelism 
proposals select concurrent prolog detailed examination points problems resolved ghc 
chapter introduces guarded horn clauses 
rst gives design principles ghc describes syntax semantics 
program examples follow 
discusses primitive operations ghc 
shows elegantly idea process interpretation logic applies ghc 
reviews design ghc justi cation mentions possible extensions language implementation issues 
chapter compares ghc languages computational models related parallel logic programming clari es ghc gives uniform general framework parallel computation 
chapter discusses implementation issues 
firstly reinforces viability ghc process description language showing time complexities communication operations mutable arrays worse procedural languages conventional sequential computers 
describes ecient implementation subset ghc concurrent prolog top prolog 
chapter gives answer applicability ghc search problems 
shows vast class horn clause programs exhaustive solution search compiled ghc runs eciently 
chapter summarizes thesis gives prospect 
chapter logic programming chapter rst review basic concepts logic programming original sense clarify advantages framework comparing framework procedural languages 
consider logic programming framework programming language point view theorem prover point view provide di erent view logic programming 
purpose consideration see viability logic programming languages general language special purpose language 
examine current practice prolog programming di erent programming pure horn clause logic points clarify extralogical notions 
stated earlier restrict scope interest resolution theorem provers set horn clauses thesis logic programming senses considered 

basic concepts logic programming introduce basic framework logic programming founded kowalski van emden kowalski clark apt van emden preceding works automated theorem proving 
similar documents example book lloyd pursue generality exposition state needed thesis self contained 
note section introduces logic programming special simple case theorem proving suitable basic framework programming language 
practical aspects logic programming discussed detail sections 

syntax logic programs de ning syntactic constructs 
classes symbols vary program program variables function symbols predicate symbols predicate symbol called predicate relation semantics question 
thesis variables capital alphabetical letters function predicate symbols small alphabetical letters 
letter denote anonymous variable 
occurrence denotes variable distinct variables occurrences denote distinct variables 
combinations non alphabetical alphabetical symbols function predicate symbols example function symbols predicate symbols thesis 
function predicate symbol arity property value indicating arguments 
function symbol arity called constant symbol 
function predicate symbols may overload function symbol predicate symbol may literally identical function predicate symbols di erent arities may literally identical 
necessary avoid confusion notation function predicate symbol arity 
addition symbols logical connectives punctuation symbols meanings explained appear 
term variable ary function symbol followed terms terms separated commas surrounded parentheses 
term form called principal function symbol called arguments 
term called ground term 
term ground term called non ground term 
non ground term called incomplete data structure contains undetermined parts 
atomic formula called atom isan ary predicate symbol followed terms terms separated commas surrounded parentheses 
expression term atomic formula 
de nite clause called program clause form atoms 
symbol followed quanti ed variable indicates variables appearing free universally quanti ed 
program clause called unit clause understood denoting unit conjunction 
called clause head simply head set called clause body simply body 
called body goal 
goal clause form atoms 
called goal 
goal clause called empty clause understood denoting contradiction 
horn clause simply called clause thesis de nite clause goal clause 
goal appearing horn clause said belong clause 
logic program simply called program thesis conjunction de nite clauses 
logic program called world internal database intended interpretation 
conjunction de nite clauses heads predicate symbol called procedure 
clauses procedure called sibling clauses 
framework rst order predicate logic subset formulae handle limited horn clauses conjunctions 
subset rst order logic called horn clause logic 
interested subset reasons de nite clause allows procedural interpretation analogous procedures conventional languages 
subset sound complete proof procedure respect declarative semantics see section practical ecient compared sound complete proof procedures larger subsets rst order logic 
notational convenience syntactic conventions de nite clause written abbreviated 
goal clause written written 
connective reads implied connective denotes conjunction 
variables occurring clause understood universally quanti ed 
prepare special notations lists write constant nil cons terms 
write structure term balanced respect square brackets 
function predicate symbols operators 
unary function predicate symbol may pre post operator binary function predicate symbol operator 

substitution uni cation give framework assigning values variables program 
substitution mapping set variables set terms 
usually mapping acts identity nitely variables 
write substitutions post operator thesis 
substitution naturally extended mapping set expressions set expressions expression obtained simultaneously replacing occurrences variables mapping 
expression called instance substitution represented set bindings form variable denotes say substitution binds variable term wesay expression variant expression instance instance term 
new variant expression informally de ned variables distinct variables course discussion computation created 
expression said instantiated substitution variant 
special case variable said instantiated substitution binds non variable term 
wesay substitution general substitution substitution expression instance 
say substitution general substitution general vice versa expression variant 
wesay substitution general set substitutions general substitutions 
de ne uni cation 
substitution said unify expressions solve equation identical 
substitution called uni er uni er called general uni er general set uni ers uni cation said bind avariable term general uni er maps 
procedural semantics procedural operational semantics logic program identi ed proof procedure goal clause respect program 
linear resolution selection function de nite clauses see apt van emden proof procedure described strategy consider introduce parallelism chapter 
goal clause proof procedure tries derive empty clause means contradiction clauses program 
successful say original goal clause refuted 
refutation sld resolution 
sld resolution derivation rule rewriting goal clause goal clause rewritten selected atom selection rule employed 
nd new variant program clause 

uni able general uni er rewrite goal clause 
call rewriting derivation step step inference 
sld resolution kind linear input resolution chang lee 
note may program clause derivation step 
proof procedure called linear uses latest goal clause behavior proof procedure may linear involves searching nd refutation 
conceive possibly nite search tree called derivation tree root corresponds original goal clause nodes root correspond goal clauses rewritten derivation steps arcs correspond program clauses deriving goal clauses corresponding son nodes goal clauses corresponding parent clauses selection rule atoms 
addition goal clause arc general uni er obtained derivation step represents 
path root empty clause expresses refutation 
refutation path substitutions appear order call composition answer substitution refutation 
logic programming usually consider answer substitutions result computation point re examined section 
say task proof procedure nd refutation paths derivation tree obtain corresponding answer substitutions 
note paths derivation tree lead empty clause may nite may non empty clause allows derivation 
search strategies selection rules atoms proof procedure take nd refutation 
depth rst proof procedure uses strategy goal clause derived deriving new goal clause possible 
proof procedure said fair nds refutation paths nite time 
wemust note formalism theorem proving gives little consideration parallel execution literature theorem proving 
discuss chapter kind parallelism exploit formalism 

declarative semantics section gave proof procedure logic programs obtain answer substitutions goal clause 
sure answer substitutions meaningful 
long proof procedure generally accepted basic computational model wemust resort considered fundamental order clarify meaning result computation 
appropriate foundation rst order logic 
brie introduce results showing computed answer substitutions correct agreeable sense 
results mainly due clark 
denote logic program goal clause form 
answer substitution said correct logical consequence closed formula logical formula free occurrences variables said logical consequence closed formula interpreted true model 
properties hold proof procedure described section soundness substitution obtained proof procedure correct 
completeness correct answer substitution selection rule atoms fair proof procedure computes substitution general 
capture semantics logic program means speci model program called minimal herbrand model go detail note important properties minimal herbrand model represented set elements herbrand base interpreted true model 
set elements herbrand base logical consequences 
xpoint mapping de ned ground instance clause ground instance clause instance obtained applying substitution mapping variables elements minimal herbrand model important points general free model ectively gives interpretations function symbols 
says just ground logical consequences 
enumerate elements 
applications may programs terminate useful equipped appropriate means observe control result computation 
clearly give semantics terms answer substitutions programs 
people try capture semantics non terminating programs extending herbrand models allow nite atoms van emden de lucena hagiya lloyd 
show semantics non terminating logic program characterized greatest xpoint extended complete herbrand base 

advantages logic programming framework pointed advantages logic programming framework framework provided conventional procedural languages non strict data structures variable logic programming language monotonic natural notion value variable unknown unde ned 
word monotonic mean knowledge value variable may increase computation proceeds changes 
variable called single assignment variable toplevel value principal function symbol determined 
handle data structure may contain uninstantiated variables natural way 
data structure called non strict incomplete 
contrast procedural languages unde ned state variable regarded exceptional possible values despite fact variable initially unde ned 
order disallow referring value unde ned variable languages impose awkward language rules violation usually detected compile time run time 
capability handle incomplete data structures ectively programming di erence lists clark 
di erence list pair list called head sublist called tail 
leaving tail unde ned di erence list part construct longer di erence list complete list terminating nil 
notion di erence lists provides freedom order determine portion concrete list structure 
uni cation replaces assignment parameter passing equality check procedural languages assignment couple parameter passing mechanisms transfer data 
logic programming languages achieved mechanism uni cation 
semantics theoretical models uni cation cleaner semantics 
procedural languages provide separate primitive checking equality values logic programming uni cation 
program looks naive logical speci cation programming language mayhave logic 
example procedural language formalized hoare logic hoare 
call logic programming language 
characterizes logic programming language naive classical logic originated tool formal treatment human inference logic dedicated computer languages 
classical logic fundamental tool describe speci cation procedural programs dijkstra 
speci cation derive logic program easily smaller semantic gap 
claimed advantages logic programming 
reserve judgment examine facilities closer section 
mentioned section semantics logic program characterized herbrand model sld resolution proved sound complete proof procedure respect herbrand model 
logic programming simple clear model theoretic operational semantics framework theorem proving 
necessarily mean clear semantics amended general purpose programming language 
automatic backtracking exhaustive search completeness proof procedure solutions answer substitutions goal convenient regarded unique feature logic programming 
situations want solutions 
multiple uses predicates capability single predicate de nition modes information ow claimed convenient feature 
example append program decomposing list sublists checking list concatenation lists addition normal suggested verb append 
cases intended mode predicate de ne 

closer look logic programming general programming language sections examine characteristics logic programming detail 
emphasis placed characteristics logic programming framework general programming 
course general programming includes speci areas problem solving knowledge processing usually considered main targets logic programming really important 
point examine logic programming programming language view speci application areas 
prolog gaining application areas general purpose programming language meaningful examine practice prolog programming clarify di erent logic programming pure sense described section 
section gives general observations section enumerates examines extralogical features prolog 

virtue logical 
stated section characterizes logic programming language naive classical logic originated tool formal human inference logic dedicated computer languages 
see actual programming language simple theorem prover requirements actual programming language simple theorem prover ful ll 
anyway devise familiar complicated logic formally describe aspects programming language 
mean naive classical logic loses role practice logic programming simple logic useful programming reasoning programs 

completeness multiple uses predicate completeness highly respected desirable property proof procedure 
logic programming prolog programming property 
observe due depth rst search strategy prolog implementation far dicult write prolog predicate fair generator solutions write predicate checking 
write trial program exhaustive search trial error manner 
necessary seldom write programs subclass horn clause logic depth rst proof procedure complete 
capability computing solutions capability predicate mode information ow independent 
cases goal appearing program intended mode 
example prolog program example naive programs sort permutation ordered 
naive programmer ordered generator way sort ordered permutation 
render de nition ordered complicated succeeds de ning program run eciently 
example shows importance notion data ow 
interested solutions goal 
express original framework logic 
rely control facilities cut operator see section 
original framework logic programming allows search solutions goal exhaustively means obtained solutions collected framework see sections chapter 

result execution logic program 
claimed lloyd interested answer substitutions computed proof procedure success failure signal returns 
answer substitutions displayed top level loop prolog system really standard way seeing result computation 
believe 
analogy help understand 
procedural language counterpart answer substitutions displayed system values variables displayed dump facilities supported operating systems 
dump standard way seeing result computation practical programs 
useful testing small pieces programs locating incomprehensible bugs large programs 
non trivial programs communicate outside world input output facilities 
practical programming language provide capability full control input output 
furthermore important medium human computer interaction character strings nakashima ueda self contained language able handle character strings expressive de ne conversion procedures internal representation data structure string representation 
prolog ful lls requirements awkward way 
input output performed side ects completely rely speci control structure prolog 
side ect obstacle veri cation optimization parallel processing 
general program transformer input data sequence output data sequence logic program express relation sequences framework just naturally expresses relation data structure 
fact exercised program interactive read input data rst transform write output data 
programming style interactive programs due control strategy prolog 
problem discussed section 
addition input output facilities examine original way seeing answer substitutions detail 
get answer substitution proof procedure nite set substitution components 
niteness answer implies tells variables left uninstantiated 
important point information considered meta level information extralogical facilities goal program means know variable instantiated 

extralogical features prolog prolog programming logic programming 
prolog yielded number programming techniques speci prolog related control structure depth rst execution backtracking 
techniques kind tricks little value harmful software engineering viewpoint 
control structure extralogical facilities especially write system program 
general extralogical features needed manipulate prolog programs data execute programs created data want meta level information depends progress proof procedure forth 
section survey extralogical features prolog clarify extralogical 
surveys extralogical features prolog done om szeredi course 
note deal logical features may look extralogical truly extralogical ones 

cut symbol cut symbol cut operator controlling depth rst execution logic program 
proof procedure encounters cut operator ignores sibling clauses clause textually containing cut operator executed 
words cut operator intentionally losing completeness proof procedure 
safe uses cut eliminating alternatives return result 
example follows abs abs care clause returns absolute value clauses return result 
inserting cut operators avoids unwanted backtracking losing solutions 
course abs reverse direction obtain cut operator lose possible answers need consider case 
cut expressing indi erence selection result sign 
sign di erence abs example care sign clause returning 
case cut reasonable prevent proof procedure returning answer substitutions di erence indi erent 
argued de nition safe abs example fails answer question sign sign sign 
question contrary intent expressed de nition sign cares possible signs 
examples show cut realizing kind input guard rst introduced dijkstra form guarded commands 
cut purpose may cause program deviate somewhat declarative semantics little problematic long predicate intended direction 
care clauses mutually exclusive cut operator eciency purposes 

cut operator rst clause explicitly lets compiler know alternative clause need considered 
compiler tail recursion optimization warren avoid unnecessary growth stack 
case rst argument caller non variable term tail recursion optimization possible cut operator 
programmer know sophisticated optimization compiler defensive programming provide information optimization possible 
compiler esp chikayama logic programming language augmented object oriented features discourages writing clause cut encountering clause 
wada nakashima kimura argue avoid unwanted backtracking 
uses cut operator include declarative reading program meaningless 
typical example cut operator expressing non monotonicity defaults exceptions fly penguin fail 
fly fail 
fly 
example cut operator implementing negation failure see section call fail 
clauses allows declarative readings cut operators depth rst proof strategy give important meanings 
noted prolog dialects try discourage cut operator providing variety high level primitives backtracking control prolog kr nakashima eager elimination cut operator 

input output mentioned section input output facilities prolog awkward 
side ects completely rely speci control strategy prolog 
input output side ect compatible procedural programming quite heterogeneous logic programming 
particular ects input output usually undone backtracking 
argue output declaratively transparent adding output goal clause changes declarative reading program 
transparency output means completely extralogical logic says output obtained 
input output facilities prolog point considered 
prolog system able display non ground terms occurrence avariable indicated character string appropriately system 
conversion non ground term character string involves extralogical operation see subterms instantiated 

primitives modifying internal database interpreter prolog systems support primitives usually called retract modifying internal database program clauses stored 
words support primitives modifying program execution 
primitives realizing large modi able data structure familiar procedural languages 
number proposals logical array facilities prolog see eriksson rayner cohen example prolog implementations lack array database features allow ecient access update framework logic 
internal database purpose logical array database help pass information branch proof tree 
programs rely property database update primitives ects undone backtracking 
warren proposed method logical database updates pure prolog 
primitive retract deleting clause means logical causes non monotonic change internal database 
hand primitive assert adding clause safer way carefully restrict assert monotonic change database 
example add fact inferred current program purpose optimization changes program 
example addition new facts knowledge acquisition system 
case internal database considered open world 

time dependent operations prolog variable deemed binary state instantiated nonvariable term 
state variable change execution uninstantiated instantiated 
knowledge state variable called meta level knowledge depends proof performed observed 
object level level program executed change state variable means changed happened just known unknown previously 
meta level knowledge clearly distinguished object level knowledge values instantiated variables 
need access current state variable example implement uni cation routine occur check plaisted supported prolog implementations 
general obliged meta level knowledge write system program prolog 
meta level knowledge exists anyway accessible 
con ned implementation prolog abandon writing system programs 
prolog systems usually provide primitives examine current state variable var examine instantiated non variable term examine literally identical uni able substitution 
nakashima ueda propose higher level meta level primitives 

sequentiality backtracking control structure fact proof procedure prolog performs depth rst search utilized eciency purposes 
eciency extralogical matter independent result computation problem arises 
prolog speci control strategy utilized guaranteeing result extralogical operations described 
said prolog program hard debug behavior program dicult understand due backtracking 
addressed problem prolog programmer worry greater lesser degree control issues eciency completeness 
program uses side ects backtracking realizing repetition 
repetition start goal repeat fail repeat de ned follows repeat 
repeat repeat 
control structure entirely meaningless side ects 
method counted programming technique trick speci prolog programming 

call negation failure prolog systems provide system predicate named call execute argument goal 
consider predicate call interprets term appropriately possibly instantiated interpretation 
harm long care term interpreted 
idea negation failure clark prolog 
de ned prolog call fail 

symbol distinguish logical dec prolog bowen byrd pereira pereira warren 
note cut operator relied speci order clauses 
pointed di erent true clause read equivalent works interpretation 
worse clause containing allows declarative reading rst order logic 
example extralogical predicate var de ned follows nakashima var 
indicates extralogical 
argument contains variables executed give declarative semantics construct clark idea completion sound extension sld resolution handle negative atom goal 
restriction negative atom ground weakened contains variables problem long proof instantiate 
ic prolog clark mccabe guarantees soundness reporting error message negated atom proved instantiating 
prolog ii colmerauer system predicate dif success postponed proved able 
dif deals simplest case logical negation 
sequentiality sibling clauses implicit negation 
instance predicate abs section tends de ned follows reason eciency abs 
abs 

examining constructing non variable terms system programmers facilities extracting principal function symbol arity non variable term getting argument speci ed position non variable term constructing general non variable term speci ed principal function symbol 
dec prolog items done system predicate functor item arg semantics clear example functor 
functor 
arg 

function symbol arguments symbol argument di erent entities happen representation 
need think primitives extralogical 
predicate functor thought relating non variable term constant write de nition functor giving clause function symbol 
write de nition arg 

meta level nature result computation examined section result computation shown possible sets answer substitutions contains meta level information 
front terminal get prolog system lot extralogical information lot extralogical decisions example modify current program 
means task man terminal easily automated replaced program introducing meta level features 
need appropriate framework meta programming construct programming systems 
important application meta programming knowledge assimilation belief revision kowalski furukawa takeuchi 
meta level extension prolog discussed bowen weinberg bowen 
important application collect solutions goal single data structure 
involves meta level operation di erent solutions originally independent 
capability prolog obtain solutions important advantage advantage diminished means collect solutions processing phase 
prolog systems support primitives collecting solutions example dec prolog provides predicates setof bagof 
meta level features underlying logic complex 
means formal mechanical treatment programs harder 
ects programming systems support veri cation debugging forth eciency programs interface meta level object level may hard optimize 
meta level facilities limited case really necessary 
example show chapter exhaustive solution search done eciently non trivial class programs meta level features 

summary sum burden imposed prolog meet practical needs went far pure horn clause logic result prolog number extralogical extensions complex semantics special control strategy prolog 
review needs try nd way meet requirements cleaner way 
course impossible formal semantics extralogical features sequential prolog completely deterministic meta level proof procedure takes exactly behavior program 
fact feature de ned formally necessarily justify feature invent formal de nition long unambiguously de ned informally 
important issue de ned 
features reconstruct divided features general features 
include access meta level information meta level programming non monotonicity database update 
researchers searching cleaner constructs support 
extension horn clause logic speci applications scope thesis thesis concentrate general features input output 
input output designed ad hoc manner forming part programming language 
take completely di erent approach wemay adopt central issue language design semantics input output uniformity language constructs 
succeed designing language principle ect improvement quite general non trivial program output 
logic programming language context input output independently proposed nakashima ueda ic prolog clark mccabe 
proposals notion streams input output declarative 
stream oriented input output major advantage enhancing modularity reusability modi ability programs 
see terminal formalized stream characters easily directed input program 
input terminal formalized stream characters source input data easily replaced output program 
means program stream oriented input output serve module larger program modi cation 
di erent way input proposed sergot called query user facility 
di erence stream oriented input query user facility utilizes monotonic change internal database input 
chapter parallel logic programming chapter introduces parallel logic programming 
parallelism logic programming considered di erent levels implementation language programming application 
levels take central interest language programming level 
section motivations considering parallelism logic programming 
go back procedural semantics logic programs chapter discuss section kinds parallelism exploited 
main sources parallelism parallel execution di erent derivations parallelism single derivation called parallelism parallelism respectively 
section survey previous research parallel execution logic programs 
non trivial parallelism parallelism involving shared variables requires control practical programming languages features proposed provides facilities controlling parallel execution 
features spoil completeness increase horn clause logic programming language practical point view 
section deals proposals section shapiro concurrent prolog exible language 

parallelism logic programming parallelism logic programming considered various levels level application domain level hardware implementation 
level parallelism signi cance stated 
parallelism application domains simulate control reason parallel systems real time systems convenient programming language allows natural concise description parallel systems 
temporal logic ubiquitously framework describing parallel systems interested state transition system time axis 
treat time separately space learns little bit relativity theory 
special treatment time meaningful long system physically small slow 
programming languages proposed various kinds temporal modal logic includes temporal prolog fujita oka language aida language hagiya 
motivation languages natural description time dependency languages aimed description parallel systems 
note language aimed parallel execution 

parallelism languages programming logic program inherently parallel program expresses sequentiality 
course logic program directed sense answer substitution generated respect goal 
mean computation proceed sequentially 
prolog introduces sequentiality primarily compatibility sequential computers 
prolog certainly expressive introducing extralogical features including sequential execution meaningful sequential execution justi es sequential execution extralogical features reconsidered anyway 
programming languages sequentiality tends program suppose variables initialized pascal program 
reason place assignment statements front natural description impose speci order 
inessential sequentiality program algorithm natural general 
procedural languages sequentiality essential destructive assignment variables 
logic programming free destructive assignments purposes sequential control limited gain eciency guarantee availability data necessary executing system predicates arithmetics 
consider prolog goal uni es value expression 
causes error uninstantiated call 
goal need cause error postpone instantiated 
say error condition indicates results discrepancy data ow control ow 
control data ow natural sequentiality 
worth noting basically sequential prolog ii colmerauer kl yamamoto nakashima try alleviate inconvenience freeze bind hook primitives respectively 
mechanism delayed execution essential realizing ii see section 
note control mechanisms delayed execution coroutines conceptually kind parallel control sequential machine oriented 
parallelism level languages programming independent parallelism implementation state 

parallelism implementation motivation parallelism implementation quite simple faster execution programs 
parallelism implementation worth exploiting independent programs written sequential language parallel language 
understood seeing vector processors exploit parallelism fortran programs numerical computation performs mega flops giga flops 
conversely case program parallel language suitable sequential implementation 
suppose program creates processes just active time 
program sequential computer perform parallel computer 
follows program written sequential language may really require pseudo parallel control features concise description optimizing compiler may generate object code 
discussions illustrate physical parallelism implementation independent logical parallelism higher levels 
parallelism called concurrency distinguish physical parallelism 

thesis take central interest level programming programming languages interest extend implementation 
stated logic program inherently parallel program framework logic programming section inadequate practical parallel programming language reasons input output facilities prerequisite practical language hard keep compatible uncontrolled parallel execution see section 
framework fully considered terms parallel execution 
clari ed considered primitive operations 
derivation step sld resolution large primitive operation involves uni cation rewriting goal clause 
trivial task design practical parallel programming language horn clause logic 
addition task interesting viewpoint 
previous research parallelism devoted enhancing performance sequential programs enhancing expressive power sequential languages 
example vector processor implementation fortran exploits parallelism sequential programs 
piece fortran program allows vectorization parallelism inherently program piece meaningful design programming language parallelism inherent problem naturally expressed 
examples seen practical parallel languages designed extension sequential languages 
notation synchronizing ordering operations replace sequential control principle 
reasons languages retain sequential control eciency 
compiler exploit sequentiality parallel program generate ecient code sequential computer sequential control 
propose shift default control sequential parallel consider sequential execution optimization meet current computer architecture 

parallel execution logic programs section discuss kinds parallelism exploited procedural semantics logic programs shown section 
kibler hogger discuss parallel execution logic programs resolution principle nd sources parallelism sld resolution argue parallelism lose soundness completeness sld resolution 

parallelism parallelism parallelism logic program divided categories 
parallel search refutations goal clause 
stated section nding refutation goal clause involves searching may program clause derivation step 
natural idea parallelism extending derivation tree nd refutation paths 
parallelism called parallelism 
note called parallelism program clauses derivation step conjunction clauses refutation 
mentioned parallelism includes couple special cases 
called database parallelism search parallelism 
database parallelism means program clauses usable derivation step searched parallel 
ective program clauses usually unit clauses potentially usable derivation step 
techniques studied relational database technology applicable case 
special case called pipeline parallelism backup parallelism 
assume refute goal clause sequentially process tasks involved solving assume select leftmost atom derivation step 
pipeline parallelism means process sequentially generates answer substitutions subgoal incrementally fed process words process extending path derivation tree process tries extend path 
note pipeline parallelism goals derivation path solved parallel goals di erent derivation paths 
pipeline parallelism kind parallelism 
source parallelism lies manner derivation path constructed 
section sequentially constructed path derivation tree 
matter refutations constructed long refutations yield correct answer substitutions 
may possible select goals simultaneously derivation exploit parallelism uni cation 
usually called parallelism refutation successful parallel tasks involved successful 

correctness parallel execution obvious parallelism ect soundness completeness procedural semantics exploits independence di erent derivation paths 
hand parallelism require justi cation follows 
linear derivation path rst consider proof tree de ned follows root corresponds original goal clause 
non root node corresponds program clause derivation step 
arc corresponds body goal clause represented parent node 
proof tree basically proof term appearing hagiya 
addition program clause non root node considered representing equation goal represented arc parent node head clause 
goal called caller said call 
proof tree said closed leaf nodes correspond unit clauses 
answer substitution proof tree general substitution substitutions simultaneously solve equations represented non root nodes 
proof tree may answer substitution 
proof tree answer substitution called non ordered refutation 
getting non ordered refutation involves kinds tasks construction proof tree uni cation needed solve equations represented non root nodes 
parallel proof procedure nds parallelism tasks may construct proof tree parallel solve equations parallel perform tasks parallel 
proof method called parallel input resolution 
primitive operation construction proof tree put new node 
corresponds just providing body goal program clause leaving uni cation goal clause head separate operation 
primitive operations solving set equations primitive operations parallel uni cation 
di erent models parallel nondeterministic uni cation proposed martelli montanari dwork kanellakis mitchell ueda choose speci method request parallel uni cation algorithm proof procedure correct stops calculates general uni er original uni cation problem 
soundness parallel input resolution correctness see section answer substitutions shown constructing sld refutation non ordered refutation obtained parallel input resolution 
non ordered refutation rst give total order non root nodes corresponding program clauses goals attached incoming arcs nodes topological sorting 
obtained sequences program clauses goals construct sld refutation refutation sld resolution follows 
assume wehave performed derivation steps obtaining uni ers th goal clause 
selected atom employ new variant derive th goal clause 
obvious th goal clause contains goal uni able clause head clause empty equal answer substitution non ordered refutation 
construction sld refutation guaranteed succeed 
sound seen section get soundness parallel input resolution 
completeness parallel input resolution shown means completeness sld resolution 
seen correct answer substitution selection rule atoms fair proof procedure computes refutation substitution general 
suces show fair proof procedure parallel input resolution computes non ordered refutation yielding substitution general 
sld refutation construct corresponding closed proof tree straightforwardly 
firstly fair proof procedure generate closed proof tree including failure construction proof tree independent uni cation 
course may constructing tree optimization uni cation turns fail mean construction proof tree failed 
suces show proof procedure nds non ordered refutation answer substitution general 
set equations obviously general uni er wehave assumed parallel uni cation algorithm parallel input resolution stops calculates general uni er original uni cation problem 
proof procedure nds non ordered refutation answer substitution general 

restricting controlling parallelism may argued non ordered resolution realistic large search space 
search space includes proof trees having goal clause root 
reduce search space detecting failure uni cation early possible 
insucient 
consider unary predicate lot unit clauses 
goal generate answer substitutions called leaving uninstantiated 
suppose goal conjunction generates small number answer substitutions 
better introduce control data ow concept goal wait nds answer substitution general impose restriction parallelism order minimize computation contribute nal answer substitutions 
way disallow parallel execution goals share variables 
share variables answer substitutions contribute set answer substitutions conjunction 
call type parallelism restricted parallelism degroot 
control illustrated 
call controlled parallelism 
purpose control goal wait instantiated avoid fruitless computation 
straightforward way control control data ow put di erently degree goal instantiated execution goals 
reasons introduce data ow concept logic programming language chapter 

previous works parallel logic programming section surveys previous works parallel execution logic programs proposals parallel logic programming languages 

parallelism research parallelism done mainly architectural aspects 
important issue characteristic parallel execution logic programs management multiple environments multiple substitutions generated di erent paths derivation tree 
issues include resource management spatial allocation processes common parallel processing systems 
explain terms sld resolution dicult multiple environments 
goal clause rewritten 
selected atom 
new variants di erent program clauses 

uni able general uni ers respectively 
goal clause rewritten ways 

depth rst sequential proof procedure usually takes advantage fact exists making derivations 
records variables rewritten derives 
turns fail derived proof procedure restores undoing bindings recorded data 
recording undoing operations usually cheaper record 
technique parallel execution means may exist 
way having simultaneously obtain clauses rewriting copying 
method kind shallow binding requires fairly expensive copying operations guarantees ecient access new goal clause 
way manage common original clause 
method kind deep binding creating new goal clauses cheap access new goal clause requires applying substitution ancestor clause mayhave obtained manner 
proposals parallel prolog machines far copying scheme 
pie goto tanaka oka oka tanaka aida hirata maruyama reduction subprocess parallel unify process performs copying new goal clause old binding information 
pim ito masuda ito shimizu kuno copying performed substitute operator 
aso shimizu masuda matsumoto adopts copying scheme 
hand prolog tamura employs deep binding scheme 
haridi aware implementation issue multiple environments propose di erent scheme 
approach called demand copying 
structure sharing scheme boyer moore environment consists contexts store binding information environment dictionary associated tree entries point context items 
size environment dictionary depends level node derivation tree dictionary associated 
derivation step new environment dictionary created context items pointed dictionary parent node containing uninstantiated variables copied introduce optimization 
introduced lazy construction dictionary lazy copying context items points 
initialization new environment cheap deep binding scheme 
rst access value variable requires looking current parent environment dictionaries possibly updating dictionaries contexts expensive deep binding scheme 
subsequent accesses variable done constant time shallow binding scheme 
avoiding eager copying ective small portions copies referenced 
author ueda proposes quite di erent approach execution logic programs 
proposes compile parallelism controlled parallelism 
mode analysis method compiles away diculties management multiple environments uninstantiated variables 
detailed description method chapter 
warren proposes memory non depth rst sequential execution logic programs 
method mixes deep binding shallow binding tree activation records serves association lists binding array holds bindings corresponding tree 
entries binding array lled demand data activation records 
method applied multiprocessor environment binding prepared process executing path derivation tree processor executes number processes repeated context switching 
architectures database parallelism studied nakagawa warren ahamad debray kal taylor lowry maguire stolfo 
pipeline parallelism studied nitta matsumoto furukawa tamura 
showed realize parallelism supercomputer pipeline processing capabilities 
note tick warren study pipelining low level propose processor eciently executes sequence compiled codes pipelining 
meaningless classify low level parallelism parallelism parallelism 

parallelism seen section parallelism requires restriction control practical 
research parallelism done mainly mechanisms restriction control 
brie review restricted parallelism 
kibler propose method serializing goals shared variables 
serialization realized computing partial order set current goals goals executed parallel ordering 
problem partial order computed times runtime 
degroot proposes coarser ecient algorithm checks absence shared variables goals 
pim executes goals parallel told 
rest section deals controlled parallelism 
research controlled parallelism goes back research coroutining 
may look little bit complex coroutining natural control scheme enables scheduling availability data 
coroutining naive generate programs practical extent early detection failure 
methods coroutining proposed coroutining number reduction steps data ow coroutining 
epilog porto appears pereira 
achieve coroutining means delay primitive causes cycle delay reduction speci ed goal 
problem method machine oriented correctly speci ed coroutining interpreter semantics primitive understood terms interpreter 
addition method easily parallel evaluation semantics de ned terms centralized interpreter 
data ow coroutining user oriented way specifying coroutining 
ic prolog clark mccabe variety features allows programmer specify occurrence shared variable act generator schedules goals information 
speci cation generator consumers done annotations variables 
scheme appropriate pseudo parallel processing ic prolog allows parallelism coroutining 
parallelism means generation bindings producer goal go ahead consumption coroutining means producer generate new binding consumer processes previous 
control primitives informally described semantics language simple clear successors relational language described 
coroutining parallelism controlled annotations provide ideal framework programming input output nakashima ueda 
stated section program input output keep relational programming style written relation sequence input data sequence output data transform 
goals processed sequentially parallelism coroutining produces advantages 
firstly realizes pipelined processing input sequence enables incremental generation output data 
secondly saves memory space part input output sequences processed discarded garbage 
relational style advantageous encourages di erential programming 
output program easily fed input program handle input output data sequences 
sequences input output data usually implemented linear lists called streams 
generally sequence data transferred goal means shared variable called stream 
controlled called stream parallelism stream important pragmatic concept controlled parallelism large grain parallelism exploited parallel execution goals communicating streams 
goals consume generate streams called processes 
van emden de lucena process interpretation logic programs see section simple examples 
showed network parallel processes described logic programming 
exposition describes basic idea deal subtle points semantics parallel execution 
early proposals stream parallelism introduced additional construct sequential framework process regarded stack computation 
annotations synchronization direction data ow dynamically determined arguments instantiated call 
researches paid little attention determinacy communicated data bindings transmitted possible ones alternatives 
determinacy bindings important practical 
processes distributed multiple processors send receive nondeterminate bindings wemust implement called distributed backtracking mechanism withdrawing broadcasted bindings 
importantly data output external device determinate impossible erase sequence characters typed 
remedy problem allow determinate data output transmitted processes 
restriction greatly simpli es implementation 
relational language clark gregory introduced guard mechanism dijkstra purpose successors parlog clark gregory clark gregory concurrent prolog shapiro guarded horn clauses ueda 
roughly speaking languages features common goals program clause divided guard goals body goals 
goal goal clause program clauses solved head uni cation uni cation goal clause head guard goals allowed solve body goals 
mechanism called committed choice nondeterminism selection program clauses called commitment 
head uni cation guard goals clause executed refute goal clause instantiate goal clause commitment 
consequence bindings determinate 
languages di erent way guaranteed 
relational language asks programmer put annotation generator occurrence shared variable call channel variable 
imposes restrictions 
firstly head uni cation bind non generator occurrence avariable goal violated clause input suspended clause 
secondly head uni cation succeeded guard goals instantiated true ground atoms 
clearly second restriction guarantees guard goals generate bindings 
third restriction output bindings generated generator occurrence applied goal clause commitment 
emphasized original restriction overlooked output bindings di erent program clauses may collide 
parlog uses mode declaration annotation 
predicate mode declared 
mode declaration declares argument predicate input output 
restrictions imposed 
head uni cation generate bindings input arguments goal 
head uni cation succeed violating restriction suspends 
restriction guard goals generate bindings input arguments 
guard set guard goals satis es restriction called safe guard 
safety guard checked run time intended checked compile time 
third restriction bindings output arguments goal generated commitment 
concurrent prolog mechanism synchronization guaranteeing determinacy bindings provided independently 
employs read annotation synchronization 
annotated occurrence variable instantiated non variable term uni cation occurrence involved 
determinacy uses local multiple environment mechanism 
commitment bindings generated head uni cation guard goals instantiate goal clause recorded locally form local environment program clause 
may exist time bind variable di erent terms implement multiple environment mechanism 
locally recorded bindings exported applied goal clause commitment program clause allowed 
bindings goal arguments determinate 
guarded horn clauses guarantees determinacy bindings making head uni cation guard goals suspend instantiate goal clause 
chapter contains detailed explanation 
compare languages viewpoints 
communication channel relational language allowed way communication want receive answers messages prepare stream 
concurrent prolog enabled exible way communication means back communication technique 
technique uses incomplete message message uninstantiated variable 
generator stream instantiates head incomplete message consumer binds uninstantiated variable answer 
concurrent prolog appears simple exible parallel logic programming language ancestors guarded horn clauses syntactically examine detail section 
concurrent prolog realized back communication language multiple environments parlog realized feature single environment language 
addition parlog showed compilation technique head uni cation algorithm checking safety guard applicable large class programs 
comparison guarded horn clauses ancestors chapter go technical detail 
note surveys stream parallel logic programming languages nitta gregory 

examination concurrent prolog section language rules concurrent prolog shapiro original 
main result assumed uni cation order reasonably de ne semantics uni cation commitment 
means logical transformation program clause may change semantics 
point semantical problems multiple environments commitment operation 
results section ueda substantially extended version ueda 
problems semantics concurrent prolog examined saraswat independently di erent viewpoint 

motivation method previous sections wehave examined parallelism logic programming general 
go detail examine best known parallel logic programming languages concurrent prolog shapiro 
thorough examination speci language help identifying subtle points parallel logic programming possibly justify designing alternative language 
concurrent prolog chosen language rules concise looked expressive 
judged appropriate rst approximation ultimate parallel logic programming language 
programming experience institute new generation computer technology icot showed concurrent prolog fairly expressive 
examined really concise described informally operational semantics hirata 
simple language rule expressed natural language may formalized set quite complex rules 
examine subtle point concurrent prolog necessary clari cations modi cations 
wemust consider points examination 
firstly contain ambiguous inconsistent rules 
secondly considered light parallelism language level parallel implementation 
thirdly concurrent prolog programming language originated horn clause logic wemust consider extent properties logic programming original sense retained essential deviation horn clause logic language concurrent prolog re examined light criteria 
regard shapiro de ning document concurrent prolog original detailed text 
fundamental method examining language de ned informally examine de ning sentence thoroughly 
quite useful detecting problems language de nition example author applied technique examine language rules preliminary version ada ueda 
comments sentence sentence purpose try obtain correct semantics concurrent prolog criticize de ning sentences 
purpose examined documents concurrent prolog shapiro shapiro takeuchi signi cant di erence original document new information help reach correct interpretation materials discussed section 

de nition concurrent prolog section introduces syntax semantics concurrent prolog described original shapiro 
quote important paragraphs number 
note language de ned shapiro rst called subset concurrent prolog simply called concurrent prolog community 

syntax section concurrent prolog program nite set guarded clauses 
guarded clause universally quanti ed axiom form atomic goals 
called guard clause called body 
guard empty commit operator omitted 
clause may contain variable marked read 
section commit operator generalizes cleans sequential prolog cut 
declaratively reads conjunction implied 

semantics section operationally guarded clause functions similarly alternative guarded command 
reduce process system uni able uni cation system invoked terminates successfully 
section uni cation read term 
term de ned follows 
non variable uni cation succeeds non variable recursively uni able 
variable uni cation 
succeeds result read variable 
symmetric algorithm applies 
section de nition uni cation implies read inherited property variables occur read term necessarily read 
stating di erently scope read annotation principal functor term arguments 
section de nition uni cation implies success uni cation may time dependent uni cation fails due violation read constraint may succeed principal functor shared read variable determined process variable occur read 
section execution concurrent prolog system running program described informally follows 
process tries asynchronously reduce processes clauses 
process reduce nding clause head uni es guard system terminates uni cation 
system terminates empty 
may empty clauses empty bodies 
section computation concurrent prolog program gives rise hierarchy systems 
process may invoke guard systems attempt nd reducing clause computation guard systems turn systems 
communication systems governed 
subsystems spawned bya process access variables occur 
long process commit reducing clause subsystems access readonly variables binding compute variables read recorded privately stored copies variables accessible outside subsystem 
commitment clause private copies variables associated clause uni ed public counterparts uni cation succeeds body system chosen clause replaces 
section detailed description distributed concurrent prolog interpreter uses kinds processes dispatcher dispatcher uni er processes confused concurrent prolog processes unit goals 
section computation begins system concurrent prolog processes progresses indeterminate process reduction 
invoked computation proceeds follows dispatcher invoked system spawns dispatcher concurrent prolog processes waits child report success 
reports success terminates 
dispatcher invoked concurrent prolog process operates follows 
clause head potentially uni able uni er clause 
dispatcher waits uni ers report success 
report arrives dispatcher reports success parent dispatcher terminates 
uni er invoked concurrent prolog process guarded clause operates follows 
attempts unify storing bindings non read variables private storage 
successful invokes dispatcher waits report success 
report arrives uni er attempts commit explained 
commitment completed successfully reports success case terminates 
section uni er spawned dispatcher may commit 
section commit uni er rst gain permission 
mutual exclusion algorithm guarantee uni er wants commit exactly uni er permission 
gaining permission uni er attempts unify local copies variables corresponding global copies 
successful commitment completes successfully 
section useful optimization deletion brother uni ers rst process ready commit 
section committing uni er required perform uni cation public private copies variable atomic action 
requirement uni cation correct sense modify instantiated variables achieved shared memory model test set primitive 
section uni cation currently fails may succeed phrase attempts unify description uni er interpreted continuous activity terminates success 
implemented busy waiting strategy optimizations incorporated 
correct small error paragraph 
dispatcher report set processes parent dispatcher simple message success 
dispatcher recognize processes newly created processes replace original spawn dispatchers 
dispatcher reports success terminates reduced empty set goals 
alternatively dispatcher may invoke new dispatcher body clause corresponding uni er reported success report dispatcher report dispatcher question 

parallel programming concurrent prolog section system processes corresponds conjunctive goal unit goal process 
state system union states processes state process value arguments 
parallelism solving goals simultaneously provides system concurrency 
parallelism attempting solve goal ways simultaneously provides process ability perform indeterminate actions 
variables shared goals serve process communication mechanism synchronization processes system done denoting processes write shared variable unify non variable term processes read content shared variable unify non variable term principal functor determined possibly process 

multiple environments commitment operation commitment operation described paragraphs process event 
preceded permission completes uni cation local global copies variables terminated successfully 
explicitly speci ed commitment starts time permission start uni cation 
controversial issue nature permission 
second sentence paragraph says mutual exclusion algorithm guarantee uni er wants commit exactly uni er permission 
clear permission revoked uni cation local global copies variables succeed providing clauses opportunity commitment permission eternal clauses longer attempt commitment operation clause gained permission 
failure uni cation happen global variable instantiated goals local copy created paragraphs de ne successful case 
permission revoked failure uni cation means failure grandparent dispatcher parent parent dispatcher 
permission revoked uni cation performed way intermediate result uni cation invisible processes 
uni cation may eventually fail case clauses retain possibility commitment 
paragraphs say uni cation continual activity terminates success 
interpretation commitment operation continual activity terminates success uni cation involved 
suggests permission need revoked 
interpretation unfortunately inconsistent description paragraph uni er terminates commitment completed successfully paragraph problematic say uni er terminate commitment completed successfully 
complete lack description locking operation shown necessary permission revoked suggests permission eternal nature 
interpreter shown shapiro adopts opposite interpretation 
impossible derive correct answer original description better way thorough examination merits alternatives 

alternative permission rst assume permission commitment revoked uni cation local global copies variables succeed 
permission revoked intermediate result uni cation kept invisible goals 
success uni cation revocation permission known unnecessary wemust perform uni cation local global information way partial result invisible goals 
problem implement commitment operation meets requirement 
possible solution perform operations order lock relevant global data variables appearing goal arguments local copies 
try export local bindings unifying local copies global counterpart 
start step nished long bindings unlocked global variables 
uni cation successful uni cation successful simply unlock global data locked step 
uni cation unsuccessful undo bindings step unlock global data locked step 
unlocking start undoing nished long global variable unlocked unbound 
independently operations return permission commitment 
problem lies locking operation step 
simplest locking scheme lock memory commitment attempted de nitely unacceptable serializes commitment operations 
want lose parallelism minimize locked area 
smallest unit locking single variable 
variable variable locking easy variables commitment operation studied area distributed databases operating systems 
assume clauses say attempting selected lock variables tries lock rst tries lock rst may deadlock 
deadlock problem easily resolved order variables 
give invariant order set variables locked clause lock order 
hard consider invariant order variables may uni ed time uni ed order 
considerations lead rst 
may think detect ability local global information earlier commitment 
enabled checking uni ability local global values variable new global local binding variable created 
eager checking eliminates uni cation commitment uni cation satisfy requirements stated 

second alternative permission eternal consider alternative permission commitment eternal nature 
longer need locking operations impossible clauses export bindings 
uni cation may done just usual manner 
alternative increases chance failure program conjunctive goals try instantiate variable commitment 
cause inconvenience 
predicates written ectively possibly nondeterministic functions returns result 
result may prepared guard exported commitment usually receive variable case failure happen 
remain semantical problems 
unnecessary return permission commitment obtained de ne uni er terms paragraph attempt gain permission 
words wehave de ne kind global information supplied goal arguments respected regard head uni cation execution guard successful 
information come attempt commitment ignored information evidently available considered clause selection 
consider goal 
goal says things call unary predicate set argument 
question argument setting completed call 
absurd question examining concurrent prolog truly parallel language 
argument setting precede call goal fails predicate ned follows 

clause succeeds head uni cation 
argument value may determined arbitrarily late goal may fail 
clause earlier value head may recorded locally uni cation corresponding goal argument determined 
case ability detected clause gained permission commitment original goal nally fails 
generalize program clause selected goal long guard succeeds system fail 
extremely inconvenient write predicate intended check values arguments 
information speci ed textually goal considered clause selection inconsistency local information detected attempting commitment operation 
means clause example detect inconsistency head uni cation create local copy argument long permission 
note applies rst alternative semantics commitment permission commitment 
allow delay determination immediate argument value may determined late commitment completed 
question allowed delay information related semantics uni cation concurrent prolog discussed section 

access local global information problem arises allowing local global copies variable copies access cases variable goal textually marked read 
variable goal textually marked read local copy 
variable goal textually marked read local copy 
rst possibility goal variable marked read textually 
candidate clauses watch global value 
necessary making suspended uni cation succeed putting computation forward 
variable local copies created exceptional case shown bindings directly read variables goal clause head guard 
exists pathological case local copy created read variable 
consider example goal 
program true 
predicate uni es arguments 
rst instantiated ways global instantiation goal running parallel local instantiation goal 
second case local copy appears readonly annotation created 
note goal locally instantiate rst argument goal textually speci es arguments identical annotation identity respected clause selection concluded section 
example illustrates suspension uni cation due goal variable marked read may resolved ways globally locally 
generally inadequate wait global instantiation read variable waits 
second contained goal marked read textually clause created local copy 
case clause see local copy 
ignoring seeing global counterpart suspend uni cation succeed 
clear clause allowed see global value may get instantiated local copy created 
paragraph disallow possible clause solve guard global value variable local copy 
third possibility variable contained goal textually marked read local copy created 
divided subcases variable uninstantiated head uni cation starts 
variable non variable read head uni cation starts 
case possible interpretations clause watch global instantiation 
clause ignore 
clause ignore 
paragraph support alternative case alternative case 
consider case rst 
alternative implies value variable goal read non variable goal called ignored 
instance program 

true 
succeed long called executed 
adopt alternative case 
case value variable goal ignored 
protected data technique hellerstein shapiro takeuchi furukawa correctly 
typical read annotation attach argument variables goals consume decompose value variables 
protection instantiation consumer achieved making generator data structure protect uninstantiated part protected data mean uninstantiated protected variables created generator 
technique read annotations appear textually consumer goal top level sent generator goal 
dynamic protection ignored alternative says technique 
cases occur depending relative timing head uni cation instantiation variable goal goal 
head uni cation instantaneous operation undesirable assign mutually exclusive behaviors cases 
alternative better choice case 
claim alternative undesirable understood justi ed observation 
clause 
succeed textually speci ed argument value ignored 
means partial evaluation clause get clause undesirably changes semantics program suspension success 

atomic operations uni cation semantics uni cation clearly state atomic operations 
consider uni cation 
uni cation performed assuming uninstantiated 
possible solutions may create term manner 
set term 
create term fresh variable 
set term parallel set 
create general unary term principal function symbol 
call argument part operation 
set term parallel set 
alternative regards uni cation variable non variable term indivisible operation 
alternative tries allow principal function symbol arguments determined parallel protects non variable arguments read annotation 
alternative states uni cation done speci ed follows 
variable appearing 
explain di erences alternatives words 
alternative says principal function symbol value variable determined values arguments determined long speci ed place principal function symbol 
alternative says argument values may come uninstantiated fresh variables appearing transient state protected 
alternative says arguments may come variables protected 
note uni cation non variable terms conceive alternatives corresponding ones 
granularity atomic operations smallest alternative largest alternative 
alternative best high parallelism criterion 
see section concurrent prolog adopt alternative 
parallelism uni cation 
known uni cation problem sequential nature general parallelism signi cantly help dwork kanellakis mitchell 
result discourage nding formulation uni cation parallel logic programming languages 

smallest granularity alternative seen section information textually speci ed goal available head uni cation commences 
put di erently goal called arguments loaded 
clause 
clause 
de ned di erent 
word di erent strong say clause restrictive clause 
di erence related semantics uni cation goal clause head section regarded claiming goals di erent head 
head 
claim clearly rejects alternative 
example better show importance information textually speci ed goal 
wehave attached read annotation simply instantiated want predicate respect value clause selection clause selection done argument value 
rewrite clause 
read property inherited uni cation 
important concepts programming languages referential transparency means expressions denote value context textually replace program referential transparency logic programming languages require property term appears goal replace fresh variable conjunction goal put new goal uni es 
example shows property hold concurrent prolog 
long claimed logic programming languages provide framework mechanical handling programs program synthesis program transformation 
properties referential transparency respected possible 
losing language rules complex mechanical handling programs dicult 

alternatives alternative means follows 
determination principal functor setting arguments done parallel principal functor determined arguments accessible protected necessary instantiated 
solution looks consistent requirement information textually speci ed goal respected clause selection retaining parallelism inherent uni cation 
examine detail 
problem solution ad hoc exploits limited part parallelism lost alternative 
arguments lled non variable terms protected read annotations 
means protect arguments example 

de ned identical 
clause textually speci es arguments identical clause moved information goal 
clause select clause 
reduce clause 
clause identical 
protective 
clause select clause 
clause 
considering problems alternative best solution concurrent prolog 
value principal functor available textually speci ed information arguments available 
means sequentiality assumed uni cation 
result urges examine semantics called feature call ing term say goal 
goal possibly incrementally generated goal 
wemust means guarantee argument information assumed textually speci ed goal set serialization commit operator purpose 
examples illustrate 
goal 
program call 
goal call 
program true 
examples possible regard having value right commitment 
goals call call de ned speci ed textually 
generalize value variable guaranteed exist right commitment treated textually speci ed value 
guaranteed exist value formed bindings uni cations guaranteed nished language rules 
readers may think discussion obvious case 
clause value determined commitment uni cation 
seen far clear principal functor arrives goal call atthe time 
depends semantics commitment semantics uni cation delicate 
far wehave de ned semantics uni cation involving non variable terms 
de ne property logical variables 
tempted de ne semantics goal 
equivalent 
logically identical 
de ning goals identical means communication shared logical variables may potential delay 
delay allowed guarded horn clauses described chapter concurrent prolog allowed 
firstly shapiro assume delay shared variables contains speci cation binary merger follows recursive clauses shown goal merge bs cs 
program merge xs ys zs merge ys xs zs 
merge xs ys zs merge ys xs zs 
allow delay rst argument ys body goal clause instantiated head argument xs clause recursive call 
delay instantiated ys uni ed bs 
head uni cation 
secondly protected data technique assumes occurrences shared variable 
information protection delayed violated 
wemust assume delay shared variables occurrences variable denote value time 
consider allowing delay shared variables possible considerably change rules concurrent prolog amount designing language 

processing heads guards clearly speci ed kind parallelism allowed processing heads guards 
regard semantics concurrent prolog shown section shapiro takeuchi problems 

head uni cation rules concurrent prolog mention order uni cation head arguments 
solutions candidates head uni cation performed parallel 
pseudo parallel implementation allowed sequentiality assumed conceptually 
head uni cation performed sequentially order de ned language 
implementation arbitrarily choose possible orders 
program depends particular order erroneous 
mixture 
head uni cation performed sequentially order parallel 
program depends particular strategy erroneous 
head uni cation performed sequentially left right 
solution preferred sequentiality language rule minimized principles stated section 
set possible results execution program remain unchanged systematically change order arguments predicate program goal clause 
result mentioned may include computation terminates terminates succeeds succeeds bindings variables goal clause 
solution uences allowable implementations sequential uni cation left right inadequate 
consider example goal 
program 
left right head uni cation suspends rule states succeed 
fact implementation head uni cation assumes speci order inadequate 
example speci order goals succeed goal 
goal 
program 
note arguments apply uni cation performed computation example uni cation commitment see section 

head uni cation guard execution rules concurrent prolog specify execution guard start head uni cation succeeded section paragraphs 
propose di erent solution head uni cation execution guard done parallel 
reasons follow 
consider example goal 
program true 
program true 
program 
shapiro program succeeds program suspends 
program suspends uni cation performed uni cation succeeded 
result speci ed 
uni cation arguments allowed performed sequentially program may suspend uni cation performed parallel recommended section succeeds 
programs identical 
propose de ne standard form programs succeed 
standard form clause head arguments distinct simple variables 
clauses considered shorthand 
justi cation proposal clauses logically identical 
de ning semantics clause terms standard form simplify description semantics 
similar approach adopted parlog clark gregory 
proposal justi ed practical clause performs head uni cation executes guard determine selected 
looking back programming style usually write head write head guard write guard write head 
example syntactic check input argument example arithmetic comparison input values 
far see choice solely content check 
program written fact head uni cation precedes execution guard 
reason head uni cation argument passing head uni cation concise description 

uni cation read variables paragraph explicitly state semantics uni cation readonly variables 
took subject argued clause 
allowed head uni cation invoked call 
succeed 
proposed possible revisions uni cation read variables 
succeed identical non read variables 
disallow read variables appearing head 
solutions desirable assume 
executed 
executed rst identical non readonly variable 
means annotated variable 
instantiated partner uni cation execution inconsistent general property annotated variables 
says read variable head useful applications hellerstein shapiro takeuchi furukawa prohibited 
disallowing read variables head destroys symmetric nature uni cation 
alternative solution uni cation readonly variables succeed identical read variables 
preserves nature read annotations 
consider goal 
goal suspends executed rst succeeds 
new undesirable kind nondeterminism arises order uni cation source nondeterminism commitment operation 
shapiro original interpreter uni cation read variables suspend 
solution looks better alternatives aida unpublished tanaka unpublished claimed uni cation identical read variables succeed 
tanaka implemented concurrent prolog tanaka miyazaki takeuchi inconvenient goal 
suspends goal 
succeeds 
best solution uni cation read variables suspend read variables identical case succeed 
consequence slight revision implementation complicated little bit 
revision suspension released read variable caused suspension gets instantiated non variable term 
suspension released read variable caused suspension uni ed variable long suspension caused uni cation read variables 
consider goal example 
goal suspends uninstantiated identical 
way release suspension instantiate non variable terms 
claim way release suspension unify means suspended goal watch bindings uninstantiated variables non variable terms 

predicate predicate rst introduced shapiro takeuchi 
goal occurs guard succeeds parallel guards fail 
commonest construct sole guard goal clause handles default exceptional case 
simple rule restrictive implies appear clause clause order clauses constituting program 
need appear sole goal guard 
guard clause containing contains goals clause may selected clauses failed 
clause cover exceptional cases restricting clause head general reasons restrict form clause 
possible restriction prohibit goals guard harmless useless 
appear guard 
assume clauses contained de nition nil 

cons 

clauses proved 
rst nil clause selected clause 
rst argument form cons clause selected 
course clauses mutually exclusive goals guards deadlock may result 

responsibility programmer avoid deadlock 
original de nition may look general recommended simplicity 
easy implement needs monitor number failing clauses succeeds reaches number clauses 
know construct useful writing non trivial programs examine generality stated really useful 

summary discussed subtle points concurrent prolog 
section examined semantics multiple environments commitment operation 
showed de ne things timing uni cation local global information values goal arguments clause heads guards access rule local global copies variables section examined semantics uni cation allowed communication occurrences shared variable 
non variable term say speci ed source text indivisible nature uni cation variable done atomic action 
put di erently assume sequentiality uni cation 
occurrences variable denote value time 
assume delay shared variable instantiated goal value referenced goal 
mean transformation program clause allowed declarative reading semantics 
section considered execute head uni cation corresponding guard 
section examined semantics uni cation read variables 
section examined semantics predicate 
noted arguments section apply flat concurrent prolog taylor shapiro levy safra 
flat concurrent prolog di erent concurrent prolog prede ned test predicates allowed guards 
management nested environments longer necessary implementation sequential machine greatly simpli ed doing clause selection indivisible operation 
flat concurrent prolog removes need multiple environments conceptually head uni cation may instantiate global variables 
flat concurrent prolog intended language parallel machine resolve problems discussed section 
results chapter helpful de ning precise semantics concurrent prolog 
resulting semantics complex de ned informally require considerable orts formal semantics 
alternative research direction revise language 
language guarded horn clauses described chapter designed direction 
abolished multiple environment mechanism read annotations time simpler language slight loss expressive power 
chapter guarded horn clauses examined section set horn clauses allows procedural interpretation kowalski 
semantics sequential programming language prolog prolog proved simple powerful ecient sequential programming language warren pereira pereira 
kowalski points discussed section horn clause program allows parallel concurrent execution sequential execution 
discussions sections revealed set horn clauses stands inadequate parallel programming language capable expressing important concepts processes communication synchronization input output 
need control parallelism mechanism express concepts 
mechanisms proposed surveyed section chapter shows construct guard adequate purposes 
chapter introduce guarded horn clauses 
name guarded horn clauses abbreviated ghc name language 
describe design principles syntax semantics program examples justi cation language design 
mention possible extensions implementation issues 
comparison ghc logic parallel programming languages chapter 

principle oriented approach language design design programming language possible approaches 
implementation oriented approach 
practical language allow ecient implementation existing hardware 
contain feature implementation hard impossible intended hardware important constraints design ecient language 
application oriented approach 
speci application domain hand desire language problems solved elegantly formulated 
third approach called principle oriented approach 
principle oriented approach rst establish principles constraints language features designed 
course principles include implementability applicability point language design external internal constraints important solely programming language point view 
example theoretical language rigorous mathematical foundation general purpose language provide general language huge software facilities declaring inter module speci cation checking language self consistent include features ects ects interaction de ned 
principles provide language designer basis design review compare languages 
help language user understand language feature designed missing 

design principles goal obtain programming language expresses parallelism allows parallel execution possible 
base language logic resolution principle hope assumption leads solution 
language expected ful ll requirements 
parallel programming language nature 
sequential language augmented primitives parallelism 
language assume little sequentiality primitive operations possible order preserve parallelism inherent horn clause logic 
lead clearer formal semantics ecient implementation novel architecture 
note formulation underlying concepts described theoretical books parallelism 
example robinson uni cation algorithm robinson sequential books mechanical theorem proving usually say resolution done parallel 
examined parallel execution logic programs section 
remarks related implementation 
firstly requirement parallelism requirement level programming language require parallelism exploited implementation 
desirable compiler sequential computer generates sequence codes set operations need executed pseudo parallel 
sequentiality implementation considered optimization framework parallel languages see section 
truly parallel language mayhave allow possibly useless computation 
impossible distinguish useful useless computation assuming speci implementation allow unrestricted parallelism 
example prefetching instructions done processor unit 
prefetched instructions may just discarded branch instruction executed usually source eciency prefetching considered generally useful 
disallow useless computation computation highly sequential lose eciency original purpose parallelism 
computation may ective allowed 
generally judge computation may utilized allow computation long harm 
go principle 
expressive general purpose parallel programming language 
particular able express important concepts parallel programming processes communication synchronization 
program able communicate outside world especially human beings 
explained section human computer communication important communication computer desirable treat uniformly principle 
simple parallel programming language 
experience theoretical pragmatic aspects parallel programming 
rst establish foundation parallel programming simple language 
accustomed parallel programming languages parallel programming 
author short experience programming concurrent prolog shown parallel programming easy experienced sequential programming 
hard expect implied interaction complex language rules 
language commit existing computer architectures 
leave unde ned control mechanism relevant eciency 
language allow ecient implementation computer current technology 
lot simple typical problems described language complex ones 
important programs run eciently comparable ones written existing parallel programming languages 
eciency simple programs important property general programming language 
requirement simplicity possibly interfere eciency useful programs important pragmatics implemented eciently linguistic support 
meaningful identify interesting subclass language pragmatics eciently supported get speci ecient language 
reservation subsetting done eciency purposes program subset program 
subsetting said undesirable 
need expressive language ecient language better choice design expressive language rst appropriately restrict get ecient language 
dicult design ecient rst extend naturally 
language speci cation satisfy general principles 
language features implementable hard implement 
rules exist blame laid language speci cation 
rules possible violation easily detected compile time run time 
promote erroneous programs circulate 
speci guidelines 
stated section base language logic resolution principle try utilize previous results logic programming parallel logic programming 
try preserve properties original framework logic programming permitted guidelines 
example logical transformation program clause preserve semantics maximal extent 
preserving underlying formalism desirable sense meets requirement simplicity 
consider input output boundary condition language design 
speci cally apply basic idea logic programming predicate de nes relation data program internal procedures mechanism interprocess communication human computer communication 
points discussed sections 
item claims input output performed means streams 
item claims communication data determinate 
note proposing basic concepts complete programming language practical language computational model sense 
believe proposal provide basis programming language describing large software 
issues user oriented language features discussed section 

syntax ghc program set guarded horn clauses form 
atomic formulas de ned section 
called clause head called guard goals called body goals 
connectives common ordinary horn clauses 
di erence horn clauses conjunctive operators replaced commitment operator 
part clause called guard part called body 
note clause head included guard 
declaratively commitment operator denotes conjunction guarded horn clause read implied 
start ghc program goal clause form 
changes original framework 
nullary predicate true denoting empty set guard body goals explicitly program 
notational convenience need considered primitive 
de ned follows true 
binary predicate prede ned language 
predicate unifying terms 
predicate considered prede ned de ned language syntactical reason 

semantics semantics ghc quite simple 
roughly speaking execute program refute section goal clause means parallel input resolution section clauses program 
course adaptations syntactical changes 
firstly proof tree constructed parallel input resolution arc corresponding guard goal body goal clause represented parent node 
de ne prede ned predicate treated de ned ordinary horn clause semantics guard restricting parallel input resolution 
simplest way meet requirement section treat construction proof trees single environment independently 
disallow uni cation proof trees instantiate variable di erent values 
substitution applied variable common global execution program 
toachieve goal letting language useful impose rules suspension rules suspension uni cation invoked directly indirectly guard clause called goal uni cation head uni cation invoked executing guard goals instantiate see section goal 
uni cation invoked directly indirectly body clause instantiate guard clause selected commitment see 
piece uni cation succeed making bindings suspended succeed making bindings rules suspension 
rule rule commitment 
clause called goal succeeds solving see guard clause tries selected subsequent execution proof 
selected rst con rm clauses program selected 
con rmed selected execution said committed clause 
wesay set goals succeeds solved proof procedure succeeds constructing non ordered refutation non root nodes represent selected ordinary clauses 
say solved proof procedure constructs non ordered refutation non root node representing non selected clause interested proof selected clauses involved 
notion failure introduce 
point discussed section 
stressed rules stated done parallel conjunctive goals solved parallel candidate clauses called goal compete parallel commitment uni cation goal head candidate clause done parallel internally execution guard goals 
stressed execute set operations predetermined order long change meaning program 
possible di erence sequential parallel execution sequential execution may fail solve set goals solved parallel execution 
serialization allowed possibility 
note spite notes parallelism instantiation variable course done indivisible operation properties uni cation longer hold 
selection clause commitment done indivisible operation 
rules suspension restated follows guard clause export bindings bindings observable caller clause body clause export bindings bindings observable guard clause clause selected commitment 
rule synchronization called rule synchronization 
rule tricky states execute body non selected clause result may prove useless 
restrictions guarantee look ahead computation ects selection candidate clauses goals running parallel caller clause 
rule ectively rule sequencing guard body clause 
compare rules ghc concurrent prolog discussed section 
concurrent prolog uni cation performed guard including head export bindings succeed recording resultant bindings locally 
ghc uni cation simply suspends 
suspension uni cation may released variable caused suspension bound variable non variable term bythe uni cation invoked body selected clause 
example may helpful understanding rules suspension 
consider program goal clause 
program clauses ok true 
true ok 
goals clause executed parallel assume executed rst 
uni cation attempted goal head ok clause uni cation instantiate constant ok invoked guard clause wait instantiated ok goal 
hand goal uni ed head clause instantiating clause selected goal ok instantiates ok 
head uni cation clause succeeds clause selected 
short clause selected goal ok executed matter goals clause starts rst 
goal acts producer value goal acts consumer 
introduced causality logic programming 
semantics program carefully understood goal clause 
program clauses 
true ok 
solve guard clause things parallel unifying parameter passing solving 
rst assume parameter passing executed rst 
goal ok tries instantiate identical ok 
suspend indirectly invoked guard clause 
consider case goal executed prior parameter passing 
variable successfully bound ok export binding goal 
binding subsequent parameter passing suspend bind ok 
matter case happens clause behaves equivalently clause binding variable 
important properties section list important consequences semantics 
uni cation intended export bindings caller clause head arguments speci ed body clause 
uni cation speci ed prede ned predicate 
programming style ghc di ers prolog point 
uni cation clause head caller may need executed parallel 
executed sequentially predetermined order 
require justi cation 
suces show uni cation clause head caller suspends trying binding variable sequential execution succeed parallel execution instantiated term 
consider frozen counterpart 
frozen counterpart expression respect variable expression obtained instantiating fresh constant 
sequential uni cation data ow restriction fails obviously 
success failure ordinary uni cation depend speci algorithm employed correct parallel uni cation algorithm fail unify 
parallel uni cation data ow restriction obvious counterpart ordinary parallel uni cation detects suspension failure detects failure 
means succeeds left uni cation head clause caller execution guard goals executed parallel 
execution guard goals start head uni cation completed 
usual way execution solves guard goals head uni cation allowed 
rst half obvious de nition parallel input resolution 
second half shown manner consequence outlined 
proof tree solve guard goal de nes set equations solved conjunction head uni cation instantiating caller 
di erence proof consequence set equations solved expanded guard goals 
consider frozen counterpart caller clause justify sequentiality head guard goals 
execution body clause may need start clause selected commitment 
explained section 
need implement multiple environment mechanism mechanism binding variable value 
mechanism general necessary candidate clause goal tried parallel 
ghc avoids allowing clause selected clause export bindings caller 
restriction reasons operational semantics ghc incomplete theorem prover discussed section 
unfortunately consequences hold weintroduce concept failure see section 

program examples section illustrates example programs 
section chapter shows program possibly automatically search problems ghc 

binary merge merge xs ys zs true zs zs merge xs ys zs 
merge xs ys zs true zs zs merge xs ys zs 
merge ys zs true zs ys 
merge xs zs true zs xs 
goal merge xs ys zs merges streams xs ys implemented lists stream zs 
typical nondeterministic programs xs ys instantiated element stream may appear rst zs 
language rules ghc state selection clauses fair 
implementation may choose rst clause rst second clauses selectable 
implementation elements xs ys expected appear zs order arrival 
fairness problem csp hoare 
note declarative reading program gives usual logical speci cation nondeterministic merge arbitrary interleaving streams output stream 
di erence ghc program logical speci cation ghc program expresses direction computation causality logical speci cation 
di erence execution mechanism ghc chooses value zs arbitrary possible interleavings xs ys compute 

generating primes primes max ps true gen max ns sift ns ps 
gen max ns gen max ns max ns 
sift xs zs true zs zs filter xs ys sift ys zs 
sift zs true zs 
filter xs ys mod filter xs ys 
filter xs ys mod ys ys filter xs ys 
filter ys true ys 
goal primes max ps returns ps stream primes max 
stream primes generated stream integers generated gen max ns ltering multiples primes 
purpose goal filter xs ys generated prime lters multiples stream xs yields ys 
integers xs guaranteed non multiples prime rst prime succeeding obtained new lter goal created cascaded 
note program simple minded 
example goal fil ter xs ys need lter nds input stream xs integer greater 
binary predicate evaluates right hand side operand integer expression uni es result left hand side operand 
binary predicate evaluates operands integer expressions succeeds results 
predicates replaced predicate evaluates arguments 
predicates comparison meanings obvious 
predicates provided system predicates need think de nable language 
example enumerate clauses expressing possible input output relations include true 
true 
true 
true 
true 
predicate de ned true ab 
predicate de ned enumerating clauses form true true 
denote non identical integers 

generating primes demand driven computation primes ps true gen ns sift ns ps 
gen ns true gen ns 
gen true true 
sift xs zs true xs xs filter xs ys sift ys zs 
sift xs true xs 
filter xs ys true xs xs filter xs ys 
filter xs true xs 
filter xs ys mod filter xs ys 
filter xs ys mod filter xs ys 
ask ios ps true ios read ios ask ios ps 
ask ios ps ps ps ask ios ps 
ask ios ps ask ios ps 
ask ios ps ask ios ps wait ios write nl ios ask ios ps 
test true ios ask ios ps primes ps 
program illustrates general statement demand driven computation implemented means data driven computation 
version prime generator program section user interface 
program section data driven means control generation ps prime max ps called 
requires upper bound primes generated prior execution 
hand predicate primes demand driven version generates primes demand 
examine program 
goal primes ps executed ps passed second argument goal sift ns ps 
predicate sift examines second argument ps guard head uni cation suspends ps instantiated goal ask ios ps 
goal gen ns suspends second argument ns 
assume ps instantiated form 
rst clause sift selected goal sift ns ps instantiates xs ns 
rst clause gen selected goal gen ns instantiates value rst element ps 
seen outside goal prime ps lls undetermined element list structure new prime create skeleton list structure 
instantiation sublist ps form regarded demand goal prime ps 
program provides user interface goal ask ios ps run prime generator explained 
goal ask ios ps reads integer terminal sends demands prime ps goal displaying obtained prime sending demand reads new integer 
declarative input output predicate provided compiler described section 
predicate takes stream input output commands argument read reading integer write displaying integer nl new line 
commands processed order appear stream precise control input output 
goal ask ios ps reads negative integer closes argument streams ios ps terminates 
important notice follows program full control generation primes program viewpoint eciency lost parallelism inherent data driven version 
eciency allow possibly useless computation extent 
way bounded bu er technique described section 
way give fully demand driven computation incorporate data driven program mechanism controlling generator integer stream 

bounded bu er stream communication test true buffer hs ts ints hs consume hs ts 
buffer hs ts hs hs buffer hs ts 
buffer hs ts ts hs 
ints max hs ints max max eos 
consume hs ts eos ts ts consume hs ts 
consume hs ts eos ts 
program shows program bounded bu er ghc idea rst shown furukawa logic programming framework 
goal ints hs demand driven generator stream hs integers 
demands generated goal consume hs ts tries keep unanswered requests issued 
purpose notion di erence list 
goal buffer hs ts initially generates di erence list length head tail hs ts respectively 
goal consume hs ts receives head tail instantiates current tail uninstantiated part stream new element hs obtained examined guard consume 
binary predicate negation predicate 
succeeds arguments turn able suspends 
predicate need thought prede ned 
term able constant eos prepare clause eos true true 
general term principal function symbol distinct eos 

meta interpreter ghc call true true true 
call true call call 
call true call true clauses clauses resolve clauses body call body 
resolve cs melt new call 
resolve cs resolve cs 
program basically ghc version concurrent prolog shapiro 
predicate clauses system predicate returns frozen form nakashima ueda list clauses heads potentially uni able goal omit program clauses turned forever simple implementation may return program clauses 
frozen clause ground term original variables indicated fresh constant symbols called frozen variable connectives represented corresponding function symbols guard rst clause resolve melt new 
goal melt new creates new term say frozen term giving new variable frozen variable tries unify 
predicate resolve tests candidate clauses returns body arbitrary clauses guards successfully solved 
arbitration realized nest binary clause selection performed predicate resolve 
essential candidate clause guard rst clause resolve 
passed guard variables protected instantiation guard 
minor problem meta interpreter allow body candidate clause executed clause selected contrary semantics section levy 
body selected clause call ed body fourth clause call 
discrepancy due syntactically restrictive way provided function commitment 
course practically problem 

primitive operations ghc section remarks primitive operations ghc 

resolution ghc uses parallel input resolution section basic computational mechanism 
resolution usual sense robinson contains selection program clause head uni cation goal rewriting parallel input resolution reveals need form indivisible operation 
head uni cation executed parallel newly created goals 

uni cation anti substitutability ghc allows equations appearing computation executed parallel actual implementation may exploit sequentiality 
examine considered primitive operations uni cation 
set equations consider new set equations obtained replacing occurrence term fresh variable 
reverse operation may appear uni cation algorithm may called substitution call transformation anti substitution 
clearly anti substitution change solution general substitution substitutions simultaneously solves equations solution binds de ne anti substitution guarded horn clause similar way 
program clause anti substitution new clause replacing occurrence term guard body fresh variable adding goal guard body respectively 
transformation change result program change answer substitution causality bindings 
suces show anti substitution ect restriction parallel input resolution imposed ghc obviously ect result original parallel input resolution binding 
divided cases case term clause head replaced case term guard goal body goal replaced 
firstly assume head clause rewritten goal added guard yielding new clause clause selected caller wemust solve conjunction guard goals instantiating 
clause selected caller solve conjunction original guard goals instantiating 
considering frozen counterpart see section case suspension understood clause selectable clause selectable 
secondly assume goal rewritten conjunction goals 
di erence explicitly states bindings necessary select clause may postponed eventually transition candidate clauses instantiates rules suspension 
rewriting ect selection clause 
note anti substitutability holds goal clause program clauses 
meets requirement section 
considered kind referential transparency logic programming framework discussed section 
anti substitutability helpful considering primitive operations uni cation ghc 
natural admit anti substitutability operationally declaratively computational mechanism left implementation long brings correct result 
admit consequences follow goal equivalent instantiated ground term instantaneously 
conjunction communicating goals equivalent conjunction 
occurrences original conjunction may value time observer 
words communication shared variable mayhave potential delay 
item pointed hagiya 
consequences suggest freedom implementation 
course actual set primitive operations determined uni cation algorithm employed 
consequences provide reason extralogical predicates var prolog sense ghc 
anti substitutability facilities proposed clark gregory semantical problem 
argument call goal result tries solve goal possibly generating output bindings uni es result succeeded success failed failure 
wehave introduced notion failure problem introducing uni cation goals 
consider example sato sakurai call 
rst goal executed rst 
uni cation fails clause 
second goal executed rst 
rst goal fails clause succeeds 
new kind nondeterminism resulting order uni cation feature nondeterminism result arbitrary choice selectable clauses 
consider example call call 
anti substitutability rewrite goal clause call call 
rewriting shows failure uni cation con ned call 
failure creep goal 
means facilities proposed clark gregory protect system program unpredictable behavior user program 

commitment body clause selected commitment free data ow restriction rules suspension 
restriction need released selection clause 
may released commitment parallel execution body goals 

process interpretation ghc ghc considered simpli cation previous parallel logic programming languages close relationship programming languages categories 
example viewed generalization nondeterministic data ow languages communicating sequential processes hoare 
section shows ghc provides exible framework describing processes communication synchronization 
detailed comparisons programming languages chapter 
program clause ghc viewed rewrite rule goal clause prolog 
example consider rst clause merge shown section merge xs ys zs true zs zs merge xs ys zs 
clause claims rewrite caller body goals caller satis es certain condition speci cally rst argument caller instantiated form 
generally speaking goal sucient bindings conjunctive goals reduces set goals doing generates new bindings 
conjunctive goals viewed processes interacting means bindings shared variables 
process interpretation ghc correspondence system processes conjunctive goals process goal process state set arguments goal computation goal rewriting uni cation communication instantiation shared variable uni cation goal body observation generated binding uni cation guard synchronization rule synchronization choice nondeterminism rule commitment possibly recursive de nition process predicate note process reduced processes need think disappeared process committed remaining tasks processes continues exist conceptually subprocesses terminated 
process interpretation logic rst van emden de lucena shapiro context concrete programming language 
ghc allows process interpretation naturally clearest notion causality logic programming languages 
ghc process description language unique feature exibility 
allows dynamic generation deletion processes including recursive process generation 
allows dynamic creation data structures 
allows demand driven computation data driven computation 
declaratively handle mutable objects arrays databases implementing processes transaction streams interface see section 
ghc uses shared variables communication communication scheme quite di erent shared variable communication procedural languages 
procedural language requires complex mechanisms protocols synchronization communication variables single assignment property 
ghc variables hand single assignment property values determined possibly gradually computation proceeds change non monotonically 
necessary synchronization information known value variable 
synchronization availability data basic idea data ow languages 
availability treated binary information early data ow languages ghc provides general uniform information structure term naturally contains notion availability data 
ghc uses shared variables communication message passing paradigm writing ghc program ghc expressive model message passing single assignment property variables 
ghc ancestors viewed proposing new computation communicational model hard categorized existing models 
hoped simplicity ghc accepted parallel computational model programming language 

justi cation language design ghc designed adapting horn clause logic resolution principle parallel programming language 
ghc interpretation apart original framework logic programming showed section meaningful try justify adaptation logical formulae express causality computation obviously connotes direction 
unnatural programming language notion direction causality 
result computation constructed uni cation logic programming natural way introducing causality introduce uni cation operations 
bindings variables determinate reason shown section 
candidate clauses goal instantiate goal candidate 
possible employ generous method rules suspension guarantee determinacy author quite doubtful increase expressive power loss simplicity 
addition rules suspension wemust rule allowing clause export bindings order construct result computation 
need mechanism select clause reasonably 
employed rule commitment involves nondeterministic choice purpose 
nondeterministic choice necessary interface outside world obliged treat nondeterministic clinger 
interaction outside world nondeterminism necessary front shared service process manager internal symbols serves clients order arrival requests 
success choice nondeterminism success failure see section closely related fact semantics ghc de ned notion failure 
computation proceeds positive information 
adaptation operational semantics ghc lost completeness theorem prover horn clause logic course retains soundness 
incompleteness introduced satisfy requirement determinate bindings reason eciency shapiro gregory state 
note ghc incomplete general complete respect nontrivial class programs goals identi ed 
semantics guard construct powerful express synchronization conditional branching choice nondeterminism contributes simplicity language 
relational language clark gregory rst introduce guard concept logic programming purpose similar ic prolog clark mccabe rst introduce guard concept logic programming purpose di erent 
ghc removed restrictions guard relational language mode declarations annotations 
note notation introduced expressing guards arbitrary 
employ notation long distinguish restricted unrestricted uni cation directly indirectly invoked clause 
example specify rst clause merge merge xs ys zs merge xs ys zs 
prede ne predicate italicized part indicates uni cation performed commitment 
justify lack sequentiality ghc 
deliberately excluded sequentiality programming experience concurrent prolog called construct 
may think speci cation scheduling synchronization 
primitives scheduling introduced di erent level ghc sequentiality synchronization computational model ghc allows anti substitutability 

possible extensions treatment failure section consider nite failure ghc 
semantics ghc described section introduce concept failure 
meaningful result computation constructed successful subcomputations result may exist 
ghc commit closed world assumption gallaire minker 
assume program open ended selectable clause goal regard provided 
idea coincides idea incomplete data structures convenient handle programs data 
idea coincides idea regarding system predicates de ned possibly nite program clauses sections 
note idea ectively query user facilities sergot 
may convenient assume closed world program speci predicate 
doing introduce predicate discussed section sequentiality parlog clark gregory expressing default clauses 
predicate appear guard goal 
goal succeeds program clauses turn non candidates see 
finite failure recursively de ned follows goal form fails principal function symbols di erent form form function symbol goal fails 
goal form fails clauses closed program turns non candidates 
clause said non candidate goal fail 
unfortunately notion failure restricts exploitation sequentiality mentioned section 
consider example due gregory goal clause false 
program clause true true true true 
head uni cation fails arguments uni ed pseudo parallel suspends forever uni ed sequentially left right 
awkward example due chikayama miyazaki unpublished shown goal clause false true 
program clause true true 
assume uni ed 
head uni cation suspends second argument bound false go third employ pseudo parallelism 
uni cation third argument suspends reason 
erroneous execution scheme false true uni ed matter bound 
ability detected uni cation done right left 
generalize variable able terms uni ed guard failure detected instantiated 
need mechanism capable detecting ability instantiating 

implementation synchronization mechanism section considers implementation rules suspension speci cally rule synchronization 
course implementation issues considered particularly parallel implementation 
parallel implementation included works diculty recognized researchers 
regards sequential implementation section describes ecient compiler compiler allow calling user de ned predicates guard 
purpose section show ideas implementation full ghc 
easy understand possibly inecient method pointer coloring 
term goal variable guard clause uni ed color pointer indicates binding 
binding term dereferenced colored pointers 
clause selected colored pointers created guard uncolored 
purpose guard clause record pointers colored guard 
done parallel operations body stated section 
care taken term goal uni ed variable guard dereferenced colored pointers 
consider example goal clause 
program clauses 
true 
directly point term colored pointer selection clause erroneously instantiated constant 
couple possible remedies disallow pointers go directly nested guards chain pointers 
pointer know guards goes 
miyazaki pointers may go directly nested guards 
colored pointer know guard colored 
directly pointing term obtained dereferencing colored pointers new pointer recorded guard records colored pointer dereferencing chain 
cases statically analyze suspension need colored pointers 
simplest case clause true clause head claims argument caller true select clause 
statically generate code check need colored pointers 
general guard calls system predicates simple checking integer comparison compile time analysis easy consideration needed clauses 
hand calls user de ned predicate global analysis necessary determine uni cation may suspend uni cation 
general method static analysis useful cases static analysis compile time mode analysis clark gregory ective 

summary works proposed parallel logic programming language guarded horn clauses 
design principles syntax semantics important properties programming examples primitive operations interpretation process description language justi cation design possible extensions implementation rule synchronization described 
review language design general design principles section 
firstly tried rule sequentiality semantics possible 
rule sequencing described part rules suspension contributes uniformity 
time tried retain possibilities exploiting sequentiality actual implementation 
important ecient implementation sequential computer communicating sequential computers 
secondly demonstrated section ghc expressive describe data driven demand driven computation er communication meta interpreter ghc 
addition showed ghc viewed general powerful process description language section 
thirdly tried keep language simple possible relating semantical guard construct 
de ned semantics terms original logic programming framework keep language independent speci architectures implementations avoid inessential details creep 
immediately concluded ghc eciently implemented parallel computers 
eciency ghc owes research language implementation 
say ghc favorable concurrent prolog implementation discussed chapter 
applications eciency primary issue little exibility needed design restricted version ghc allows subclass ghc introduces declarations help optimization 
stated section variant properties additional constructs eciency purposes program variant readable ghc program additional constructs removed source program 
works language implementation related control issues system programming 
include notations helping implementation perform eciently time space facilities writing programming systems tracers debuggers notations exception handling better treatment fairness nondeterministic choice choice priority 
issues discussed detail section 
chapter comparison ghc programming languages models chapter compare guarded horn clauses programming languages computational models 

concurrent prolog ghc designed ort re ne concurrent prolog keeping programming paradigm possible 
result languages features common viewpoint programming process interpretation communication streams committed choice nondeterminism 
turns eyes semantical details nd ghc simpler concurrent prolog 
firstly concurrent prolog ghc read annotations 
ghc semantics guards enables process synchronization 
synchronization mechanism static easier analyze compile time 
incomplete messages specify demand driven computation 
technique abandoned protected data technique explained section 
ghc excluded protected data sense language assumes sequentiality transmission terms see section 
ghc sequentiality adopted anti substitutability section states complex term may treated atomic entity variable instantiated 
secondly concurrent prolog needs multiple environment mechanism ghc 
concurrent prolog bindings generated guard recorded locally commitment exported global miyazaki takeuchi chikayama 
language rules mechanism proved contain semantical problems solution require additional set language rules discussed section 
importantly evidence need multiple environments stream parallel programming 
multiple environment mechanism concurrent prolog may helpful detecting failure output uni cation prior commitment 
checking important write programs output uni cation succeeds 
checking incomplete adopt harder alternative semantics commitment described section 
third di erence ghc enjoys anti substitutability mentioned concurrent prolog synchronization mechanism 
complex term treated atomic ghc communication shared variable may potential delay see section 

parlog ghc similarities parlog concurrent prolog viewpoint programming 
parlog ghc requires mode declaration predicate 
mode declaration parlog guide translating parlog program kernel parlog clark gregory 
kind macro modes 
fact ghc similar kernel parlog parlog 
kernel parlog kind uni cation 
uni cation operation appearing ghc program compiled specialized uni cation procedures ghc needs 
di erence kernel parlog kernel parlog program requires compile time analysis order guarantee legal contains unsafe guard bind variables caller guard clark gregory 
gregory states safety check guard done run time intended parlog 
hand ghc program legal syntactically legal executed semantic analysis 
main source semantical simplicity ghc compared parlog 
wemust note ghc program executed eciently compile time analysis 
true ghc programs require nontrivial run time analysis piece uni cation generates disallowed binding expect programs seldom written 
expected class ghc programs parlog counterparts unsafe guard accepts compile time analysis 
example ghc prolog compiler described section disallows user de ned goals guards generates code suspension checking sequence prolog goals 
semantical point view ghc nearer parlog concurrent prolog 
result implementation techniques parlog ghc vice versa 
kernel parlog intermediate language ghc compiler 
output uni cation speci ed clause body implemented full uni cation principle uni cation ecient compile time analysis 
word parlog viewed realistic approximation specialization guarded horn clauses 
parlog couple features ghc 
notation set constructors eager lazy exhaustive search solutions horn clause programs 
possible incorporate similar notation user language ghc 
program user language compiled ghc technique described chapter 
features include sequential control extralogical predicates var 
features scope de nition ghc 
features mere control ect result computation introduced control metalanguage 
extralogical features studied 

sato sakurai functional language uni cation 
allows parallel evaluation corresponds parallelism logic programming languages result evaluation guaranteed irrespective particular order evaluation 
committed choice nondeterminism 
ghc independently developed look di erently glance suspension mechanisms introduced di erent motivations essentially 
counterpart ghc guard condition part construct bindings exported 
guard condition part conditional branching synchronization 
important di erence uses notion failure notion success conditional branching ghc uses 
discussed section failure easy implement correctly sequential machine dicult cases may pathological 
di erence related nondeterminism ghc 
committed choice nondeterminism sato sakurai suggest pursues church rosser property evaluation algorithm 
ghc applications include system real world peripheral devices 
ghc provides simpler disciplined user interface point 
ways returning result computation returning value evaluable expression returning argument variable expression 
ghc 
argued stronger language ghc senses notion failure allows functional abstraction allows dynamically construct function pass apply 
studied features essential writing program 

oc oc proposed hirata thought programming language simpli ed ghc 
oc thrown away guard goals guard consists clause head 
may wonder say comparison integers speci ed 
system predicates changed return constant indicating success failure conditional branching constant 
disregarding issue system predicates oc strict subset ghc 

communicating sequential processes csp compare ghc csp communicating sequential processes de scribed hoare 
choose csp described hoare computational model csp hoare proposal programming language 
ghc similar csp points encourage programming concept communicating processes 
input output regarded fundamental design language 
guard mechanism plays important role conditional branching nondeterminism synchronization 
pursue simplicity 
major di erence csp tries rule dynamic constructs dynamic process creation dynamic memory allocation recursive call ghc 
major di erence csp concept sequential processes ghc 
ghc program read specifying communicating parallel processes 
di erences come di erence design philosophy design csp ected current computer architecture ghc designed keeping independence ignoring implementation existing computers 
result ghc smaller set primitives uses uni cation input output assignment commands uses recursive call repetitive command 
guard mechanism guard ghc capability synchronization csp provides synchronization primitives separately 
csp ghc di erent manner communication csp employs synchronized communication ghc employs bu ered communication 
essential di erence communication scheme simulate 

sequential prolog comparison sequential prolog viewpoint logic programming languages viewpoint parallel programming languages 
ghc concepts order program clauses order goals clause 
ghc undoubtedly nearer horn clause logic point 
semantics prolog explain sequentiality discuss properties program termination 
ghc lost completeness theorem prover horn clause logic deliberately result compromise see section 
hand prolog lost completeness unconsciously depth rst search strategy 
hard straightforwardly describe semantics ghc framework rst order logic 
situation common prolog notorious important cut operator search strategy 
commitment operator ghc parallel cut operator simpler construct formal point view introduced disciplined way 
prolog features backtracking sequential implementation multiple environment mechanism 
hand ghc single environment language 
means implementation ghc needs trail stack operations 
problem prolog read write predicates prevents declarative reading program see section 
ghc longer need imperative predicates concept streams adapted input output 
large data structures arrays databases declaratively eciently handled transaction streams interface discuss section 

delta prolog delta prolog pereira nasr extension prolog allows multiple processes 
communication synchronization realized notion event 
underlying logic explains meaning events called distributed logic kind modal logic 
di erences delta prolog ghc delta prolog retains concept sequentiality cut operator prolog 
essential delta prolog utilized guaranteeing order events 
ghc stick features prolog peculiarities prolog 
parallel program delta prolog may look quite di erent comparable sequential programs delta prolog prolog 
hand class ghc programs unidirectional information ow pipelining easily rewritten prolog replacing commitment operators cuts class prolog programs deep backtracking predicates intended input output mode easily rewritten ghc 

computational models section compare paradigms provided ghc provided computational models 
shapiro detailed comparison concurrent prolog models 

data ow computation mentioned section ghc viewed exible process description language generalization data ow languages 
compare ghc detail conventional data ow computational model data ow graphs speci cally model described 
ghc called data ow language computation proceeds availability data 
translate data ghc program straightforwardly long data ow graph awkward notions mentioned 
data ow model kind process function realized ghc goal 
arc carries data represented avariable possibly shared goals 
note avariable may necessarily represent stream data stream necessary process sequence data 
stream merging considered primitive ghc de ned language 
ghc viewed providing general exible data ow model conventional data ow model 
major di erence conventional data ow model ghc poor distinction computational model implementation issues static program structures run time process structures 
example idea sharing nodes sake eciency called notion colored tokens concrete notion appear computational model 
ghc hand separates source programs run time process structures naturally expresses dynamic process recon guration 
allows ecient implementation recursion de ning iterative processes recursive creation process cheap show section 
data ow graph restrictive expressing exible data control structures 
ghc demand driven computation communication incomplete messages mutable objects speci ed elegantly uniform framework data ow graph representations tend awkward 
sum data ow graph appropriate expressing simple class data ow computation 

actor model actor model hewitt yonezawa yonezawa computational model objects message passing 
considered giving foundation object oriented programming 
process interpretation ghc shows major similarity minor difference actor model 
roughly speaking object called actor actor model corresponds goal ghc message passing receiving done uni cation body guard respectively 
ghc goal represent pure impure actor ectively hold internal state 
goal representing object identi es goal shared variable usually stream leading name 
actor model goal directly send message direct acquaintances hewitt baker bindings variables access 
models completely distributed models 
global central notions computation subject local causality speci ed program clauses 
lastly models assume potential delay message passing 
exist di erences 
mention di erences concept object 
ghc notion state change pragmatic language level described side ects 
object internal states implemented goal state arguments hold current set state values state change done reducing new goal di erent state arguments 
di erence objects may implemented goals denoting values individual integers may implemented terms 
kind optimization alternatively implement individual integers goals accept messages plus factorial natural programming style 
di erences follow 
actor activated receiving message ghc goal active receives message uni cation guards 
relationship arrival message reduction goal 
ghc goal may reduced goals receiving messages may reduced receiving messages di erent goals 
mention di erences message passing 
important di erence communication ghc speci ed explicitly means choice nondeterminism commitment operation merging messages implicit actor model 
assume example goal directly send stream communication message goal direct acquaintance 
ask goal set new stream merged existing streams leading destination goal 
merge predicate provides necessary choice nondeterminism 
note explicit speci cation choice nondeterminism necessarily cause inconvenience programming ineciency implementation appropriate user language optimizing compiler see section optimization technique merge predicate 
actor model assumes total order arrivals messages object hewitt baker 
hand ghc corresponding notion assume order instantiation arguments goal natural decision 
clinger suggests arrival ordering strong assumption needs form arbitration realistic 
arbitration implicit formalism actor model discuss fairness current computational model provided ghc liberal handle fairness 
note messages stream ordered ghc course 

process network model kahn kahn simple language express networks parallel processes conceptually similar ghc process interpretation 
procedural language counted ancestors ghc 
language static csp allows recursive call employs bu ered communication 
channel communication exactly counterpart stream ghc communication performed uni cation imperative commands 
kahn explicitly state network allows dynamic recon guration macqueen showed prime generator program similar section slightly modi ed language 
small important di erence language ghc excluded choice nondeterminism 

functional applicative programming proposals functional applicative languages including fp backus hope burstall macqueen sannella turner fel keller valid hasegawa allow concurrent evaluation 
compare ghc languages 
ghc similar functional languages declarative language satisfying form referential transparency whichwe called anti section 
languages free side ects 
point functional languages ghc allow demand driven computation non strict data structures 
major di erence ghc functional languages elegantly features introduced 
showed section demand driven computation elegantly speci ed ghc additional computation rules incomplete message technique 
furthermore data structure ghc naturally includes incomplete non strict terms usual functional languages non strict data structures realized means lazy evaluation call need 
said ghc simpler re ned concepts data structures computation rules owes parallelism 
ghc express quite complex information ow incomplete message technique functional languages express simple information ow 
ghc describing parallel systems message passing 
note comparison apply functional language section questionable called functional language usual sense evaluation expression may instantiate variables expression 
functional programming languages type systems ghc 
user language ghc system programs readable reliable providing programming systems compilers information bruynooghe 
functional languages logic programming languages including ghc capability handling higher order entities 
higher order features provided current logic programming languages expressive elegant 

object oriented languages discussed computational aspects object oriented languages section deal linguistic aspects 
important linguistic aspect common object oriented languages inheritance mechanism goldberg weinreb chikayama independent message passing aspect prerequisite object oriented 
inheritance mechanism important enables di erential programming programming methodology obtaining desired program specifying di erences existing ones 
shapiro takeuchi showed implement inheritance concurrent prolog technique applies ghc 
method object goal delegates processing message received parent object process message 
hierarchy objects implemented cascading streams 
solution relational programming provides suitable framework di erential programming discussed section 
problem solution message delegation occurs dynamically hierarchical structure usually static 
necessary consider technique ecient implementation 
process fusion technique furukawa ueda help ecient implementation encourage di erential programming modularization 
appropriate syntactical support hierarchical programming may useful user language ghc 
note syntactic support ect underlying computational model believe simple possible 
chapter implementation parallel logic programming languages chapter deals topics implementation guarded horn clauses parallel logic programming languages 
ecient implementation stream communication processes ecient compiler guarded horn clauses concurrent prolog top sequential prolog 
technique applied implementation arrays allow constant time access 
chapter focuses implementation conventional sequential computers implementation parallel computers discussed 
course demonstrate logic programming languages parallel computers limit scope discussion sequential computers 
implementation sequential computer important 
rst step general purpose parallel computer communicating sequential computers 
parallel architecture processor deal multiple processes reasons 
unrealistic limit number processes user create number processors available 
second lot processors available best way allocate processes communicate intensively little portions executable parallel allocate processor 
technique running multiple processes eciently single processor crucial eciency system 
parallelism source language parallelism implementation di erent argued section 
problem write better program parallel language sequential language meaningful ecient implementation parallel language sequential computer 

stream array processing section ghc predicate merging input streams investigated compilation technique getting ecient code 
technique data input streams transferred delay independent 
furthermore shown average time addition removal input stream 
predicate distributing item input stream output streams realized eciently ary 
compilation technique predicate applicable implementation mutable arrays allow constant time access updating 
eciency stated achieved sophisticated compiler codes provided directly system get rid bulk source programs time required compile 
implementation technique described section rst proposed ueda chikayama concurrent prolog base language 
altering base language ghc technique described slightly simpli ed 

implement large scale distributed system parallel logic programming languages concurrent prolog parlog ghc performance system uenced signi cantly eciently streams interprocess communication channels merged distributed 
discuss implement predicates merging input streams distributing data single input stream output streams 
ghc discussions results obtained principle applicable concurrent prolog parlog 

importance streams ghc languages stated section ghc allows process interpretation processes expressed goals executed parallel interprocess communication expressed means shared variables appearing arguments goals 
statically shared variables express lists data messages owing usually goals computation proceeds values lists gradually instantiated 
term stream refer shared variables manner section 
interprocess communication done instantiating checking streams laid processes advance eciency stream operations sending receiving merging distributing crucial importance 

necessity dynamic multiway stream merging distribution streams need merged distributed processes linearly connected shared variables perform pipeline processing 
process needs receive data messages processes process manages shared resource merging process put front merge 
order accept messages inde nite number processes possible dynamically vary number input streams merged 
suppose newly created process needs communicate shared process 
rst issue request front merging process input streams request stream set new input stream 
new stream alternatively laid attaching binary existing input streams 
communication delay proportional number communicating processes method repeatedly 
purposes message distribution classi ed broadcasting routing 
broadcasting easy source language level receiver processes need share broadcast stream 
hand routing somewhat complex 
routing necessary implement public communication channels private communication 
may happen process say wants communicate process direct communication channel laid 
case possible ways 
send message indirect public path send request message indirect path establish direct private communication channel 
case process indirect access process relay processes able appropriately transfer messages destinations attached messages 
message distribution possible dynamically change number processes managed 

related works shapiro dealt problem merging inde nite number streams henceforth number input streams denoted 
demonstrated method ensure bounded waiting maximum delay unbalanced tree consisting binary method ensure bounded waiting maximum delay log tree aho hopcroft ullman consisting binary ternary 
term bounded waiting de ned mean message arriving merging process input messages streams 
delay method unacceptable large trac heavy 
method may practical case essentially costly communication interprocess communication multi processor environments 
method major improvement method terms delay 
procedural languages delay interprocess communication depend number senders long simulated sequential computer 
desirable achieve constant time delay logic programming languages 
dealt bounded wait merging streams 
showed method ensure bounded wait merging resort operational characteristics underlying machine interpreter extralogical primitive 
solutions log delay number input streams changed 
solutions merge inde nite number streams inecient 
papers concentrate ary having desired properties 
hand study compile naive ary program 
method published shapiro safra showed multiway merge programmed concurrent prolog introducing destructive assignment 
di erence approaches introduce extralogical primitives base language 
claim approach realize smaller delay essential di erence delay 
approach specialized housekeeping data code manipulating simpli ed ecient 
gelernter discussed suitability concurrent prolog description multi process systems 
concludes interprocess communication merge networks bulky unduly 
criticism viewpoint descriptive power eciency 

objectives objectives realize sequential computer ary maximum delay 
extend solution case varies dynamically 
clear accomplished combination binary ternary 
predicates process messages directly top level merge ys true ys zs merge zs 
distribute xs true distribute xs 
predicates interpreted cost tail recursion proportional size clause 
compiled predicates promise yield higher eciency discussed section 
longer de ne delay depth tree 
de ne delay time passed arrival message goal waiting state original waiting state restored tail recursion message transferred output stream 
delay calculated number primitive operations regarded executable unit time sequential computer usual complexity analysis 
speaking precisely adopt ram model uniform cost criterion aho hopcroft ullman 

outline sequential implementation ghc assume implementation adopts process management technique proposed shapiro 
descriptors conjunctive goals circular list called loop descriptors candidate clauses composing predicate circular list called loop 
element goal loop parent loop comprising candidate clauses committed clauses commitment replaced doubly linked list representing goals body 
body empty element original loop disappears 
parent loop having lost elements considered success 
hand failure loop element failure parent assuming adopt closed world assumption 
element loop represents candidate clause selected commitment parent loop elements represent guard goals 
success loop element implies parent goal committed clause corresponding element 
contrary element loop fails element simply disappears 
parent goal loop having lost elements considered failure 
system queue called process queue leaf elements tree formed loops elements parents loops see await execution 
clause suspended due data ow restriction waits waiting list attached variable caused suspension waiting process queue 
clause re scheduled variable instantiated 
possible optimization method execute head uni cation simple guard goals indivisible sequence operations 
call immediate check 
immediate check succeeds need create loop 
loop created clauses suspended immediate check succeeded immediate check complex guards wait instantiation variables 

implementation merge predicate 
examination ary ary predicate de ned clauses form ignore base cases termination discussed section th clause merge ys true ys zs merge zs 
predicate characteristics see th clause selectable need examine th argument henceforth number arguments starting 
tail recursion employing th clause th th arguments change compared original goal 
argument list tail recursive goal obtained slightly modifying original goal 
clauses wait state argument variables instantiated clause including base case needs re examined 
consider tail recursion 
suppose goal selects clause recursive body goal generated th argument 
wait condition program clause respect respect regards th argument uni cation head clause suspends th argument suspend body goals clause instantiate th argument 
stating property terms ary get 
tail recursion employing th clause wehave examine clauses selectable clause clauses examined examined th clause clauses examined previous call due selection clause clauses examined result uni cation invoked body th clause 
possibility directly related tail recursion count cost tail recursion 
possibility refers clauses carried examined suspend due failure uni cation selected candidates tail recursion 
average number clauses checked tail recursion depend total number clauses 
considerations conjecture ary process message constant time 
note warren proposed implementation technique sequential prolog takes advantage characteristics 

implementation technique fixed arity eciently implement ary consider loop elements created discarded recursion clauses suspend 
order prevent examination clauses worth examining best manage candidate clauses descriptor goal 
argument list re utilized 
sections show general compilation technique achieves constant time delay applied ary 
technique applicable predicates long user de ned goals guards 
technique eciently processes multiple waits goal programs write wait values variables simultaneously programs simpler compilation technique 
adopt closed world assumption section 
number clauses composing predicate denoted andthe number arguments 
con guration process descriptor process descriptor descriptor goal items 
brothers pointers constructing loop 
process queue pointer pointer designating queue 
candidate queue queue candidate clauses goal managed process descriptor 
elements 
clause states array indicating clause state 
elements 
clause backward pointers array pointers designating entries waiting lists attached uninstantiated variables suspended candidate clauses 
element clause 
pointer meaningful corresponding clause state 
suspend fail table reasons particular clause selected commitment attributed arguments goal 
arguments change tail recursion clause may selectable 
table pairs number suspended failing clause number argument may cause maintained 
table enable ecient sequential retrieval elements containing ecient deletion elements containing 
example structure shown ful lls condition 
maximum number elements depends predicate case ary 
fail count total number clauses selected current goal due failure uni cation 
program code pointer predicate code 
argument list arguments goal 
elements 

operations creation process descriptor predicate newly called tail recursion area process descriptor allocated entries set follows clauses entered candidate queue clause states set clause backward pointers left unde ned suspend fail table cleared fail count set program code argument list set 
completed process descriptor entered loop appropriately modifying brothers neighboring goals 
entered process queue making designated process queue pointer element 
selection clause 
candidate queue empty instructions unifying arguments rst candidate th clause goal argument list process descriptor executed 
case ary instructions th argument executed 
succeeds body goals executed see 
fails fail count incremented clause state th clause set suspend fail table updated cf 
section candidate clauses candidate queue tested 
suspends clause state th clause set suspend fail table updated pair pointer process descriptor number clause entered waiting list variable appears goal caused suspension clause backward pointer th clause point pair entered candidate clauses candidate queue tested 

candidate queue empty fail count equal number clauses goal ends failure wehave adopted closed world assumption 
execution current goal suspended 
instantiation variables variable suspended uni cation invoked guards instantiated uni cation invoked clause body done waiting list variable 
done process descriptor designated 
clause state th clause set entered candidate queue 
elements form stands don care deleted suspend fail table 
process descriptor entered process queue 
execution body body clause selected commitment say th clause recursive call tasks done 
assume arguments head arguments recursive call di er th th th arguments 
done 
elements form searched suspend fail table done 
clause state th clause fail count decremented 
entry waiting list pointed clause backward pointer eliminated 
clause state th clause set entered candidate queue 
elements form deleted suspend fail table 
th element argument list rewritten 
th clause entered candidate queue 
clause selection cf 

goals recursive call contained generate new process descriptors 
short lived goals uni cation executed immediately commitment making process descriptors 
particular uni cation goal clause body suspends indirectly called guard need prepare suspension disallow user de ned goals guards 
output uni cation ary eciently executed 
recursive call area original process descriptor released pairs entered waiting lists uninstantiated variables eliminated 
cases area re utilized optimization cf 
section 

management purpose managing suspend fail table minimize number suspended clauses woken variable gets instantiated 
carefully design management scheme clauses suspended clauses woken correctly woken 
ary called follows th th merge ys xs 
th clause suspends 
case cause suspension lies th argument goal clause selected tail recursion took place tail recursion remove cause th argument remains 
complex cases th clause suspends fails due th argument th clause selected tail recursive goal change th argument th clause woken tail recursion 
consider example goal 
program true true 
true 
head uni cation done left right head uni cation rst program clause fails second argument 
attribute cause failure rst second arguments 
second clause selected tail recursion takes place rst clause selectable second argument remains unchanged 
generalize uni cation th argument th clause suspends fails suces enter suspend fail table pair th argument related th argument 
term said related henceforth denoted term variable appearing related variable variable said related variable related re exive transitive closure relation relation variables appear goal guard guard empty sameness variables 
th clause ary quotient set arguments clause true 
get number elements simultaneously entered suspend fail table exceed maximum size elements set arguments case ary value 
note ary specialize simplify data structure suspend fail table operations possible entries form 

properties fixed arity merge examine properties ary compiled technique section 
existence base case clauses considered 
discussed section 

space eciency size item process descriptor suspend fail table obviously greater size suspend fail table stated section 
size process descriptor 
size program code discussed section 

time eciency consider time required processing message arriving ary waiting input 
creation process descriptors ignore done 
head uni cation clause woken message arrives 
cost head uni cation uni cation attempted argument 
uni cation suspends fails cost accompanying suspension failure updating suspend fail table waiting lists variables appropriate data structure suspend fail table section 
instantiation variable stated clause woken task shown section takes constant time 
tail recursion th clause selected commitment clause checked th clause 
furthermore entries argument list need rewritten 
time required recursive call 
delay message arriving ary input wait state depend 
merge process busy processing messages newly arriving message may appear output stream constant time 
processing message starts ends constant time 

order clause checking individual clauses ary checked order entered candidate queue 
selected clause tail queue bounded waiting achieved 
clauses suspended failed candidate queue uence eciency 

program size codes operations section common predicates 
code operations prepared predicate 
case ary code size constant time tasks 
codes individual clauses parameterized respect clause numbers 
done code size predicate reduced 
parameterization accomplished sophisticated compiler capable detecting similarities clauses 
compiler employed reduce size source program time required compilation 
furthermore may programs bene optimization 
considering things realistic approach system provide code ary 
shown code size ary 
unsatisfactory system provide ary various 
provided separate codes amount codes maximum value 
drastic optimization possible 
code ary remain varies parameterized respect 
parameterization realizes family predicates merging number inputs single code size independent note mandatory codes provided system size corresponding source program 

base case terminate ary clause describing base case carefully supplied 
clause merge ys true ys 
logically correct eciently processed implementation technique 
suppose input streams terminated original goal merge reduced goal merge technique shown section delay message may longer small may check input streams execute base case clause 
way avoid record process descriptor input clauses terminated information optimize code base case 
alternative simpler solution uses construct proposed shapiro takeuchi merge ys ys 
explained section goal guard succeeds guards fail 
clause containing guard put candidate queue fail count reaches number clauses containing 
base case clause increase delay message transfer size process descriptor scheduled input streams terminated 
base case clause scheduled input streams instantiated usually clause turns succeed fail suspension 

dynamic change number input streams merge predicate xed arity useful number inputs statically known 
expand allow addition new streams removal terminated streams 
program shown additional say th argument accepting requests new input streams 
th clause transfer merge ys true ys zs merge zs 
th clause addition merge ys true merge ys 
th clause removal merge xs true merge xs 
base case merge xs true xs 
clauses adding removing streams tail recursive clauses clause heads body goals similar 
process descriptors body goals constructed modifying original ones ecient create scratch 
ghc process descriptors managed simple general memory management technique 
suppose buddy system knuth employed 
size partitioned area power process descriptor created areas 
created item placed depending size area allocated cost relocation addition removal streams minimized 
number inputs changes existing information need moved long area large accommodate new descriptor 
show operations performed th th clauses selected process descriptor reusable 
value possible values clause state take area clause states allocated ll unutilized portion 
simplicity description specialized merge predicate 
th clause selected new stream added operations accompanying addition clause states th clauses set clauses entered candidate queue 
th clause entered candidate queue 
th th arguments argument list updated 
program code replaced program parameterized respect parameter value replaced 
wemust note clause states th clauses may case clauses candidate queue 
happens case process descriptor area predicate clauses 
th clause selected empty stream removed operations accompanying change th argument elements form exist searched suspend fail table 
done 
clause state th clause fail count decremented 
entry waiting list pointed clause backward pointer th clause deleted 
clause state th clause set entered candidate queue 
elements form exist deleted suspend fail table 
operations accompanying disappearance th clauses clause state th clause fail count decremented 
operation done th clause 
elements form exist deleted suspend fail table 
done th clauses candidate queue 
clauses disappeared dequeued clause states changed 
th clause entered candidate queue 
th argument argument list updated 
program code replaced 
step performed case th clause selected th clause entered suspend fail table due failure uni cation th argument 
clear performed constant time 
area current process descriptor reused add new stream necessary allocate new area twice size create new descriptor area 
contrary possible express process descriptor half size current area repeated removal streams process descriptor packed unused area freed 
operations shown 
addition streams entailing moving new area area twice large current process descriptor area allocated 
items original process descriptor copied 
entries designated meaningful clause backward pointers ones suspended clauses point new area 
operations described performed 
deletion streams entailing compaction operations described performed 
candidate queue examined clauses th th clauses deleted 
original process descriptor packed top half current area 
bottom half area freed 
step necessary case reduce number elements candidate queue free area 
consider time complexity time needed memory allocation release ignored done time 
time complexity memory allocation release buddy system log size area managed buddy system value determined execution environment program independent 
execution environment xed time needed 
order add remove streams average time guaranteed frequency operations changes number streams 
easily achieved doing possible represent process descriptor example fourth current area 

implementation distribute predicate section describes outline implementation technique predicate message distribution 
go details implementation simpler need implement multiple waits main source merging 

distribution fixed number output streams predicate output streams expressed clauses form th clause distribute xs true distribute xs 
th clause distribute true 
consider situation wait 
enable random access clauses rst th clauses individually checked time 
dec prolog compiler warren generates code selects clauses hash value principal functor rst argument 
case hashing tertiary functor functor third level rst argument necessary select clause constant time 
consider achieve code size 
parameterization code clause course necessary 
case fact clauses selected simple indexing hashing hash table requires area 
wait 
rst th clauses wait th argument 
individually wait desired eciency achieved 
clauses managed waiting 
words entered waiting list variable cluster clauses 
th argument instantiated appropriate clause selected indexing 

dynamic change number output streams case important function dynamically change number output streams 
implemented adding clauses addition distribute grow xs true distribute xs 
deletion distribute shrink xs true distribute xs 
order eciently change number output streams technique similar described section applied 

applying implementation technique distribution predicates mutable arrays lack mutable arrays arrays elements counted problems prolog 
course arrays simulated arrays logical arrays 
direction realize logical arrays correspondence arrays data array type operations arrays predicates manipulate array arguments gain eciency dedicated data structure 
possible correspondence arrays goals processes operations arrays streams messages program array array 
array read true array 
array write true array 

natural solution regard arrays mutable objects 
eriksson rayner independently proposed solution 
program similar constant time accessing updating realized applying implementation technique 
possible add clauses inquiring changing number elements 
note transactions array object done argument binary array predicate programmer direct access array elements 

summary investigated properties ary written ghc implementation transfers message delay independent 
furthermore input stream added removed average time 
respect ary gave outlines implementation ecient 
mutable arrays allow constant time accessing updating shown realizable implementation technique 
concluded predicates supported directly system 
system provides arities realized constant size code 
unrealistic obtain code compiling source program reason eciency code obtained reason bulk source program time needed compilation 
favorable respects construction programming systems semantics system supplied code expressible ghc program 
alternative system predicate approach enhance descriptive power source programs 
fact predicates allow compact representation object code level indicates sparseness redundancy source codes 
introduce new source level notations enable concise representation predicates compiler approach realistic 

concurrent prolog compiler ghc compiler top prolog section describes compilers concurrent prolog ghc sequential prolog target implementation languages 
object programs obtained compiled machine codes prolog compiler 
due similarity source target implementation languages compilers runtime supports small rapidly developed 
benchmark tests showed twice compiled concurrent prolog programs ran times faster times slower comparable prolog programs running interpreter compiler respectively prolog system 
ghc programs ran fast comparable concurrent prolog programs mode declarations 
contents section ueda chikayama ueda chikayama 

evaluate programming language terms eciency try serious implementation language 
unfair language implementation purpose rapid prototyping 
case concurrent prolog interpreter original shapiro regarded prototype 
availability interpreter quite important language useful experiments small programs slowdown bare prolog system interpreter ran amounted orders magnitude 
motivated develop concurrent prolog compiler 
compiler concurrent prolog rst guarded horn clauses invented time 
compiler ghc concurrent prolog compiler developed rapidly ghc invented 
development compilers major purposes provide programming environment write test programs considerable size 
know fast concurrent prolog ghc programs run 
chose sequential prolog target description languages reasons 
prolog program compiled ecient machine codes warren 
similarity source target description languages enables rapid development 
obtain portable implementation 
laborious writing system predicates greatly reduced concurrent prolog ghc prolog 
approach similar gregory wrote system top prolog 
optimize uni cation performance compiler prolog implementation reported 
tried get maximum eciency compiler prolog implementation 
di erence underlying implementations trivial accumulation small hacks may greatly improve eciency optimizing compiler improvement drastic interpreter 

linguistic non linguistic features implementation concurrent prolog basically compiler version original interpreter shapiro 
linguistic extensions listed 
features common ghc compiler ghc compiler concurrent prolog compiler 
input output declarative 
read write predicate la prolog 
wehave predicates take argument stream request messages 
request message appropriate prolog goal 
example goal write ok nl executed message ok followed newline output 
order guarantee uniqueness input output streams called twice 
accepts messages related output accepts messages related output input 
feature synchronizing output terminal input 
fact perform operations provided mere convenience 
mode declaration facilities similar dec prolog bowen byrd pereira pereira warren provided 
purpose get smaller ecient codes 
hand compilers inherit linguistic nonlinguistic restrictions original interpreter 
scheduling candidate clauses depth rst unfair 
clause suspends partial result computation retained subsequent execution just discarded 
distinction suspension failure 
goal immediately selectable clauses may re scheduled cause nite failure suspension 
suspended goals busy waiting 
restrictions greatly simplify implementation prolog ective performance 
look true restrictions glance cause little inconvenience execution concurrent prolog ghc programs written guards just synchronization conditional branching parallel problem solving 
programs require pseudo parallel execution guards 
typical concurrent prolog ghc programs written goals may succeed small ones guards 
failure program exceptional situation concurrent prolog ghc 
employing bounded depth rst scheduling see frequency suspension small applications 
ghc compiler restriction allow user de ned goals guard 
purpose restriction enable simple static analysis suspension 
note restriction similar restriction adopted flat concurrent prolog taylor shapiro levy safra 
non linguistic features include scheduling strategies trace facilities 
conjunctive goals solved pseudo parallel implement scheduler goals 
decided goal queue employed bounded depth rst scheduling default strategy 
bounded depth rst scheduling means newly scheduled goal reducible 
newly scheduled goal goal enqueued rear previously dequeued front 
goal reducible means reduced clause 
reducible prior execution goals queue 
goal reducible means pushed rear goal queue goal front executed 
easy see bounded depth rst scheduling general interpolate breadth rst depth rst scheduling 
bounded depth rst scheduling fairness breadth rst scheduling eciency depth rst scheduling see 
initial bound value goal speci ed run time 
bounded depth rst scheduling unnecessary tell compilers generate simpler code uses unbounded depth rst scheduling gain eciency 
mix strategies program 
stream oriented programs check bound value important producer goal may generate arbitrarily data autonomously goals suspended synchronization mechanism concurrent prolog ghc irrespective scheduling strategy 
restrict bounded depth rst scheduling producer predicates retaining fairness scheduling 
execution trace enabled compiling source program trace option 

compilation technique general advantage compiler approach statically determine parts determine run time interpreter approach 
case concurrent prolog ghc parts include scheduling uni cation 
aspects discussed 

scheduling compilers inherited notions shapiro original interpreter queue represented di erence list goals solved ag showing computation may deadlock cycle marker detecting termination deadlock computation 
compilers inherited scheduler predicate 
compilers generate prolog predicate object code concurrent prolog ghc predicate 
prolog predicate called arguments goal queue called continuation 
called predicate perform scheduling tasks appropriately handle continuation start prolog goal nished tasks swaps caller 
goal started rst goal continuation goal provided predicate 
case pop rst goal provide rest continuation call 
case continuation passed new goal 
prolog predicate generated compilers fails calls nonexistent predicate 
prolog predicate generated compilers consists parts optional prelude part tracing clause indexing clause clause part prolog clause concurrent prolog ghc clause goal reduction postlude part re scheduling clauses fail selected bound value reaches zero 
shows source object programs quicksort concurrent prolog 
shows source object programs quicksort ghc 
note candidate clauses tested sequentially implementation 
compiled clause additional arguments counter maintaining current bound value bounded depth rst scheduling 
head tail di erence list representing continuation 
deadlock ag showing goal reduced occurrence cycle marker 
ag checked cycle marker deadlock detection 
initial bound value run time 
element continuation form 
prolog goal corresponding concurrent prolog ghc goal 
called additional arguments appropriate values 
taps purpose 
uni ed second third fourth additional arguments respectively 
concurrent prolog ghc clause 
transformed prolog clause form receiving arguments uni cation bound check executing decrementing bound scheduling 
bound check decrementing bound parts generated depth rst scheduling speci ed 
part scheduling things 
body goals exist true rst goal continuation called 
just body goal exists goal called continuation current clause received 
qsort pivot xs ys ys ys ys list part xs pivot small large qsort small ys pivot ys qsort large ys ys 
qsort ys ys 
ys ys empty list part xs pivot small large pivot part xs pivot small large 
part xs pivot small large pivot part xs pivot small large 
part 
concurrent prolog source program 
compiler option public qsort 
mode qsort 
qsort arg ys ys bold flag arg pivot xs arg pivot xs bold bound check bnew bold decrement bound part xs pivot small large bnew qsort small ys pivot ys bnew flag flag push st qsort qsort large ys ys bnew flag flag nd qsort top continuation nd 
qsort arg ys ys bold flag unil arg unify ys ys ys ys arg bold bound check goal nd pop rst goal give goal 
appropriate continuation deadlock ag schedule object program dec prolog continued page fig 

compiling prolog prolog qsort arg arg arg suspension processing bold goal flag pop rst goal qsort arg arg arg flag push qsort flag flag goal 
call public part 
mode part 
part arg pivot small arg bold flag arg xs arg xs arg large arg large unify bold bound check pivot pivot wait pivot pivot compare bnew bold decrement bound part xs pivot small large bnew nd 
part arg pivot arg large bold flag arg xs arg small unify bold pivot pivot pivot bnew bold part xs pivot small large bnew nd 
part arg arg arg bold flag unil arg unil arg arg arg unil arg arg bold goal nd goal 
part arg arg arg arg bold goal flag part arg arg arg arg flag flag flag goal 
object program dec prolog continued previous page fig 

compiling prolog prolog continued qsort pivot xs ys ys true part xs pivot small large qsort small ys pivot ys qsort large ys ys 
qsort ys ys true ys ys 
part xs pivot small large pivot large part xs pivot small 
part xs pivot small large pivot small part xs pivot large 
part small large true small large 
ghc source program 
public qsort 
mode qsort 
qsort arg ys ys bold flag arg arg pivot xs bold bnew bold part xs pivot small large bnew qsort small ys pivot ys bnew flag flag qsort large ys ys bnew flag flag nd 
qsort arg ys ys bold flag arg unil arg bold ys ys goal nd goal 
object program dec prolog continued page fig 

compiling ghc prolog qsort arg arg arg bold goal flag qsort arg arg arg flag flag flag goal 
public part 
mode part 
part arg pivot small large bold flag arg arg xs bold pivot pivot large bnew bold part xs pivot small bnew nd 
part arg pivot small large bold flag arg arg xs bold pivot small bnew bold part xs pivot large bnew nd 
part arg small large bold arg unil arg bold small large goal nd goal 
part arg arg arg arg bold goal flag part arg arg arg arg flag flag flag goal 
object program dec prolog continued previous page fig 

compiling ghc prolog continued body goals exist second subsequent goals put front continuation rst goal called modi ed continuation 
calls fourth additional argument deadlock ag set nd deadlock 
ghc compiler gives special treatment uni cation goals clause body 
disallow nested guards uni cation goals suspend 
need schedule normally execute immediately commitment 
treatment body goals described applies uni cation 
cases rst case needs indirect call cases body goals directly called long current bound value zero 
avoiding indirect calls important eciency 
major application concurrent prolog ghc describe distributed system constituent processes represented conjunctive goals communicate shared variables streams 
case reductions clauses having just body goal output uni cation 
compilers translate clauses tail recursive prolog clauses 
advanced prolog implementations realize tail recursion optimization growth local stack re utilizes information left stack tail recursive concurrent prolog ghc program expected properties 
assume bounded depth rst scheduling reductions clauses body goals uni cation 
predicate calls done ecient direct scheduling 
clause handling suspension included postlude part predicate 
pushes current goal rear continuation calls rst goal 
deadlock termination detected cycle marker call system predicate 
predicate receives continuation deadlock ag simply terminates continuation empty 
continuation empty deadlock ag set nd call enqueues resets deadlock ag deadlock calls rst goal continuation 
predicate fails 
goal continuation initial goal input terminal 

uni cation concurrent prolog ghc uni cation terms may suspend uni able ordinary sense 
object code prolog public 

succeeds goals remain goal pop rst goal push nd deadlock ag nd goal 
call popped goal fig 

system predicate deadlock termination public 
mode 


public unil 
mode unil 
unil 
unil unil 
public 
mode 

st arg non variable 

concurrent prolog public 
mode 

public unil 
mode unil 
unil 
ghc fig 

system predicates uni cation synchronization realize suspension mechanism 
concurrent prolog compiler represents read annotations means function symbol appropriately interpreted uni cation routines 
ghc compiler realizes suspension extralogical predicates 
suspension mechanism uni cation little bit heavier 
uni cation goal clause head specialized uni cation procedures depending form head form head analyzed statically 
specialized uni cation procedures diminishes run time overhead 
code head uni cation expanded clause body form sequence goals 
assume head arguments source clause list terms 
corresponding prolog code rst tries unify goal argument term variables successful executes goals processing forms expanded 
idea similar employed dec prolog compiler warren di erence compiler expand uni cation procedure level warren new prolog machine architecture warren enables 
note uni cation procedures expanded case concurrent prolog general uni cation procedure variable occurs head variable ys qsort 
case ghc occurrences variable clause head compared literally prolog predicate instantiate caller 
shows de nitions uni cation synchronization procedures program figures 
predicate interfacing concurrent prolog prolog 
note object code uni cation fails suspension suspension processing done clause predicate 
mode declaration facilities enable declare modes argument predicate 
index mode tells compiler generate code takes advantage clause indexing feature underlying prolog implementation 
object code predicate having mode stage structure rst stage waiting arguments mode second stage clause selection 
mode ective lots clauses 
normal mode speci es argument processed ordinary way 
output mode declares goal argument uninstantiated non read variable 
mode ective concurrent prolog compiler 
arguments output mode implicit head uni cation prolog explicit uni cation procedures 
shows object codes generated concurrent prolog compiler ected mode declaration 

performance detailed performance evaluation concurrent prolog compiler ghc compiler reasonable comparison compiler original interpreter 
ghc compiler note compiled ghc programs ran fast comparable concurrent prolog programs mode declarations 
table shows benchmark results 
program obtained timing data concurrent prolog compiler bounded depth rst depth rst scheduling mode declarations 
benchmark programs timed original interpreter breadth rst scheduling 
prolog programs having input output relations benchmark programs written timed 
prolog system dec prolog dec 
table shows object codes ran times fast original interpreter 
ran times fast comparable prolog programs processed dec prolog interpreter 
course slower comparable prolog programs processed compiler slowdown think quite reasonable 
append program ran reductions second equivalent guards 
mode declaration ective benchmark programs 
speedup 
benchmark programs source improvement declaration output mode 
speedup brought changing bounded depth rst scheduling depth rst scheduling 
third program performs bounded bu er communication ine cient process switching took place 
see table program times faster changing bu er size 
column showing number suspensions indicates bounded depth rst scheduling provides behavior bounded bu er programs 
ill behavior bounded bu er program inevitable behavior just program explicitly speci ed 

history possible extensions concurrent prolog system explained second version icot 
rst version written chikayama unpublished optimized head uni cation append append 
append 
mode append 
append append 
append 
concurrent prolog source program 
public append 
mode append 
append arg arg bold flag arg arg unify head uni cation bold bound check bnew bold updating append bnew nd 
tail recursion append arg bold flag unil arg unify head uni cation bold bound check goal nd pop goal goal 
call append arg arg arg bold goal flag append arg arg arg flag flag flag goal 
suspension processing object program dec prolog continued page fig 

ect mode declaration public append 
mode append 
append arg arg arg bold flag arg arg wait arg bold bound check append arg arg arg bold flag 
clause selection append arg arg arg bold goal flag append arg arg arg flag flag flag goal 
suspension processing append uni cation arg arg embedded bold flag bnew bold bound updating append bnew nd 
tail recursion append uni cation arg arg embedded bold flag goal nd pop goal goal 
call append arg arg arg bold goal flag append arg arg arg flag flag flag goal 
suspension processing object program dec prolog continued previous page fig 

ect mode declaration continued table 
concurrent prolog benchmark dec program proces reduc time rps sing tions sions compiler compiler interpreter mode mode list tion append bd elements stream merge bd elements bounded bu er size bd bounded bu er size bd primes bd output quicksort elements bd breadth rst scheduling bd bounded depth rst scheduling bound depth rst scheduling dec prolog compiler option interpreter 
milliseconds 
overhead timing excluded rps number reductions second 
rps value count reductions guards 
rps values prolog programs calculated number reductions corresponding concurrent prolog programs 
prolog counterpart exist 
employed centralized scheduler predicate managed goal queue 
rst version considered step original interpreter second version 
ecient rst version advantage detailed trace information obtained easily 
re ects fact degree compilation smaller compared second version 
writing second version mock ups object codes simple programs tested 
design object codes carefully crucial performance 
slight di erence object codes may greatly ect performance codes highly optimized 
determining object code format ort write compiler 
ghc compiler modifying second version concurrent prolog compiler 
due similarity concurrent prolog ghc modify code generator guards runtime support routines including uni cation 
restriction ghc compiler user de ned goals allowed guard severe look relaxed 
possible approaches allowing user de ned goals guard static approach dynamic approach 
static approach analyze user de ned goals guards determine piece uni cation suspend 
approach parlog compile time mode analysis clark gregory 
dynamic approach miyazaki compiler miyazaki 
compiler fact dec prolog newer global variable larger address older ones 
fact enables distinguish non writable variables caller writable ones newly created guard threshold address 
course inevitable dynamic approach loses eciency exchange exibility 

summary wehave implemented fast portable compilers concurrent prolog ghc top prolog 
prolog system available immediately get started parallel logic programming 
concurrent prolog ghc systems lines long 
took days rst working version concurrent prolog compiler 
modifying concurrent prolog system ghc system took half days 
methods orts system eciency 
known prolog tool rapid prototyping logic programming language facts show ecient prolog implementation tool getting ecient implementation logic programming language rapidly 
chapter exhaustive search ghc chapter presents technique compiling horn clause program intended exhaustive ghc guarded horn clauses program 
technique viewed transformation technique prolog programs eliminates bagof primitive non determinate bindings 
class programs technique applicable shown static checking algorithm nontrivial extended 
experiment prolog system showed compilation technique improved eciency exhaustive search times case permutation generator program 
compilation technique important exploits parallelism ghc parallel search 
contents chapter ueda 

motivations horn clause logic speci cally language prolog obtain solutions problem obtain answer substitutions variables goal solved 
framework dicult collect obtained solutions single environment counting number solutions comparing classifying 
solutions correspond di erent independent paths search tree 
reason prolog implementations support system predicates creating list solutions goal argument examples setof bagof dec prolog 
naish survey solutions predicates various prolog systems 
system predicates internally extralogical features record obtained solutions 
interesting question possible exhaustive search primitives 
motivation may wish exhaustive search ghc parallel logic programming languages directly support exhaustive search 
case parallelism inherent ghc ectively search 
possible way achieve requirements write rstorder relation directly states example list solutions queens problem 
evident relation described framework horn clause logic 
practice harder write manually write program nds solution time 
programming tool automatically generates exhaustive search program resolve situation way whichwe pursue chapter 

outlines method method compile horn clause program intended exhaustive search means backtracking parallelism ghc program deterministic prolog program returns multi set solutions form single list 
word deterministic means bindings variables determinate undone 
prolog programs subclass interesting viewpoint implementation trail stack need prepared execute correctly 
furthermore determinism sense similarity semantical restriction ghc imposed horn clauses activities done single environment 
ected fact transformed program interpreted ghc program prolog program slight change commitment operator 
cut operator 
possible views transformation technique 
regard compilation horn clause program concept sequentiality guarded horn clause program 
compiling parallelism eliminate multiple environment mechanism general necessary parallel search path search tree create binding environment 
view regard transformation prolog program 
transformation serves simpli cation sense predicate bagof mechanism eliminated 
transformation may remarkably improve eciency search program see 
technique important meaning 
making search performed single environment possible introduce mechanism controlling search 
technique may provide starting point intelligent search 
transformed program viewed ghc program emulates parallel sequential execution original program 
original parallelism compiled parallelism stated sequential execution conjunctive goals realized passing continuation 
parallelism ghc simple conjunctive goals solving di erent paths search tree interaction solutions collected 
continuation data structure represents remaining tasks done get solution 
notion continuation ectively concurrent prolog ghc compilers top prolog section implement goal queue 
di erence stack queue 

previous research implementation technique exhaustive search parallel logic programming languages hirakawa chikayama furukawa clark gregory 
approach describe interpreter horn clause programs concurrent prolog parlog problems addressed approach interpreter approach loses eciency 
multiple environment mechanism implemented run time creation variants section terms 
problem serious resolved partial evaluation technique 
alternatively directly write compiler corresponds original interpreter diculty section 
hand problem serious 
reason environments di erent sets uni ers generated rewrite goal ways di erent program clauses time section 
interpret exhaustive search program number variants current set goals partially determined solution prior simultaneous derivation 
interpreters optimization reduce amount variants created avoid run time creation 
run time creation variants time sensitive operation 
goal creating variant say copy rewritten conjunction goals copy 
predicate copy incompatible anti substitutability ghc section ghc reasonable semantics 
framework sequential prolog predicate copy considered extralogical de ned extralogical predicate var checks argument currently uninstantiated variable 
extralogical predicates course discouraged introduces semantical complexity hinders description programming systems support 

simple example illustrate di erence previous method consider example decomposing list append predicate append 
append 
append append 
head clause get partial solution 
get instances recursive calls 
solutions share common pre long value variable represented pointer association list variants partial solution 
method hand rst rewrites clause follows append append 
predicate uni es arguments 
de ned single unit clause assume body goals executed left right head uni cation 
clause generates answer substitutions top manner clause generates bottom manner combining ground terms 
rst output argument remains uninstantiated rst recursive goal fork candidate clauses succeeds 
need variants partial solution recursive call 
clause tail recursive push remaining task task consing obtain stack representing continuation 
variable ground value information stacked represented ground term continuation need copied append goal forks 
prepared elimination nondeterminism 
shows ghc program returns result equivalent permutation solutions dec prolog goal bagof append search corresponding clauses original append performed conjunctive goals ap ap 
arguments follows input third argument original program ii continuation iii head di erence list solutions iv tail 
clause unit clause corresponding predicate ap activates remaining tasks calling predicate cont continuation processing 
time output results input argument passed continuation processing goal 
predicate ap activates rst recursive goal information second goal attached continuation case input argument form 
input argument form uni cation input argument fails empty di erence list returned immediately 
predicate cont continuation processing 
continuation form cont pushes front output calls cont process rest continuation cont 
continuation form calling form ap ap cont true ap cont ap cont 
ap cont true cont cont 
ap cont true ap cont 
ap 
cont cont true cont cont 
cont true 
fig 

list decomposition program inserts outputs received di erence list 
function symbols construct continuation regarded indicating locations original program indicates top level goal indicates recursive call clause 
interestingly predicate cont similar ecient non naive list reversal program continuation example essentially list represents rst part solution pair lists reversed form 
di erent solutions collected created di erent calls cont reverse di erent substructures shared continuation 
program collects solutions ap ap concatenation di erence lists fair way collection 
example rst clause predicate produced nite number solutions see solutions second clause 
need fair collection collect solutions merge predicate implemented fair 
interpret prolog program provided operators replaced bythe operators goal second clause ap deleted second clause ap guaranteed clause ap 

general transformation procedure section rst presents class horn clause programs technique illustrated section easily mechanically applied brie shows transformation procedure 
permutation program example 
show class horn clause programs transformation technique applicable 
program class enjoy property body goals clause executed left right head uni cation arguments goal appearing program classi ed input arguments output arguments 
goal called input arguments instantiated ground terms goal instantiate output arguments ground terms succeeds 
look restrictive glance programs notion multiple writers see section notion di erence list incomplete data structure enjoy property 
programs multiple writers require pre transformation described section 
hand programs di erence lists handled extending notion input output long allow static data ow analysis 
conjecture observation write perm 
perm del perm 
del 
del del 
fig 

permutation program declaration perm 
input output perm 
perm del perm 
del 
del del 
fig 

mode analysis permutation program prolog program handles di erence lists usually fully recognize uninstantiated variables appear data structures 
input output modes program programmer declare goal arguments appearing program 
realistic programmer declare mode arguments top level goal infer modes goals rules policy single goal arguments instantiated ground terms call regarded input arguments classi ed 
arguments regarded output arguments 
mode inference check program belongs class done simple static analysis 
perform analysis clause mode predicate containing clause mode analysis single program clause mark variables appearing input head arguments ground 
body goal analyzed repeatedly determine mode body goal policy single goal 
terms composed variables marked ground function symbols regarded ground terms 
ii mark variables appearing output arguments goal ground 
check variables appearing output head arguments marked ground 
check succeeds terminate analysis clause success report failure 
initially modes top level goals known possible modes goals incrementally obtained analysis 
algorithm mode analysis follows 
denotes set moded predicates 
moded predicate predicate mode called di erent modes predicate correspond di erent moded predicates 
mode analysis entire program set moded predicates calls appear declared top level goal 
mark predicates unanalyzed 
repeatedly unanalyzed predicate remains 
predicate unmark analyze clauses algorithm adding mark unanalyzed moded predicates calls newly execution step shows analyzed permutation program 
easy prove induction number steps resolution successfully analyzed program instantiates output arguments goal ground terms successful termination provided ground terms input arguments 
successfully analyzed program transformed steps predicate called di erent modes give unique predicate name mode 
rewrite clause normal form 
transform predicate program 
step removes multi mode predicates 
transformation attaches concept mode predicate predicate call 
step steps clause unit clauses replace output head arguments distinct fresh variables place goals clause 
goal body clause replace output arguments distinct fresh variables place goals immediately distinct variables appearing previous goals clause head 
purpose step simplify output arguments clause head 
clear program passed mode analysis rewritten steps class 
shows normal form permutation program 
show outline step main part transformation method 
shows result applied permutation program 
indicate braces example permutation program mentioned term appearing explanation 
arguments transformed predicate input arguments original predicate continuation perm 
perm del perm 
del 
del del 
fig 

normal form permutation program cont true cont 
cont true cont 

cont true cont cont 
cont true cont 

cont true cont 

cont true cont 
true 
cont true cont 
cont true cont 
fig 

transformed permutation program head tail di erence list returning solutions 
transformed predicate responsible doing task original predicate followed task represented continuation 
predicate perm clause reducing goal transformed predicate consists transformed clauses original ones see 
predicate del clause may applicable reduction separate name transformed clause transformed predicate call subpredicates collect solutions 
body clause transformed unit clause calls goal continuation processing 
goal arguments output values returned original unit clause 
body clause transformed non unit clause calls predicate corresponding rst body goal del original clause see 
calling transformed predicate corresponding th body goal recursive call del clause push label indicating goal input data subsequent goals 
calling predicate corresponding top level goal say perm ground term give initial value continuation label indicating termination refutation data necessary constructing term collected 
predicates continuation processing composed clauses corresponding label pushed step 
clauses classi ed predicates immediately labels separate predicate names 
clause predicate continuation processing input data goal perm indicated received label information stacked label output goal 
calls predicate corresponding goal see 
clause processing label indicating termination generates term collected output top level goal information stacked label returns di erence list having term sole element 
transformed predicates may fail uni cation input arguments backup clauses generated return empty di erence lists uni cation fails 
spite rules transformed predicates generated system predicates processed immediately spot followed task 
worth noting spite restriction transformed program handle non ground data structure correctly 
portions input data structure passed examined uni cation need ground terms 
example execute goal 
correctly instantiated list permutations 

class programs technique described useful practical point view class horn clause programs de ned section large express problems naturally 
problem regard notion multiple writers 
multiple writers mean goals sharing data structure trying instantiate cooperatively competitively 
prolog programming data structure usually represented directly prolog term operated direct prolog uni cation typical example construction output data parser program 
programming technique problems transformation generally impossible analyze statically part shared data structure instantiated goal 
shared data structure may instantiated fully ground term 
item considered problem semantical point view 
extracting information shared data structure generated search program wehave extralogical predicate var see portion data structure left undetermined 
may argue need predicate var analyze data structure making ground instantiating undetermined portions ground terms new constant symbols 
may argue making term ground calls predicate var accomplish trying unify subterm new constant 
search program generates non ground result program ground relationship multiple writers program start program nished program lower priority respect instantiation shared data structure 
means concept sequentiality priority conjunctive goals concepts outside pure horn clause logic 
anyway pre transformation horn clause program order apply transformation technique 
change representation shared data structure ground term representation list binding information generated writer 
writer receive current list binding information return new separate argument 
writer add binding information check consistency current new information added 
checking done trying construct original representation scratch time done eciently adopting appropriate data structure possibly list bindings binding information 
comparing original proposed implementation schemes multiple writers practical point view proposed scheme apparently disadvantageous ease programming 
di erence lie speci cation data ease implementation essential problem accumulation programming techniques program libraries alleviate diculty 
eciency point comparison 
original representation suitable execution backtracking requires multiple environment mechanism parallel execution may cause additional complexity overhead haridi 
proposed pre transformation may consistency checking somewhat expensive parallel execution easier multiple environment mechanism necessary 

performance evaluation table compares performance original transformed programs 
programs measured described queens program queens program class shown section 
programs measured dec prolog dec 
original program execution time exhaustive search forced backtracking collection solutions measured execution time bagof primitive 
setof primitive considered sorting solutions inessential 
program measured possible simpli cation fact prolog checks candidate clauses sequentially 
table shows proposed program transformation improved ciency exhaustive search times permutation program table 
performance exhaustive search programs msec 
program original original transformed number bagof search solutions list decomposition elements permutation genera tion elements queens queens queens queens times list decomposition program append 
remarkable speedup brought specializing task collecting solutions framework horn clause logic bagof primitive uses extralogical feature similar assert optimizing compiler help 
program queens small number solutions compared search space expect remarkable speedup transformed queens program got slightly slower case queens 
manual optimization transformed queens program surpassed original bagof version 
important point note case queens transformed program slower original program collect solutions dedicated mechanism search problems automatic backtracking 
suggests transformed program improved changing search algorithm 

summary works wehave described method compiling horn clause program exhaustive ghc program deterministic prolog program 
stated method concept continuation applied case solution required 
method provides possibility introducing control search activities performed single environment 
restricted class horn clause programs method applicable 
class trivial expected diculty writing program class natural extension 
believe important practical point view show class horn clause programs transformed loss eciency resort extralogical predicates 
loss performance dedicated mechanisms automatic backtracking small 
conversely technique may greatly improve eciency exhaustive search done bagof primitive 
proposed transformation eases parallel search eliminates need multiple environments eliminates problems resource management 
resource management important problem realizing parallel search 
results need interpreted reducing signi cance parallel prolog machines specialized hardware perform better special class programs 
purpose primarily examine possibility ecient search general purpose parallel machine expect technique utilized improving eciency parallel prolog machines 
comparison approaches interesting research near 
chapter works 
contributions implications main contribution thesis simple basic framework programming language describe programs interacting outside worlds 
framework logic programming nontrivial extensions programming language 
practical programming language means interact outside worlds 
original logic programming framework regards answer substitution set answer substitutions possible refutations result computation 
set answer substitutions meta level concept obtained observing proof 
hand input output ghc done participating proof 
processes treated completely relational framework viewed modeling outside worlds 
framework ghc suitable treating computers surroundings uniformly interchangeably human process automated process perform task 
reasons meta level concepts 
absence meta level concepts keeps language underlying theory simple 
lead ecient implementation 
including outside worlds uniform framework naturally called parallelism regardless computer parallel sequential 
called notion determinate bindings causality bindings 
hand call sequentiality prolog 
design ghc re ects considerations 
amended original framework logic programming framework greatly contributed simplicity resulting language 
particular enabled introduce elegant notion information ow synchronization 
hoped simplicity generality ghc contribute research parallel programming parallel programming languages 
may feel uneasy practical aspects ghc case 
steadily remove anxiety chapters addressed important issues communication large network processes ecient implementation sequential machine facilities exhaustive search discarded 
results chapters remind general principle program need executed way appears specify 
programming languages program speci es ultimately inputoutput relation 
suggests result computed may suggest computed 
chapters show compilation important programming languages machine oriented 
compilation technology serves raise level programming language minimum loss eciency 
course enlarges semantic gap language target machine long computer architecture remains 
correctness compiler may harder prove 
compiler correctness proved 
description veri cation user programs simpli ed 
bene higher level language 

applications ghc ghc general purpose language intended applications 
application programs written far include formula manipulation program window system hardware simulator 
addition programs written concurrent prolog parlog easily translated ghc see hellerstein shapiro gregory edelman shapiro gregory neely matsumoto 
takeuchi wrote algorithmic debugger ghc ghc see section 
shown chapter ueda ghc target language exhaustive search programs written ordinary horn clauses 
programs written ghc widely accepted practical programming language 
process important identifying necessary syntactic constructs incorporated user language section developing ecient implementations 
real time systems form important application area 
computational model provided ghc liberal permit description real time systems example allows delay communication shared variables 
correctly handle real time ghc necessary introduce notion time impose appropriate restrictions operational semantics 

works 
formal semantics semantics ghc section formally described care 
simplicity language familiar stable concepts uni cation contribute clarity informal description 
clear informal semantics valuable need formal semantics course 
formal semantics gives foundation correct implementation language mechanical manual handling programs partial evaluation reasoning programs 
declarative semantics logic programs described section limited additional construct ghc 
hard introduce causality declarative framework 
promising approach generalize formal semantics non deterministic data ow languages brock ackerman brock staples nguyen 
wemust develop detailed operational semantics 
operational semantics shows guidelines implementation algorithmically 
especially important parallel languages constructs semantics program means primitive operations 
ueda analyzes operational aspects anti substitutability 

user language ghc described chapter provides syntactic author believes ghc program fairly readable 
program complex data ow easy understand course mainly due complexity program 
ghc process description language process interpretation mind 
process interpretation kind pragmatics appropriate syntactic support user language desirable 
interesting design process oriented user language clearly express exible data ow ghc 
interesting design modularization facilities notion processes 
conservative feature incorporated user language notation anonymous predicates 
current syntax ghc forces programmer invent new predicate name conditional branching program appearing section 
filter xs ys true xs xs filter xs ys 
filter xs true xs 
filter xs ys mod filter xs ys 
filter xs ys mod filter xs ys 
eliminating auxiliary predicate filter restricting clause head general form get representation filter xs ys ys ys xs xs mod filter xs ys mod filter xs ys ys xs 
anonymous predicates look guarded commands program looks procedural 
note syntactic sugar representation inappropriate open world assumption 
syntactic kind include notation similar case statement pascal multiway branching value variable 
syntactic conventions kind added called writing programs 

programming system metalevel facilities said parallel program hard debug 
probably simple process structure simple data ow tractable may hard analyze behavior program complex data ow 
takeuchi developed debugger ghc divide query method shapiro 
techniques developed context functional programming incorporated 
example takahashi ono improved eciency divide query debugging static structure program account 
techniques tracing parallel program developed 
tracing useful analyzing erroneous situation large complex program identifying bug 
monitoring resource allocation eciency 
programming system automatically proves helps prove correctness program system automatically derives helps derive correct ecient program important 
purposes speci cation language suited basic concept ghc valuable 
best write programming systems ghc nished design set features system programming 
system program ful ll requirements system program able communicate user program 
system program able observe execution user program able detect termination user program 
system program necessary control user program 
system program killed user program 
previous proposals system programming parallel logic programming languages fail satisfy requirements 
unix shell shapiro satisfy requirement claims guard guarantee 
argument clark gregory satisfy anti substitutability explained section 
investigation necessary better solution 
introducing notions distinguish object meta levels inevitable observation control inherently meta level notions 
problem introduce 

implementation implementation described section compiler sequential implementation miyazaki psi yamamoto nakajima 
implementation intended modi ed distributed implementation multi psi multiprocessor system composed psi 
implementation ort instruction set 
sample object program append marked reductions second idealized condition 
implementations allow user de ned goals guards 
speed append machine mips may unsatisfactory gure means message message second process interpretation 
considered section optimization techniques stream merging stream distribution mutable arrays go far optimize representation streams 
necessary consider time space ecient implementation important data structures including streams character strings large mutable objects databases 

theoretical issues parallel computation hoped simplicity generality ghc stimulate theoretical research underlying parallel computational model 
important nd appropriate cost criterion discuss computational complexity may implementation dependent 
theoretical results sequential computation depending sequential computation re examined adapt framework parallel computation 
re examination may help separating points essential manner computation speci sequential computation contributing sequential computation 
wehave seen history lisp prolog pure language widely impure extensions extensions pure subset attracts attention theoretical persons 
extensions ignored theorists tend dirty 
try minimize discrepancy theoretical practical versions language simple powerful language promote direction 
programming language mediate theorists application programmers implementors 
ghc rst step prolog direction provided framework handle input output introduced minimal control structure necessary guide computation right direction 
excludes important concepts including control fairness nondeterministic choice easy introduce way 
step consider unsolved problems better approximation ultimate language 
aho hopcroft ullman design analysis computer algorithms 
addison wesley reading mass aida proposal logic programming language suited parallel processing 
proc 
th meeting ips japan japanese 
data ow architecture 
computer software vol 
pp 
japanese 
hasegawa list processing data flow machine 
proc 
rims symposia software science engineering goto furukawa nakajima nakata yonezawa 
eds lecture notes computer science springer verlag berlin heidelberg pp 

fujita oka temporal logic programming language programming 
logic programming conf 
institute new generation computer technology tokyo pp 

appear logic programming wada 
ed lecture notes computer science springer verlag berlin heidelberg 
apt emden van contributions theory logic programming 
acm vol 
pp 

backus programming liberated von neumann style 
functional style algebra programs 
comm 
acm vol 
pp 

bowen 
ed byrd pereira pereira warren prolog user manual 
dept arti cial intelligence univ edinburgh 
bowen meta level programming knowledge representation 
logic programming research group school computer information science syracuse univ bowen weinberg meta level extension prolog 
proc 
symp 
logic programming ieee computer society pp 

boyer moore sharing structure theorem proving programs 
machine intelligence edinburgh university press 
brock formal model non determinate data ow computation 
tech 
report tr laboratory computer science massachusetts institute technology 
brock ackerman scenarios model non determinate computation 
formalization programming concepts diaz ramos 
eds lecture notes computer science springer verlag berlin heidelberg pp 

gregory parlog discrete 
proc 
second int 
logic programming conf uppsala univ sweden pp 

bruynooghe adding redundancy obtain reliable readable prolog programs 
proc 
int 
logic programming conf fac ult des sciences de marseille pp 

burstall macqueen sannella hope experimental applicative language 
proc 
lisp conf pp 

chang 
lee 
symbolic logic mechanical theorem proving 
academic press new york 
chikayama unique features esp proc 
int 
conf 
fifth generation computer systems institute new generation computer technology tokyo pp 

computer architecture parallel execution logic programs 
cs dept telecommunication systems computer systems royal institute technology stockholm 
haridi formal model parallel execution logic programs 
proc 
ifip mason 
ed elsevier science publishers amsterdam pp 

clark negation failure 
logic data bases gallaire minker 
eds plenum press new york pp 

clark predicate logic computational formalism 
research monograph toc dept computing imperial college science technology london 
clark gregory relational language parallel programming 
proc 
acm conf 
functional programming languages computer architecture acm pp 

clark gregory parlog parallel logic programming language 
research report doc dept computing imperial college science technology london 
clark gregory parlog parallel programming logic 
research report doc dept computing imperial college science technology london 
clark gregory notes systems programming parlog proc 
int 
conf 
fifth generation computer systems institute new generation computer technology tokyo pp 

clark gregory notes implementation parlog 
research report doc dept computing imperial college science technology london 
logic programming vol 
pp 

clark mccabe ic prolog language features 
proc 
logic programming workshop 
ed hungary pp 

logic programming clark 
eds academic press london pp 

clark order theory data programs 
proc 
ifip 
ed north holland amsterdam pp 

clinger foundations actor semantics 
ai tr arti cial intelligence laboratory massachusetts institute technology 
colmerauer prolog ii manual theoretical model 
internal report groupe intelligence arti universit aix marseille ii 
cohen multi version structures prolog 
proc 
int 
conf 
fifth generation computer systems institute new generation computer technology tokyo pp 

process model parallel interpretation logic programs 
ph 
thesis tech 
report univ california irvine 
kibler parallel interpretation logic programs 
proc 
symp 
functional programming languages computer architecture acm pp 

kibler parallelism nondeterminism logic programs 
new generation computing vol 
pp 

degroot restricted parallelism 
proc 
int 
conf 
fifth generation computer systems institute new generation computer technology tokyo pp 

dijkstra guarded commands formal derivation programs 
comm 
acm vol 
pp 

om szeredi prolog practice 
proc 
ifip mason 
ed elsevier science publishers amsterdam pp 

dwork kanellakis mitchell sequential nature uni cation 
logic programming vol 
pp 

edelman shapiro quadtrees concurrent prolog 
tech 
report cs dept applied math weizmann institute science israel 
emden van kowalski semantics predicate logic programming language 
acm vol 
pp 

emden van lucena de predicate logic language parallel programming 
logic programming clark 
eds academic press london pp 

eriksson 
rayner incorporating mutable arrays logic programming 
proc 
second int 
logic programming conf uppsala univ sweden pp 

miyazaki sequential implementation ghc subset 
appear proc 
nd annual convention ips japan japanese 
furukawa ueda ghc process fusion program transformation 
proc 
second national conf 
japan society software science technology pp 

gallaire minker 
eds 
logic data bases 
plenum press new york 
gelernter note systems programming concurrent prolog 
proc 
int 
symp 
logic programming ieee computer society pp 

goldberg robson smalltalk language implementation 
addison wesley reading mass goto tanaka oka highly parallel inference engine pie goal rewriting model machine architecture 
new generation computing vol 
pp 

gregory parlog prolog version 
dept computing imperial college london 
gregory private communication 
gregory design application implementation parallel logic programming language 
ph 
thesis dept computing imperial college science technology london 
gregory neely parlog speci cation veri cation simulation 
research report doc dept computing imperial college science technology london 
proc 
th int 
symp 
computer hardware description languages applications tokyo 
hagiya lazy uni cation nite trees 
proc 
logic programming conf 
institute new generation computer technology tokyo japanese 
hagiya foundation prolog 
ips japan vol 
pp 
japanese 
hagiya theory modal logic programming 
proc 
th meeting ips japan japanese 
hellerstein shapiro implementing parallel algorithms concurrent prolog maxflow example 
proc 
int 
symp 
logic programming ieee computer society pp 

hewitt viewing control structures patters passing messages 
arti cial intelligence vol 
pp 

hewitt baker laws communicating parallel processes 
proc 
ifip 
ed north holland amsterdam pp 

hirakawa chikayama furukawa eager lazy enumerations concurrent prolog 
proc 
second int 
logic programming conf uppsala univ sweden pp 

hirata operational semantics pure concurrent prolog 
proc 
conf 
japan society software science technology pp 
hirata self description oc applications 
proc 
second national conf 
japan society software science technology pp japanese 
hoare axiomatic basis computer programming 
comm 
acm vol 
pp 

hoare communicating sequential processes 
comm 
acm vol 
pp 

hoare communicating sequential processes 
prentice hall international uk london 
hogger logic programming 
academic press london 
ito masuda parallel inference machine data flow model 
int 
workshop high level computer architecture pp 

ito shimizu kuno data ow execution mechanisms parallel concurrent prolog 
new generation computing vol 
pp 

kahn semantics simple language parallel programming 
proc 
ifip north holland amsterdam london pp 

kahn macqueen coroutines networks parallel processes 
proc 
ifip 
ed north holland amsterdam pp 

high speed execution prolog supercomputers 
proc 
th programming symp pp 
japanese 
keller fel experimental applicative language 
proc 
rd meeting ips japan 
knuth art computer programming vol 
fundamental algorithms 
addison wesley reading mass kowalski predicate logic programming language 
proc 
ifip north holland amsterdam london pp 

kowalski directions logic programming 
proc 
symp 
logic programming pp 

kowalski logic programming 
byte vol 
pp 

bounded wait merge shapiro concurrent prolog 
new generation computing vol 
pp 

uni cation read terms concurrent prolog 
discussion computer science dept univ british columbia canada 
levy personal communication 
lloyd foundations logic programming 
springer verlag berlin heidelberg new york tokyo 
martelli montanari ecient uni cation algorithm 
acm trans 
prog 
lang 
syst vol 
pp 

tamura implementing parallel prolog system prolog 
trans 
ips japan vol 
pp 
japanese 
matsumoto parallel parsing system natural language analysis 
third int 
conf 
logic programming london 
taylor shapiro 
levy safra design implementation flat concurrent prolog 
technical report cs dept applied mathematics weizmann institute science israel 
furukawa takeuchi knowledge assimilation method logic databases 
proc 
int 
symp 
logic programming ieee computer society pp 

new generation computing vol 
pp 

miyazaki unpublished manuscript 
institute new generation computer technology tokyo japanese 
miyazaki ghc prolog compiler unpublished program 
miyazaki takeuchi chikayama sequential implementation concurrent prolog shallow binding scheme 
proc 
symp 
logic programming pp 

oka tanaka aida hirata maruyama architecture parallel inference engine pie 
proc 
int 
conf 
fifth generation computer systems institute new generation computer technology tokyo pp 

naish solutions predicates prolog 
proc 
symp 
logic programming ieee computer society pp 

nakagawa parallel prolog divided assertion set 
proc 
int 
symp 
logic programming ieee computer society pp 

nakashima knowledge representation system prolog kr 
tech 
report dept mathematical engineering instrumentation physics faculty engineering univ tokyo 
nakashima prolog 
tokyo japanese 
nakashima ueda applicative input output string manipulation facilities logic programming languages 
trans 
ips japan vol 
pp 
japanese 
nakashima ueda variable prolog 
proc 
int 
conf 
fifth generation computer systems institute new generation computer technology tokyo pp 

nitta parallel prolog 
ips japan vol 
pp 
japanese 
nitta matsumoto furukawa description prolog interpreter parallel extension 
trans 
institute electronics communication engineers japan vol 
pp 
japanese 
aso shimizu masuda matsumoto architecture reduction parallel inference machine pim 
new generation computing vol 
pp 

pereira logic control logic 
proc 
int 
logic programming conf 
des sciences de marseille pp 

implementation prolog campbell 
ed wiley new york pp 

pereira nasr delta prolog distributed logic programming language 
