proceedings acm sigmod intl 
conference management data seattle washington june pp 
incremental distance join algorithms spatial databases new spatial join operations distance join distance semijoin introduced join output ordered distance spatial attribute values joined tuples 
incremental algorithms computing operations pipelined fashion obviating need wait completion tuples needed 
algorithms large class hierarchical spatial data structures arbitrary spatial data types dimensions 
addition distance metric may employed 
performance study shows incremental algorithms outperform non incremental approaches order magnitude small part result needed penalty incremental processing modest entire join result required 
spatial join operation similar join operation relational databases 
defined sets objects computes subset cartesian product sets determined spatial predicate prescribes certain spatial relationship objects result 
common spatial predicate intersect geometry objects required intersect 
generalization objects required lie distance 
spatial predicates considered compute spatial join proposed 
methods involve special join indexes 
define distance join operation computes subset cartesian product sets speci supported part national science foundation iri department energy contract er 
sli hanan samet computer science department center automation research institute advanced computer studies university maryland college park maryland cs umd edu cs umd edu fies result distance 
distance usually defined terms spatial attributes need case 
distance resulting pairs limited range generalization spatial join predicate 
distance semi join useful special case distance join object finds nearest object defines distance join distance semi join operations syntax loosely adapted sql including clause extension proposed 
clauses specifying limits distance number result tuples optional 
basic queries complicated adding selection conditions clause 
select distance dmin dmax order select min distance dmin dmax group order definition distance join distance semijoin sql 
distance join distance semi join numerous useful applications spatial databases 
example spatial database rivers cities partial computation find city nearest river find city nearest river city population find cities miles river 
distance semi join useful clustering operation 
example suppose relations consisting locations stores warehouses respectively store wish determine closest warehouse 
distance semi join stores relation warehouse relation 
distance semi join works proceedings acm sigmod intl 
conference management data seattle washington june pp 
reporting store warehouse pairs order distance 
note determined closest warehouse particular store store participate tuples remaining warehouses 
computing complete distance semi join yields clustering stores 
fact point data result partitions space manner analogous discrete voronoi diagram point stores relation associated closest point warehouse relation terminology voronoi diagrams locations warehouses sites 
attractiveness analogy lies providing users mechanism perform geometric operation voronoi diagram data base primitive having invoke special purpose algorithm geometric library perform operation 
note operation symmetric 
particular result computing distance semi join warehouse relation stores relation warehouse get closest store 
clustering join similar distance semi join difference clustering join symmetric 
algorithm computing clustering join 
algorithm suited spatial data resides dimensional euclidean space 
reason deals general objects patterns strings trees graphs internal structure unknown far algorithm concerned 
knowledge objects comes distance measure returns distance objects 
furthermore distance measures assumed expensive compute goal compute distances possible 
contrast spatial data allows spatial indexes effect summarize data enable avoiding distance calculations necessarily expensive component query algorithms involving distances 
incremental algorithms computing distance join distance semi join sense pairs resulting corresponding operation reported 
query engine algorithms pipelined fashion 
furthermore algorithms aim deliver results soon possible 
fast pipelined join methods focus attention :10.1.1.56.701
important enabling development user friendly interactive interfaces database systems 
proposals extending sql benefit greatly presence algorithms 
variation incremental distance join algorithm compute intersecting pairs closest pair nearest neighbors set objects 
incremental distance join algorithm may competitive algorithms terms computational complexity may spatial data structure built 
addition methods limited point rectangle objects 
rest organized follows 
section describes incremental algorithms computing distance join distance semi join 
section describes environment perform experiments section presents results 
section concludes number tasks 
incremental distance join algorithms section describe incremental distance join algorithm 
algorithm general sense spatial data structures concreteness context tree 
performance tests conducted trees see section 
rest section organized follows 
section reviews tree 
section describes basic incremental algorithm distance join followed outline number methods extending functionality improving performance 
section presents modifications basic algorithm enable compute distance semi join operation 
trees tree see proposed spatial data structures 
object hierarchy form balanced structure inspired tree 
tree node contains array key pointer entries key hyper rectangle minimally bounds data objects subtree pointed pointer 
tree leaf node pointer object identifier tuple id relational system non leaf node pointer child node lower level 
maximum number entries node termed node capacity fan may different leaf non leaf nodes 
node capacity usually chosen node fills small number disk pages 
trees index space arbitrary dimension arbitrary spatial objects just points 
described tree leaf nodes contain minimal bounding rectangle object identifier object node geometric description objects stored external rtree 
possibility store actual object geometric description leaf bounding rectangle 
usually useful object representation relatively small similar size bounding rectangle fixed length 
entire object data stored leaf nodes object identifiers need stored 
approach objects fixed address objects moved tree node split 
abr cir ef tree set line segments 
spatial rendering line segments bounding rectangles tree access structure 
bounding rectangles individual line segments omitted interest clarity 
tree variant called tree 
differs tree employing sophisticated insertion node splitting algorithms attempt minimize combination overlap area increase minimum bounding rectangles 
computing distance join incremental distance join algorithm may viewed simultaneously applying incremental nearest neighbor algorithm see application similar approach lsd tree spatial data structures corresponding spatial attributes joined relations 
algorithm works spatial data structure hierarchical decomposition 
description assume spatial data structure forms tree structure tree node represents region space objects pointers external storage stored proceedings acm sigmod intl 
conference management data seattle washington june pp 
leaf nodes region intersects objects 
assume object stored leaf 
handle case objects stored directly leaf case leaf nodes contain minimum bounding rectangles objects pointer actual object representation 
set assumptions chosen holds tree 
algorithm easily adapted handle spatial data structures satisfy assumptions hb tree forms directed acyclic graph quadtrees non point objects may stored leaf node 
remainder section distinction node region represents meaning clear context 
input incremental distance join algorithm spatial indexes 
algorithm maintains set pairs item item node object 
initially contains just pair corresponding root nodes 
obtain set pairs cartesian product sets objects follows 
long contains pair item node replace pairs resulting replacing node entries child nodes non leaf nodes objects leaf nodes 
intuitively obvious process result containing set pairs 
algorithm essentially computes way processes pairs order distance attempting report object pairs soon possible 
algorithm works data objects arbitrary type dimension experiments dimensional points provided consistent distance functions 
distance functions needed objects collection objects collection nodes spatial index collection nodes spatial index 
accurately functions need don dno object node respectively object node respectively 
leaf nodes store minimum bounding rectangle objects functions don dno required 
need functions dbn addition dbb denote minimum bounding rectangle objects respectively 
node regions rectangles dnn serve purpose functions 
usually distance functions distance metric points chessboard manhattan euclidean metrics 
need case 
long distance functions consistent algorithm function correctly 
informally consistent mean pair smaller distance pair gives rise processing algorithm 
example objects respectively leaf node contains dno 
distance functions metric condition hold due triangle inequality property 
follows usually refer distance functions collectively symbol particular distance function inferred context 
basic algorithm describe basic version algorithm introduce extensions ways improve performance 
heart algorithm priority queue element contains pair items input spatial indexes 
item data node kinds possible pairs node node node object object node object object 
object bounding rectangles abbreviated stored leaves third type pair items resulting possible kinds pairs node node node node object object key order queue elements distance pair 
discuss howto handle ties order pairs equal distance 
step algorithm element head priority queue retrieved element smallest distance key 
element stores pair data objects pair reported closest pair 
pair subsequently reported smaller distance due pair having smallest key queue 
furthermore consistency constraints distance functions guarantee pair result generating pair data objects smaller distance items dequeued element node algorithm pairs entries node objects leaf nodes child nodes nonleaf nodes item 
basic algorithm case leaf nodes spatial indexes contain object bounding rectangles 
item queue element item 
contains high level control structure algorithm procedures processnode processnode enqueue new pairs entry node respectively 
lines closest pair objects reported 
entire state algorithm represented priority queue 
point control passed process invoked incremental distance join algorithm may may decide retrieve pairs 
items dequeued element node procedures processnode called 
version algorithm arbitrarily chooses call processnode items nodes 
line processnode denotes bounding rectangle note practice object enqueued bounding rectangle 
object geometry represented directly leaf nodes actual objects bounding rectangles 
case statement line needed 
connection incremental distance join incremental nearest neighbor algorithm easy see processnode essentially basic loop nearest neighbor algorithm 
particular processnode item serves role query object 
priority queue ordering tree traversal key ordering priority queue pairs distance items 
important question break ties pairs distance 
different choices lead vastly different traversal patterns 
goal produce result pairs soon possible obvious want order pairs containing objects object bounding rectangles ahead greater priority pairs nodes 
furthermore pairs nodes pair containing nodes deeper level higher priority 
leads depth traversal pattern tree hierarchy spatial indexes pairs having distance version note objects combinations allow order reduce number object storage 
scheme object object object pair 
iis said generated iif sequence algorithm operations starting 
example object object pairs ultimately generated initial pair root nodes 
proceedings acm sigmod intl 
conference management data seattle washington june pp 
enqueue hr isempty elem dequeue items elem data objects report elem items object bounding rectangles corresponding object dist isempty ord front dist enqueue ho endif item elem node processnode elem processnode elem endif enddo processnode elem node item elem item item elem node leaf node entry enqueue dist item item enddo child node node enqueue dist child item item enddo endif processnode elem items exchanged basic version incremental distance join algorithm leaf nodes contain bounding rectangles 
approach termed depthfirst section 
alternatively nodes higher level priority breadth traversal result termed breadthfirst section 
advantage wanted compute large portion distance join operation generate large number pairs certain cases enable algorithm better schedule node object accesses 
usage assumptions may wasted breadth traversal require processing pairs level pairs distance level considered 
version procedure dequeued pair contains nodes hn node arbitrarily chosen processed entries examined 
strategy cause traversed leaf level root processed 
better strategy attempt traverse indexes evenly level nodes node node pairs differ 
done choosing process node shallower depth 
nodes level respective trees algorithm process node region larger area 
strategy outlined best experiments shown perform 
alternative nodes node node pairs process simultaneously termed simultaneous section 
line traditional spatial join algorithms 
fact done optimization techniques developed spatial join applied usage plane sweep restriction search space 
idea processing mark entries specified distance range see section space spanned similarly entries mark ones specified distance range space spanned 
serves eliminate entries possibly members new pairs 
plane sweep axis pair entries nodes previously sorted axis 
illustrates plane sweep process andr entries ands ands entries 
plane sweep checked intersection entries plane sweep check intersection ofr ands 
plane sweep algorithm modified non zero maximum distance recall focuses spatial join intersection predicate 
example rectangle currently coordinate range sweep axis algorithm sweep entries node coordinate value dmax dmax maximum distance 
example check proper distance addition tos ands 
sweep direction max plane sweep axis entries nodes 
processing nodes simultaneously node node pairs better processing node original formulation 
intuitively optimizations affords yield significant benefits distance range narrow 
extreme case minimum maximum unbounded possible pairs entries nodes generated total number entries node 
contrast nodes processed say pairs result 
pairs may greater distance closest pair 
best case pairs generated original formulation incremental distance join algorithm object pair reported 
downside course processing node time may lead node accessed times disk algorithm produce result pairs 
nodes node node pairs processed simultaneously incremental distance join algorithm resembles somewhat spatial join algorithm introduced 
difference breadth limited finding intersecting object pairs straightforward generalize com proceedings acm sigmod intl 
conference management data seattle washington june pp 
pute spatial join predicate algorithm pairs desired order distance entire result computed sorted pair reported 
widely spatial data structures form unbalanced tree hierarchies quadtrees buddy tree 
bounding rectangles leaf nodes structures objects represented directly leaves leaves contain pointers objects 
case better defer processing leaf nodes items node node pairs leaf nodes time leaf nodes processed simultaneously 
strategy tend reduce number times object needs accessed disk 
distance range shortcoming algorithm stated section large number pairs inserted priority queue computing modest number object pairs relatively small object relations 
pairs inserted priority queue large distance retrieved queue large number object pairs requested 
object relations non trivial size number pairs cartesian product relations recall full distance join operation computes cartesian product immense 
example relations objects cartesian product contains pairs 
typical queries require computing small fraction high number 
pairs large distance retrieved queue 
large number pairs put queue requested occupies great deal memory space slows queue operations need way limiting number pairs inserted queue 
way doing impose maximum distance object pairs 
pair distance larger maximum rejected object pair distance derived consistency distance functions 
established need able impose maximum distance object pairs 
addition may useful queries impose minimum distance object pairs 
incremental distance join algorithm easily modified limits distance pairs returned range values 
order effectively prune pairs minimum distance need functions compute upper bound distance object pair generated function clearly needed object object pairs 
words object dmax upper bound function appropriate 
means dmax smaller minimum distance bound discard object pair distance larger minimum generated 
question compute dmax various types pairs 
pairs nodes hn maxp 
node object dmax maxp similar object node pairs 
functions node node pairs defined similar manner node node pairs 
closer approximation upper bound possible types pairs distance metric see section description priority queue implementation puts part queue disk size large fit memory 
termed minmaxdist 
object bounding rectangles required minimally bound objects 
key idea minmaxdist metric ddimensional minimum bounding rectangle object dimensional faces touch point 
point wehave maxp pf denotes set faces face causing right hand side inequality reach minimum best approximation bounding rectangle function computing min maxdist point bounding rectangle dmm min maxp pf 
practical way computing value dmm compute maximum distance vertex determine vertex ad vmax edge closest 
define dmax maxp dmm similarly node pairs 
minmaxdist definition dmax object bounding rectangles complicated dmax 
price minf maxp basing dmax functions pairs bounding rectangle minmaxdist metric expensive compute simpler dmax function node node pairs 
presents version processnode restricts distances range values 
modify statement line procedure check distance falls desired range 
arguments min max specify minimum maximum desired distance 
mindist denotes regular distance functions dist maxdist denotes dmax functions 
version processnode assumes leaf nodes spatial indexes store bounding rectangles 
object geometry represented directly leaf nodes actual objects line 
case item object maxdist equivalent line 
processnode elem min max node item elem item item elem node leaf node maxdist item min mindist item max enqueue mindist item item endif enddo child node node maxdist child item min mindist child item max enqueue mindist child item item endif enddo endif portion incremental distance join algorithm distance range restriction 
dimensions faces line segments 
proceedings acm sigmod intl 
conference management data seattle washington june pp 
estimating maximum distance pointed section reasonably narrow distance range small interval minimum maximum distance crucial incremental distance algorithm perform 
practical require user set maximum distance 
furthermore maximum distance greatly overestimated 
important way estimating maximum distance information 
way doing set upper bound number pairs algorithm compute 
applications especially involving interactive queries fairly low number pairs known needed 
aided query language extensions number tuples result queries clause proposed select statement sql 
algorithm compute maximum pairs algorithm estimate maximum distance pairs seen far 
obviously object object pairs seen pair largest distance pairs provide lower bound maximum distance necessary compute closest pairs 
better making types pairs node node pairs 
general object object pair may generated 
means fewer pairs sufficient estimating maximum distance object object pairs 
dmin dmax denote minimum maximum distance imposed pairs computed algorithm denotes regular distance function computing minimum distance items dmax denotes functions computing upper bound distance object pairs generated pair 
query specifies maximum distance dmax initially 
goal reduce dmax possible maximum number pairs requested 
iis inserted priority queue show pair purpose estimating lower value dmax 
doing adds overhead algorithm large reduces considerably number pairs inserted priority queue improves running time algorithm 
eligible estimating dmax dmin dmax dmax 
guarantees object object pairs generated distance range dmin dmax 
know advance object pairs generated determine lower bound number 
derived minimum number objects subtree assuming nodes objects object rectangles number 
minimum number objects subtree node turn derived minimum fan height corresponding tree 
tree example minimum fan nodes typically maximum fan root node 
result expected number pairs generated average node occupancy 
number pairs generated iis estimated may lead value dmax small smaller th object object pair causing find pairs force restart query 
reason need restart priority queue provide useful information pruned entries maximum distance heuristic 
process estimating maintains set pairs inserted priority queue retrieved 
eligible pair distance function values specified inserted priority queue inserted causes sum number object object pairs lower bound object object pairs described generated pairs larger remove pairs case setting dmax dmax value pair removed 
pair remove chosen largest dmax value 
pair retrieved priority queue remove pair 
reporting object object pair reduce value 
question organize set operations performed addition insertion remove pair largest dmax remove pair particular items pair 
single data structure supports efficient execution operations 
implementation chose priority queue qm organized dmax values support finding largest value hash table support locating particular pair 
hash table entries contain pointer corresponding priority queue entry enabling deleting entry qm pair removed 
important confuse qm main priority queue algorithm 
qm discussed remainder 
extensions number extensions incremental distance join possible 
add spatial criterion relations involved join 
example objects may required fall inside rectangle may required minimum area 
extension applied equally spatial join algorithms necessarily involve modifying algorithm 
distance functions may parametrized check additional spatial criteria return special value pair discarded 
course spatial criterion high selectivity objects relation participating join satisfy criterion may better restrict number objects spatial criterion computing join 
cost alternative include building spatial index resulting restricted relations require algorithm incremental distance join 
case may take longer produce pairs alternative incremental distance join highly geared producing pairs early 
second extension impose secondary ordering pairs algorithm distance objects 
probably useful resulting pairs required intersect maximum distance 
example may wish find intersections roads rivers order distance house 
general case extension requires modifying algorithm 
special case finding intersections distance functions return nonintersecting pairs intersecting pairs functions return ordering value distance house example 
possible extension find pairs reverse order distance farthest pair relatively simple achieve 
ordering elements priority queue ascending order distance order descending order distance example done simply negative distance key 
addition regular distance functions key order pairs priority queue dmax functions types pairs object object pairs recall dmax functions compute upper bound distance object object pairs generated pairs 
proceedings acm sigmod intl 
conference management data seattle washington june pp 
algorithm perform better distance range narrow 
case estimate minimum distance presence upper bound number object pairs requested 
estimating maximum distance described section 
computing distance semi join recall distance semi join subset distance join object result prior pairs contain item 
keep track set objects reported 
easiest way extend incremental distance join algorithm compute distance semi join algorithm unchanged check outside algorithm object output seen set 
approach termed outside section take advantage special structure distance semi join reduce amount expended algorithm 
section identify ways modify incremental distance join algorithm computes distance semi join operation efficiently 
discuss extensions optimizations described section incremental distance join algorithm apply computing distance semi join operation 
bring algorithm knowledge set set objects collection seen 
straightforward requires minor modifications procedure termed inside section procedure processnode termed inside section 
specifically line dequeued object object bounding rectangle check 
discard pair 
processnode node leaf node line ignore entries correspond objects 
bringing knowledge set algorithm definite improvement better 
improvement fact iin output distance semi join object nearest 
exploited locally processnode procedure termed local section 
see note object subtree closest entries region near 
specifically compute dmax entry determine minimum value dmm 
farther away dmm discarded guaranteed contain object subtree nearest 
principle applied pro object bounding rectangle node dmax upper bound distance object pair derived 
observe approach analogous downward pruning strategy nearest neighbor algorithm 
aggressive strategy obtained insight global fashion 
words object node spatial data structure representing objects maintain smallest dmax distance seen far termed section 
time consider enqueuing sure distance pair smaller smallest dmax distance 
employing strategy requires considerable amount memory space contains objects 
useful comparison strategies 
compromise maintaining globally smallest dmax distance nodes requires order magnitude space doing objects termed section 
case computing distance join incrementally estimate maximum distance needed produce maximum pairs distance semi join 
done way described section 
difference set pairs estimation process item pair unique 
words iis pair pair item number pairs generated iis bounded number objects subtree assuming node 
iis inserted check hi iif smaller dmax value 
additional subtle differences 
reported iin removed 
pair hn inserted processed 
objects subtree counted processing lead ito inserted entry 
may lead estimate dmax low causing find pairs forces restart query 
reason need restart priority queue provide useful information pruned entries maximum distance heuristic 
extensions discussed section apply distance semi join version incremental algorithm 
modifying algorithm find pairs reverse order distance leads may unintuitive useful result 
possible ways defining reverse distance semi join operation relations report reverse order distance object closest object second report reverse order distance object farthest object straightforward way applying incremental distance join reverse distance semi join accordance second definition corresponds reporting object occurs reverse distance join 
definition mean reporting object occurs reverse distance join extremely inefficient 
experimental environment system data experiments run sun ultra model machine rated specint specfp mb main memory gb internal disk drive 
spatial data structure tree 
size nodes maximum fan memory buffers 
spatial objects represented directly leaves trees 
chose approach order simplify analysis execution time results 
organization external object storage large effect performance introduces additional variable 
software compiled gnu compiler set maximum optimization 
distance functions euclidean metric 
evaluations spatial algorithms derived test data tiger line file 
sets points coverage washington dc area water contains centroids water features points roads contains centroids road features points 
far concerned object bounding rectangle treated way corresponding object represented object identifier 
proceedings acm sigmod intl 
conference management data seattle washington june pp 
clear dealing line data complex points 
making experiments line data complex spatial features subject study 
implementation details important issue implementation priority queue 
clear number object pairs result full distance join operation extremely large cartesian product relations absence distance range restrictions 
computing entire distance join useful practice size priority queue incremental distance join algorithm remains smaller size result 
small fraction large number large number 
size priority queue may large fit memory 
exclusively disk scheme representing priority queue desirable due poor performance 
experiments simple hybrid memory disk scheme stores parts priority queue memory heap structure chose pairing heap structure rest offloaded disk 
relatively small number object pairs requested vast majority pairs put priority queue needed 
goal developing scheme contents priority queue put disk needed large number object pairs requested 
reason limiting contents memory heap pairs needed algorithmic complexity heap operations directly related size heap 
chose tiered scheme representing priority queue distance pairs 
pairs distance stored memory heap pairs distance stored unorganized list memory pairs distance ofd greater stored disk 
heap empty contents unorganized list put heap value ofd changed tod new value chosen ford pairs disk distance new values andd put unorganized list avoid accessing pairs disk need inserted priority queue 
implementation fixed distance increment dt updated andd initial values dt dt respectively 
part queue stored disk organized linked lists pages pairs list having distances range kdt dt 
drawback priority queue scheme depends fixed constant dt responding dynamically distribution queue contents 
experiments chose value dt worked input relations 
developing way choosing dt input relations finding dynamic method deciding part priority queue stored disk subjects investigation 
section set maintained objects pair reported incremental algorithm distance semi join 
experiments bit string representation 
reason bit string representation extremely efficient membership tests insertions 
certainly space time tradeoff involved bit string representation set fixed space regardless size set 
sets elements space efficient approach 
memory capacity modern computers size bit strings modest large data sets 
example bit string representation subset elements occupy 
performance results section evaluate effectiveness strategies enhancing efficiency incremental distance join algorithm compare performance competing approaches computing distance join distance semi join 
experiments joined water roads noted distance join priority queue ordering tree traversal section discussed effect choosing different priority queue ordering ties resolved pairs distance process pairs nodes 
table lists values performance measures number object distance calculations maximum queue size number node operations producing result pairs distance join 
algorithm version experiments pairs distance ordered algorithm performs depth traversal nodes deeper level priority node time node node pairs spatial indexes traversed evenly noted type queue order traversal 
plot execution times version labeled depthfirst versions breadthfirst orders pairs distance leads breadth traversal basic depthfirst basic algorithm process node node node pairs simultaneous depthfirst nodes node node pairs processed simultaneously 
shape graphs similar 
versions priority queue order leading depth traversal depth basic simultaneous obtaining pair relatively inexpensive cost rise pairs 
computing larger number pairs cost rises dramatically 
difference execution times versions due differences values performance measures table 
dominant factor shown number distance calculations size priority queue larger basic simultaneous 
maximum distance specified experiments simultaneous version able benefit filtering plane sweep techniques 
reason depthfirst somewhat faster breadthfirst retrieving pair object pair distance 
pair reported soon depthfirst breadthfirst reported intersecting nodes processed 
pair difference methods negligible 
interesting question reason sharply higher cost computing pairs compared computing pairs 
table reveals relatively larger increase node computing pairs distance join symmetric result joining roads water 
incremental distance join algorithm necessarily symmetric execution pattern execution time may different order joined relations 
distance semi join operation symmetric result distance semi join roads water different distance semi join water roads 
recall traversing evenly mean nodes node node pair different level respective trees choose process node shallower level 
proceedings acm sigmod intl 
conference management data seattle washington june pp 
time dist queue node pairs sec 
calc 
size table values performance measures incremental distance join algorithm depth traversal processing node time traversal 
node counts number times requested node node buffer 
number node accesses shown table increases additional accesses nodes node buffer 
larger node buffer better buffer strategy improve performance computing pairs 
factor higher cost computing pairs pairs parts priority queue contents written disk read back memory 
values performance measures joining roads water water roads virtually versions algorithm basic 
roads larger pairs generated case roads traversed 
fact producing result pairs pairs generated priority queue fit disk 
treatment node node pairs basic clearly simplistic 
execution time seconds basic depthfirst simultaneous depthfirst breadthfirst depthfirst number result pairs log scale execution time different queue order node processing 
maximum distance maximum pairs section discussed importance imposing maximum distance section described maximum distance estimated upper bound number object pairs requested 
compares execution time regular algorithm depthfirst preceding section versions algorithm applied distance join maxdist regular algorithm maximum distance set distance pair number maxdist compute pairs max pair uses maximum distance estimation upper bound pairs setting maximum slower regular version 
purpose showing maxdist plots demonstrate effect setting maximum distance provides useful benchmark effectiveness maximum distance estimation 
course practice know advance distance pair number confirms benefit setting maximum distance 
performance similar values maximum distance 
setting maximum number pairs seen beneficial relatively small number pairs 
maximum pairs get similar performance setting maximum distance 
maximum set pairs benefit maximum distance estimate tight overhead estimation process greater 
section confirmed processing nodes simultaneously node node pairs worse processing time maximum distance specified 
performed experiments shown simultaneous version incremental distance join algorithm 
explicitly results expected performance simultaneous better depthfirst relatively small maximum distance specified maxdist 
improvement pronounced retrieving pairs smaller retrieving pairs usually 
specifying maximum number pairs little faster simultaneous version small number pairs 
pairs proved better process node time node node pairs improvement great typically 
execution time seconds regular maxdist maxdist maxdist number result pairs log scale execution time different maximum distance maximum pairs distance join 
priority queue implementation section discussed hybrid implementation priority queue parts queue disk 
gives execution time purely memory queue implementation hybrid different values dt hybrid approach memory queue little slower pairs 
pairs order magnitude slower due excessive virtual memory thrashing seconds compute 
hybrid approach performed equally different values dt retrieving pairs 
case values dt chosen somewhat arbitrarily correspond pairs number 
value experiments 
proceedings acm sigmod intl 
conference management data seattle washington june pp 
higher dt value hybrid better required fewer reads disk portion priority queue 
fewer pairs lower dt value hybrid gave slightly better performance higher number unnecessary priority queue elements kept memory part queue 
best value dt depends nature data sets amount available memory 
execution time seconds memory hybrid hybrid number result pairs log scale execution time storing priority queue entirely memory vs offloading parts disk 
alternative implementations distance join operation computed ways incremental distance join algorithm 
maximum distance imposed spatial join predicate executed output sorted done 
maximum distance imposed distance guessed algorithm spatial join predicate 
distance small pairs result spatial join executed larger distance 
due problem spatial join algorithm comparison 
way computing distance join nested loop approach compute distance possible pairs objects 
compare favorably incremental distance join algorithm large number pairs needed arise practice example full join data sets contains pairs 
experiment approach water roads data sets 
simplicity sake computed distance values didn store sort necessary real implementation 
data set inner loop read completely memory order avoid 
time execute experiment hours 
amount time incremental distance join able compute pairs 
unfortunately pairs priority queue large incremental distance join practical large disk space available 
large disk space required generate sort pairs nested loop approach 
distance semi join section discuss results experiments computing distance semi join variants incremental distance join algorithm 
joining water roads results finding nearest neighbors points water 
pair filtering smallest dmax distance section enumerated ways filtering pairs hi object object bounding rectangle reported 
ways limiting number pairs generated dmax distance pairs 
gives execution time various filtering methods outside executes regular incremental distance join algorithm filters resulting pairs contain objects reported inside filters procedure inside filters processnode procedure 
schemes exploit dmax distance filtering inside local works locally processnode procedure uses local strategy globally maintaining smallest dmax distance nodes globally maintains smallest dmax distance nodes objects 
filtering pairs outside procedure appears slightly better pairs 
priority queue large find neighbors points water shown pairs 
filtering inside processnode saves distance calculations node accesses retrieving pairs outweighed member checks set pairs 
pairs benefit filtering greater finding neighbors points water inside slower inside vs seconds shown order obscure time difference smaller numbers pairs 
schemes exploiting dmax distances similar pairs 
larger number pairs benefit maintaining dmax distance objects nodes pronounced 
doing nodes result appreciable improvement compared local 
execution time seconds outside inside inside local number result pairs log scale execution time storing priority queue entirely memory vs offloading parts disk 
maximum distance maximum pairs section report experiments testing effect setting maximum distance upper bound numbers pairs computing distance semi join operation incremental distance join algorithm 
shows result doing local version section 
maxdist result setting maximum distance largest possible distance objects result dis proceedings acm sigmod intl 
conference management data seattle washington june pp 
tance semi join upper bound number pairs set number points water 
confirms benefit restricting maximum distance 
notice setting maximum number pairs improve execution time making virtually identical setting maximum distance distance th pair 
choosing maximum number pairs algorithm slower large limit give tight estimate maximum distance overhead cost incurred estimating maximum distance exceeds benefit 
cost computing neighbor points river shown seconds maxdist seconds 
numbers lower higher respectively maximum distance set 
see imposing maximum setting upperbound number pairs generated yields significant savings execution time maximum low savings high values maximum yields little savings 
execution time seconds regular maxdist maxdist maxdist number result pairs log scale execution time different maximum distance maximum pairs distance semi join 
alternative implementations distance semi join implemented nearest neighbor algorithm 
object relation perform nearest neighbor computation relation sort resulting array distances neighbors computed 
data sets question execution time doing seconds 
incremental distance join methods reported compare favorably method computing entire distance semi join especially took seconds 
better result obtained switch order relations compute distance semi join roads water case takes seconds nearest neighbor implementation takes seconds 
observe strategy keep track dmax distance objects nodes tree relation occupy considerable storage 
implementation uses nearest neighbor algorithm store distance values objects 
concluding remarks directions research new spatial join operations defined join output ordered distance spatial attribute values joined tuples number different incremental strategies computing examined 
rationale solutions frequently small part join result needed 
experiments revealed distance join variant incremental distance join algorithms performed best processed node node node pairs time attempted traverse trees evenly descend farther ordered pairs distance result depth traversal 
setting limit distance pairs shown improve performance considerably maximum distance limit relatively large 
imposing upper bound number pairs worthwhile upper bound large experiments upperbound pairs improve performance 
applications envision algorithm notably interactive query interfaces quickly user relevant part query result small upper bound established 
distance semi join strategies improving performance incremental distance join shown yield significant improvements especially computing large part result 
strategies different means eliminating consideration pairs sure needed compute output algorithm 
best strategy possible opportunity eliminating pairs containing object pair ho reported earlier uses global knowledge distance bounds eliminate pairs processing nodes 
version better non incremental approach computes distance semi join nearest neighbor algorithm 
maintaining global knowledge distance bounds requires somewhat large amount storage 
reasonable compromise exploit distance bounds locally node processed local 
effect restricting maximum distance maximum number pairs yield similar benefits computing distance join 
algorithm finds processing queries find city nearest river city population 
options query engine incremental distance join algorithm answer query 
execute algorithm city river relations filter result pairs city small population 
find cities population greater incremental distance join algorithm 
second option spatial index built result finding cities population algorithm applicable 
option appropriate population criteria high selectivity 
population criteria low selectivity option superior 
query plans may exist employing algorithm 
enable query optimizer choose options requires cost model relevant algorithms developed traditional tree spatial join 
developing cost models incremental distance join algorithms subject study 
issues investigation include developing techniques dynamically partition priority queue memory structure disk 
experiments limited dimensional points 
needed determine appropriate approach complex spatial objects extent lines polygons higher dimensions 
proceedings acm sigmod intl 
conference management data seattle washington june pp 
wish bj rn 
nsson dr robert webber critical comments 
aref samet 
spatial filter revisited 
proc 
th international spatial data handling pp 
edinburgh scotland september 
hinrichs 
probabilistic analysis algorithm solving dimensional nearest neighbors problem projection 
bit 
bayardo miranker 
processing queries answers 
proc th cikm pp 
rockville md november 
becker hinrichs finke 
new algorithm computing joins grid files 
proc th ieee int 
conf 
data engineering pp 
vienna austria april 
beckmann kriegel schneider seeger 
tree efficient robust access method points rectangles 
proc 
acm sigmod pp 
atlantic city nj june 

optimal algorithm closest pair maintenance 
proc 
th symp 
computational geometry pp 
vancouver british columbia june 
brinkhoff kriegel schneider seeger 
multistep processing spatial joins 
proc 
acm sigmod pp 
minneapolis mn june 
brinkhoff kriegel seeger 
efficient processing spatial joins trees 
proc 
acm sigmod pp 
washington dc may 
bureau census 
tiger line 
washington dc 
carey kossmann 
saying sql 
proc 
acm sigmod pp 
tucson az may 
clarkson 
fast algorithm nearest neighbors problem 
proc 
th ieee symp 
foundations computer science pp 
tucson november 
comer 
ubiquitous tree 
acm computing surveys june 
fredman sedgewick sleator tarjan 
pairing heap new form self adjusting heap 
algorithmica 
nther 
efficient computation spatial joins 
proc 
th ieee int 
conf 
data engineering pp 
vienna austria april 
guttman 
trees dynamic index structure spatial searching 
proc 
acm sigmod pp 
boston ma june 
hellerstein haas wang 
online aggregation 
proc acm sigmod pp 
tucson az may 

distance spatial 
proc 
nd acm workshop gis pp 
gaithersburg md december 
samet 
ranking spatial databases 
advances spatial databases th int 
symp ssd pp 
portland august 
springer verlag lecture notes computer science 
hoel samet 
data parallel spatial join algorithms 
proc 
rd int 
conf 
parallel processing pp 
st charles il august 

huang jing rundensteiner 
cost model estimating performance spatial joins trees 
proc 
th int 
conf 
scientific statistical database management pp 
wa august 

huang jing rundensteiner 
spatial joins trees breadth traversal global optimizations 
proc 
rd vldb conf pp 
athens greece august 
kitsuregawa harada takagi 
join strategies tree indexed relations 
proc 
th ieee int 
conf 
data engineering pp 
los angeles february 
lomet salzberg 
robust multi attribute search structure 
proc 
th ieee int 
conf 
data engineering pp 
los angeles february 
rotem 
spatial join indices 
proc 
th int 
conf 
data engineering pp 
kobe japan april 
roussopoulos kelley vincent 
nearest neighbor queries 
proc 
acm sigmod pp 
san jose ca may 
samet 
applications spatial data structures computer graphics image processing gis 
addison wesley reading ma 
samet 
design analysis spatial data structures 
addison wesley reading ma 
seeger kriegel 
buddy tree efficient robust access method spatial data base systems 
proc 
th vldb conf pp 
brisbane australia august 
shafer agrawal 
parallel algorithms highdimensional proximity joins 
proc 
rd vldb conf pp 
athens greece august 
wood 
counting reporting intersections ranges 
ieee transactions computers march 
vaidya 
log algorithm nearestneighbor problem 
discrete computational geometry 
wang shasha 
query processing distance metrics 
proc 
th vldb conf pp 
brisbane australia august 
wilschut apers 
dataflow query execution parallel main memory environment 
proc st int 
conf 
parallel distributed information systems pp 
miami fl december 
