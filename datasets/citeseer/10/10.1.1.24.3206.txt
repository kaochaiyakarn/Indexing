random tree diameter diameter constrained mst abdalla deo pankaj gupta department computer science university central florida abdalla deo cs ucf edu minimum spanning tree mst small diameter required numerous practical situations 
needed example distributed mutual exclusion algorithms order minimize number messages communicated processors critical section 
understanding behavior tree diameter useful example determining upper bound expected number links arbitrary documents world wide web 
diameter constrained mst dcmst problem stated follows undirected edge weighted graph nodes positive integer find spanning tree smallest weight spanning trees contain path edges 
problem known np complete values 
investigate behavior diameter mst randomly weighted complete graphs erd nyi sense explore heuristics dcmst problem 
case diameter bound small independent time tree construction ottc algorithm 
constructs dcmst modified greedy fashion employing heuristic selecting edge added tree stage tree construction 
algorithm fast easily parallelizable 
second algorithm outperforms ottc larger values starts generating unconstrained mst iteratively refines replacing edges middle long paths spanning tree path left edges 
expected performance heuristic determined diameter unconstrained mst graph 
discuss convergence relative merits implementation heuristics sequential parallel machines 
extensive empirical study shows heuristics produce solutions wide variety inputs 
keywords tree diameter greedy algorithm iterative refinement constrained minimum spanning tree 
diameter constrained minimum spanning tree dcmst problem stated follows undirected edge weighted graph positive integer find spanning tree smallest weight spanning trees contain path edges 
length longest unweighted path tree called diameter tree 
garey johnson show dcmst problem np complete transformation exact cover sets problem 
denote number nodes dcmst problem solved polynomial time special cases edge weights identical 
dcmst problem applications areas distributed mutual exclusion linear networks bit compression information retrieval 
distributed systems message passing algorithms dcmst limit number passed messages 
example raymond algorithm imposes logical spanning tree structure network processors 
messages passed processors requesting entrance critical section processors granting privilege enter 
maximum number messages generated critical section execution diameter spanning tree 
small diameter essential efficiency algorithm 
minimizing edge weights reduces cost network 
dcmst useful information retrieval large data structures called bitmaps compressing large files 
bookstein klein proposed spanning tree cluster bitmap vectors compress smaller spanning tree weight results storage space 
recover bitmap vector nodes path spanning tree decompressed 
compression spanning tree small diameter fast retrieval 
dcmst problem arises linear networks desirable short spanning tree multi transmission minimize interference network 
algorithm bala decomposes lln edge disjoint trees spanning tree computing trees maximum node degree parameter assuming lines network identical 
lln lines different bandwidths lines higher bandwidth included spanning trees traffic 
employing algorithm solves dcmst problem help find better tree decomposition type network 
network modeled edge weighted graph edge weight represent line bandwidth 
exact algorithms dcmst problem developed branch bound methods reduce number subproblems 
algorithms implemented sun sparc ii workstation operating mips tested complete graphs different orders 
fastest algorithms diameter bound produced exact solutions seconds average graphs nodes respectively 
clearly exact algorithms exponential time complexity suitable graphs thousands nodes 
special case approximation algorithm computes approximate dcmst diameter bound proposed 
algo rithm easily generalizable 
bar ilan polynomialtime approximate algorithms dcmst diameter constrained 
algorithms specifically designed provide logarithmic ratio approximation edge weights input graph elements integral non decreasing function 
suitable general dcmst problem 
significant amount literature height diameter random tree 
expected height random labeled rooted tree derived nyi 
problem tree enumeration height diameter labeled unlabeled trees addressed riordan 
showed expected value diameter diameter maximum probability respectively random labeled tree order goes infinity 
finite values experimentally study expected value mst diameter complete graphs uniformly distributed random edge weights section 
sections discuss polynomially solvable exact cases dcmst problem methods evaluate approximate solutions general cases 
approximate algorithms solving dcmst problem employ distinct strategies time tree construction ottc iterative refinement ir 
ottc algorithm section prim algorithm grows tree desired diameter constraint 
general ir algorithms sections starts unconstrained minimum spanning tree uses edge replacements transform spanning tree satisfying diameter constraint 
analyze empirical data obtained implementation algorithms section 
empirical study expected mst diameter randomly weighted complete graph spanning tree equally mst 
correspondence set minimum spanning trees randomly weighted complete graph nodes set labeled trees nodes 
behavior mst diameter randomly weighted complete graph studied unweighted random labeled trees 
number nodes small expected value labeled tree diameter calculated computing number trees possible diameter computing average 
trees hundreds thousands nodes empirical study expected value diameter considerably faster 
compared average diameter computer generated random labeled trees expected value computed formula 
mean diameter computed trees nodes randomly generated averaged different trees order 
curve fitting result error percentage obs 
dia 
sqrt obs 
dia 

percentage error approximate diameter diameter means obtained squares fit program showing difference formula 
curve fitting error illustrated stabilizes 
generate random spanning trees randomly generated pr fer code 
tried different methods calculating diameter trees 
algorithm takes na approach computing distances pairs leaves tree employing warshall floyd path algorithm time 
second method repeatedly removes leaves tree single node path remains 
diameter equal twice number deletions plus length remaining path 
queue keep track order leaves deleted method requires linear time 
third method proposed handler perform depth search dfs arbitrary node tree find farthest node node diameter 
perform dfs find farthest node gives diameter tree 
method computes diameter linear time 
compared execution time linear time algorithms pc pentium iii mhz processor set randomly generated trees nodes 
running time averaged trees order order 
seen trees order larger algorithm clearly fastest 
source code algorithms included technical report :10.1.1.24.3206
sequential time seconds handler 
comparison speed diameter calculation methods polynomially solvable cases order leaf deletion cases dcmst problem exactly solved polynomial time 
diameter constraint mst solution 
optimal solution smallest weight star computed comparing weight node star optimal dcmst computed computing stars choosing smallest weight follows clearly dcmst graph node degree nodes call construct dcmst select edge central edge node include spanning tree smaller edges 
get optimal dcmst compute spanning trees edge central edge select smallest weight 
graph edges compute different spanning trees 
trees requires comparisons select 
total number comparisons required obtain optimal dcmst complete graphs 
case edge weights equal minimum diameter spanning tree easily constructed breadth search mn time 
quality dcmst exact dcmst large graphs determined reasonable time ratio weight approximate dcmst unconstrained mst rough measure quality solution 
obtain crude upper bound approximate dcmst weight diameter constraint observe dcmst dcmst feasible grossly suboptimal solutions dcmst 
polynomial time exact algorithms dcmst dcmst solutions upper bounds weight approximate dcmst 
section develop special dcmst compare weight dcmst verify heuristic provides tighter upper bound produces lower weight spanning tree 
denote weight tree clearly mst dcmst dcmst dcmst 
special iterative refinement heuristic dcmst special case algorithm compute approximate dcmst starts exact dcmst replaces higher weight edges smaller weight edges allowing diameter increase 
refinement process starts arbitrarily selecting node central edge dcmst say center dcmst 
denote weight edge 
node adjacent attempt obtain tree replacing edge edge adjacent 
furthermore replacement edge nodes adjacent 
edge exists keep edge tree 
method compute second approximate dcmst center 
accept dcmst smaller weight approximate solution 
suppose leaves adjacent dcmst 
leaves adjacent comparisons get approximate dcmst 
shown employing procedure complete graph expected number comparisons required obtain approximate dcmst exact dcmst 
time tree construction time tree construction ottc strategy modification prim algorithm compute approximate dcmst pass 
prim algo rithm chosen experimentally shown fastest algorithm computing mst large dense graphs 
ottc algorithm starts node grows spanning tree procedure input graph diameter bound start node output spanning tree vt initialize vt initialize near wu vt compute nearest node minu vt select node smallest value set vt vt near 
set dist ecc dist near dist dist near dist ecc ecc near 
update dist near ecc near dist near ecc near ecc near 
update nodes values dist ecc tree node near dist dist near ecc max ecc dist 
update near values nodes node tree ecc near examine nodes determine near compare weight 

ottc modified prim algorithm connecting nearest neighbor violate diameter constraint 
approach keeps tree connected iteration easy keep track increase tree diameter 
modified prim algorithm formally described maintain information node near tree node tree nodes adjacent node near 
weight edge near 
dist unweighted distance tree set tree 
ecc eccentricity node distance tree farthest node tree set tree 
update near determine edges connect partially formed tree increasing diameter criterion edges want minimum weight 
code segment ottc algorithm set dist ecc values node copying parent node near 
code segment update values dist 
ecc 
parent node steps 
code segment update values dist 
ecc 
nodes 
dist 
ecc 
arrays described simplify ottc computation 
code segment update near 

values node tree 
adding node tree increase diameter constraint reexamine nodes tree find new value near 
achieved examining ecc nodes tree need recompute tree diameter 
computation includes adding new node tree minimum addition increase tree diameter constraint 
complexity code segment diameter constraint small requires looking node tree node tree 
loop requires iterations 
iteration requires steps worst case time complexity algorithm 
algorithm find dcmst 
furthermore algorithm sensitive node chosen starting spanning tree 
sequential parallel implementations compute trees starting node 
output spanning tree largest weight 
reduce time needed compute dcmst develop heuristic selects small set starting nodes ottc follows 
select nodes independent smallest sum weights edges emanating node 
defining criterion trees diameter polynomially computable 
producing spanning trees reduces time complexity factor constant 
incomplete graphs choose nodes highest degrees break tie choosing node smaller sum weights edges emanating 

example cycling iterative refinement ir iterative refinement algorithm ir general iterative refinement ir algorithm computes unconstrained mst iteratively refines mst edge replacement diameter constraint satisfied 

finding dcmst penalizing edges iteration heart ir problem specific penalty function 
penalty function succinctly encodes edges penalize edges penalize penalty amount penalty increase 
iteration ir mst graph current weights computed subset tree edges penalized discouraged appearing mst iteration 
reduce diameter subset contain edges belonging long paths current tree long paths broken short subpaths 
obviously edge center long path candidate penalized split path subpaths equal length 
penalizing edge iteration may sufficient illustrated example 
complete graph shown specified diameter bound mst path shown 
penalizing center edge recomputing mst get path shown 
center edge path penalized producing path 
algorithm fails reduce diameter tree producing tree iteration reproduces mst started 
iterative refinement cycles paths length finds spanning trees diameter 
edges penalized iteration cycling example 
solution iterations shown 
case edge weighted graph 
penalizing edges iteration may sufficient 
reduce possibility cycling number edges penalized iteration increase penalizing edges cause iterative refinement jump single iteration tree edges different missing number solutions smaller weight 
number edges penalized slow growing function say log penalize edges incident center 
log edges incident center edges distance center chosen 
tie broken choosing higher weight edge penalize 
effective causing overflow penalty value relate range weights spanning tree 
denote current weight edge penalized wmax wmin denote largest smallest edge weight respectively current mst 
denote distance edge center node plus 
center edge lc lc edge incident point center edge 
penalty amount imposed tree edge wmin wmax max wmax wmin minimum penalty ensures iterative refinement stay spanning tree imposing zero penalties edges 
penalty amount decreases penalized edge farther away center current mst long path broken significantly shorter subpaths short subpath long 
edges value edge larger weight penalized larger amount discourage appearing mst 
problem approach recomputes mst iteration reproduces spanning trees examined replacement increases diameter 
implemented algorithm succeeded avoiding cycling diameter constraint failed find approximate dcmst small constant 
different ir algorithm section avoids cycling problem produces solutions smaller values ir iterative refinement algorithm iterative refinement algorithm ir recompute mst iteration new spanning tree computed modifying 
example ir procedure ir input graph diameter bound output spanning tree diameter compute mst move false repeat diameter move true move false edges edge farther center previous iteration edges center repeat highest weight edge splits trees subtree subtree subtree subtree edge remove move true remove get replacement edge add recompute values diameter removing edges farthest center 
ir iterative refinement algorithm previously computed 
modification performed regenerate previously generated trees guarantees algorithm terminate 
ir algorithm removes edge time prevents cycling moving away center tree cycling imminent 
illustrates technique prevents cycling original graph 
computing mst algorithm considers middle edge shown bold candidate removal 
edge replacement reduce diameter consider edges little farther away center tree 
edge shown bold highest weight edge 
seen able replace edge reduces diameter 
algorithm ir starts computing unconstrained mst input graph prim algorithm 
initial eccentricity values nodes mst computed preorder tree traversal node visit consists computing distances node nodes spanning tree 
requires total computations 
spanning tree changes recompute eccentricity values change 
computing mst initial eccentricity values algorithm iteratively identifies edge remove spanning tree replaces edge diameter constraint met algorithm fails 
implemented executed variety inputs process required iterations 
iteration consists parts 
part described subsection find edge removal contribute reducing diameter second part described subsection find replacement edge 
ir algorithm shown edge replacement subprocedure shown 
denote eccentricity node respect tree maximum distance node diameter tree max nodes selecting edges removal reduce diameter edge removed break longest path tree near center tree 
center tree identifying nodes diameter node nodes minimum eccentricity 
edges candidate removal kept sorted list call implemented max heap sorted edge weights highest weight candidate edge root 
removing edge tree guarantee breaking longest paths tree 
verify removing edge splits spanning tree subtrees subtree subtree subtrees contains node equal diameter point longest path highest weight edge list satisfy condition remove list consider highest 
process continues find edge breaks longest path list empty 
list contain edge removal consider edges farther center 
done identifying nodes diameter bias bias initialized zero incremented list contains edges removal 
list recomputed edges incident set nodes time algorithm succeeds finding edge remove bias reset zero 
method examining edges helps prevent cycling considers different edge time edge removed 
guarantee prevention cycling select replacement edge reduces length path spanning tree guarantee refinement process terminate reduce diameter bound bias large try remove edges incident points longest paths worst case computing list requires examining edges requiring comparisons 
addition sorting take log time 
replacement edge helps reduce diameter time requires recomputing eccentricity values nodes 
iterative process removes replaces edges iterations take time worst case 
list sorted time computed execution time reduced constant factor prevent large 
achieved edge replacement method keeps spanning tree fairly uniform small number edges near center show subsection 
list constructed edges near center keep small 
procedure erm recompute nodes subtree minimum weight edge subtree subtree edge add edge add removed edge back move true 
edge replacement method erm selecting replacement edge remove edge tree split subtrees subtree subtree 
select non tree edge connect subtrees way reduces length longest path increasing diameter 
diameter reduced longest paths broken 
develop method erm find replacement edges 
method shown computes 

values subtree individually 
subtrees joined follows 
removed edge subtree subtree 
replacement edge smallest weight edge guarantees new edge increase diameter current spanning tree guar reducing length longest path 
enforce condition condition edge remove edge farther center tree 
replacement selected large set edges erm produces reasonably small weights creating nodes high degree near center 
implementation section empirical results obtained implementing ottc ir algorithms maspar mp massively parallel simd machine processors 
processors arranged mesh processor connected neighbors 
source code algorithms implemented written mpl included technical report :10.1.1.24.3206
complete graphs kn represented weight matrices input 
incomplete graph viewed complete graph missing edges infinite weight 
mst randomly generated graph small diameter suited studying performance dcmst algorithms 
generated graphs minimum spanning trees forced diameter 
edge weights nonnegative numbers randomly chosen equal probability erd nyi model 
weight ratio number nodes dcmst dcmst nsm nsm 
weight dcmst obtained different node search heuristics multiple mst weight 
initial diameter time tree construction parallelized ottc algorithm implemented maspar mp graphs nodes 
approximate dcmst generated start node graph nodes took roughly seconds means take hours run start nodes 
address issue running algorithm carefully selected small set start nodes 
different methods choose set start nodes 
node selection method nsm selects center nodes smallest stars start nodes 
method nsm selects nodes random 
seen weight quality dcmst obtained heuristics chose similar 
execution times heuristics identical 
results running ottc algorithm start nodes obtained graphs nodes compared results obtained start nodes graphs 
results compare average value smallest weight nsm nsm average weight ottc algorithm runs iterations 
quotient values reported 
approximate dcmst obtained nsm weight times weight iteration ottc algorithm 
weight nsm tree times iteration tree 
nsm weight ratio nsm weight ratio 
nsm weight ratio nsm weight ratio 
cases nsm outperforms nsm terms weight solutions cases 
results obtained confirm theoretical analysis predicted improvement execution time iteration algorithm described section 
weight ratio dcmst mst number nodes dcmst dcmst 
weight dcmst obtained ir multiple mst weight 
initial diameter ir iterative refinement algorithms special ir heuristic dcmst parallelized implemented maspar mp 
produced approximate dcmst weight approximately half exact dcmst see figures 
time refine dcmst approximate dcmst time calculate dcmst 
general ir algorithms parallelized implemented maspar mp 
ran code ir random graphs nodes minimum spanning trees forced hamiltonian paths 
upper bounds tree weights resulting ir reported factors minimum spanning tree weight 
results follows range upper bounds mean standard deviation runs range tree weights resulting ir mean standard deviation 
indicates remarkable performance ir diameter constraint large fraction number nodes 
algorithm fast reduced diameter node complete graph minutes 
ir algorithm unable obtain approximate dcmst small fraction number nodes 
large values expected ir enter infinite loop terminated iterations 
algorithm unable find spanning tree diameter cases graphs nodes 
graphs nodes empirical results show failure rate 
algorithm successful finding approximate dcmst graphs nodes 
indicates failure rate algorithm depend fraction value depends small constant see note algorithm fail try remove edges incident points longest paths spanning tree 
note ir moves away center spanning tree time goes entire list finding replacement edge returns center spanning tree time succeeds 
way algorithm fails unable find replacement edge diameter consecutive attempts includes going different list empirical results show algorithm fail consecutive times suitable finding approximate dcmst constant 
algorithm performs fairly data analysis excluded cases algorithm achieve diameter 
exclusion affect analysis excluded cases achieved diameter approximately speed successful attempts 
weight quality approximate dcmst obtained ir shown 
diagram shows weight computed approximate dcmst multiple weight unconstrained mst 
time taken ir obtain approximate dcmst shown 
seen figures ir achieve feasible solutions diameter mst diameter 
significantly smaller diameters solutions obtained ir 
time seconds number nodes 
time obtain dcmst ir 
initial diameter tested ir random graphs 
weight quality approximate obtained charted approximate dcmst obtained special ir heuristic explained section 
comparing obtained randomly generated graphs forced unconstrained mst diameter seen weight quality approximate dcmst graphs starting msts diameter better unrestricted random graphs 
ir keeps removing edges close center constrained spanning tree contain low weight edges unrestricted random graphs coming unconstrained mst 
unconstrained mst diameter heavy weight edges near center added earlier iterations algorithm 
approximate dcmst type graphs lose low weight edges unrestricted random graphs 
furthermore weight approximate dcmst higher approximate dcmst unrestricted random graphs lower weight exact dcmst 
note approximate dcmst heuristic approaches diameter optimization 
diameter constraint small difficult general ir algorithms find solution allow large increases tree weight order achieve required diameter 
approach upper bound weight ratio dcmst mst guarantees tree weight increase refinement process 
tested unrestricted random graphs dcmst algorithm produced approximate solutions half weight dcmst randomly generated graphs forced hamiltonian path mst 
weight quality approximate dcmst produced ir deteriorated unrestricted random graphs exceeding weight approximate dcmst produced special case algorithm 
clearly dcmst algorithm provides better solution type graphs 
number nodes dcmst dcmst dcmst 
quality dcmst heuristic ir unrestricted random graphs evident dcmst various practical applications 
empirical study behavior mst diameter randomly generated graphs 
developed approximate algorithms dcmst problem 
special case ir dcmst algorithm providing upper bound weight approximate solutions algorithm choice obtaining approximate dcmst 
ottc algorithm prim algorithm best suited small values diameter constraint diameter constraint large fraction ir provides smallest weight approximate solutions short amount time 
ir faster ottc provides low weight solutions constant larger 
abdalla deo parallel heuristics diameter constrained mst problem congressus numerantium pp 

abdalla deo gupta random tree diameter diameter constrained mst technical report cs tr university central florida orlando fl :10.1.1.24.3206
computational methods diameter restricted minimum weight spanning tree problem australasian journal combinatorics pp 

ahuja magnanti orlin network flows theory algorithms applications 
prentice hall upper saddle river nj pp 

bala stern multicasting linear network ieee infocom pp 

bar ilan peleg generalized submodular cover problems applications proceedings th israel symposium computing systems pp 

bookstein klein compression correlated bit vectors information systems pp 

deo kumar constrained spanning tree problems approximate methods parallel computation dimacs series discrete mathematics theoretical computer science pp 

erd nyi evolution random graphs publication mathematical institute hungarian academy sciences pp 

garey johnson computers intractability guide theory np completeness 
freeman san francisco 

handler minimax location facility undirected tree graph transportation science pp 

harary prins number irreducible trees species acta math pp 

horowitz sahni fundamentals computer algorithms 
computer science press md pp 

kumar deo kumar parallel generation random trees connected graphs congressus numerantium pp 

moret shapiro empirical analysis algorithms constructing minimum spanning tree dimacs series discrete mathematics theoretical computer science pp 

bounded diameter minimum spanning tree problem thesis george mason university fairfax va 
raymond tree algorithm distributed mutual exclusion acm transactions computer systems pp 

nyi height trees journal australian mathematical society pp 

riordan enumeration trees height diameter ibm journal research development pp 

distribution labelled trees diameter lecture notes math pp 

wall owicki center broadcasting technical report computer systems laboratory stanford university 
