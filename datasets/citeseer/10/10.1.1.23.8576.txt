focus building software securely improving security extensible lightweight static analysis security attacks exploit known implementation flaws occur disturbing frequency software development process include techniques preventing flaws 
authors developed extensible tool detects common flaws lightweight static analysis 
david evans david university virginia building secure systems involves numerous complex challenging problems ranging building strong cryptosystems designing authentication protocols producing trust model security policy 
despite challenges security attacks exploit human weaknesses poorly chosen passwords careless configuration software implementation flaws 
hard human help available education better interface design security conscious defaults 
software implementation flaws problems typically understood 
analyzing reports security attacks quickly reveals attacks result clever attackers discovering new kinds flaws stem repeated exploits known problems 
summarizes mitre common vulnerabilities exposures list entries january september 
entries standard buffer overflow vulnerabilities including related memory access vulnerabilities involve format bugs 
rest reveal common flaws detectable static analysis including resource leaks file name problems symbolic links 
entries involve cryptographic problems 
analyses vulnerability incident reports reveal similar repetition 
example david wagner colleagues buffer overflow vulnerabilities account approximately percent software engineering institute cert advisories 
developers keep making mistakes 
errors caused legacy code programmers lack awareness security concerns 
root problem security vulnerabilities buffer overflows understood techniques avoiding codified development process 
programmers overlook security issues especially rely undocumented assumptions procedures data types 
relying programmers memories strive produce ieee software january february ieee tools codify known common security vulnerabilities integrate directly development process 
article describes way codify knowledge 
describe splint tool uses lightweight static analysis detect vulnerabilities programs 
splint analyses similar done compiler 
efficient scalable detect wide range implementation flaws exploiting annotations added programs 
mitigating software vulnerabilities recommendation recommendation month ago haven patched software scott security program manager microsoft security response center quotation commenting internet information server buffer overflow vulnerability exploited code red worm acquire zombie machines launching denial service attack white house web site 
quotation suggests way deal security vulnerabilities wait bugs exploited attacker produce patch hope fixes problem introducing new bugs system administrators don install patches quickly 
surprisingly approach proven largely ineffective 
group promising approaches reducing software flaw damage categories mitigate damage flaws cause eliminate flaws software deployed 
limiting damage techniques limit security risks software flaws include modifying program binaries insert runtime checks running applications restricted environments limit may 
projects developed safe libraries compiler modifications specifically addressing classes buffer overflow vulnerabilities 
approaches reduce risk security vulnerabilities requiring minimal extra application developers 
disadvantage runtime approaches increase performance overhead 
importantly malformed input access buffer overflows symbolic links format bugs resource leaks pathnames approaches eliminate flaw simply replace denial service vulnerability 
recovering detected problem typically requires terminating program 
security sensitive applications damage limitation techniques approach supplant techniques eliminating flaws 
eliminating flaws techniques detect correct software flaws include human code reviews testing static analysis 
human code reviews time consuming expensive find conceptual problems impossible find automatically 
extraordinarily thorough people overlook mundane problems 
code reviews depend expertise human reviewers automated techniques benefit expert knowledge codified tools 
testing typically ineffective finding security vulnerabilities 
attackers attempt exploit weaknesses system designers consider standard testing uncover weaknesses 
static analysis techniques take different approach 
observe program executions analyze source code directly 
static analysis lets claims possible program executions just test case execution 
security viewpoint significant advantage 
range static analysis techniques offering tradeoffs re 
common vulnerabilities exposures list months 
entries common flaws detectable static analysis including buffer overflow vulnerabilities 
january february ieee software splint finds potential vulnerabilities checking see source code consistent properties implied annotations 
ieee software january february quired effort analysis complexity 
low effort standard compilers perform type checking simple program analyses 
extreme full program verifiers attempt prove complex properties programs 
typically require complete formal specification automated theorem provers 
techniques effective expensive cumbersome security critical programs 
approach lightweight static analysis techniques require incrementally effort compiler fraction effort required full program verification 
requires certain compromises 
particular heuristics assist analysis 
design criteria eschew theoretical claims favor useful results 
detecting vulnerabilities real programs depends making compromises increase class properties checked sacrificing soundness completeness 
means checker generate false warnings real problems goal create tool produces useful results real programs reasonable effort 
splint overview splint previously known lclint lightweight static analysis tool ansi describe splint version available source code binaries platforms gpl www splint org 
designed splint fast easy compiler 
checking compiler exploiting annotations added libraries programs document assumptions intents 
splint finds potential vulnerabilities checking see source code consistent properties implied annotations 
annotations denote annotations stylized comments identified character comment marker 
associate annotations syntactically function parameters return values global variables structure fields 
annotation notnull ex ample syntactically type qualifier 
parameter declaration notnull annotation documents assumption value passed parameter null 
splint reports warning call site actual parameter null 
checking function implementation splint assumes notnull annotated parameter initial value null 
return value declaration notnull annotation indicate function returns null 
splint report warning return path return null check callsite assuming function result null 
global variable declaration notnull annotation indicates variable value null interface point null function body null call site return point 
failure handle possible null return values detected normal testing exploited denial service attacks 
annotations document assumptions object lifetime 
example annotation pointer indicate sole long lived target storage temporary local aliases 
annotation implies obligation release storage 
system passing object parameter annotated returning object result annotated assigning object external annotated 
options transfers obligation 
example library storage allocator malloc annotated result free takes parameter 
way satisfy obligation release malloc storage pass free 
splint reports warning code path fails satisfy storage release obligation causes memory leak 
memory leaks typically constitute direct security threat attackers exploit increase denial service attack effectiveness 
half common vulnerabilities exposures entries involved memory leaks cve cve cve 
storage management modeled programs share procedure structure boundaries 
contend splint provides annotations describing different storage management models 
analysis theoretical practical limits analyze statically 
precise analysis interesting properties arbitrary programs depends undecidable problems including reachability determining possible aliases 
limit checking issues type checking depend solving undecidable problems admit imprecision results 
goal useful checking possible allow checking unsound incomplete 
splint produces false positives false negatives 
intend warnings useful possible programmers offer guarantee messages indicate real bugs bugs 
easy users configure checking suppress particular messages weaken strengthen checking assumptions 
static analysis designers face tradeoff precision scalability 
analysis fast scalable large programs certain compromises 
important limit analysis data flow procedure bodies 
splint analyzes procedure calls information annotations describes preconditions postconditions 
compromise flow sensitive analysis considers program paths analysis ignores control flow 
splint considers control flow paths limit analysis path blowup merges possible paths branch points 
analyzes loops heuristics recognize common idioms 
lets splint correctly determine number iterations bounds loops requiring loop invariants evaluation 
splint simplifying assumptions wrong reveals convoluted code challenge humans automated tools analyze 
provide easy ways programmers customize checking behavior locally suppress spurious warnings result imprecise analysis 
buffer overflows buffer overflow vulnerabilities single important security problem past decade 
simplest buffer overflow attack stack smashing overwrites buffer stack replacing return address 
function returns jumping return address control jumps address attacker placed stack 
attacker execute arbitrary code 
buffer overflow attacks exploit buffers heap common harder create 
programs particularly vulnerable buffer overflow attacks 
designed emphasis performance simplicity security reliability 
provides direct low level memory access pointer arithmetic bounds checking 
worse ansi library provides unsafe functions gets write unbounded amount user input buffer bounds checking 
buffers stored stack passed functions 
exploit vulnerabilities attacker merely enters input larger buffer size encoding attack program binary input 
splint detects stack heap buffer overflow vulnerabilities 
simplest detection techniques just identify calls misused functions precise techniques depend function descriptions program value analysis 
warnings simplest way detect possible buffer overflows produce warning code uses library functions susceptible buffer overflow vulnerabilities 
gets function vulnerable reasonable static analysis tool report uses gets 
library functions strcpy safely source buffer overflow vulnerabilities 
splint provides annotation warn flag specifier message precedes declaration indicate declarator produce warning 
example splint library declares gets warn gets leads buffer overflow vulnerabilities single important security problem past decade 
january february ieee software splint resolves preconditions postconditions previous statements annotated preconditions function 
ieee software january february indicate splint issue warning message gets flag set 
security scanning tools provide similar functionality including www 
com rough auditing tool security www 
com rats 
splint tools lexical analysis parsing code 
means report spurious warnings names vulnerable functions ways example local variables 
main limitation warnings imprecise 
alert humans possibly dangerous code provide assistance determining particular potentially dangerous function safe 
improve results need precise specification function safely precise analysis program values 
describing functions consider strcpy function takes char parameters copies string second parameter points buffer parameter points 
call strcpy overflow buffer pointed parameter buffer large hold string pointed second parameter 
property described adding requires clause declaration strcpy requires 
precondition uses buffer attribute annotations 
value highest integer safely lvalue left side assignment expression 
value highest integer safely rvalue 
parameter annotation indicates character string 
implies nul character 
call site splint produces warning precondition satisfied 
call strcpy produce warning splint determine 
warning indicate buffer allocated overrun strcpy call 
analyzing program values splint analyzes function body starting annotated preconditions checks function implementation ensures postconditions 
generates preconditions postconditions expression level parse tree internal rules case function calls annotated descriptions 
example declaration char buf maxsize generates postconditions buf maxsize buf 
expression buf lvalue splint generates precondition buf constraint variables identify particular code locations 
variable value change analysis distinguish values different code points 
splint resolves preconditions postconditions previous statements annotated preconditions function 
resolve generated precondition function satisfy documented postcondition splint issues descriptive warning unsatisfied condition 
buf example splint produce warning determine value maxsize 
splint propagates constraints statements axiomatic semantics simplifies constraints constraint specific algebraic rules ptr ptr handle loops heuristics recognize common loop forms 
experience indicates heuristics match loops real programs 
lets effectively analyze loops needing loop invariants expensive analyses 
extensible checking addition built checks splint provides mechanisms defining new checks annotations detect new vulnerabilities violations application specific properties 
large class useful checks described constraints attributes associated program objects global execution state 
types values attributes change execution path 
splint provides general language lets users define attributes associated attribute taintedness context char oneof untainted tainted annotations tainted tainted untainted untainted transfers tainted untainted error possibly tainted storage untainted merge tainted untainted tainted defaults tainted literal untainted null untainted different kinds program objects rules constrain values attributes interface points specify attributes change 
limited expressiveness user attributes means splint check user defined properties efficiently 
user defined attribute checking integrated normal checking splint analysis user defined attributes take advantage analyses alias analysis 
illustrate user defined checks detect new vulnerabilities taintedness attribute detect format bugs 
extensible checking detect files sockets failing close file reset read write file certain operations incompatibilities unix win 
detecting format bugs june researchers discovered new class vulnerability format bug 
attacker pass hostile input format string variable arguments routine printf attacker write arbitrary values memory gain control host manner similar buffer overflow attack 
directive particularly susceptible attack treats corresponding argument int stores number bytes printed far location 
simple way detect format vulnerabilities provide warnings format string unknown compile time 
flag set splint issues warning callsites format string known compile time 
produce spurious messages unknown format strings vulnerable hostile input 
precise way detect format bugs report warnings format string derived potentially malicious data comes user external environment 
perl taint option suggests way 
taint option activated running perl flag considers user input tainted produces runtime error halting execution tainted value unsafe way 
untainted values derived tainted input perl regular expression matching 
taintedness attribute splint detect possibly dangerous operations tainted values compile time 
accomplish define taintedness attribute associated char objects introduce annotations tainted untainted indicate assumptions taintedness 
umesh shankar colleagues similar approach 
attributes explicit rules type qualifiers 
lets take advantage type theory particular wellknown type inference algorithms automatically infer correct type qualifiers programs 
splint attributes flexible expressive type qualifiers 
shows complete attribute definition 
lines define taintedness attribute associated char objects states untainted tainted 
clause specifies rules transferring objects example passing parameter returning result 
tainted untainted error rule directs splint report warning tainted object untainted object expected 
oc 
definition taintedness attribute 
january february ieee software splint iterative process 
ieee software january february cur system passed tainted object untainted parameter returned untainted result 
transfers example untainted tainted implicitly permitted leave transferred object original state 
merge clause indicates combining tainted untainted objects produces tainted object 
tainted control path untainted control path checking assumes tainted branches merge 
merge taintedness states function specifications see strcat example section 
annotations clause defines annotations programmers declarations document taintedness assumptions 
case names annotations match taintedness states 
final clause specifies default values taintedness annotations 
choose default values easy start checking unannotated program 
assume unannotated possibly tainted splint report warning unannotated passed functions require untainted parameters 
warnings indicate format bug code place untainted annotation added 
running splint adding annotation propagate newly documented assumption program 
specifying library functions source code library code unavailable rely default annotations splint needs source code detect inconsistencies 
provide annotated declarations document taintedness assumptions standard library functions 
providing annotated declarations tainted xh file 
example int printf untainted char fmt indicates argument printf untainted 
ensures clauses indicate value tainted call returns 
example parameter tainted returns char returned char int file stream ensures tainted returned annotation parameter means return value aliases storage passed result tainted splint alias analysis uses information 
deal functions take tainted untainted objects final taintedness states parameters results depend parameters initial taintedness states 
example strcat annotated way char strcat returned char char ensures taintedness taintedness taintedness parameters lack annotations implicitly tainted default rules untainted tainted passed parameters strcat 
ensures clause means strcat returns parameter result returned annotation tainted passed object tainted 
splint merges taintedness states attribute definition rules parameter untainted parameter tainted result parameter tainted strcat returns 
experience splint iterative process 
run splint produce warnings change code annotations accordingly 
run splint check changes propagate newly documented assumptions 
continue process splint issues warnings 
splint checks approximately lines second running splint repeatedly burdensome 
splint predecessor lclint detect range problems including data hiding memory leaks dead storage usage null dereferences programs comprising hundreds thousands lines code 
lclint widely working programmers especially open source development community 
far experience buffer overflow checking extensible checking limited encouraging 
splint detect known previously unknown buffer overflow vulnerabilities wu ftpd popular ftp server bind libraries tools comprise domain name system implementation 
summarize experience analyzing wu ftpd version line program known known specifically authors analysis done format buffer overflow bugs 
detected known flaws finding previously unknown flaws wu ftpd 
takes splint seconds check wu ftpd ghz athlon machine 
format bugs running splint wu ftpd version produced warnings regarding taintedness 
ftpd function ftpd invalid transfer implicitly tainted fmt untainted possibly tainted storage untainted fmt 
ftpd fmt implicitly tainted tainted xh declared untainted annotation format string parameter 
passed value fmt parameter tainted default rules 
added untainted annotation fmt parameter declaration document assumption untainted value passed 
adding annotation splint reported warnings possibly tainted values passed reply 
added additional annotations 
running splint produced warnings involved passing global variable untainted parameter 
adding untainted annotation variable declaration directed splint ensure tainted interface point 
warnings concerned possibly tainted values passed table false warnings checking wu ftpd cause number percent external assumptions arithmetic limitations alias analysis flow control loop heuristics site exec 
values obtained remote user constituted serious vulnerability cve 
second message splint produced execution reported similar invalid transfer 
adding annotation rerunning splint additional format string bugs 
vulnerabilities described cert ca easily fixed constant format string 
ran splint wu ftpd version fixed known format bugs 
adding untainted annotations splint ran reporting format bug vulnerabilities 
buffer overflow vulnerabilities running splint wu ftpd adding annotations produced warnings potential bounds writes 
adding annotations iterative process described checking taintedness splint produced warnings 
warnings indicated real problems false summarized table 
false warnings resulted splint unaware assumptions external wu ftpd code 
example wu ftpd allocates array system constant open max specifies maximum number files process open 
program writes buffer integer value open file stream file descriptor index 
safe file descriptor value open max 
detailed specification meaning file descriptor values way static analysis tool determine memory access safe 
false warnings resulted loops correct match loop heuristics 
extent address incorporating additional loop january february ieee software tool eliminate security risks lightweight static analysis part development process applications 
ieee software january february heuristics splint unmatched loops 
remaining spurious messages resulted limitations splint ability reason arithmetic control flow aliases 
re optimistic implementing known techniques splint overcome limitations unacceptable sacrifices efficiency usability 
impossible eliminate spurious messages general undecidability static analysis 
lightweight static analysis promising technique detecting software vulnerabilities helping programmers fix software deployed patch attackers exploit problem 
static analysis important approach security panacea 
replace runtime access controls systematic testing careful security assessments 
splint find problems revealed inconsistencies code language conventions assumptions documented annotations 
occasionally inconsistencies reveal serious design flaws splint offers general mechanisms detecting high level design flaws lead security vulnerabilities 
effort involved annotating programs significant limits widely techniques near 
providing annotated standard library solves part problem 
remove need add annotations user functions correctness depends documenting assumptions cross interface boundaries 
annotating legacy programs fairly tedious mechanical currently working techniques automating process 
techniques combining runtime information static analysis automatically guess annotations show promise 
tool eliminate security risks lightweight static analysis part development process security sensitive applications 
hope security community develop tool suite knowledge security vulnerabilities way accessible programmers 
newly discovered security vulnerabilities lead just patch specific program problem checking rules detect similar problems programs prevent mistake programs 
lightweight static checking play important part codifying security knowledge moving today penetrate patch model prevent model understood security vulnerability codified tools detect automatically 
acknowledgments david evans supported nsf career award nasa langley research 
david supported usenix student research 

common vulnerabilities exposures version mitre cve mitre org current nov 

wagner step automated detection buffer overrun vulnerabilities proc 
network distributed system security symp internet society reston va www isoc org ndss proceedings current nov 

goldberg secure environment untrusted helper applications confining hacker proc 
sixth usenix security symp usenix assoc berkeley calif www cs berkeley edu daw papers janus usenix ps current nov 

evans flexible policy directed code safety ieee symp 
security privacy ieee cs press los alamitos calif pp 


singh tsai transparent run time defense stack smashing attacks proc 
ninth usenix security symp usenix assoc berkeley calif www usenix org events usenix general html current nov 

cowan stackguard automatic adaptive detection prevention buffer overflow attacks proc 
seventh usenix security symp usenix assoc berkeley calif org stackguard pdf current nov 

evans static detection dynamic memory errors sigplan conf 
programming language design implementation acm press new york pp 


ramalingam undecidability aliasing acm trans 
programming languages systems vol 
pp 


static vulnerability scanner code proc 
ann 
computer security applications conf ieee cs press los alamitos calif www acsac org abstracts html current nov 

evans statically detecting buffer overflow vulnerabilities proc 
th usenix security symp usenix assoc berkeley calif www usenix org events sec html current nov 

barker static error checking applications ported unix win systems lclint senior thesis dept computer science university virginia charlottesville 

cowan automatic protection printf format string vulnerabilities proc 
th usenix security symp usenix assoc berkeley calif www usenix org events sec 
html current nov 

wall christiansen orwant programming perl rd edition reilly associates sebastopol calif 

shankar detecting format string vulnerabilities type qualifiers proc 
th usenix security symp usenix assoc berkeley calif www 
usenix org events sec shankar html current nov 

evans lclint tool specifications check code sigsoft symp 
foundations software eng acm press new york www cs 
virginia edu evans sigsoft html current nov 

code analyzer lclint linux journal may www com article 
php sid current nov 

static checking programs lclint linux mar www com issue html current nov 

ernst dynamically discovering program invariants support program evolution proc 
int conf 
software eng ieee cs press los alamitos calif pp 

information computing topic please visit digital library computer org publications dlib 
authors software engineering professionals need know hire manage 
able produce secure high quality systems timely predictable cost effective manner 
special issue focus methods techniques enhancing software education programs worldwide academic re education alternative give graduates knowledge skills need industrial software career 
potential topics include balancing theory technology practice experience reports professional education software processes curriculum teaching software engineering practices project management requirements design construction quality security practices team building software engineering courses computer science education vs se education undergraduate vs graduate se education nontraditional education distance education asynchronous learning laboratory teaching innovative se courses curricula training workplace david evans assistant professor university virginia department computer science 
research interests include annotation assisted static checking programming swarms computing devices 
received bs ms phd computer science massachusetts institute technology 
contact department computer science school engineering applied science university virginia engineer way box charlottesville va virginia edu www cs virginia edu evans 
david phd student university virginia department computer science works lightweight static analysis focus security 
bs computer science college william mary williamsburg virginia mcs computer science university virginia 
contact department computer science school engineering applied science university virginia engineer way box charlottesville va cs virginia edu www ds 
virginia edu 
information focus contact guest editors author guidelines submission details contact magazine assistant software computer org go computer org software author htm 
submissions due software computer org april 
advance editorial comment proposed topic send guest editors extended february return comments february 
manuscripts exceed words including figures tables count words 
submissions excess limits may rejected 
articles deem theme scope peer reviewed subject editing magazine style clarity organization space 
reserve right edit title submissions 
sure include name theme submitting article 
guest editors watts humphrey software engineering institute carnegie mellon university watts sei cmu edu thomas dept computing mathematics riddle aeronautical university db edu january february ieee software 
