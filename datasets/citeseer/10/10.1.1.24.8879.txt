hints computer system design butler lampson computer science laboratory xerox palo alto research center palo alto ca studying design implementation number computer led general hints system design 
described illustrated examples ranging hardware alto dorado application programs bravo star 

designing computer system different designing algorithm external interface requirement precisely defined complex subject change 
system internal structure internal interfaces 
measure success clear 
designer usually finds floundering sea possibilities unclear choice limit freedom choices affect size performance entire system 
probably isn best way build system major part important avoid choosing terrible way clear division responsibilities parts 
designed built number computer systems worked didn studied systems successful unsuccessful 
experience come general hints designing successful systems 
claim originality part folk wisdom experienced designers 
expert forgets second system comes fourth 
disclaimer novel exceptions foolproof recipes laws system design operation precisely formulated consistent appropriate approved leading experts guaranteed 
originally 
th acm symposium operating systems principles appeared operating systems review oct 
version slightly revised 
hints computer system design july just hints 
quite general vague specific techniques widely applicable people know 
hints illustrative examples necessarily oversimplified 
controversial 
tried avoid modularity methodologies top bottom iterative design techniques data abstraction schemes widely disseminated 
pointed pitfalls application popular methods system design 
hints illustrated number examples drawn systems worked 
range hardware ethernet local area network alto dorado personal computers operating systems sds alto operating system programming systems lisp mesa application programs bravo editor star office system network servers dover printer grapevine mail system 
tried avoid obvious examples favor show unexpected uses known methods 
nearly specific examples ideas part folklore take lot track multiple sources 
precepts thy memory look thou character 
appropriate decorate guide doubtful process system design quotations hamlet 
indicated taken advice iii 
quotations sources noted 
intended apply text follows 
hint summarized slogan properly interpreted reveals essence hint 
organizes axes helps making system functionality speed fast fault tolerance keep working 
system design helps ensuring completeness choosing interfaces devising implementations 
fat lines connect repetitions slogan thin lines connect related 
body sections headings functionality section speed section fault tolerance section 

functionality important hints obtaining right functionality system getting things want 
hints depend notion interface separates implementation abstraction clients abstraction 
interface programs consists set assumptions programmer needs program order demonstrate correctness program paraphrased 
defining interfaces important part system design 
usually difficult interface design satisfy conflicting requirements interface simple complete hints computer system design july 
functionality 

completeness separate normal worst case interface thing don generalize get right don hide power procedure arguments leave client keep basic interfaces stable keep place stand implementation plan throw away keep secrets idea divide conquer admit sufficiently small fast implementation 
alas assumptions embodied interface turn misconceptions 
parnas classic device interfaces offer excellent practical advice subject 
main reason interfaces difficult design interface small programming language defines set objects operations manipulate objects 
concrete syntax issue aspect programming language design 
hoare hints language design read supplement 
keep simple perfection reached longer add longer take away 
saint friends thou adoption tried grapple thy soul steel dull thy palm entertainment new hatch 
speed fast 
shed load safety fast split resources static analysis dynamic translation cache answers hints brute force compute background batch processing summary fault tolerance keep working 
log updates actions atomic actions atomic hints thing time 
interface capture minimum essentials abstraction 
don generalize generalizations generally wrong 
hints computer system design july faced insurmountable opportunity 
kelley interface undertakes implementation probably large slow complicated 
interface contract deliver certain amount service clients interface depend contract usually documented interface specification 
depend incurring reasonable cost time scarce resources interface definition reasonable usually documented 
levels abstraction costs reasonable service delivered top factor 
kiss keep simple stupid 
anonymous doubt leave 
anonymous features 
thacker hand simple possible simpler 
einstein service fairly predictable cost interface promise implementer knows deliver 
especially promise features needed clients implementer knows provide penalizing 
better implementer comes years problem better understood able deliver wise reduce aspirations 
example pl got serious trouble attempting provide consistent meanings large number generic operations wide variety data types 
early implementations tended handle cases inefficiently optimizing compilers years hard programmer tell fast slow 
language pascal easier construct roughly constant cost independent context arguments fact constructs cost 
course observations apply strongly interfaces clients heavily virtual memory files display handling arithmetic 
right sacrifice performance functionality seldom interface password checking interpreting user commands printing point characters 
really means cost predictable times minimum achievable cost 
cautious rules don apply research object learning better implementations 
research may fail depend success 
algol improvement predecessors nearly successors 
hoare examples offering legion 
alto operating system ordinary read write bytes interface files extended interlisp ordinary paging system stores virtual page dedicated disk page 
small implementations lines code files paging fast page fault takes disk access constant computing cost small fraction disk access time client hints computer system design july fairly easily run disk full speed 
pilot system succeeded alto os follows multics systems allowing virtual pages mapped file pages subsuming file input output virtual memory system 
implementation larger lines code slower incurs disk accesses handle page fault run disk full speed 
extra functionality bought high price 
say implementation interface impossible merely hard 
system designed coded highly competent experienced people 
part problem avoiding circularity file system virtual memory virtual memory depends files 
quite general ways known solve problem tricky easily lead greater cost complexity normal case 
upshot purposes fall th inventors heads 
ii example illustrates easily generality lead unexpected complexity 
system innocent looking combination features reports unassigned virtual page trap user program 
system call viewed machine instruction extended machine unassigned virtual page similarly reported user program 
large arguments system calls including strings passed 
system call connect obtain access directory arguments string containing password directory 
password wrong call fails second delay prevent guessing passwords high speed 
connect implemented loop form length wait seconds return loop connect directory return success trick finds password length tries average uses bit characters strings 
arrange character character page page unassigned try possible character 
connect reports guess wrong system reports unassigned page correct 
arrange second character character page proceed obvious way 
obscure amusing bug went unnoticed designers interface provided system call quite complex includes possibility reported unassigned page 
looked way interface provided ordinary memory instruction system code quite complex includes possibility improper reported client chance system code get control 
hints computer system design july engineer man dime fool dollar 
anonymous times worth lot fast implementation clean powerful interface 
interface widely effort put designing tuning implementation pay times 
interface importance known existing uses 
sure know fast 
example interface manipulating raster images devised dan ingalls years experimenting alto high resolution interactive display 
implementation costs microcode entire emulator alto standard instruction set required lot skill experience construct 
performance nearly special purpose character raster operations preceded simplicity generality easier build display applications 
dorado memory system contains cache separate high bandwidth path fast input output 
provides cache read write ns cycle mbits second bandwidth virtual addressing cache special cases worry 
implementation takes msi chips consumed man years design time 
justified extensive prior experience years 
interface knowledge memory access usually limiting factor performance 
retrospect high bandwidth worth cost mainly displays dual ported frame buffer certainly better 
lest advice easy take get right 
abstraction simplicity substitute getting right 
fact abstraction source severe difficulties cautionary tale shows 
word processing office information systems usually provision embedding named fields documents handle 
example form letter address salutation fields 
usually document represented sequence characters field encoded name contents 
operations procedure finds field name 
major commercial system time procedure ran time length document 
remarkable result achieved writing procedure find ith field take time auxiliary data structure implementing name natural program name name exit loop chosen abstraction available lively awareness cost avoid disaster 
course argument abstraction aware dangers 
hints computer system design july corollaries rule simplicity generalization interesting corollaries 
costly thy habit thy purse buy express fancy rich 
fast general powerful 
fast client program function wants client program function 
better basic operations executed quickly powerful ones slower course fast powerful operation best know get 
trouble slow powerful operations client doesn want power pays basic function 
usually turns powerful operation right 
time fell death strict arrest tell 
ii example studies shown programs spend time doing simple things loads stores tests equality adding 
machines risc instructions simple operations quickly run programs faster amount hardware machines vax general powerful instructions take longer simple cases 
easy lose factor running time program amount hardware implementation 
machines ideas client needs worse 
find places time spent large system necessary measurement tools pinpoint time consuming code 
systems understood properly tuned tools normal time spent code priori analysis intuition usually find certainty 
performance tuning interlisp sped factor set effective tools 
don hide power 
slogan closely related 
low level abstraction allows done quickly higher levels bury power inside general 
purpose abstractions conceal undesirable properties desirable ones hidden 
course abstraction multiplexing resource necessarily cost 
possible deliver nearly single client slight loss performance 
example alto disk hardware transfer full cylinder disk speed 
basic file system transfer successive file pages client memory full disk speed time client computing sector sectors buffering entire disk scanned disk speed 
facility write variety applications ranging scavenger reconstructs broken file system programs search files substrings match pattern 
stream level file system read write bytes client memory portions bytes occupy full disk sectors transferred full disk speed 
loaders compilers editors programs depend hints computer system design july performance ability read large files quickly 
level client gives facility see pages arrive price paid higher level abstraction 
procedure arguments provide flexibility interface 
restricted encoded various ways necessary protection portability 
technique greatly simplify interface eliminating parameters amount small programming language 
simple example enumeration procedure returns elements set satisfying property 
cleanest interface allows client pass filter procedure tests property defining special language patterns 
theme variations 
interesting example spy system monitoring facility system berkeley allows untrusted user program plant patches code supervisor 
patch coded machine language operation installs checks wild branches contains loops long stores designated region memory dedicated collecting statistics 
spy student system fine tune measurements fear breaking system perturbing operation 
unusual example illustrates power method mechanism cal time sharing system cdc 
supervisor call possible cf executes exactly normal case sends control designated failure handler gives error return 
cf operation example extend files fast limited capacity storage device larger files slower device runs fast hopefully normal case 
may better specialized language amenable static analysis optimization 
major criterion design database query languages example 
leave client 
long cheap pass control back forth interface combine simplicity flexibility high performance solving problem leaving rest client 
example parsers confine doing context free recognition call client supplied semantic routines record results parse 
obvious advantages building parse tree client traverse find happened 
success monitors synchronization device partly due fact locking signaling mechanisms little leaving real client programs monitor procedures :10.1.1.46.7240
simplifies monitor implementation keeps fast client needs buffer allocation resource accounting provides functions calls library facilities pays needs 
fact monitors give control scheduling processes waiting monitor locks condition variables cited drawback advantage leaves client free provide scheduling needs separate condition variable class process having pay fight built mechanism right thing 
unix system encourages building small programs take character streams input produce streams output operation 
style imitated properly program simple interface thing leaving client combine set programs code achieve precisely effect desired 
hints computer system design july slogan discussed section corollary keeping simple 
continuity constant tension desire improve design need stability continuity 
keep basic interfaces stable 
interface embodies assumptions shared part system great parts desirable change interface 
system programmed language type checking nearly question change public interface way tracking clients checking elementary incompatibilities disagreements number arguments confusion pointers integers 
language mesa complete type checking language support interfaces easier change interface causing system collapse 
type checking usually detect assumption longer holds programmer correct assumption 
system grows lines code amount change intolerable doubt done takes long 
choice break system smaller pieces related interfaces stable years 
traditionally interface defined programming language operating system kernel stable 
keep place stand change interfaces 
different examples illustrate idea 
compatibility package implements old interface top new system 
allows programs depend old interface continue working 
new operating systems including cal kept old software usable simulating supervisor calls old system tops scope respectively 
usually simulators need small amount effort compared cost reimplementing old software hard get acceptable performance 
different level ibm systems provided emulation instruction sets older machines 
taken little leads virtual machines simulate copies machine machine 
different example world swap debugger works writing real memory target system debugged secondary storage device reading debugging system place 
debugger provides user complete access target world mapping target memory address proper place secondary storage 
care possible swap target back continue execution 
somewhat clumsy allows low levels system debugged conveniently debugger depend correct functioning target simple world swap mechanism 
especially useful bootstrapping 
variations 
instance debugger run different machine small nub target world interpret go commands arriving debugger network 
target process timesharing system debugger run different process 
hints computer system design july making implementations perfection reached degrees requires slow hand time 
plan throw away 
new function system implementation redone completely achieve satisfactory acceptably small fast maintainable result 
costs lot plan prototype 
unfortunately prototypes needed especially lot innovation 
lucky copy lot previous system sds 
previous system unix took ideas multics 
implementation successful pays revisit old decisions system evolves particular optimizations particular properties load environment memory size example come far optimal 
give thy thoughts tongue thought act 
keep secrets implementation 
secrets assumptions implementation client programs allowed paraphrased 
words things change interface defines things change simultaneous changes implementation client 
obviously easier program modify system parts fewer assumptions 
hand system may easier design hard design interface 
tension desire hide power 
efficient program exercise logical 
dijkstra danger keeping secrets 
way improve performance increase number assumptions part system additional assumptions allow done lot 
instance set size known sorted membership test takes time log technique important design algorithms tuning small modules 
large system ability improve part separately usually important 
striking right balance remains art 
throw away part live purer half 
iii iv divide conquer 
known method solving hard problem reduce easier ones 
resulting program usually recursive 
resources limited method takes slightly different form bite fit leaving rest iteration 
example alto scavenger program scans disk rebuilds index directory structures file system file identifier page number recorded disk sector 
rewrite program phase builds data structure main storage entry contiguous run disk pages hints computer system design july contiguous set pages file 
normally files allocated contiguously structure large 
disk badly fragmented structure fit storage 
happens scavenger discards information half files continues half 
index files rebuilt process repeated files 
necessary subdivided method fails single file index won fit 
interesting example arises dover raster printer scan converts lists characters rectangles large array bits ones correspond spots ink zeros spots ink 
printer array contains fourteen bits large store memory 
printer consumes bits faster available disks deliver array stored disk 
entire array divided bit slices called bands printer electronics contains band buffers 
characters rectangles sorted buckets band bucket receives objects start corresponding band 
scan conversion proceeds filling band buffer bucket playing printer zeroing filling buffer bucket 
objects spill edge band added bucket trick allows problem subdivided 
convenient artificially limit resource quantizing fixed size units simplifies bookkeeping prevents kind fragmentation 
classical example fixed size pages virtual memory variable size segments 
spite apparent advantages keeping logically related information transferring main storage backing storage unit paging systems worked better 
reasons complex systematically studied 
bear fly know 
iii idea generalizing 
specialized implementation idea may effective general 
discussion caching gives examples applying general principle 
interesting example notion replicating data reliability 
small amount data easily replicated locally writing disk drives 
amount data large data recorded separate machines easy ensure copies 
gifford shows solve problem building replicated data top transactional storage system allows arbitrarily large update done atomic operation see section 
transactional storage depends simple local replication scheme store log reliably 
circularity idea twice code 
third way replication context store commit record machines 
user interface star office system small set operations type text move copy delete show properties apply nearly objects system text graphics file folders file record files printers baskets exact meaning operation varies class object limits user find natural 
instance copying document basket causes sent message moving endpoint line causes line follow rubber band 
certainly implementations quite different cases 
generic operations simply system easier hints computer system design july represent view operations possible implementation class object organized 
handling cases diseases desperate grown desperate appliance 
iii vii project back second hold blast proof 
iv iii handle normal worst cases separately rule requirements quite different normal case fast 
worst case progress 
systems right schedule unfairly give service processes deadlock entire system long event detected automatically doesn happen 
usual recovery crashing processes entire system 
sounds terrible crash week usually cheap price pay better performance 
course system decent error recovery application toend principle see section required case possible causes crash 
caches hints section examples special treatment normal case 
interlisp cedar programming systems counting garbage collector important optimization kind 
pointers local frames activation records procedures counted frames scanned garbage collected 
saves lot counting pointer assignments local variables 
frames time scan small collector nearly real time 
cedar goes farther keep track local variables contain pointers assumes 
means integer happens contain address object longer referenced keep object freed 
measurements show storage incorrectly retained 
counting easy incremental collector computation need collection 
reclaim circular structures longer reachable 
cedar conventional trace sweep collector 
suitable real time applications stops entire system seconds interactive applications coffee breaks reclaim accumulated circular structures 
problem counting count may overflow space provided 
happens seldom objects 
simple maximum value sticky 
unfortunately applications root large structure referenced places root sticky lot storage hints computer system design july unexpectedly permanent 
attractive solution overflow count table hash table keyed address object 
count reaches limit reduced half overflow count increased overflow flag set object 
count reaches zero process reversed overflow flag set 
bits room count overflow table touched rare case count swings 
cases resources dynamically allocated freed example real memory paging system additional resources needed temporarily free item table swapped find write page 
normally cushion clean pages freed worst case cushion may disappear pages dirty 
trick keep little reserve bringing crisis 
necessary bound resources needed free item determines size reserve regarded fixed cost resource multiplexing 
crisis arrives item freed time entire reserve devoted job may slow things lot ensures progress 
radically different strategies appropriate normal worst cases 
bravo editor uses piece table represent document edited 
array pieces pointers strings characters stored file piece contains file address character string length 
strings modified normal editing 
characters deleted example piece containing deleted characters split pieces pointing string second 
characters inserted keyboard appended file piece containing insertion point split pieces preceding characters second inserted characters third characters 
hours editing hundreds pieces things start bog 
time cleanup writes new file containing characters document order 
piece table replaced single piece pointing new file editing continue 
cleanup specialized kind garbage collection 
done background user doesn editing bravo doesn 

speed section describes hints making systems faster discussion important 
bentley excellent book says ideas gives 
borrower loan oft loses friend borrowing edge 
split resources fixed way doubt sharing 
usually faster allocate dedicated resources faster access behavior allocator predictable 
obvious disadvantage total resources needed ignoring multiplexing overheads come common pool 
cases cost extra resources small overhead larger fragmentation 
hints computer system design july example faster access information registers processor get memory machine high performance cache 
registers gotten bad name tricky allocate intelligently saving restoring procedure calls may negate speed advantages 
programs written approved modern style lots small procedures registers nearly local variables temporaries allocation problem 
sets registers arranged stack saving needed successive calls return 
input output channels floating point coprocessors similar specialized computing devices applications principle 
extra hardware expensive services provided multiplexing single processor cheap static allocation computing power various purposes worthwhile 
interlisp virtual memory system mentioned earlier needs keep track disk address corresponding virtual address 
information held virtual memory systems including pilot need avoid circularity complicated 
real memory dedicated purpose 
disk fragmented space consumed space code prevent circularity 
static analysis generalization slogan 
static analysis discovers properties program usually improve performance 
hooker static analysis possible don bad fall back dynamic scheme 
remarks registers depend fact compiler easily decide allocate simply putting local variables temporaries 
machines lack multiple sets registers lack way stacking efficiently 
allocation difficult requiring elaborate inter procedural analysis may succeed case redone time program changes 
little bit dynamic analysis stacking registers goes long way 
course static analysis pay large procedure compiler clever 
program read data faster reads data sequentially 
easy predict data needed read ahead buffer 
data allocated sequentially disk allows transferred order magnitude faster 
performance gains depend fact programmer arranged data accessed predictable pattern static analysis possible 
attempts analyze programs fact optimize disk transfers far know worked 
dynamic analysis done demand paging 
kinds static analysis exploit fact invariant maintained 
system depends facts may robust face hardware failures bugs software falsify invariant 
dynamic translation convenient compact easily modified easily displayed representation quickly interpreted important variation old idea compiling 
translating bit time idea separate compilation goes back hints computer system design july fortran 
incremental compilers automatically statement procedure changed 
mitchell investigated smooth motion continuum convenient fast representation 
simpler version scheme translation demand cache result interpreter required decisions needed cache replacement 
example experimental smalltalk implementation uses bytecodes produced standard smalltalk compiler convenient case compact representation translates single procedure byte codes machine language invoked 
keeps cache room instructions translated code 
scheme pay cache large average procedure executed times ratio translation time execution time code 
machine stack cache provides different example 
device instructions fetched instruction cache loaded operand address relative local frame pointer fp converted absolute address current value fp remains constant execution procedure 
addition resulting address range addresses currently stack data cache operand changed register mode execution instruction access register directly data cache 
fp value concatenated instruction address form key translated instruction cache multiple activations procedure 
thou hold thy heart 
ii cache answers expensive computations doing 
storing triple associative store keys retrieve lookup 
faster needed gets replaced cache presumably limited capacity 
faster depends expensive compute 
serious problem functional give different results arguments need way invalidate update cache entry value changes 
updating depends equation form cheaper compute example array numbers sum array elements new value pair 
sum sum cache small hold active values thrash recomputing expensive performance suffer badly 
wise choose cache size adaptively making bigger hit rate decreases smaller entries go unused long time 
classic example caching hardware speeds access main storage entries triples fetch address contents address 
fetch operation certainly functional fetch gives different answer store done 
cache updated invalidated store 
virtual memory systems exactly thing main storage plays role cache disk plays role main storage unit transfer page segment 
nearly non trivial system specialized applications caching 
especially true interactive real time systems basic problem incrementally update complex state response frequent small changes 
doing ad hints computer system design july hoc way extremely error prone 
best organizing principle recompute entire state change cache expensive results computation 
change invalidate cache entries renders invalid hard identify precisely may invalidate entries price computing reestablish 
secret success organize cache small changes invalidate entries 
example bravo editor function document returns bitmap line text displayed document document character 
returns numbers character displayed line character examined computing bitmap usually necessary look past line order choose line break 
function computes line breaks justification uses font tables map characters raster pictures cache entry line currently displayed screen lines just 
edit changes characters invalidates cache entry 
intersects 

display recomputed loop bitmap document paint bitmap loop call short circuited cache entry document exists 
cache entry discarded entries invalid longer interesting line breaks changed line longer begins points 
idea applied different setting 
bravo allows document structured paragraphs specified left right margins inter line leading ordinary page layout information paragraph needed layout represented compactly number lines height line normally lines height keep properties pre post leading 
usual case encoded bytes 
page chapter paragraphs bytes required data information required specify characters page 
layout computation comparable line layout computation page possible chapter time required render page 
layout done independently chapter 
idea cache paragraph paragraph entries 
paragraph edited cache entry invalid recomputed 
done time edit reasonable paragraph screen usually case global substitute background requested 
hints computer system design july apparel oft man hints speed normal execution 
hint cache entry saved result computation 
different ways may wrong necessarily reached associative lookup 
hint may wrong way check correctness unrecoverable action 
checked truth information correct optimized purpose efficient execution 
cache entry purpose hint system run faster 
usually means correct nearly time 
example alto pilot operating systems file unique identifier disk page label field contents checked reading writing data slowing data transfer 
label contains identifier file contains page number page file 
page zero file called leader page contains things directory file resides string name directory 
truth file systems take great pains keep correct 
information way find identifier file name directory find disk address page search entire disk method works unacceptably slow 
system maintains hints speed operations 
systems represent directory file contains triples string name file identifier address page 
file data structure maps page number disk address page 
alto uses link label points label fast get page page 
pilot uses tree implements map directly advantage common case consecutive file pages occupy consecutive disk pages 
information obtained hints checked checking label reading file name leader page 
proves wrong reconstructed scanning disk 
similarly bit table keeps track free disk pages hint truth represented special value label free page checked page allocated label overwritten file identifier page number 
example hints store forward routing arpanet 
node network keeps table gives best route node 
table updated periodic broadcasts node announces nodes opinion quality links neighbors 
broadcast messages synchronized guaranteed delivered nodes may consistent view instant 
truth case node knows identity knows receives packet destined 
rest routing best things aren changing fast nearly optimal 
curious example ethernet lack carrier signal cable hint packet sent 
senders take hint simultaneously collision detect delay randomly chosen interval try 
successive collisions occur taken hint number senders sender sets mean random delay interval times initial value 
exponential backoff ensures net overloaded 
hints computer system design july different application hints speeds execution smalltalk programs 
smalltalk code executed procedure called determined dynamically type argument 
print format invokes print procedure part type smalltalk declarations type known statically 
object pointer table pairs procedure name address code call executed print looked table normalized unusual smalltalk terminology syntax oversimplified bit 
expensive 
turns usually type time 
code call print format arranged push format push push call print procedure begins pop pop type print body procedure 
immediate values stored code 
idea store type code address finds back fields 
type time procedure called directly 
measurements show cache hits time 
machine instruction fetch unit scheme nice property transfer proceed full speed hint correct call fast ordinary subroutine call 
check arranged normally branch 
idea different guise extra bit instruction instruction cache 
clears bit instruction loaded sets instruction causes branch taken uses choose path instruction fetch unit follows 
prediction turns wrong changes bit follows path 
doubt brute force 
especially cost hardware declines straightforward easily analyzed solution requires lot special purpose computing cycles better complex poorly characterized may certain assumptions satisfied 
example ken thompson chess machine belle relies mainly special purpose hardware generate moves evaluate positions sophisticated chess strategies 
belle won world computer chess times 
instructive example success personal computers time sharing systems include cleverness fewer wasted cycles increasingly recognized cost effective way interactive computing 
asymptotically faster algorithm necessarily better 
algorithm multiplies matrices faster constant factor prohibitive 
mundane note compiler uses linear search look symbols student programs symbols setup time better algorithm recovered 
compute background possible 
interactive real time system little possible responding request 
reason twofold rapid response better users second load usually varies great deal idle processor time background 
kinds deferred background 
interlisp cedar garbage collectors nearly way 
paging systems write dirty pages prepare candidates hints computer system design july replacement background 
electronic mail delivered retrieved background processes delivery hour usually acceptable 
banking systems consolidate data accounts night ready morning 
examples successively need synchronization foreground background tasks 
amount synchronization increases care needed avoid subtle errors extreme example fly garbage collection algorithm 
cases simple producer consumer relationship independent processes possible 
batch processing possible 
doing things incrementally costs aside fact disks tapes better accessed sequentially 
batch processing permits simpler error recovery 
bank america interactive system allows tellers record deposits check withdrawals 
loaded current account balances morning best maintain day 
early morning line data discarded replaced results night batch run 
design easier meet bank requirements trustworthy long term data significant loss function 
wary best safety lies fear 
iii safety 
allocating resources strive avoid disaster attain optimum 
years experience virtual memory networks disk allocation database layout resource allocation problems clear general purpose system optimize resources 
hand easy overload system drastically degrade service 
system expected function demand resource exceeds thirds capacity load characterized extremely 
fortunately hardware cheap getting cheaper afford provide excess capacity 
memory especially cheap especially fortunate extent plenty memory allow resources processor cycles communication bandwidth utilized fully 
sad truth optimization brought home paging systems 
days memory expensive people visions squeezing byte clever optimization swapping putting related procedures page predicting pages referenced previous running jobs share data code learned 
memory got cheaper systems spent provide cushion simple demand paging 
learned important thing avoid thrashing demand available memory 
system spends time waiting disk 
systems cleverness worked known loads 
instance apl system size workspace user common system code 
system code resident allocates contiguous piece disk user overlaps swap swap unit computation 
works fine 
thing alto doesn run faster night 
morris similar lesson learned processor time 
interactive response time demand computing important person waiting 
attempts hints computer system design july tune processor scheduling function priority computation working set size memory loading past history likelihood request 
efforts failed 
parameters produce intelligible effects interactive vs non interactive computation high foreground background priority levels 
successful schemes give fixed share cycles job don allocate unused cycles wasted luck consumed background job 
natural extension strategy personal computer user processor 
give man thy ear thy voice take man reserve thy judgment 
shed load control demand allowing system overloaded 
corollary previous rule 
ways shed load 
interactive system refuse new users deny service existing ones 
memory manager limit jobs served working sets fit available memory 
network discard packets 
comes worst system crash start 
bob morris suggested shared interactive system large red button terminal 
user pushes button dissatisfied service system improve service throw user equitable choice sufficiently long period 
idea keep people wasting time front terminals delivering useful amount service 
original specification arpanet packet accepted net guaranteed delivered recipient machine network node fails holding packet 
turned bad idea 
rule hard avoid deadlock worst case attempts obey lead complications inefficiencies normal case 
furthermore client benefit deal packets lost host network failure see section 
eventually rule abandoned 
pup internet faced variable set transport facilities discarded packets sign congestion 

fault tolerance unavoidable price reliability simplicity 
hoare making system reliable really hard know go 
retrofitting reliability existing design difficult 
self true follow night day thou false man 
error recovery application level absolutely necessary reliable system error detection recovery logically necessary strictly performance 
observation saltzer widely applicable 
example consider operation transferring file file system disk attached machine file system disk attached machine confident right bits really disk read file disk compute checksum hints computer system design july reasonable length say bits find equal checksum bits disk 
checking transfer disk memory network memory disk sufficient trouble point bits clobbered sitting memory 
checks necessary check fails entire transfer repeated 
course lot errors frequent intermediate checks reduce amount repeated 
strictly question performance irrelevant reliability file transfer 
ring system cambridge customary copy entire disk pack mbytes check errors infrequent minutes seldom needs repeated 
uses hints applications idea 
alto file system described earlier example check label disk sector writing sector ensures disk address write correct 
precautions taken address correct may important critical performance affect reliability file system 
pup internet adopts strategy levels 
main service offered network transport data packet source destination 
packet may traverse number networks widely varying error rates properties 
internet nodes store forward packets may run short space forced discard packets 
rough estimates best route packet available may wildly wrong parts network fail resume operation 
face uncertainties pup internet provides service simple implementation attempting best efforts delivery 
packet may lost notice sender may corrupted transit 
clients provide error control deal problems higher level pup protocols provide complex services reliable byte streams 
packet transport attempt report problems clients providing modest amount error control bit checksum notifying senders discarded packets possible services intended improve performance face unreliable communication overloading best efforts don complicate implementation 
problems strategy 
requires cheap test success 
second lead working systems severe performance defects may appear system operational placed heavy load 
remember thee 
table memory ll wipe away trivial fond records books forms pressures past youth observation copied thy shall live book volume brain matter 
log updates record truth state object 
log simple data structure reliably written read cheaply forced disk stable storage survive crash 
append amount writing minimized hints computer system design july fairly easy ensure log valid matter crash occurs 
easy cheap duplicate log write copies tape 
logs years ensure information data base lost idea general ordinary file systems obvious situations 
log holds truth current state object hint isn exactly hint cheap way check correctness 
technique record update object log entry consisting name update procedure arguments 
procedure functional applied arguments effect 
words state outside arguments affects operation procedure 
means procedure call specified log entry re executed object updated state update done state update done 
induction means sequence log entries re executed starting objects produce objects produced original execution 
requirements satisfied update procedure true function result depend state outside arguments 
side effects object log appears 
arguments values immediate values integers strings immediate value large thing array list entire value copied log entry 
immutable objects 
objects course immutable updated 
particular version object immutable changes object change version 
simple way refer object version unambiguously pair object identifier number updates 
object identifier leads log object replaying specified number log entries yields particular version 
course doing replay may require finding object versions long update refers existing versions won cycles process terminate 
example bravo editor exactly update functions editing document replace old interval new interval interval interval triple document version character character 
function properties properties property italic italic true 
kinds log entries needed 
editing commands reduce applications functions 
hints computer system design july beware entrance bear th opposed may beware thee 
actions atomic restartable 
atomic action called transaction completes effect 
example main storage systems fetching storing word atomic 
advantages atomic actions fault tolerance obvious failure occurs action effect recovering failure necessary deal intermediate states action 
database systems provided atomicity time log store information needed complete cancel action 
basic idea assign unique identifier atomic action label log entries associated action 
commit record action tells progress committed logically complete cleanup remains done aborted logically canceled cleanup remains changes state commit record recorded log entries 
action committed log entries updates 
failure recovery applies log entries committed action undoes updates aborted action 
variations scheme possible 
log entry usually needs restartable 
means partially executed number times complete execution changing result action called idempotent 
example storing set values set variables restartable action incrementing variable 
restartable log entries applied current state object need recover old state 
basic method kind permanent storage 
things simple distorted version 
alto file system described example effect uses disk labels leader pages log rebuilds data structures necessary 
file systems file allocation directory actions atomic file system help client updates atomic 
file system goes allowing client arbitrary set updates single atomic action 
uses trick known shadow pages data pages moved log files simply changing pointers tree implements map file addresses disk addresses trick cal system 
cooperating clients ordinary file system implement atomic actions checking recovery needed access file carry entries specially named log files 
atomic actions trivial implement general preceding discussion tries show nearly hard public image suggests 
weaker cheaper method 
grapevine mail transport registration system example maintains replicated data base names distribution lists large number machines nationwide network 
updates site propagated sites mail system 
guarantees updates eventually arrive sites fail recover network partitions order arrive may vary greatly 
update message time stamped latest wins 
time passed sites receive updates agree 
propagation sites may disagree hints computer system design july example person member certain distribution list 
occasional disagreements delays important usefulness particular system 

take leave lord 
collection advice anecdotes tiresome read best taken small doses 
ignored rules nearly 
tell fuller stories systems techniques sketched 
complete 
collected near 
acknowledgments am indebted sympathetic readers earlier drafts comments program committee 

birrell grapevine exercise distributed computing 
comm 
acm april pp 

bobrow paged time sharing system pdp 
comm 
acm march pp 

boggs pup internetwork architecture 
ieee trans 
communications com april pp 

breed implementation apl 
interactive systems experimental applied mathematics eds academic press pp 

britton procedure designing interfaces device interface modules 
proc 
th int conf 
software engineering ieee computer society order pp 

brooks mythical man month addison wesley 

burton interlisp overview 
papers interlisp technical report ssl xerox palo alto research center 

clark memory system high performance personal computer 
ieee trans 
computers tc oct pp 

origin vm time sharing system 
ibm res 
develop 
sep pp 

deutsch 
flexible measurement tool software systems 
proc 
ifip congress north holland 

deutsch bobrow efficient incremental automatic garbage collector 
comm 
acm sep pp 
hints computer system design july 
deutsch efficient implementation smalltalk system 
proc 
th acm symposium principles programming languages 

dijkstra 
fly garbage collection exercise cooperation 
comm 
acm nov pp 

register allocation free machine stack cache 
sigplan notices april pp 

early experience mesa 
comm 
acm aug pp 

gifford weighted voting replicated data 
operating systems review dec pp 

gray recovery manager system database manager 
computing surveys june pp 

hansen performance evaluation intel computer architecture news june pp 

hoare hints programming language design 
sigact sigplan symposium principles programming languages boston oct 

hoare monitors operating system structuring concept 
comm 
acm oct pp 

ingalls smalltalk graphics kernel 
byte aug pp 

janson type extension organize virtual memory mechanisms 
operating systems review oct pp 

knuth empirical study fortran programs software practice experience mar pp 

lampson 
bravo manual 
alto users handbook xerox palo alto research center 

lampson redell experience processes monitors mesa 
comm 
acm feb pp 

lampson electronic image processing system patent may 

lampson replicated commit 
circulated workshop fundamental principles distributed computing mesa ca dec 

lampson sturgis atomic transactions 
distributed systems advanced course lecture notes computer science springer pp 

lampson sproull open operating system single user machine 
operating systems review dec pp 

lampson sturgis reflections operating system design 
comm 
acm may pp 

mcneil tracz pl program efficiency 
sigplan notices june pp 

walden arpa network design decisions 
computer networks aug pp 
hints computer system design july 
metcalfe boggs ethernet distributed packet switching local computer networks 
comm 
acm july pp 

mitchell design construction flexible efficient interactive programming systems 
garland 

mitchell dion comparison network file servers 
comm 
acm april pp 

needham personal communication 
dec 

newman sproull principles interactive computer graphics nd ed mcgraw hill 

parnas criteria decomposing systems modules 
comm 
acm dec pp 

patterson sequin risc reduced instruction set vlsi computer 
th symp 
computer architecture ieee computer society order may pp 

client transaction system maintain data integrity 
operating systems review dec pp 

sigplan notices april pp 

redell pilot operating system personal computer 
comm 
acm feb pp 

reed naming synchronization decentralized computer system mit lcs tr 
sep 

ritchie thompson unix time sharing system 
bell system tech 
july pp 

personal communication 
dec 

saltzer arguments system design 
proc 
nd int conf 
distributed computing systems paris april pp 

smith designing star user interface 
byte april pp 
smith study branch prediction strategies 
th symp 
computer architecture ieee computer society order may pp 

sturgis issues design distributed file system 
operating systems review july pp 

sturgis time sharing system 
technical report csl xerox palo alto research center 

sweet static analysis mesa instruction set 
sigplan notices april pp 

tanenbaum implications structured programming machine architecture 
comm 
acm march pp 
hints computer system design july 
thacker alto personal computer 
computer structures principles examples nd ed siewiorek bell newell eds mcgraw hill 

traiger virtual memory management data base systems 
operating systems review oct pp 

bentley writing efficient programs 
prentice hall 
hints computer system design july 
