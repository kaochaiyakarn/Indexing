points analysis java annotated constraints rountev ana milanova barbara ryder department computer science rutgers university new brunswick nj rountev milanova ryder cs rutgers edu goal points analysis java determine set objects pointed variable object field 
information wide variety client applications optimizing compilers software engineering tools 
points analysis java andersen points analysis :10.1.1.109.6502:10.1.1.109.6502
implement analysis constraint approach employs annotated inclusion constraints 
constraint annotations allow model precisely ciently semantics virtual calls flow values object fields 
solving systems annotated inclusion constraints able perform practical precise points analysis java 
evaluate performance analysis large set java programs 
experiments show analysis runs practical time space 
show points solution significant impact clients object read write information call graph construction virtual call resolution synchronization removal object allocation 
results demonstrate analysis realistic candidate relatively precise practical general purpose points analysis java 

performance improvement compiler technology important making java viable choice production strength software 
addition development large java software systems requires strong support software engineering tools program understanding maintenance testing 
optimizing compilers software engineering tools employ various static analyses determine properties run time program behavior 
fundamental static analysis points analysis 
java points analysis determines set objects addresses may stored variable digital hard copies part personal classroom granted fee provided copies distributed profit commercial advantage copies bear notice full citation page 
copy republish post servers redistribute lists requires prior specific permission fee 
oopsla tampa florida usa copyright acm ence object field 
computing points sets variables fields analysis constructs abstraction run time memory states analyzed program 
abstraction typically represented pointsto graphs 
example points graph shown discussed 
points analysis enables variety analyses example side ect analysis determines memory locations may modified execution statement def analysis identifies pairs statements set value memory location subsequently value 
analyses needed compilers perform known optimizations code motion partial redundancy elimination 
analyses important context software engineering tools example def analysis needed program slicing data flow testing 
points analysis crucial prerequisite employing analyses optimizations 
addition enabling analyses points analysis directly optimizing java compilers perform variety popular optimizations virtual call resolution removal unnecessary synchronization stack object allocation 
typically optimizations specialized analysis designed purpose specific optimization 
compilers employ multiple optimizations need implement di erent analyses 
contrast single generalpurpose points analysis enable di erent optimizations 
furthermore cost analysis amortized client optimizations development ort implement optimizations significantly reduced 
applications points analysis important investigate approaches precise cient computation points information 
define evaluate points analysis java andersen points analysis extensions necessary handle object oriented features :10.1.1.109.6502:10.1.1.109.6502
andersen analysis relatively precise flow context insensitive analysis cubic worst case complexity 
despite complexity previous shown certain constraint techniques allow cient implementations analysis 
developed constraint flow insensitive analysis ignores flow control program points 
context insensitive analysis distinguish di erent invocations procedure 
approach extends previous features necessary points analysis java 
introduce constraint annotations show implement analysis annotated inclusion constraints form constraint annotation expressions representing points sets 
annotations play roles analysis 
method annotations model precisely ciently semantics virtual calls representing relationships virtual call receiver objects target methods 
field annotations allow separate tracking flow values different fields object 
techniques cient representation resolution systems annotated inclusion constraints able perform practical precise points analysis java 
disadvantage andersen analysis implicit assumption code program executable 
java programs contain large portions unused library code including dead code negative ects analysis cost precision 
analysis keep track methods potentially reachable entry points program analyze reachable methods 
implemented analysis evaluated performance large set java programs 
data programs analysis time minute 
large programs analysis runs minutes uses mb memory 
results show analysis runs practical time space realistic candidate relatively precise general purpose points analysis java 
evaluated impact analysis possible client applications 
results show analysis precision determining objects may read written program statements object readwrite information prerequisite clients ect analysis def analysis dependence analysis 
addition measurements show significant improvement precision program call graph 
profiling experiments observe cases analysis allows resolution majority run time virtual calls 
experiments show points solution detect large number objects need synchronization stack allocated 
contributions 
contributions define general purpose points analysis java andersen points analysis show implement analysis constraint approach employs annotated inclusion constraints 
implementation models virtual calls object fields precisely ciently analyzes reachable methods 
evaluate analysis large set java programs 
results show analysis runs practical time space significant impact object read write information call graph construction virtual call resolution synchronization removal stack object allocation 
class 
class void set static void main new new set sample program points graph 
outline 
rest organized follows 
section defines semantics points analysis 
section discusses applications points analysis java 
section describes general structure annotated inclusion constraints section contains details constraint points analysis 
experimental results section 
section discusses related section presents 

java section define semantics points analysis java section describes implementation analysis annotated inclusion constraints 
analysis defined terms sets 
set contains variables analyzed program including static variables 
set contains names objects created object allocation sites allocation site separate object name set contains instance fields program classes 
analysis semantics expressed manipulations points graphs containing kinds edges 
edge shows variable points object edge shows field object points object sample program points graph shown 
simplify presentation discuss kinds statements listed actual implementation described section handles entire language 
direct assignment instance field write instance field read object creation new virtual invocation rk virtual call name uniquely identifies method program 
method compile time target call determined declared type section 
run time invoked method determined examining class receiver object superclasses finding method matches signature return type section 
new 
rn resolve 
rn resolve 
rn 
pn ret dispatch 
ret points ects program statements 
analysis semantics defined terms rules adding new edges points graphs 
rule represents semantics program statement 
shows rules functions form stmt points set set successors graph denoted 
solution computed analysis points graph closure empty graph edge addition rules 
statements ects points graph straightforward example statement creates new points edges objects pointed virtual call sites resolution performed receiver object pointed function dispatch uses class object compile time target call determine actual method invoked run time 
variables 
pn formal parameters method variable corresponds implicit parameter 
variable ret contains return value 
applications points analysis java points analysis optimizing compilers software engineering tools advantages 
single points analysis enable wide variety client applications 
cost analysis amortized clients 
implemented analysis reused various clients additional development cost reusability important practical advantage 
section briefly discuss specific applications pointsto analysis java 
experiments evaluated impact analysis applications results experiments section 
object read write information points analysis determine objects read written program statement 
information necessary prerequisite variety analyses 
example purposes side ect analysis points information answer questions statement modify field object pointed 
points information needed answer questions statement read memory locations written statement necessary def analysis dependence analysis 
analyses require read write information compilers perform various optimizations code motion partial redundancy elimination 
addition analyses play important role variety software engineering tools context program slicing dataflow testing 
practical precise points analysis crucial enabling analyses optimizations 
call graph construction virtual call resolution points solution determine target methods virtual call examining classes possible receiver objects 
set target methods needed construct call graph analyzed program graph prerequisite interprocedural analyses optimizations java compilers tools 
call target method resolved replacing virtual call direct call optimization eliminates run time overhead virtual dispatch 
addition virtual call resolution allows subsequent inlining target method potentially enabling additional optimizations caller 
synchronization removal synchronization java allows safe access shared objects multi threaded programs 
object associated lock ensure mutual exclusion 
synchronization operations locks considerable runtime overhead overhead occurs single threaded programs standard java libraries written thread safe manner 
static analysis detect properties allow removal unnecessary synchronization 
example synchronization necessary object escape creating thread accessed thread thread local object 
escape analyses identify thread local objects remove synchronization constructs associated objects :10.1.1.12.2189
points analysis alternative escape analysis detecting thread local objects 
consider object suppose points graph computed analysis reachable static global variables ii objects classes implement interface java lang runnable proven case accessible outside thread created 
identify thread local objects performing reachability computation points graph approach similar multithreaded object analysis proposed aldrich 
synchronization operations removed objects receiving wait notify notifyall messages modified program may throw 
problem avoided maintaining information needed notification methods performing actual synchronization 
run methods objects starting points new threads 
stack allocation cases object allocated method stack frame heap 
transformation reduces garbage collection overhead enables additional optimizations object reduction 
similarly synchronization removal static analysis detect properties allow stack allocation 
example stack allocation possible object may escape lifetime creating method accessed lifetime object 
escape analyses detect method local objects clearly objects allocated stack frames creating methods :10.1.1.12.2189
points analysis alternative escape analysis identifying method local objects 
suppose object classified thread local points solution reachable static variables objects implementing runnable 
suppose computed points graph reachable formal parameters return variable method created case proven method local identify method local objects traversing points graph 

constraints section describes general structure annotated inclusion constraints points analysis java 
details specific kinds constraints annotations discussed section 
previous constraint implementations andersen analysis employ non annotated inclusion constraints 
developed constraint approach extends previous introducing constraint annotations 
analysis annotations model flow values virtual call site run time target methods call 
addition annotations allow separate tracking di erent object fields possible constraints 
constraint language consider annotated set inclusion constraints form chosen set annotations 
assume element set designated empty annotation denote constraints labeled 
expressions representing sets defined grammar 
vn proj set variables 
constructed terms proj 
projection terms 
constructed term built ary constructor constructor covariant contravariant arguments role variance constraint resolution explained shortly 
constructed terms may appear sides inclusion relations 
represent empty set universal set treated nullary constructors 
projections form proj terms select th argument constructed term described shortly 
projection terms may appear vn covariant 
contravariant 
vn proj covariant contravariant resolution rules non atomic constraints 
right hand side inclusion 
annotated constraint graphs systems constraints language represented directed multi graphs 
constraint represented edge node node edge labeled annotation multiple edges pair nodes di erent annotation 
nodes graph classified variables sources sinks 
sources constructed terms occur left hand side inclusions 
sinks constructed terms projections occur right hand side inclusions 
graph contains edges represent atomic constraints forms source var var var var sink 
constraint system contains non atomic constraint resolution rules generate new atomic constraints described section 
annotated constraint graphs inductive form representation 
inductive form cient sparse representation explicitly represent transitive closure constraint graph 
graphs represented adjacency lists pred succ stored node edge annotation represented predecessor edge having pred successor edge having succ 
source var predecessor edge var sink successor edge 
var var predecessor successor edge fixed total order vars edge predecessor edge 
order function typically order variables created part building constraint system 
solving systems annotated constraints system annotated inclusion constraints represented annotated constraint graph inductive form 
system solved computing closure graph transitive closure rule pred succ match trans closure rule applied locally examining pred succ 
new transitive constraint created annotations existing constraints match match holds match binary predicate set annotations 
intuitively trans rule uses annotations filter flow values constraint system 
match predicate defined follows match true empty annotation true false annotation new constraint intuitively annotation propagated matched instance instances cancel 
new constraint generated trans rule atomic new edge added graph 
resolution rules transform constraint atomic constraints corresponding edges added graph 
closure constraint graph trans rule solved inductive form corresponding constraint system 
solution system explicit solved inductive form easy compute examining predecessors variable 
constraint graphs annotations solution ls variable ls 

pred pred ls case ls computed transitive acyclic traversal predecessor edges 
annotated constraint graph traversal done similarly annotations rule trans ls 

pred 
pred 
ls match 
points analysis java annotated constraints section show implement pointsto analysis section annotated inclusion constraints 
recall analysis defined terms set variables set names objects created object allocation sites 
element essentially memory location representing set run time memory locations 
implement analysis annotated inclusion constraints generalize approach modeling andersen analysis non annotated constraints 
location set variable vx represents set locations pointed representation location ternary constructor ref build constructed terms form ref vx vx 
arguments variable different variance notation denote contravariant argument 
intuitively second argument new ref vo vo vr proj ref vr fresh vr proj ref fresh constraints assignment statements 
new new accessing object fields 
read values locations pointed argument update values locations pointed variable object variable constraint ref vo vo vr shows points field annotations model flow values fields objects 
field annotations unique identifiers instance fields defined program classes 
object variables constraint ref vo vo vo shows field object points object constraints assignment statements program statement analysis generates annotated inclusion constraints representing semantics statement 
shows constraints generated assignment statements 
generation rules straightforward 
rule uses constraint access points set second constraint update values field objects pointed similarly rule uses constraints read values field objects pointed example consider statements corresponding points graph 
processing statements analysis creates constraints ref vo vo vp ref vo vo vq vp proj ref vq vp proj ref vr fresh variables 
purpose example assume variable order defined section vp vq vr vo vo 
consider indirect write ref vo vo vp proj ref trans rule resolution rules generate new constraint vo vq vo rule trans generate vq vo intuitively new constraint shows values field object come variable ref vo vo vq vo constraint edges predecessor edges apply rule trans 
solution constraint system defined section constraint ref vo vo vo shows field points model indirect reads second argument ref constructor 
example constraints ref vo vo vp proj ref vo vr trans generates vo vr new constraint shows value comes field object vq vo vr annotations constraints match represent accesses field generate vq vr represent flow values solution system ref vo vo vr shows variable points example illustrates field annotations allow model flow values object fields 
handling virtual calls virtual call program analysis generates constraint rule 
rk vr lam vr 
vr rule lam lambda constructor 
constructor build term encapsulates actual arguments left hand side variable call 
annotation constraint unique identifier compile time target method call 
annotation analysis find appropriate run time target methods 
model semantics virtual calls defined section separately perform virtual dispatch receiver object pointed order ciently precomputed lookup table 
receiver object virtual call site lookup table determine corresponding run time target method class receiver object 
table straightforward precompute analyzing class hierarchy object tagged class tag performing lookups 
table essentially representation dispatch function section 
class receiver object unique identifier compile time target virtual call lookup table returns lambda term form lam vp vp 
vp ret formal parameters run time target method corresponds implicit parameter 
assume method unique variable ret assigned value returned method achieved inserting auxiliary assignments program representation 
analysis lambda terms form created non methods program stored lookup table 
model ects virtual calls define additional closure rule virtual 
rule encodes semantics virtual calls described section trans rule obtain solved form constraint system 
virtual applied constraints form ref vo vo lam vr 
vr described section edge ref term predecessor edge edge lam term successor edge 
virtual closure rule applied locally examining sets pred succ 
constraints detected lookup table find lambda term run time method corresponding object compile time target method result applying virtual new constraints ref vo vo vp lam vp vp 
vp ret lam vr 
vr constraint creates association parameter invoked method receiver object 
second constraint immediately resolves vr vp ret plus trivial constraint vp new atomic constraints model flow values actuals formals flow return values left hand side variable call site 
example consider set statements 
purpose example assume va vc 
declared type call site compiletime target method lam vx rule virtual applied shown lookup receiver object compile time target produces run time target resolution lam term creates new constraints shown 
declared type call site vc lam vy 
ref vo vo lam vy second constraint obtained trans class return ra class extends return rb new new 
ref vo vo lam vx ref vo vo vb vx ref vo vo lam vy ref vo vo vb vy ref vo vo va lam vz ref vo vo va vz ref vo vo va lam vz ref vo vo vb vz example virtual call resolution 
rule 
applying rule virtual shown lookup receiver object compile time target leads run time target new constraints result resolution shown 
call site receiver object shown separate lookup resolution performed receiver 
correctness program statement analysis generates constraints representing semantics statement 
initial constraint system solved closing corresponding constraint graph closure rules trans virtual 
solved inductive form constraint system 
recall solution system explicit obtained additional traversal predecessor edges described section 
points graph computed algorithm section 
consider variable object variable proven solution constructed contains constraint ref vo vo vr similarly consider object variables proven solution contains ref vo vo vo proof claims depends restriction variable order variables vr lower order rest constraint variables 
enforce restriction part building constraint system 
restriction proven note vc propagating lam term propagate ref term vc solution constraint system represents points pairs 
cycle elimination merging cycle elimination projection merging techniques reduce cost andersen analysis adapted techniques allow reduce cost points analysis java 
idea cycle elimination detect set variables form cycle constraint graph 
vk clearly variables equal solutions replaced single variable 
cycle detected resolution process variable cycle chosen witness variable rest variables redirected witness 
transformation ect computed solution significantly reduce cost analysis 
cycle detection performed time new edge added variables detection algorithm essentially performs depth traversal constraint graph tries determine reachable cycle detection partial detect cycles 
andersen analysis technique significant impact running time analysis 
cycle elimination directly annotated constraint systems 
performed standard cycle detection discover cycles edges field annotations variables cycles solution replaced single witness variable 
guarantee correctness analysis java restricted form cycle elimination 
cycle detection algorithm invoked new edge added variables new edge vr vr proven case detected cycle contains variables edges cycle empty annotations 
guarantees variables cycle identical points sets replacing cycle single variable preserves points solution 
projection merging technique reducing redundant edge additions constraint systems 
combines multiple projection constraints variable single projection constraint 
example constraints proj proj replaced proj special projection variable 
points analysis constraints form represented successor edges restriction guarantees bound number projection variables analysis ensures restriction assigning high index variable order 
case projection merging beneficial coupled cycle elimination 
annotated constraint systems projection merging interact cycle elimination 
case high indices necessitate interaction required 
high indices unnecessary bound number special projection variables ensured variable ordering restriction section 
special projection variables treated similarly rest variables constraint system 
decoupled form projection merging significant impact running time analysis java 
tracking reachable methods andersen analysis implicitly assumes code program executable 
java programs heavily libraries contain unused methods augmented analysis keep track reachable methods order avoid analyzing dead code 
take account ects statements method body method shown reachable entry methods program 
set entry methods contains main method starting class ii methods invoked jvm startup iii class initialization methods containing initializers static fields section 
analysis maintain list reachable methods method reachable statements body processed appropriate constraints introduced constraint system 
call constructor generates corresponding call appropriate finalize method 
multi threaded programs call thread start treated call corresponding run method 
analysis implementation soot framework www sable mcgill ca version process java bytecode build typed intermediate representation 
constraint analysis uses bane berkeley analysis engine 
bane toolkit constructing constraint program analyses 
public distribution bane bane cs berkeley edu contains constraint solving engine non annotated constraints employs inductive form cycle elimination projection merging 
modified constraint engine represent solve systems annotated constraints 
analysis works top constraint engine processing newly discovered reachable methods generating appropriate constraints 
points ects jvm startup code native methods jdk encoded stubs included analysis input 
dynamic class loading class forname reflection calls class newinstance resolved manually similar approaches typical static program compilers tools 

empirical results experiments performed mhz sun ultra machine mb physical memory 
reported times median values runs 
publicly available data programs ranging size kb mb bytecode 
programs spec jvm suite benchmarks previous analysis java programs internet archive www com popular publicly available java applications 
table shows characteristics data programs 
program user size program class kb class method stmt proxy compress db jb echo raytrace mtrt jlex javacup rabbit jack jess mpegaudio sablecc javac creature soot beta mu javacc table characteristics data programs 
columns show number bytecode size user classes 
columns include library classes 
columns show number user classes bytecode size 
columns show size program including library classes class hierarchy analysis cha filter irrelevant classes methods 
number methods essentially number nodes call graph computed cha 
column shows number statements soot intermediate representation 
analysis cost set experiments measured cost analysis shown table 
columns show running time analysis amount memory 
programs analysis runs minute 
programs running time minutes memory usage mb 
results show analysis practical terms running time memory usage evidenced large set java programs 
practicality means analysis relatively precise general purpose points analysis advanced static compilers software engineering tools java 
analysis cost reduced library code analyzed advance 
allow certain partial analysis information java libraries computed subsequently multiple times di erent client programs 
intend investigate approach 
investigated version analysis cha inexpensive analysis determines possible targets virtual call examining class hierarchy program 
program time memory time nf memory nf sec mb sec mb proxy compress db jb echo raytrace mtrt jlex javacup rabbit jack jess mpegaudio sablecc javac creature soot mu javacc table running time memory usage analysis field annotations 
field annotations individual object fields distinguished 
columns table show cost fields version 
running time average median running time original analysis memory usage average 
typically fields version significantly expensive larger programs ran memory 
results show importance distinguishing object fields improved precision produces smaller points sets turn reduces analysis cost 
field annotations able distinguish object fields simple cient manner 
object read write information performed measurements estimate potential impact analysis clients object read write information side ect analysis def analysis 
particular considered expressions form occuring statements reachable methods 
indirect access expression points set contains objects may read written corresponding statement 
precise points analyses produce smaller numbers accessed objects improves precision reduces cost clients read write information 
estimate potential impact analysis measured number accessed objects indirect access expression similar metrics traditionally points analysis table shows distribution number accessed objects column corresponds specific range numbers 
example column corresponds expressions may access single object column corresponds expressions may access program proxy compress db jb echo raytrace mtrt jlex javacup rabbit jack jess mpegaudio sablecc javac creature soot mu javacc table number accessed objects indirect access expressions 
column shows percentage indirect accesses number objects 
objects 
column shows percentage indirect access expressions corresponds particular range numbers accessed objects 
measurements table indicate analysis produces precise read write information 
typically half indirect accesses resolved single object lower bound metric average accesses resolved objects 
results show analysis promising candidate producing useful read write information clients aggressive optimizing compilers optimizations require precise read write information ii software engineering tools analysis precision important reducing human ort spent program understanding restructuring testing 
call graph construction virtual call resolution measure precision respect call graph construction virtual call resolution compared pointsto analysis rapid type analysis rta 
rta inexpensive widely analysis call graph construction 
performs reachability computation call graph generated cha keeping track classes instantiated rta computes precise call graph cha 
analysis rta improve call graph computed cha identifying sets methods reachable entry points program reachability computation reduces number nodes call graph 
brevity summarize reduction explicitly showing number nodes program 
average reduction number nodes analysis rta 
average call graph computed program removed targets resolved call sites points rta points rta proxy compress db jb echo raytrace mtrt jlex javacup rabbit jack jess mpegaudio sablecc javac creature soot mu javacc average table improvements cha unresolved virtual call sites 
average reduction number target methods call site 
percentage uniquely resolved call sites 
analysis nodes call graph computed rta 
reduction allows subsequent analyses optimizations safely ignore portions program 
determine improvement call graph edges considered call sites resolved single target method cha 
set call sites occur methods identified analysis reachable 
data programs size average virtual call sites reachable methods 
site computed di erence number target methods cha number target methods rta analysis 
average di erences shown section table 
average analysis removes twice targets rta improved precision beneficial reducing cost improving precision subsequent interprocedural analyses 
second section table shows percentage call sites resolved single target method 
points analysis performs significantly better rta average versus virtual call sites resolved 
increased precision allows better removal run time virtual dispatch additional method inlining 
performed additional experiments estimate potential performance impact analysis precision virtual call resolution 
experiments subset data programs representative input data 
program instrumented user classes classes measured number times call site executed profile run program 
col program num resolved run time calls rta points monomorphic compress db mtrt jlex jack jess mpegaudio sablecc javac javacc table execution counts virtual call sites 
total count cha unresolved call sites 
percentage due resolved sites 
percentage due sites single run time target 
umn table shows total number invocations cha unresolved call sites 
number indicator run time overhead virtual dispatch missed opportunities performance improvement inlining 
measured percentage total number contributed call sites uniquely resolved rta analysis 
percentages shown column table higher percentages indicate higher potential performance improvement 
results profiling experiment indicate rta little potential improving run time performance cha 
analysis shows significantly higher potential programs allows resolution majority run time virtual calls 
addition profile determine cha unresolved call sites run time target 
column shows contribution sites total count column 
number upper bound number invocations resolved static analysis 
comparing columns clear cases analysis achieves performance close best possible performance 
synchronization removal stack allocation points analysis wide variety client applications including optimizations removal unnecessary synchronization stack object allocation 
investigate impact analysis synchronization removal stack allocation identified object allocation sites correspond thread local method local objects described section 
shows percentage allocation sites reachable methods identified thread local method local 
programs analysis detects significant number allocation sites thread local objects average allocation sites 
results indicate points information useful detecting eliminating unnecessary synchronization java programs 
analysis discovers significant number sites method local objects average sites 
results suggest opportunities stack object allocation detected analysis 
object allocation sites proxy compress db jb raytrace mtrt jlex javacup echo jack mpegaudio javac creature soot javacc thread local method local run time objects program objects thread local method local compress db mtrt jlex jack jess mpegaudio sablecc javac javacc thread local method local allocation sites 
number objects created run time total number percentage thread local objects percentage method local objects 
virtual call resolution performed additional profiling experiments obtain better estimates potential impact run time performance 
set programs instrumented user classes data input sets measured number run time objects created object allocation site 
total number created objects shown column columns show percentage objects identified analysis thread local method local 
results experiment indicate analysis potential improving run time performance synchronization removal stack object allocation 
results similar results obtained expensive flow contextsensitive escape analyses :10.1.1.12.2189
direct comparison previous possible due differences infrastructure data programs results suggest analysis may viable alternative expensive analyses 

related points analysis object java clearly related pointer analysis imperative languages various pointer analyses di erent tradeo cost precision 
closest related category constraint implementations andersen analysis constraints inductive form cycle elimination projection merging 
extend introducing constraint annotations changing constraint representation resolution procedure allow points analysis java 
field annotations track object fields separately possible constraints 
method annotations allow model semantics virtual calls 
addition avoid analyzing dead library code including reachability computation analysis 
constraint indices constraint polarities introduce context sensitivity unification flow analysis 
similar flavor annotations tracking flow values object fields 
conceptually cases goal restrict flow values constraint systems unification constraints inclusion constraints case 
initial report describes points analysis java andersen analysis analysis cost higher due di erent kind constraints employed approach 
points analysis java andersen analysis analysis variations :10.1.1.25.4206:10.1.1.25.4206
direct comparison possible handles library code di erent manner size analyzed code analysis appears faster 
example pointsto analysis object oriented languages due chatterjee :10.1.1.37.6842
flow context sensitive analysis precise expensive 
points analyses di erent degrees precision proposed context framework call graph construction object oriented languages :10.1.1.18.621
closest cfa algorithm incorporates flow context sensitive points analysis 
scalability analyses remains unclear approach may practical alternative expensive analyses 
related analyses unification techniques context sensitive alias analysis synchronization removal due ruf points analyses java derived steensgaard points analysis :10.1.1.25.4206:10.1.1.11.3368
class analysis object oriented languages computes set classes program variable set approximates classes run time values variable 
traditional client applications class analysis call graph construction virtual call resolution 
defouw family practical interprocedural class analyses ranging linear cubic complexity closest analysis classic cfa linear edge cfa algorithms 
area considers expensive analyses degree context flow sensitivity precise inexpensive analyses rta 
comparison results di cult due di erences language infrastructure analysis parameters handling libraries dynamic class loading 
large body synchronization removal stack object allocation 
gay steensgaard unification analysis stack allocation 
ruf describes algorithm synchronization removal 
aldrich propose approaches synchronization removal 
approach identifying thread local objects similar multithreaded object analysis cfa 
previous escape analysis java investigates synchronization removal stack allocation scalability approaches remains unclear 
contrast specialized analyses propose points analysis variety client applications 

designing precise practical points analyses important enabling wide variety popular analyses optimizations 
define points analysis java andersen points analysis implement analysis constraint approach employs constraint annotations 
method annotations model precisely ciently semantics virtual calls 
field annotations allow distinguish different fields object 
large set java programs experiments show cost analysis practical 
show points solution significant impact object read write information call graph construction virtual call resolution synchronization removal stack object allocation 
results demonstrate analysis realistic candidate relatively precise practical general purpose points analysis advanced optimizing compilers software engineering tools java 
direction investigate techniques reduction analysis cost 
example cost reduced library code analyzed advance 
allow partial analysis information java libraries computed subsequently di erent client programs 
direction investigate impact analysis solution traditional client analyses def analysis side ect analysis dependence analysis turn necessary various optimizations 
analyses optimizations extensively investigated languages play increasingly important role aggressive optimizing compilers java 
interesting investigate applications points analysis context software engineering tools program checking understanding maintenance testing 
functionality provided tools necessary development production strength java software systems 

acknowledgments matthew arnold michael hind anonymous reviewers suggestions improving content presentation 
research supported nsf ccr 

agesen 
constraint type inference parametric polymorphism 
static analysis symposium lncs pages 
aiken fahndrich foster su 
toolkit constructing type constraint program analyses 
international workshop types compilation 
aiken wimmers 
type inclusion constraints type inference 
conference functional programming languages computer architecture pages june 
aldrich chambers sirer eggers 
static analyses eliminating unnecessary synchronization java programs 
static analysis symposium lncs pages 
andersen :10.1.1.109.6502
program analysis specialization programming language 
phd thesis diku university copenhagen 
bacon sweeney 
fast static analysis virtual function calls 
conference object oriented programming systems languages applications pages 
blanchet 
escape analysis object oriented languages 
applications java 
conference object oriented programming systems languages applications pages 
holzle 
removing unnecessary synchronization java 
conference object oriented programming systems languages applications pages 
chatterjee ryder landi :10.1.1.37.6842
relevant context inference 
symposium principles programming languages pages 
choi gupta serrano sreedhar 
escape analysis java 
conference object oriented programming systems languages applications pages 
dean grove chambers 
optimizations object oriented programs static class hierarchy analysis 
european conference object oriented programming pages 
defouw grove chambers 
fast interprocedural class analysis 
symposium principles programming languages pages 
diwan moss mckinley 
simple ective analysis statically typed object oriented programs 
conference object oriented programming systems languages applications pages 
fahndrich foster su aiken 
partial online cycle elimination inclusion constraint graphs 
conference programming language design implementation pages 
fahndrich rehof das 
scalable context sensitive flow analysis instantiation constraints 
conference programming language design implementation pages 
fitzgerald knoblock ruf steensgaard tarditi 
marmot optimizing compiler java 
software practice mar 
gay steensgaard 
fast escape analysis stack allocation object programs 
international conference compiler construction lncs 
gosling joy steele 
java language specification 
addison wesley 
grove defouw dean chambers :10.1.1.18.621
call graph construction object oriented languages 
conference object oriented programming systems languages applications pages 
ibm 
high performance compiler java 
www alphaworks ibm com formula 
liang harrold :10.1.1.25.4206
extending evaluating flow insensitive context insensitive points analyses java 
workshop program analysis software tools engineering pages 
lindholm yellin 
java virtual machine specification 
addison wesley 
palsberg schwartzbach 
object oriented type inference 
conference object oriented programming systems languages applications pages 
plevyak chien 
precise concrete type inference object oriented languages 
conference object oriented programming systems languages applications pages 

study side ect analyses java 
master thesis mcgill university dec 
rountev milanova ryder 
points analysis java annotated constraints 
technical report dcs tr rutgers university nov 
rountev milanova ryder 
points analysis java annotated inclusion constraints 
technical report dcs tr rutgers university july 
initial report superseded dcs tr 
ruf 
ective synchronization removal java 
conference programming language design implementation pages 
steensgaard :10.1.1.11.3368
points analysis linear time 
symposium principles programming languages pages 
snelting 
points java general framework comparison 
technical report passau sept 
su fahndrich aiken 
projection merging reducing redundancies inclusion constraint graphs 
symposium principles programming languages pages 
sundaresan hendren rai lam gagnon godin 
practical virtual method call resolution java 
conference object oriented programming systems languages applications pages 
tip la ra sweeney streeter 
practical experience application extractor java 
conference object oriented programming systems languages applications pages 
tip palsberg 
scalable propagation call graph construction algorithms 
conference object oriented programming systems languages applications pages 
rai gagnon hendren lam sundaresan 
optimizing java bytecode soot framework feasible 
international conference compiler construction lncs 
whaley rinard 
compositional pointer escape analysis java programs 
conference object oriented programming systems languages applications pages 
