behavioral interface contracts java rice university cs tr robert bruce findler matthias felleisen department computer science rice university south main ms houston tx usa contact september programs consist shelf interchangeable black box components produced network independent software companies 
components come type signatures contracts describe aspects behavior 
way express contracts state pre post conditions externally visible functions 
pre post conditions validated evaluation possibly compilation 
function call fails satisfy contract run time system blame faulty program component 
behavioral contracts form assertions understood world procedural languages 
addition class interface hierarchies object oriented programming languages raises new interesting questions 
complicating factor objects pass components trigger callbacks 
problem object oriented languages allow objects satisfy interfaces 
analyze existing approaches adding contracts class languages show blame wrong component certain situations breach contract 
conservative extension java allows programmers specify method contracts interfaces 
extension compromise consistent enforcement contracts language design concerns 
plan clarify relationship contracts contract violations rigorous analysis 
contracts assertions plouzeau watkins suggest software components come contracts 
describe levels contracts 
syntactic contracts type systems 
contracts invariants pre post conditions 
synchronization contracts 
quality service contracts 
type systems syntactic contracts components studied extensively object oriented functional higher order contexts 
behavioral contracts studied procedural contexts 
behavioral contracts added object oriented languages :10.1.1.31.7982
adding behavioral contracts object oriented languages subtle 
referenced systems fails component interactions interface observer void void class private observer public boolean isempty 
post isempty false public void enq int 
pre isempty false public int deq 
public void observer 
class implements observer public void deq public void class main public static void main new queue observer new enq queues icontract interpret properly 
allow contracts methods means catch contractual violations objects higher order manner callbacks 
allow contracts interfaces certain situations evaluation blame components contractual violation occurred 
contract java version java behavioral interface contracts 
design goals contract java fold 
semantics program contracts identical contract java standard java adding contracts satisfied change program meaning 
second code compiled contracts interoperate legacy code compiled contracts 
fact design contract java compromise sacrifices degree contract enforcement classes compiled contracts interact legacy code 
model contract java translation plain java 
compiler inserts code appropriate places check pre post conditions 
feasible broken contract causes evaluation halt blames component broke contract 
section analyzes previous contracts object oriented languages 
section explains add behavioral contracts java interfaces contracts interfaces affect design rest language 
section describes contract java shows compiles programs contracts standard java 
sections discuss related 
contracts classes previous contracts suggests programmers annotate implementation methods contracts particular pre post conditions 
unfortunately contracts capture component invariants 
consider 
contains pictorial representations component interactions szyperski mentions book 
boxes indicate component boundaries 
dotted vertical lines represent flow control single component dotted diagonal lines represent control transfer component 
left hand side pictorial representation simple interaction components 
lefthand component begins evaluation course evaluation calls right hand component exchanging flat values numbers characters strings 
simple world sufficient associate contracts directly methods 
right hand side describes complex interaction components 
control begins left hand component 
time left hand component passes object right hand component 
right hand component just returning flat value calls method object received transferring control back left hand side component nested fashion 
nested call lefthand component may modify state causing post condition right hand component fail 
blame cast left hand component providing faulty object right hand component 
unfortunately contracts associated implementations contract right hand component write ensure object receives left hand component behaved 
concrete example consider program icontract adaption eiffel notion contract java 
contracts icontract specified pre post clauses methods 
pre clause precondition true method called 
pre clause fails icontract blames method caller 
post clause postcondition method true method returns 
post clause fails icontract blames method 
contains icontract code components implement observer pattern queue 
component implements queue class 
queue supports enqueue enq dequeue deq operations test emptiness isempty 
additionally queue supports observer 
method registers argument current observer methods called enq operation deq operation respectively 
example pre post clauses dictate dequeuing empty queue illegal enqueue queue empty 
order preserve invariants behavior observer restricted 
particular observer method empty queue 
unfortunately icontract contract language provides way specify enforce restriction 
second component observer implements observer interface 
observer method dequeues element queue observed 
mechanism forcing implementor component add postconditions check queue invariants 
final component main instantiates binds respectively registers main enqueues queue observer immediately dequeues causing post condition enq fail 
blame fall observer improperly dequeuing queue 
icontract tool incorrectly blames enq method completing empty queue 
implemented different companies false blame cause economic damage 
contracts specified classes interfaces appropriate contract argument 
contracts associated interfaces author impose condition observers observer interface 
interface contain contract ensures empty queue 
contract java lesson preceding section assertions specified method implementations insufficient capture component contracts 
designed contract java extension java method contracts higher order functions language sml scheme exhibit kind behavior 
fair icontract allow contracts specified interfaces properly assign blame rewrite interface contracts 
icontract syntax attempt facilitate understanding 
section returns icontract explains shortcomings 
specified interfaces 
identified design goals 

contract java programs contracts programs fully satisfied contracts behave run contracts java 

second programs compiled conventional java compiler able interoperate programs compiled contract java 

class declares meets particular contract blamed failing meet contract 
abstractly method object type called caller blamed pre condition contracts associated blamed post condition contracts associated design goals raise interesting questions demand decisions balance language design software engineering concerns 
section describes major design issues alternatives decisions rationale ramifications decisions 
decisions orthogonal decisions depend earlier ones 
contracts specification enforcement contracts contract java decorations methods signatures interfaces 
method declaration may come pre condition expression post condition expression expressions evaluate booleans 
pre condition specifies true method called 
fails context method call blame method proper context 
post condition expression specifies true method returns 
fails method blame establishing promised conditions 
contract java restrict contract expressions 
programming discipline dictates expressions contribute result program 
particular expressions side effects 
pre post condition expressions parameterized arguments method 
bound current object 
additionally post condition contract may refer name method bound result method call 
contracts enforced type context method call 
object type interface type method call meet contracts interface 
instance object implements interface call methods check pre condition post condition specified object type class type object contractual obligations 
programmer create interface class leave objects class types unchecked efficiency reasons 
example consider interface interface float getvalue float pre getvalue post math abs getvalue describes interface float wrapper class provides method 
method getvalue contracts 
accepts arguments returns unwrapped float 
method accepts arguments contract 
pre condition asserts unwrapped value greater equal zero 
result type float 
post condition states square result value float 
contract language sufficiently strong specify complete behavior cases previous example total partial correctness goal designing contracts 
typically contracts express full behavior method 
fact tension amount information revealed interface amount validation contracts satisfy 
example consider stack interface time provisions referring initial value argument post condition 
interface stack void push int int pop push pop operations available interface impossible specify push top element stack element just pushed 
augment interface top operation reveals topmost item stack removing specify push adds items top stack interface stack void push int post top int pop int top summary restrict language contracts 
contract language flexible possible contract expression evaluation may contribute final result computation 
despite flexibility contract language desirable contracts expressible 
contracts inexpressible may involve checking undecidable properties inexpressible interface permit observations 
need study java class interface type system interacts contracts 
multiple interfaces single object may play roles 
example object may different contexts different methods different contexts may need share state 
java allows class implement interface 
contract java means single method may pre condition post condition different interfaces may impose different contracts method 
pre conditions enforced type method application site caller uses object single type pre conditions method required satisfied method called 
consider program interface int int pre fx interface int int pre class implements int int 
instance class type argument greater 
conversely instance treated argument 
due java type system instance type means meet pre conditions simultaneously 
analogously post conditions met 
determined calling context 
principle guide choice decision 
client library uses aspect library code trigger error messages failed contracts unused aspects library 
substitutability java type system defines notion object substitutability ability instance class take place instance class play role defined interface 
specifically type system allows object context type superclass class interface object implements interface superclass object implements 
second third form substitutability pose problems presence interface contracts 
section discusses problem second item section discusses different problem third item 
program demonstrates class interface expected complicates semantics contract java interface int getvalue post getvalue void void dec pre getvalue class counter implements int val int getvalue return val void val val void dec val val main client new client client new client client new client pc counter pc class client return new counter class client counter return counter class client void counter dec program defines class counter implements interface 
counter class keeps track single integer supports increment decrement operations integer 
interface promises counter delivers contains number 
enforces promise adding pre condition dec method 
client class creates instances counter returns type 
client accepts instances casts counter returns 
client accepts instances counter decrements 
main creates instance client uses create counter main receives counter pre condition constraint dec interface 
main passes client 
counter passed client decremented pre condition dec fails 
earlier description fault post condition failure method postcondition dec case temporarily treated counter true cause violation dec post condition 
client class decremented counter blame client class cast counter 
client casts counter take responsibility violations contracts 
client decrements counter blame fall client 
wish contract java blame client language track class casts counter object way create proxy class class proxy proxy void dec getvalue error client dec void int getvalue getvalue proxy class duplicates pre condition blames client client precondition fails 
proxy classes created implicit explicit cast lifts pre condition 
compiler statically detects place casts happen inserts code create proxy class point 
subtle change semantics java programs 
java supports object identity operation 
contract java wrap objects unwrapped object wrapped object longer equal java operation 
plain java cast affect identity object 
problem fixed changed method call checks object wrapped temporarily comparison 
solution flawed reasons 
pre compiled legacy code call new method replaces 
second simple efficient check pointer equality turned expensive method call 
contract enforcement casts introduce incompatibilities java contract java omit 
blame assigned previous example pre condition counter ignored dynamic extent call client strengthening pre conditions strengthening pre condition method derived interface quite useful 
consider pair interfaces interface object visit interface extends object visit pre fi instanceof interfaces extracted extensible visitor pattern 
interface defines visit method accepts instances 
interface derived visit method requires arguments instances extension 
type system allow derived visit method different type super method programmer specify input type pre condition 
unfortunately strengthening pre condition cause problems 
consider continuation program class client void visit class jc implements 
class main void main client new client new jc program client written instances interface unspecified visitor object 
main calls method passes instance jc implicitly cast eventual call visit violates contract jc 
client issues call visit blamed 
allow strengthen requiring class implementing matter treated instance check pre condition visit 
violates third design criterion 
particular example client designed match blamed contract violation object 
approach adapt proxy solution section 
technique enable properly blame main 
reject alternative reasons discussed 
contract java disallows pre condition strengthening way supporting compromising goal java compatibility 
weakening pre conditions strengthening pre conditions important able weaken 
consider program interface shape 
class moon implements shape 
class square implements shape 
interface public void shape pre instanceof square consists shape datatype variants moon square 
supports single operation sense concave shapes 
omit details operation important precondition ensures concave shapes allowed inputs operation 
programmer extends shape datatype concave shape extend pre condition class circle implements shape 
interface circle extends public void shape pre instanceof square jj instanceof circle precondition implies pre condition 
contract java contract expressions arbitrary java expressions special purpose sublanguage decision procedure determine contract java contracts weaker contract java simultaneously provide pre condition weakening dis allow pre condition strengthening 
contract java requires pre conditions derived methods syntactically overridden counterparts 
strengthening post conditions pre conditions important strengthen method post condition 
see consider factory method design pattern 
instantiation pattern consists single method abstracts creation instances class 
program fragment illustrating pattern interface class implements new example method produces classes implement pattern derived classes override create instances derived class interface extends post instanceof class extends implements return new case class overrides creates instance due typing discipline java overriding definition type method overrides similarly method result type 
programmer provide stronger guarantee components interface guarantee contract 
case programmer strengthened result instance kind strengthening cause problems pre condition strengthening easily accommodated contract java 
weakening post conditions supporting weakened post conditions poses problems contract java 
consider program variation square root example section interface number 
class implements number float interface float getvalue number post instanceof class root implements 
consists number interface class implements number interface 
class calculates square root number 
post condition method ensures square roots positive 
program extended complex numbers class implements number 
interface extends float getvalue number post instanceof jj instanceof class implements 
main new extension adds class represent complex numbers extension class calculate complex roots 
post condition method weakened allow complex results 
java instance implicitly cast 
allows instances class cast 
instances forced meet stringent requirements incorrectly blamed returning complex results 
solution dilemma proxy classes described section 
proxies blame class casts instance 
reject solution order maintain compatibility java 
disallow post condition weakening 
implied interface inheritance section described ways java type system defines substitutability problem second 
section describes problem java notion substitutability 
typical java programmer derive class re implementation original class 
example class may implement list derived class may re list implement finite mapping 
similarly class may extend class arrays easily implemented arrays digits 
style inheritance designed code re java type system treats substitutability respect interfaces 
java allows finite mapping treated list treated array 
picture demonstrates issue programmer implements implements elaboration java implements implements left hand side shows programmer writes interface class implements class derived java translates program right hand side diagram 
class implements programmer intent 
implicit interface inheritance induces problems contracts 
consider interfaces interface array int object lookup int pre void update object int pre interface int object lookup int pre void update object int specifies standard array class 
second lifts restriction update argument range implementations dynamically resize array new elements added 
priori interfaces unrelated 
natural want reuse class implementing array say ac class implements programmer create new class rac extends ac 
unfortunately semantics java rac implement array derived class eliminate pre condition update 
contract java fix problem changing semantics java induced interface inheritance 
say contract java rac implement ac 
violates design goals contract java pursue option 
semantics java require rac implement array contract java enforce array contracts rac 
rac support pre condition array empty pre condition discussed section illegal contract java single method different pre conditions program syntactically illegal contract java 
implementing contract java specify contract java define elaboration plain java 
specifically modify type elaboration phase conventional java model compilation classes method calls account contracts interfaces 
changes follow 
subsections explain major ideas appendix specifies details 
elaborating plain contracts illustrates contract java elaborated java 
top half represents contract java version example section 
contracts enq deq shifted queue interface observer interface enriched contracts method 
bottom half represents elaboration classes example 
illustrates method contract interface causes compiler insert new method class implements interface 
call new method enforcer 
example method contract enq generates enq queue enforcer contract leads observer enforcer 
test pre post conditions necessary signal errors necessary 
test pre condition consume additional argument information source call 
error messages source information 
method call elaborated type object 
type interface method annotated interface matching enforcer called 
annotation pre condition call consumes information call context potential blame assignment 
calls deq enq main illustrate kind elaboration 
evaluation program detect violates contract correctly blame class failure 
interface observer void queue post isempty void queue interface queue boolean isempty void enq int post isempty void deq pre isempty void observer class implements queue private observer public boolean isempty 
public void enq int public int deq 
public void observer 
class implements observer public void queue deq public void queue 
class main public static void main queue new observer new enq class implements queue private observer public boolean isempty 
public void enq queue int enq isempty error violates queue public void enq int observer public void deq queue string source isempty error source deq public int deq 
public void observer 
class implements observer public void observer queue isempty error violates observer public void queue deq queue public void queue 
class main public static void main queue new observer new enq queue compiling contract java programs syntactic errors contract java introduces new form syntactic error 
interface extends interface may mention methods new pre conditions 
sections explain modifying preconditions violates basic expectations concerning contracts contract enforcement 
classes multiple interfaces class implement interfaces mentioned implements clauses inherited extends clause 
method contract implemented interface class contain enforcer 
class implements 
contains method contracts similarly class implements 
class extends implements 
contains specify contracts collecting postconditions elaborator checks interface dag collect postconditions methods derivation path 
extends adds post condition method enforcer relative check post conditions 
conditions merely anded enforcer 
naive implementation steps lead quadratic increase size program 
factoring post conditions separate methods overcomes problem natural manner 
related software engineering literature contains large number publications integrating assertions programs 
focus typically concerns relationship program specifications usefulness certain classes assertions efficient implementation kinds programming languages 
focus narrower 
explore mechanism adding contracts class object oriented programming languages 
regard research literature sparser 
relevant concerns adl eiffel handshake icontract eiffel adl permit programmers specify contracts methods classes interfaces :10.1.1.31.7982
outlined section approach suffers serious problems 
technically eiffel programmer avoid problems multiple inheritance classes 
class implement hook pattern superimpose contracts method derived concrete classes 
second multiple inheritance needed mimic java implements clause 
solution complex error prone 
addition programming protocol compiler enforced mechanism 
remaining systems icontract advanced ones 
eiffel adl icontract permit programmers add contracts interfaces 
unfortunately interpret interface contracts incorrectly 
particular class declares implements interface interface pre postcondition checks compiled corresponding methods class 
leads incorrectly assigned blame 
consider example section 
example important method accepts instance blamed failing meet pre conditions unrelated interfaces 
icontract class implements blame callers violations pre conditions treat instance exclusively worse mutually unsatisfiable contracts impossible write class implements icontract 
icontract fail handle example section properly 
blame client violation client 
worse client longer stack give programmer help tracking true broken contract 
believe handshake falls category eiffel falls category icontract 
unfortunately design documents leave point open 
worse implementations available testing 
wider perspective rosenblum programming assertions closely related research 
experience building assertion preprocessor projects identifies assertions contracts functions critical 
furthermore identifies important classes contracts especially consistency checks arguments value dependencies subrange subset membership data 
interpreted adaption rosenblum java 
adaption complex due desire deal java class interface hierarchies 
parnas recognize languages building large systems support linguistic mechanism components components come contracts form total correctness assertions 
anna understood representative implementation parnas proposal modules 
ml family programming languages provides sophisticated form module mechanisms 
alas designers ml exclusively focus type specifications module interfaces ignore forms assertions 
consider complementary modules module interfaces especially module languages express class interface hierarchies 
analyzed existing integrations contracts assertions class languages proposed alternative approach 
proposal represents compromise language design software engineering concerns 
believe result superior previous lines leaves open questions 
question plan address practical contract java really implementation contract java wish uncover discipline contracts similar developed rosenblum 
furthermore plan study expressiveness assertion language effectiveness finding bugs cost contracts realistic programs 
second question concerns design java variant better suited specification contracts 
design contract java required compromises concerning enforcement contractual invariants sake consistency java semantics 
conversely study java changed allow stricter enforcement contracts 
interested developing specialized language contracts contract proof system spirit static debugger 
static debugger uses program analysis paint primitive operation arithmetic operations function applications method calls red green 
green primitive operation means operation provably stated invariant 
red operation indicates analysis prove operation safety conditions met 
case static debugger programmer request draw value flow graph top program text indicating flow values trigger potential error 
programmer determine truly error analysis weak prove safety application 
contract proof system generalize form safety analysis component class contracts 
acknowledgments matthew flatt clemens szyperski helpful discussions 

plouzeau watkins 
making components contract aware 
ieee software pages june 
cardelli type systems 
tucker editor computer science engineering handbook pages 
crc press 
clinger rees 
revised report algorithmic language scheme 
acm lisp pointers july 
duncan :10.1.1.31.7982
adding contracts java handshake 
technical report university california santa barbara december 
felleisen hieb 
revised report syntactic theories sequential control state 
proceedings theoretical computer science pages 
flanagan flatt krishnamurthi weirich felleisen 
catching bugs web program invariants 
acm sigplan conference programming language design implementation pages may 
flatt krishnamurthi felleisen 
classes mixins 
acm conference principles programming languages 
gamma helm johnson vlissides 
design patterns elements reusable object oriented software 
addison wesley massachusetts 
gomes stoutamire 
language manual sather august 
harper mitchell 
type structure standard ml 
acm transactions programming languages systems 
earlier version appears essence ml proc 
th acm symp 
principles programming languages pp 

holt cordy 
turing programming language 
communications acm volume pages december 
holzle bruno 
reflective java library support design contract 
proceedings meta level architectures reflection volume lecture notes computer science july 
rosenberg 
blue language specification version 
kramer icontract java design contract tool 
proceedings technology object oriented languages systems 
krishnamurthi felleisen friedman 
synthesizing object oriented functional design promote re 
european conference object oriented programming pages july 
leroy manifest types modules separate compilation 
acm conference principles programming languages pages 
leroy objective caml system documentation user guide 
liskov wing 
behavioral notion subtyping 
acm transactions programming languages systems november 
luckham programming specifications 
springer verlag 
luckham von henke 
overview anna specification language ada 
ieee software volume pages march 
man machine systems 
design contract java 
www com html 
meyer eiffel language 
prentice hall 
milner tofte harper 
definition standard ml 
mit press 
mallet 
assertion testing tool oop adl 
international conference software engineering 
parnas technique software module specification examples 
communications acm may 
rosenblum practical approach programming assertions 
ieee transactions software engineering 
eiffel 
prentice hall 
szyperski component software 
addison wesley 
semantics contract java defn defn class extends implements field meth interface extends imeth field fd meth md arg body imeth md arg pre post arg var body new var null fd fd md super md view binding true false binding var var variable name class name object interface name empty fd field name md method name boolean surface syntax defn defn class extends implements field meth interface extends imeth field fd meth md arg body imeth md arg pre post arg var body new var null fd fd md super md view binding true false binding var var variable name class name object interface name empty fd field name md method name boolean typechecking elaboration defn defn class extends implements field meth interface extends imeth field fd meth md arg body imeth md arg arg var body new var null fd fd md super md view binding true false binding var var variable name class name object interface name empty fd field name md method name boolean contracts compiled away contract java syntax contracts compiled away syntax syntax model contract java shown 
program sequence class interface definitions followed expression 
class definition consists sequence field declarations sequence method declarations interface consists method specification contracts 
method body class indicating method overridden subclass class instantiated 
java body method expression result result method 
java classes instantiated new operator class constructors contract java instance variables initialized null 
view forms represent java casting expressions capability bindings locally 
syntax divided parts 
surface syntax programmer uses 
second includes additional information underlined added elaboration type checking 
support evaluation field update field annotated class containing field calls super annotated class 
method calls annotated types order insert calls enforcer methods 
second syntax adds new form compile post conditions 
third syntax produced contract compiler accepted evaluator 
pre post conditions removed interfaces 
third syntax call blames argument contract violation 
predicates relations valid contract java program satisfies number simple predicates relations described figures 
example predicate states class name defined program sets names variables classes interfaces fields methods assumed mutually distinct 
meta variable method signatures variable lists var environments mapping variables types 
ellipses baseline indicate repeated pattern continued sequence centered ellipses 
indicate arbitrary missing program text spanning class interface definition 
class name declared class 
class 
field names class declaration unique class 

fd 
fd 
fd fd method names class declaration unique class 

md 


md 


md md interface name declared interface 
interface 
method name unique md var var 
var var distinct class declared immediate subclass class extends 

field declared class hc fd ti class 

fd 
method declared class hmd var var ei class 

md var var feg 
interface declared immediate interface extends 


method declared interface hmd interface 

md arg arg eb 
arg ea 
class declares implementation interface class 
implements 


class subclass transitive reflexive closure classes extended defined rng dom class hierarchy order antisymmetric method overriding preserves type hmd ei hmd field contained class hc fd ti hc fd ti minfc hc fd method contained class hmd ei hmd ei minfc hmd predicates relations model contract java part relation associates class name class extends overloaded relations capture field method declarations syntax summarizing relations induce second set relations predicates summarize class structure program 
subclass relation partial order predicates hold 
case classes declared form tree object root 
program describes tree classes decorate class tree collection fields methods accumulates local declarations inheritance 
source declaration field method class computed finding minimum superclass farthest root declares field method 
algorithm described precisely relations 
relation retains information source class field retain source class method 
reflects property java classes fields overridden instances subclass contain field methods overridden may inaccessible 
interfaces similar set relations 
declaration relation induces relation classes single interface multiple proper superinterfaces order forms dag tree 
set methods interface described union interface declared methods methods superinterfaces 
classes interfaces related implements declarations captured relation 
relation interface transitive reflexive closure extended implemented interfaces defined rng rng dom interface hierarchy order antisymmetric class implements interface interface inheritance methods consistent hmd hmd method contained interface hmd hmd classes supply methods implement interfaces md hmd hmd ei class methods instantiated hmd ei type subtype field method type method interface hmd hmd field method type method class hmd hmd ei field method type field type hc fd ti hc fd ti 
pre condition contract method interface 
hi mdi interface 
md arg pre post 

post condition contract method interface 
hi mdi interface 
md arg pre post 
contract declared interface hmd hht arg ht arg ii interface 

md arg arg pre post 
contract contained interface hmd hht arg ht arg ii hmd hht arg ht arg ii method pre condition contracts 
hi 
hi meth predicates relations model contract java part ii set edges joining class tree interface graph completing subtype picture program 
type full graph subtype ancestors 
pre post condition relation ensures interfaces declare method pre conditions 
contract java type elaboration type elaboration rules contract java defined judgements elaborates type defn defn defn elaborates defn meth meth meth elaborates meth imeth imeth imeth elaborates imeth elaborates type type subsumption exists type elaboration rules translate expressions access field call super method call normal method annotated expressions see underlined parts 
field uses annotated expression contains compile time type instance expression determines class containing declaration accessed field 
super method invocations annotated expression contains compile time type determines class contains declaration method invoked 
regular method calls contains type object called 
defn defn defn defn defn defn defn defn prog meth meth class 
fd fd meth class 
fd fd meth meth defn imeth imeth interface 
imeth imeth interface 
imeth imeth defn var var md var var md var var meth md var var md var var abs var var boolean md var var boolean fe 
hi mdi md arg arg pre post md arg arg pre post imeth new new new var dom var var var var null null null hc fd ti fd fd get hc fd ti fd fd set context sensitive checks type elaboration rules contract java part hmd md md call hmd var var super md super md super view dom dom view view var var var var var var true true boolean true false false boolean false boolean seq sub dom dom empty type context sensitive checks type elaboration rules contract java part ii complete typing rules shown figures 
program typed class definitions final expression typed 
definition turn typed field method declarations legal types method body expressions typed 
expressions typed elaborated context environment binds free variables types 
example get set rules fields determine type instance expression calculate class tagged field name yields type field class installed annotation 
set rule right hand side assignment match type field match may exploit subsumption coerce type value supertype 
rule interface methods folds post conditions super methods name post condition form 
program compiles program defn defn defn compiles defn program meth meth check pre post conditions 
imeth imeth imeth compiles imeth meth meth meth compiles meth enforces post condition meth blames compiles blames contract violations contract java judgements contract compilation contract compilation rules contract java defined judgements 
contains predicates compilation 
important ones ensures preconditions method syntactically 
second provides contract information translation 
gives contracts post conditions objects implement multiple interfaces 
predicates define important 
contains rules translate java contract programs java programs 
method pre post condition enforcer method generated interface rule 
enforcer accepts arguments original method plus additional argument names class calling method 
enforcer tests pre condition 
fails enforcer blames calling method 
enforcer calls original method 
original method returns enforcer checks post conditions folded single method expressions 
fail enforcer blames class 
enforcer returns result 
calls methods objects interface types changed calls enforcer call rule 
contract java evaluation operational semantics contract java defined contextual rewriting system pairs expressions stores 
store mapping objects class tagged field records 
field record mapping elaborated field names values 
evaluation rules straightforward adaption imperative scheme 
complete evaluation rules 
example call rule invokes method rewriting method call expression body invoked method syntactically replacing argument variables expression supplied argument values 
dynamic aspect method calls implemented selecting method run time type object store 
contrast super reduction performs super method selection class annotation statically determined type checker 
defn defn main defn defn defn defn defn defn prog imeth imeth interface extends imeth imeth interface extends imeth imeth defn meth meth pre meth pre ig class implements meth class implements pre meth pre meth meth defn interface md pre post nj nj pre post md string cname md md true md gg cname nj nj string cname md md xn nj true md gg cname interface md var var pre post md var var imeth md arg arg md arg arg meth new new new null null null var var var fd fd set fd fd get md md call md md call super md super md super view view cast var var var var true true true false false false seq blame compilation object object null true false fd fd fd md md super md view var var var new si 
object object hc fi new object dom fc fd null hc fd ti object fd si 
si get object hc fi fd object fd si 
object hc fd set object hc fi object md si 
object var varn si call object hc fi hmd var var ei super object md si 
object var varn si super hmd var var ei view object si 
object si cast object hc fi var var si 
var varn si true si 
si iftrue false si 
si iffalse si 
si seq si 
si true si 
si false si 
false si si 
herror violated contract si contract view object si 
herror bad cast si object hc fi view null si 
herror bad cast si null fd si 
herror dereferenced null si null fd si 
herror dereferenced null si nset null md si 
herror dereferenced null si operational semantics contract java 
