object test coverage finite state machines oscar department computer science australian national university canberra act australia email oscar dit csiro au heinz schmidt department software development monash university po box east australia email heinz schmidt monash edu au objects described having identity state behaviour differing views object states 
programmer object oriented programming language state current values attributes hidden accessible 
object oriented design methods object state abstraction design states determined observable behaviour object 
difference significant example views behave differently inheritance difficult validate implementation design specification 
describe technique resolving different views state 
representation states object partitioned states predicates attributes 
direct implication behaviour objects described finite state machines 
established testing techniques proving equivalence state machines example design specification implementation feasible prove test coverage level states automatically generated tests object oriented programs 
keywords testing object oriented programming object oriented design finite state machines community practitioners researchers object technology recognisable distinction programmers software engineers 
concentration object oriented programming languages features extensions 
seen explosion methodologies object oriented analysis design 
testing needs foot camps 
valid useful testing technology understand object oriented analysis design order find inconsistencies model implementation understand implementation language order concentrate search faults effectively 
difficult claim object technology new surprise little headway testing technology object oriented software 
focus behaviour objects terms states state transitions 
develop technique testing object state reconciles design view object state object oriented programming builds established technology testing finite state machines fsms 
section discusses fsms objectoriented design 
section describes method relating fsm view object behaviour implementation object oriented programming language 
applications testing addressed section approach generating test cases described section 
describe progress plans section relate section 
section concludes 
fsm models design point view object oriented design objects state behaviour booch rumbaugh henderson sellers edwards 
aspects objects closely related state object affects behaviour response messages sent resulting behaviour may turn change object state 
behaviour objects represented fsms 
object oriented design methods statecharts harel derivative specify dynamic behaviour objects see example coleman rumbaugh :10.1.1.20.461
formally deterministic finite state machine tuple 
set states sets inputs outputs theta state transition function theta output function initial state 
functions characterise behaviour state receiving input produces output enters state hopcroft ullman 
object inputs outputs represent messages tuples method name actual parameters initial state state object created transition function output function appropriately derived objects methods 
shows statechart stack 
states indicated rounded boxes transitions arrows 
transitions labelled message causes may firing condition square brackets 
initial state indicated arrow source 
corresponds creation message object oriented programs 
avoid cluttering diagram methods change state object top shown 
empty empty push pop elts pop elts statechart describing dynamic behaviour stack object 
call fsm model design fsm states design states transitions design transitions 
object oriented programming language sather omohundro design states represented predicates boolean functions design transitions method names associated firing conditions method preconditions 
multiple inheritance combine different facets state object concurrent states called states harel :10.1.1.20.461
state design fsm expressed formula terms state predicates fsm disjunction alternative states conjunction concurrent states 
sather formula part class invariant example 
subtyping design fsm subclass may vary parent fsm limited number ways 
states may modified added substates parents states concurrent states 
concurrent states commonly result multiple inheritance 
transitions added existing new states changed 
states transitions may deleted coleman mcgregor dyer 
subclasses represent subtypes distinct sather transition constraints preconditions weakened 
way possible ensure substitutability allowing object subtype act role parent type 
specialisation wanted example bounded stack uses inheritance subtyping 
shows statechart specialisation stack bounded stack 
notice new states added substates fsm parent preserved 
case sequences inputs stack legitimate bounded stack example bounded stack maximum size support sequence consecutive pushes 
sather implementation design appears 
empty full full empty pop elts push elts max pop push elts pop elts push statechart describing dynamic behaviour bounded stack object 
representation implementation object oriented programming language objects instances classes 
classes describe attributes methods operate attributes 
state object values attributes object particular point time 
obviously number states object may arbitrarily large infinite 
purposes reasoning behaviour object oriented programs natural think representation state object graph schmidt zimmermann 
nodes graph objects executing program directed arcs objects 
attributes object local variables actual arguments currently executing method 
arc labelled name attribute variable 
current value attributes basic type example integer boolean sather kept object node 
design fsms classes related inheritance similar identical corresponding relation level code 
implementation states values object attributes 
hidden suggested programming practice inheritance restriction addition removal 
absence language support preserving correct fsm behaviour requires programming discipline 
clearly mismatch implementation design views object state 
practice mapping design states representation states explicit state transitions usually buried method implementations 
factors difficult validate implementation correct respect design 
design fsm code class body opposite corners 
previously connection class interface 
suggests lower left corner provide appropriate bridge reconcile incompatibility implementation design views object state 
suggest representation implementation decisions called representation fsm captures important internal states representation states predicates abstraction implementation transitions 
corresponding fsm invariant called representation invariant terminology clu liskov guttag wulf 
fsm model concrete sather code implementation interface class body representation fsm design fsm class interface dimensions object class behaviour 
distinction design state corresponds representation states vectors values object attributes 
design states object represented partitioning representation states 
representation state predicates defined attribute values object 
furthermore assume similar mapping representation transitions design transitions 
representation fsms mapping design implementation levels explicit simplify validation dynamic behaviour classes 
simple example representation state predicates seen shows implementation sather stack class fsm specification illustrated 
representation states defined predicates empty notempty corresponding similarly named design states statechart 
sather implementation bounded stack specialisation stack 
new states design fsm see partition empty 
state parent 
implementation appears redefined predicate notempty disjunction representation state predicates added substates 
invariant parent holds inherited unchanged 
clearly design states abstractions attribute values basic types referenced objects rumbaugh class implementation stack arrays stack int constant init create res new create empty array storing elements res stack new size init create push stack size extend stack new size copy elements new array 
int stack stack stack push pop notempty top notempty res stack representation state predicates empty bool res notempty bool res representation invariant invariant welldefined empty notempty class stack stack class implemented sather 
design state represented predicate attributes 
furthermore valid representation state object predicate true disjunction predicates invariant object 
method fsm design specifies possible transitions design states 
implementation expressed post condition class bounded implementation bounded stack include inherit stack 
constant max create res bounded new create empty array storing elements res stack new size max create push stack push representation state predicates full bool res max bool res max notempty bool redefine parent notempty state assume max 
res full class bounded stack bounded stack class implemented sather 
method representation state predicates 
languages support invariants pre post conditions sather explicitly describing mapping fsm design enhances robustness implementation meyer 
testing fsms fsms 

equivalent sequence inputs produces sequence outputs fsms 
chow showed fsm minimal select finite set input sequences ae equivalent equivalent input sequences practice restriction minimal fsm presents difficulty test implementation specification specification typically minimal readily minimised hopcroft ullman 
number refinements fujiwara bernhard reduce size test set generated chow method 
derive set traces sequences inputs expected outputs cover representation fsm 
trace test case implementation relative representation fsm 
intuitively trace implemented sequence calls appropriate methods code guarded tests preconditions 
test cases find errors implementation complete correct respect representation fsm 
map states transitions representation fsm design fsm cover design fsm 
representation invariants related subtyping gain advantage situation case design fsm say stays fixed representation fsm say changed 
generate coverage reuse coverage expect benefits approach outweigh restrictions introduced subtyping viz 
requirements weakening representation invariants 
context project prefer representation invariants subclasses related subtyping 
covering test generator constructing representation fsm requires additional 
believe small portion implementation effort 
testing typically excess total development effort pressman 
basing testing fsm models test data generation straightforward established techniques 
advantage clear semantic relation fsms class invariants 
additional benefit documenting design design fsm implementation decisions terms representation fsm 
understandability maintainability software increased 
representation fsm drives tests class code 
design fsm defines expected outcomes 
level testing class behaviour tested defined granularity representation fsm 
behaviour observed required defined granularity design fsm 
detailed aspects behavioural model coverage interface testing greater confidence correctness workings 
selecting appropriate level detail design representation fsm possible strike balance cost validation effort targeted reliability robustness 
current state date developed test driver classes methods supported classes provide framework test case generation 
current efforts directed design test case generator test driver classes 
map fsm driver written sather code generates sequences calls corresponding test cases partial method fujiwara 
test code generated fsms provided separate files 
fsm descriptions files compared existing assertions code provide additional consistency checking 
parallel working semantics testing object machines schmidt zimmermann operational semantics objects execution 
ideally notion coverage code just behavioural model described design fsm typically coarse abstraction actual behaviour 
coverage analysis compare control flow graph program representation fsm 
established possible design guidelines combining test coverage system runtime instrumentation 
object machines describe transformations implementation state object execution sather program history 
class histories share similarities traces trace assertion method parnas wang 
may possible derive trace assertions state graph transitions occuring object machines 
case apply trace rewriting technique trace simulator tool wang parnas 
related state defining predicates chambers class object determined dynamically attributes satisfy class predicate 
powerful design technique simplifies class implementation requires multi methods applicability limited object oriented programming languages support 
hoffman approach class testing ways similar 
partition class implementation state derive appropriate transitions creating effect fsm 
deriving fsm test cases class design specification implementation fsm test oracle test set cover nodes arcs test graph 
case fsm testing techniques show equivalence class test graph propose 
immediate approach testing object state classes described turner robson 
object state case vector attribute values seen additional method arguments adequacy addressed covering partitioning state values way inputs 
frankl derive test suite class consists pairs message sequences put object state 
essence implements trace equivalence wang parnas class viewed fsm 
method testing class behaviour method sequence specifications message sequence specifications tsai derived complete fsm model 
oo methodologies fsm models related diagrams play role supporting validation context 
objectoriented design methods avoid fsms stat particular ed rejects modelling specification tools favour petri nets 
petri nets underlying state machine semantics reachability graph decomposition sequential fsm components possible classes petri nets 
jacobson 
object behaviour described event timing diagrams 
adopted methods booch 
event timing diagrams derived complete fsm specification obvious extract underlying fsm diagrams 
software development process specification direct implementation fsms suggested reed 
method uses rsml leveson modification statecharts developing formal specifications validated domain experts 
major advantages method seen testability fsms 
described technique validating dynamic behaviour objects refinement fsms coverage equivalence 
test case generation tool approach developed 
method adaptable software development priorities allows users define granularity testing means representation fsm implementation tested 
oscar gratefully acknowledges support csiro studentship 
brian lin anonymous referees comments draft 


essays objectoriented software engineering volume englewood cliffs nj usa prentice hall 
bernhard 
july 
reduced test suite protocol conformance testing 
acm trans 
software engineering methodology 
booch 

object oriented analysis design applications nd ed 
redwood city california usa benjamin cummings 
chambers 
july 
predicate classes 
nierstrasz ed european conference object oriented programming ecoop kaiserslautern germany pp 

lncs springer verlag 
chow 
may 
testing software design modeled finite state machines 
ieee trans 
software engineering 
coleman hayes bear january 
introducing statecharts object oriented design 
ieee trans 
software engineering 

frankl 
astoot approach testing objectoriented programs 
technical report polytechnic university jay st brooklyn ny 
fujiwara june 
test selection finite state models 
ieee trans 
software engineering 
july 
graph model object oriented programming 
acm sigplan notices 
harel 

statecharts visual formalism complex systems 
science computer programming 
henderson sellers edwards 
object oriented knowledge working object 
englewood cliffs nj usa prentice hall 
hoffman 
graphbased class testing 
proceedings seventh australian software engineering conference pp 

hopcroft ullman 
automata theory languages computation 
addison wesley 
jacobson jonsson 
objectoriented software engineering case driven approach 
wokingham england addison wesley 
tsai december specification verification object oriented programs 
technical report computer science department university minnesota minneapolis mn usa 
leveson heimdahl hildreth reese september 
requirements specification systems 
ieee trans 
software engineering 
liskov guttag 
abstraction specification program development 
cambridge massachusetts mit press 
mcgregor dyer october note inheritance state machines 
sigsoft software engineering notes 
meyer 
october 
applying design contract 
comm 
acm 
omohundro december 
sather specification 
international computer science institute university california berkley 
documentation provided sather compiler version 
parnas wang 
trace assertion method module interface specification 
technical report telecommunications research institute ontario trio queen university ontario canada 
pressman 

software engineering practitioner approach rd ed 
mcgraw hill 
rumbaugh blaha premerlani eddy lorensen 
objectoriented modeling design 
prentice hall international 
schmidt zimmermann 
complexity calculus objectoriented programs 
object oriented systems 
turner robson 
suite tools state testing object oriented programs 
technical report tr computer science division school engineering computer science university durham durham uk 
wang parnas october 
simulating behaviour software modules trace rewriting 
ieee trans 
software engineering 
wulf london shaw 
abstraction verification language methodology 
technical report usc information science university southern california los angeles usa 
reed 
building testable software 
submitted sigsoft software engineering notes 
