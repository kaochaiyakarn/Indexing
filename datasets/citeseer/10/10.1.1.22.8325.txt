automatic generation targeting application specific operating systems embedded systems software gauthier yoo ahmed sls group laboratory avenue felix grenoble france gauthier yoo ahmed imag fr propose method automatic generation application specific operating systems os automatic targeting application software 
os generation starts small flexible os kernel 
os services specific application deduced dependencies services added kernel construct os 
communication synchronization functions application code adapted generated os 
preliminary experiment applied proposed method system example called token ring system 

sw parts embedded systems system resources terms numbers sizes processors memory usage power consumption 
implement complex sw target processors operating systems os usually adopted serialize sw execution interface sw application target architecture exemplifies os sw implementation concurrent multiple tasks processor 
shows concurrent tasks communicate tasks high abstraction level channels fifo shared memory 
os sw implementation os schedules execution tasks executes communication tasks system calls 
shows case os sw implementation tasks 
tasks communicates tasks system calls case fifo shm fifo shm 
target architecture represents processor memory modules devices fifo void task value read port ain write port aout value shm void task value read port bin write port bout value fifo void task value fifo port ain shm port aout value system call scheduling os cpu void task value shm port bin fifo port bout value system call scheduling 
example os sw implementation multiple tasks 
crucial problems os sw implementation porting configuring os target architecture target processor memory architecture targeting sw application code os done manual designer ports os sets os configurations specific target architecture modifies application sw code meet ported configured os 
design practice time consuming error prone 
change target architecture require significant re porting re configuration os possibly re targeting sw application code 
design practice finding optimal target architecture os configuration design space exploration dse os os related target architecture hard tighter time market 
enable dse os implementation methods automatic generation application specific os required 
method gives automatic generation application specific os automatic targeting application code generated os 
organized follows 
give review model application multitask hand coding specific software code os manual compile link executable software code unique os code direct transmission human interpretation 
sw implementation ported os 
related section 
propose method automatic generation application specific os automatic targeting application sw code section 
section case study applying proposed method 
section give 

related section review previous studies implementing concurrent multiple tasks single processor application specific os generation 
approaches sw implementation multi task descriptions 
approaches os scheduler interface multiple tasks target architecture 

designer ports existing os target architecture targets multiple tasks os runs os shows os porting sw targeting flow approach 

improve performance os system call execution times reduce overhead os os code size designer configure existing os 
instance designer determine usage message queue os depending application sw uses 
granularity configuration depends os vendors 

prevent usage os sequential code generated concurrent multi task representa table 
comparisons different approaches multi task sw implementation 
approaches speed size flexibility efforts os porting os configuration sequential code gen 
tion 
approach trade reduction os overhead increase sequential code overhead terms code size system runtime approaches mix sequential code generation maximizing sequential code parts application os usage 
enable system design higher abstraction level high level model os called 
analysis context switching overhead context switching methods pico kernel code merging table sequencing non preemptive task scheduling 
table compares approaches terms os execution time speed memory requirement size scalability portability flexibility designer efforts efforts 
table stars represent excellent average poor note 
case os configuration put stars size flexibility efforts configurable os quality degree configuration differs 
case sequential code generation reasons poor note speed synchronization done polling lot conditional jumps sequential code fit pipelines caches state art processors 
note mentioned approaches os sw implementation targeting application sw ported configured os requires lot hand coding 
method proposed os generated small flexible os kernel including application specific functions 
compared os configuration approach proposed method give efficient adaptation os application sw determining application specific functions done automatically start os generation small flexible os kernel 
terms adapting os specific application proposed method related method called os specialization 
authors strategy automatic targeting communication os parameterized communication physical implementation interrupt propagate synchronization event 
detection event done polling event 
operating system library existing code void fifo struct fifo port short res port head port queue sleep port signal res port data port queue port queue port queue return res adaptable code ports declaration define ports endfor 
targeted operating ports declaration fifo fifo port void shm xa 
allocation table fifo porta shm xa 
makefile cc gcc objs boot fifo 
high level tasks description void task val read port porta write port val architecture analyser communication protocols parameters required services code parameters targeted processor selector os code file names macro files tasks code file names task code code makefile adapter generator targeted task description void task val read fifo fifo port write shm shm val 

flow automatic generation application specific os automatic sw targeting 
library simple scalable target architecture targeted os automatic synthesis method task scheduler 
compared proposed method automates generation os scheduler inter task communication implementation specific application target architecture systematic construction os application specific derived os services targeting high level inter task communication application generated os 
difference proposed method os specialization method focus generating os minimum sufficient services required application os specialization methods optimize os services exploiting quasi static behavior os specific application 
method similar proposed 
main difference application domain method mainly focus dataflow application ambition focus heterogenous application domain 
due difference input model application changes os library complex see section section 

automatic synthesis targeting application specific os application sw codes 
design flow sw implementation shows design flow automatic os generation sw targeting 
input os generation module processor module module task task module processor module task 
hierarchical network modules 
sw targeting flow system description consisting hierarchically structural representation communication modules module behavior memory allocation information 
shown architecture analyzer takes structural information memory allocation information 
code selector receives list services specific application architecture analyzer finds full list original deduced services code expander generates source code os 
task code adapter performs sw targeting makefile generator gives makefiles 
outputs design flow source code generated os targeted application code makefile processor 
obtain binary code downloaded target processor memory designer runs compilation generated os targeted application generated makefile 

application domain focus targeting tool heterogenous embedded applications cellular phones car controllers 
applications require various communication protocols may different time constraints processor 

system description input system description input flow takes structural representation communication hierarchical network modules behavior code tasks memory allocation table 
shows example hierarchical network modules 
structural representation modules connected communication channels 
hierarchical representation module leaf module module network modules inside 
call leaf module task 
module consists behavior port representation behavior communication separated 
behavior part uses ports calling port functions communicate modules 
high level task description void task val read port porta write port val targeted task description void task val read fifo fifo port write shm shm val 

example task behavior 
viewpoint behavior ports give high level communication functions encapsulating communication details communication protocols 
shows example communication ports task 
behavioral part just calls high level communication function port function read port porta communication port porta 
sw targeting refine calls port functions 
exemplifies case sw targeting task description 
port function read port porta replaced system call read fifo fifo port generated os 
structural description information behavior mapping multi processor target architecture shows module case task mapped processor os generated processor basis 
os scheduling task task priority 
mapping information task priority represented attributes module 
memory allocation table information memory allocation inter processor communication memory allocation fifo shared memory interprocessor communication 

operating system library os library provides small flexible os kernel os services 
os kernel main functionality os kernel scheduling multiple tasks 
preemptive schedulers available os library round robin scheduler scheduler case round robin scheduler time slicing assigning different cpu load tasks supported 
os kernel small flexible task scheduler selected requirement application code minimal amount kernel code size processor specific assembly code context switching interrupt service routines 
table 
basic functions os kernel 
function behavior code type context switching assembly sleep task sleeping wake waking task schedulers task scheduling table shows basic functions os kernel 
function performs context switching currently running task task executed 
context switching operation differs processor processor function consists kinds code code assembly code 
code part called schedulers code priority scheduler round robin scheduler 
assembly code part performs processor specific context switching operation 
function sleep wake preemptive task scheduling 
task scheduling schedulers required application sw selected os library scheduler services 
os services os library provides services specific embedded systems communication services fifo communication services pci bus drivers memory services cache virtual memory usage service may provided os element described library 
os elements represent part os 
provide services may require services 
may implementations compatible different architectures 
implementations os elements contain types code re usable existing code expandable code 
example existing code fifo code exist os library form language 
example expandable code os kernel functions exist os library form macro code 
examples existing expandable codes shown os library 
section explain code expansion detail 

os code generation architecture analyzer architecture analyzer finds information system description input 
application specific services detailed parameters module specific parameters application specific os services attributes modules channels ports system description input 
instance channel attribute fifo implementation fifo service selected included os generated 
detailed parameters required services allocation table 
instance address range fifo communication interrupt priority interrupt driven port allocation table 
information required services sent code selector 
module specific parameters task priority cpu load type mapped processor module attributes 
type processor sent makefile generator choose right compiler code expander target os code processor 
code selector code selector takes input list required services architecture analyzer 
looks os library check service dependencies finds elements dependency relation required services compliant target architecture 
element compliant architecture implementations compliant architecture services requires provided compliant element 
element may require services algorithm repeated recursively 
instance required service fifo communication need interrupt handling service 
case element providing interrupt handling service chosen included os generated 
elements compliant architecture may provide required service 
case user choose 
element selection done code selector sends list code file names makefile generator macro file names code expander 
code expander code expander takes input list macro code code selector parameters processor allocation informations architecture analyzer 
generates final os code expanding macro codes elements source codes assembly 
shows example code expansion 
macro code section shown os kernel functions context switch function round robin scheduler function circle 
code expander determines necessity services information requested services 
instance depending number priority values pr max number define schedule pr max size void int switching endif schedule define round size void circle endif round void int switching tasks cxt tasks cxt void circle macro code example expanded code example 
example macro code expansion 
tasks size priority value context switch function round robin scheduler function circle selected 
example priority value pr max size need context switching 
case context switching code selected 
tasks priority value size context switching code round robin scheduler code circle selected expanded 
shows example expanded code case 
note case scheduler selected schedule tasks different priority values 
shows example expanding macro processor specific code 
processor specific code expansion limited functions context switching synchronization primitives semaphore functions interrupt service routines 

targeting application sw code target application sw code generated os task code adapter replaces function calls communication synchronization original application sw os service calls system calls 
instance function call communication called read port porta replaced os service function call read fifo fifo port 
note original function arguments replaced arguments specific os service function 
example argument original function porta replaced argument fifo service function fifo port pointer fifo address case 

makefile generator makefile generator takes input processor type information architecture analyzer list source codes os assembly elements code selector list application sw codes 
determines right compiler linker generates makefile processor includes code lists os application sw 

application existing os existing os integrated proposed flow automatic generation specific case automatic configuration application specific os 
explain integration assume existing os supports os configuration ifdef statements configuration defining required macros modifying os source code commercial os allow configuration 
integration done follows 

information available os services service functions macros defined services dependency relations services existing os taken os library 

os generation flow designer gives system description input explained section 
architecture analyzer performs operation extracting required information services target processor information described section 
code selector finds required derived services os library explained section 
selects os library macro definitions corresponding required services selecting existing adaptable files explained section 
note case automatic configuration existing os code expander generate os source code existing os source code modified 

task code adaptor performs operation explained section automatically configured os 

makefile generator outputs makefile selected macro definitions received code selector 
token token cnt token token os generation sw targeting token token cnt token token os os os processor processor processor communication layer 
implementation token ring system multi processor target architecture 
note compared original flow automatic os generation proposed case integrating existing os flow change automatic execution service extraction architecture analyzer makefile generation adaptation application code automatically configured os 
terms code quality size execution time automatically configured os depends granularity os services existing os 
existing os supports fine granularity os services os kernel services quality automatically configured os comparable automatically generated os 

experiment 
system example target architecture applied proposed method system example called token ring system lines systemc 
consists tasks called token exchange tokens counter task called cnt counts number tokens exchanged 
shows interconnection tasks example task corresponds module example 
shown token tasks bidirectional ring connection 
counter task connected token tasks 
note structural description belongs system description input 
experiment implement system example multi processor target architecture processors 
shows result implementation 
token tasks mapped processors tasks processor counting tasks mapped processor 

synthesis application specific os sw targeting system description input assigned information processor mapping attributes mod ule 
assigned equal priority tasks 
communication channel modules specified word communication non blocking write blocking read 
example size transferred data counter value token word 
system description input read architecture analyzer 
code selector selects kernel functions services os processors token tasks mapped 
round robin scheduler service tasks priority 
timer service round robin scheduler 
non blocking write called blocking read services called 
code expander generates os source code handles tasks equal priority communication service functions 
task code adaptor replaces original communication functions port value port value services value value 
processor counter task mapped communication services selected 
scheduler timer services selected task processor 
obtained binary executables processors running compilation generated source codes makefiles 
validated system implementation instruction set simulators processor vhdl simulator hw interfaces processors 
preliminary result experiment generated os gives small code sizes lines assembly kb processors token tasks kb processor counter task 
terms performance gives instruction cycle latency channel read operation interrupt trigger single word data access 

proposed method automatic generation application specific operating systems automatic targeting application code 
proposed method starts automatic generation operating system small flexible kernel includes os services specific application 
applied method token ring system obtained promising result 
project 
available www cse ogi edu disc projects 
task generation compile time scheduling mixed data control embedded software 
proc 
design automation conf pages june 
man operating system software generation systems chip 
proc 
design automation conf pages june 
dick raghunathan jha 
power analysis embedded operating systems pp 
proc 
design automation conf june 
edwards 
compiling esterel sequential code 
proc 
design automation conf pages june 
systems 
available www com 

optimized rapid prototyping real time embedded heterogeneous multiprocessor 
codes workshop hardware software codesign may 
benner ernst 
code generation context switching static scheduling mixed control data oriented hw sw systems 
proc 
th asia pacific conference hardware description language pages aug 

memory cpu size optimization embedded system designs 
proc 
design automation conf pages june 

modeling verification exploration task level concurrency real time embedded systems 
kluwer academic publishers boston 
lin man strategy real time kernel support application specific hw sw embedded architectures 
proc 
design automation conf pages 
wind river systems vxworks 
available www wrs com products html html 
