appears proceedings th annual acm ieee international symposium microarchitecture austin texas december correctly implementing value prediction microprocessors support multithreading multiprocessing milo martin daniel harold cain mark hill lipasti computer sciences department department electrical computer engineering university wisconsin madison milo cain cs wisc edu explores interaction value prediction thread level parallelism techniques including multithreading multiprocessing correctness defined memory consistency model 
value prediction subtly interacts memory consistency model allowing data dependent instructions reordered 
find predicting value verifying value eventually calculated value predicted sufficient 
example multithreaded pointer manipulation generate surprising erroneous result value prediction implemented considering memory consistency correctness 
show problem occur real software discuss apply existing techniques eliminate problem sequentially consistent systems systems obey relaxed memory consistency models 
prominent trend micro architectural research improving system performance adding prediction speculation processor core 
value prediction type prediction emerged research community numerous papers demonstrated performance potential 
value prediction mechanism predicts complete value bit integer contrast bit branch outcome resulting branch prediction 
principle value prediction enable program execution time lower bound determined dataflow limit 
trend micro architectural research exploits thread level parallelism tlp form simultaneous multithreading smt coarse grained multithreading cmt single chip multiprocessing cmp traditional multiprocessing mp 
software perspective hardware multithreading multiprocessing treat similarly 
techniques shown improve performance substantially important applications database workloads web workloads desktop applications 
explores correctness issues arise interaction techniques 
date value prediction research assumed singlethreaded uniprocessor system ignored multithreading input output issues 
correct implementation value prediction context single threaded uniprocessor system coherent understood show nave implementations value prediction tlp systems systems multithreading multiprocessing coherent produce incorrect executions 
mean correctness 
system single threaded uniprocessor coherent correctness simply defined program order uniprocessor correctness 
scenario value prediction correct simple verification succeeds value predicted equals actual value eventually obtained 
multiple threads processors devices concurrently access logically shared memory definition correctness complicated 
tlp systems correctness defined memory consistency model 
memory consistency model enforced jointly processor memory system interface hardware low level software defines legal orderings loads stores different memory locations 
example memory consistency model system answers questions thread writes different memory locations order threads devices system allowed observe writes threads system observe writes order 
memory consistency models defined part instruction set architecture isa hardware obey consistency model just hardware correctly implement instructions specified isa 
tlp system implementations value prediction ensure value prediction cause consistency model violations 
value prediction violate consistency model 
key insight value prediction allows processor relax ordering data dependent operations 
normally dependencies enforced dataflow processor value prediction allows processor break dataflow program allowing dependent operations speculatively execute program order 
generally current microarchitectural optimization allows relaxation program order data dependent operations lead consistency violations focus value prediction 
key result systems multithreading multiple processors coherent verifying value prediction comparing predicted actual values sufficient cause erroneous behavior 
tlp system single threaded uniprocessor possible value prediction incorrect time prediction correct time value prediction verified thread processor device modified value interval prediction verification 
simple verification value prediction appears correct show cases execution incorrect violates memory ordering rules consistency model 
possible violation sufficient determine implementation incorrect 
informal example simple value prediction cause problem consider scenario professor plans post results exam impatient student class wait see score 
student assigned student id class predicts results posted bulletin board arrives bulletin board finds student score 
results looking old results class 
professor posts correct results actual score board replacing results student seen announces results posted board student looked originally verifies earlier prediction board continues incorrectly assume score 
explore analogous scenario arises multithreaded code reading writing linked list data structure 
section examine issues involved implementing value prediction context sequential consistency simplest consistency model 
example show adding simple value prediction tlp system insufficient implement sequential consistency 
review techniques ensure correctness aggressive implementations sequential consistency show existing mechanisms sufficient value prediction added 
section investigate relaxed consistency models demonstrate simple implementations relaxed consistency models insufficient value prediction added 
mechanisms similar aggressive sequentially consistent implementations added ensure correctness mechanisms conservative 
ideas conservative schemes detailed evaluation relative performances scope 
potential criticism value prediction problems illuminate occur theory practice 
section show dynamic code sequences necessary generate value prediction errors relaxed memory model occur workloads simulated processor symmetric multiprocessor smp 
value prediction sequential consistency simplest intuitive set rules governing behavior ordering memory operations threads devices sequential consistency sc 
section describe sc example simple system implements sc value prediction fails implement sc value prediction added 
describe techniques detection ordering violations techniques restore simple system valid sc implementation 
techniques methods correct implementation sc aggressive order processors 
adding value prediction system supports sc simple processors result additional complexity adding value prediction dynamically scheduled sc implementation minimal additional design impact due memory consistency model considerations 
sc simple sc system memory consistency model system specifies memory operations appear programmer 
programmers view tlp system multi tasking uniprocessor 
lamport formalized notion defined system sequentially consistent sc result execution operations processors threads executed sequential order operations individual processor thread appear sequence order specified program 
sc restrictive consistency model implemented commercial systems including mips hp pa presents simplest intuitive surprising interface programmer 
consider simple order processor implements coarse grained hardware multithreading multiple hardware contexts share cache 
processor performs memory operations thread order implements sc 
system multithreaded processors multiple processors standard invalidation cache coherence exhibits similar interactions value prediction memory consistency 
consider aggressive processor designs section 
simple value prediction violate sc show extending example system simple value prediction simple verification violates sc 
simple value prediction 
instruction value predicted processor predicts value produced instruction continues executing instructions thread including dependent instructions speculatively 
simplicity conservatively assume implementation waits value predictions verified executing store instructions encountered speculating 
predicted instruction completes possibly cycles due cache misses delays processor compares actual value predicted value 
value matches prediction determined successful execution continues 
processor aborts execution rolls back thread mechanism similar recovering branch misprediction 
illustrative example 
illustrates problem simple implementation value prediction serve illustrative example 
example pointer data structure manipulation analogous informal example professor posting grades student checking grade 
thread professor inserting front list thread student reading element list 
synchronization necessary writer reader 
reader writer may execute code instructions may occur interleaved 
sc code segment allows possible outcomes read happens insert resulting reader observing data value insert occurs read reader observers data value student grade 
sc store changes data old grade previous class occur store changes head pointer point reader observe stale value 
example execution 
example code sequence works correctly sc system implementation value prediction returns simple value prediction generate surprising result value 
examine value prediction change execution example 
reader executes 
assume reader value predicts result instruction 
value predicted assume hardware predicts value 
student predicts grade board 
notice appears value prediction incorrect value head time 
reader continues executing speculatively instruction reads value 
student sees score 
reading impossible value speculating allowed discarded value prediction ultimately determined incorrect 
reader resolves value prediction thread switch occurs writer executes instructions effectively inserting new node list 
professor posts grades board 
memory system processes reader load head returns current value 
reader compares predicted value board actual value professor announces results board surprisingly decides value prediction correct 
value prediction pronounced correct reader continues execute 
execution violates sc instruction reads value student thinks score 
intuition 
value prediction correct clearly initially wrong 
time value prediction resolved thread new value 
essence predicted allowed read location ready observed 
student verified looking right set grades looking right grades prediction incorrectly believed score 
key observation adding simple value prediction allows perform dependent operations program order 
executing data dependent memory operations order sc violated 
particular example load value prediction value prediction types instructions faces issues 
instance load address dependent instruction output value predicted similar violation possible 
formal explanation value valid 
execution correct definition sc requires construct total order memory operations loads stores 
instruction precedes global order writes value read 
instruction precedes reads value writes value 
sc second requirement head head 
example showing failure simple value prediction part presents code writer left races reader right 
writer sets element value links element list 
reader reads value element 
part gives initial state memory singly linked list head currently linked element unlinked element element data value field pointer 
part shows final state writer atomically inserts element reader execute atomic insert obtaining respectively 
part shows value prediction simple verification allow reader obtain incorrect stale value 
technically result assumes sequential consistency sc see similar problems exist memory consistency models 
head data null data null initial state code writer store mem data load reg mem head store mem reg store mem head code reader load reg mem head load reg mem reg racing code final state incorrect execution data null data data null prediction load reg mem head value predict reg load reg mem reg speculatively load reg store mem data load reg mem head store mem reg store mem head reader verifies reg mem head reader commits reg reg data null final state called program order requires precedes precedes precedes precedes 
instructions put sequential order sc requirement required order instructions forms cycle shown 
execution obey sc example system simple value prediction correctly enforce sc 
restoring correctness alternatives exist correctly implementing value prediction sequentially consistent system 
schemes previously developed techniques implementing dynamically scheduled processors support sc detect value prediction violated sc 
techniques suffice detecting ordering violations caused value prediction recovering add complexity increase cost simple processor implementations considered far 
discuss techniques enforce sc systems value prediction explain mechanisms detect ordering violations introduced value prediction 
address detection 
dynamically scheduled processors implement sc mips allow memory operations occur speculatively program order rollback possible memory ordering violation detected 
enforce sc processor detect thread processor device writes address speculatively read cache instruction 
ordering violation detected processor rolls back execution speculative thread known consistent non speculative state 
implements approach augmenting load store queue track addresses speculatively loaded loads retire compare addresses addresses written processors 
external writes revealed coherence protocol arrival invalidation messages addresses 
multithreaded processors implement similarly keeping thread table speculatively loaded addresses checking stores threads processor table 
refer process comparing threads stores processors invalidations set addresses thread loaded speculatively read set tracking 
scheme overly conservative false triggered false sharing multiprocessors writing value silent store 
relaxation program order enabled value prediction analogous relaxation program order load instructions data dependent 
sc requires appear occur order cases read set tracking sufficient identifying ordering violations 
example reader detects writer writes mem reg detected comparing store address writer address speculatively loaded reader prediction retirement knows simple verification prediction insufficient 
special check enforce dependence order needed guaranteeing appearance program order guarantees appearance dependence order 
returning running analogy student test score student detect professor posts grades prediction verification bulletin board correct prediction 
student asks friend stand bulletin board report changes posted grades 
case professor posts board student prediction student friend tell information board changed student know check score 
friend reports violation grade known correct validation required 
value detection 
approach loads execute directly transitively predicted address operands replayed operands non 
value prediction simple verification violating sc 
example execution forms cycle violating sc 
code writer store mem data load reg mem head store mem reg store mem head code reader load reg mem reg load reg mem head speculative immediately retirement 
speculative load wait operands non speculative read value cache second time compare non speculative value earlier speculatively loaded value 
values match ordering violation occurred 
values match standard misprediction recovery mechanism invoked 
approach avoids false due false sharing silent stores 
approach considerable downside loads execute twice increasing contention cache read ports 
dynamic verification introduced technique tolerating transient design errors microprocessor implement value detection memory consistency ordering violations 
proposed implementation dynamic verification uses separate core checker processors dedicated data cache 
organization mitigates cache port pressure problem removes verification critical path allowing main processor proceed executing speculatively retiring instructions 
decoupled approach reduce cost performance penalty associated traditional implementations value detection 
value detection fits simple analogy 
professor announced scores posted student friend go bulletin board double check score just case 
situation speculatively observed score score student know prediction wrong 
discussion 
noted connection memory value prediction software directed binding prefetching 
binding prefetching data brought registers early direction software 
software guarantee high level language semantics possibly hardware assistance ia alat 
contrast memory value prediction implemented hardware disturbing low level memory consistency model 
value prediction sc broadly sc implementations simple coarse grained multithreading order non speculative aggressive smt order highly speculative 
correctly applying value prediction simple sc system moves implementation complexity aggressive sc implementation mechanisms verifying value prediction similar enable aggressive sc implementations 
implementing value prediction system supports dynamic scheduling sc straightforward existing mechanisms sufficient 
section explore ramifications adding value prediction systems exploit relaxed consistency models 
value prediction relaxed memory models common instruction set architectures require strict semantics sequential consistency 
systems said implement relaxed memory consistency models 
relaxed memory models allow hardware potentially employ optimizations store queues write buffers simplify implementation order execution 
relaxed models require programmer add explicit annotations enforce memory orderings 
value prediction interacts relaxed models interacts sc similar challenges exist value prediction relaxed consistency models 
defining relaxed memory consistency models complex 
refer reader adve gharachorloo tutorial subject primary sources 
broadly classes relaxed models address section 
class called processor consistent pc models similar sc models allow fifo non coalescing store buffers relaxing order thread write subsequent reads 
class generally referred weakly ordered models allows reordering reads writes 
processor consistency pc models sparc total store order tso ia allow relaxation order thread write subsequent reads 
pc models allow relaxation read read program order simple implementations example execute program order 
hand sophisticated implementation allows reads reordered outof order execution guarantee appearance program order execution methods described section 
pc relaxes write read order result valid pc models 
going back sc example difference pc pc relaxes write read ordering arc 
arc part cycle 
sc correct implementations value prediction pc models return surprising result 
issues correctly implementing value prediction pc models substantially similar issues sc discussed section pc models sc enforce read read ordering 
mechanism guarantees appearance read read program order suffices guarantee appearance read read dependence order loads serialized dependence order serialized program order 
sc adding value prediction simple processor supports pc require additional mechanism detect violations introduced value prediction 
adding value prediction complicated processor speculatively relaxes read read order contains mechanism detect violations require additional mechanism 
weakly ordered models section concentrates class relaxed memory consistency models including weak ordering release consistency allows processor reorder reads writes provided processor sees reads writes order 
commercial models class include alpha powerpc ia sparc relaxed memory order rmo 
models differ subtle ways require programmer insert memory barriers mbs barriers fences syncs annotations assert required orderings 
sc pc dynamically scheduled processors support weaker models need implement memory ordering detection mechanisms described section 
processors allow memory operations speculatively execute order requiring additional inter thread detection mechanisms 
re orderings longer violations correct semantics allowed memory model 
processors enforce ordering memory barriers 
simplicity thread encounters memory barrier examples order enforced stalling execution instructions memory barrier retires 
thread continues execution speculative instructions including value predicted instructions completed 
implementation conservative similar alpha 
subtle difference weak memory models affects interaction value prediction establish order data dependent reads processor 
models require memory barrier data dependent operations register models require memory barrier enforce ordering reads reads data dependent say models enforce data dependence order 
discuss alternatives turn 
models enforce data dependence 
discuss models including sparc rmo powerpc ia require memory barrier order independent reads dependent reads 
case hardware required preserve dependence order 
considering value prediction programmers want linked list code allow expected outcomes add memory barrier instruction shown 
memory barrier asserts instructions initializing element ordered instruction inserts element head list 
memory barrier ordered operations resulting addition partially uninitialized node head linked list 
extend informal analogy professor posting grades consider different situation professor busy post results sends teaching assistant ta 
assume professor gives results ta post immediately sends mail class 
ta delayed posting results student see mail go check score believe erroneously despite value prediction score 
professor prevent problem waiting ta report back acknowledging results posted sending mail 
waiting ta return analogous inserting memory barrier required weak models regardless enforce data dependence order 
weak models allow relaxation read read ordering appear example require insertion additional memory barrier enforce order reads 

simplify discussion assume type memory barrier enforces orderings 
reality relaxed models multiple flavors barriers annotations different ordering requirements 

correct code weak ordering data dependence enforced code writer store mem data load reg mem head store mem reg memory barrier code reader load reg mem reg load reg mem head store mem head considering models enforce data dependence order 
example require memory barrier instructions data dependence orders instructions dependence order rmo page powerpc page ia section 
addition memory barrier ensures correctness value prediction prevent incorrect execution nave value prediction 
student predict grade board see score verify board correct location erroneously believe grade 
simple implementation value prediction violates weak memory models enforce data dependence order 
approach restoring correctness change memory consistency model removing enforcement data dependence order 
change requires programmers insert memory barrier dependent instructions 
memory barrier explicitly order instructions ensuring expected outcomes example occur 
student predict look board act prediction observes professor announcement approach breaks backward compatibility changing memory model definition architecture require additional memory barriers may break programs written old definition 
reason consider practical solution 
conservative solution approach described earlier aggressive sc pc implementations enforce read read program order speculatively executing explicitly detecting possible violations 
sc pc cases technique sufficient avoid subtle correctness issues induced value prediction 
solution reduce performance due false faces implementation issues described section 
alternatively aggressive strategy selectively enforce read read ordering dependent operations value prediction active processor reducing unnecessary 
leave detailed description proof correctness performance evaluation aggressive techniques 
models enforce data dependence 
class weak memory models includes alpha requires memory barrier order reads regardless dependent 
example alpha programmers want linked list example allow expected outcomes insert memory barriers shown 
just models enforce data dependence memory barrier inserted instruction 
second alpha requires memory barrier instructions alpha model enforce data dependence order 
second barrier surprising result valid alpha memory consistency model 
adding second barrier result disallowed 
advantage enforcing dependence order nave value prediction violate consistency model 
straightforward implementation allow value prediction memory barrier preventing subtle reorderings due value prediction 
side effect adopting memory model enforce dependence order programmer insert memory barrier explicitly enforce data dependence order 
requiring additional memory barriers increases frequency memory barriers possibly reducing performance adds extra burden programmer requiring barriers non intuitive locations section 
vp relaxed memory models value prediction complicate implementations relaxed memory models enforce read read ordering dependent operations 
examples relaxed models include sparc tso ia sparc rmo powerpc ia 
memory models enforce data dependence order alpha allow simple implementations value prediction long prediction memory barriers allowed 
violations occur real code 
correctness issues described valid regardless frequency errors may occur 
issues important 
alpha implementation leverages relaxation data dependence order produce undesired results memory barrier omitted 

correct code weak ordering data dependence code writer store mem data load reg mem head store mem reg memory barrier code reader memory barrier load reg mem head store mem head load reg mem reg occurred contrived code sequences real ones 
section quantify dynamic frequency code sequences similar relaxed consistency code illustrated simulating set multithreaded workloads processor powerpc system 
show error potential real workloads contain code sequences simple verification value prediction incorrect 
simulate user system level instructions workloads simos ppc full system simulator augmented detailed memory hierarchy modeling ibm rs server 
workloads chosen representative wide array applications running aix operating system 
tpc commerce benchmark ibm db database zeus web server 
raytrace parallel image rendering application splash benchmark suite 
spec benchmarks 
specjbb multithreaded transaction processing application written java 
specint rate uses multiple threads concurrently execute spec integer benchmarks 
specweb web serving benchmark zeus web server 
detect potential consistency model violations entry fifo queues processor loads stores 
store fifo associated processor tracks dynamic store memory barrier instances 
load fifo tracks dynamic load instances dependences dependent loads separated memory barriers 
execution load dependent load instruction window separated memory barrier ordering instruction scan store fifo processors 
scan search store instructions overlap memory locations read dependent loads store instructions separated memory barrier 
match potential consistency violation 
shown table potential consistency model violations occur applications 
occur infrequently occurrence indicates potential system failure acceptable 
examined code surrounding violations occur locking routines called operating system task dispatcher 
loads stores involved normal load store operations restricted load store conditional synchronization operations value prediction selectively disabled 
shown micro architects consider system correctness defined architecture memory consistency model implementing value prediction microprocessors systems thread level parallelism tlp 
value prediction induce violations read read dependence ordering violations cause incorrect executions multithreaded workloads 
issue exists commonly applied consistency models including sequential consistency processor consistency flavors weakly ordered models pertains commercial architectures 
class consistency models value prediction induce violations solutions sufficient eliminate consistency model violations due value prediction 
relaxed models including processor consistency weak ordering viable solution borrow mechanisms aggressive implementations sequential consistency detect violations read read program order 
solution potential drawbacks terms performance complexity 
alternate solutions may alleviate drawbacks evaluation relative performances scope 
acknowledgments individuals contributions findings bell ras bodik adam kourosh gharachorloo kevin kevin moore craig ed david wood 
supported part national science foundation ccr ccr eia cda university wisconsin graduate school donations compaq computer ibm intel sun microsystems 
milo martin supported ibm graduate fellowship 
daniel supported intel graduate fellowship 
table 
frequency consistency model violations caused value prediction application instructions executed millions possible violations tpc raytrace specjbb specint rate specweb adve gharachorloo 
shared memory consistency models tutorial 
ieee computer dec 
agarwal 
lim kranz kubiatowicz 
processor architecture multiprocessing 
proceedings th annual international symposium computer architecture pages may 
austin 
diva reliable substrate deep microarchitecture design 
proceedings nd annual ieee acm international symposium microarchitecture pages nov 
gharachorloo bugnion 
memory system characterization commercial workloads 
proceedings th annual international symposium computer architecture pages june 
gharachorloo mcnamara qadeer sano smith verghese 
piranha scalable architecture single chip multiprocessing 
proceedings th annual international symposium computer architecture pages june 

multithreaded powerpc processor commercial servers 
ibm journal research development nov 
cain lipasti 
architectural evaluation java tpc 
proceedings seventh ieee symposium high performance computer architecture pages jan 
chatterjee weaver austin 
efficient checker processor design 
proceedings rd annual ieee acm international symposium microarchitecture pages dec 
stone barton 
formal specification powerpc shared memory architecture 
ibm technical report rc jan 
culler singh 
parallel computer architecture hardware software approach 
morgan kaufmann publishers 

power focuses memory bandwidth 
microprocessor report oct 
digital equipment 
compiler writer guide alpha june 
eggers emer levy lo tullsen 
simultaneous multithreading platform generation processors 
ieee micro sept oct 
johnson liu 
evaluation multithreaded uniprocessors commercial application environments 
proceedings th annual international symposium computer architecture pages may 
uhlig mudge 
thread level parallelism interactive performance desktop applications 
proceedings ninth international conference architectural support programming languages operating systems pages nov 
gharachorloo 
personal communication july 
gharachorloo gupta hennessy 
techniques enhance performance memory consistency models 
proceedings international conference parallel processing volume pages aug 
ibm 
book enhanced powerpc architecture version july 
intel 
pentium pro family developer manual volume operating system writer manual jan 
intel 
intel ia architecture software developer manual volume ia system architecture revision july 
keller maynard simpson 
full system simulator 
www cs utexas edu users cart simos 
kessler 
alpha microprocessor 
ieee micro mar apr 
kumar 
hp pa risc cpu 
ieee micro mar apr 
lamport 
multiprocessor computer correctly executes multiprocess programs 
ieee transactions computers sept 
lipasti 
value locality store instructions 
proceedings th annual international symposium computer architecture pages june 
lipasti wilkerson shen 
value locality load value prediction 
proceedings seventh international conference architectural support programming languages operating systems pages oct 
lo eggers gharachorloo levy parekh 
analysis database workload performance simultaneous multithreaded processors 
proceedings th annual international symposium computer architecture pages june 
eggers levy 
analysis operating system behavior simultaneously multithreaded architecture 
proceedings ninth international conference architectural support programming languages operating systems pages nov 
singh 
weber gupta 
splash stanford parallel applications shared memory 
computer architecture news mar 
sites editor 
alpha architecture manual 
digital press 
systems performance evaluation cooperative 
spec benchmarks 
www spec org 
transaction processing performance council 
tpc benchmark web commerce standard specification revision feb 
weaver editors 
sparc architecture manual version 
ptr prentice hall 

mips superscalar microprocessor 
ieee micro apr 
