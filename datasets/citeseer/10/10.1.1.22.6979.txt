continuations parallel logic programming technical university dept computer science parallel distributed systems laboratory str 
romania 
cs ro national technical university athens dept electrical computer engineering software engineering laboratory greece 
ntua gr gives denotational models logic programming languages progressive complexity adopting logic programming logic approach 
rst language control ow kernel sequential prolog featuring sequential composition backtracking 
concurrent logic language parallel composition parallel don care nondeterminism studied 
third language core warren basic andorra model combining parallel composition don care nondeterminism forms don know nondeterminism interpreted sequential parallel favoring deterministic nondeterministic computation 
show continuations valuable tool analysis design semantic models sequential parallel logic programming 
mathematical notation functional programming language haskell metalanguage denotational semantics employ monads order facilitate transition language study 
keywords parallel logic programming basic andorra model denotational semantics continuations monads haskell 

theory practice sequential logic programming considered established having studied decades 
years researchers distinguished basic categories semantics logic programming declarative operational 
idea logic programming logic control number researchers convenient dedicate investigation declarative semantics logic programming study various control ow concepts encountered approach usually called logic programming logic advocated 
focusing control ow possible apply techniques theory programming language semantics develop operational denotational models sequential prolog parallel logic languages 
rst models parallel logic programming implemented family committed choice languages known representatives concurrent prolog parlog guarded horn clauses ghc 
committed choice languages support don care nondeterminism parallel composition goals 
descendants languages flat concurrent prolog flat ghc guards 
attempt combine sequential logic programming model prolog provides don know nondeterminism model committed choice languages basic andorra model bam proposed 
bam guards implemented owes prolog 
andorra provides don care don know nondeterminism 
execution don know choice expensive practice contains non failing alternatives phenomenon called nondeterministic promotion parallel goals replicated non failing alternative 
reason don know goals suspended andorra parallel goals reduced 
aim show continuations suited designing denotational semantic models control ow kernel sequential parallel logic programming 
de ne languages progressive complexity largely representing categories logic programming languages discussed previous paragraphs provide denotational semantics continuations 
approach follows principles logic programming logic 
de nition languages articulation basic computation steps represent elementary operations encountered logic programming uni cation substitution generation uninterpreted atomic actions 
logical connectives modelled appropriate operators processes 
mathematical notation de nition denotational semantics functional programming language haskell 
way allow denotational semantics directly implementable form interpreter languages study easily tested evaluated 
time avoid unnecessary complexities accompanying domain theory theory metric spaces adopted alternatively 
important drawbacks classic denotational semantics lack modularity small changes language de nition imply complete rewrite formal semantics 
monads proposed remedy quite popular denotational semantics functional programming community 
monads directly supported haskell order facilitate de nition modular elegant semantics languages study uni ed way 
brief description languages comments concerning techniques de ning semantics 
language pure sequential prolog backtracking don know nondeterminism 
named language consider appetizer parallel logic languages follow 
denotational semantics classic technique continuations advocated capturing semantics backtracking sequential prolog various papers 
mentioned numerous operational denotational semantics sequential prolog proposed approaches include extra logical features cuts side ects considered 
language choice concurrent logic language providing parallel composition don care nondeterminism guards 
basically equivalent core flat concurrent prolog flat ghc 
denotational semantics de ned classic direct approach concurrency semantics 
de nition continuation semantics concurrency csc technique introduced 
technique model sequential parallel composition interleaving semantics providing general advantages classic technique continuations 
language basic andorra model incorporates parallel composition don care nondeterminism prolog don know nondeterminism 
best knowledge denotational semantics andorra published attempts model behaviour model various combinations direct approach concurrency classic technique continuations failed 
consider denotational model propose section signi cant result 
csc technique capture semantics features parallelism prolog backtracking implemented sequential parallelism 
semantics models process suspension mechanism follows andorra principle deterministic computation priority nondeterministic computation 
detailed description basic andorra model section 
parallelism implemented true parallel composition operator interleaving semantics studied absence parallelism 
denotational models known implement parallelism context concurrent constraint logic programming don care nondeterminism trace corresponds logical solution program 
obviously approach longer appropriate language don know nondeterminism andorra 
rest structured follows 
sections de ne languages study denotational semantics continuations provide implementations semantics haskell 
sections discuss related concluding remarks directions research 

rst language study called intended simpli ed approximation sequential prolog 
features combines failure atomic actions recursion sequential composition sequential backtracking sequential 
simple grammar language 
call fail program sequence declarations followed statement 
declarations associate statements procedure variables elements syntactic class recursive 
statements consist elementary statements elements syntactic class recursive calls applications sequential composition backtracking operators 
elementary statements failure interpretation single atomic action element syntactic class backtracking operator takes possibly empty list operands element syntactic class operand statement guarded elementary statement model head uni cation 
syntax implemented haskell follows type act string type pvar string data stmt atomic rec pvar sand stmt stmt sor data atomic fail act act type atomic stmt necessary implement declarations programs directly 
declarations modelled haskell functions type type decl pvar stmt order simplify de nition semantics assume distinguished element type contains declarations program 
decl decl main semantic function maps statement computation element semantic class selection appropriate relatively easy goal selection general possible order simplify transition languages sections 
technique continuations reasonable assume computations functions mapping current continuation nal answer program 
semantic class unspeci ed represents continuations semantic class represents program answers 
sem stmt type study logic programming logic reasonable choice program answer sequence observations result program execution 
finding appropriate easy tendency generalization leads monads rationale 
performance atomic actions may observable program answer 
reasonable distinguish observations program answer atomic actions syntax 
relation best modelled monad map syntactic class act atomic actions semantic class obs observations 
type obs act mentioned sequences observations required program answers 
monad helps abstraction implementation details maps obs semantic class seq sequences observations 
type seq obs logic programs deterministic 
answer varies language certainly deterministic expect languages sections 
general program answers expected consist set elements seq nd reasonable hide implementation details monad possible program answers 
monad maps seq shown 
type seq reader referred appendix brief monads haskell 
apart hiding implementation details monads improves semantics terms modularity elegance transition languages sections 
semantics observations need di erentiated atomic actions 
deterministic program answers consist sequence 
monads substituted identity monad id de ned appendix 
haskell list monad perfect candidate monad 
study class continuations needs di erent class program answers continuation answer fragment program remains executed 
type id type type id type operations sequences observations easily implemented terms haskell operations lists 
empty sequence sequence pre xing operator sequence concatenation seqs de ned 
seq obs seq seq seqs seq seq seq seqs operations program answers de ned operations sequences properties monad 
empty answer contains empty sequence observations 
function implements pre xing observation program answer 
function takes argument list program answers pn returns new program answer sn sequences observations pn respectively concatenation sn sequence return obs return ps return seqs selection empty continuation simply empty program answer 
function cont implements continuation completion 
maps continuation program answer result continuation left execute 
semantics cont identity function true languages studied sections 
cont cont id failure computation ignores current continuation returns empty program answer 
function implements backtracking sequential operator takes list computations passes current continuation concatenates results 
function takes computation continuation returns extended continuation performs implementation simply applies resulting sequential execution rst map de nition auxiliary operations sequences program answers continuations computations de nition semantics straightforward 
meaning fail failure computation meaning atomic action pre xing associated observation completion current continuation 
recursive calls easily handled sequential composition operator extends current continuation computation second statement passes result computation rst statement 
meaning backtracking operator nl read nl read fail nl read example semantics 
implemented function candidates execution statements non failing guards 
sem fail sem act return cont sem rec sem decl sem sand sem sem sem sor ls return cont sem act meaning complete program simply meaning statement applied empty continuation 
stmt sem semantics example programs shown 
rst examples illustrate sequential composition fail statement 
example illustrates backtracking mechanism 

concurrent logic programming concurrent logic programming sequential composition backtracking give way parallel composition parallel general don care nondeterministic choice 
second language study called intended core concurrent logic programming language combines basic features failure atomic actions recursion 
features sequential composition backtracking removed 
possibility retaining discussed section 
grammar rule statements replaced call addition features nondeterministic choice guarded statements additional haskell code supports parsing programs 
appendix contains information obtain complete code 
interleaved parallel execution point notice semantic di erence symbol rule syntactic class previous section symbol rule syntactic class de nition 
symbol viewed simple sequential composition operator pre xing guard statement 
guard succeeds statement executed alternatives may follow 
way provides don know nondeterminism 
hand symbol viewed commit operator provides don care nondeterminism 
guard succeeds statement executed alternative follow 
implementation syntax requires modi cation haskell code 
type implementing syntactic class data stmt atomic rec pvar ned pand stmt stmt nondeterministic features compel rede nition monad support multiple program answers 
haskell list monad reasonable choice intention haskell lists model sets necessary implement set union operation removing multiply occurring elements 
function returns union program answers returns union list program answers 
notice empty program answer returned list empty 
type ys ys xs ys elem ys xs ys xs ys foldl presence interleaved execution forced reconsider notion continuation 
csc technique de ne continuations multisets computations executed parallel implement multisets haskell lists 
empty continuation empty list computations adds computation continuation 
newtype completion function cont returns union possible interleaved executions computations included continuation 
operator combines alternative program answers time synonym 
presence necessary computation model biased speci program answers justi ed section 
cont cont cont cont cont cont cont cont implementation nondeterministic choice operator simply union program answers alternatives applied current continuation 
similarly implementation parallel composition possibly biased combination alternative computations starting rst statement starting second 
semantics constructs de nitions auxiliary functions 
sem ned ls return cont sem act sem pand sem sem sem sem map number example programs shown corresponding semantics 
rst examples illustrate semantics parallel composition atomic actions executed order third example illustrates semantics nondeterministic choice 
example combination features 

basic andorra model third language study called core warren basic andorra model 
language contains features studied previous sections exception sequential composition sequential nl read nl read nl read nl read example semantics 
plus additional don know nondeterministic operator implemented parallel 
grammar rule statements call haskell implementation syntax 
data stmt atomic rec pvar sor ned pand stmt stmt por basic characteristic language andorra principle gives priority deterministic computation nondeterministic computation 
rationale principle nondeterministic reduction steps nondeterministic promotion multiply 
principle logic programming language equipped parallel reduce number steps required execution program compared sequential version language 
andorra principle execution favors determinate goals nondeterminate ones parallel conjunctions 
elementary goals don care goals determinate reduced 
hand don know goals reduced determinate alternatives non failing guard 
reduction nondeterminate goals delayed possible 
nondeterminate goals remain reduced alternatives don know goal tried order sequential concurrently parallel 
behaviour semantic model needs distinguish determinate nondeterminate reduction steps 
achieved modifying notion observation 
case determinate reduction step observation single atomic action semantics previous sections 
case nondeterminate reduction step don know goal alternatives reduced observation multiset containing atomic actions guarding alternatives nondeterminate goal 
need modify de nition monad haskell lists implement multisets 
type order model semantics biased execution behaviour need modify de nition function 
new version function distinguishes determinate nondeterminate goals 
program answers combined contains determinate goal contains sequence starting simple observation combined answer contains determinate goals nondeterminate goals combined 
det det det det det det det det case det det implementation backtracking operator requires small modi cation original de nition section 
reason set union operation needs applied resulting program answer order eliminate multiple answers 
ps return seqs semantics parallel construct requires number additional operations semantics 
function pars takes sequences observations generates program answer contains possible interleaved executions sequences 
functions extend operation lists program answers lists computations respectively 
pars seq seq worthwhile noticing semantics decide determinacy goals syntax program answers 
laziness haskell prevents implementation semantics computing program answer deciding goals determinate leads improved performance 
pars pars seq seq pars pars pars pars pars ps return pars map complete semantics need address don know nondeterministic operators language 
cases alternative non failing guard corresponding statement added current continuation 
list computations formed way passed appropriate function prepended observation contains non failing guards 
sem sor ls sor act sor sor map fst map snd sor cont sem act sem por ls por act por por map fst map snd por cont sem act examples implementation semantics 
rst examples contained 
exception rst fourth example contain nondeterminate sequential goals obtained results obtained previous gures 
rst fourth example results similar non failing guards sequential goals combined observation 
examples illustrate biased execution behaviour determinate goals 
rst reduction nondeterminate sequential goal delayed presence executed order nondeterminate goal reduced 
notice example produce di erent program answers andorra principle followed 
answers correspond answers obtained rest result nondeterministic promotion follow reduction sequential goal 
example similar nondeterminate goal parallel 
example complex goals executed parallel 
interleaved execution determinate goals state reached goals remain nondeterminate ones 
state arbitrary nondeterminate goal selected execution proceed nondeterministic promotion making copies goal alternative selected 
example rst trace shown obtained nondeterminate goal selected nondeterministic promotion 
performing nondeterministic promotion step produces observable execution proceeds computations rst produces sequence observables backtracking produces 

related classic technique continuations advocated capturing semantics backtracking sequential prolog various papers 
list monad describing semantics prolog clause unfolding advantages adopting monads higher order logic programming framework prolog investigated 
continuation approach semantics parallelism logic programming new 
papers known including follow classic direct approach concurrency semantic designer de nes various operators parallel composition processes functions manipulate nal semantic values 
csc technique provides di erent way computing interleaved execution parallel processes manipulating continuations 
approaches di erent experiments show behave case language provides parallel composition parallelism don care nondeterminism 
best knowledge denotational semantics languages andorra model published attempts model behaviour various combinations direct approach concurrency classic technique continuations failed 
con rms belief expressed csc technique provide exibility classic direct approach concurrency handling complex operations processes 
operational semantics languages similar combining reactive behaviour related parallelism logic programming search backtracking parallelism 
papers formalize implementations extended andorra model extension basic andorra model deep guards 
rst gives operational semantics andorra kernel language akl second presents calculus operational nature intended semantic foundation oz 
nl read nl read nl read nl read nl read nl read nl read nl read nl read example semantics 
worth mentioning authors propose axiomatization semantics logic languages similar focusing control ow concepts 
functional library primitive operators equational machinery functional languages authors nd primitive scheduling operators logic programming obey laws categorical theory monads 
authors identify monads corresponding depth rst scheduling strategy breadth rst strategy allows strategies 
semantics propose denotational nature implemented haskell 
language features basic control ow operators conjunction disjunction interpreted sequentially parallel depending scheduling strategy 
approach di ers ways 
sequential parallel forms control ow operators distinct language simultaneously 
second approach models andorra principle 

concluding remarks research shown continuations tool systematic speci cation design sequential parallel logic programming languages 
studied languages progressive semantic complexity uni ed way shown careful selection monads enhance modularity elegance semantics facilitate additional features additional execution principles 
furthermore implemented semantics haskell providing directly executable prototype languages study 
minor modi cations haskell implementation serve basis prototype interpreter randomly choose alternative execution paths 
main contribution accurate denotational semantics basic andorra model csc technique 
best knowledge denotational semantics andorra previously published 
basic andorra model incorporated various logic constraint languages believe parallel distributed languages combine reactive behaviour search mechanisms design 
combinations concepts shown csc technique adequate speci cation tool 
little previous experience exists building concurrent languages systematically denotational description 
haskell implementation andorra csc technique important step direction 
possible include backtracking operator sequential form don know nondeterministic operator modifying de nition section 
add semantic complexity 
retaining sequential composition sequential complicate bit semantics languages 
reader referred semantics sequential composition de ned concurrent language partial ordering relations continuations 
convenient follow logic programming logic approach advocated focus control ow kernel parallel logic programming 
accordingly abstracted articulation basic computation steps ignored concepts uni cation substitution generation dicult add concepts semantic models obtain full denotational descriptions parallel logic languages 
explained general achieved interpreting elementary actions computational steps relevant logic language consideration leaving available control ow kernel intact 
semantic framework exible allowing re nements 
mainly interested application csc technique speci cation design concurrent constraint logic programming languages 
shown csc technique express asynchronous communication mechanism encountered concurrent constraint logic programming see simple elegant way augmenting semantic function additional parameter model constraint store shared processes continuation 
know obtain full descriptions concurrent constraint logic languages adding asynchronous communication mechanism semantic models 
subject trivial defer treatment forthcoming 
considered languages guards 
aims apply csc technique parallel logic programming languages deep guards 
doing intend move basic andorra model extended andorra model implemented languages incorporate constraint programming paradigm akl oz 
research directed tighter combination continuations monads order improve exibility elegance modularity semantic descriptions 
previous results concerning interleaved semantics expression evaluation unspeci ed evaluation order believe possible de ne monads csc technique underlying execution behaviour 

anonymous referees useful comments rst version 

apt 
logic programming 
van leeuwen editor handbook theoretical computer science volume pages 
elsevier science publishers 

nondeterministic parallel logic programming 
world scienti 

monadic constructs logic programming 
lloyd editor proceedings pages portland dec 
mit press 
costa warren yang 
andorra parallel prolog system transparently exploits parallelism 
proceedings rd acm sigplan symposium principles practice parallel programming 
acm press 
de bakker 
comparative semantics ow control logic programming logic 
information computation 
de bakker de 
control ow semantics 
foundations computing series 
mit press cambridge ma 
de bakker kok 
comparative metric semantics concurrent prolog 
theoretical computer science 
de boer kok palamidessi rutten 
paradigm asynchronous communication application concurrent constraint programming 
apt de bakker rutten editors logic programming languages constraints functions objects pages 
mit press 
de boer palamidessi 
nondeterminism nite computations constraint programming 
theoretical computer science 
de bruin 
experiments continuation semantics jumps backtracking dynamic networks 
phd thesis vrije universiteit amsterdam 
de bruin de 
continuation semantics prolog cut 
proceedings tapsoft volume lncs pages 
springer verlag 
de 
comparative semantics prolog cut 
science computer programming 
gregory 
parallel logic programming parlog 
addison wesley 
haridi janson 
andorra prolog computation model 
proceedings international conference logic programming iclp 
mit press 
haridi palamidessi 
structural operational semantics kernel andorra prolog 
proceedings conference parallel architectures languages europe parle 
springer verlag 
kowalski 
algorithm logic control 
communications acm 
lloyd 
foundations logic programming 
springer verlag nd edition 
mazurkiewicz 
proving algorithms tail functions 
information control 
taylor shapiro levy safra 
design implementation concurrent prolog 
technical report cs institute department applied mathematics israel 
moggi 
view programming languages 
technical report ecs lfcs university edinburgh laboratory foundations computer science 
ma study evaluation order semantics expressions side ects 
journal functional programming 
appear 
peyton jones 
editors 
report programming language haskell non strict purely functional language 
available haskell org 

parlog logicians 
communications acm 
spivey 
algebra logic programming 
proceedings international conference logic programming iclp 
shapiro 
subset concurrent prolog interpreter 
technical report tr icot tokyo 
shapiro 
family concurrent logic programming languages 
acm computer surveys 
smolka 
calculus higher order concurrent constraint programming deep guards 
research report rr deutsches forschungszentrum ur kunstliche intelligenz dfki saarbrucken germany 
smolka 
oz programming model 
computer science today volume lncs pages 
springer verlag 
strachey wadsworth 
continuations mathematical semantics handling full jumps 
technical monograph prg oxford university programming research group 

metric semantics synchronous communication continuations approach 
electronic notes theoretical computer science 
den de 
comparative metric semantics commit parallel logic programming 
proceedings international logic programming symposium pages 
mit press 
ueda 
guarded horn clauses parallel logic programming language concept guard 
nivat editors proceedings programming generation computers pages 
north holland 
wadler 
essence functional programming 
proceedings th annual symposium principles programming languages popl jan 
warren 
andorra principle 
talk workshop swedish institute computer science sics stockholm sweden 
warren 
extended andorra model implicit control 
talk parallel logic programming workshop israel 
yang 
prolog parallel logic programming language 
world scienti 
appendix complete code due space restrictions haskell code implement pretty printing parsing programs 
apart self contained 
complete code obtained ftp ftp ntua gr pub users papers ppdp code tar gz 
monads haskell rest appendix contains brief monads haskell 
detailed introductions theory practice monads 
know haskell including papers monads haskell home page haskell org 
monad triple form return rst element type constructor kind mapping arbitrary type new type code contains de nition standard haskell class monad previous description 
types polymorphic functions return speci ed line de nes left associative operator low precedence 
class monad return infixl types constructed monad considered denoting computations type denotes computations returning values type de nition monad re ects notion computation 
result return trivial computation simply returning value assuming mb result combined computation returning followed computation return seen way inserting values computations seen way extracting values computations order subsequent computations 
monad laws monad required satisfy insure soundness correspondance monads computations law return law return law identity monad id implemented follows 
trivial check satis es monad laws 
newtype id id instance monad id return id id 
