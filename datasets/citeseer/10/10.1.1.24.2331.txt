istituto la ricerca scientifica tecnologica trento gamma loc 
pant di povo gamma tel 
gamma gamma telefax gamma multi context systems specification framework complex reasoning systems giunchiglia traverso giunchiglia june technical report published treur eds formal specification methods complex reasoning systems ellis horwood 
istituto di cultura multi context systems specification framework complex reasoning systems enrico giunchiglia paolo traverso fausto giunchiglia mechanized reasoning group dist university genoa opera pia genoa italy irst povo trento italy email enrico dist unige irst motivations specification complex reasoning system take account components interactions 
propose multi context systems mc systems logical framework formal specification complex reasoning 
mc systems motivated formally introduced called multilanguage systems ml systems emphasize fact allow definition multiple languages language associated context 
general idea model local reasoning deduction inside context 
context formally defined axiomatic formal system triple consisting language set axioms set inference rules 
interaction contexts formalized bridge rules rules premises belong different contexts 
notion deduction mc system modeling reasoning system defined composition bridge rules contextual deductions 
claim mc systems appropriate tool specification complex reasoning 
basic motivation complex reasoning highly modular 
mc systems allow structure specifications reasoning possibly structure system terms local reasoning sub patterns conducted part integrated ai project development irst done partial support italian national progetto sistemi special project information systems parallel computing progetto special project robotics 
performed context 
shown mc systems capture forms reasoning 
reasoning abstraction meta reasoning reasoning propositional attitudes non monotonic reasoning reasoning temporal evolution physical systems examples 
propose variation framework proposed developed define mc system ms model dynamic aspects reasoning process instance dynamic assumptions design task 
ms distinguished context called psc problem solving context models reasoning agent 
reasoning psc essentially metatheoretic 
remaining contexts objects reasoning going psc model situations reasoning agent believes possible 
reasoning situation agent dynamically assumptions expressing beliefs 
new assumption associated new situation 
different sets dynamic assumptions define different situations 
inconsistent beliefs correspond distinct situations asserted distinct contexts 
approach allows keep reasoning monotonic inside context 
non monotonic reasoning patterns simulated switching contexts 
describe discuss formal multi contextual framework sections particular section gives general formal definition mc systems 
section describe multi context system ms section describes framework specialized solve workshop example reasoning task 
example reasoning traces reported 
second part section show getfol interactive system multi contexts formal specifications 
mechanization getfol multi context system ms reasoning process solving example task contained appendix 
section 
mc systems mc system knowledge reasoning structured set contexts 
context contains partial knowledge base specification written language context 
local contextual reasoning represented inference mechanism specification describes reasoning facts knowledge base context 
different contexts may different languages specifications knowledge bases inference mechanisms 
define generic context belonging set contexts cn axiomatic formal system language logical language knowledge base specification set axioms inference mechanism set logical inference rules language 
definition context language omega set axioms delta set inference rules 
context triple hl omega delta language axioms inference rules chosen depending problem reasoning specified context 
definition restricted particular kind logic logical language instance propositional order higher order logic non monotonic logic 
restrict order theories associated sorted language 
turns gives expressibility represent forms reasoning considered far non monotonic reasoning 
definition mc system capture idea reasoning patterns specified terms interactions local reasoning patterns 
interactions specified inference rules enabling assertion fact context facts inferred contexts 
fc hl omega delta ig family contexts 
ha mean formula written language call wff 
write bridge rules suitable modification natural deduction formalism defined ha 
han hb han 
hb jm han ha ffi consistently notation ffi represents rule discharging assumptions hb 
jm simplify notation relevant write ha instance inside context hl omega deltai write modus ponens ha ci ha ci hb ci mc system defined pair consisting family contexts set bridge rules 
definition multi context system mc system set indices fc hl omega delta ig family contexts 
multi context formal system mc system mc pair delta mc delta mc set bridge rules 
note may case happen set formulas proved different bridge rules vice versa 
mc deductions obtained composing bridge rules local deductions distinct contexts obtained repeated applications delta rules 
defined generalization usual notion deduction formula set assumptions see instance 
trees wffs formula trees built starting finite number assumptions axioms possibly belonging distinct contexts applying finite number inference rules 
formula written language context fc say derivable set wffs possibly belonging distinct languages gamma mc system mc gamma mc hw ci deduction gamma 
theorem mc mc hw ci derivable empty set depend assumption 
mc deduction empty set mc proof instance consider mc system mc contains contexts suppose language inference rule modus ponens natural deduction axioms foeg foe respectively 
bridge rules delta mc fffi hff hff jg ff example mc proof oe ffi oe oe ffi ffi proof oe axiom bridge rule ffi derives oe modus ponens delta applied oe oe proved 
rest proof described similar way 
notice surround deductions context boxes labeled name context 
notation meant emphasize locality reasoning patterns interactions 
mc system ms aim section describe mc system ms able model dynamic aspects reasoning process 
start defining metatheoretic problem solving context psc containing principles problem solving 
fundamental psc principle believe fact holds situation possible situation holds 
context called situation context context associated possible situation 
suppose context associated result believing step take new context corresponding situation step ii assert step iii determine facts holding hold particular case test reasoning examples facts holding supposed hold design object evaluation want consider situation assumption assumptions earlier considered true 
mutually contradictory beliefs situation believe situation consistent cause contradiction asserted different contexts 
proposed representation discussed advantage allowing modular specification known gives computational savings 
properties referring particular situation checked directly inside associated context greatly reducing search space 
minor issue search space reduced situation elementarily described inside context 
context argument sort situation time needed order associate facts particular situation 
context directly associated situation 
relation situations contexts temporal relation expressing situation immediately situation kept metatheoretic context psc 
summarizing family contexts part mc system ms ffl particular metatheoretic problem solving context psc decides deductions performed contexts 
controls reasoning contexts ffl infinitely contexts associated particular situation 
ms bridge rules psc represent correct metatheory provability various contexts correctly describe facts inferred context 
constants language psc denoting context formula respectively 
th formula psc intuitive meaning provable language psc defined section 
require th provable psc ms hth formula provable context ms hw 
similarly want psc complete metatheory provability psc able describe facts proved context 
means fact provable ms hw theoremhood th provable psc ms ht 
requirements achieved bridge rules called reflection reflection hth hw hw hth restriction applicable discharged assumption hw depends wff 
formula psc constants denoting respectively 
notice restriction applicable iff hw depend wff 
th means provability case assumption depends assumptions context derive th psc 
applicable fact depends set assumptions 
allows infer facts context result assumptions generated metatheoretic context psc 
notice context inconsistent 
consider instance deduction th psc th psc intuitively corresponds case reasoning agent believes situation modeled impossible case simply believes inconsistent facts situation 
defining problem solving context psc define psc define language set axioms inference rules 
take granted usual rules constructing terms wffs order language 
constants variables constants language psc determined objects psc reasons 
psc reasons problem solving activity performed context 
psc language contain names elements language contexts contexts 
formula language psc individual constant quotation mark name denoted formula 
psc constant context intuitively allows psc distinguish contexts reason local reasoning performed particular context 
psc variables ranging objects context reasons 
achieved having variables sort part language psc 
ms fw fc defined variables sort wff context respectively 
predicates psc predicates th arity cbb arity arity 
intended meanings follows ffl th expresses fact provable ffl cbb express beliefs reasoning phenomena intuitively cbb holds believed formula believed context want extend theory considering situation holds 
perspective cbb resemblance predicate pa meaning possible assumption defined 
ffl expresses fact situation described nonmonotonic extension situation described allows keep track problem solving activity context context transition 
inference rules axioms fundamental principle informally stated section formally defined psc axiom psc wc cbb th mkcxt mkcxt place function wff context returning context meant context holds 
mkcxt satisfy basic properties 
instance want avoid mkcxt mkcxt mkcxt different sets assumptions associated different situations 
want avoid mkcxt mkcxt sets assumptions associated contexts different 
requirements formally stated psc axioms psc wc mkcxt psc mkcxt mkcxt stands 
furthermore hold reasoning switched result non monotonically extending stated axiom psc wc mkcxt supposing assume axiom psc forall elimination modus ponens derive hth mkcxt supposing mkcxt deduce hw corresponding steps ii section 
describe axiomatization corresponding step iii 
suppose reasoning switched determine cbb originally introduced ary predicate third argument problem solved 
relevant drop argument 
facts holding hold considering example reasoning task basic activity design object evaluation performed instantiate situation facts hold obtained psc axiom 
psc wc 
th th notice inconsistent context hc holds inconsistent 
captures intuition assumption inconsistent situation build new situation inconsistent 
case contradictory belief assumed assume ci holds new context generated asserted inconsistency detected cbb proved 
note psc contradictory assumed 
captured psc axiom psc wc cbb 
mkcxt th cbb shorten trace proof solves example reasoning task section bridge rules hw hc hw rule restriction rule applicable discharged assumption hw depends wff 
cbb restriction applicable discharged assumption depends wff 
notice bridge rules rule conceptually equivalent axioms psc psc respectively 
example reasoning task specify description example reasoning task 
description specified set axioms provides set axioms context 
suppose language context consists 
individual constants sort activity sort period 

individual variables sort period sort activity 

place predicative letters intuitively means activity scheduled period needed establish temporal order time periods requirements test example expressed follows 
ax ax ax ax ax ax state activity scheduled ax activity scheduled axioms ax ax respectively occur time period ax order time periods ax ax 
suppose psc context set natural deduction rules defined available 
reasoning traces test example section show multi contextual proof ms produce expected result 
order easier follow proof divide sub proofs 
suppose arbitrary choice possible generated assumptions initially select cbb 
want show design object evaluation inconsistency detected causes design process evaluation assertion cbb psc 
deduction proceeds follows 
result assumption cbb new context considered asserted 
occur earliest period scheduled inconsistency detected cbb proved psc 
trace proof trace deductions bn fax 
means exists finite number application inference rules context consideration derivable bn axioms fax 

cbb mkcxt th psc fax fax ax fax cbb psc note step fax ax requires separate derivation respectively failure satisfying opposite collection results resulting conjunction 
considering proof note analogous cbb reached substituting previous deduction 
vice versa assuming cbb new context considered asserted causing contradiction cbb mkcxt th psc considering state described context assumption generation selection iterated assuming cbb 
result new context considered asserted 
cbb mkcxt th psc fact holds obtained result deduction psc rule hc derived axiom psc forall elimination substitution equals 
conclude rules context fax fax fax notice traced deductions considered show desired results deduced 
example deliberately ignored fact derivable context starting axioms fax 
ax rules context 
shown knowledge th lead knowledge th holds 
capability necessary solve second example reasoning task reported 
formal specifications getfol mc systems implemented inside getfol 
getfol usually interactive reasoning system theorem prover 
section give hints getfol computer system supporting formal specifications reasoning systems 
want point getfol deductions performed interactively user specifies step step rules applied axioms 
getfol complex decision procedures lessen user 
appendix getfol proof reported 
getfol commands allow user define arbitrary mc systems 
possible create copy name change context 
commands allow user generate new contexts interactively copy axioms contexts required steps iii section 
instance contexts psc context created commands getfol psc commands typed getfol prompt getfol 
lines start getfol system output 
text taken directly system input output 
replaced irrelevant parts dots 
named current context psc getfol created empty context getfol context getfol copied current context context contexts created getfol psc context psc 
context define language set axioms specifying partial knowledge base 
instance define language context 
getfol context 
getfol declare declared getfol declare indconst activity activity declared sort declared indconst declared indconst declared indconst declared indconst getfol declare indconst period 
declared individual constants sort activity 
declared individual constants sort period 
switch psc define language 
getfol psc context psc 
getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst context 
ina declared psc individual constant sort wff 
individual constant declared denote expression interpreted formula applying bridge rules 
getfol hardware ina appl mak ina attached appl mak getfol attach attached command hardware asserts constant ina psc language denotes expression appl mak evaluates 
command attach asserts constant denotes expression 
constants variables psc language declared follows getfol declare indconst context 
getfol declare context 
declare predicates psc language arity getfol declare th th declared getfol declare cbb cbb declared getfol declare declared getfol commands create assumptions axioms apply inference rules 
instance assumptions created command assume getfol assume th ina th ina user performs assumption getfol builds fact 
fact consists label identifies wff set labels denoting wffs depends 
example fact corresponding previous assumption label set dependencies assumption depends 
getfol commands apply bridge rules 
instance commands rup implement respectively 
getfol get changed context get changed context psc ok 
am finished reflecting 
wff fact labeled psc psc th ina premise rule 
wff fact labeled rule application 
asserted fact context 
notice dependencies depends facts asserted psc 
dependencies taken account reflecting results obtained 
fact suppose prove false basing having proved th ina psc case example getfol 
getfol 
false getfol psc 
reflect fact psc get back dependencies hth ina getfol rup th false get changed context get changed context psc th false ok 
am finished reflecting 
comparison works proposed multicontext systems tool formal specification complex reasoning systems 
similarly approaches proposed local reasoning patterns specified deduction logical framework 
mc systems interactions contexts formalized inference rules part logical framework 
global behavior system formalized deduction time spanning multiple contexts 
approaches interactions specified kind admissible rules 
effect rules intuitively clear notion global deduction formalizing global behavior 
strong similarity various approaches distinction object level modules specification domain layer meta level module guide inference 
difference kind logic object level components 
fact desire provides sorted partial predicate logic karl order horn clauses plus types classes model terminological knowledge data types propositional horn clauses ml mc systems sorted full order logic 
full order logic provides expressiveness horn clauses propositional logic provide may simpler allow faster inference engine information retrieval 
logical frameworks approaches proposed differ mainly aspects procedural declarative reasoning control automated interactive reasoning 
ml uses simple imperative language founded dynamic logic 
desire ii declarative language effect procedural downward reflection 
kbs sf karl control specified procedural language 
way similar control language described kbs sf karl control easily performed getfol lisp programming language implement getfol called 
underlying idea getfol provide framework reasoning performed interactively 
framework proposed reasoning steps decided user specified hand system 
provides certain amount flexibility course force user perform detailed tedious proofs step step 
getfol provides set powerful decision procedures subclasses order logic 
provide efficient tools local reasoning 
analogously ml planning build third level psc specify control strategies expressions theory see section 
shown mc systems appropriate tool describing formal specifications reasoning systems 
motivated claim showing mc systems allow ffl specify different reasoning systems ffl formalize interactions 
ms example mc system capable handling dynamic aspects typical reasoning process 
ms contains metatheoretic problem solving context psc denumerably contexts different sets contemporary believed facts asserted 
structure ms resembles level architecture described meta reasoning module contains principles non monotonically extending object reasoning module 
conceptual difference approach different object level reasoning modules contexts 
framework switch particular context perform local deduction import result problem solving context psc depending new assumptions switch different object reasoning module context different sets facts inferred 
shown getfol system computer tool formalization reasoning systems 
getfol reasoning process interactively guided user responsible specify appropriate commands 
studying build third level la ml psc responsible automatically guide deduction psc 
differently ml task layer formalized quantified dynamic logic planning order theory explicit information state computation notion central accessed evaluation psc context 
logic specify control better solution 
fact authors quite complex completely natural 
metatheory described provides way define control strategies expressions order logical language metatheory 
metatheory provides capability represent logical analogous tactics tactics programs specify object logic inference rules composed build proofs 
furthermore metatheory expressive represent programs specify complex compositions inference rules instance mechanisms detect object level rule application fails conditionals iterations recursive definitions 
plan apply approach provide interactive framework user write heuristics logical metatheory getfol proof assistant derive new control strategies 
amounts say define distinct context say mt metatheory psc context 
appendix shows getfol mechanized proof example reasoning task 
allen general theory action time 
artificial intelligence july 
armando giunchiglia embedding complex decision procedures inside interactive theorem prover 
second international symposium artificial intelligence mathematics fort lauderdale florida 
appear annals artificial intelligence mathematics 
harmelen van kads ml model scheduling task 
treur th 
editors formal specification complex reasoning systems ellis horwood volume 
giunchiglia una della dei 
master thesis dist university genoa 
giunchiglia logical treatment qualitative reasoning 
technical report dist university genova genoa italy 
short version appeared proceedings european workshop qualitative reasoning physical systems genoa italy january 
giunchiglia multilanguage systems 
proceedings aaai spring symposium logical formalizations commonsense reasoning 
report 
giunchiglia contextual reasoning 
appear 
giunchiglia getfol manual getfol version 
technical report dist university genova genoa italy 
irst manual forthcoming irst trento italy 
giunchiglia serafini hierarchical meta logics beliefs provability modal logics 
proc 
canadian conference artificial intelligence ai vancouver canada 
irst technical report irst trento italy 
long version appear artificial intelligence 
giunchiglia traverso reflective reasoning declarative metatheory implementation code 
proc 
th international joint conference artificial intelligence ijcai pages sydney 
irst technical report irst trento italy 
giunchiglia walsh theory abstraction 
artificial intelligence 
irst technical report irst trento italy 
giunchiglia weyhrauch multi context monotonic axiomatization inessential non monotonicity 
nardi maes editors meta level architectures reflection pages 
north holland 
technical report dist university genova genoa italy 
kassel aide succeeds example design task 
treur th 
editors formal specification complex reasoning systems ellis horwood volume 
fensel angele formalizing operationalizing design task karl 
treur th 
editors formal specification complex reasoning systems ellis horwood volume 
van treur compositional architecture simple design formally specified desire 
treur th 
editors formal specification complex reasoning systems ellis horwood volume 
van treur example reasoning task description 
treur th 
editors formal specification complex reasoning systems ellis horwood volume 
mccarthy hayes philosophical problems standpoint artificial intelligence 
meltzer michie editors machine intelligence pages 
university press 
prawitz natural deduction proof theoretical study 
almquist wiksell stockholm 
sierra godo specifying simple scheduling task reflective modular architecture 
treur th 
editors formal specification complex reasoning systems ellis horwood volume 
tan treur bi modular approach nonmonotonic reasoning 
proc 
world conference fundamentals artificial intelligence pages 
jonker specification complex reasoning tasks kbs sf 
treur th 
editors formal specification complex reasoning systems ellis horwood volume 
getfol deduction getfol psc named current context psc getfol comment getfol comment setting contexts getfol comment getfol created empty context getfol context switching proof name 
getfol declare indconst period period declared sort declared indconst declared indconst declared indconst getfol declare period period sort declared declared declared getfol declare indconst activity activity declared sort declared indconst declared indconst declared indconst declared indconst getfol declare activity activity sort declared getfol declare inf declared getfol declare declared getfol axiom ax forall 
ax forall 
getfol axiom ax forall 
imp ax forall 
imp getfol axiom ax forall 
imp ax forall 
imp getfol axiom ax forall 
imp ax forall 
imp getfol axiom ax ax getfol axiom ax forall 
iff ax forall 
iff getfol copied current context context getfol copied current context context getfol copied current context context getfol comment getfol comment setting psc getfol comment getfol psc context psc switching proof name 
getfol declare cbb th cbb declared declared th declared getfol declare wff wff declared sort declared declared declared getfol declare context context declared sort declared declared declared getfol declare indconst context context sort declared indconst getfol declare indconst context context sort declared indconst getfol declare indconst context context sort declared indconst getfol declare indconst context context sort declared indconst getfol attach attached getfol attach attached getfol attach attached getfol attach attached getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst ina wff wff sort ina declared indconst getfol declare indconst false wff wff sort false declared indconst getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol hardware ina appl mak ina attached appl mak getfol attach false false false attached false getfol declare mkcxt mkcxt declared getfol axiom psc forall 
cbb imp th mkcxt psc forall 
cbb imp th mkcxt getfol axiom psc forall 
mkcxt psc forall 
mkcxt getfol axiom psc forall 
imp mkcxt mkcxt psc forall 
imp mkcxt mkcxt getfol axiom psc forall mkcxt psc forall mkcxt getfol axiom psc forall 
cbb imp mkcxt th false imp cbb psc forall 
cbb imp mkcxt th false imp cbb getfol axiom psc forall 
imp th imp th psc forall 
imp th imp th getfol comment getfol comment proving cbb ina getfol comment getfol alle psc ina cbb ina imp th ina mkcxt ina getfol assume cbb ina cbb ina getfol impe th ina mkcxt ina getfol axiom mkcxt ina mkcxt ina getfol th ina th ina getfol get changed context get changed context psc ok 
am finished reflecting 
getfol context switching proof name 
getfol alle ax imp getfol ax getfol taut getfol alle ax imp getfol ax ax getfol taut getfol alle ax imp getfol ax ax getfol taut getfol alle ax getfol taut false false getfol psc context psc switching proof name 
getfol rup th false get changed context get changed context psc th false ok 
am finished reflecting 
getfol alle psc ina cbb ina imp mkcxt ina th false imp cbb ina getfol cbb ina cbb ina getfol impi cbb ina imp cbb ina getfol taut cbb ina cbb ina getfol comment getfol comment asserting getfol comment getfol alle psc ina cbb ina imp th ina mkcxt ina getfol assume cbb ina cbb ina getfol impe th ina mkcxt ina getfol axiom mkcxt ina mkcxt ina getfol th ina th ina getfol get changed context get changed context psc ok 
am finished reflecting 
getfol comment getfol comment asserting getfol comment getfol alle psc ina cbb ina imp th ina mkcxt ina getfol assume cbb ina cbb ina getfol impe th ina mkcxt ina getfol axiom mkcxt ina mkcxt ina getfol th ina th ina getfol get changed context get changed context psc ok 
am finished reflecting 
getfol comment getfol comment deducing getfol comment getfol alle psc ina mkcxt ina getfol getfol alle psc ina imp th ina imp th ina getfol th ina th ina getfol get changed context get changed context psc ok 
am finished reflecting 
getfol comment getfol comment proving getfol comment getfol context switching proof name 
getfol alle ax imp getfol getfol alle ax imp getfol ax getfol getfol alle ax getfol getfol andi getfol andi getfol psc context psc switching proof name 
getfol comment getfol comment getting back dependencies deduction getfol comment getfol wff wff list wff wff getfol declare declared getfol attach attached getfol rup th ina ina ina get changed context get changed context psc th ina ina ina ok 
am finished reflecting 
