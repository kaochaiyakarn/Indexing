constant space reasoning dynamic bayesian networks adnan darwiche computer science department university california los angeles ca darwiche cs ucla edu november dynamic bayesian networks dbns receiving increased attention tool modeling complex stochastic processes especially generalize popular hidden markov models hmms kalman lters 
dbns subclass standard bayesian networks structure algorithms developed bayesian networks immediately applied reasoning dbns 
structure algorithms variations elimination algorithms take exp time space compute likelihood event number nodes network width corresponding elimination order 
dbns pose speci computational challenges require solutions 
dbns typically heavily connected admitting elimination orders high width 
second nd elimination order reasonable width ord space complexity exp nt case number variables time slice number time slices dbn 
applications large making space complexity nt exp unrealistic 
key challenges dbns develop ecient algorithms space complexity independent time span leading known constant space algorithms 
study main algorithms achieving constant space complexity slice slice elimination orders suggest improvements new classes elimination orders 
identify topological parameters dbns prove number tight bounds time complexity algorithms study 
observe experimentally newly identi ed elimination orders tend better ones general purpose elimination heuristics min ll 
suggests constant space algorithms ones study dbns space concern 
keywords dynamic bayesian networks elimination orders structure algorithms variable elimination space complexity 
dynamic bayesian network dbn 
dynamic bayesian network dbn special kind bayesian network model dynamic stochastic processes see :10.1.1.119.6111
variable dbn associated time slice denoted key characteristic dbns number time slices needed model particular problem call time span key characteristic number variables associated time slice call slice size dbn assumed satisfy conditions structure time slice cross slice edges allowed extend slice slice 
assume variables time slice connected talk expansion dbn mean dbn slices 
key usages dbns forecasting prediction computing probability events evidence past pr typically time span large goal perform computation space independent span 
task diagnosis computing probability past events evidence pr key requirement perform computation space independent time span task monitoring point time need probability events evidence past pr 
proceed time step want update probabilities time space independent complexity reasoning general bayesian networks typically characterized key parameters number variables network width elimination order 
expansion dbn number variables nt number variables standard notation variables denoted upper case letters values lower case letters 
sets variables denoted bold face upper case letters instantiations denoted bold face lower case letters 
time slice 
standard algorithms inference bayesian networks variations peeling algorithms time space complexity exp 
reason dbns standard algorithm constructing expansion covers events interest 
require time space complexity nt exp 
turns unacceptable reasons 
dbns typically heavily connected admitting elimination orders high width second width acceptable space complexity nt exp typically unrealistic time span usually large 
direction address rst challenge appeal approximate inference algorithms :10.1.1.119.6111
second challenge wants develop algorithms space complexity independent exp minimizing time complexity possible 
algorithms referred constant space algorithms 
stress recursive algorithms hmms kalman lters property space complexity independent time span straightforward solution second challenge collapse time slice dbn single variable leading chain structure handled recursive algorithms hmms kalman lters 
approach exponential size time slice works small 
sophisticated solution second challenge algorithms variations peeling algorithms restricting oneself subclass elimination orders 
speci cally appropriate restriction elimination order reduce space complexity methods nt exp exp 
popular class elimination orders achieve space complexity known informally slice slice orders requires eliminate variables time slice eliminating variables time slice 
fact comprehensive algorithm structure reasoning dbns class elimination orders 
analyze class elimination orders highlighting important facts 
width elimination order class tightly bounded follows dbn structural parameter known interface width 

classes elimination orders lead constant space complexity outperform class certain network structures 
contribution fold 
formal explicit computational limits algorithms slice slice elimination orders 
second slice variables collapsed variable exp values transition probability matrix size exp 
open door identi cation classes elimination orders achieve constant space complexity 
regard identify new classes elimination orders study properties new dbn structural parameter known temporal bandwidth 
show temporal bandwidth greater interface width class dbns persistence edges ones extend time slice 
show tends smaller number randomly generated networks 
nal contribution surprising observation regarding heuristics constructing elimination orders 
speci cally constrained elimination orders principle outperform unconstrained ones appears constrained versions popular min ll heuristic constructing elimination orders tend outperform unconstrained counterpart 
encouraging observation means contrary expect pay computational price practice result constraining elimination orders achieve constant space complexity dbns 
fact experimental results suggest constrained orders concerned constant space reasoning 
structured follows 
start reviewing variable elimination algorithm section time space complexity nt exp 
show section space complexity algorithm dropped exp case temporal prediction restrict slice slice elimination orders 
analyze class elimination orders propose new studying properties comparing slice slice orders 
turn problem temporal diagnosis section generalizing results combined algorithm diagnosis prediction 
section dedicated experimental results compare classes elimination orders addition comparing constrained unconstrained versions min ll elimination heuristic 
section closes concluding remarks 
proofs theorems available appendix variable elimination variable elimination algorithm quite simple especially want computing probability evidence respect bayesian network containing conditional probability tables cpts number variations variable elimination initialized set tables table set inconsistent evidence refer step entering evidence 
consider variables elimination order multiplication tables mentions variable table multiplication standard operation de ned cpts potentials see example 
sum variable yield summing standard operation de ned cpts potentials see example 
replace tables mentioning say case tables mentioning consumed result eliminating variable 
algorithm guaranteed contain single table single entry contains probability evidence way computing marginals compute pr pr pr pr 
require invocations algorithm 
important notion width variable elimination order respect bayesian network 
number ways de ning notion 
suppose jointree constructed elimination order number variables largest clique width 
suppose largest table constructed applying variable elimination algorithm order number variables appearing width 
standard de nition direct terms moral graph bayesian network 
appeal second de nition easily show complexity variable elimination network nodes elimination order width exp 
close section noting variable elimination algorithms known arti cial intelligence literature structurally similar peeling algorithms known pedigree analysis literature 
prediction utilize elimination algorithm reason dbns 
start problem prediction generalize tasks section 
rst algorithm uses slice slice elimination order show choice orders allows drop space complexity nt exp exp width order 
suppose observation sequence suppose interested computing marginals variables slice simply construct dbn span eliminate variables slices eliminate variables compute marginals 
contain cpts slices enter evidence tables 

eliminate variables slice 
apply variable elimination compute marginals variables number observations order algorithm refer pd 
note step contain variables slice second algorithm non deterministic eliminate variables steps di erent ways 
elimination orders satisfy property variables slice eliminated variables slice eliminated 
key achieving constant space complexity shown observation proposition iteration step pd tables corresponding time slices irrelevant elimination process 
basically means need initialize set tables 
dynamically introduce tables need leading constant space version pd 
contain cpts slice 
enter evidence tables 

generate cpts slice enter evidence add 
eliminate variables slice 
apply variable elimination compute marginals variables exact space time complexity pd depends speci order variables eliminated steps establish tight bounds width order 
rst need notion de nition interface dbn set variables time children parent time 
interface width dbn size interface 
dbn interface contains variables interface contains slice variables 
theorem interface width dbn elimination order algorithm pd dbn 
width order bounded follows bounds tight 
stress points 
algorithm constructs slice slice elimination orders complexity subject established bounds 
leads sophisticated notion variable elimination reduces complexity answering multiple queries 
better complexity comes expense substantial algorithmic subtlety especially algorithm dynamic editing 
shall see context dbns attain improved complexity case multiple queries limited simple usage 
propose new class elimination orders di erent properties shown continues allow constant space reasoning dbns 
new class elimination orders observation 
consider dbn suppose slice variables 
interface width slice slice elimination order width note dbn treewidth independent wonders exists elimination order width independent answer turns need de nition rst 
de nition forward interface dbn span set variables time having children time 
temporal bandwidth dbn size forward interface 
slice slice elimination referred constrained elimination shown jointree constructed order separator includes dbn interface 
forward interface contains variables contains variable basic idea restrict forward elimination process processing time slice eliminate variable belonging forward interface slice variables eliminated processing slice 
leads algorithm call pd 
generate cpts slice enter evidence add 
eliminate variables belonging forward interface slice 
generate cpts slice enter evidence add 
apply variable elimination compute marginals variables example dbn variables eliminated follows step fx fx fx dbn variables eliminated follows fx fx fx 
compare section classes elimination orders embodied algorithms pd pd showing algorithm pd dominates pd number benchmark randomly generated networks 
general algorithm prediction diagnosis general class elimination orders show complexity bounded exponentially temporal bandwidth 
diagnosis constant space elimination algorithm temporal diagnosis dbns backward slice slice elimination orders 
combine prediction diagnosis algorithms obtain algorithm general inference general class elimination orders 
note algorithm pd pd matter easily modi ed monitor dynamic process long able execute cycles step fast 
particular suppose predicted state time time move forward time obtain evidence goal compute probabilities variables time time space independent long saved state step previous time slice execute cycle step followed step compute marginals variables clearly accomplished time space independent time suppose observation sequence suppose interested computing marginals variables slice simply construct dbn span eliminate variables slices eliminate variables slice compute marginals 
leads algorithm dg 
contain cpts slices enter evidence tables 

eliminate variables slice 
apply variable elimination compute marginals variables note algorithm takes memory linear observation tells modi ed memory requirements independent proposition iteration step dg tables corresponding time slices irrelevant elimination process 
means need initialize set tables 
dynamically introduce tables need leading constant space version dg 
generate cpts slice enter evidence add 
eliminate variables slice 
generate cpts slice enter evidence add 
apply variable elimination compute marginals variables algorithm employs backward slice slice elimination orders width bound follows 
theorem temporal bandwidth dbn elimination order algorithm dg dbn 
width order bounded follows bounds tight 
temporal edge dbn extends time slice 
persistence edge temporal edge extends variable time slice variable time slice 
temporal edges persistence edges temporal bandwidth greater interface width 
possible width order algorithm pd theorem suppose temporal bandwidth interface width respectively dbn temporal edges persistence edges 
combine algorithms pd dg leading algorithm 
observation sequence compute pr jo 
generate cpts slice enter evidence add 
eliminate variables belonging forward interface slice 
downto generate cpts slice enter evidence add 
eliminate variables slice 
generate cpts slice enter evidence add 
apply variable elimination compute marginals total variables algorithm simply classical variable elimination algorithm computing marginals variables slice dbn 
di erence algorithm standard elimination algorithm uses constrained class elimination orders 
advantage class elimination orders space complexity independent dbn temporal span 
establish algorithm complexity theorem elimination order algorithm width 
space complexity algorithm exp time complexity exp number variables time slice 
temporal bandwidth dbn 
note contrary jointree algorithm time complexity depends number marginals wish compute time slice step takes nm exp time 
deal dropping time complexity step exp restricted usage 
perform step rst constructing undirected graph follows contain node variable appears set tables 
include edge variables appear table 
construct jointree quantify tables perform jointree propagation take exp dropping total running time nt exp 
note dbn construct jointree structure pre processing stage leaving quanti cation run time reducing overhead considerably 
experimental results main goals section 
give idea kind dbns accessible structure algorithms compared simple collapsing algorithm exponential double slice size 
second provide experimental comparison min ll heuristic applied unrolled dbn constrained min ll heuristic applied context algorithms pd pd dg 
min ll heuristic weight variable number edges add order pairwise connect neighbors 
generate elimination order heuristic start undirected graph representing moral graph bayesian network 
heuristic rst eliminates variable smallest weight connects neighbors repeats process variables eliminated 
min ll heuristic proceeds ordering proposed corresponding algorithm appealing min ll heuristic choice elimination possible example eliminating variables particular time slice pd 
conducted sets experiments 
rst considered number dbns reported literature 
second generated randomly static bayesian network added random set persistence edges construct dbn 
third set experiments generated static networks temporal edges restricted persistence edges variable time connected variable chosen randomly time 
set experiments report width elimination order constructed unconstrained min ll heuristic min ll heuristic algorithm modi ed perform smoothing constant space increase time complexity quadratic adopt technique allows log space increase time complexity log 
network min ll pd pd interface temporal width bandwidth bat dna water table experimental results realistic dbns 
expansions experiments 
dbn slice size 
context pd pd dg 
report interface width temporal bandwidths considered networks 
table reports widths networks appeared literature dbns 
clear results pd algorithm dominates pd standard elimination algorithm min ll 
cases structure approach clearly better slice collapsing approach 
considered randomly generated dbns 
size time slice randomly generate static network edge node node added randomly probability 
persistence factor add persistence edges nodes chosen randomly time slice 
table reports results varying clear table pd dominates pd standard elimination algorithm min ll 
fact di erence quite signi cant leading exponential savings cases 
note pd dg close networks 
set experiments added temporal edges random slices restrict edges persistence ones 
set variables selected random slice probability child randomly chosen variable slice 
table reports results varying clear table pd dominates pd standard elimination algorithm 
di erence pd pd signi cant class dbns standard elimination algorithm better pd case 
pd dg close networks 
di erence quality elimination orders constructed popular min ll heuristic elimination orders computed context pd dg surprisingly large 
di erence quality suggests may constrained elimination orders context space complexity issue 
observed quality elimination orders computed min ll worse larger time spans smaller spans 
min ll pd pd dg interface temporal width bandwidth table orders computed expansions 
reporting average standard deviation parenthesis cases 
achieved goals 
spelled precisely simplest constant space algorithms predictive diagnostic inference dbns analyzed complexity new structural parameter known temporal bandwidth 
algorithm combination new classes elimination orders prediction diagnosis 
second compared quality new classes elimination orders known class slice slice elimination orders employed algorithm 
explicit computational limits algorithm classes elimination orders showed algorithms proposed elimination orders better performance number realistic randomly generated networks 
experimental results suggesting constrained versions min ll elimination heuristic tend outperform unconstrained version heuristic 
surprising encouraging 
means contrary expect constrained eliminated orders achieve constant space complexity dbns practically entail higher computational price 
going observation concerned constant space complexity sense constrained elimination orders unconstrained ones context dbns 
min ll pd pd dg interface temporal width bandwidth table orders computed expansions 
reporting average standard deviation parenthesis cases 
partially supported muri research number 
proofs denote variables slice denote forward interface variables slice denote interface variables slice de nition set tables graph obtained including node table adding edge nodes corresponding tables share variable set tables connected graph connected 
lemma central proofs 
lemma set connected tables de ned variables 
eliminating variables left single table variables variable eliminated table fxg constructed elimination process 
graph set tables graph fxg set tables result eliminating variable tables 
prove rst part suces show connected connected 
show starting connected graph eliminating variables connected graph nx 
nx contains variables contain single node 
contain single table variables 
graph tables graph tables 
nodes corresponding tables contain variable nodes form clique result 
replacing nodes new node corresponds table 
replacing edge node node edge nodes de nition graph 
connected connected 
prove second part lemma note eliminating variable fxg set tables graph connected 
remaining tables contain eliminating tables multiplied leading single table fxg summed table 
lemma cpts variables bayesian network 
variables connected bayesian network tables connected 
graph tables 
correspondence nodes variables node corresponds cpt variable edge connects variables bayesian network edge connects corresponding tables belong tables 
nodes connected variables connected 
lemma cpts variables slice cpts children slice 
tables connected 
graph tables 
subgraph corresponding cpts variables connected lemma variables connected bayesian network 
cpt slice belongs child variable slice mention variable cpt child connected cpt graph connected 
proof proposition eliminating variable tables matter appears 
tables associated children 
children appear slices 
table slices contain slices tables irrelevant elimination variables proof theorem step elimination process involve variables step involve variables consider dbn node slice nodes slices parents 
case treewidth network 
upper bound tight 
step elimination process guaranteed construct table variables 
shown follows 
rst iteration step set tables involved elimination process cpts variables children slice 
variables appearing tables invoking lemma table variables constructed process eliminating variables tables connected lemma 
bound tight consider chain network 
proof proposition cpts associated variables slices mention variables slice involved eliminating variables slice proof theorem step variables involved elimination process step variables involved elimination process consider dbn node slice nodes slices parents 
case treewidth network 
upper bound tight 
step elimination process guaranteed construct table variables 
shown follows 
rst iteration step tables involved elimination process cpts variables contain variables invoking lemma table constructed variables eliminating variables tables connected lemma 
bound tight consider chain network 
proof theorem temporal edges persistent edges interface time contain variables forward interface time addition parents time proof theorem step elimination process involve variables rst iteration variables 
step elimination process involve tables variables guaranteed construct table variables see proof theorem 
step elimination process involve tables variables guaranteed construct table variables constructed table variables leading show number tables maintained algorithm stage execution establishes space complexity size table exp 
initially tables number tables 
show maintained algorithm execution step introduce tables 
step consume tables variables introduce tables variables iterations step addition consume tables left iteration 
speci cally cpt introduced step iteration constructed step iteration consumed iteration variables consumed variables eliminated iteration number tables continue iteration step 
step introduce tables step consume introducing table variables step introduce tables step consume addition table constructed iteration 
step introduce table variables number tables continue iteration step 
enter step tables continue tables cpts introduced step 
variable elimination increase number tables 
number tables continue elimination process 
time complexity follows eliminate nt variables steps eliminate nm variables step creating table size exp 
binder murphy russell 
space ecient inference dynamic probabilistic networks 
proc 
international joint conference arti cal intelligence ijcai 
boyen koller 
tractable inference complex stochastic processes 
proceedings th conference uncertainty arti cial intelligence uai 
thompson skolnick 
probability functions complex pedigrees 
adv 
appl 
prob 
rina dechter 
constraint networks 
shapiro editor encyclopedia arti cial intelligence pages 
john wiley sons 
rina dechter 
bucket elimination unifying framework probabilistic inference 
proceedings th conference uncertainty arti cial intelligence uai pages 
rina dechter 
mini buckets general scheme approximation automated reasoning 
proc 
international joint conference arti cal intelligence ijcai pages 
forbes tim huang kanazawa stuart russell 
bayesian automated taxi 
proc 
international joint conference arti cal intelligence ijcai 
cecil huang adnan darwiche 
inference belief networks procedural guide 
international journal approximate reasoning 
finn jensen 
bayesian networks 
springer verlag new york 
computational system dynamic time sliced bayesian networks 
international journal forecasting 
nevin zhang david poole 
exploiting causal independence bayesian network inference 
journal arti cial intelligence research 

