nonmonotonic delegation logic prioritized conflict handling ninghui li computer science department new york university mercer street new york ny ninghui cs nyu edu benjamin grosof ibm watson research center box yorktown heights ny grosof ibm com www research ibm com people grosof joan feigenbaum labs research room park avenue florham park nj jf research att com extend previous delegation logic dl tractable practically implementable logic language authorization large scale open distributed systems 
expressively generalize previous version dl called lp nonmonotonic expressive features including negation failure classical negation prioritized conflict handling 
resulting formalism called lp 
discuss motivations usefulness prioritized conflict handling subtleties challenges extending dl 
partly subtleties restrict lp prohibiting queries delegation statements 
technical approach defining lp tractably compiling lp generalized courteous lp gclp turn tractably compiled ordinary lp olp 
show lp tractable practically implementable top existing technologies olp prolog sql databases rule systems 
address problem authorization large scale open distributed systems 
authorization decisions needed electronic commerce mobile code execution remote resource sharing content advising privacy protection applications 
distributed authorization authorizer know requester directly needs information third parties know requester better normally authorizer trusts third parties certain things certain degree 
multi agent aspect distributed authorization different traditional access control 
adopt trust management view distributed authorization requester submits request possibly supported set credentials issued parties authorizer controls requested resources 
authorizer decides credentials prove request complies local policies 
delegation logic dl logic approach representing policies credentials requests distributed authorization 
dl extends logic programming languages delegation construct features delegation depth wide variety complex principals including limited thresholds 
delegation allows party parties information controllable way 
lp monotonic version dl defined 
lp datalog definite lp 
expressively generalize lp nonmonotonic expressive features including negation failure classical negation prioritized conflict handling 
resulting generalization called lp 
security policies logically nonmonotonic easily specified nonmonotonic formalism 
applications natural policy decision direction favor authorizing information evidence contrary known revocation 
negation failure default negation weak negation easy intuitive way 
useful representation policies classical negation explicit negation strong negation allows policies explicitly forbid 
argued allows flexible security policies 
introducing classical negation leads potential conflict 
conflict handling mechanisms needed 
nonmonotonic reasoning extensively studied 
existing logic language authorization uses formalisms results nonmonotonic reasoning :10.1.1.25.7359
main difference lp previous lp delegation construct deals multi agent aspect distributed authorization 
defining lp deal interaction delegation nonmonotonic expressive features 
interaction results subtleties 
partly subtleties restrict lp prohibiting queries delegation statements 
lp different languages prioritized conflict handling :10.1.1.25.7359
especially useful resolving conflicting advice different apparently trustworthy sources 
technical approach defining lp tractably compiling lp generalized courteous lp gclp turn tractably compiled ordinary lp olp 
show lp tractable practically implementable top existing technologies olp prolog sql databases rule systems 
gclp courteous lp clp 
clp features negation failure classical negation prioritized conflict handling 
clp rule optionally label conflicts rules resolved priority relationships labels defined reserved predicate overrides 
gclp extends clp mutual exclusion constraints mutex prioritized reasoning predicate overrides 
generalize gclp version allow rule labels terms constants 
rest organized follows 
section discuss motivations usefulness prioritized conflict handling give syntax semantics gclp 
argue gclp useful language expressing authorization policies 
section discuss subtleties extending dl prioritized conflict handling define syntax semantics lp show tractable 
conclude section 
datalog means functions zero arities constants 
definite means negation free 
olp known normal general lp definite lp plus negation failure 
gclp lot interest language approach security policies :10.1.1.25.7359
goal provide unified framework support multiple access control policies achieve separation policies mechanisms 
uses logic programming lp languages uses languages easily translated lp languages 
policy languages negative authorizations policies explicitly forbid 
positive negative authorizations specified conflicts may arise 
existing authorization languages deal conflict handling ways resolve conflicts define semantics conflict free policy programs 
totally ordered rules resolve conflicts 
define fixed conflict resolving policy relative authority specificity 
add paraconsistent layer negation failure resolve conflicts 
example write file file file specifies particular negative authorization wins positive 
specify relative priority pair mutually conflicting rules derive 
argue approaches undesirably limited 
cases isn meaningful total ordering 
relative authority specificity important sources conflict resolving information sources 
sources may useful recency relative importance rules single source 
gclp conflict resolving mechanism flexibly specify conflict resolving policies 
syntax gclp gclp classical literal takes form atom 
literal takes form stands negation failure classical literal 
gclp rule takes form lab lab term classical literal formula built literals conjunction disjunction 
lab called label head body respectively rule 
label rule empty body rule 
variable starts question mark 
variables rule label appear rule head body 
say rule label range restricted variables rule label appear rule head 
special binary predicate overrides specify prioritization mutually conflicting rules 
atom overrides lab lab means rule lab label take precedence conflicts rule label lab 
pre defined semantics predicate overrides different predicate 
mutual exclusion constraint mutex takes form 
called focus mutex called body 
empty symbol omitted 
intuitively mutex specifies conflict true 
atom conflicts conflict need specified explicitly 
note mutex labels labels resolve conflicts conflicts mutex 
introduce mutex conflicts conveniently represented classical negations 
examples include classification users mutually disjoint groups roles choices mutual exclusive actions 
gclp program consists set rules mutex rule mutex variables stands ground instantiations 
example gclp policies represented gclp represented olp 
gclp compiled olp 
gclp mutex prioritized conflict handling offers expressive convenience clarity 
example consider database authorization model 
authorization may specified single user group 
group may contain users groups members may contain member directly indirectly 
user authorizations specified groups belongs directly indirectly 
authorizations positive negative strong weak 
conflicts positive authorizations negative ones resolved follows 
strong authorizations override conflicting weak authorizations 
conflict strong authorizations resolved policies having conflicts inconsistent 
conflict weak authorizations specific authorization wins specific conflict resolved 
example alice member scientist group member researcher group turn member employee group authorization researcher group take precedence conflicting authorization employee group 
policy easily represented gclp 
giving group researcher weak authorization select table represented rule auth weak researcher authorizes sel user member researcher 
conflict resolving policies represented follows overrides auth strong auth weak 
overrides auth weak auth weak member 
semantics gclp intuitive meaning gclp conflict handling mechanism follows 
rule body true say rule ready candidate head 
candidate classical literal refuted candidate literal conflicts overrides label label true 
literal true candidate candidate conflicts semantics concludes conflicts example candidates concluded defeat 
skeptical semantics 
choose paraconsistent semantics desired dropping requirement true candidate conflicts desirable applications 
gclp semantics formally defined transformation ordinary lp 
gclp program compile olp steps 

predicate pred arity predicate pred number arguments takes introduce new predicate pred represent pred classical negation add mutex pred 
xz pred 
xz replace literal pred 
tz pred 
tz 
denote result transformation pm set mutex set rules empty set 

predicate including new predicates introduced classical negation introduce new predicates literal 
tz define 
tz true candidate define 
tz true defeated candidate literal conflicts 
mutex pm body define ready atom ready pred 
xw ready pred new predicate 
xw variables add rule ready body rule define atom ready 
xw define atom refuted 
xw ready refuted new predicates 
xw variables add rules 
head 
head heads intuitively mean rule ready body true rule ready refuted head candidate literal candidate defeated literal true 

rule rule loss generality assume variables appear rename variables necessary 
mutex body assume variables appear general unifier mgu exists add rules ready overrides 
head ready head 
rule means refuted rule head conflicts head ready label overrides label 
second rule means defeated head conflicts head head candidate 
resulting program olp size transformation level loop 
size program mean number symbols variables constants predicate symbols logical operators semantics gclp defined semantics corresponding olp 
leading semantics olp founded semantics wfs stable model semantics 
olp programs stable model programs 
furthermore propositional program determining stable model np complete 
hand wfs assigns unique valued model program 
finite ground programs complexity compute founded model worst case quadratic size program 
choose wfs 
gclp model computed follows 
compute compute wfs model translate wfs model back gclp discarding new predicates introduced steps translating pred 
tz pred 
tz 
compile gclp queries olp queries evaluate olp 
compile gclp query olp needs replace pred pred 
olp reasoning detect conflict literal lit checking lit lit true 
complexity results theorem transformation gclp corresponding olp takes time generates output program size 
size sketch proof 
size bound follows definition transformation 
definition corresponds straightforwardly algorithm linear output size 
note linear time algorithms unification see 
worst case size reached mutex pairs rules potentially conflict 
highly practice 
theorem shows gclp inferencing tractable restrictions similar olp inferencing tractable datalog bounded number logical variables rule 
say lp obeys restriction upper bound number logical variables rule mutex rule label range restricted 
lp datalog say 
theorem gclp inferencing takes time 
sketch proof 
key observation transformation maintains rule number variables bound 
ground instantiation size datalog restriction implies terms instantiate variable 
furthermore wfs inferencing takes worst case quadratic time bound 
show transformation maintains variable bound 
new rule added step variables variables rule consider rules added step ready overrides head ready head rule label range restricted vari ables new rules applying variables note datalog restriction unifies terms nv min nv nv nv number variables similarly unifies nv min nv nv nv 
mutex variables unifies variables new rules 
mutex added transformation pred 
xz pred 
xz 
unifies arguments arguments 
xz 
variables new rules 
inferencing datalog olp variable rule bound takes time worst case gclp inferencing complexity equivalent adding variables rule 
bad logic programs high variable bounds practice 
high theoretical worst case complexity practical running times programs acceptable 
lp nonmonotonic delegation logic section extend delegation logic nonmonotonic expressive features gclp 
call nonmonotonic version delegation logic lp 
subtleties integrating delegation nonmonotonicity delegation important concept distributed authentication authorization systems 
delegation logic delegation depth positive integer symbol infinite depth 
dl interprets depth delegation alice delegates bob alice says bob says depth delegation alice delegates bob implies depth delegation alice delegates bob delegates lp delegation relation queried 
lp semantics answers says delegates 
answering delegation queries simultaneously resolving conflicts subtle 
consider example example alice delegates bob 
bob delegates carl 
bob says bob says overrides 
carl says conclude alice delegates carl 
chaining delegation true 
fact conclude alice says counter intuitive 
intuitively propagates carl bob alice 
blocked bob reach alice 
delegation query free restriction subtlety discussed previous section restrict lp prohibiting delegation statements appearing queries rule bodies rule bodies queries nature 
call delegation query free restriction answer delegation queries conflict resolution topic research 
expect complex syntax semantics 
restriction stronger conjunctive delegatee query restriction ensures lp tractable 
delegation statements queries rule bodies required single principal conjunction principals delegatee 
restriction says answered delegates despite restriction lp significant expressive power 
way lp direct statements represent attributes principals example groups roles authorizations viewed attributes 
lp principal bind attributes principals delegate principals authority bind attributes principals reason attributes principals 
example give example lp 
program alice authorizes believes credit transactions delegates right determine credit credit allows delegate step 
alice says authorizes transaction alice says credit 
alice delegates credit alice says 
syntax lp 
base atom takes form pred 
tn 
base literal takes form pred 
tn pred 
tn 
gclp lp reserved binary predicate overrides prioritization 

direct statement takes form says lit delegation statement takes form delegates lit xs speaks statement takes form speaks lit principal terms called issuer statement 
principal term principal variable 
lit base literal 
xs complex principal term principal structure variable called delegatee delegation statement 
principal structures constructed principals threshold structures conjunction disjunction 
see definition discussion threshold structures discussion delegations speaks statements 
mutex statement takes form says lit opposes lit principal term called issuer statement lit lit base literals 
intuitively statement means view lit lit conflict says lit says lit mutually exclusive 

body statement body direct statement takes form xs says lit negation failure statement takes form xs says lit xs complex principal term 

rule takes form lab head body 
head direct statement delegation statement speaks statement mutex statement body formula constructed body statements conjunction disjunction 
note delegation statements speaks statements mutex statements allowed appear rule bodies 
rule labels resolve conflicts direct statements derived rules 
example continuing example alice delegates ability determine bad credit fraud expert bad credit information overrides credit information 
expert bob alice fully trusts 
recommend place ascii representation desired 
trusted alice delegates credit status bob 
alice delegates credit alice says 
bad alice delegates credit bad alice says 
alice says credit opposes credit bad 
alice says overrides bad 
alice says overrides trusted 
alice says overrides trusted bad 
semantics lp lp semantics define transforming lp gclp transformation part similar transformation lp olp 
addition reserved predicate overrides predicate holds 
represent direct statements appear derived inference process 
atom holds takes form holds lt len principal term principal principal variable lt term represents base literal len 
integer largest integer delegation depth define pred introduce function symbols pred nd pred 
function pred represent base atom nd pred represent negated base atom 
lt denote term corresponds lt classical negation 
field len stores number delegation steps gone 
field len means gone steps need keep track number steps greater maximal integer delegation depth transformation need function sf defined expand statements complex principal structures issuers 
example function call sf holds returns holds holds holds 
transformation label negation transformation lp specific transformation changes rules result called 
rule 
tn change label 
tn issuer 
replace base literal pred 
nd pred 
transformation body transformation transformation changes rule bodies result called 
replace body direct statement xs says lt sf xs holds lt lp specific replace negation failure statement xs says lt de holds xs lt negation pushed inside conjunctions disjunctions 
transformation ii head transformation transformation changes rule heads removes rules adds new rules result called 
rule cases case lp specific mutex statement says lt opposes lt remove len len add rule holds lt len holds lt len 
case direct statement says lt replace head holds lt case delegation statement speaks statement 
delegation statement delegates lt bs ll 
speaks statement speaks lt ll bs delegation expansion remove len add rule holds lt len ll sf bs holds lt len 
case case 
len add rule holds lt len holds lt len 
len len add mutex lp specific holds lt len holds lt len 
lt overrides 

add rule lp specific overrides 

holds overrides 


threshold structures handled similarly 
omit details 
goal transformation define intended semantics lp 
possible transformation optimize sense resulting fewer output rules maintaining equivalent semantics 
optimizations improve asymptotic bound output size 
choose computationally slightly expensive clearer definition 
important property transformation introduce new variables precisely rule variables come rule transformation introduces new logical function symbols new sense appear original lp 
particular lp datalog generated gclp non datalog 
predicate pred corresponding function symbols pred nd pred 
transformation introduces pre defined functions threshold structures 
directly tractability results datalog gclp section 
problem exists transformation lp definite olp problem dealt generating typed olp essentially wish ensure variable ground terms instantiate 
variables come variables instantiated ground terms terms constructed function symbols introduced transformation 
typing ensures restriction instantiation 
technique 
transformation generates typed gclp 
transformation gclp olp simply passes typing generated olp 
discussions types see appendix inferencing complexity results theorem transformation lp gclp generates output program size 
straightforward algorithm takes time 
sketch proof 
counting argument function sf growth factor 
delegation expansion step generates largest output steps 
generates rules uses sf 
step growth factor 
output program size 
lp inferencing done compiling lp program gclp computing minimal gclp model translating back lp 
gclp holds pred 
len translated says pred 
holds nd pred 
len translated says pred 
way inferencing follows 
compile lp queries addition lp programs gclp queries compiled way rule bodies 
compile gclp queries program olp 
olp inference engine answer queries 
example continued add facts example 
alice says cb 
alice says carl 
bob says credit john 
cb says credit jack 
carl says credit john bad 
carl says credit jack bad 
conclude alice says credit john alice says credit jack bad recall say lp datalog rule variables rule variables label appears head 
practice bound programs small constant 
expect usually smaller theorem inferencing lp takes time polynomial nd constant inferencing lp takes time polynomial sketch proof 
lp output gclp program size 
typing ensures variables instantiated constants note datalog 
compile olp variable bound 
instantiating increases size inferencing takes time quadratic size instantiated inferencing time polynomial nd discussion defined syntax semantics nonmonotonic version delegation logic lp 
lp extends lp earlier version delegation logic equip negation failure olp prioritized conflict handling manner similar generalized courteous logic programs gclp 
features prioritized conflict handling lp includes classical negation mutual exclusion integrity constraints mutex complexity bound proof high degree polynomial 
get tighter bound doing detailed analysis 
observation pairs rules re potentially conflict 
due space limit focus omit analysis 
acknowledge practicality lp needs tested experiments 
specify scope conflict flesh particular consistency constraints enforced semantics 
discussed subtleties arise delegation construct dl combined nonmonotonic features 
particular care taken defining semantics delegation appropriate provision handling conflict intermediate steps chain delegation 
partly result subtleties avoided non trivial derivation statements delegation se delegation statements prohibited queries delegation statements 
technical approach defining lp compiling lp generalized courteous lp gclp turn compiled ordinary lp olp 
showed compilation steps computationally tractable lp inferencing tractable broad restriction similar ensures tractability olp inferencing 
compilation approach enables lp implemented modularly top existing technologies olp include prolog sql relational databases rulebased knowledge systems see discussion review olp relates current commercially important families rule systems 
major challenge designing knowledge representation kr esp nonmonotonic multi agent achieve usefully rich expressiveness intuitively natural semantics moderate computational complexity relative ease incorporation existing software environments 
believe lp represents significant progress lines 
bertino ferrari logical framework reasoning data access control policies proceedings th ieee computer security foundations workshop ieee computer society press los alamitos pp 

bertino jajodia samarati flexible authorization mechanism relational data management systems acm transactions information systems pp 

preliminary version appeared title supporting multiple access control policies database systems proceedings ieee symposium security privacy oakland ca may 
blaze feigenbaum ioannidis keromytis role trust management distributed systems secure internet programming lncs vol 
springer berlin pp 

van gelder ross schlipf founded semantics logic programming journal acm pp 

grosof courteous logic programs prioritized conflict handling rules ibm research report rc may 
extended version 
grosof prioritized conflict handling logic programs proceedings international symposium logic programming mit press cambridge pp 

grosof compiling prioritized default rules ordinary logic programs ibm research report rc may 
grosof compiling prioritized default rules ordinary logic programs commerce applications extended intelligent systems demonstration proceedings aaai morgan kaufmann 
extended version ibm research report rc may 
jajodia samarati subrahmanian logical language expressing authorizations proceedings ieee symposium security privacy ieee computer society press los alamitos pp 

jajodia samarati subrahmanian bertino unified framework enforcing multiple access control policies proceedings acm sigmod conference management data 
li feigenbaum grosof logic knowledge representation authorization delegation extended proceedings th ieee computer security foundations workshop ieee computer society press los alamitos ca pp 

full available ibm research report rc 
li grosof feigenbaum practically implementable tractable delegation logic appear proceedings st ieee symposium security privacy may oakland ca 
available cs nyu edu ninghui papers oakland ps 
lloyd foundations logic programming second edition springer berlin 
lupu sloman conflict policy distributed systems management ieee transaction software engineering special issue inconsistency management appear 
preliminary version appeared title analysis management policies proceedings fifth ieee ifip international symposium integrated network management san diego usa may 
marek nonmonotonic logic context dependent reasoning springer berlin 
naish types intended meaning logic programs pp 

pfenning editor types logic programming mit press cambridge ma 
neuman representation evaluation security policies distributed system services proceedings discex hilton head island sc january 
woo lam authorization distributed systems new approach journal computer security pp 

woo lam designing distributed authorization service proceedings ieee info com 
approach adding types lp languages section mentioned typing needed ensure tractability lp inferencing 
typing implicitly syntax dl 
dl principals principal variables 
set principals subset constants variable said principal variable appears certain places 
implicit type principal 
addition types logic programs studied logic programming community 
argued logic programs implicit assumptions types logic program satisfies intended meaning type information added program 
think typing potentially useful lp authorization languages 
authorization different types entities subjects objects groups roles predicates take arguments certain types 
briefly describe approach add types lp languages 
approach different approaches view type information supplementary logic rules 
give partial type information type information program correctly typed 
additional type information serves purposes clarify intended meaning policy programs enable efficient reasoning 
approach add types olp gclp lp languages 
intuitively type corresponds subset ground terms subsets need disjoint 
symbols start colon type names 
ground term type contained subset corresponding term may multiple types 
require terms constructed function function uniquely identified name arity types 
say function types equivalently type type contain function approach define argument types functions predicates types variables subtype relationship types 
typed lp program consists set typed rules called theory possibly empty set type specifications 
typed rule term including variable followed zero type names called type definitions term 
pre defined types program terms constants 
term type constant type addition types need explicitly added terms 
scope function including constant program 
type definitions function program taken function types 
scope variable rule appears 
type definitions variable rule taken variable instantiated terms required types 
type definitions rules define return types function types terms constructed function 
type specification part specify argument types predicates functions 
example declare pred overrides specifies predicate overrides takes terms type arguments 
specification equivalent adding type definition argument predicate overrides 
example specification atom overrides equivalent overrides 
similarly specify argument types functions declare func auth group specifies second argument function auth type group doesn specify type argument 
specification defines function auth type specification predicate function 
specification exists predicate function argument default type specification part specify ordering types 
declaration declare incl means terms defined type automatically type semantics typed olp defined follows 
find functions determine functions contained type types variable determine functions variable instantiated intersection sets functions corresponding type variable 
done time number types second instantiate need compute ground terms instantiate variable 
may infinite number terms type signatures functions satisfy acyclic condition finite number terms 
compute minimal model instantiated program 
ensure variables post transform gclp lp instantiated terms constructed functions constants add step step transformation lp gclp 
transformation sort related transformation sort insert name colon example da 
change sort names new 
explicitly add sort dc constants da terms 
sort specification predicate pred replace sort specifications functions pred nd pred 
transformation variable type da 
instantiated terms terms type 
