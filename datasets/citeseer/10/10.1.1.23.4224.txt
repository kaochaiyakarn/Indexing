identifying similar code program dependence graphs jens krinke lehrstuhl universit passau passau germany approach identify similar code programs finding similar subgraphs attributed directed graphs 
approach program dependence graphs considers syntactic structure programs data flow abstraction semantics 
result tradeoff precision recall approach 
evaluation prototype implementation shows approach feasible gives results despite non polynomial complexity problem 

duplicated code common kind software systems 
cut copy paste adapt techniques considered bad practice programmer 
code duplication easy cheap software development software maintenance complicated errors may duplicated duplicated code 
modifications original code applied duplicated code 
especially software renovation projects desirable detect duplicated code number approaches developed :10.1.1.45.9928:10.1.1.139.2982
approaches graph text language independent syntax metrics syntax text 
approaches detect textual structural identical duplicates typical software systems duplicates adapted environment 
similar pieces code main agrep program shown detected duplicates prototype tool 
assume left part original right part duplicate 
identify typical modifications duplicate 
parts code executed different circumstances lines moved statement lines 

variables expressions changed lines 

parts code inserted deleted line 

code moved different locations line 
modifications disturb structure code duplicated code complicated identify 
causes tradeoff precision amount false positives recall amount undiscovered duplicates text structure detection methods 
detect identical similar duplicates increased recall methods ignore certain properties 
may lead false positives reduced precision 
tradeoff studied 
approaches suffer duplicates symptom simple modification duplicate causes detection independent duplicates duplicate code modifications 
unmodified parts small duplicate identified 
developed approach suffer tradeoff recall precision modified duplicates detected 
approach just text syntax consider semantics 
approach fine grained program dependence graphs pdgs represent structure program data flow 
graphs try identify similar subgraph structures stemming duplicated code 
identified similar subgraphs directly mapped back program code user 
approach progress issues resolved 
ieee 
published proceedings eigth working conference reverse engineering stuttgart germany 
personal material permitted 
permission reprint republish material advertising promotional purposes creating new collective works resale redistribution servers lists reuse copyrighted component works obtained ieee 
newline init init tail inverse num matched printf snn return output buffer init init buffer 
newline init hh ll init init hh ll tail hh ll inverse num matched printf snn return output buffer init hh ll init buffer mask 

similar pieces code agrep rest structured follows section fine grained program dependence graphs contrast traditional program dependence graphs 
section formalize similar subgraphs identified attributed directed graphs 
section specific implementation evaluated section 
related section section discuss 

fine grained program dependence graphs traditional program dependence graph pdg directed attributed graph vertices represent assignment statements control predicates occur program :10.1.1.50.4405
vertices attribute marks entry vertices represent entry procedures 
edges represent dependences components program 
attributes separating edges control data dependence edges second true false control dependence edges 
control dependence edge vertex represents predicate represented evaluated second attribute edge component represented executed 
data dependence edge vertex represents component represented assigns value variable may component represented program dependence graphs kind software engineering reengineering problems main application program slicing 
pdg specialization traditional similar ast traditional pdg 
level statements expressions ast vertices mapped pdg vertices 
definitions variables procedures special vertices 
vertices may attributed class operator value 
class specifies kind vertex statement expression procedure call operator specifies kind binary expression constant value carries exact operator constant values identifier names 
vertices represents components expressions specialized edges 
components expression special control dependence call immediate control dependence targets immediate control dependence edges evaluated source evaluated 
data flow expression components represented specialized edge value dependence edge data dependence edge expression components 
specialized edge represents assignments values variables 
dependence edges similar value dependence edges show computed value stored variable 
definition definitions data control dependence 

expression vertex value dependent expression vertex value computed needed vertex 
assignment vertex dependent expression vertex value computed stored variable shows example pdg code 
void int int int example vertex entry vertex vertices formal vertices vertices formal vertices 
kind operator 
vertex compound vertex groups subgraphs assignments 
remaining vertices expression vertices different operators 
example vertex expression vertex operator kind binary value 
note assignments expressions vertex expression vertex operator assign value 
benefit fine grained program dependence graphs structural representations expressions richness attributes eases identification similar identical vertices edges 
section 

identification similar subgraphs program dependence graphs attributed directed graphs vertex attributes class operator value vertices edge attributes class label edges 
attributed directed graph tuple set vertices set edges maps vertices vertex attributes ae maps edges edge attributes 

ae mapping 

path finite sequence edges vertices limited path path attributed directed graphs isomorphic bijective mapping exists 


simple graphs means graphs isomorphic edge bijectively matched edge graph attributes edges incident vertices 
question graphs isomorphic np complete general 
simple attributed graphs shown edge labels represents complete vertex edge attributes 
single pair maximal isomorphic subgraphs exists vertices 
interested similar subgraphs isomorphic 
defining similar tricky similarity precise vague 
try define similarity graphs relaxing mapping edges consider graphs similar path graph exists path graph attributes vertices edges identical path mapped 


second restriction paths start single vertex paths 
naive approach identify maximal similar subgraphs calculate cycle free paths starting entry form form form compound form form form assign binary assign binary dependence value dependence immediate dependence data dependence assign binary 
example fine grained pdg pairwise comparison 
course infeasible 
paths length limited maximal length unusable small 
approach constructing maximal similar subgraphs induction starting vertices matching length limited similar paths 
approach feasible considers possible matchings 
cases edge consideration matched edge 
checking possible pair check complete set matching edges 
best seen example 
algorithm starts 
vertices considered endpoints matching paths length zero 

matching paths extended incident edges partitioned equivalence classes attributes 
pair equivalence classes share attributes graphs 
reached vertices marked part maximal similar subgraphs algorithm continuing sets reached vertices 

incident edges partitioned pair second pair pairs algorithm continues recursively 

reached vertices marked parts maximal similar subgraphs 
edges leaving vertices 

set pair reached vertices marked 
edges leaving vertices 

set pairs exists algorithm terminates 
algorithm marked induce maximal similar subgraphs 
accident identical union maximal isomorphic subgraphs 
general similar maximal isomorphic subgraphs 
simplified version algorithm shown 
calculates maximal similar subgraphs induced limited paths starting vertices call graphs maximal similar limited path induced subgraphs maximal similar limited path induced subgraphs possible pairs propagate endpoints similar paths 
edges leaving vertices partition equivalence classes 
corresponding add edges vertices reached edges call propagate generate initialize empty 
call propagate fv fv return result 

algorithm generate detected 
naive approach check pairs leads complexity jv independent complexity generation subgraphs self 
smarter approaches complexity reduced 
subset considered starting vertices vertices reached construction maximal subgraphs 
subset specific features vertices highly application specific 

implementation find similar code identifying maximal similar subgraphs fine grained pdgs find subset vertices pairwise construction subgraphs 
possibility entry vertices find similar procedures 
decided predicate vertices want find similar pieces code independent procedures 
pair predicate vertices maximal similar generated 
generation basically recursive implementation induction 

weighted subgraphs take subgraphs direct result just represent structural similarity achieved expensive techniques 
subgraphs large similar semantic 
reason data dependence edges may match subgraphs induced control dependence edges 
example nodes may included subgraph reached control dependence edges match similar subgraph 
possible data dependence edge included subgraph matching edge similar subgraph 
data dependence edges considered special guaranteed subgraphs similar semantic 
constructed subgraphs weighted 
simple criterion just number data dependence edges subgraphs 
evaluation section shows criterion 
sophisticated criterions possible percentage data dependence edges amount length paths induced data value dependence edges 
possibility reduce constructed subgraphs edge induced connected node induced part 
case pair nodes exists subgraph connected edge included subgraph 
planned 

infrastructure technique implemented prototype top infrastructure analyze ansi programs 
infrastructure aimed validation measurement system software complex data flow analysis techniques flow sensitive points analysis construct pdgs 
application identifying maximal similar subgraphs complex data flow techniques needed just prototype implementation readily available 
pdgs application identifying similar subgraphs just need basic data flow information 

evaluation limited technique tuned find appropriate value checked set test programs stemming different sources duplicated code 
results seen examples 
size programs terms lines code number vertices edges pdg 
different limits running times measured seconds user time spent 
direct relation size program running time exists running time dependent size amount similar subgraphs program 
due pairwise comparison expect quadratic complexity 
table columns show amount project loc edges vertices time limit sec duplicates agrep bison cdecl compiler ctags diff fft flex football patch simulator 
sizes running times test cases discovered duplicates minimum weight 
limit minimal differences exists larger 
due lack time impossible manually verify reported duplicates 
reported duplicates checked correct precision 
due complexity data flow analysis infrastructure able construct pdgs limited size 
test cases limited size 
mean technique limit plan reimplementation top different infrastructure evaluate big programs 

optimal limit insure highest possible recall high limit desirable 
possible due exponential complexity graph comparison 
claim small sufficient limit small value increase recall 
claim true test case 
typical case bison results shown 
test cases repeated limits axis 
shown duplicates axis reported specific minimum weight axis 
see small duplicates reported 
bigger small amount reported duplicates increasing fast 
bigger amount reported duplicates changing 
test case limit sufficient highest recall 
bison minimum weight limit duplicates min 
weight 
results bison 
minimum weight tunable parameter technique minimum weight similar subgraph reported 
value critical limit influence comparison 
normally possible duplicates identified independent weights minimum weight just changes amount reported duplicates 
bison test case ideal example small minimum weights duplicates reported 
bigger minimum weights changes quickly shows majority duplicates small pieces codes 
minimum weights duplicates reported 
minimum weights duplicates reported shows maximum weight duplicates 
limit bison 
running times bison limit compiler 
running times compiler ideal minimum weight test case different amounts reported duplicates varying minimum weights 
unexpected duplication different program 
minimum tuned identification finished presentation user 

running time shows times bison example increasing exponential large claimed limit ideal recall need seconds analyze bison limit 
test cases interesting behavior running time increasing exponential reverse logarithmic increased shown test case compiler 
see limits bigger amount reported duplicates stays duplicates weight bigger 
compiler minimum weight limit duplicates min 
weight 
results compiler minimum weight limit duplicates min 
weight 
results means similar paths longer edges software limit reached larger limits 
result time needed calculate similar graphs independent bigger 
needed time changing 
behavior seen test cases test cases differences running time limits 
amount reported duplicates change shown 
test case see different test limits bigger running time hours 
amount reported duplicates incredibly high weight bigger weight bigger 
extreme high numbers stemming massive code duplication particular software 
high amount files just copied slightly changed slightly different purpose 

related approach similar traditional program dependence graphs 
starting pair matching nodes construct isomorphic subgraphs ideal clones replaced function calls automatically 
approach subgraphs subtrees maximal visit node subgraph construction 
analyze big programs due limitations underlying pdg generating infrastructure 
structure comparing program observation transformed ast 
subtree ast hash value computed identical subtrees identified identical hash values 
detect similar identical subtrees subtrees pairwise compared 
authors suggest improvements similar approach 
approach obeys compares syntactical structure metrics calculated names layout expression simple control flow functions 
functions considered clones metrics similar 
identify similar functions similar pieces code 
language independent approach looking specific patterns comparison line 
text approaches 
approaches analyze large programs relying pairwise comparison 
application setting detection plagiarism programs detect program part completely duplicated 
plagiarism detecting systems comparing lexical structure programs 
system metrics studies show systems partly successful tradeoff recall precision detection plagiarism detection similar code 
opposite problem identifying similar identical parts programs identifying differences programs 
approach identify program differences program dependence graphs 
approach relies existence mapping maps vertex program vertex representing program components programs 
authors suggest special program editor keeps mapping 
approach find mapping 
matching similar attributed graphs areas computer vision graph visualization 

summary technique identifying similar code finding maximal similar subgraphs finegrained program dependence graphs 
problem solvable polynomial time limiting technique 
prototype implementation shows approach feasible non polynomial complexity problem results high precision recall 
progress obstacles remain solved high amounts duplicated code cause exploding running times 
secondly large duplicated code sections cause duplicates reported duplicates basically reported predicate 
duplicates overlapping merged reported user 
plans include reimplementation top simpler infrastructure enable evaluation large programs 
due underlying infrastructure pdg generation prototype able analyze programs limited size 
adaption prototype detection plagiarism 
education great success 
manual check needed students aware tool usage try hinder detection simple modifications 
plagiarism detection tool approach easily confused 
full evaluation precision recall 
find false positives mean aren unable check reported duplicates 
really checked recall able check test programs code duplication manually 
cross check tools desirable 
general implementation types graphs 
graphs main representation data reengineering detection similar subgraphs helpful 
implementation gxl proposed standard exchange format graphs 
automatic substitution identified duplicated code new functions macros 
underlying infrastructure contains semantic information pdgs isomorphic subgraphs identified replaced new parameterized function calls change semantic program 

und anwendung beim von 
dissertation universit passau 
german 
baker 
finding duplication near duplication large software systems 
proceedings second working conference reverse engineering 
ieee computer society press 
baxter moura anna bier 
clone detection syntax trees 
proceedings international conference software maintenance 
ducasse rieger demeyer 
language independent approach detecting duplicated code 
proceedings ieee international conference software maintenance 
holt winter sch 
gxl standard exchange format 
proceedings th working conference reverse engineering wcre 
horwitz prins reps integrating noninterfering versions programs 
acm transactions programming languages systems 
horwitz reps program dependence graphs software engineering 
proceedings fourteenth international conference software engineering 
horwitz reps binkley :10.1.1.50.4405
interprocedural slicing dependence graphs 
acm transactions programming languages systems 
oja 
comparisons attributed graph matching algorithms computer vision 
technical report university technology finland 
horwitz 
slicing identify duplication source code 
eigth international static analysis symposium sas 
kontogiannis 
evaluation experiments detection programming patterns software metrics 
proceedings fourth working conference reverse engineering 
krinke snelting 
validation measurement software application slicing constraint solving 
information software technology 
leblanc merlo 
experiment automatic detection function clones software system metrics 
proceedings international conference software maintenance 
prechelt philippsen 
finding set programs 
technical report fakult ur informatik universit karlsruhe germany 
wise 
plagiarism la mode comparison automated systems detecting suspected plagiarism 
computer journal 
wise 
detection similarities student programs yap ing may preferable plague ing 
proceedings rd technical symposium computer science education volume bulletin 
