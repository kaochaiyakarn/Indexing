system typed assembly language greg morrisett david walker cornell university karl crary carnegie mellon university neal glew cornell university motivate design typed assembly language tal type preserving translation system tal 
typed assembly language conventional risc assembly language static type system provides support enforcing high level language abstractions closures tuples user defined data types 
type system ensures typed programs violate abstractions 
addition typing constructs admit low level compiler optimizations 
translation tal specified sequence type preserving transformations including cps closure conversion phases type correct source programs mapped type correct assembly language 
key contribution approach polymorphic closure conversion considerably simpler previous 
compiler typed assembly language provide fully automatic way produce certified code suitable systems untrusted potentially malicious code checked safety execution 
categories subject descriptors software engineering software architectures languages programming languages formal definitions theory semantics syntax programming languages language classifications macro assembly languages programming languages processors compilers logics meanings programs semantics programming languages operational semantics logics meanings programs studies program constructs type structure general terms languages security theory verification additional key words phrases closure conversion certified code secure extensible systems typed assembly language type directed compilation typed intermediate languages material supported part afosr arpa radc nsf ccr ccr 
opinions findings recommendations expressed article authors reflect views agencies 
authors addresses morrisett walker glew upson hall ithaca ny usa crary school computer science carnegie mellon university forbes avenue pittsburgh pa usa 
permission digital hard copy part material fee granted provided copies distributed profit commercial advantage acm copyright server notice title publication date appear notice copying permission association computing machinery 
acm 
copy republish post servers redistribute lists requires prior specific permission fee 
morrisett 
compilers manipulate statically typed intermediate languages compelling advantages traditional compilers manipulate untyped program representations 
optimizing compiler high level language ml may passes single program performing sophisticated analyses transformations cps conversion closure conversion unboxing subsumption elimination region inference 
optimizations require type information order succeed benefit additional structure supplied typing discipline 
essence program transformations specified corresponding type translation 
types provide concise precise documentation compilation process automatically verified type checker 
practice technique invaluable debugging new transformations optimizations tarditi morrisett 
today small number compilers typed intermediate languages order realize benefits leroy peyton jones birkedal tarditi lindholm yellin shao :10.1.1.47.6555
compilers conceptual line types lost 
instance til ml compiler preserves type information approximately compilation remaining untyped 
show recode untyped portions compiler maintain type information phases compilation doing extend paradigm compiling typed intermediate languages compiling typed target languages 
target language article strongly typed assembly language tal generic risc instruction set 
type system tal surprisingly standard supporting tuples polymorphism existential packages restricted form function pointer sufficiently powerful automatically generate typed code high level ml languages 
tal framework admits conventional low level optimizations global register allocation copy propagation constant folding dead code elimination 
small number atomic code patterns tal supports code motion optimizations instruction scheduling common subexpression elimination loop invariant removal 
advanced implementation techniques supported simple typed assembly language including run time code generation intensional polymorphism array bounds check elimination 
section discuss extend type system support techniques 
tal allows reap benefits types compiler enables practical system executing untrusted code safely efficiently 
example suggested spin project bershad operating systems allow users download tal extensions kernel :10.1.1.117.6702
kernel type check tal extension ensuring accesses hidden resources kernel calls kernel routines right number types arguments forth 
type checker verified extension kernel safely assemble dynamically link 
tal system number advantages 
currently spin requires extensions system typed assembly language written single high level language modula single trusted compiler cryptographic signatures order ensure safety 
contrast kernel typed assembly language support extensions written variety high level languages variety untrusted compilers safety resulting assembly code checked independently source code compiler 
furthermore critical inner loops hand written assembly language order achieve better performance 
tal support extensible web browsers extensible servers active networks extensible system security performance language independence desired 
course type safety implies important security properties memory safety spin tal enforce important security properties termination follow type safety 
framework verifying safety properties low level programs proposed necula lee called proof carrying code pcc necula lee necula :10.1.1.40.2507:10.1.1.142.6054
necula lee encode relevant operational content simple type systems extensions order predicate logic automatically verify proofs security properties memory safety necula :10.1.1.40.2507:10.1.1.40.2507
necula lee general purpose logic encode expressive security properties permit optimizations impossible tal 
tal hand provides compiler writers higher level set abstractions pcc 
abstractions compiling languages features higher order functions data types simpler 
order pcc programmer build abstractions low level logical primitives obvious obtain compact logical encoding language constructs preserves necessary security properties 
benefit tal abstractions possible automatically reconstruct proof type safety tal binaries compact pcc binaries need contain complete proof 
clearly ideal system contains compiler support compact annotations tal flexibility pcc 
leave long term goal research focus theoretical framework automatic compilation high level languages type safe assembly language 

overview goals twofold define type system conventional assembly language prove soundness second demonstrate expressiveness resulting language showing automatically compile high level language type correct assembly code 
section give brief overview typed assembly language structure compiler 
tal primary goal tal type system provide fully automatic way verify programs violate primitive abstractions language 
conventional untyped assembly language values represented integers primitive operations language apply values 
untyped assembly language abstraction machine word 
contrast tal provides set built abstractions morrisett word sized integers pointers tuples code labels operations applicable 
example arithmetic permitted integer values dereferencing permitted pointer values control transfer permitted code labels 
say program stuck attempts perform operation 
primary goal tal type system ensure typed programs stuck 
tal treats integers separate abstraction pointers code labels arithmetic permitted integers possible show addition stuck typed tal program satisfies number important safety policies relevant security 
instance possible conclude programs manufacture pointers arbitrary objects programs jump code verified 
addition providing set built abstractions tal provides set type constructors may programmers compilers build new abstractions 
example functional language compiler sketch closures high level language abstraction encoded tal level abstractions existential type constructor 
high level language impossible program apply primitive operation closure function application 
instance impossible program inspect environment closure 
tal level closures represented pair label code environment data structure intended hold free variables 
structure connect code 
resulting object prevents malicious faulty code reading environment passing closure environment closure code 
extended type system support abstractions modules glew morrisett run time stack morrisett 
attempted keep type system simple formalism may understood proven sound powerful demonstrate high level ml language may compiled type correct tal code automatically 
typed assembly language conventional assembly language 
particular instructions standard assembly operations 
effort simplify formalism omitted typical instructions jump link may synthesized primitives 
gives example tal program control transferred label main computes factorial halts result register 
code looks behaves standard assembly code label annotated code precondition associates types registers 
precondition specifies control transferred corresponding label registers contain values specified types 
allowing jump fact main type checker ensures integer value resides register 
type preserving compiler order motivate typing constructs tal justify claims expressiveness spend large part article sketching compiler system typed assembly language main code 
entry point mov jmp fact fact code int 
compute factorial mov set loop mov jmp loop loop code int int 
product far number multiplied nonzero branch zero halt int halt result nonzero code int int 
mul multiply number sub decrement counter jmp loop fig 

tal program computes factorial 
variant polymorphic lambda calculus tal 
compiler structured translations typed calculi cps conversion closure conversion hoisting allocation code generation tal calculus class programming language sense translation operates correctly typed program input calculus 
translations assume input output preceding translation 
fact frees compiler optimize code aggressively translation steps 
inspiration phases ordering derived sml nj appel macqueen appel turn rabbit steele orbit kranz compilers compiler uses types compilation :10.1.1.55.9444
rest article proceeds describing languages translations compiler detail 
give syntax static semantics language type preserving translations 
middle calculi features common 
describe full successive calculus defined terms differences preceding 
presenting compiler source language section 
section describes intermediate language gives typed cps translation harper lillibridge 
cps translation fixes order evaluation names intermediate computations 
section presents gives typed closure translation considerably simpler minamide 
closure translation construction functions environments closures explicit rendering data structures explicit 
followed simple hoisting translation lifts closed code top level 
morrisett section presents allocation initialization data structures explicit gives translation point compilation intermediate code essentially lambda calculus syntax assembly language ideas wand 
section presents formal details typed assembly language 
show type safety tal define translation tal 
section discuss extensions tal support additional language constructs optimizations 
describe current implementation tal discuss directions investigation 

system source language compiler variant system girard reynolds polymorphic calculus augmented integers products recursion terms 
syntax appears types int annotated terms terms fix pe primitives type contexts value contexts xn integers base type introduced integer literals operated arithmetic primitives eliminated conditional expression 
term evaluates zero evaluates 
notation refer vector syntactic objects drawn syntactic class example shorthand tuple en elimination form tuples evaluates ith field tuple recursive functions written fix wherex name recursive function may appear free body argument type body type 
polymorphic functions written abstracted type body polymorphic function 
example polymorphic identity function may written 
fix id instantiation polymorphic expression written 
usual consider types expressions differ names bound variables identical 
write capture avoiding substitution 
interpret conventional call value operational semantics 
static semantics specified set inference rules concluding judgments form isa context containing free type variables context assigns types free variables 
second judgment asserts type formed type context 
judgments denote empty type value context 
simplify presentation translations type annotated terms unannotated terms marked types 
decision allows translations simple syntax directed fashion making dependent structure typing derivations 
typing rules ensure system typed assembly language ftv int fix ei en int int int pe int fig 

static semantics annotations formed term correct 
interest clarity omit type annotations informal discussions examples 
running example consider compiling term computes factorial fix int int 

cps conversion compilation stage conversion continuation passing style cps 
stage names intermediate computations eliminates need control stack 
unconditional control transfers including function invocation return achieved function call 
target calculus phase called types annotated values int void values fix xn primitives declarations pv terms halt type contexts value contexts xn code nearly linear consists series bindings followed function call 
exception construct forms tree containing subexpressions 
abstraction mechanism fix abstracts type value variables simplifying rest compiler 
corresponding morrisett ftv int void xn fix xn void vi vn int int int pv void vi vn int halt fig 

static semantics types combined 
abbreviate void void abbreviate fix xn xn appear free omit empty type argument brackets fix forms applications 
functions return values function calls just jumps 
function notation void intended suggest fact 
control returned caller caller pass callee continuation function invoke 
execution completed construct halt accepts result value type terminates computation 
typically construct top level continuation 
expressions return values typing judgments values state types 
new judgment indicates term formed type value contexts 
aside issues static semantics standard appears 
translation cps translation takes harper lillibridge appears 
type translation written 
principal translation terms takes continuation computes value hands value second term translation full programs calls principal translation special top level continuation int system typed assembly language def def int def void def void def def void def halt def yk def ik fix def fix def 

def def xk def 
xn 
def 
yk pe def int 
int 
px int int def int 
int fig 

translation accepts final answer halts 
translation variables assumed fresh order avoid variable capture 
important property translation translates formed expressions formed expressions lemma cps conversion type correctness 

translation follow particular effort optimize resulting code 
realistic compiler type systems discuss section integrate optimizations translations 
instance realistic cps converter eliminate administrative redices optimize tail recursion danvy filinski :10.1.1.42.4772
factorial example coded 
code obtained morrisett conjunction optimizations mentioned 
fix int int void 
int 
int 
halt int 
simplified polymorphic closure conversion second compilation stage closure conversion closures explicit separating program code data 
done steps 
main step closure conversion proper rewrites functions contain free variables 
variables appear free function taken additional arguments function 
additional arguments collected environment paired closed code create closure 
function calls performed extracting code environment closure calling code environment additional argument 
second step hoisting code blocks lifted top program achieving desired separation code data 
code blocks closed hoisting done difficulty 
closure conversion proper hoisting step considered section 
operational explanation closure conversion quite simple number subtle issues involved type checking resulting code 
absence polymorphic functions approach typing closure conversion minamide observe functions type different free variables different environment types naively typed closure conversion types closures 
prevent existential types mitchell plotkin types environments hiding fact closures environments different types 
presence polymorphism functions may free type variables free value variables just free value variables closure conversion rewrite functions take free type variables additional arguments 
approach dealing issue diverges minamide desire interpretation polymorphism types constructed passed data run time 
type passing interpretation additional type arguments collected type environment type level equivalent value environment discussed earlier 
type environments necessitate complex mechanisms kinds hide differences type environments translucent types ensure code blocks called correct type environments 
propose considerably simpler approach polymorphic closure conversion 
avoid complexities type environments adopt type erasure interpretation polymorphism definition standard ml milner 
type erasure interpretation need save contents free type variables type environment substitute directly code blocks 
semantically amounts making copies code blocks relevant additional syntactic constructs types system typed assembly language values pack declarations unpack terms replace typing rule fix xn replaced void xn fix xn xn void typing rule replaced void vi vn additional typing rules void shorthand void unpack pack def void def void void fig 

changes substitutions performed 
types ultimately erased copies represented term run time resulting runtime cost 
formally means type erasure interpretation consider partial application function type argument value 
example suppose type void type variables stand function free type variables type variables function ordinary type arguments 
contents free type variables partial instantiation considered value type void 
instantiation takes place construction type environment 
minamide arose til compiler morrisett uses run time type information optimize data layout tarditi 
type erasure semantics precludes optimizations 
crary shows encode run time type information type erasure language 
manipulating types directly programs manipulate values represent types 
device type environment part value environment closure conversion may performed similar fashion described 
mechanisms added tal optimizations compiler targeting 
presents differences principal difference body function type check context containing formal arguments 
words code blocks closed desired 
discussed morrisett type instantiation value form 
add existential types mitchell plotkin support typing closures 
note type erasure interpretation type portion existential package pack erased run time creation package run time cost 
translation closure conversion algorithm formalized 
translation types denoted interesting rule function types void void existentially quantified variable represents type value environment closure 
closure pair consisting piece code instantiated types free type variables value environment 
instantiated code takes arguments original type value arguments value environment 
closures invoked extracting code environment closure applying code environment function arguments 
term translation parts terms cexp declarations values cval 
uniformity translations provide program translation case simply invokes term translation 
avoid variable capture variables assumed fresh 
may show translation preserves formedness programs lemma closure conversion type correctness 

hoisting closure conversion functions closed may hoisted top level difficulty 
real compiler phases combined separated simplicity 
target hoisting translation calculus longer value form 
code blocks defined letrec prefix call heap anticipation heaps tal 
change precise 
programs translated replacing fix expressions fresh variables binding variables corresponding code expressions heap 
translation denoted straightforward formalize omit formalization interest brevity 
lemma hoisting type correctness 

examples closure conversion hoisting appear figures 
gives factorial example closure conversion hoisting simplifying optimizations beta reduction copy propagation 
illustrate polymorphic closure conversion consider example polymorphic higher order function twice takes function composes 
twice function contains nested functions int void cexp cexp vn cexp cexp halt pv system typed assembly language def def int def void def def cexp def cexp def unpack cval code code code cval cval vn code def cval cexp cexp def halt cval def cval def cval def cval cval cval def xc cval def ic cval vn def cval cval vn cval fix xn def pack env vcode code env fv fix xn ftv fix xn env env void code vcode env void fix env xn 
pack env env code env env ym env cexp ym env fig 

translation contains free type variable closure conversion part type environment functions 
consequently type argument ordinary type argument type arguments code blocks code code stand free type variables instantiated appropriately closures formed code blocks 
morrisett syntax changes values delete fix xn heap values code xn programs letrec xn hn typing rule fix replaced heap value rule code xn code xn void xn new typing rule xn hi xn letrec xn hn xi xj fig 

changes letrec main factorial code block code env int 
true branch continue unpack false branch recurse env pack int cont code cont code code block continuation factorial computation code env int int 
open environment env env compute 
continue unpack halt code code block top level continuation code env int 
halt int pack halt code int void fig 

factorial 
explicit allocation intermediate language atomic constructor forming tuples machines allocate space tuple fill field field allocation stage process explicit 
eliminate value form tuples introduce new declaration forms allocating initializing tuples shown 
creation element tuple computation separated allocation step initialization steps 
example source twice 


fx source twice void 
void 

void void system typed assembly language translation letrec env void 
pack create closure unpack cenv cenv env 
env pack create closure unpack env 
env env unpack void void fig 

polymorphic example 
integers pair created follows types added clarity int int malloc int int int int int int malloc int int step allocates uninitialized tuple binds address tuple 
superscripts types fields indicate fields uninitialized projection may performed morrisett syntax changes types 
replace initialization flags values delete declarations 
malloc heap values 
typing rule projection replaced typing rule tuples replaced heap value rule vi new typing rules shorthand vn malloc def def fig 

changes fields 
step updates field tuple value binds address tuple 
note assigned type field superscript indicating field initialized 
step initializes second field tuple binds address tuple assigned fully initialized type int int allowed code sequence need atomic may rearranged interleaved projections typed manner 
initialization flags types ensure field projected initialized 
syntactic value restriction ensures unsoundness presence polymorphism 
operationally declaration interpreted imperative operation sequence andx aliases location different types 
consequently initialization flags prevent field initialized twice 
possible monads wadler launchbury peyton jones linear types girard wadler ensure tuple initialized exactly avoided approaches interest simpler type system 
presence uninitialized values raises garbage collection issues section discuss implementation deals issues 
translation system typed assembly language translation types simple amounts adding initialization flags field tuple types def term translation formalized translations full programs heap values expressions aexp declarations values aval 
focus translation rule generalizes informal translation tuples previous section 
rule returns sequence declarations allocate initialize tuple 
values unchanged translation return sequences declarations needed construct values 
sequences empty value question contains tuple 
similarly declaration translation produces sequence declarations 
avoid variable capture variable assumed fresh 
lemma allocation type correctness 

factorial example application explicit allocation translation appears 

typed assembly language final compilation stage code generation converts tal 
major typing constructs tal code generation largely syntactic 
summarize type structure point combined abstraction mechanism may simultaneously type environment set type arguments set value arguments 
values types may partially applied type environments remain values 
existential types support closures data abstractions 
tuples flags fields indicating field initialized 
key technical distinction tal uses alpha varying variables tal uses register names labels records alpha vary 
assume infinite supply registers 
mapping language finite number registers may performed spilling registers tuple reloading values tuple necessary 
consequences aspect tal calling convention code generation calling conventions explicit types 
tal includes type rn describe entry points code blocks tal analog function type void 
key difference assign fixed registers arguments code 
intuitively jump block code type type variables suitably instantiated registers rn contain values type respectively 
distinction tal mechanism variables identifying values tal follows real machines distinguishes labels may thought pointers registers 
registers may register file may viewed record register names field labels 
morrisett def int def int void def void def def letrec xn hn def letrec xn hn aexp code xn def code xn aexp aexp aexp vn aexp aexp halt pv unpack aval aval aval aval pack aval un def aexp def dn aval di aval def vi aexp aexp aval def halt aval def aval def aval def pv di aval def unpack vi aval def xa def ia def aval def pack aval def dn malloc yn di aval ui fig 

translation contain word values integers pointers 
tuples code blocks large values heap allocated 
heap objects identified labels may reside registers 
manner tal layout data memory explicit 
remainder section syntax tal section dynamic semantics section full static semantics section 
system typed assembly language letrec main factorial code block code env int 
true branch continue unpack false branch recurse malloc int malloc int int void int cont code cont code env pack int cont code code block continuation factorial computation code env int int 
open environment env env continue unpack halt code code block top level continuation code env int 
halt int malloc malloc malloc int void halt code halt code pack int void fig 

factorial translation tal section 
tal syntax syntax tal 
tal machine state program triple consisting heap register file sequence instructions 
heap mapping labels heap values tuples code blocks 
register file mapping registers word values 
heaps register files respective types syntactically correct repeat labels registers 
appears notation represents register file binding replaced ifr appear indicated binding simply added similar notation heaps register file types heap types 
morrisett types int initialization flags heap types register file types rn type contexts registers word values pack small values pack heap values wn code heaps hn register files rn wn instructions add rd rs ld rd rs mul rd rs st rd rs sub rd rs unpack rd instruction sequences jmp halt programs fig 

syntax tal 
heap values word values labels point 
word values integers instantiations word values existential packages junk values operational semantics represent uninitialized data 
small value word value register instantiated packed small value 
draw distinction word values small values register contain word register 
code blocks linear sequences instructions set type variables state register assumptions 
sequence instructions terminated jmp halt instruction 
expressions differ alpha variation bound type variables considered identical expressions differ order fields heap register file heap register file type 
tal operational semantics operational semantics tal deterministic rewriting system maps programs programs 
discussed ultimately intend type erasure interpretation erase types operational semantics may easily state prove subject reduction theorem lemma 
erase types instructions meaning intuitively clear correspondence conventional assembly language instructions 
malloc instructions discussed 
intuitively ld rd rs instruction loads ith component counting tuple bound label rs places word value rd conversely st rd rs places word value rs ith position tuple bound label rd instruction jmp value form transfers control code bound label instantiating abstracted type variables code 
instruction tests value see zero 
control continues instruction control transferred system typed assembly language rs rd rs similarly mul sub andh code andh code ld rd rs rd wi rs wn rd rd st rd rs wi rs wi wn rd wn unpack rd rd pack pack pack fig 

operational semantics tal 
jmp instruction 
instruction unpack rd value form pack evaluated substituting remainder sequence instructions currently executed binding register rd value erased unpack instruction reduces simple mov instruction 
malloc rd allocates fresh uninitialized tuple heap binds rd address tuple 
course real machines provide primitive malloc instruction 
intention types erased malloc expanded fixed instruction sequence allocates tuple appropriate size 
instruction sequence prevents optimization reordering interleaving underlying instructions surrounding tal code 
instruction sequence tal 
tal static semantics purpose static semantics specify programs formed ensure formed programs get stuck 
programs closed self contained expressed judgment tal formedness program defined formedness components heap register file instruction stream 
consequently formation judgments required heaps register files instruction sequences turn require judgments various sorts values types 
static semantics tal appears figures consists judgments summarized morrisett judgment meaning tal formed type tal formed heap type tal formed register file type tal subtype tal register file subtype tal formed heap heap type tal formed register file register file type tal formed heap value type tal wval formed word value type tal formed word value flagged type type tal formed small value type tal formed instruction sequence tal formed program fig 

tal static semantic judgments 
elaborated 
large number judgments reflection large number syntactic classes inherent semantic complexity 
static semantics inspired follows conventions morrisett harper gc judgments specify formedness conditions types define subtyping relationships 
judgments include type context indicates type variables scope 
heaps heap types closed result judgments include type contexts 
subtyping judgments intended support subtyping usual generality expanded 
allow forgetting information 
judgment tal instance possible forget field tuple initialized 
subject reduction argument lemma necessary initialized tuple old uninitialized type 
register file subtyping judgment possible forget contents registers 
possible jump code block registers defined 
rest judgments check formedness term constructs 
heaps register files may contain free type variables judgments include type context 
values heap mutually recursive heap type typing heap sound separately require heap types formed 
judgments assigning types values 
addition judgment sort value judgment assigning flagged types word values junk value may assigned regular type may assigned flagged type sort value may contain heap heap values may contain free type variables small values may contain registers 
consequently heap value formation requires heap type word value formation adds type context small value formation adds type context register file type 
central result type safety tal programs formed programs tal tal tal type ftv tal tal tal reflex tal tal system typed assembly language tal tal tal tal rn trans tal tal tal tal tal weaken tal tal rm rn tal tal tal reg heap prog tal tal tal tal tal tal hi tal hn tal wi wval tal rm wm rn fig 

static semantics tal miscellaneous 
get stuck formed terminal configurations operational semantics form halt 
terminal configurations considered stuck 
type safety follows usual subject reduction progress theorems 
proofs appendix 
theorem subject reduction 
tal tal theorem progress 
tal exists form halt 
corollary type safety 
tal stuck code generation translation tal appears figures 
type translation tal straightforward 
point interest translation function types assign registers value arguments void def rn interesting part term translation translation morrisett tal tal wval tal tal tal wi tuple tal wn code tal tal tal code label tal tal wval int tal int wval tapp word tal tal wval tal wval pack word tal tal wval tal pack wval init tal wval tal reg val word val tal uninit tal tal tapp val tal tal tal pack val tal tal tal pack fig 

static semantics tal values 
tal wval tal tions 
informally declarations translated instruction sequences follows mapped mov rx mapped sequence mov rx ld rx rx 
pv mapped sequence mov rx arith rx rx appropriate arithmetic instruction 
unpack mapped unpack rx malloc rx 
mapped sequence mov rx mov rtemp st rx rtemp 
vn mapped sequence mov rtemp mov rtemp mov rtemp vn mov rtemp mov rn rtemp jmp rtemp note arguments moved immediately registers rn registers may arguments 
mapped sequence mov rtemp rtemp tal system typed assembly language tal rs int tal int arith rd int tal tal arith rd rs arith add mul sub tal int tal tal tal tal tal rs ld rd tal tal ld rd rs malloc tal rd tal tal mov tal rd tal sto tal mov rd tal rd tal rs rd tal tal st rd rs unpack tal rd tal tal unpack rd jmp tal tal halt tal jmp tal tal halt fig 

static semantics tal instructions 
bound heap code translation ei ii type variables contained register file type corresponding free variables 
halt mapped sequence mov halt formal translation uses mapping tracks label register implement term variable 
discussed terms implemented conditional branch new code block representing clause 
new code blocks heap allocated translations terms translations heap values contain terms return addition heap instruction sequence 
translation terms track current type context register file type order place information new code blocks resulting terms 
lemma code generation type correctness 
tal 
composing translations cps conversion closure conversion hoisting allocation code generation obtain translation tal 
type correctness composite translation follows preceding type correctness morrisett int void def def int def rn def def letrec xn hn def xn hi hi exp distinct code xn vn val val val val pack lemmas 
def code rn xn rn exp def vn def def def def pack val fig 

translation tal expressions 
corollary compiler type correctness 
tal 
tal factorial factorial computation translated tal appears 
obtain code shown standard optimizations applied particular clever automatable register allocation removal redundant moves 
efficiency version unsatisfactory efficient version obtained improving source program tail recursion optimizing intermediate language programs eliminating unnecessary closure creation hand coding highly optimized version directly tal 
extensions practice previous sections provide theoretical basis compiling high level languages typed assembly language 
section discuss issues arise putting technology practice 
exp exp exp pv exp unpack exp malloc exp def exp vn exp exp halt system typed assembly language def exp fresh def ld exp fresh def val int texp arith add arith sub arith mul fresh def unpack exp fresh def exp fresh val val st exp fresh def val vn fresh rn def val hi ii exp ei code fresh def halt fig 

translation expressions tal 
morrisett 
fact code int 
nonzero unpack zero branch call ld project code ld project environment mov jmp jump env nonzero code int 
sub malloc int create environment cont st store environment st store environment malloc int int int create cont closure mov cont st store cont code st store environment mov arg mov pack int type environment jmp fact call fact env cont cont code int int 
contains 
ld retrieve ld retrieve mul 
unpack unpack ld project code ld project environment jmp jump env 
halt code int 
mov halt int halt result malloc create empty environment malloc create empty environment malloc int create halt closure mov halt st store halt code st store halt environment mov load argument mov pack type environment jmp fact call fact halt int fig 

typed assembly code factorial 
implementation system typed assembly language order investigate applicability approach realistic modern programming languages implemented version tal intel bit architecture ia intel compilers number different source languages including safe language morrisett higher order dynamically typed language subset scheme 
compilers standard ml small object oriented language development 
talx target language compilers strongly typed version ia assembly language 
type checker verifies standard assembly code type annotations complex instructions malloc assembly language macros 
assembler processes annotated code assembly code expanding instruction macros definitions dictate erasing types translates assembly code concrete machine instructions 
implemented assembler extending produced typed object files 
typed object files include code data segments type segment similar necula lee code proof segments pcc binaries necula :10.1.1.40.2507:10.1.1.40.2507
implemented tool reads talx files type checks assembles object files invokes 
talx type system type system described article enriched variety standard constructs including floats sums arrays recursive types higher order type constructors 
order deal floating point values correctly presence polymorphism kind structure distinguishes types objects bits wide pointers integers types objects possibly sizes 
polymorphic type variable bit kind objects type passed generalpurpose registers tuple offsets may computable fields appearing 
hand general kind type type checker tell large objects type operations disallowed 
support separate compilation type safe linking augmented typed assembly language module system glew morrisett 
tal interface file specifies types terms tal implementation file defines 
types may opaque support information hiding modularity transparent allow information sharing admit cross module optimizations 
system performs series checks ensure implementations formed interfaces compatible complete 
interface compatibility completeness verified assemble code described invoke standard untyped linker 
deal creation examination exception packets talx includes type tagging mechanism glew 
basic idea freshly created heap pointers may associated type tag unknown type tested tag known type 
test succeeds unknown type refined known type 
tags implement exception packet existentially packaged pair containing tag hidden type serving exception name value type 
talx contains support compiling objects 
type system morrisett general notion subtyping article includes usual contravariant rule code right extension depth subtyping tuples variance mechanism arrays 
furthermore type tagging mechanism tag objects class 
mechanism provides way implement casting 
talx contains necessary constructs admit simple object encodings developing theoretical practical tools need admit efficient object encodings 
article describes cps compiler compilers built stack compilation model 
standard continuations exceptions allocated stack stack store spilled temporary values 
details stack typing discipline discussed morrisett 
primary mechanisms follows 
size stack types contents specified stack types code blocks indicate stack types describing state stack expect 
code typically expected stacks varying size functions may quantify stack type variables resulting stack polymorphism 
combination stack types register typing discipline allows model standard calling convention 
arguments results continuations return addresses may placed registers stack implementer may specialize conventions known functions better register allocation 
real machines finite amount heap space 
straightforward link talx conservative garbage collector boehm weiser reclaim dead heap values 
worth noting conservative collection sound 
conservative collectors assumptions way pointers programs untyped assembly language programs violate 
tal type system guarantees assumptions hold labels strong abstraction labels synthesized integers operations pointer arithmetic disallowed 
tal guarantees gc constraints hold values constraints constructed 
example tal disallows pointers middle objects ensures alignment constraints obeyed 
support accurate collector require introducing tags may distinguish pointers integers require type passing interpretation tolmach morrisett harper :10.1.1.141.5654
case ensure values properly tagged fully initialized potential garbage collection site 
believe feasible devise type system ensure constraints seriously investigated option 
remain directions tal improved 
important array manipulation efficient 
order ensure safe access arrays talx uses complex instructions expand real instructions perform subscript update operations checking array offset bounds 
bounds checks eliminated current tal framework 
result array intensive applications suffer performance penalties java just time compilers time perform analyses eliminate checks 
xi xi system typed assembly language pfenning shown eliminate array bounds checks effectively dependent types 
talx extended similar constructs 
implemented prototype version checks eliminated added compiler support generating code unchecked array subscripts 
important direction augment compiler data layout optimizations til compiler tarditi 
discussed section optimizations require programs ability analyze types run time directly compatible type erasure interpretation adopted 
optimizations permissible augmenting talx language tal programs construct values represent types analyze values necessary crary 
believe translations operationally correct searching robust proofs correctness 
similar cps danvy filinski closure conversion minamide translations proven correct results easily extend languages include recursive types objects :10.1.1.141.7192
principal problem arguments inductively defined type indexed logical relations source target language terms 
extending framework supports recursive types objects difficult relations longer constructed simple inductive fashion 
syntactic proof correctness possible constructed arguments cps closure conversion phases proofs overly specific details translation 
security conscious applications require translations operationally correct fully 
hope research proof theory similar systems eventually allow construct arguments 
avenues research include extension type system level generality pcc dependent type theory investigation support required compile java classes objects tal exploration type theoretic mechanisms performing explicit memory management 

summary compiler system statically typed assembly language 
type system assembly language ensures source level abstractions closures polymorphic functions enforced machine code level 
furthermore type system may preclude advanced optimizations common compiler introduced low level optimizations register allocation instruction selection instruction scheduling largely unaffected 
furthermore programmers concerned efficiency hand code routines assembly long resulting code passes type checker 
consequently tal provides foundation high performance computing environments untrusted code checked safety executed 
appendix lemma context strengthening 
morrisett 
tal tal tal tal 
proof 
part immediate type 
part induction derivations 
lemma subtyping regularity 
tal tal tal proof 
induction derivations 
lemma heap extension 
tal tal tal tal tal tal tal tal tal tal tal tal tal tal wval tal wval tal tal 
proof 
part immediate 
part follows parts 
parts induction derivations 
lemma heap update 
tal tal tal tal tal tal tal tal tal tal tal tal tal tal wval tal wval tal tal 
proof 
part immediate subtyping regularity 
part follows parts 
parts induction derivations 
interesting case case rule label 
derivation tal tal wval clearly inference holds 
suppose hypothesis context strengthening deduce tal may proven trans rule follows tal tal tal tal wval system typed assembly language lemma register file update 
tal tal wval tal 
proof 
suppose rn wn rm may may rn 
tal reg case tal wi wval 
certainly ri wehave tal wi wval hypothesis tal wval rule reg tal 
lemma canonical heap forms 
tal code tal 
wn tal wi proof 
inspection 
lemma canonical word forms 
tal tal wval int 
code tal 
wn tal wi 
pack tal wval 
proof 
inspection 
induction derivation tal wval derivation label tapp word rule 
suppose 
tal 
inspection subtyping rules reveals 
tal may deduce tal 
follows canonical heap forms 
alternatively suppose derivation ends tapp word 
tal wval 
follows induction 
derivation tal wval shown label rule 
tal say 
inspection subtype rules reveals morrisett form 
tal may deduce tal 
wn tal wi canonical heap forms 
remains show tal wi 
suppose immediate 
tal wi shown init rule permits deduction tal wi 
inspection 
lemma typing 
tal tal tal wval 
proof 
proof induction syntax consider cases case immediate 
case rule type reg val rule requires 
rule type reg rule requires tal wval 
follows 
case 
rule type tapp val tal induction deduce tal wval rule tapp word proves tal wval 
result follows 
case pack rule type pack val tal 
induction deduce tal wval rule pack word proves tal pack wval 
result follows pack pack lemma canonical forms 
tal tal tal int 
code tal 
wn tal wi 
pack tal wval 
proof 
immediate typing canonical word forms 
lemma type substitution 
tal tal tal tal tal system typed assembly language tal wval tal wval tal tal tal tal tal tal 
proof 
induction derivations 
interesting case case rule type ftv tal hypothesis proven rule type ftv 
consequently ftv ftv ftv 
may prove tal type rule 
lemma register file weakening 
tal tal tal 
proof 
inspection rules weaken reg 
theorem subject reduction 
tal tal proof 
form 
td derivation tal consider cases jmp case jmp 
td form tal tal tal tal tal jmp tal operational semantics andh code tal td 
tal tal follows register file weakening tal 
canonical forms follows tal tal type substitution conclude tal 
case add mul sub 
td form tal tal tal rs int tal int tal tal rd rs tal rd int 
operational semantics rd rs 
morrisett 
tal td 
canonical forms follows rs integer literals tal rs int wval 
conclude tal register file update 
tal td 
case 
td form tal tal tal int tal tal tal tal tal tal follows tal td 
reasoning exactly case jmp 
case ld 
td form tal tal tal rs tal tal ld rd rs tal rd 
operational semantics rd wi rs wm tal td 
canonical forms follows tal rs tal wj inspection init rule tal wi wval 
register file conclude tal 
tal td 
case malloc 
td form tal tal tal tal tal malloc rd tal rd 
operational semantics rd tuple uninit rules may deduce tal 
heap extension follows tal 
type reflex label rules may deduce tal wval 
heap extension deduce tal follows register file update tal 
heap extension tal case mov 
td form tal tal tal tal tal mov tal system typed assembly language 
operational semantics 
tal td 
typing follows tal tal wval 
register file update conclude tal 
tal td 
case st td form tal tal tal rd tal rs tal tal tal st rd rs rd 
operational semantics wi rs wi wm rd wm tal rd case rd tal andr rd may deduce tal wval 
judgment proven label rule tal note follows subtyping regularity definition tal say 
inspection subtyping rules reveals form tal tal 
tal may deduce 
tal wj heap update follows tal wj typing heap update may deduce tal rs wval applying init tuple rules may conclude tal wi rs wi wm 
tal heap update 
heap update may deduce tal 
recall tal 
tal wval register file update may conclude tal rd 
heap update tal morrisett case unpack 
td form tal tal tal tal tal unpack tal operational semantics pack tal td 
canonical forms follows tal tal wval 

register file update follows tal 
type substitution follows tal tal theorem progress 
tal exists orp form halt tal wval tal 
proof 
suppose 
td derivation tal proof cases instruction 
case halt td form tal tal tal tal halt tal halt typing may deduce defined tal wval 
words tal wval 
case add mul sub td form tal tal tal rs int tal int tal rd rs tal canonical forms rs andr represent integer literals 
rd rs 
case td form tal int tal tal tal tal tal canonical forms integer literal code 

case jmp td form tal tal tal tal jmp tal system typed assembly language canonical forms code 
case ld td form tal tal tal rs tal ld rd rs tal canonical forms rs wn rd wi 
case malloc suppose form malloc forsome case mov td form tal tal tal tal mov tal typing defined 

case st td form tal tal tal rd tal rs tal st rd rs tal canonical forms rd wn typing rs defined 
wi rs wi wn 
case unpack td form tal tal tal tal unpack tal canonical forms pack 

grateful dan grossman dexter kozen frederick smith stephanie weirich steve zdancewic anonymous referees helpful comments suggestions 
appel 
compiling continuations 
cambridge university press new york ny usa 
appel macqueen 
standard ml new jersey 
rd international symposium programming language implementation logic programming wirsing ed 
springer verlag new york ny usa 
volume lecture notes computer science 
morrisett bershad savage pardyak sirer fiuczynski becker chambers eggers 
extensibility safety performance spin operating system 
th acm symposium operating systems principles 
acm press new york ny usa 
birkedal rothwell tofte turner 
ml kit version 
tech 
rep department computer science university copenhagen 
boehm weiser 
garbage collection uncooperative environment 
softw 
pract 
exper 
sept 
crary weirich 
flexible type analysis 
acm sigplan international conference functional programming 
acm press new york ny usa 
appear 
crary weirich morrisett 
intensional polymorphism type erasure semantics 
acm sigplan international conference functional programming 
acm press new york ny usa 
danvy filinski 
representing control study cps transformation 
math 
struct 
comput 
sci 
dec 
muller turbak wells 
strongly typed flow directed transformations 
acm sigplan international conference functional programming 
acm press new york ny usa 
girard 

une extension de interpr tation de del analyse son application de coupures dans analyse la th orie des types 
proceedings second scandinavian logic symposium fenstad ed 
north holland 
girard 

interpr tation fonctionelle des coupures de arithm ordre sup 
ph thesis universit 
girard 

linear logic 
theor 
comput 
sci 

glew 
type dispatch named hierarchical types 
acm sigplan international conference functional programming 
acm press new york ny usa 
glew morrisett 
type safe linking modular assembly language 
th acm sigplan sigact symposium principles programming languages 
acm press new york ny usa 
harper lillibridge 
explicit polymorphism cps conversion 
th acm sigplan sigact symposium principles programming languages 
acm press new york ny usa 
intel 

intel architecture software developer manual 
intel box mt prospect il 
kranz kelsey rees hudak philbin adams 
orbit optimizing compiler scheme 
proceedings acm sigplan symposium compiler construction 
acm press new york ny usa 
launchbury peyton jones 
state haskell 
lisp symb 
comput 
dec 
leroy 
unboxed objects polymorphic typing 
th acm sigplan sigact symposium principles programming languages 
acm press new york ny usa 
lindholm yellin 
java virtual machine specification 
addison wesley menlo park ca usa 
milner tofte harper macqueen 
definition standard ml revised 
mit press cambridge ma usa 
minamide morrisett harper 
typed closure conversion 
rd acm sigplan sigact symposium principles programming languages 
acm press new york ny usa 
mitchell plotkin 
types existential type 
acm trans 
program 
lang 
syst 
july 
morrisett crary glew grossman samuels smith walker weirich zdancewic 
talx realistic typed assembly language 
acm system typed assembly language sigplan workshop compiler support system software 
inria research report vol 

inria centre de diffusion inria bp le chesnay cedex france 
morrisett crary glew walker 
stack typed assembly language 
workshop types compilation 
lecture notes computer science vol 

springer verlag berlin germany 
morrisett harper 
semantics memory management polymorphic languages 
st workshop higher order operational techniques semantics gordon pitts eds 
publications newton institute 
cambridge university press cambridge uk 
morrisett tarditi cheng stone harper lee 
til ml compiler performance safety types 
acm sigplan workshop compiler support system software 
necula 
proof carrying code 
th acm sigplan sigact symposium principles programming languages 
acm press new york ny usa 
necula 
compiling proofs 
ph thesis school computer science carnegie mellon university pittsburgh pa usa 
available cmu technical report cmu cs 
necula lee 
safe kernel extensions run time checking 
nd usenix symposium operating system design implementation 
usenix berkeley ca usa 
peyton jones hall hammond partain wadler 
glasgow haskell compiler technical overview 
proc 
uk joint framework information technology technical conference 

reynolds 
theory type structure 
programming symposium 
lecture notes computer science vol 

springer verlag new york ny usa 
shao 
overview flint ml compiler 
workshop types compilation 
boston college computer science department technical report vol 

boston college fulton hall room hill ma usa 
steele jr 
rabbit compiler scheme 
thesis mit 
tarditi morrisett cheng stone harper lee 
til type directed optimizing compiler ml 
acm sigplan conference programming language design implementation 
acm press new york ny usa 
tolmach 
tag free garbage collection explicit type parameters 
acm conference lisp functional programming 
acm press new york ny usa 
wadler 
comprehending monads 
acm conference lisp functional programming 
acm press new york ny usa 
wadler 
linear types change world 
programming concepts methods broy jones eds 
north holland sea israel 
ifip tc working conference 
wadler 
taste linear logic 
mathematical foundations computer science 
lecture notes computer science vol 

springer verlag poland 
wand 
correctness procedure representations higher order assembly language 
proceedings mathematical foundations programming semantics brookes ed 
lecture notes computer science vol 

springer verlag new york ny usa 
xi 
dependent types practical programming 
ph thesis school computer science carnegie mellon university pittsburgh pa usa 
xi pfenning 
eliminating array bound checking dependent types 
acm sigplan conference programming language design implementation 
acm press new york ny usa 
xi pfenning 
dependent types practical programming 
th acm sigplan sigact symposium principles programming languages 
acm press new york ny usa 
received december revised december accepted march 
