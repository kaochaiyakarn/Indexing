syntactic versus computational views approximability sanjeev khanna rajeev motwani madhu sudan umesh vazirani stanford university stanford university ibm research berkeley attempt reconcile distinct views approximation classes syntactic computational 
syntactic classes max snp permit structural results natural complete problems computational classes apx allow classes problems approximability understood 
results provide syntactic characterization computational classes give computational framework syntactic classes 
compare syntactically defined class max snp computationally defined class apx show problem apx placed approximation preserving reduction problem max snp 
methods introduce simple general technique creating approximation preserving reductions show approximable problem reduced approximation preserving manner problem hard approximate corresponding factors 
reduction follows easily non approximability results max problems 
demonstrate generality technique applying classes rmax min pi clique problem set cover problem respectively complete problems 
syntactic nature max snp yannakakis provide approximation algorithms problem class 
provide alternate approach demonstrating result syntactic nature max snp 
develop general paradigm non oblivious local search useful developing simple efficient approximation algorithms 
show algorithms find approximations max snp problems yielding approximation ratios comparable best known variety specific max snp hard problems 
non oblivious local search provably performs standard local search degree approximation achieved efficiency resulting algorithms 
keywords approximation algorithms complete problems computational complexity computational classes polynomial reductions local search 
ams subject classification 
department computer science stanford university stanford ca sanjeev theory stanford edu 
supported nsf ccr schlumberger foundation fellowship 
department computer science stanford university stanford ca rajeev theory stanford edu 
supported alfred sloan research fellowship ibm faculty development award nsf young investigator award ccr matching funds ibm schlumberger foundation shell foundation xerox 
ibm watson research center yorktown heights ny madhu watson ibm com 
computer science division berkeley ca vazirani cs berkeley edu 
supported nsf ccr 
preliminary version appeared 
approximability np optimization npo problems investigated past definition different types problem classes syntactically defined classes max snp class npo problems expressible bounded arity constraint satisfaction problems computationally defined classes apx class npo problems constant factor approximation polynomial time see section formal definitions 
useful obtaining structural results natural complete problems allows classes problems approximability completely determined 
attempt develop linkages views approximation problems obtain new insights types classes 
show natural generalization max snp renders identical class apx 
validates papadimitriou yannakakis definition max snp providing structural basis study approximability 
side effect resolve open problem identifying complete problems max np 
techniques extend generic theorem create approximation hierarchy 
develop generic algorithmic paradigm guaranteed provide approximations max snp problems may applications 
background motivation wide variety classes defined directly polynomial time approximability problems contained apx constant factor approximable problems ptas problems polynomialtime approximation schemes problems fully polynomial time approximation schemes 
advantage working classes defined approximability criterion allows problems approximability understood 
crescenzi able exhibit complete problems classes particularly apx 
unfortunately complete problems rare artificial provide insight natural problems class 
research direction find approximation preserving reductions known complete artificial problems classes natural problems view understanding approximability 
second family classes npo problems studied defined syntactic considerations syntactic characterization np due fagin 
research direction initiated papadimitriou yannakakis followed ranjan kolaitis thakur led identification approximation classes max snp rmax min pi 
syntactic prescription definition classes proved useful establishment complete problems 
results arora lund motwani sudan szegedy established hardness approximating complete problems max snp specific constant factors np 
natural wonder hardest problems syntactic sub class apx bear relation np 
computational view allows precisely classify problems approximability yield structural insights natural questions certain problems easier approximate 
canonical structure hardest representative problems approximation class 

furthermore intuitively speaking view facilitate identification reductions establish natural complete problems class 
syntactic view hand essentially structural view 
syntactic prescription gives natural way identifying canonical hard problems class performing approximation preserving reductions establish complete problems 
attempts trying find class mentioned properties natural complete problems capturing problems specified approximability successful 
typically focus relax syntactic criteria allow wider class problems included class 
cases inevitable classes expressive encompass problems approximability 
syntactically defined approximation classes strictly contained class npo strict containment shown syntactic considerations 
result show classes contains separated np 
expect class nature missing problems case current definitions 
explore different direction studying structure syntactically defined classes look closure approximation preserving reductions 
idea looking closure class implicit papadimitriou yannakakis state minimization problems placed classes reductions maximization problems 
advantage looking closure set maintains complete problems set managing include closure problems reduction simply polynomial time algorithm compute exact solution 
interesting example compare closure max snp denoted max snp apx 
positive resolution max snp apx immediately imply non existence ptas max snp hard problems known ptas strict subset apx np 
hand unconditional negative result difficult obtain imply np 
resolve question affirmative 
exact nature result obtained depends precise notion approximation preserving reduction define closure class max snp 
strictest notion reductions available literature reductions due papadimitriou yannakakis 
slight extension reduction call reductions 
reductions define class max snp show equals apx pb class polynomially bounded np optimization problems approximable constant factors 
slightly looser definitions approximation preserving reductions particular ptas reductions crescenzi extended include apx max snp 
build result identify interesting hierarchy approximability classes 
interesting side effect results positive answer question papadimitriou yannakakis max np complete problems 
syntactic view useful obtaining structural complexity results developing paradigms designing efficient approximation algorithms 
demonstrated papadimitriou yannakakis show approximation algorithms problem max snp 
exploit syntactic nature max snp develop paradigm designing approximation algorithms problems class provide alternate computational view 
refer paradigm non oblivious local search modification standard local search technique 
show max snp problem approximated constant factors algorithms 
turns performance non oblivious local search comparable best known approximation algorithms interesting representative problems max snp 
intriguing possibility coincidence hint universality paradigm variant thereof 
results related extent ausiello 
define class glo guaranteed local optima npo problems property locally optimum solutions ratio value global local optimum bounded constant 
follows glo subset apx shown fact strict subset 
show max snp problem contained glo establishing max snp contained glo 
contrasts notion non oblivious local search guaranteed provide constant factor approximations problems max snp 
fact results indicate non oblivious local search significantly powerful standard local search delivers strictly better constant ratios provide constant factor approximations problems glo 
independently similar local search technique approximation specific problem contained glo max snp 
summary results section definitions required state results particular definitions reduction apx apx pb max snp max snp 
section show max snp apx pb 
generic theorem allows equate closure syntactic classes appropriate computational classes outlined section develop approximation hierarchy result 
notion non oblivious local search non oblivious glo developed section 
section illustrate power non obliviousness showing oblivious local search achieve performance ratio max sat allowed search exponentially large neighborhoods contrast simple non oblivious local search algorithm achieves performance ratio 
establish paradigm yields gamma approximation max sat 
section provide alternate characterization max snp class problems called max csp 
shown simple non oblivious algorithm achieves best known approximation problem providing uniform approximation max snp 
section illustrate power class algorithms showing achieve best known ratio specific max snp problem vertex cover contained glo 
implies max snp contained glo glo strict subset non oblivious glo 
section apply approximating traveling salesman problem 
section apply technique improving long standing approximation bound maximum independent sets bounded degree graphs 
preliminaries definitions npo problem pi instance pi jij denote length opt denote optimum value instance 
solution value solution denoted assumed polynomial time computable function takes positive integer values see precise definition npo 
definition error solution instance npo problem pi define error max ae opt opt oe gamma notice definition error applies uniformly maximization problems levels approximability 
definition performance ratio approximation algorithm optimization problem pi performance ratio instance pi jij solution satisfies max ae opt opt oe solution value multiplicative factor optimal value referred approximation 
performance ratio computes solution error gamma 
reductions describe precise approximation preserving reduction 
reduction call reduction essentially reduction papadimitriou yannakakis differs relatively minor aspect 
definition reduction problem pi reduces problem pi denoted pi pi exist polynomial time computable functions constant fi ffl maps instance pi instance pi opt opt related polynomial factor exists polynomial opt jij opt 
ffl maps solutions solutions fie approximation preserving reductions literature reduction appears strictest 
reduction appears slightly weaker allows polynomial scaling problems stricter known reductions 
reductions reductions qualify approximation preserving reductions definitions particular fit definitions reductions reductions crescenzi 
having pi pi implies pi approximable pi fact reduction preserving reduction 
reduction applied levels approximability 
case existing definitions preserving reduction literature 
example preserving reduction reduction crescenzi unrestricted scope share important property reduction 
note crescenzi showed exists problem pi ptas problem pi apx pi pi undesirable situation problem pi ptas preserving reduction problem pi ptas 
reduction papadimitriou yannakakis enforces condition optima instance pi linearly related optima instance pi mapped 
appears unnatural restriction considering reduction allowed arbitrary polynomial time computation 
real difference reduction reduction reduction linearity relation satisfied reduction 
intuitively study approximability desirable attribute simply errors corresponding solutions closely linearly related 
somewhat artificial requirement linear relation optimum values precludes reductions problems related scaling factor 
instance desirable problems objective functions simply related fixed polynomial factor inter reducible reasonable definition approximation preserving reduction 
relaxation reduction constraint motivated precisely consideration 
class npo problems 
notion reduction define hardness completeness problems respect closure polynomially bounded sub class 
definition hard complete problems problem pi said hard problems pi pi pi hard problem pi said complete addition pi definition closure closure denoted set npo problems pi pi pi pi closure operation maintains set complete problems class 
definition polynomially bounded subset polynomially bounded subset denoted pb set problems pi exists polynomial instances pi opt jij 
computational syntactic classes define basic computational class apx 
definition apx npo problem pi class apx exists polynomial time algorithm pi performance ratio bounded constant class apx pb consists polynomially bounded npo problems approximated constant factors polynomial time 
apx denote class npo problems approximable factor obtain hierarchy approximation classes 
instance poly apx log apx classes npo problems polynomial time algorithms performance ratio bounded polynomially logarithmically respectively input length 
precise versions definitions provided section 
briefly review definition syntactic classes 
definition max snp max np max snp class npo problems expressible finding structure maximizes objective function jf phi gj denotes input consisting finite universe finite set bounded arity predicates finite structure phi quantifier free order formula 
class max np defined analogously objective function jf phi gj natural extension associate weight tuple modified objective find maximizes phi denotes weight associated tuple example max sat max sat problem collection clauses boolean variables clause precisely literals find truth assignment satisfying maximum weight collection clauses 
fixed integer max sat belongs class max snp 
results papadimitriou yannakakis adapted show max sat complete reductions class max snp 
definition rmax rmax class npo problems expressible finding structure maximizes objective function jf gj phi single predicate phi quantifier free cnf formula occurs times clause occurrences negative 
results ranjan adapted show max clique complete reductions class rmax 
definition min pi min pi class npo problems expressible finding structure minimizes objective function jf gj phi single predicate phi quantifier free cnf formula occurs times clause occurrences positive 
results kolaitis thakur adapted show set cover complete reductions class min pi 
max snp closure apx pb section establish theorem examine implications 
proof results arora efficient proof verifications 
theorem max snp apx pb 
weakness max snp captures polynomially bounded apx problems removed looser forms approximation preserving reduction defining closure 
particular crescenzi trevisan define notion ptas preserving reduction apx apx pb 
result conjunction theorem easily seen max snp apx 
weaker reduction necessary allow reductions fine grained optimization problems coarser polynomially bounded optimization problems cf 

surprising consequence theorem 
theorem max np max snp 
papadimitriou yannakakis implicitly introduced closure classes conjecture 
interesting see equality shown independent result arora 
obtain resolution problem posed papadimitriou yannakakis finding complete problems max np 
theorem max sat complete max np 
sub sections establish max snp apx pb 
idea reduce minimization problem apx maximization problem reduce maximization problem apx pb specific complete problem max snp viz max sat 
reduction forces problems involved related polynomial factors easy see max snp apx pb 
combining facts obtain theorem 
reducing minimization maximization observe fact pi belongs apx implies existence approximation algorithm constant opt theta opt henceforth denote 
reduce pi apx pb maximization problem pi apx pb obtained merely modifying objective function pi follows 
pi objective function max gamma cv instances solutions pi 
clearly takes positive values 
ensure integer valued assume loss generality integer real valued performance ratio rounded integer 
verified optimum value instance pi lies 
approximation algorithm pi solution instance pi error ffi want construct solution instance pi error fi ffi fi 
show fi 
consider case ffi gamma 
case simply output solution 
trivially done observe gamma gamma fie hand may proceed follows 
ffi error solution optimum pi opt ffi gamma ffi op opt optimal value conclude gamma gamma opt ffi theta opt theta opt ffi theta opt opt ffi opt solution pi error ffi solution pi error ffi implying reduction fi 
np languages max sat theorem adapted result arora lund motwani sudan szegedy critical reduction maximization problems max sat 
theorem language np instance sigma compute polynomial time instance max sat properties 

formula clauses depends 
exists constant ffl independent input gamma ffl clauses satisfied truth assignment 

completely satisfiable 

truth assignment satisfies gamma ffl clauses 
truth assignment satisfies gamma ffl clauses truth assignment satisfies completely alternatively witness showing constructed polynomial time 
properties may immediately obvious construction arora lund motwani sudan szegedy 
easy verify provide reduction properties 
property obtained fact assignments satisfy clauses close terms hamming distance valid codewords linear code uniquely error corrected codeword obtained corrupted code word satisfy clauses property requires bit care provide brief sketch may ensured 
idea revert back pcp model redefine proof verification game 
suppose original game properties exists proof verifier accepts probability verifier accepts probability 
augment game adding proof th bit prover uses follows bit set prover chooses play old game effectively giving game 
verifier turn looks th bit proof 
set performs usual verification tosses unbiased coin accepts turns heads 
clear exists proof verifier accepts 
proof cause verifier accept probability greater 
setting th bit prover create proof verifier accepts probability exactly 
proof system transformed cnf formula desired form 
reducing maximization max sat established loss generality need worry maximization problems pi apx pb 
consider problem pi polynomial time algorithm delivers approximation pi constant 
instance pi ca bound optimum value obtained running input note may stronger bound priori polynomial bound optimum value instance length jij 
important consequence opt 
generate sequence np decision problems fij opt ig instance create formulas reduction theorem ith formula obtained np language consider formula features 
ffl number satisfiable clauses exactly max gamma ffl mp opt ffl guaranteed theorem 
ffl assignment satisfies gamma ffl mp clauses construct polynomial time solution value see observe assignment clauses satisfy gamma ffl clauses formulas largest index happens clearly furthermore property theorem construct truth assignment satisfies completely 
truth assignment obtain solution order complete proof remains shown truth assignment error ffi satisfies max ffi clauses find solution error fi ffi constant fi 
show possible fi cffl ffl 
main idea finding solution second property find solution truth assignment suppose solution satisfies max ffi clauses 
max ffi gamma ffi max max gamma ffl mp opt second feature construct solution gamma ffi max gamma gamma ffl mp gamma ffi opt gamma ffi ffl gamma ffi ffl opt suppose ffi gamma ffl ffl 
ffi ffi ffl fl ffi gamma ffi 
readily seen opt fl fl cffl ffl ffi hand ffi 
gamma ffl ffl error solution obtained running approximation algorithm pi gamma cffl ffl ffi choosing fi cffl ffl immediately obtain solution larger value error 
reduction reduction 
generic reductions approximation hierarchy section describe generic technique turning hardness result approximation preserving reduction 
start listing kind constraints imposed hardness reduction approximation class optimization problem 
observe restrictions obeyed known hardness results corresponding approximation classes 
definition additive problems npo problem pi said additive exists operator polynomial time computable function maps pair instances instance opt opt opt maps solution pair solutions respectively 
definition downward closed family family functions ff said downward closed constants particular integers implies function said hard family exists constant function said complete hard definition apx downward closed family class apx consists polynomially bounded optimization problems approximable ratio jij function definition canonical hardness np maximization problem pi said canonically hard class apx exists transformation mapping instances sat instances pi constants gap function hard family instance sat variables instance pi properties 
ffl sat opt ffl sat opt 
ffl solution truth assignment satisfying polynomial time 
definition transformation sat pi somewhat special specify size optimum reduced problem produce mapped instance desired size 
additional property easily obtained additive problems sufficient number additions till optimum reduced problem close target optimum adding problem known optimum value reduced problem 
canonical hardness np minimization problems analogously defined opt formula satisfiable opt ng 
solution value ng construct satisfying assignment polynomial time 
reduction theorem downward closed family functions additive npo problem omega canonically hard class apx pb problems apx pb reduce omega proof pi polynomially bounded optimization problem apx approximable algorithm omega problem shown hard factor hard denote objective functions pi omega respectively 
start special case pi omega maximization problems 
describe functions constant fi required reduction 
pi instance size pick 
describe reduction need specify functions function defined follows 

mc denote np language fij opt ig 
create instance oe omega size opt oe 
define oe oe construct function instance pi solution compute solution manner 
find solution compute second solution follows 
largest index solution projects solution instance oe oe 
turn implies find solution witness solution yields larger objective function value 
show reduction reduction fi gamma 
ff opt observe opt nm ff gamma ff consider cases case case solution error ff gamma suffices argue error solution oe ff gamma fi 
start upper bound oe 
oe nm gamma approximation factor achieved oe nm ff gamma ff nm gamma gamma ff gamma gamma gamma ff gamma fi case solution error fi ffl solution oe error ffl 
case flm 
note fl error solution ff gamma fl fl 
bound value solution oe oe nm fl gamma fl error oe ff gamma ff fl gamma fl gamma ff gamma fl fl fl gamma ff gamma fl fl fi final inequality follows fact fl gamma gamma fi 
case find virtue solution error fi ffl solution oe error ffl 
consider general cases pi omega maximization problems 
case minimization problems transformation works minor change 
creating oe np language consists instances exists case pi minimization problem omega maximization problem reduce pi maximization problem pi proceed 
reduction proceeds follows 
pi polynomially bounded optimization problem compute upper bound value solution instance bound instance objective function pi instance defined easy verify pi apx implies pi apx 
solution instance pi error fi 
show solution instance pi error fi 
assume loss generality fi 
gamma opt fi opt multiplying opt get opt gamma fi implies opt gamma theta opt gamma fi theta rearranging fi opt gamma fi opt reduction pi pi reduction 
remaining case pi maximization problem omega minimization problem dealt similarly transform pi minimization problem pi theorem appears merge different notions relative ease approximation optimization problems 
notion consider problem pi easier pi exists approximation preserving reduction pi pi different notion regard pi easier pi better factor approximation 
statement essentially states comparisons 
instance max clique problem chromatic number problem poly apx inter reducible 
observation motivates search interesting function classes class apx may contain interesting optimization problems 
applications consequence 
theorem rmax poly apx 
set cover canonically hard approximate factor omega gamma log apx min pi 
briefly sketch proof theorem 
hardness reduction max sat clique canonical 
classes apx pb poly apx log apx expressible classes apx downward closed function families 
problems max sat max clique set cover additive 
apply theorem 
point known instances hardness results shown problems additive 
particular true max snp problems max clique chromatic number set cover 
cases hardness result directly apply additive problem longest path bin packing 
case closely related longest path problem easily seen additive hardness result essentially stems problem 
case bin packing admit ptas hardness result multiplicative nature fact problem approximated arbitrarily small factors provided small additive error term allowed 
yields reason problem additive 
lastly interesting optimization problems additive problems related graph bisection partition happen notable instances hardness approximation results achieved 
local search max snp section formal definition paradigm non oblivious local search 
idea local search implicitly known techniques interior point methods 
formalize idea context max snp illustrate application max snp problems 
max snp problem pi recall goal find structure maximizes objective function phi 
subsequent discussion view dimensional boolean vector 
classical local search start reviewing standard mechanism constructing local search algorithm 
ffi local algorithm pi distance function hamming distance dimensional vectors 
ffi neighborhood structure ffi fs ffi universe 
structure called ffi optimal ffi 
algorithm computes ffi optimum performing series greedy improvements initial structure iteration moves current structure ffi better value 
constant ffi ffi local search algorithm polynomially bounded npo problem runs polynomial time ffl local change polynomially computable ffl number iterations polynomially bounded value objective function improves monotonically integral amount iteration optimum polynomially bounded 
non oblivious local search non oblivious local search algorithm tuple hs di initial solution structure independent input real valued function referred weight function real valued distance function returns distance structures appropriately chosen metric 
weight function number distinct values taken polynomially bounded input size 
distance function structure fixed ffi ffi computed time polynomial jsj 
classical local search constant ffi non oblivious ffi local algorithm terminates time polynomial input size 
classical local search paradigm call oblivious local search natural choice function distance function chooses hamming distance 
show choice yield approximation ratio 
formalize notion general type local search 
definition non oblivious local search algorithm non oblivious local search algorithm ffi local search algorithm weight function defined phi constant phi quantifier free order formulas profits real constants 
distance function arbitrary polynomial time computable function 
non oblivious local search implemented polynomial time way oblivious local search 
note considering polynomially bounded weight functions profits fixed independent input size 
general non oblivious weight functions direct search direction actual objective function 
fact see exactly reason powerful allow better approximations 
define classes npo problems 
definition oblivious glo class problems oblivious glo consists approximated constant factors oblivious ffi local search algorithm constant ffi definition non oblivious glo class problems non oblivious glo consists npo problems approximated constant factors non oblivious ffi local search algorithm constant ffi perfectly reasonable allow weight functions non linear stay definition purposes 
allowing constant number predicates weight functions enables prevent encoding arbitrarily complicated approximation algorithms 
structure natural metric distance function hamming distance 
fact classical local search hamming metric useful proving negative results paradigm 
contrast definition non oblivious local search allows distance functions hamming metric proving positive results remainder 
useful modify example modifying hamming distance complement vector considered distance 
convenient assume local search best possible move bounded neighborhood arbitrary move improves weight function 
believe increase power non oblivious local search 
power non oblivious local search show exists choice non oblivious weight function max sat assignment optimal respect weight function yields performance ratio gamma respect optimal 
obtain tight bounds performance oblivious local search max sat establishing performance significantly weaker best known result allowed search exponentially large neighborhoods 
notation fixed truth assignment set clauses exactly literals true set clauses denotes total weight clauses oblivious local search max sat show strong separation performance oblivious non search max sat 
suppose ffi local strategy weight function total weight clauses satisfied assignment 
theorem shows ffi oblivious ffi local strategy deliver performance ratio better 
surprising willing allow near exponential time oblivious algorithm 
theorem asymptotic performance ratio oblivious ffi local search algorithm max sat positive ffi 
ratio bounded ffi may take value 
proof show existence input instance max sat may elicit relatively poor performance ratio ffi local algorithm provided ffi 
construction input instance assume ffi 
input instance comprises disjoint union sets clauses say gamma gamma gamma gamma defined gamma jn gamma jn gamma iffi gamma ffi jn clearly gamma gamma gamma delta gamma gamma gamma delta gamma ffi ffi 
loss generality assume current input assignment 
satisfies clauses gamma gamma clauses gamma gamma satisfied 
flip assignment values ffi variables precisely gamma clauses gamma gamma number clauses gamma gamma flipped variable occurs variable 
hand flipping assigned values ffi variables satisfy gamma clauses gamma gamma show 
pi ffi denote set clauses variables iffi ffi ffi claim 
lemma assignment values variables ffi variables assigned value false satisfy gamma clauses pi ffi 
proof prove simultaneous induction ffi statement true instance pi ffi ffi non negative integers ffi base case includes trivially verified true allowable value ffi ffi 
assume statement true instance pi ffi ffi consider instance pi ffi 
statement trivially true ffi 
consider ffi ffi fz jk choice ffi variables assertion trivially true 
assume 
delete clauses containing variables pi ffi get instance pi gamma ffi gamma 
consider cases 
case case reduced problem finding upper bound maximum number clauses satisfied setting variables false pi gamma ffi gamma 
ffi gamma may inductive hypothesis conclude gamma gamma clauses satisfied 
assertion holds case 
may directly inductive hypothesis ffi case observe inductive hypothesis setting gamma variables pi gamma ffi gamma false satisfies gamma gamma gamma gamma clauses assigning value false set variables satisfy gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma gamma clauses 
assertion holds case 
case case satisfies clause remaining gamma variables satisfy gamma gamma gamma gamma clauses inductive hypothesis pi gamma ffi gamma 
adding terms see assertion holds 
case analyze case 
satisfy precisely gamma clauses remaining gamma variables satisfy gamma gamma gamma gamma clauses inductive hypothesis 
assertion holds 
satisfies precisely gamma clauses remaining gamma variables satisfy gamma gamma gamma gamma clauses inductive hypothesis 
summing terms get gamma upper bound total number clauses satisfied 
assertion holds case 
see bound tight simply consider situation variables set false gamma ffi 
total number clauses satisfied ji gamma gamma assuming clause weight lemma allows conclude ffi local algorithm increase total weight satisfied clauses starting assignment 
optimal assignment hand satisfy clauses choosing vector 
performance ratio ffi local algorithm say ffi bounded ffi gamma gamma gamma gamma gamma gamma gamma delta ffi ffi gamma ffin gamma delta ffi ratio asymptotically converges 
show bound tight local algorithm achieves 
intriguing observation ffi ratio ffi bounded 
see local algorithm ensures performance ratio consider optimal assignment ff denote set clauses containing variable literal clause ff satisfied similarly fi denote set clauses containing variable precisely literal satisfied clause fi furthermore precisely literal containing variable complement value assigned variable exactly set clauses ff satisfied set clauses fi longer satisfied 
optimal case ff fi 
sum inequality variables get inequality ff fi 
observe ff fi clause gets counted twice clause gets counted exactly 
fractional weight number clauses satisfied local assignment bounded performance ratio achieved local algorithm bounded 
combining upper bound derived earlier conclude 
concludes proof theorem 
non oblivious local search max sat illustrate power non oblivious local search showing achieves performance ratio max sat local search simple non oblivious weight function 
theorem non oblivious local search achieves performance ratio max sat 
proof non oblivious weight function consider assignment optimal respect weight function 
loss generality assume variables renamed unnegated literal gets assigned value true 
respectively denote total weight clauses containing literals respectively 
optimal assignment variable satisfy equation 
gamma gamma summing inequality variables obtain inequality immediately implies total weight unsatisfied clauses local optimum times total weight clauses 
algorithm ensures performance ratio 
result achieved oblivious weight function modifying distance function corresponds distances hypercube augmented edges nodes addresses complement 
generalization max sat design non oblivious weight function max sat local strategy ensures performance ratio gamma 
weight function form coefficients specified 
theorem non oblivious local search achieves performance ratio gamma max sat 
proof loss generality assume variables renamed unnegated literal assigned true current truth assignment 
set set clauses unnegated literals 
delta gamma gamma denote change current weight flip value set 
easy verify equation gamma delta delta gamma gamma delta gamma gamma delta algorithm terminates know summing values fact iw gamma get inequality 
delta gamma delta gamma gamma delta delta determine values delta coefficient term left hand side unity 
verified delta gamma gamma gamma delta gammai achieves goal 
coefficient right hand side equation gamma 
clearly weight clauses satisfied bounded times total weight clauses 
worthwhile note regardless value chosen coefficient local search csp max snp introduce class constraint satisfaction problems problems max snp exactly equivalent problems class 
furthermore problem class approximated constant factor non oblivious local search algorithm 
constraint satisfaction problems syntactic description optimization non oblivious local search problem called max csp captures problems max snp special case 
definition ary constraint fz set boolean variables 
ary constraint size subset ft fg ft fg ary boolean predicate 
definition max csp collection cm weighted ary constraints variables fz max csp problem find truth assignment satisfying maximum weight sub collection constraints 
theorem shows max csp problem universal max snp problem contains special cases problems max snp 
theorem fixed max csp max snp 
pi max snp 
constant pi max csp problem 
csp instance corresponding instance problem computed polynomial time 
proof proof part implicit theorem concentrate proving part 
goal obtain representation csp problem max snp syntax max jfx phi gj input structure ft fg max farg fz max contains integers mg predicate arg encodes sets predicate eval encodes predicates described 
ffl arg ary predicate true rth argument variable ffl eval ary predicate true evaluates true ft fg 
structure defined ftrueg true unary predicate denotes assignment truth values variables vector components called convenience 
intention refer arguments sth constraint 
remains specify quantifier free formula phi 
basic idea phi evaluate true conditions satisfied ffl arguments constraint variables order ffl values variables truth assignment specified constraint satisfied 
formula phi sub formulas ensuring conditions 
arg ft fg eval true easy see sub formula desired effect checking correspond arguments second sub formula considers possible truth assignment variables checks particular set values assigned structure evaluate true 
fixed structure exactly choice constraint phi evaluate true happens constraint satisfied 
value solution particular truth assignment structure exactly number constraints satisfied 
shows max snp problem value intended csp problem 
things need checked ensure valid max snp formulation 
notice predicates bounded arity structures consist bounded number predicates independent input size max 
length formula exponential independent input 
non oblivious local search max csp suitable generalization non oblivious local search algorithm max sat yields result 
theorem non oblivious local search algorithm performance ratio max csp 
proof approach similar previous section design non oblivious weight function weighted version max csp problem local algorithm yields performance ratio problem 
consider constraints satisfying assignment 
constraint replaced monomial conjunction literals monomial evaluates true corresponding literal assignment represents satisfying assignment constraint 
furthermore monomial precisely satisfying assignment 
assign monomial weight constraint represents 
assignment variables satisfies monomials total weight satisfies constraints original problem total weight denote monomials true literals assume weight function form 
assuming variables renamed current assignment gives value true variable know variable equation 
fact optimal assignment summing values write inequality 
delta gamma gamma delta gamma delta delta determine values delta coefficient term left hand side unity 
verified delta gamma delta gamma achieves goal 
coefficient right hand side equation gamma 
clearly total weight clauses satisfied times total weight clauses satisfiable assignment 
conclude theorem 
theorem optimization problem pi max snp approximated constant factor uniform non oblivious local search algorithm max snp non oblivious glo problem expressible csp performance ratio non oblivious versus oblivious glo section show exist problems constant factor approximation obtained ffi local search algorithm oblivious weight function allow ffi grow input size 
simple local search algorithm appropriate non oblivious weight function ensure constant performance ratio 
max csp problem instance max csp collection monomials monomial precisely literals 
objective find assignment maximize number monomials satisfied 
show instance problem ffi exists instance local optima value vanishingly small fraction global optimum 
input instance consists disjoint union sets monomials say gamma gamma defined gamma jn gamma iffi jn clearly gamma gamma delta gamma gamma gamma ffi delta consider truth assignment 
satisfies monomials gamma monomials gamma claim assignment ffi optimal respect oblivious weight function 
see observe complementing value ffi variables ffip monomials gamma ffi 
hand satisfy precisely gamma delta monomials gamma ffi ffip gamma delta ffi local optimum 
optimal assignment hand satisfies monomials gamma ffi performance ratio achieved ffi local algorithm gamma delta gamma gamma ffi delta asymptotically diverges infinity ffi 
seen section local non oblivious algorithm ensures performance ratio problem 
problem max snp obtain theorem 
theorem exist problems max snp ffi ffi local oblivious algorithm approximate constant performance ratio max snp oblivious glo vertex cover ausiello shown vertex cover belong class glo exist constant ffi oblivious ffi local search algorithm compute constant factor approximation 
fact example show ffi performance ratio ensured ffi local search asymptotically diverges infinity 
show exists simple non oblivious weight function ensures factor approximation local search 
fact algorithm simply enforces behavior standard approximation algorithm iteratively builds vertex cover simply including points currently uncovered edge 
assume input graph structure feg set vertices theta encodes edges graph 
solution represented ary predicate iteratively constructed represent maximal matching 
clearly points maximal matching constitute valid vertex cover vertex cover twice large vertex cover graph 
encoding vertex cover computed algorithm 
algorithm starts initialized empty relation iteration new pair included 
non oblivious weight function hx zi phi gamma phi gamma phi phi phi phi encode valid matching graph observations 
ffl relation obtained deleting edge including edge incident edge including non existent edge property 
local search move relation encode valid matching ffl hand relation corresponds encoding matching larger matching encoded 
encode maximal matching exist relation neighborhood larger weight 
observations combined fact start valid initial matching empty matching immediately allow conclude optimal relation encodes maximal matching established 
theorem local search algorithm non oblivious weight function achieves performance ratio vertex cover problem 
theorem glo strict subset non oblivious glo aside seen algorithm performance starting arbitrary initial solution 
relation encoding matching input graph deleting violating members strictly increases 
traveling salesman problem tsp problem traveling salesman problem restricted complete graphs edge weights clearly satisfies triangle inequality 
papadimitriou yannakakis showed problem hard max snp 
natural weight function tsp weight tour show local algorithm yields performance ratio 
algorithm starts arbitrary tour iteration checks exist disjoint edges tour deleting replacing edges yields tour lesser cost 
theorem local search algorithm oblivious weight function achieves performance ratio tsp 
proof optimal solution permutation vertices occur order consider optimal solution unit cost edge associate unit cost edge follows 
consider edges claim unit cost 
suppose tour obtained simply deleting inserting edges cost optimal contradiction 
uo denotes set unit cost edges uc set unit cost edges form image uo mapping 
edge uc image unit cost edges incident tour edges uo map ju ju cost cost ju gamma ju ju gamma ju fact bound shown tight 
maximum independent sets bounded degree graphs input instance maximum independent set problem bounded degree graphs denoted mis graph degree vertex bounded constant delta 
algorithm performance ratio delta delta gamma delta problem delta 
algorithm uses local search algorithms larger independent sets computed algorithms gives claimed performance ratio 
refer algorithms framework algorithm characterized local algorithm weight function simply ji gamma theta ej 
start initialized empty set easy see iteration correspond independent set convenient way looking algorithm follows 
define swap process deleting vertices including vertices set gamma set iteration algorithm performs swap swap 
swap interpreted applications swaps 
algorithm may viewed executing swap swap iteration 
algorithm terminates operations applicable 
denote optimal independent set produced algorithm furthermore optimal independent set useful observations 
ffl vertex swap performed implies vertex gamma incoming edge ffl similarly swaps performed implies ji gamma vertices gamma precisely edge coming jo gamma gamma ji gamma joj gamma ji vertices gamma edges entering set straightforward consequence observations lemma 
lemma algorithm performance ratio delta mis 
proof observations imply minimum number edges entering vertices gamma ji gamma joj gamma ji 
hand maximum number edges coming vertices vertices gamma bounded ji gamma delta 
ji gamma delta ji gamma joj gamma ji rearranging get ji joj delta jx delta gamma joj delta yields desired result 
nearly matches approximation ratio delta due hochbaum 
noted result holds broader class graphs viz claw free graphs 
graph called claw free exist independent set size larger vertices independent set adjacent vertex 
lemma applies delta claw free graphs 
objective improve ratio algorithm combination algorithm lemma uses slightly different counting argument give alternative bound approximation ratio algorithm constraint size optimal solution 
lemma real number delta algorithm performance ratio delta gamma mis optimal value delta gamma jv delta 
proof noted earlier vertex gamma edge coming set joj gamma ji vertices edges coming inequality satisfied ji delta jv gamma ji joj gamma ji ji jv joj delta 
observe jv joj delta delta gamma joj joj delta gamma jv delta 
lemma shows algorithm yields better approximation ratio size optimal independent set relatively small 
algorithm simply classical greedy algorithm 
algorithm conveniently included framework directed local search 
denote set neighbors vertices weight function simply ji delta jv gamma gamma theta ej delta 
difficult see starting empty independent set local algorithm directed search weight function simply simulates greedy algorithm 
greedy algorithm exploits situation optimal independent set relatively large size 
fact existence large independent set ensures large subset vertices relatively small average degree 
lemmas characterize performance greedy algorithm 
lemma suppose exists independent set average degree vertices bounded ff 
ff greedy algorithm produces independent set size jx ff 
proof greedy algorithm iteratively chooses vertex smallest degree remaining graph deletes vertex neighbors graph 
examine behavior greedy considering types iterations 
consider iterations picks vertex outside suppose ith iteration picks vertex gamma exactly neighbors set remaining graph 
vertices edges incident loose edges incident suppose iterations occur observe secondly consider iterations greedy selects vertex loose vertices independent set 
total size independent set constructed greedy algorithm jx gamma cauchy schwartz inequality ff jx rearranging obtain ff jx gamma ff jx jx ff ff jx gamma ff jx ff ff jx gamma ff ff ff result follows 
lemma delta non negative real number delta gamma delta delta gamma performance ratio delta gamma mis optimal value delta gamma jv delta 
proof observe average degree vertices bounded jv gamma oj delta joj fact joj delta gamma jv delta know algorithm computes independent set size joj ff ff delta deltac delta gamma ff 
sufficient determine range values take inequality satisfied joj ff delta gamma joj substituting bound value ff rearranging terms equation yields quadratic equation gamma delta gamma delta gamma delta strictly bounded delta quadratic equation satisfied choice delta gamma delta delta gamma delta 
combining results lemmas choosing largest allowable value get result 
theorem approximation algorithm simply outputs larger independent sets computed algorithms performance ratio delta delta gamma delta mis 
performance ratio claimed essentially delta 
improves long standing approximation ratio delta due hochbaum delta 
flurry new results problem 
berman furer algorithm performance ratio delta ffl delta delta ffl odd delta ffl fixed constant 
radhakrishnan shown algorithm run clique free graphs yields independent set size delta 
combine algorithm clique removal scheme achieve performance ratio delta 
note khanna motwani vishwanathan shown semidefinite programming technique obtain delta log log delta log delta approximation algorithm problem 
kolaitis helpful comments suggestions giorgio ausiello crescenzi guiding intricacies approximation preserving reductions available literature 
anonymous referees detailed comments corrections previous draft 

new local search approximation techniques maximum generalized satisfiability problems 
proceedings nd italian conference algorithms complexity pp 

arora lund motwani sudan szegedy 
proof verification hardness approximation problems 
proceedings rd annual ieee symposium foundations computer science pp 

ausiello crescenzi 
approximate solution np optimization problems 
theoretical computer science pp 

ausiello 
local search reducibility approximability np optimization problems 
inform 
process 
lett pp 

bellare goldwasser lund russell 
efficient probabilistically checkable proofs applications approximation 
proceedings fifth annual acm symposium theory computing pp 

berman furer 
approximating maximum independent set bounded degree graphs 
proceedings fifth annual acm siam symposium discrete algorithms pp 

crescenzi 
theory complexity 
prentice hall new york 
crescenzi 
completeness approximation classes 
information computation vol 
pp 

crescenzi trevisan 
approximation scheme preserving reducibility applications 
th conference foundations software technology theoretical computer science lecture notes computer science pp 
fagin 
generalized order spectra polynomial time recognizable sets 
richard karp ed complexity computer computations ams 
feige goldwasser lov asz safra szegedy 
approximating clique np complete 
proceedings nd annual ieee symposium foundations computer science pp 

michael garey david johnson 
computers intractability guide theory npcompleteness 
freeman 
michel goemans david williamson 
approximation algorithms max cut max sat 
proceedings sixth acm symposium theory computing pp 

radhakrishnan 
improved approximations independent sets bounded degree graphs 
nordic journal computing pp 

hochbaum 
efficient bounds stable set vertex cover set packing problems 
discrete applied mathematics vol 
pp 

kann 
approximability np complete optimization problems 
ph thesis department numerical analysis computing science 
royal institute technology stockholm sweden 
karger motwani 
approximating longest path graph 
proceedings third workshop algorithms data structures pp 

khanna motwani sudan vazirani 
syntactic versus computational views approximability 
proceedings th annual ieee symposium foundations computer science pp 

khanna motwani vishwanathan 
approximating max snp problems semi definite programming 
preparation 
kolaitis thakur 
approximation properties np minimization classes 
comput 
system sci pp 

lund yannakakis 
hardness approximating minimization problems 
acm pp 

ranjan 
quantifiers approximation 
theoretical computer science pp 

papadimitriou yannakakis 
optimization approximation complexity classes 
journal computer system sciences vol 
pp 

papadimitriou yannakakis 
traveling salesman problem distances 
mathematics operations research vol 
pp 

yannakakis 
analysis local search problems heuristics 
proceedings th annual symposium theoretical aspects computer science pp 


