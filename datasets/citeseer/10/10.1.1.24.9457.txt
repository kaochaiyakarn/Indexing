artificial intelligence search algorithms richard korf computer science department university california los angeles los angeles ca 
july search universal problem solving mechanism artificial intelligence ai 
ai problems sequence steps required solution problem known priori determined systematic trial error exploration alternatives 
problems addressed ai search algorithms fall general classes single agent pathfinding problems player games constraint satisfaction problems 
classic examples ai literature pathfinding problems sliding tile puzzles including theta puzzle see fig 
larger relatives theta fifteen puzzle theta puzzle 
puzzle consists theta square frame containing numbered square tiles empty position called blank 
legal operators slide tile horizontally vertically adjacent blank blank position 
problem rearrange tiles random initial configuration particular desired goal configuration 
supported part nsf iri rockwell international 
sliding tile puzzles common testbeds research ai search algorithms simple represent manipulate finding optimal solutions theta generalization sliding tile puzzles np complete 
known examples single agent pathfinding problems include rubik cube travelling salesman problem theorem proving 
case task find sequence operations map initial state goal state 
second class search problems include player perfect information games chess checkers othello 
third category constraint satisfaction problems queens problem 
task place queens theta chessboard queens row column diagonal 
describing problem space model search algorithms 
searches considered including breadth uniform cost depth depth iterative deepening bidirectional search 
various heuristic searches examined including pure heuristic search algorithm iterative deepening depth branch bound heuristic path algorithm recursive best search 
consider single agent algorithms interleave search execution including lookahead search real time learning real time 
consider player game searches including minimax alpha beta pruning 
examine constraint satisfaction algorithms backtracking constraint recording heuristic repair 
efficiency algorithms terms costs solutions generate amount time algorithms take execute amount computer memory require central concern 
search universal problem solving method limits applicability efficiency performed 
problem space model problem space environment search takes place 
problem space consists set states problem set operators change state 
example puzzle states different possible permutations tiles operators slide tile blank position 
problem instance problem space initial state goal state 
case puzzle initial state initial permutation puzzle starts goal state particular desired permutation 
problem solving task find sequence operators map initial state goal state 
puzzle goal state explicitly 
problems queens problem goal state explicitly implicitly specified certain properties satisfied goal state 
problem space graph represent problem space 
states space represented nodes graph operators edges nodes 
edges may undirected directed depending corresponding operators invertible 
task single agent path problem find path graph initial node goal node 
shows small part puzzle problem space graph 
problem spaces correspond graphs path pair nodes simplicity represented trees initial state root tree 
cost simplification state reached different paths represented duplicate nodes increasing size tree 
benefit tree absence cycles greatly simplifies search algorithms 
survey restrict attention trees exist graph versions algorithms describe 
feature distinguishes ai search algorithms graph searching algorithms size graphs involved 
example entire chess graph estimated contain puzzle search tree fragment nodes 
simple problem puzzle contains nodes 
result problem space graphs ai problems represented explicitly listing state implicitly represented specifying initial state set operators generate new states existing states 
furthermore size ai problem rarely expressed number nodes problem space graph 
parameters search tree determine efficiency various search algorithms branching factor solution depth 
branching factor average number children node 
example puzzle average branching factor 
solution depth problem instance length shortest path initial state goal state length shortest sequence operators solves problem 
goal bottom row depth problem instance represented initial state root moves 
brute force search general search algorithms brute force searches require domainspecific knowledge 
required brute force search state description set legal operators initial state description goal state 
important techniques breadth uniform cost depth depth iterative deepening bidirectional search 
descriptions algorithms generate node means create data structure corresponding node expand node means generate children node 
breadth search breadth search expands nodes order distance root generating level tree time solution see 
easily implemented maintaining queue nodes initially containing just root removing node head queue expanding adding children tail queue 
generates node tree nodes shallower levels generated breadth search finds shortest path goal 
amount time breadth search proportional number nodes generated node generated constant time function branching factor solution depth number nodes level total number nodes generated worst case delta delta delta asymptotic time complexity breadth search 
order node generation breadth search main drawback breadth search memory requirement 
level tree saved order generate level amount memory proportional number nodes stored space complexity breadth search 
result breadth search severely space bound practice exhaust memory available typical computers matter minutes 
uniform cost search edges cost breadth search generalizes uniform cost search 
expanding nodes order depth root uniform cost search expands nodes order cost root 
step node expanded cost lowest sum edge costs root node nodes stored priority queue 
algorithm known dijkstra single source shortest path algorithm 
node chosen expansion uniform cost search lowest cost path node 
worst case time complexity uniform cost search cost optimal solution minimum edge cost 
unfortunately suffers memory limitation breadth search 
depth search depth search remedies space limitation breadth search generating child deepest unexpanded node see 
algorithms implemented list unexpanded nodes difference breadth search manages list queue depth search treats list stack 
commonly depth search implemented recursively recursion stack place explicit node stack 
order node generation depth search advantage depth search space requirement linear search depth opposed exponential breadth search 
reason algorithm needs store stack nodes path root current node 
time complexity depth search depth generates set nodes breadth search simply different order 
practical matter depth search time limited space limited 
disadvantage depth search may terminate infinite tree simply go left path forever 
finite graph generate infinite tree 
usual solution problem impose cutoff depth search 
ideal cutoff solution depth value rarely known advance solving problem 
chosen cutoff depth algorithm fail find solution cutoff depth greater large price paid execution time solution may optimal 
depth iterative deepening depth iterative deepening combines best features breadth depth search 
performs depth search depth starts executing complete depth search depth continues run depth searches successively greater depths solution see 
generates node shallower nodes generated solution guaranteed shortest path 
furthermore point executing depth search saving stack nodes algorithm terminates finds solution depth space complexity 
appears wastes great deal time iterations prior finds solution extra usually insignificant 
see note number order node generation depth iterative deepening search nodes depth nodes generated final iteration 
number nodes depth gamma gamma generated twice final iteration penultimate iteration 
general number nodes generated gamma gamma delta delta delta db 
asymptotically strictly greater large values lower order terms insignificant 
words goes final iteration cost previous iterations relatively small 
ratio number nodes generated generated breadth search tree approximately gamma 
fact asymptotically optimal terms time space brute force shortest path algorithms tree 
edge costs differ run iterative deepening version uniform cost search depth cutoff replaced cutoff cost node 
iteration new threshold minimum cost nodes generated pruned previous iteration 
graph cycles breadth search may efficient depth search 
reason breadth search check duplicate nodes depth search 
complexity breadth search grows number nodes depth complexity depth search depends number paths length 
example square grid number nodes radius origin number paths length children node counting parent 
graph large number short cycles breadth search preferable depth search sufficient memory available 
approach problem duplicate nodes depth search see 
bidirectional search bidirectional search brute force algorithm requires explicit goal state addition basic problem space 
main idea simultaneously search forward initial state backward goal state search frontiers meet 
path initial state concatenated inverse path goal state form complete solution path 
bidirectional search guarantees optimal solutions 
assuming comparisons identifying common state frontiers done constant time node hashing example time complexity bidirectional search search need proceed half solution depth 
searches breadth order find common state space complexity bidirectional search 
result bidirectional search space bound practice 
combinatorial explosion problem brute force search algorithms time complexities grow exponentially problem size 
called combinatorial explosion result size problems solved techniques quite limited 
example puzzle states easily solved brute force search fifteen puzzle contains states solved brute force techniques current machines 
faster machines significant impact problem 
example theta puzzle contains states 
heuristic search order solve larger problems domain specific knowledge added improve search efficiency 
ai heuristic search general meaning specialized technical meaning 
general sense term heuristic advice effective isn guaranteed case 
heuristic search literature term heuristic usually refers special case heuristic evaluation function 
heuristic evaluation functions single agent path finding problem heuristic evaluation function estimates cost optimal path pair states 
example euclidean airline distance estimate highway distance pair locations 
common heuristic function sliding tile puzzles called manhattan distance 
computed counting number moves grid tile displaced goal position summing values tiles 
fixed goal state heuristic evaluation function node estimates distance node goal state 
key properties heuristic evaluation function estimate actual cost inexpensive compute 
example euclidean distance pair points computed constant time 
manhattan distance pair states computed time proportional number tiles 
addition naturally occurring heuristic functions lower bounds actual cost property referred admissibility 
example airline distance lower bound road distance points shortest path pair points straight line 
similarly manhattan distance lower bound actual number moves necessary solve instance sliding tile puzzle tile move times distance grid units goal position 
number algorithms heuristic functions including pure heuristic search algorithm iterative deepening depth branch bound heuristic path algorithm 
addition heuristic information employed bidirectional search 
pure heuristic search simplest algorithms pure heuristic search expands nodes order heuristic values 
maintains closed list nodes expanded open list nodes generated expanded 
algorithm begins just initial state open list 
cycle node open list minimum value expanded generating children placed closed list 
heuristic function applied children placed open list order heuristic values 
algorithm continues goal state chosen expansion 
graph cycles multiple paths node path may shortest 
shorter path open node shorter path saved longer discarded 
shorter path closed node node moved open shorter path associated 
main drawback pure heuristic search ignores cost path far node find optimal solutions 
breadth search uniform cost search pure heuristic search special cases general algorithm called best search 
differ cost functions depth node breadth search uniform cost search pure heuristic search 
algorithm algorithm combines features uniform cost search pure heuristic search efficiently compute optimal solutions 
best search cost associated node cost path initial state node heuristic estimate cost path node goal 
estimates lowest total cost solution path going node point node lowest value chosen expansion 
ties nodes equal value broken favor nodes lower values 
algorithm terminates goal node chosen expansion 
finds optimal path goal heuristic function admissible meaning overestimates actual cost 
example airline distance overestimates actual highway distance manhattan distance overestimates actual moves sliding tile puzzles evaluation functions find optimal solutions problems 
addition efficient heuristic function sense shortest path algorithms heuristic function expands fewest number nodes 
main drawback best search memory requirement 
entire open list saved severely space limited practice practical breadth search current machines 
example run successfully puzzle exhausts available memory matter minutes fifteen puzzle 
iterative deepening just depth iterative deepening solved space problem breadth search ida eliminates memory constraint sacrificing solution optimality 
iteration algorithm complete depth search keeps track cost node generated 
soon node generated cost exceeds threshold iteration path cut search backtracks continuing 
cost threshold initialized heuristic estimate initial state successive iteration increased total cost lowest cost node pruned previous iteration 
algorithm terminates goal state reached total cost exceed current threshold 
ida performs series depth searches memory requirement linear maximum search depth 
addition heuristic function admissible solution ida optimal 
argument similar ida expands number nodes asymptotically tree provided number nodes grows exponentially solution cost 
facts optimality imply ida asymptotically optimal time space heuristic search algorithms find optimal solutions tree 
additional benefits ida easier implement runs faster incur overhead managing open closed lists 
depth branch bound problems maximum search depth known advance search tree finite 
example consider travelling salesman problem tsp visiting set cities returning starting city tour shortest total distance 
natural problem space problem consists tree root node represents starting city nodes level represent cities visited nodes level represent cites visited second tree maximum depth number cities candidate solutions occur depth 
space simple depth search guarantees finding optimal solution space linear number cities 
idea depth branch bound search efficient keeping track lowest cost solution far 
cost partial tour sum costs edges travelled far partial tour cost equals exceeds cost best complete tour far branch representing partial tour pruned descendents equal greater cost 
lower cost complete tour cost best tour updated lower cost 
addition admissible heuristic function cost minimum spanning tree remaining unvisited cities added cost far partial tour increase amount pruning 
carefully ordering children node smallest largest estimated total cost lower cost solution quickly improving pruning efficiency 
interestingly ida exhibit complementary behavior 
guaranteed return optimal solution linear space assuming cost functions admissible 
ida cost threshold lower bound optimal solution cost increases iteration reaches optimal cost 
cost best solution far upper bound optimal solution cost decreases reaches optimal cost 
ida expands nodes cost exceeds optimal cost overhead consists expanding nodes 
expands node overhead consists expanding nodes costs exceed optimal cost 
problems search trees bounded depth easy construct solution tsp usually algorithm choice finding optimal solution 
problems infinite search trees difficult construct low cost solution sliding tile puzzles rubik cube ida usually best choice 
complexity finding optimal solutions time complexity heuristic search algorithm depends accuracy heuristic function 
example heuristic evaluation function exact estimator runs linear time expanding nodes optimal solution path 
conversely heuristic returns zero uniform cost search exponential complexity 
general time complexity ida exponential function error heuristic function 
example heuristic constant absolute error meaning underestimates constant amount regardless magnitude estimate running time linear solution cost 
realistic assumption constant relative error means error fixed percentage quantity estimated 
case running times ida exponential 
base exponent smaller brute force branching factor reducing asymptotic complexity allowing somewhat larger problems solved 
example manhattan distance heuristic ida optimally solve random instances fifteen puzzle 
heuristic path algorithm complexity finding optimal solutions problems generally exponential practice order solve significantly larger problems optimality requirement relaxed 
early approach problem heuristic path algorithm hpa 
hpa best search algorithms merit node gamma 
varying produces range algorithms uniform cost search pure heuristic search 
increasing generally decreases amount computation increasing cost solution generated 
tradeoff quite favorable small increases solution cost yielding huge savings computation 
furthermore shown solutions algorithm guaranteed factor gamma greater optimal significantly better 
recursive best search memory limitation heuristic path algorithm overcome simply replacing best search ida weighted evaluation function 
ida longer best search total cost child parent nodes necessarily expanded best order 
alternative algorithm recursive best search rbfs 
rbfs best search runs space linear maximum search depth regardless cost function 
admissible cost function rbfs generates fewer nodes ida generally superior ida small increase cost node generation 
works maintaining recursion stack complete path current node expanded immediate siblings nodes path cost best node subtree explored sibling 
cost current node exceeds node previously expanded portion tree algorithm backs deepest common ancestor continues search new path 
effect algorithm maintains separate threshold subtree diverging current search path 
see full details rbfs 
interleaving search execution discussion assumed complete solution computed step solution need executed 
contrast situation player games discussed computational limits uncertainty due opponent moves search execution interleaved search determining move 
paradigm applicable single agent problems 
case autonomous vehicle navigation example information limited horizon vehicle sensors physically move acquire information 
move computed time move executed computing 
consider algorithms designed scenario 
search search determines individual single agent moves constant time move 
algorithm searches forward current state fixed depth determined informational computational resources available 
search horizon evaluation function applied frontier nodes 
decisions single agent value interior node minimum frontier values subtree node 
single move neighbor current state minimum value 
heuristic functions obey triangle inequality characteristic distance measures 
result guaranteed monotonically nondecreasing path 
furthermore search fixed depth limit apply depth branch bound prune search tree 
performance improvement due branch bound quite dramatic cases extending achievable search horizon factor relative brute force search sliding tile puzzles 
search branch bound algorithm evaluating immediate neighbors current node 
run best child identified point chosen move executed real world 
view static evaluation function combined lookahead search simply accurate computationally expensive heuristic function 
fact provides entire spectrum heuristic functions trading accuracy cost depending search horizon 
real time simply repeating search move ignores information previous searches results infinite loops 
addition actions committed limited information best move may undo previous move 
principle rationality backtracking occur estimated cost continuing current path exceeds cost going back previous state plus estimated cost reaching goal state 
real time rta implements policy constant time move 
move value neighbor current state computed cost edge current state neighbor initial state 
problem solver moves neighbor minimum value stores previous state best value remaining neighbors 
represents value previous state perspective new current state 
repeated goal reached 
determine value previously visited state stored value new state heuristic evaluator called 
note heuristic evaluator may employ lookahead search branch bound 
finite problem space exists path goal state rta guaranteed eventually find solution regardless heuristic evaluation function 
furthermore tree rta locally optimal decisions information seen far 
learning real time problem solved repeatedly goal state different initial states algorithm improves performance time 
learning real time lrta algorithm 
behaves identically rta storing second best value node new heuristic value stores best value 
problem instance solved stored heuristic values saved initial values problem instance 
lrta efficient rta solving single problem instance assuming starts admissible initial heuristic values repeated trials heuristic values eventually converge exact values 
point algorithm returns optimal solutions 
player games second major application heuristic search algorithms ai player games 
original challenges ai fact predates term artificial intelligence build program play chess level best human players 
minimax search standard algorithm player games minimax search heuristic static evaluation 
algorithm searches forward fixed depth game tree limited amount time available move 
search horizon heuristic function applied frontier nodes 
case heuristic evaluation function takes board position returns number indicates favorable position player relative 
example simple heuristic evaluator chess count total number pieces board player appropriately weighted relative strength subtract weighted sum opponent pieces 
large positive values correspond strong positions player called max large negative values represent advantageous situations opponent called min 
heuristic evaluations frontier nodes values interior nodes tree recursively computed minimax rule 
value node max turn move maximum values children value node min move minimum values children 
alternate levels tree minimum maximum values children backed 
continues values immediate children current position computed point move child maximum minimum value depending turn move 
alpha beta pruning elegant ai search algorithms alpha beta pruning 
apparently john mccarthy came original idea didn publish 
appeared print mit tech report thorough treatment algorithm 
idea similar branch bound minimax value root game tree determined examining nodes search frontier 
shows example alpha beta pruning 
labelled nodes generated algorithm heavy black lines indicating pruning 
square nodes max move circular nodes min turn 
search proceeds depth minimize memory required evaluates node necessary 
nodes statically evaluated respectively minimum value backed parent node node evaluated value parent node equal minimum unknown value right child 
label node 
value node maximum value equal 
determined minimax value node need evaluate generate brother node similarly statically evaluating nodes respectively backed value parent node minimum values 
tells minimax value node greater equal maximum unknown value right child 
value node minimum value greater equal achieve cutoff 
right half tree shows example deep pruning 
evaluating left half tree know value root node greater equal minimax value node node evaluated value parent node equal 
value root greater equal value node propagate root need generate brother node similar situation exists evaluation node 
point value node equal value node equal value node maximum values nodes equal 
furthermore value node alpha beta pruning minimum value node brother node value equal value node equal 
causes brother node pruned value root node greater equal 
computed minimax value root tree generating sixteen leaf nodes case 
alpha beta pruning performs minimax search pruning tree effect allow deeper search amount computation 
raises question alpha beta improve performance 
best way characterize efficiency pruning algorithm terms effective branching factor 
effective branching factor th root number frontier nodes evaluated search depth efficiency alpha beta pruning depends order nodes encountered search frontier 
set frontier node values exists ordering values alpha beta perform cutoffs 
case frontier nodes evaluated effective branching factor brute force branching factor 
hand optimal perfect ordering possible cutoff realized 
case effective branching factor reduced square root brute force branching factor 
way viewing perfect ordering case amount computation search twice deep alpha beta pruning 
search tree grows exponentially depth doubling search horizon dramatic improvement 
worst possible ordering perfect ordering random ordering average case 
random ordering frontier nodes alpha beta pruning reduces effective branching factor approximately 
means search deep alpha beta yielding improvement search depth 
node ordering quiescence iterative deepening transposition tables practice effective branching factor alpha beta closer best case due node ordering 
idea node ordering generating tree left right reorder tree static evaluations interior nodes 
words children max nodes expanded decreasing order static values children min nodes expanded increasing order static values 
important ideas quiescence iterative deepening 
idea quiescence static evaluator applied positions values unstable occurring middle piece trade 
positions small secondary search conducted static evaluation stable 
practice achieved exploring capture moves level deeper 
iterative deepening solve problem set search horizon fact memory saving device single agent search 
tournament game limited amount time allowed moves 
unfortunately difficult accurately predict long take perform alpha beta search depth 
solution perform series searches successively greater depths 
time runs move recommended completed search 
search graphs games chess contain multiple paths node reached making moves different order referred transposition moves 
alpha beta depth search important detect node searched order avoid researching 
transposition table table previously encountered game states backed minimax values 
new state generated stored transposition table value searching tree node 
virtually player game programs full width fixed depth alpha beta minimax search node ordering quiescence iterative deepening transposition tables techniques 
special purpose hardware basic algorithms described performance advances computer chess come faster hardware 
faster machine deeper search time available better plays 
despite rapidly advancing speed general purpose computers best machines today special purpose hardware designed built play chess 
example chess machine evaluate chess positions second 
lost game tournament gary kasparov world champion win game draw 
constraint satisfaction problems addition single agent path finding problems player games third major application heuristic search constraint satisfaction problems 
queens problem mentioned previously classic example 
examples include graph coloring boolean satisfiability scheduling problems 
constraint satisfaction problems modelled follows set variables set values variable set constraints values variables assigned 
unary constraint variable specifies subset possible values assigned variable 
binary constraint variables specifies possible combinations assignments pair variables satisfy constraint 
example map graph coloring problem variables represent regions nodes values represent colors 
constraints binary constraints pair adjacent regions nodes prohibit assigned color 
brute force backtracking brute force approach constraint satisfaction called backtracking 
selects order variables order values starts assigning values variables time 
assignment constraints involving variables assigned satisfied 
reason constraint violated assignment remaining variables possibly constraint 
variable reached remaining legal assignments variable assigned reassigned legal value 
algorithm continues complete consistent assignment resulting success possible assignments shown violate constraint resulting failure 
shows tree generated brute force backtracking find solutions queens problem 
tree searched depth minimize memory requirements 
limited discrepancy search limited discrepancy search lds completely general tree search algorithm useful context constraint satisfaction problems entire tree large search exhaustively :10.1.1.34.2426
case search subset tree yield solution time available 
assume heuristically order binary tree node left branch lead solution right branch 
lds proceeds series depth iterations 
iteration explores just left path tree 
second iteration explores root leaf paths exactly right branch discrepancy 
general iteration explores paths exactly discrepancies ranging zero depth tree 
iteration explores just rightmost branch 
certain assumptions show lds find solution sooner strict left right depth search 
intelligent backtracking improve performance brute force backtracking number techniques variable ordering value ordering backjumping forward checking 
order variables instantiated large effect size search tree 
tree generated solve queens problem idea variable ordering order variables constrained constrained 
example variable single value remaining consistent previously instantiated variables assigned value immediately 
general variables instantiated increasing order size remaining domains 
done statically search dynamically reordering remaining variables time variable assigned new value 
order values variable chosen determines order tree searched 
doesn effect size tree difference solutions 
single solution required value ordering decrease time required find solution 
general order values constraining constraining order minimize time required find solution 
important idea originally called backjumping reached simply undoing decision decision caused failure modified 
example consider variable problem variables instantiated order assume values chosen possible values conflict value chosen pure backtracking value chosen changed possible values tested avail 
better strategy case go back source failure change value trying different values variable assigned value idea forward checking check remaining uninstantiated variable sure assignment consistent previous assignments 
original variable assigned value 
constraint recording constraint satisfaction problem constraints explicitly specified implied explicit constraints 
implicit constraints may discovered backtracking search advance preprocessing phase 
idea constraint recording implicit constraints discovered saved explicitly don rediscovered 
simple example constraint recording preprocessing phase called arc consistency 
pair variables related binary constraint remove domain values corresponding consistent assignment vice versa 
general iterations may required achieve complete arc consistency 
path consistency generalization arc consistency considering pairs variables examine triples constrained variables 
effect performing arc path consistency backtracking resulting search space dramatically reduced 
cases preprocessing constraints eliminate need search entirely 
heuristic repair backtracking searches space consistent partial assignments variables sense constraints instantiated variables satisfied looking complete consistent assignment variables words solution 
alternative approach search space inconsistent complete assignments variables consistent complete assignment 
approach known heuristic repair :10.1.1.31.8372
example queens problem amounts placing queens board time moving queens time solution 
natural heuristic called min conflicts move queen conflict queens move position conflicts fewest queens 
surprising simple strategy performs relative backtracking 
backtracking techniques solve order queen problems heuristic repair solve queen problems individual queen moves 
strategy extensively explored context boolean satisfiability referred gsat :10.1.1.34.6853
gsat satisfy difficult formulas variables best backtracking approach davis putnam algorithm unit propagation difficult variables 
main drawback approach complete guaranteed find solution finite amount time exists 
solution algorithms run forever backtracking eventually discover problem solvable 
constraint satisfaction problems appear somewhat different single agent path finding problems player games strong similarity algorithms employed 
example backtracking viewed form branch bound node pruned constraint violated 
similarly heuristic repair viewed heuristic search evaluation function total number constraints violated goal find state zero constraint violations 
research issues summary research issues primary research problem area development faster algorithms 
algorithms limited efficiency size problems solve optimally quality decisions solutions compute practical computational limits 
continual demand faster algorithms 
related research area development space efficient algorithms 
algorithms clearly impractical linear space algorithms little memory available current machines 
primary issue fixed amount memory best speed search possible 
player game search extra memory primarily transposition table 
single agent path finding problems effective uses additional memory form bidirectional search known perimeter search 
idea search breadth backward goal state memory nearly exhausted 
forward search proceeds encounters state perimeter backward search 
main advantage approach nodes perimeter refine heuristic estimates forward search 
research area development parallel search algorithms 
search algorithms tremendous amount potential parallelism basic step node generation evaluation performed billions times 
result algorithms readily parallelized nearly linear speedups 
algorithms difficult parallelize branchand bound algorithms alpha beta pruning results searching part tree determine part tree needs examined 
performance search algorithm depends critically quality heuristic evaluation function important research area automatic generation functions 
pioneered area player games arthur samuel landmark checkers program learned improve evaluation function repeated play 
area problems dominant theory exact cost solution simplified version problem admissible heuristic evaluation function original problem 
example sliding tile puzzles remove constraint tile slid blank position tile moved adjacent position time 
optimal number moves required solve simplified version problem manhattan distance admissible heuristic original problem 
automating approach research problem 
important research area development selective search algorithms player games 
despite fact evaluate chess positions second lost gary kasparov mere human 
obviously humans selective choices positions examine 
development alternatives full width fixed depth minimax search active area research 
see example selective search algorithm pointers area 
summary described search algorithms different classes problems 
path finding problem task find sequence operators map initial state desired goal state 
area focussed finding optimal solutions problems making admissible heuristic functions speed search sacrificing optimality 
second area player games finding optimal solutions infeasible research focussed algorithms making best move decision possible limited amount computing time 
approach applied single agent problems 
third class problems constraint satisfaction problems task find state satisfies set constraints 
types problems different set ideas brute force searches heuristic evaluation functions applied 
defining terms admissible heuristic said admissible overestimates actual distance state goal 
algorithm said admissible finds optimal solution problem exists 
branching factor average number children node problem space graph 
constraint satisfaction problem problem task identify state satisfies set constraints 
depth length shortest path initial state goal state 
heuristic evaluation function function state number 
single agent problem estimates distance state goal 
player game estimates merit position respect player 
node expansion generating children state 
node generation creating data structure corresponds problem state 
operator action maps state state twist rubik cube 
problem instance problem space initial state problem desired set goal states 
problem space theoretical construct search takes place consisting set states set operators 
problem space graph graphical representation problem space states represented nodes operators represented edges 
search trial error exploration alternative solutions problem systematic 
search tree problem space graph cycles 
single agent path finding problem problem task find sequence operators map initial state goal state 
state configuration problem arrangement parts rubik cube point time 
search methods artificial intelligence academic press london 
davis putnam computing procedure quantification theory journal association computing machinery vol 
pp 

davis gregor wang advantages depth breadth components heuristic search methodologies intelligent systems ras saitta eds north holland amsterdam pp 

dechter pearl generalized best search strategies optimality journal association computing machinery vol 
july pp 

dechter pearl 
network heuristics constraint satisfaction problems artificial intelligence vol 
pp 

dijkstra note problems connexion graphs numerische mathematik 
nelson perimeter search artificial intelligence vol 
jan pp 

doran michie experiments graph program proceedings royal society vol pp 

freuder 
sufficient condition backtrack free search 
assoc 
comput 
mach 
gaschnig performance measurement analysis certain search algorithms ph thesis 
department computer science carnegie mellon univ pittsburgh pa 
haralick elliott increasing tree search efficiency constraint satisfaction problems artificial intelligence vol 
pp 

hart edwards alpha beta heuristic artificial intelligence project memo massachusetts institute technology cambridge mass october 
hart nilsson raphael formal basis heuristic determination minimum cost paths ieee transactions systems science cybernetics vol 
pp 

harvey ginsberg limited discrepancy search proceedings international joint conference artificial intelligence ijcai montreal canada aug pp 

limited memory heuristic search appear proceedings fourteenth international joint conference artificial intelligence ijcai montreal canada aug 
kanal kumar eds search artificial intelligence springer verlag new york 
keene jacobs man machine acm chess challenge kasparov ibm deep blue enterprises sussex 
korf depth iterative deepening optimal admissible tree search artificial intelligence vol 
pp 

korf search ai survey results exploring artificial intelligence shrobe ed morgan kaufmann los altos ca 

korf real time heuristic search artificial intelligence vol 
march pp 

korf search revised version encyclopedia artificial intelligence second edition john wiley new york pp 

korf linear space best search artificial intelligence vol 
july pp 

korf space efficient search algorithms computing surveys vol 
sept pp 

korf chickering best minimax search appear artificial intelligence 
korf improved limited discrepancy search appear proceedings thirteenth national conference artificial intelligence aaai portland aug 
knuth moore analysis alpha beta pruning artificial intelligence vol 
pp 

mackworth consistency networks relations 
artificial intelligence vol 
pp 

manzini improved perimeter search algorithm artificial intelligence vol 
june pp 

minton johnston philips laird minimizing conflicts heuristic repair method constraint satisfaction scheduling problems artificial intelligence vol :10.1.1.31.8372
december pp 

montanari networks constraints fundamental properties applications picture processing information science vol 
pp 

newell simon human problem solving prentice hall englewood cliffs 
pearl solution branching factor alpha beta pruning algorithm optimality communications association computing machinery vol 
pp 

pearl heuristics addison wesley reading ma 
pearl korf search techniques annual review computer science vol 
annual reviews palo alto ca 
pohl results effect error heuristic search machine intelligence meltzer michie eds american elsevier new york pp 

pohl heuristic search viewed path finding graph artificial intelligence vol 
pp 

pohl bi directional search machine intelligence meltzer michie eds american elsevier new york pp 

prieditis machine discovery effective admissible heuristics machine learning vol 
pp 

purdom 
search rearrangement backtracking polynomial average time 
artif 
intell 
ratner warmuth finding shortest solution nxn extension puzzle intractable proceedings fifth national conference artificial intelligence aaai philadelphia pa 
samuel studies machine learning game checkers computers thought feigenbaum feldman eds mcgraw hill new york pp 

selman levesque mitchell new method solving hard satisfiability problems proceedings tenth national conference artificial intelligence aaai san jose ca july pp :10.1.1.34.6853

shannon programming computer playing chess philosophical magazine vol 
pp 

slate atkin chess northwestern university chess program chess skill man machine frey 
ed springer verlag new york pp 

stickel tyson analysis consecutively bounded depth search applications automated deduction proceedings international joint conference artificial intelligence ijcai los angeles ca august 
taylor korf pruning duplicate nodes depth search proceedings national conference artificial intelligence aaai washington july pp 

turing computing machinery intelligence mind vol 
october pp 

computers thought feigenbaum feldman eds mcgraw hill new york 
information classic area 
survey articles include 
material article derived sources 
number papers collected edited volume devoted search 
book length treatment area 
new research area initially appears proceedings national conference artificial intelligence aaai proceedings international joint conference artificial intelligence ijcai 
prominent journals area include artificial intelligence ieee transactions pattern analysis machine intelligence ieee tpami 

